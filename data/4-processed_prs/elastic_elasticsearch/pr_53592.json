{"pr_number": 53592, "pr_title": "Add async_search.submit to HLRC", "pr_createdAt": "2020-03-16T10:54:20Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53592", "timeline": [{"oid": "a147c41b8b1da4a853fdcae748d1e6b301b9131a", "url": "https://github.com/elastic/elasticsearch/commit/a147c41b8b1da4a853fdcae748d1e6b301b9131a", "message": "Add async_search.submit to HLRC\n\nThis commit adds a new AsyncSearchClient to the High Level Rest Client which\ninitially supporst the submitAsyncSearch in its blocking and non-blocking\nflavour. Also adding client side request and response objects and parsing code\nto parse the xContent output of the client side AsyncSearchResponse together\nwith parsing roundtrip tests and a simple roundtrip integration test.\n\nRelates to #49091", "committedDate": "2020-03-16T10:47:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NzUxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393047515", "bodyText": "We should probably not force users to remember to set this to false, although true seems to be the default. I wonder if we shold either\n\nset the value to false automatically for every SearchRequest once it is set for an AsyncSearchRequest\nignore this parameter as request parameter when sending the request\nignore this paramter on the receiving Rest action regardless of how it is set in the client (maybe warn)\nfail on the client side already when validating the request. This would still require the user to always set the property to \"false\" manually", "author": "cbuescher", "createdAt": "2020-03-16T14:07:57Z", "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchRequest searchRequest = new SearchRequest(index);\n+        // TODO either check that in client request validation already or set it automatically?\n+        searchRequest.setCcsMinimizeRoundtrips(false);", "originalCommit": "a147c41b8b1da4a853fdcae748d1e6b301b9131a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5ODA5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393098091", "bodyText": "Can we copy the original SubmitAsyncSearchRequest that creates the SearchRequest internally and sets the default appropriately. We can then add a validation client side if needed or let the server-side validation throw error if users override the ccs option ?", "author": "jimczi", "createdAt": "2020-03-16T15:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NzUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3Nzk2OA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393177968", "bodyText": "Thanks, I didn't see we implicitely set the defaulfs in the server side org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchRequest we should do that on the client side as well then. Also see we're overwriting these properties:\nrequest.setPreFilterShardSize(1);\nrequest.setBatchedReduceSize(5);\nrequest.requestCache(true);\n\nI assume we also want to do that then on the client side as well?", "author": "cbuescher", "createdAt": "2020-03-16T17:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NzUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4NDQ3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393184479", "bodyText": "yes", "author": "jimczi", "createdAt": "2020-03-16T17:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NzUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTQ4OA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393481488", "bodyText": "This can be removed now that we set these values automatically in the ctr ?", "author": "jimczi", "createdAt": "2020-03-17T07:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NzUxNQ=="}], "type": "inlineReview"}, {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2", "url": "https://github.com/elastic/elasticsearch/commit/ebf54280526c314dcd9dbff1782d4ecff54804e2", "message": "iter", "committedDate": "2020-03-16T14:09:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3MzcxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393073711", "bodyText": "Is it required to extend TimedRequest ? What's the advantage of doing so ?", "author": "jimczi", "createdAt": "2020-03-16T14:38:10Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.TimedRequest;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+public class SubmitAsyncSearchRequest extends TimedRequest {", "originalCommit": "ebf54280526c314dcd9dbff1782d4ecff54804e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3OTMyNA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393179324", "bodyText": "It gives \"timeout\" and \"master_timeout\" parameters, but I guess on the submit request they don't make much sense. Removing.", "author": "cbuescher", "createdAt": "2020-03-16T17:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3MzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4NDUzNg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393184536", "bodyText": "+1", "author": "jimczi", "createdAt": "2020-03-16T17:13:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3MzcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NDA3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393074073", "bodyText": "Can you add javadocs for the options ?", "author": "jimczi", "createdAt": "2020-03-16T14:38:44Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.TimedRequest;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+public class SubmitAsyncSearchRequest extends TimedRequest {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    public SubmitAsyncSearchRequest(SearchRequest searchRequest) {\n+        this.searchRequest = searchRequest;\n+}\n+", "originalCommit": "ebf54280526c314dcd9dbff1782d4ecff54804e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NjM1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393076352", "bodyText": "Can we try to avoid this change ? Maybe using a custom parser in the root object parser for the response field ?", "author": "jimczi", "createdAt": "2020-03-16T14:41:48Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchResponse.java", "diffHunk": "@@ -255,8 +255,12 @@ public XContentBuilder innerToXContent(XContentBuilder builder, Params params) t\n     }\n \n     public static SearchResponse fromXContent(XContentParser parser) throws IOException {\n-        ensureExpectedToken(Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        parser.nextToken();", "originalCommit": "ebf54280526c314dcd9dbff1782d4ecff54804e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA4MjQ5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393082492", "bodyText": "I did that at first but found the change in the server object is cleaner. Happy to change to the other solution though, but I think its working around something that we can fix better here.", "author": "cbuescher", "createdAt": "2020-03-16T14:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NjM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5OTY2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393099667", "bodyText": "We can also split into fromXContent and fromXContentFragment, the former would consume the start object and delegate to fromXContentFragment ?", "author": "jimczi", "createdAt": "2020-03-16T15:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NjM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2ODg2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393168861", "bodyText": "We already have innerFromXContent which in an earlier version of this PR I exposed and used from the client side, but then we have to explain that there. I'll change the PR back to that version so you can see the options.", "author": "cbuescher", "createdAt": "2020-03-16T16:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NjM1Mg=="}], "type": "inlineReview"}, {"oid": "0ed46e6165c7b91fa99fac3e26e2af4638ae647c", "url": "https://github.com/elastic/elasticsearch/commit/0ed46e6165c7b91fa99fac3e26e2af4638ae647c", "message": "Change supertype of SubmitAsyncSearchRequest", "committedDate": "2020-03-16T17:08:57Z", "type": "commit"}, {"oid": "701793e47997edd4e61c12352adfe5f21225da6b", "url": "https://github.com/elastic/elasticsearch/commit/701793e47997edd4e61c12352adfe5f21225da6b", "message": "Adding javadoc", "committedDate": "2020-03-16T17:22:06Z", "type": "commit"}, {"oid": "089485bd01819fdc332fa8c3d97a87600bf3fb22", "url": "https://github.com/elastic/elasticsearch/commit/089485bd01819fdc332fa8c3d97a87600bf3fb22", "message": "Overwrite certain SearchRequest paramters on submit request", "committedDate": "2020-03-16T17:52:42Z", "type": "commit"}, {"oid": "87a4f928060b6a239d156859681b36fe56698d53", "url": "https://github.com/elastic/elasticsearch/commit/87a4f928060b6a239d156859681b36fe56698d53", "message": "Change SearchResponse parsing", "committedDate": "2020-03-16T17:59:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MDU1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393480556", "bodyText": "The response is shared with the get api so can you rename like the original AsyncSearchResponse ?", "author": "jimczi", "createdAt": "2020-03-17T07:12:45Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class SubmitAsyncSearchResponse implements ToXContentObject  {", "originalCommit": "87a4f928060b6a239d156859681b36fe56698d53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU0NDU1MA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393544550", "bodyText": "+1. Already did that in a follow up PR but I will also do it here already then.", "author": "cbuescher", "createdAt": "2020-03-17T09:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTA3MA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393481070", "bodyText": "The original request takes the indices to search in the constructor rather than the SearchRequest that is created internally. Can you adapt it to match the behavior of the transport request ?", "author": "jimczi", "createdAt": "2020-03-17T07:14:18Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Create a request to submit an async search.\n+     * Target indices, queries and all other search related options should be set on\n+     * the input {@link SearchRequest}.\n+     * @param searchRequest the actual search request to submit\n+     */\n+    public SubmitAsyncSearchRequest(SearchRequest searchRequest) {", "originalCommit": "87a4f928060b6a239d156859681b36fe56698d53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU2NjcyNw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393566727", "bodyText": "I thought about it but decided against it. The transport requests signature  public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) doesn't allow setting things in the SearchRequest thats constructed internally, like e.g. search_type or routing.\nYou probably would need to do sth. like this on the client side which I find cumbersome:\nSearchSourceBuilder sourceBuilder = new SearchSourceBuilder()....;        \nSubmitAsyncSearchRequest submitRequest = new SubmitAsyncSearchRequest(indices, sourceBuilder);\nsubmitRequest.getSearchRequest().routing(). \n\nI think on the client side its easier for the user to pass in the full SearchRequest rather than having to do things like this. Wdyt?", "author": "cbuescher", "createdAt": "2020-03-17T10:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU4NTI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393585252", "bodyText": "Then maybe we should expose the search request options that we allow to modify directly in the SubmitAsyncSearchRequest and hide the internal searchRequest ? Whatever we do here I'd prefer to have the same signature between hlrc and transport since they should be equivalent.", "author": "jimczi", "createdAt": "2020-03-17T10:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYwNDA4NA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393604084", "bodyText": "here I'd prefer to have the same signature between hlrc and transport since they should be equivalent.\n\nI'm open to adding a bunch of setters to the client side SubmitAsyncSearchRequest but I wonder if its really necessary. Why do the transport and the client side request ctors need to be equivalent? With the transport client gone I only see the transport request used internally, everything else would go through the RestSubmitAsyncSearchAction which handles creating the transport request, or am I missing something? Maybe @javanna has some ideas here as well.", "author": "cbuescher", "createdAt": "2020-03-17T11:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYwOTQ2MA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393609460", "bodyText": "I agree but in an ideal world we'd have a single class here so I prefer if we don't diverge in the hlrc. Exposing the search request directly is tricky since some of the options are not allowed (scroll, ccs) and we change the default internally. Hiding the search request entirely behind direct setters and getters seems safer and would avoid the confusion when building an async search request ?", "author": "jimczi", "createdAt": "2020-03-17T11:25:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTE1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393481151", "bodyText": "++", "author": "jimczi", "createdAt": "2020-03-17T07:14:31Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class SubmitAsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    private SearchResponse searchResponse;\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link SubmitAsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    SubmitAsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<SubmitAsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new SubmitAsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(SubmitAsyncSearchResponse::setId, ID_FIELD);\n+        PARSER.declareObject(SubmitAsyncSearchResponse::setSearchResponse, (p, c) -> SubmitAsyncSearchResponse.parseSearchResponse(p),\n+                RESPONSE_FIELD);\n+        PARSER.declareObject(SubmitAsyncSearchResponse::setFailure, (p, c) -> ElasticsearchException.fromXContent(p), ERROR_FIELD);\n+    }\n+\n+    private static SearchResponse parseSearchResponse(XContentParser p) throws IOException {\n+        // we should be before the opening START_OBJECT of the response\n+        ensureExpectedToken(Token.START_OBJECT, p.currentToken(), p::getTokenLocation);\n+        p.nextToken();\n+        return SearchResponse.innerFromXContent(p);", "originalCommit": "87a4f928060b6a239d156859681b36fe56698d53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "207441dd07eee0b9b0efd474eba1336eb3c24c68", "url": "https://github.com/elastic/elasticsearch/commit/207441dd07eee0b9b0efd474eba1336eb3c24c68", "message": "Merge branch 'master' into async-search-hlrc", "committedDate": "2020-03-17T09:28:36Z", "type": "commit"}, {"oid": "8f708af8bd46b3dc9c6516c9ec04c29c5f85d7af", "url": "https://github.com/elastic/elasticsearch/commit/8f708af8bd46b3dc9c6516c9ec04c29c5f85d7af", "message": "Rename response class", "committedDate": "2020-03-17T09:50:21Z", "type": "commit"}, {"oid": "b7d6f1438d71f47d3c4cede30de6d2447cdf3079", "url": "https://github.com/elastic/elasticsearch/commit/b7d6f1438d71f47d3c4cede30de6d2447cdf3079", "message": "Don't set CcsMinimizeRountrips in test", "committedDate": "2020-03-17T09:54:36Z", "type": "commit"}, {"oid": "68baeb933103cf574345295f661493cdaa4cf1c6", "url": "https://github.com/elastic/elasticsearch/commit/68baeb933103cf574345295f661493cdaa4cf1c6", "message": "Use setCleanOnCompletion(false) in AsyncSearchIT to always get an ID back", "committedDate": "2020-03-17T10:18:15Z", "type": "commit"}, {"oid": "94083b6e6b5585d92c3960be5dbdc4de54b22362", "url": "https://github.com/elastic/elasticsearch/commit/94083b6e6b5585d92c3960be5dbdc4de54b22362", "message": "Change ctor of SubmitAsyncSearchRequest", "committedDate": "2020-03-17T14:58:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc0OTEyOA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393749128", "bodyText": "We should also expose batchedReduceSize since that's the option to use to change the granularity of the progress ?", "author": "jimczi", "createdAt": "2020-03-17T15:07:47Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {\n+        return searchRequest;\n+    }\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void routing(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void routing(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void preference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void indicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void searchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void allowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+", "originalCommit": "94083b6e6b5585d92c3960be5dbdc4de54b22362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxNDI5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393814297", "bodyText": "Sure, I didn't add that because we implicitely set it to 5 in the ctor now, so thought its something we don't want the user to set.\nWhat about PreFilterShardSize and requestCache then, those I also didn't add since we set them to fixed values internally?", "author": "cbuescher", "createdAt": "2020-03-17T16:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc0OTEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2MzEyMg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393863122", "bodyText": "I would expose batchedReduceSize and requestCache only, preFilterShardSize is not necessary imo (we want to always run the can_match phase in async search).", "author": "jimczi", "createdAt": "2020-03-17T17:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc0OTEyOA=="}], "type": "inlineReview"}, {"oid": "07966510b30766367b80c0ead730a83b293afc9f", "url": "https://github.com/elastic/elasticsearch/commit/07966510b30766367b80c0ead730a83b293afc9f", "message": "Merge branch 'master' into async-search-hlrc", "committedDate": "2020-03-17T15:24:17Z", "type": "commit"}, {"oid": "310fdee51c59a7d28eb2b4e7d3627767969161a9", "url": "https://github.com/elastic/elasticsearch/commit/310fdee51c59a7d28eb2b4e7d3627767969161a9", "message": "Add request validation and tests", "committedDate": "2020-03-17T17:33:07Z", "type": "commit"}, {"oid": "7e02579a94fa48bade62a04d565d2b5f38f457aa", "url": "https://github.com/elastic/elasticsearch/commit/7e02579a94fa48bade62a04d565d2b5f38f457aa", "message": "iter on failing test", "committedDate": "2020-03-17T18:16:07Z", "type": "commit"}, {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb", "url": "https://github.com/elastic/elasticsearch/commit/c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb", "message": "Expose batchedReduceSize and batchedReduceSize on submit request", "committedDate": "2020-03-17T18:37:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyOTQ2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394229465", "bodyText": "I wonder if we need to expose this async async method. Is there a reason why people would call an async API asynchronously?", "author": "javanna", "createdAt": "2020-03-18T10:02:57Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.client.asyncsearch.AsyncSearchResponse;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.emptySet;\n+\n+public class AsyncSearchClient {\n+    private final RestHighLevelClient restHighLevelClient;\n+\n+    AsyncSearchClient(RestHighLevelClient restHighLevelClient) {\n+        this.restHighLevelClient = restHighLevelClient;\n+    }\n+\n+    // TODO add docs url\n+    /**\n+     * Submit a new async search request.\n+     * See <a href=\"todo\"> the docs</a> for more.\n+     * @param request the request\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @return the response\n+     * @throws IOException in case there is a problem sending the request or parsing back the response\n+     */\n+    public AsyncSearchResponse submitAsyncSearch(SubmitAsyncSearchRequest request, RequestOptions options) throws IOException {\n+        return restHighLevelClient.performRequestAndParseEntity(request, AsyncSearchRequestConverters::submitAsyncSearch, options,\n+                AsyncSearchResponse::fromXContent, emptySet());\n+    }\n+\n+    // TODO add docs url\n+    /**\n+     * Asynchronously submit a new async search request.\n+     * See <a href=\"todo\"> the docs</a> for more.\n+     * <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-ilm-ilm-get-lifecycle-policy.html\">\n+     * the docs</a> for more.\n+     * @param request the request\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @param listener the listener to be notified upon request completion\n+     * @return cancellable that may be used to cancel the request\n+     */\n+    public Cancellable submitAsyncSearchAsync(SubmitAsyncSearchRequest request, RequestOptions options,", "originalCommit": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMzODkwMw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394338903", "bodyText": "Please correct me, but as far as I understand it, this is not about the asynchronism of the search request, but the submit request itself. While the _async_search request controlls when and whether it returns by waitForCompletion / keepAlive, this method allows using a listener for wait for the response instead of blocking. So say, a user sends and \"_async_search\" with waitForCompletion=10s because thats how long its okay for the search to initially take with the first responses, but wants the client call to return immediately nevertheless? I think having this method also makes sense in terms of consistency of the API with other client methods.", "author": "cbuescher", "createdAt": "2020-03-18T13:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyOTQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM1MTAxOA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394351018", "bodyText": "ok lets leave it.", "author": "javanna", "createdAt": "2020-03-18T13:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyOTQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzNDYxMw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394234613", "bodyText": "good catch, looks like search was not supporting this parameter.", "author": "javanna", "createdAt": "2020-03-18T10:11:44Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RequestConverters.java", "diffHunk": "@@ -403,13 +403,14 @@ static Request search(SearchRequest searchRequest, String searchEndpoint) throws\n         return request;\n     }\n \n-    private static void addSearchRequestParams(Params params, SearchRequest searchRequest) {\n+    static void addSearchRequestParams(Params params, SearchRequest searchRequest) {\n         params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n         params.withRouting(searchRequest.routing());\n         params.withPreference(searchRequest.preference());\n         params.withIndicesOptions(searchRequest.indicesOptions());\n         params.putParam(\"search_type\", searchRequest.searchType().name().toLowerCase(Locale.ROOT));\n         params.putParam(\"ccs_minimize_roundtrips\", Boolean.toString(searchRequest.isCcsMinimizeRoundtrips()));\n+        params.putParam(\"pre_filter_shard_size\", Integer.toString(searchRequest.getPreFilterShardSize()));", "originalCommit": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzNTY0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394235646", "bodyText": "maybe this should be nullable too?", "author": "javanna", "createdAt": "2020-03-18T10:13:18Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    private SearchResponse searchResponse;\n+    private ElasticsearchException error;", "originalCommit": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394238836", "bodyText": "I see that whether or not to expose the inner search request was discussed in previous reviews. I am confused though on what direction was chosen. I see that the getters and setters from the search request are copied to the async request, but the inner search request is still exposed through this getter and can be modified directly. Didn't we want to rather hide it from users?", "author": "javanna", "createdAt": "2020-03-18T10:18:25Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "originalCommit": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0MDkyMw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394340923", "bodyText": "+1 to hide", "author": "jimczi", "createdAt": "2020-03-18T13:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM1MzE0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394353141", "bodyText": "Okay, I will look into that. Will make testing a bit more awkward though because I can't reuse some existing infra then.", "author": "cbuescher", "createdAt": "2020-03-18T13:40:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM5MzM2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394393363", "bodyText": "package protected ? ;)", "author": "jimczi", "createdAt": "2020-03-18T14:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQyODY5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394428695", "bodyText": "Would work but then I need to move some classes around. I'd prefer that to adding all those getters to the submit request.", "author": "cbuescher", "createdAt": "2020-03-18T15:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzODA4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394438087", "bodyText": "I think that if we can do without the getter, even better. The changes you had to make to remove it don't look so bad. The problem with keeping it package protected is that theoretically some stuff can still be set directly to the search request, then we need to validate parameters that are not even supported.", "author": "javanna", "createdAt": "2020-03-18T15:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3OTgxOA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394479818", "bodyText": "package protected ? ;)\n\nThis is proving to be tricky. I cannot easily move the AsyncSearchRequestConverters out of the org.elasticsearch.client package since they need package private infra from RequestConverters. I can probably move the SubmitAsyncSearchRequest into that package though, will take a look what that would change.", "author": "cbuescher", "createdAt": "2020-03-18T16:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5NTU1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394495551", "bodyText": "I pushed f686a50 which moves the new request and response classes into org.elasticsearch.client to be able to use a package protected getSearchRequest() to avoid all the boilerplate getters on the new request. I'm unsure what I like best, take a look and let me know which direction you are leaning.", "author": "cbuescher", "createdAt": "2020-03-18T16:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUwNTY1NA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394505654", "bodyText": "I  think no getter is  safer. We also do have extra protection on the server side for unsupported values but I think the client should never allow to send unsupported values.", "author": "javanna", "createdAt": "2020-03-18T17:06:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU0MjM5NA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394542394", "bodyText": "I agree with Luca, we should avoid the getter on the search request. However, we should have a getter for all options that we expose so I don't see why you want to avoid them ? If we have a setter, we need to provide a way to access the value.", "author": "jimczi", "createdAt": "2020-03-18T18:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU1NDQ5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394554493", "bodyText": "Ok, I reverted that change back to the one where I removed getSearchRequest and added a bunch of getters.", "author": "cbuescher", "createdAt": "2020-03-18T18:25:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzOTI5OA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394239298", "bodyText": "annoying nit: I see that some getters and setters use the get and set prefix in this class, while others don't. I get why, but shall we unify the style at least throughout this one class?", "author": "javanna", "createdAt": "2020-03-18T10:19:17Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {\n+        return searchRequest;\n+    }\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void routing(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void routing(String... routings) {", "originalCommit": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394245111", "bodyText": "this should work but it's also risky. What other options we have?\n\nincrease the timeout even more to really make sure it's enough, though what is enough\naccept that we may get a response while the search is still running, in which case is_partial and is_final will have a different value? Maybe don't set cleanOnCompletion and assert that when the id is returned the search is running, and when the id is not returned, both flags are false.\n\nI am not sure either way, maybe  I would go for option 1.", "author": "javanna", "createdAt": "2020-03-18T10:29:12Z", "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery());\n+        SubmitAsyncSearchRequest request = new SubmitAsyncSearchRequest(sourceBuilder, index);\n+        // 2 sec should be enough to make sure we always complete right away\n+        request.setWaitForCompletion(new TimeValue(2, TimeUnit.SECONDS));", "originalCommit": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0MjE3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394342177", "bodyText": "We can also have a loop here when get is implemented that submits the initial request and use get until isRunning is false on the response ?", "author": "jimczi", "createdAt": "2020-03-18T13:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0NzIzNw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394347237", "bodyText": "I'll go with 1.) then, staying on the save side. I will keep cleanOnCompletion though, currently thats the only way I can see to actually get an Id and I'd like to tests its deserialization etc... here if possible (will also need ids in a follow-up PR around get-API)", "author": "cbuescher", "createdAt": "2020-03-18T13:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0OTU1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394349559", "bodyText": "sorry, missed the previous comment. Loop sounds okay as well, getting a response thats not running any more isn't actually the problem, the oposite is tricky (getting a response with an Id, as I mentioned earlier). I don't need that here so will remove it but will need it later for get/delete API tests.", "author": "cbuescher", "createdAt": "2020-03-18T13:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM1MTk1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394351951", "bodyText": "Just also realize I haven't implemented get yet in this PR, we could change this later to a loop with get if you agree?\nI don't see the benefits over a long-enough wait time though, quite the oposite. I never got this call to not finish in the first call, neither locally nor on CI which is even faster.", "author": "cbuescher", "createdAt": "2020-03-18T13:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM1MjE1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394352151", "bodyText": "I like the loop idea if it does not make things too complicated, it sounds doable.", "author": "javanna", "createdAt": "2020-03-18T13:39:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM1MjcwMg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394352702", "bodyText": "it's fine to make this a loop later ;)", "author": "javanna", "createdAt": "2020-03-18T13:40:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ=="}], "type": "inlineReview"}, {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851", "url": "https://github.com/elastic/elasticsearch/commit/3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851", "message": "Adressing review comments", "committedDate": "2020-03-18T14:32:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDY4MA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394430680", "bodyText": "we may want to expose a setter for the source too. Not so important but I guess users would argue that once set at the constructor it can never be reset. Search request allows to set it.", "author": "javanna", "createdAt": "2020-03-18T15:23:25Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }\n+\n+    /**\n+     * Gets if the source of the {@link SearchSourceBuilder} initially used on this request.\n+     */\n+    public SearchSourceBuilder getSearchSource() {\n+        return this.searchRequest.source();\n+    }", "originalCommit": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1ODA0NA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394458044", "bodyText": "Sorry, I don't follow. Why would you want to change the source when you are constructing the request in the client? You can get it and change the various parts of it if you like. Why aim for parity with SearchRequest? This would mean allowing the user to reach down into a thing we want to hide (the SearchRequest) and make changes there. I don't see how thats useful.", "author": "cbuescher", "createdAt": "2020-03-18T15:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3OTU5OA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394479598", "bodyText": "I would have replied the same way to this comment :) it is just a comment that I got in the past with these client requests. People expect to be able to reset stuff, while here once you set the source you can not go back to the initial state. Though you can modify it. I am fine with doing without the setter though, it is not that useful.", "author": "javanna", "createdAt": "2020-03-18T16:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMTAxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394431015", "bodyText": "how about maxConcurrentShardRequests? Was it left out on purpose?", "author": "javanna", "createdAt": "2020-03-18T15:23:49Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }", "originalCommit": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1OTc4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394459782", "bodyText": "Good one, I think that parameter is also missing from the regular RequestConverters.", "author": "cbuescher", "createdAt": "2020-03-18T16:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMTAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3NjE2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394476166", "bodyText": "I pulled adding this parameter (and the previously mentioned pre_filter_shard_size) to the regular RequestConverters into #53745 to get this in independently of this PR.", "author": "cbuescher", "createdAt": "2020-03-18T16:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMTAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3ODQ5MA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394478490", "bodyText": "sounds good thanks", "author": "javanna", "createdAt": "2020-03-18T16:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMTAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU1NDA4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394554082", "bodyText": "Cherry-picked that PR and added support for max_concurrent_shard_requests", "author": "cbuescher", "createdAt": "2020-03-18T18:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMTAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMjU0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394432545", "bodyText": "some of these checks become redundant once the search request is hidden. Are we going to be able to remove the getter for the search request, or will it be package protected? I guess that will play a role in whether these values are at least theoretically settable from the same package, or not at all.", "author": "javanna", "createdAt": "2020-03-18T15:25:58Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }\n+\n+    /**\n+     * Gets if the source of the {@link SearchSourceBuilder} initially used on this request.\n+     */\n+    public SearchSourceBuilder getSearchSource() {\n+        return this.searchRequest.source();\n+    }\n+\n+    @Override\n+    public Optional<ValidationException> validate() {\n+        final ValidationException validationException = new ValidationException();\n+        if (searchRequest.scroll() != null) {\n+            validationException.addValidationError(\"[scroll] queries are not supported\");\n+        }\n+        if (searchRequest.isSuggestOnly()) {\n+            validationException.addValidationError(\"suggest-only queries are not supported\");\n+        }\n+        if (searchRequest.isCcsMinimizeRoundtrips()) {\n+            validationException.addValidationError(\"[ccs_minimize_roundtrips] is not supported on async search queries\");\n+        }", "originalCommit": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0MjAzMg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394442032", "bodyText": "That getter can probably go, other need to be accessible from the AsyncRequestConverters, which currently need to stay in org.elasticsearch.client to work with existing infra in RequestConverters. Moving the former proved to be difficult. I think I can remove the validation checks for \"ccs_minimize_roundtrips\" and \"scroll\" though because now they should not be settable any more (and there is an extra layer of protection on the REST layer later.", "author": "cbuescher", "createdAt": "2020-03-18T15:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMjU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1NzY2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394457665", "bodyText": "there should be no setters/getters for scroll and ccs_minimize_roundtrips anymore now so I removed the validation.", "author": "cbuescher", "createdAt": "2020-03-18T15:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMjU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzczNg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394433736", "bodyText": "should this be there given that we don't allow to set it directly and we support only one value for it?", "author": "javanna", "createdAt": "2020-03-18T15:27:29Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -56,4 +55,21 @@ static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) th\n         request.addParameters(params.asMap());\n         return request;\n     }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));\n+        params.putParam(\"pre_filter_shard_size\", Integer.toString(SubmitAsyncSearchRequest.DEFAULT_PRE_FILTER_SHARD_SIZE));\n+        params.putParam(\"ccs_minimize_roundtrips\", Boolean.toString(SubmitAsyncSearchRequest.DEFAULT_CCS_MINIMIZE_ROUNDTRIPS));", "originalCommit": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0Mjc3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394442771", "bodyText": "Yes, wee need to send those values (the onse we set on the ctor) via HTTP because they are different than the defaults in SearchRequest.", "author": "cbuescher", "createdAt": "2020-03-18T15:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzczNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0NzkxNA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394447914", "bodyText": "Okay, upon rechecking the code in RestSearchAction#prepareRequest, we set those values in the ctor on the server side to the defaults and shold only send those that the user can still modify, like batchedReduceSize and requestCache(see #53592 (comment))", "author": "cbuescher", "createdAt": "2020-03-18T15:45:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzczNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1NjA4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394456089", "bodyText": "Removing \"pre_filter_shard_size\" and \"ccs_minimize_roundtrips\" from the http serialization", "author": "cbuescher", "createdAt": "2020-03-18T15:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzNDE2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394434166", "bodyText": "I think we can remove it. it is not in the spec and we don't allow to set it directly", "author": "javanna", "createdAt": "2020-03-18T15:28:04Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -56,4 +55,21 @@ static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) th\n         request.addParameters(params.asMap());\n         return request;\n     }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));\n+        params.putParam(\"pre_filter_shard_size\", Integer.toString(SubmitAsyncSearchRequest.DEFAULT_PRE_FILTER_SHARD_SIZE));", "originalCommit": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "594a5eb68b4c26925bbde16776dfa4b4b9b2b7b0", "url": "https://github.com/elastic/elasticsearch/commit/594a5eb68b4c26925bbde16776dfa4b4b9b2b7b0", "message": "Remove redundant parameters and validation", "committedDate": "2020-03-18T15:55:14Z", "type": "commit"}, {"oid": "f686a5081f0a2489c32eae027c0b7817c18f0884", "url": "https://github.com/elastic/elasticsearch/commit/f686a5081f0a2489c32eae027c0b7817c18f0884", "message": "Avoid additional boilerplate getters on SubmitAsyncSearchRequest by making getSearchRequest() package private", "committedDate": "2020-03-18T16:40:29Z", "type": "commit"}, {"oid": "1d301c47d871a9bcc43907eb861e4c0fb4b7353d", "url": "https://github.com/elastic/elasticsearch/commit/1d301c47d871a9bcc43907eb861e4c0fb4b7353d", "message": "Add unsupported parameters to HLRC search request\n\nCurrently we don't send values for the `pre_filter_shard_size` and\n`max_concurrent_shard_requests` SearchRequest parameters over http when using\nthe High Level Rest Client. This change adds these parameters to the\nRequestConverters and tests.", "committedDate": "2020-03-18T18:10:45Z", "type": "commit"}, {"oid": "4ab7dc78477bb8752fcc899aac12f31d3f1049f8", "url": "https://github.com/elastic/elasticsearch/commit/4ab7dc78477bb8752fcc899aac12f31d3f1049f8", "message": "Revert \"Avoid additional boilerplate getters on SubmitAsyncSearchRequest by making getSearchRequest() package private\"\n\nThis reverts commit f686a5081f0a2489c32eae027c0b7817c18f0884.", "committedDate": "2020-03-18T18:13:35Z", "type": "commit"}, {"oid": "720c966dc4aa7b54a083c18b7fa79b8d12452964", "url": "https://github.com/elastic/elasticsearch/commit/720c966dc4aa7b54a083c18b7fa79b8d12452964", "message": "Add support for max_concurrent_shard_requests", "committedDate": "2020-03-18T18:24:21Z", "type": "commit"}, {"oid": "220e6a89f0600570717081089cba70acf412c3c4", "url": "https://github.com/elastic/elasticsearch/commit/220e6a89f0600570717081089cba70acf412c3c4", "message": "Merge branch 'master' into async-search-hlrc", "committedDate": "2020-03-18T20:30:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MTUyMg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394691522", "bodyText": "docs link should be https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html PR is open but not merged yet: #53675", "author": "javanna", "createdAt": "2020-03-18T23:14:04Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.client.asyncsearch.AsyncSearchResponse;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.emptySet;\n+\n+public class AsyncSearchClient {\n+    private final RestHighLevelClient restHighLevelClient;\n+\n+    AsyncSearchClient(RestHighLevelClient restHighLevelClient) {\n+        this.restHighLevelClient = restHighLevelClient;\n+    }\n+\n+    // TODO add docs url", "originalCommit": "220e6a89f0600570717081089cba70acf412c3c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkwNDM3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394904377", "bodyText": "done, see ebd1906", "author": "cbuescher", "createdAt": "2020-03-19T09:50:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MTUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MTgyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394691825", "bodyText": "nit: maybe given they are now used in two places we could add the with* methods for these params too?", "author": "javanna", "createdAt": "2020-03-18T23:15:00Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.apache.http.client.methods.HttpPost;\n+import org.elasticsearch.client.RequestConverters.Params;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.rest.action.search.RestSearchAction;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.client.RequestConverters.REQUEST_BODY_CONTENT_TYPE;\n+\n+final class AsyncSearchRequestConverters {\n+\n+    static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) throws IOException {\n+        String endpoint = new RequestConverters.EndpointBuilder().addCommaSeparatedPathParts(\n+                asyncSearchRequest.getIndices())\n+                .addPathPartAsIs(\"_async_search\").build();\n+        Request request = new Request(HttpPost.METHOD_NAME, endpoint);\n+        Params params = new RequestConverters.Params();\n+        // add all typical search params and search request source as body\n+        addSearchRequestParams(params, asyncSearchRequest);\n+        if (asyncSearchRequest.getSearchSource() != null) {\n+            request.setEntity(RequestConverters.createEntity(asyncSearchRequest.getSearchSource(), REQUEST_BODY_CONTENT_TYPE));\n+        }\n+        // set async search submit specific parameters\n+        if (asyncSearchRequest.isCleanOnCompletion() != null) {\n+            params.putParam(\"clean_on_completion\", asyncSearchRequest.isCleanOnCompletion().toString());\n+        }\n+        if (asyncSearchRequest.getKeepAlive() != null) {\n+            params.putParam(\"keep_alive\", asyncSearchRequest.getKeepAlive().getStringRep());\n+        }\n+        if (asyncSearchRequest.getWaitForCompletion() != null) {\n+            params.putParam(\"wait_for_completion\", asyncSearchRequest.getWaitForCompletion().getStringRep());\n+        }\n+        request.addParameters(params.asMap());\n+        return request;\n+    }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        params.putParam(\"max_concurrent_shard_requests\", Integer.toString(request.getMaxConcurrentShardRequests()));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));", "originalCommit": "220e6a89f0600570717081089cba70acf412c3c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkwNDU2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394904566", "bodyText": "done in f65cf82", "author": "cbuescher", "createdAt": "2020-03-19T09:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MTgyNQ=="}], "type": "inlineReview"}, {"oid": "1d0b59c406bea3b1a621e5108187922680afcc37", "url": "https://github.com/elastic/elasticsearch/commit/1d0b59c406bea3b1a621e5108187922680afcc37", "message": "Merge branch 'master' into async-search-hlrc", "committedDate": "2020-03-19T09:08:55Z", "type": "commit"}, {"oid": "ebd19061c1d5f00e8a54de372ea294ed6da6b54d", "url": "https://github.com/elastic/elasticsearch/commit/ebd19061c1d5f00e8a54de372ea294ed6da6b54d", "message": "Add docs urls", "committedDate": "2020-03-19T09:24:57Z", "type": "commit"}, {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68", "url": "https://github.com/elastic/elasticsearch/commit/f65cf820d03d64096d506b95d412f03a26db9c68", "message": "Unify conversion of some request parameters", "committedDate": "2020-03-19T09:49:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNTY4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394915682", "bodyText": "nit: rename to  withAllowPartialResults ?", "author": "jimczi", "createdAt": "2020-03-19T10:08:53Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RequestConverters.java", "diffHunk": "@@ -860,6 +860,26 @@ Params withPreference(String preference) {\n             return putParam(\"preference\", preference);\n         }\n \n+        Params withSearchType(String searchType) {\n+            return putParam(\"search_type\", searchType);\n+        }\n+\n+        Params withMaxConcurrentShardRequests(int maxConcurrentShardRequests) {\n+            return putParam(\"max_concurrent_shard_requests\", Integer.toString(maxConcurrentShardRequests));\n+        }\n+\n+        Params withBatchedReduceSize(int batchedReduceSize) {\n+            return putParam(\"batched_reduce_size\", Integer.toString(batchedReduceSize));\n+        }\n+\n+        Params withRequestCache(boolean requestCache) {\n+            return putParam(\"request_cache\", Boolean.toString(requestCache));\n+        }\n+\n+        Params withPartialResults(boolean allowPartialSearchResults) {", "originalCommit": "f65cf820d03d64096d506b95d412f03a26db9c68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjMyMw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394916323", "bodyText": "Why can't this be a constructor arg ?", "author": "jimczi", "createdAt": "2020-03-19T10:10:07Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<AsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new AsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(AsyncSearchResponse::setId, ID_FIELD);", "originalCommit": "f65cf820d03d64096d506b95d412f03a26db9c68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAwNDA0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r395004049", "bodyText": "True, this could be an optionalConstructorArg(). I think I did this via setters because I disklike too many optional ctor args that can be null and made the setters for them package private. I can even make them private (the setters), would that be okay with you? I don't remember exactly if more ctor args somehow slow down ConstructingObjectParser since they need to be buffered before object creation but I guess that would be a minor disadvantage.", "author": "cbuescher", "createdAt": "2020-03-19T12:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyMDMyNw==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r395020327", "bodyText": "I pushed some changes and went with optionalConstructorArg to avoid more unnecessary roundtrips on this, in the end I don't care that much.", "author": "cbuescher", "createdAt": "2020-03-19T13:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjQwMA==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394916400", "bodyText": "Same here ?", "author": "jimczi", "createdAt": "2020-03-19T10:10:15Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<AsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new AsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(AsyncSearchResponse::setId, ID_FIELD);\n+        PARSER.declareObject(AsyncSearchResponse::setSearchResponse, (p, c) -> AsyncSearchResponse.parseSearchResponse(p),\n+                RESPONSE_FIELD);", "originalCommit": "f65cf820d03d64096d506b95d412f03a26db9c68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjQ4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394916486", "bodyText": "And here ?", "author": "jimczi", "createdAt": "2020-03-19T10:10:23Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<AsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new AsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(AsyncSearchResponse::setId, ID_FIELD);\n+        PARSER.declareObject(AsyncSearchResponse::setSearchResponse, (p, c) -> AsyncSearchResponse.parseSearchResponse(p),\n+                RESPONSE_FIELD);\n+        PARSER.declareObject(AsyncSearchResponse::setFailure, (p, c) -> ElasticsearchException.fromXContent(p), ERROR_FIELD);", "originalCommit": "f65cf820d03d64096d506b95d412f03a26db9c68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNzgzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394917831", "bodyText": "This can be set in the ctr ? It should be final too.", "author": "jimczi", "createdAt": "2020-03-19T10:12:35Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;", "originalCommit": "f65cf820d03d64096d506b95d412f03a26db9c68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNzg4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394917885", "bodyText": "same here", "author": "jimczi", "createdAt": "2020-03-19T10:12:42Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;", "originalCommit": "f65cf820d03d64096d506b95d412f03a26db9c68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "841430e94cd6789e9b2f229ea46859c213569327", "url": "https://github.com/elastic/elasticsearch/commit/841430e94cd6789e9b2f229ea46859c213569327", "message": "adress review comments", "committedDate": "2020-03-19T13:21:28Z", "type": "commit"}, {"oid": "7d3a8ed27dff978d2c7929637b925b5119760e72", "url": "https://github.com/elastic/elasticsearch/commit/7d3a8ed27dff978d2c7929637b925b5119760e72", "message": "Merge branch 'master' into async-search-hlrc", "committedDate": "2020-03-19T14:46:32Z", "type": "commit"}, {"oid": "82239897bf05bc3bd2c9c2f87b754f8e1542fd06", "url": "https://github.com/elastic/elasticsearch/commit/82239897bf05bc3bd2c9c2f87b754f8e1542fd06", "message": "iter", "committedDate": "2020-03-19T18:12:18Z", "type": "commit"}]}