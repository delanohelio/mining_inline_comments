{"pr_number": 62473, "pr_title": "Build local unreleased bwc versions more efficient for tests", "pr_createdAt": "2020-09-16T15:18:51Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62473", "timeline": [{"oid": "60a2c55508206909cba2d8481dafacb59be9e8df", "url": "https://github.com/elastic/elasticsearch/commit/60a2c55508206909cba2d8481dafacb59be9e8df", "message": "fix bwc jdbc build", "committedDate": "2020-09-21T16:11:03Z", "type": "forcePushed"}, {"oid": "f544a08bf99cc8f92c0b3437702901e42a75b9b2", "url": "https://github.com/elastic/elasticsearch/commit/f544a08bf99cc8f92c0b3437702901e42a75b9b2", "message": "Minor refactoring of the plugin and fixing path calculations", "committedDate": "2020-09-23T13:25:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMTQ3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r494311477", "bodyText": "From all the changes, this tweaked test actually shows what this PR is all about.", "author": "breskeby", "createdAt": "2020-09-24T13:21:47Z", "path": "buildSrc/src/integTest/groovy/org/elasticsearch/gradle/internal/InternalDistributionDownloadPluginFuncTest.groovy", "diffHunk": "@@ -74,14 +74,13 @@ class InternalDistributionDownloadPluginFuncTest extends AbstractGradleFuncTest\n         then:\n         result.task(\":distribution:archives:linux-tar:buildExploded\").outcome == TaskOutcome.SUCCESS\n         result.task(\":setupDistro\").outcome == TaskOutcome.SUCCESS\n-        assertExtractedDistroIsCreated(distroVersion, \"build/distro\", 'current-marker.txt')\n+        assertExtractedDistroIsCreated(\"build/distro\", 'current-marker.txt')\n     }\n \n-    def \"resolves bwc versions from source\"() {\n+    def \"resolves expanded bwc versions from source\"() {", "originalCommit": "7b85294ffa2c256af99d34bb5adf6a08823728f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMTIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496931217", "bodyText": "Will we need to update this as we bump our real ci java properties? If so, can we generate or copy the file when running the test?", "author": "rjernst", "createdAt": "2020-09-29T17:55:02Z", "path": "buildSrc/src/integTest/resources/org/elasticsearch/gradle/internal/fake_git/remote/.ci/java-versions.properties", "diffHunk": "@@ -0,0 +1,21 @@\n+#\n+# Licensed to Elasticsearch under one or more contributor\n+# license agreements. See the NOTICE file distributed with\n+# this work for additional information regarding copyright\n+# ownership. Elasticsearch licenses this file to you under\n+# the Apache License, Version 2.0 (the \"License\"); you may\n+# not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+#\n+ES_BUILD_JAVA=openjdk14", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0MDgyMA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497040820", "bodyText": "Well, this is only needed for our build as BWC branches might have different java requirements. I suspect in the case of this mock project it doesn't really matter.", "author": "mark-vieira", "createdAt": "2020-09-29T20:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMTIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMzMzgyNA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497333824", "bodyText": "As it is just for testing purposes only, it doesn't need to match exactly what we use in production", "author": "breskeby", "createdAt": "2020-09-30T08:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMTIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzOTUxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496939515", "bodyText": "What does the entirety of the lifecycle output look like? This comment on its own would be pretty cryptic", "author": "rjernst", "createdAt": "2020-09-29T18:09:01Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMzOTM0OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497339348", "bodyText": "The overall lifecycle output here hasn't changed in this PR and would look e.g. like this:\n> Task :distribution:bwc:bugfix:checkoutBwcBranch\nCommit date of current: 'Wed, 30 Sep 2020 10:33:41 +0200'\nPerforming checkout of elastic/7.9...\nCheckout hash for :distribution:bwc:bugfix is c9534e03e8beae7e9b566cda7236532665c376e9", "author": "breskeby", "createdAt": "2020-09-30T08:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzOTUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MjIzNg==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496942236", "bodyText": "We can just use Files.write:\nFiles.writeString(file.toPath(), content);", "author": "rjernst", "createdAt": "2020-09-29T18:13:41Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n+\n+        String mergeCommits = execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n+        );\n+        if (mergeCommits.isEmpty() == false) {\n+            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n+        }\n+        return execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n+        );\n+    }\n+\n+    private void writeFile(File file, String content) {\n+        try {\n+            FileWriter myWriter = new FileWriter(file, false);", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA3OTcwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498079701", "bodyText": "done", "author": "breskeby", "createdAt": "2020-10-01T08:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MjIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0Mjg0NA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496942844", "bodyText": "Let's not swallow any exceptions. This should cause the build to fail. If we can't let it propagate as is, then wrap it with UncheckedIOException?", "author": "rjernst", "createdAt": "2020-09-29T18:14:42Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n+\n+        String mergeCommits = execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n+        );\n+        if (mergeCommits.isEmpty() == false) {\n+            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n+        }\n+        return execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n+        );\n+    }\n+\n+    private void writeFile(File file, String content) {\n+        try {\n+            FileWriter myWriter = new FileWriter(file, false);\n+            myWriter.write(content);\n+            myWriter.close();\n+        } catch (IOException e) {\n+            e.printStackTrace();", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MjAyMg==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062022", "bodyText": "fixed", "author": "breskeby", "createdAt": "2020-10-01T08:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0Mjg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzUyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496943521", "bodyText": "If we need a git specific method, then the spec should set the executable to git? Otherwise how is this different than just a generic exec helper?", "author": "rjernst", "createdAt": "2020-09-29T18:15:51Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n+\n+        String mergeCommits = execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n+        );\n+        if (mergeCommits.isEmpty() == false) {\n+            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n+        }\n+        return execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n+        );\n+    }\n+\n+    private void writeFile(File file, String content) {\n+        try {\n+            FileWriter myWriter = new FileWriter(file, false);\n+            myWriter.write(content);\n+            myWriter.close();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private String execGit(Action<ExecSpec> execSpecConfig) {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MjI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062263", "bodyText": "I removed the git part of it. at the end its just about using the common working dir", "author": "breskeby", "createdAt": "2020-10-01T08:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzkzNw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496943937", "bodyText": "nit: These -> these", "author": "rjernst", "createdAt": "2020-09-29T18:16:35Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MjMyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062329", "bodyText": "fixed", "author": "breskeby", "createdAt": "2020-10-01T08:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MDUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497060537", "bodyText": "Why do we now hard-code this vs relying on BuildParams.bwcVersions? The list of \"unreleased\" projects is dynamic and changes based on where we are at in the stack release process. For example the :staged bwc project is only \"active\" when we have branched for a new minor release but have not gone GA yet. I believe with this change we would never resolve dependencies from that branch, and therefore our CI images would be slightly more out of date than necessary.", "author": "mark-vieira", "createdAt": "2020-09-29T21:08:04Z", "path": "distribution/bwc/build.gradle", "diffHunk": "@@ -17,345 +17,20 @@\n  * under the License.\n  */\n \n-import org.apache.tools.ant.taskdefs.condition.Os\n-import org.elasticsearch.gradle.LoggedExec\n-import org.elasticsearch.gradle.Version\n-import org.elasticsearch.gradle.BwcVersions\n-import org.elasticsearch.gradle.info.BuildParams\n-import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin\n-import org.gradle.util.GradleVersion\n-\n-import java.nio.charset.StandardCharsets\n-\n-import static org.elasticsearch.gradle.util.JavaUtil.getJavaHome\n-\n-/**\n- *  We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n- *  For this we need to check out and build the unreleased versions.\n- *  Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n- *  unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n- *  and configure them to build various versions here.\n- */\n-BuildParams.bwcVersions.forPreviousUnreleased { BwcVersions.UnreleasedVersionInfo unreleasedVersion ->\n-  project(\"${unreleasedVersion.gradleProjectPath}\") {\n-    Version bwcVersion = unreleasedVersion.version\n-    String bwcBranch = unreleasedVersion.branch\n-    apply plugin: 'distribution'\n-    // Not published so no need to assemble\n-    tasks.named(\"assemble\").configure {\n-      enabled = false\n-    }\n-    File checkoutDir = file(\"${buildDir}/bwc/checkout-${bwcBranch}\")\n-\n-    final String remote = System.getProperty(\"bwc.remote\", \"elastic\")\n-\n-    boolean gitFetchLatest\n-    final String gitFetchLatestProperty = System.getProperty(\"tests.bwc.git_fetch_latest\", \"true\")\n-    if (\"true\".equals(gitFetchLatestProperty)) {\n-      gitFetchLatest = true\n-    } else if (\"false\".equals(gitFetchLatestProperty)) {\n-      gitFetchLatest = false\n-    } else {\n-      throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + gitFetchLatestProperty + \"]\")\n-    }\n-\n-    tasks.register(\"createClone\", LoggedExec) {\n-      onlyIf { checkoutDir.exists() == false }\n-      commandLine = ['git', 'clone', rootDir, checkoutDir]\n-    }\n-\n-    tasks.register(\"findRemote\", LoggedExec) {\n-      dependsOn \"createClone\"\n-      workingDir = checkoutDir\n-      commandLine = ['git', 'remote', '-v']\n-      ByteArrayOutputStream output = new ByteArrayOutputStream()\n-      standardOutput = output\n-      doLast {\n-        project.ext.remoteExists = false\n-        output.toString('UTF-8').eachLine {\n-          if (it.contains(\"${remote}\\t\")) {\n-            project.ext.remoteExists = true\n-          }\n-        }\n-      }\n-    }\n-\n-    tasks.register(\"addRemote\", LoggedExec) {\n-      dependsOn findRemote\n-      onlyIf { project.ext.remoteExists == false }\n-      workingDir = checkoutDir\n-      commandLine = ['git', 'remote', 'add', \"${remote}\", \"https://github.com/${remote}/elasticsearch.git\"]\n-    }\n-\n-    tasks.register(\"fetchLatest\", LoggedExec) {\n-      onlyIf { project.gradle.startParameter.isOffline() == false && gitFetchLatest }\n-      dependsOn(\"addRemote\")\n-      workingDir = checkoutDir\n-      commandLine = ['git', 'fetch', '--all']\n-    }\n-\n-    Closure execGit = { Action<ExecSpec> action ->\n-      new ByteArrayOutputStream().withStream { os ->\n-        ExecResult result = project.exec { spec ->\n-          workingDir = checkoutDir\n-          standardOutput os\n-          action.execute(spec)\n-        }\n-        result.assertNormalExitValue()\n-        return os.toString().trim()\n-      }\n-    }\n-    tasks.register(\"checkoutBwcBranch\") {\n-      dependsOn(\"fetchLatest\")\n-      doLast {\n-        def refspec = System.getProperty(\"bwc.refspec.\" + bwcBranch) ?: System.getProperty(\"tests.bwc.refspec.\" + bwcBranch) ?: \"${remote}/${bwcBranch}\"\n-        if (System.getProperty(\"bwc.checkout.align\") != null) {\n-          /*\n-              We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n-              Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n-              reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n-              commit was made.\n-\n-              This approach doesn't work with merge commits as these can introduce commits in the chronological order\n-              after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n-              deterministic.\n-\n-              We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n-              we are interested in.\n-\n-              Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n-              passed as input. This means the results might not be deterministic in the current second, but this\n-              should not matter in practice.\n-          */\n-          String timeOfCurrent = execGit { spec ->\n-            spec.commandLine 'git', 'show', '--no-patch', '--no-notes', \"--pretty='%cD'\"\n-            spec.workingDir project.rootDir\n-          }\n-          logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent)\n-          String mergeCommits = execGit { spec ->\n-            spec.commandLine \"git\", \"rev-list\", refspec, \"--after\", timeOfCurrent, \"--merges\"\n-          }\n-          if (mergeCommits.isEmpty() == false) {\n-            throw new IllegalStateException(\n-              \"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits\n-            )\n-          }\n-          refspec = execGit { spec ->\n-            spec.commandLine \"git\", \"rev-list\", refspec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"\n-          }\n-        }\n-\n-        logger.lifecycle(\"Performing checkout of ${refspec}...\")\n-        LoggedExec.exec(project) { spec ->\n-          spec.workingDir = checkoutDir\n-          spec.commandLine \"git\", \"checkout\", refspec\n-        }\n-        String checkoutHash = GlobalBuildInfoPlugin.gitInfo(checkoutDir).revision\n-        logger.lifecycle(\"Checkout hash for ${project.path} is ${checkoutHash}\")\n-        file(\"${project.buildDir}/refspec\").text = checkoutHash\n-      }\n-    }\n-\n-\n-    Closure<TaskProvider> createRunBwcGradleTask = { name, extraConfig ->\n-      return tasks.register(\"$name\", LoggedExec) {\n-        dependsOn \"checkoutBwcBranch\"\n-        spoolOutput = true\n-        workingDir = checkoutDir\n-        doFirst {\n-          // Execution time so that the checkouts are available\n-          List<String> lines = file(\"${checkoutDir}/.ci/java-versions.properties\").readLines()\n-          environment(\n-            'JAVA_HOME',\n-            getJavaHome(Integer.parseInt(\n-              lines\n-                .findAll({ it.startsWith(\"ES_BUILD_JAVA=\") })\n-                .collect({ it.replace(\"ES_BUILD_JAVA=java\", \"\").trim() })\n-                .collect({ it.replace(\"ES_BUILD_JAVA=openjdk\", \"\").trim() })\n-                .join(\"!!\")\n-            ))\n-          )\n-          environment(\n-            'RUNTIME_JAVA_HOME',\n-            getJavaHome(Integer.parseInt(\n-              lines\n-                .findAll({ it.startsWith(\"ES_RUNTIME_JAVA=java\") })\n-                .collect({ it.replace(\"ES_RUNTIME_JAVA=java\", \"\").trim() })\n-                .join(\"!!\")\n-            ))\n-          )\n-        }\n-\n-        if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-          executable 'cmd'\n-          args '/C', 'call', new File(checkoutDir, 'gradlew').toString()\n-        } else {\n-          executable new File(checkoutDir, 'gradlew').toString()\n-        }\n-        if (gradle.startParameter.isOffline()) {\n-          args \"--offline\"\n-        }\n-        String buildCacheUrl = System.getProperty('org.elasticsearch.build.cache.url')\n-        if (buildCacheUrl) {\n-          args \"-Dorg.elasticsearch.build.cache.url=${buildCacheUrl}\"\n-        }\n-\n-        args \"-Dbuild.snapshot=true\"\n-        args \"-Dscan.tag.NESTED\"\n-        final LogLevel logLevel = gradle.startParameter.logLevel\n-        if ([LogLevel.QUIET, LogLevel.WARN, LogLevel.INFO, LogLevel.DEBUG].contains(logLevel)) {\n-          args \"--${logLevel.name().toLowerCase(Locale.ENGLISH)}\"\n-        }\n-        final String showStacktraceName = gradle.startParameter.showStacktrace.name()\n-        assert [\"INTERNAL_EXCEPTIONS\", \"ALWAYS\", \"ALWAYS_FULL\"].contains(showStacktraceName)\n-        if (showStacktraceName.equals(\"ALWAYS\")) {\n-          args \"--stacktrace\"\n-        } else if (showStacktraceName.equals(\"ALWAYS_FULL\")) {\n-          args \"--full-stacktrace\"\n-        }\n-        if (gradle.getStartParameter().isParallelProjectExecutionEnabled()) {\n-          args \"--parallel\"\n-        }\n-        standardOutput = new IndentingOutputStream(System.out, bwcVersion)\n-        errorOutput = new IndentingOutputStream(System.err, bwcVersion)\n-        configure extraConfig\n-      }\n-    }\n-\n-    Closure buildBwcTaskName = { projectName ->\n-      return \"buildBwc${projectName.replaceAll(/-\\w/) { it[1].toUpperCase() }.capitalize()}\"\n-    }\n-\n-    def buildBwc = tasks.register(\"buildBwc\");\n-\n-    Closure createBuildBwcTask = { projectName, projectDir, projectArtifact ->\n-      def bwcTaskName = buildBwcTaskName(projectName)\n-      createRunBwcGradleTask(bwcTaskName) {\n-        inputs.file(\"${project.buildDir}/refspec\")\n-        outputs.files(projectArtifact)\n-        outputs.cacheIf(\"BWC distribution caching is disabled on 'master' branch\") {\n-          // Don't bother caching in 'master' since the BWC branches move too quickly to make this cost worthwhile\n-          BuildParams.ci && System.getenv('GIT_BRANCH')?.endsWith(\"master\") == false\n-        }\n-        args \":${projectDir.replace('/', ':')}:assemble\"\n-        if (project.gradle.startParameter.buildCacheEnabled) {\n-          args \"--build-cache\"\n-        }\n-        doLast {\n-          if (projectArtifact.exists() == false) {\n-            throw new InvalidUserDataException(\"Building ${bwcVersion} didn't generate expected file ${projectArtifact}\")\n-          }\n-        }\n-      }\n-      buildBwc.configure {\n-        dependsOn(bwcTaskName)\n-      }\n-    }\n+apply plugin:\"elasticsearch.internal-distribution-bwc-setup\"\n \n-    Map<String, File> artifactFiles = [:]\n-    List<String> projectDirs = []\n-    List<String> projects = ['deb', 'rpm']\n-    if (bwcVersion.onOrAfter('7.0.0')) {\n-      projects.addAll(['windows-zip', 'darwin-tar', 'linux-tar'])\n-    } else {\n-      projects.add('zip')\n-    }\n-\n-    for (String projectName : projects) {\n-      String baseDir = \"distribution\"\n-      String classifier = \"\"\n-      String extension = projectName\n-      if (bwcVersion.onOrAfter('7.0.0') && (projectName.contains('zip') || projectName.contains('tar'))) {\n-        int index = projectName.indexOf('-')\n-        classifier = \"-${projectName.substring(0, index)}-x86_64\"\n-        extension = projectName.substring(index + 1)\n-        if (extension.equals('tar')) {\n-          extension += '.gz'\n-        }\n-      }\n-      if (bwcVersion.onOrAfter('7.0.0') && projectName.contains('deb')) {\n-        classifier = \"-amd64\"\n-      }\n-      if (bwcVersion.onOrAfter('7.0.0') && projectName.contains('rpm')) {\n-        classifier = \"-x86_64\"\n-      }\n-      if (bwcVersion.onOrAfter('6.3.0')) {\n-        baseDir += projectName.endsWith('zip') || projectName.endsWith('tar') ? '/archives' : '/packages'\n-        // add oss variant first\n-        projectDirs.add(\"${baseDir}/oss-${projectName}\")\n-        File ossProjectArtifact = file(\"${checkoutDir}/${baseDir}/oss-${projectName}/build/distributions/elasticsearch-oss-${bwcVersion}-SNAPSHOT${classifier}.${extension}\")\n-        artifactFiles.put(\"oss-\" + projectName, ossProjectArtifact)\n-        createBuildBwcTask(\"oss-${projectName}\", \"${baseDir}/oss-${projectName}\", ossProjectArtifact)\n-      }\n-      projectDirs.add(\"${baseDir}/${projectName}\")\n-      File projectArtifact = file(\"${checkoutDir}/${baseDir}/${projectName}/build/distributions/elasticsearch-${bwcVersion}-SNAPSHOT${classifier}.${extension}\")\n-      artifactFiles.put(projectName, projectArtifact)\n-\n-      createBuildBwcTask(projectName, \"${baseDir}/${projectName}\", projectArtifact)\n-    }\n-\n-    // Create build tasks for the JDBC driver used for compatibility testing\n-    String jdbcProjectDir = 'x-pack/plugin/sql/jdbc'\n-    File jdbcProjectArtifact = file(\"${checkoutDir}/${jdbcProjectDir}/build/distributions/x-pack-sql-jdbc-${bwcVersion}-SNAPSHOT.jar\")\n-    createBuildBwcTask('jdbc', jdbcProjectDir, jdbcProjectArtifact)\n+import org.elasticsearch.gradle.Version\n \n-    createRunBwcGradleTask(\"resolveAllBwcDependencies\") {\n-      args 'resolveAllDependencies'\n+[project(\"minor\"), project(\"bugfix\")].each { bwcProject ->", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MjU3MA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062570", "bodyText": "I fixed this. my understanding here was wrong", "author": "breskeby", "createdAt": "2020-10-01T08:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MDUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MzczMA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497063730", "bodyText": "Will this go away when these changes are backported?", "author": "mark-vieira", "createdAt": "2020-09-29T21:14:40Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionDownloadPlugin.java", "diffHunk": "@@ -94,14 +94,22 @@ private void registerInternalDistributionResolutions(NamedDomainObjectContainer<\n                             + \"without a bundled JDK is not supported.\"\n                     );\n                 }\n+                String distributionProjectName = distributionProjectName(distribution);\n+                String projectConfig = getProjectConfig(distributionProjectName, unreleasedInfo);\n                 return new ProjectBasedDistributionDependency(\n-                    (config) -> projectDependency(project, unreleasedInfo.gradleProjectPath, distributionProjectName(distribution))\n+                    (config) -> projectDependency(project, unreleasedInfo.gradleProjectPath, projectConfig)\n                 );\n             }\n             return null;\n         }));\n     }\n \n+    private static String getProjectConfig(String distributionProjectName, BwcVersions.UnreleasedVersionInfo info) {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM2NDg2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497364866", "bodyText": "yes, adding a not. Though I think we can only backport this down to 7.x we will live with that for a while till bugfix and minor is actually taken from that branch.", "author": "breskeby", "createdAt": "2020-09-30T09:19:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MzczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NDg5OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497064898", "bodyText": "Can't this be injected as a constructor arg?", "author": "mark-vieira", "createdAt": "2020-09-29T21:17:02Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2Mjc4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062787", "bodyText": "done", "author": "breskeby", "createdAt": "2020-10-01T08:14:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NDg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NzAzMw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497067033", "bodyText": "Does this only technically \"work\" since we are lazily configuring these tasks?", "author": "mark-vieira", "createdAt": "2020-09-29T21:21:10Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM4NTM5OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497385398", "bodyText": "yes. One clean solution could be to change the implementation of LoggedExec to not rely on the Exec Task", "author": "breskeby", "createdAt": "2020-09-30T09:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NzAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497068154", "bodyText": "Can we leverage Util.getBooleanProperty() here?", "author": "mark-vieira", "createdAt": "2020-09-29T21:23:30Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM4NzM3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497387371", "bodyText": "Ideally we should move away from just using System.getProperty and therefore Util.getBooleanProperty as is as this is discouraged by gradle in order to support --configuration-cache. IMO we should actually deprecate Util.getBooleanProperty  or change its implementation to take a ProviderFactory", "author": "breskeby", "createdAt": "2020-09-30T09:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NDE0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497654145", "bodyText": "Understood. Yeah, we do this pattern a lot so maybe we should later add some helper for returning a provider.", "author": "mark-vieira", "createdAt": "2020-09-30T16:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NTkxNw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497655917", "bodyText": "Why not turn Util.getBooleanProperty() into that helper?", "author": "rjernst", "createdAt": "2020-09-30T16:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NjgwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497656801", "bodyText": "I don't believe everywhere we use that is setup to consume a Provider as-is. We'd have to do some refactoring there and it's significant to probably address in a separate PR.", "author": "mark-vieira", "createdAt": "2020-09-30T16:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY2NzI5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497667299", "bodyText": "Sorry, I was not suggesting changing in this PR, only changing the implementation of that method in a followup, rather than continuing to add any more uses of this pattern.", "author": "rjernst", "createdAt": "2020-09-30T17:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NDY0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497074649", "bodyText": "Looks like we aren't using bwcProject for anything?", "author": "mark-vieira", "createdAt": "2020-09-29T21:36:24Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM4ODczOA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497388738", "bodyText": "removed", "author": "breskeby", "createdAt": "2020-09-30T09:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NDY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NzE4OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497077188", "bodyText": "What's the purpose of passing unreleaseVersionInfo to the extension and then just grabbing it back out? Do we need the getUnreleaseVersionInfo() method on the extensions since we already have a handle to that here?", "author": "mark-vieira", "createdAt": "2020-09-29T21:42:06Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM5NjcyMw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497396723", "bodyText": "actually just an oversight from refactoring. fixed", "author": "breskeby", "createdAt": "2020-09-30T10:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NzE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MDAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497080013", "bodyText": "I'm not sure ArchiveProject is the right name here since this includes deb and rpm packages. Our packaging nomenclature uses \"archive\" to mean specifically zip and tar.", "author": "mark-vieira", "createdAt": "2020-09-29T21:47:31Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n+    }\n+\n+    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n+        String projectName = archiveProject.name;\n+        String buildBwcTask = buildBwcTaskName(projectName);\n+\n+        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n+        if (archiveProject.getExpandedDistDirectory() != null) {\n+            String expandedDistConfiguration = \"expanded-\" + projectName;\n+            bwcProject.getConfigurations().create(expandedDistConfiguration);\n+            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n+                artifact.setName(\"elasticsearch\");\n+                artifact.builtBy(buildBwcTask);\n+                artifact.setType(\"directory\");\n+            });\n+        }\n+    }\n+\n+    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n+        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n+        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n+\n+        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n+        int archIndex = artifactFileName.indexOf(\"x86_64\");\n+\n+        bwcProject.getConfigurations().create(archiveProject.name);\n+        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n+            artifact.setName(artifactName);\n+            artifact.builtBy(buildBwcTask);\n+            artifact.setType(suffix);\n+\n+            String classifier = \"\";\n+            if (archIndex != -1) {\n+                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n+                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n+            }\n+            artifact.setClassifier(classifier);\n+        });\n+    }\n+\n+    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MzY4MA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498063680", "bodyText": "changed to DistributionProject", "author": "breskeby", "createdAt": "2020-10-01T08:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MDAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497081919", "bodyText": "I think we can remove this condition given that we will never build a bwc branch prior to this version since the oldest active branch is 6.8.", "author": "mark-vieira", "createdAt": "2020-09-29T21:51:46Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n+    }\n+\n+    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n+        String projectName = archiveProject.name;\n+        String buildBwcTask = buildBwcTaskName(projectName);\n+\n+        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n+        if (archiveProject.getExpandedDistDirectory() != null) {\n+            String expandedDistConfiguration = \"expanded-\" + projectName;\n+            bwcProject.getConfigurations().create(expandedDistConfiguration);\n+            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n+                artifact.setName(\"elasticsearch\");\n+                artifact.builtBy(buildBwcTask);\n+                artifact.setType(\"directory\");\n+            });\n+        }\n+    }\n+\n+    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n+        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n+        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n+\n+        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n+        int archIndex = artifactFileName.indexOf(\"x86_64\");\n+\n+        bwcProject.getConfigurations().create(archiveProject.name);\n+        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n+            artifact.setName(artifactName);\n+            artifact.builtBy(buildBwcTask);\n+            artifact.setType(suffix);\n+\n+            String classifier = \"\";\n+            if (archIndex != -1) {\n+                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n+                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n+            }\n+            artifact.setClassifier(classifier);\n+        });\n+    }\n+\n+    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n+        List<String> projects = new ArrayList<>();\n+        projects.addAll(asList(\"deb\", \"rpm\"));\n+        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n+            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n+        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n+            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n+        } else {\n+            projects.addAll(asList(\"zip\"));\n+        }\n+\n+        return projects.stream().map(name -> {\n+            String baseDir = \"distribution\";\n+            if (bwcVersion.onOrAfter(\"6.3.0\")) {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzExNzMwOA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497117308", "bodyText": "In master that is true, though we should be sure to add it back then in the backport to 7.x", "author": "rjernst", "createdAt": "2020-09-29T23:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzEyNTg3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497125873", "bodyText": "The oldest version of ES that 7.x will ever build from source is 6.8.x. This is definitely legacy logic that is no longer needed in any active development branch.", "author": "mark-vieira", "createdAt": "2020-09-29T23:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzEyODg1OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497128858", "bodyText": "Doh, you are absolutely right. Ignore me!", "author": "rjernst", "createdAt": "2020-09-29T23:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjQwNg==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497082406", "bodyText": "I think we can ditch this conditional branch. As mentioned below, we no longer will ever build versions prior to 6.8 from source for bwc.", "author": "mark-vieira", "createdAt": "2020-09-29T21:52:54Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n+    }\n+\n+    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n+        String projectName = archiveProject.name;\n+        String buildBwcTask = buildBwcTaskName(projectName);\n+\n+        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n+        if (archiveProject.getExpandedDistDirectory() != null) {\n+            String expandedDistConfiguration = \"expanded-\" + projectName;\n+            bwcProject.getConfigurations().create(expandedDistConfiguration);\n+            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n+                artifact.setName(\"elasticsearch\");\n+                artifact.builtBy(buildBwcTask);\n+                artifact.setType(\"directory\");\n+            });\n+        }\n+    }\n+\n+    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n+        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n+        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n+\n+        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n+        int archIndex = artifactFileName.indexOf(\"x86_64\");\n+\n+        bwcProject.getConfigurations().create(archiveProject.name);\n+        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n+            artifact.setName(artifactName);\n+            artifact.builtBy(buildBwcTask);\n+            artifact.setType(suffix);\n+\n+            String classifier = \"\";\n+            if (archIndex != -1) {\n+                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n+                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n+            }\n+            artifact.setClassifier(classifier);\n+        });\n+    }\n+\n+    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n+        List<String> projects = new ArrayList<>();\n+        projects.addAll(asList(\"deb\", \"rpm\"));\n+        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n+            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n+        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n+            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n+        } else {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MzczMw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498063733", "bodyText": "removed", "author": "breskeby", "createdAt": "2020-10-01T08:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4NTU5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497085593", "bodyText": "Here we zero out the task dependencies but above we actually disable the task. Should we do one or the other?", "author": "mark-vieira", "createdAt": "2020-09-29T22:00:04Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUzNzUyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497537525", "bodyText": "actually I took that over from the original bwc build.gradle script but I don't see the point. Assemble should build all artefacts of that project. if its referenced somewhere were we do not want that. we should fix it there. I'll remove this. Also I think the distribution plugin is not needed.", "author": "breskeby", "createdAt": "2020-09-30T14:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4NTU5Mw=="}], "type": "inlineReview"}, {"oid": "aa2ac780e895911fd352a98a290ecb286e767626", "url": "https://github.com/elastic/elasticsearch/commit/aa2ac780e895911fd352a98a290ecb286e767626", "message": "Start porting bwc distribution setup into plugin", "committedDate": "2020-09-30T08:33:37Z", "type": "commit"}, {"oid": "0661fe2183fcb7af8f376961ea7dfaad1efec7ad", "url": "https://github.com/elastic/elasticsearch/commit/0661fe2183fcb7af8f376961ea7dfaad1efec7ad", "message": "Move git checkout logic into its own plugin", "committedDate": "2020-09-30T08:33:37Z", "type": "commit"}, {"oid": "27decd8d692f49640205923064472798c2ae444f", "url": "https://github.com/elastic/elasticsearch/commit/27decd8d692f49640205923064472798c2ae444f", "message": "Fix spotless", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "876be3303e61ad8ce1366d23a10132e24812ca1e", "url": "https://github.com/elastic/elasticsearch/commit/876be3303e61ad8ce1366d23a10132e24812ca1e", "message": "Port more bwc setup into binary plugin", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "c490dbe281e85c53a9d97a01919154dd5517999c", "url": "https://github.com/elastic/elasticsearch/commit/c490dbe281e85c53a9d97a01919154dd5517999c", "message": "Cleanup", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "0473bd731f336227259dc60a908d912d70dd53c9", "url": "https://github.com/elastic/elasticsearch/commit/0473bd731f336227259dc60a908d912d70dd53c9", "message": "Fix minor issues in bwc setup", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "2a16102ced91dd3745d780841bbed4fc73aa87fd", "url": "https://github.com/elastic/elasticsearch/commit/2a16102ced91dd3745d780841bbed4fc73aa87fd", "message": "Formatting", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "c19484aea04a9d7e5211013f0db8931d96f7fadf", "url": "https://github.com/elastic/elasticsearch/commit/c19484aea04a9d7e5211013f0db8931d96f7fadf", "message": "Extract specific logic from plugin", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "584e2dc7c7787b8aa2a6d0f573f40abc61c06b62", "url": "https://github.com/elastic/elasticsearch/commit/584e2dc7c7787b8aa2a6d0f573f40abc61c06b62", "message": "Fix expected artifact paths", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "3411ae2e0778c7e7b7d346fdaa3d28b4e905d944", "url": "https://github.com/elastic/elasticsearch/commit/3411ae2e0778c7e7b7d346fdaa3d28b4e905d944", "message": "fix bwc jdbc build", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "e2f324d0b57c79e1791cfc43816e3f82f75ce73a", "url": "https://github.com/elastic/elasticsearch/commit/e2f324d0b57c79e1791cfc43816e3f82f75ce73a", "message": "Add initial test coverage for general bwc setup", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "20e5e8316b32ee089d3f51a31621d9bfcfdd0d32", "url": "https://github.com/elastic/elasticsearch/commit/20e5e8316b32ee089d3f51a31621d9bfcfdd0d32", "message": "Tweak func tests for bwc build setup", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "4b274baebaf6f2eb908cc1998760ab731216dfee", "url": "https://github.com/elastic/elasticsearch/commit/4b274baebaf6f2eb908cc1998760ab731216dfee", "message": "Add todo", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "fb6caff2525584d10577d8e164a008697673454b", "url": "https://github.com/elastic/elasticsearch/commit/fb6caff2525584d10577d8e164a008697673454b", "message": "Minor refactoring of the plugin and fixing path calculations", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "5a5fb669575dea27c04bba1646bb9a5464b53814", "url": "https://github.com/elastic/elasticsearch/commit/5a5fb669575dea27c04bba1646bb9a5464b53814", "message": "Expose exploded dists as artifacts", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "0f40234e245834e81d9da285999b3544c92f5f75", "url": "https://github.com/elastic/elasticsearch/commit/0f40234e245834e81d9da285999b3544c92f5f75", "message": "Fix spotless", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "9d523e134481093d3ebc0e0db3f85a8c38f288e7", "url": "https://github.com/elastic/elasticsearch/commit/9d523e134481093d3ebc0e0db3f85a8c38f288e7", "message": "fix bwc setup plugin func test", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "fe55986f5fe630ad737f9f7cef806562abc68f59", "url": "https://github.com/elastic/elasticsearch/commit/fe55986f5fe630ad737f9f7cef806562abc68f59", "message": "Resolve exploded dist for bwc versions > 7.10", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "32684c93f5c564fee3df1fbbd294b73d373e10d9", "url": "https://github.com/elastic/elasticsearch/commit/32684c93f5c564fee3df1fbbd294b73d373e10d9", "message": "Fix bwc tests against current", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "1be13123c054d2bb3d9d8499543b21343e94ae57", "url": "https://github.com/elastic/elasticsearch/commit/1be13123c054d2bb3d9d8499543b21343e94ae57", "message": "Fix formatting", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "9a1b2278739ccd360262227cc3463987972dd970", "url": "https://github.com/elastic/elasticsearch/commit/9a1b2278739ccd360262227cc3463987972dd970", "message": "Polishing\n\n- unify namings\n- use provider api", "committedDate": "2020-09-30T08:33:41Z", "type": "commit"}, {"oid": "4e2bdc7d57ecdf8fa1c7c82a11918c38da724afd", "url": "https://github.com/elastic/elasticsearch/commit/4e2bdc7d57ecdf8fa1c7c82a11918c38da724afd", "message": "Fix jdbc driver bwc build", "committedDate": "2020-09-30T08:33:41Z", "type": "commit"}, {"oid": "a1ff0830d57b34a52aaeedf705def222c01f0d2c", "url": "https://github.com/elastic/elasticsearch/commit/a1ff0830d57b34a52aaeedf705def222c01f0d2c", "message": "Apply review feedback", "committedDate": "2020-09-30T15:20:25Z", "type": "commit"}, {"oid": "a1ff0830d57b34a52aaeedf705def222c01f0d2c", "url": "https://github.com/elastic/elasticsearch/commit/a1ff0830d57b34a52aaeedf705def222c01f0d2c", "message": "Apply review feedback", "committedDate": "2020-09-30T15:20:25Z", "type": "forcePushed"}]}