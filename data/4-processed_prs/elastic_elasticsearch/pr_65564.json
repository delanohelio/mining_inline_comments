{"pr_number": 65564, "pr_title": "Record timestamp field range in index metadata", "pr_createdAt": "2020-11-26T18:04:17Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65564", "timeline": [{"oid": "1f1d5f7f8f867e03882c9640f95eb17250638315", "url": "https://github.com/elastic/elasticsearch/commit/1f1d5f7f8f867e03882c9640f95eb17250638315", "message": "Record timestamp field range in index metadata\n\nQueries including a filter by timestamp range are common in time-series\ndata. Moreover older time-series indices are typically made read-only so\nthat the timestamp range becomes immutable. By recording in the index\nmetadata the range of timestamps covered by each index we can very\nefficiently skip shards on the coordinating node, even if those shards\nare not assigned.\n\nThis commit computes the timestamp range of immutable indices and\nrecords it in the index metadata as the shards start for the first time.\nNote that the only indices it considers immutable today are ones using\nthe `ReadOnlyEngine`, which includes frozen indices and searchable\nsnapshots but not regular indices with a write block.", "committedDate": "2020-11-26T18:02:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQxMTk4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532411986", "bodyText": "Is there a reason we do not return MUTABLE here instead?", "author": "henningandersen", "createdAt": "2020-11-30T08:16:01Z", "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -1713,6 +1716,46 @@ public RecoveryState recoveryState() {\n         return this.recoveryState;\n     }\n \n+    @Override\n+    public ShardLongFieldRange getTimestampMillisRange() {\n+        assert isReadAllowed();\n+\n+        if (mapperService() == null) {\n+            return ShardLongFieldRange.MUTABLE; // no mapper service, no idea if the field even exists\n+        }\n+        final MappedFieldType mappedFieldType = mapperService().fieldType(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD);\n+        final boolean hasMappedTimestampField = mappedFieldType instanceof DateFieldMapper.DateFieldType;\n+\n+        final Engine engine = getEngine();\n+        final ShardLongFieldRange rawTimestampFieldRange;\n+        try {\n+            rawTimestampFieldRange = engine.getRawFieldRange(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD, hasMappedTimestampField);\n+        } catch (IOException e) {\n+            logger.debug(\"exception obtaining range for timestamp field\", e);\n+            return ShardLongFieldRange.MUTABLE;\n+        }\n+        if (rawTimestampFieldRange == ShardLongFieldRange.MUTABLE) {\n+            return ShardLongFieldRange.MUTABLE;\n+        }\n+        if (rawTimestampFieldRange == ShardLongFieldRange.EMPTY) {\n+            return ShardLongFieldRange.EMPTY;\n+        }\n+\n+        if (hasMappedTimestampField == false) {\n+            return ShardLongFieldRange.EMPTY;\n+        }\n+        final DateFieldMapper.DateFieldType dateFieldType = (DateFieldMapper.DateFieldType) mappedFieldType;\n+\n+        try {\n+            return ShardLongFieldRange.of(\n+                    dateFieldType.resolution().roundDownToMillis(rawTimestampFieldRange.getMin()),\n+                    dateFieldType.resolution().roundUpToMillis(rawTimestampFieldRange.getMax()));\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(new ParameterizedMessage(\"could not convert {} to a millisecond time range\", rawTimestampFieldRange), e);\n+            return ShardLongFieldRange.of(Long.MIN_VALUE, Long.MAX_VALUE); // any search might match this shard", "originalCommit": "1f1d5f7f8f867e03882c9640f95eb17250638315", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUwMjM4OA==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532502388", "bodyText": "Pedantry I suppose, we know it's immutable by this point, so MUTABLE isn't right.", "author": "DaveCTurner", "createdAt": "2020-11-30T10:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQxMTk4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI4NDAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533284013", "bodyText": "I added a suggestion to rename MUTABLE below, I think having this difference between essentially unknown timestamp ranges is unnecessary.", "author": "henningandersen", "createdAt": "2020-12-01T10:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQxMTk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQxNDM1NA==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532414354", "bodyText": "Can we also add following?\nassert shards != null || this == MUTABLE;", "author": "henningandersen", "createdAt": "2020-11-30T08:20:40Z", "path": "server/src/main/java/org/elasticsearch/index/shard/IndexLongFieldRange.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.index.shard.ShardLongFieldRange.LONG_FIELD_RANGE_VERSION_INTRODUCED;\n+\n+/**\n+ * Class representing an (inclusive) range of {@code long} values in a field in an index which may comprise multiple shards. This\n+ * information is accumulated shard-by-shard, and we keep track of which shards are represented in this value. Only once all shards are\n+ * represented should this information be considered accurate for the index.\n+ */\n+public class IndexLongFieldRange implements Writeable, ToXContentFragment {\n+\n+    /**\n+     * Sentinel value indicating that no information is currently available, for instance because the index has just been created.\n+     */\n+    public static final IndexLongFieldRange UNKNOWN = new IndexLongFieldRange(new int[0], Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating an empty range, for instance because the field is missing or has no values in any shard.\n+     */\n+    public static final IndexLongFieldRange EMPTY = new IndexLongFieldRange(null, Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating the actual range may change in the future.\n+     */\n+    public static final IndexLongFieldRange MUTABLE = new IndexLongFieldRange(null, Long.MIN_VALUE, Long.MAX_VALUE);\n+\n+    @Nullable // if this range includes all shards\n+    private final int[] shards;\n+    private final long min, max;\n+\n+    private IndexLongFieldRange(int[] shards, long min, long max) {\n+        assert (min == Long.MAX_VALUE && max == Long.MIN_VALUE) || min <= max : min + \" vs \" + max;\n+        assert shards == null || shards.length > 0 || (min == Long.MAX_VALUE && max == Long.MIN_VALUE);\n+        assert shards == null || Arrays.equals(shards, Arrays.stream(shards).sorted().distinct().toArray()) : Arrays.toString(shards);\n+        this.shards = shards;\n+        this.min = min;\n+        this.max = max;\n+    }\n+\n+    /**\n+     * @return whether this range includes information from all shards yet.\n+     */\n+    public boolean isComplete() {\n+        return shards == null;\n+    }\n+\n+    // exposed for testing\n+    int[] getShards() {\n+        return shards;\n+    }\n+\n+    // exposed for testing\n+    long getMinUnsafe() {\n+        return min;\n+    }\n+\n+    // exposed for testing\n+    long getMaxUnsafe() {\n+        return min;\n+    }\n+\n+    /**\n+     * @return the (inclusive) minimum of this range.\n+     */\n+    public long getMin() {\n+        assert shards == null : \"min is meaningless if we don't have data from all shards yet\";\n+        assert this != EMPTY : \"min is meaningless if range is empty\";\n+        assert this != MUTABLE : \"min is meaningless if range is mutable\";\n+        return min;\n+    }\n+\n+    /**\n+     * @return the (inclusive) maximum of this range.\n+     */\n+    public long getMax() {\n+        assert shards == null : \"max is meaningless if we don't have data from all shards yet\";\n+        assert this != EMPTY : \"max is meaningless if range is empty\";\n+        assert this != MUTABLE : \"max is meaningless if range is mutable\";\n+        return max;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        if (out.getVersion().onOrAfter(LONG_FIELD_RANGE_VERSION_INTRODUCED)) {\n+            if (this == UNKNOWN) {\n+                out.writeByte((byte) 1);\n+            } else if (this == MUTABLE) {\n+                out.writeByte((byte) 2);\n+            } else if (this == EMPTY) {\n+                out.writeByte((byte) 3);\n+            } else {\n+                out.writeByte((byte) 0);\n+                if (shards == null) {\n+                    out.writeBoolean(false);\n+                } else {\n+                    out.writeBoolean(true);\n+                    out.writeVIntArray(shards);\n+                }\n+                out.writeZLong(min);\n+                out.writeZLong(max);\n+            }\n+        }\n+    }\n+\n+    public static IndexLongFieldRange readFrom(StreamInput in) throws IOException {\n+        if (in.getVersion().before(LONG_FIELD_RANGE_VERSION_INTRODUCED)) {\n+            // conservative treatment for BWC\n+            return MUTABLE;\n+        }\n+\n+        final byte type = in.readByte();\n+        switch (type) {\n+            case 1:\n+                return UNKNOWN;\n+            case 2:\n+                return MUTABLE;\n+            case 3:\n+                return EMPTY;\n+            case 0:\n+                return new IndexLongFieldRange(in.readBoolean() ? in.readVIntArray() : null, in.readZLong(), in.readZLong());\n+            default:\n+                throw new IllegalStateException(\"type [\" + type + \"] not known\");\n+        }\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        if (this == MUTABLE) {\n+            builder.field(\"mutable\", true);\n+        } else if (this == EMPTY) {\n+            builder.field(\"empty\", true);\n+        } else if (this == UNKNOWN) {\n+            builder.startArray(\"shards\");\n+            builder.endArray();\n+        } else {\n+            builder.field(\"min\", min);\n+            builder.field(\"max\", max);\n+            if (shards != null) {\n+                builder.startArray(\"shards\");\n+                for (int shard : shards) {\n+                    builder.value(shard);\n+                }\n+                builder.endArray();\n+            }\n+        }\n+        return builder;\n+    }\n+\n+    public static IndexLongFieldRange fromXContent(XContentParser parser) throws IOException {\n+        XContentParser.Token token;\n+        String currentFieldName = null;\n+        Boolean isMutable = null;\n+        Boolean isEmpty = null;\n+        Long min = null;\n+        Long max = null;\n+        List<Integer> shardsList = null;\n+        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n+            if (token == XContentParser.Token.FIELD_NAME) {\n+                currentFieldName = parser.currentName();\n+            } else if (token.isValue()) {\n+                if (\"mutable\".equals(currentFieldName)) {\n+                    if (Boolean.FALSE.equals(isMutable)) {\n+                        throw new IllegalArgumentException(\"unexpected field 'mutable'\");\n+                    } else {\n+                        isMutable = Boolean.TRUE;\n+                        isEmpty = Boolean.FALSE;\n+                    }\n+                } else if (\"empty\".equals(currentFieldName)) {\n+                    if (Boolean.FALSE.equals(isEmpty)) {\n+                        throw new IllegalArgumentException(\"unexpected field 'empty'\");\n+                    } else {\n+                        isMutable = Boolean.FALSE;\n+                        isEmpty = Boolean.TRUE;\n+                    }\n+                } else if (\"min\".equals(currentFieldName)) {\n+                    if (Boolean.TRUE.equals(isMutable) || Boolean.TRUE.equals(isEmpty)) {\n+                        throw new IllegalArgumentException(\"unexpected field 'min'\");\n+                    } else {\n+                        isMutable = Boolean.FALSE;\n+                        isEmpty = Boolean.FALSE;\n+                        min = parser.longValue();\n+                    }\n+                } else if (\"max\".equals(currentFieldName)) {\n+                    if (Boolean.TRUE.equals(isMutable) || Boolean.TRUE.equals(isEmpty)) {\n+                        throw new IllegalArgumentException(\"unexpected field 'max'\");\n+                    } else {\n+                        isMutable = Boolean.FALSE;\n+                        isEmpty = Boolean.FALSE;\n+                        max = parser.longValue();\n+                    }\n+                }\n+            } else if (token == XContentParser.Token.START_ARRAY) {\n+                if (\"shards\".equals(currentFieldName)) {\n+                    if (Boolean.TRUE.equals(isMutable) || Boolean.TRUE.equals(isEmpty) || shardsList != null) {\n+                        throw new IllegalArgumentException(\"unexpected array 'shards'\");\n+                    } else {\n+                        isMutable = Boolean.FALSE;\n+                        isEmpty = Boolean.FALSE;\n+                        shardsList = new ArrayList<>();\n+                        while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n+                            if (token.isValue()) {\n+                                shardsList.add(parser.intValue());\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    throw new IllegalArgumentException(\"Unexpected array: \" + currentFieldName);\n+                }\n+            } else {\n+                throw new IllegalArgumentException(\"Unexpected token: \" + token);\n+            }\n+        }\n+\n+        if (Boolean.TRUE.equals(isMutable)) {\n+            //noinspection ConstantConditions this assertion is always true but left here for the benefit of readers\n+            assert min == null && max == null && shardsList == null && Boolean.FALSE.equals(isEmpty);\n+            return MUTABLE;\n+        } else if (Boolean.TRUE.equals(isEmpty)) {\n+            //noinspection ConstantConditions this assertion is always true but left here for the benefit of readers\n+            assert min == null && max == null && shardsList == null && Boolean.FALSE.equals(isMutable);\n+            return EMPTY;\n+        } else if (shardsList != null && shardsList.isEmpty()) {\n+            //noinspection ConstantConditions this assertion is always true but left here for the benefit of readers\n+            assert min == null && max == null && Boolean.FALSE.equals(isEmpty) && Boolean.FALSE.equals(isMutable);\n+            return UNKNOWN;\n+        } else if (min != null) {\n+            //noinspection ConstantConditions this assertion is always true but left here for the benefit of readers\n+            assert Boolean.FALSE.equals(isMutable) && Boolean.FALSE.equals(isEmpty);\n+            if (max == null) {\n+                throw new IllegalArgumentException(\"field 'max' unexpectedly missing\");\n+            }\n+            final int[] shards;\n+            if (shardsList != null) {\n+                shards = shardsList.stream().mapToInt(i -> i).toArray();\n+                assert shards.length > 0;\n+            } else {\n+                shards = null;\n+            }\n+            return new IndexLongFieldRange(shards, min, max);\n+        } else {\n+            throw new IllegalArgumentException(\"field range contents unexpectedly missing\");\n+        }\n+    }\n+\n+    public IndexLongFieldRange extendWithShardRange(int shardId, int shardCount, ShardLongFieldRange shardFieldRange) {\n+        if (shardFieldRange == ShardLongFieldRange.MUTABLE) {\n+            assert shards == null || Arrays.stream(shards).noneMatch(i -> i == shardId) : Arrays.toString(shards);", "originalCommit": "1f1d5f7f8f867e03882c9640f95eb17250638315", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxNDE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532514147", "bodyText": "Yes that's also a good invariant to check; I reworded it into a single assertion in 27b7f38 for clarity.", "author": "DaveCTurner", "createdAt": "2020-11-30T11:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQxNDM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQxODE1MA==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532418150", "bodyText": "Can we assert that when all shards are started in routing table, the timestamp range is also complete?", "author": "henningandersen", "createdAt": "2020-11-30T08:27:45Z", "path": "server/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java", "diffHunk": "@@ -578,6 +608,17 @@ public ShardStartedClusterStateTaskExecutor(AllocationService allocationService,\n             ClusterState maybeUpdatedState = currentState;\n             try {\n                 maybeUpdatedState = allocationService.applyStartedShards(currentState, shardRoutingsToBeApplied);\n+\n+                if (updatedTimestampRanges.isEmpty() == false) {\n+                    final Metadata.Builder metadataBuilder = Metadata.builder(maybeUpdatedState.metadata());\n+                    for (Map.Entry<Index, IndexLongFieldRange> updatedTimestampRangeEntry : updatedTimestampRanges.entrySet()) {\n+                        metadataBuilder.put(IndexMetadata", "originalCommit": "1f1d5f7f8f867e03882c9640f95eb17250638315", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxNDEwNw==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532514107", "bodyText": "Yes, see acfa17b.", "author": "DaveCTurner", "createdAt": "2020-11-30T11:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQxODE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQzNjEyMA==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532436120", "bodyText": "I think toNanoSeconds on the up-rounded value can result in IllegalArgumentException?", "author": "henningandersen", "createdAt": "2020-11-30T08:59:21Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/DateFieldMapperTests.java", "diffHunk": "@@ -333,4 +338,27 @@ public void testFetchDocValuesNanos() throws IOException {\n         assertEquals(List.of(date), fetchFromDocValues(mapperService, ft, format, date));\n         assertEquals(List.of(\"2020-05-15T21:33:02.123Z\"), fetchFromDocValues(mapperService, ft, format, 1589578382123L));\n     }\n+\n+    public void testResolutionRounding() {\n+        final long millis = randomLong();\n+        assertThat(DateFieldMapper.Resolution.MILLISECONDS.roundDownToMillis(millis), equalTo(millis));\n+        assertThat(DateFieldMapper.Resolution.MILLISECONDS.roundUpToMillis(millis), equalTo(millis));\n+\n+        final long nanos = randomNonNegativeLong();\n+        final long down = DateFieldMapper.Resolution.NANOSECONDS.roundDownToMillis(nanos);\n+        assertThat(DateUtils.toNanoSeconds(down), lessThanOrEqualTo(nanos));\n+        try {\n+            assertThat(DateUtils.toNanoSeconds(down + 1), greaterThan(nanos));\n+        } catch (IllegalArgumentException e) {\n+            // ok, down+1 was out of range\n+        }\n+\n+        final long up = DateFieldMapper.Resolution.NANOSECONDS.roundUpToMillis(nanos);\n+        assertThat(DateUtils.toNanoSeconds(up), greaterThanOrEqualTo(nanos));", "originalCommit": "1f1d5f7f8f867e03882c9640f95eb17250638315", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxNDA0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532514041", "bodyText": "Ah yes, good point. Mind you if you care about this level of improbability then you should be ok with how often IndexLongFieldRangeTestUtils#randomSpecificRange() returns EMPTY \ud83d\ude09\nAddressed in 214b6b7.", "author": "DaveCTurner", "createdAt": "2020-11-30T11:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQzNjEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ0NDIzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532444235", "bodyText": "Maybe also return EMPTY sometimes?", "author": "henningandersen", "createdAt": "2020-11-30T09:13:29Z", "path": "server/src/test/java/org/elasticsearch/index/shard/IndexLongFieldRangeWireTests.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.test.AbstractWireSerializingTestCase;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import static org.elasticsearch.index.shard.IndexLongFieldRangeTestUtils.checkForSameInstances;\n+import static org.elasticsearch.index.shard.IndexLongFieldRangeTestUtils.randomRange;\n+\n+public class IndexLongFieldRangeWireTests extends AbstractWireSerializingTestCase<IndexLongFieldRange> {\n+    @Override\n+    protected Writeable.Reader<IndexLongFieldRange> instanceReader() {\n+        return IndexLongFieldRange::readFrom;\n+    }\n+\n+    @Override\n+    protected IndexLongFieldRange createTestInstance() {\n+        return randomRange();\n+    }\n+\n+    @Override\n+    protected IndexLongFieldRange mutateInstance(IndexLongFieldRange instance) throws IOException {", "originalCommit": "1f1d5f7f8f867e03882c9640f95eb17250638315", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMTE2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532511169", "bodyText": "IndexLongFieldRangeTestUtils#randomSpecificRange() already returns EMPTY sometimes. It's not fantastically likely but it happens often enough.", "author": "DaveCTurner", "createdAt": "2020-11-30T10:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ0NDIzNQ=="}], "type": "inlineReview"}, {"oid": "fe4caef3dd19f7bab5d2c65d676a7a5066427d22", "url": "https://github.com/elastic/elasticsearch/commit/fe4caef3dd19f7bab5d2c65d676a7a5066427d22", "message": "Merge branch 'master' into 2020-11-24-record-timestamp-field-range-in-index-metadata", "committedDate": "2020-11-30T10:43:19Z", "type": "commit"}, {"oid": "27b7f3868af7bf6cbdc803c35f1c4e3b5cfabeea", "url": "https://github.com/elastic/elasticsearch/commit/27b7f3868af7bf6cbdc803c35f1c4e3b5cfabeea", "message": "Stronger assertion", "committedDate": "2020-11-30T10:50:10Z", "type": "commit"}, {"oid": "acfa17b451ba2352162eb6e47afa61d64cda2df7", "url": "https://github.com/elastic/elasticsearch/commit/acfa17b451ba2352162eb6e47afa61d64cda2df7", "message": "Assert timestamp range complete when all primaries started", "committedDate": "2020-11-30T10:56:12Z", "type": "commit"}, {"oid": "214b6b79783afbd6f77e286221cb2fcdddaf08cd", "url": "https://github.com/elastic/elasticsearch/commit/214b6b79783afbd6f77e286221cb2fcdddaf08cd", "message": "Deal with rounding up out-of-range", "committedDate": "2020-11-30T11:02:28Z", "type": "commit"}, {"oid": "fb48dca4976d8d3e27fedb5d090fa03800a8297f", "url": "https://github.com/elastic/elasticsearch/commit/fb48dca4976d8d3e27fedb5d090fa03800a8297f", "message": "Assertion message", "committedDate": "2020-11-30T13:05:16Z", "type": "commit"}, {"oid": "d6585ecbcc71d55689cbe598b8be04497a2a0f15", "url": "https://github.com/elastic/elasticsearch/commit/d6585ecbcc71d55689cbe598b8be04497a2a0f15", "message": "Oops", "committedDate": "2020-11-30T13:05:57Z", "type": "commit"}, {"oid": "c3d35f9add7e67613a5ea5bb376f933cf1955e48", "url": "https://github.com/elastic/elasticsearch/commit/c3d35f9add7e67613a5ea5bb376f933cf1955e48", "message": "Introduce ILFR#removeShard", "committedDate": "2020-11-30T13:05:57Z", "type": "commit"}, {"oid": "c07217570099e0d17b1e224d27320e49c683d1f2", "url": "https://github.com/elastic/elasticsearch/commit/c07217570099e0d17b1e224d27320e49c683d1f2", "message": "Remove shard from range when allocating stale primary", "committedDate": "2020-11-30T13:05:58Z", "type": "commit"}, {"oid": "efa98b3160b9db8c8670c8eab4b6e744e47dfb64", "url": "https://github.com/elastic/elasticsearch/commit/efa98b3160b9db8c8670c8eab4b6e744e47dfb64", "message": "Precommit", "committedDate": "2020-11-30T13:15:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUyMzc4OA==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532523788", "bodyText": "nit: can we extract these constants to a static field?", "author": "fcofdez", "createdAt": "2020-11-30T11:21:02Z", "path": "server/src/main/java/org/elasticsearch/index/shard/IndexLongFieldRange.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.index.shard.ShardLongFieldRange.LONG_FIELD_RANGE_VERSION_INTRODUCED;\n+\n+/**\n+ * Class representing an (inclusive) range of {@code long} values in a field in an index which may comprise multiple shards. This\n+ * information is accumulated shard-by-shard, and we keep track of which shards are represented in this value. Only once all shards are\n+ * represented should this information be considered accurate for the index.\n+ */\n+public class IndexLongFieldRange implements Writeable, ToXContentFragment {\n+\n+    /**\n+     * Sentinel value indicating that no information is currently available, for instance because the index has just been created.\n+     */\n+    public static final IndexLongFieldRange UNKNOWN = new IndexLongFieldRange(new int[0], Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating an empty range, for instance because the field is missing or has no values in any shard.\n+     */\n+    public static final IndexLongFieldRange EMPTY = new IndexLongFieldRange(null, Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating the actual range may change in the future.\n+     */\n+    public static final IndexLongFieldRange MUTABLE = new IndexLongFieldRange(null, Long.MIN_VALUE, Long.MAX_VALUE);\n+\n+    @Nullable // if this range includes all shards\n+    private final int[] shards;\n+    private final long min, max;\n+\n+    private IndexLongFieldRange(int[] shards, long min, long max) {\n+        assert (min == Long.MAX_VALUE && max == Long.MIN_VALUE) || min <= max : min + \" vs \" + max;\n+        assert shards == null || shards.length > 0 || (min == Long.MAX_VALUE && max == Long.MIN_VALUE);\n+        assert shards == null || Arrays.equals(shards, Arrays.stream(shards).sorted().distinct().toArray()) : Arrays.toString(shards);\n+        this.shards = shards;\n+        this.min = min;\n+        this.max = max;\n+    }\n+\n+    /**\n+     * @return whether this range includes information from all shards yet.\n+     */\n+    public boolean isComplete() {\n+        return shards == null;\n+    }\n+\n+    // exposed for testing\n+    int[] getShards() {\n+        return shards;\n+    }\n+\n+    // exposed for testing\n+    long getMinUnsafe() {\n+        return min;\n+    }\n+\n+    // exposed for testing\n+    long getMaxUnsafe() {\n+        return min;\n+    }\n+\n+    /**\n+     * @return the (inclusive) minimum of this range.\n+     */\n+    public long getMin() {\n+        assert shards == null : \"min is meaningless if we don't have data from all shards yet\";\n+        assert this != EMPTY : \"min is meaningless if range is empty\";\n+        assert this != MUTABLE : \"min is meaningless if range is mutable\";\n+        return min;\n+    }\n+\n+    /**\n+     * @return the (inclusive) maximum of this range.\n+     */\n+    public long getMax() {\n+        assert shards == null : \"max is meaningless if we don't have data from all shards yet\";\n+        assert this != EMPTY : \"max is meaningless if range is empty\";\n+        assert this != MUTABLE : \"max is meaningless if range is mutable\";\n+        return max;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        if (out.getVersion().onOrAfter(LONG_FIELD_RANGE_VERSION_INTRODUCED)) {\n+            if (this == UNKNOWN) {\n+                out.writeByte((byte) 1);", "originalCommit": "214b6b79783afbd6f77e286221cb2fcdddaf08cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYxODczNw==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532618737", "bodyText": "Yep, see a978aea.", "author": "DaveCTurner", "createdAt": "2020-11-30T14:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUyMzc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5Njg2OA==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532596868", "bodyText": "I was thinking that we might want to consider EMPTY and MUTABLE sentinel values as incomplete, so we can avoid triggering the query rewrite on the coordinator in the cases where we don't know the field range. wdyt @DaveCTurner ?", "author": "fcofdez", "createdAt": "2020-11-30T13:30:03Z", "path": "server/src/main/java/org/elasticsearch/index/shard/IndexLongFieldRange.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.index.shard.ShardLongFieldRange.LONG_FIELD_RANGE_VERSION_INTRODUCED;\n+\n+/**\n+ * Class representing an (inclusive) range of {@code long} values in a field in an index which may comprise multiple shards. This\n+ * information is accumulated shard-by-shard, and we keep track of which shards are represented in this value. Only once all shards are\n+ * represented should this information be considered accurate for the index.\n+ */\n+public class IndexLongFieldRange implements Writeable, ToXContentFragment {\n+\n+    /**\n+     * Sentinel value indicating that no information is currently available, for instance because the index has just been created.\n+     */\n+    public static final IndexLongFieldRange UNKNOWN = new IndexLongFieldRange(new int[0], Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating an empty range, for instance because the field is missing or has no values in any shard.\n+     */\n+    public static final IndexLongFieldRange EMPTY = new IndexLongFieldRange(null, Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating the actual range may change in the future.\n+     */\n+    public static final IndexLongFieldRange MUTABLE = new IndexLongFieldRange(null, Long.MIN_VALUE, Long.MAX_VALUE);", "originalCommit": "efa98b3160b9db8c8670c8eab4b6e744e47dfb64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYwNTM1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532605359", "bodyText": "I'm leaving that logic up to you \ud83d\ude04 I definitely think they're both complete, but if you want to implement some of the coordinator-node-side logic as more methods on IndexLongFieldRange then that's fine by me.\nThe EMPTY case sounds to me to be suitable for rewriting on the coordinator: if we require docs with a timestamp in a certain range, and the index contains no docs with a timestamp, then should we not skip this index?", "author": "DaveCTurner", "createdAt": "2020-11-30T13:43:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5Njg2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYwOTA3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532609073", "bodyText": "\ud83d\udc4d\nYou're right, for the EMPTY case we can skip the shard on the coordinator.", "author": "fcofdez", "createdAt": "2020-11-30T13:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5Njg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5NzQ1MA==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532597450", "bodyText": "nit: can we extract these constants to a static field?", "author": "fcofdez", "createdAt": "2020-11-30T13:30:58Z", "path": "server/src/main/java/org/elasticsearch/index/shard/ShardLongFieldRange.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Class representing an (inclusive) range of {@code long} values in a field in a single shard.\n+ */\n+public class ShardLongFieldRange implements Writeable {\n+\n+    static final Version LONG_FIELD_RANGE_VERSION_INTRODUCED = Version.V_8_0_0;\n+\n+    /**\n+     * Sentinel value indicating an empty range, for instance because the field is missing or has no values.\n+     */\n+    public static final ShardLongFieldRange EMPTY = new ShardLongFieldRange(Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating the actual range may change in the future.\n+     */\n+    public static final ShardLongFieldRange MUTABLE = new ShardLongFieldRange(Long.MIN_VALUE, Long.MAX_VALUE);\n+\n+    /**\n+     * Construct a new {@link ShardLongFieldRange} with the given (inclusive) minimum and maximum.\n+     */\n+    public static ShardLongFieldRange of(long min, long max) {\n+        assert min <= max : min + \" vs \" + max;\n+        return new ShardLongFieldRange(min, max);\n+    }\n+\n+    private final long min, max;\n+\n+    private ShardLongFieldRange(long min, long max) {\n+        this.min = min;\n+        this.max = max;\n+    }\n+\n+    /**\n+     * @return the (inclusive) minimum of this range.\n+     */\n+    public long getMin() {\n+        assert this != EMPTY && this != MUTABLE && min <= max: \"must not use actual min of sentinel values\";\n+        return min;\n+    }\n+\n+    /**\n+     * @return the (inclusive) maximum of this range.\n+     */\n+    public long getMax() {\n+        assert this != EMPTY && this != MUTABLE && min <= max : \"must not use actual max of sentinel values\";\n+        return max;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (this == MUTABLE) {\n+            return \"MUTABLE\";\n+        } else if (this == EMPTY) {\n+            return \"EMPTY\";\n+        } else {\n+            return \"[\" + min + \"-\" + max + \"]\";\n+        }\n+    }\n+\n+    public static ShardLongFieldRange readFrom(StreamInput in) throws IOException {\n+        if (in.getVersion().before(LONG_FIELD_RANGE_VERSION_INTRODUCED)) {\n+            // conservative treatment for BWC\n+            return MUTABLE;\n+        }\n+\n+        final byte type = in.readByte();\n+        switch (type) {\n+            case 1:", "originalCommit": "efa98b3160b9db8c8670c8eab4b6e744e47dfb64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYxODY5MA==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532618690", "bodyText": "Yep, see a978aea.", "author": "DaveCTurner", "createdAt": "2020-11-30T14:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5NzQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5ODMzNg==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532598336", "bodyText": "maybe ShardLongFieldRange belongs to RecoveryState?", "author": "fcofdez", "createdAt": "2020-11-30T13:32:25Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "diffHunk": "@@ -271,7 +272,7 @@ public static StartRecoveryRequest getStartRecoveryRequest(Logger logger, Discov\n     }\n \n     public interface RecoveryListener {\n-        void onRecoveryDone(RecoveryState state);\n+        void onRecoveryDone(RecoveryState state, ShardLongFieldRange timestampMillisFieldRange);", "originalCommit": "efa98b3160b9db8c8670c8eab4b6e744e47dfb64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYwODg3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r532608871", "bodyText": "Hmm, RecoveryState is really just about progress tracking, I'd prefer to keep this separate. If we were passing it around everywhere then I might change my thinking, but most places that want a RecoveryState don't care about the timestamp range.", "author": "DaveCTurner", "createdAt": "2020-11-30T13:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5ODMzNg=="}], "type": "inlineReview"}, {"oid": "a978aea54f52d357ab41bbc38d89fd26df3dd797", "url": "https://github.com/elastic/elasticsearch/commit/a978aea54f52d357ab41bbc38d89fd26df3dd797", "message": "Name the magic numbers", "committedDate": "2020-11-30T13:51:05Z", "type": "commit"}, {"oid": "9cfdcf3617be57d1b74dc547567d6f5a71b2d0d9", "url": "https://github.com/elastic/elasticsearch/commit/9cfdcf3617be57d1b74dc547567d6f5a71b2d0d9", "message": "Fix serialization test", "committedDate": "2020-11-30T14:23:37Z", "type": "commit"}, {"oid": "9bf52c084fc792fedd1d6ddbdc4ff9f3e0f4f2ae", "url": "https://github.com/elastic/elasticsearch/commit/9bf52c084fc792fedd1d6ddbdc4ff9f3e0f4f2ae", "message": "Wipe out range when closing indices too", "committedDate": "2020-11-30T14:46:18Z", "type": "commit"}, {"oid": "e40f9a13a5de3b4cda3ca44c81dd5aeaca21d409", "url": "https://github.com/elastic/elasticsearch/commit/e40f9a13a5de3b4cda3ca44c81dd5aeaca21d409", "message": "Fix assertions", "committedDate": "2020-11-30T15:39:48Z", "type": "commit"}, {"oid": "dc47717ee2f31eaa7f6a41761bebed906f1e9b53", "url": "https://github.com/elastic/elasticsearch/commit/dc47717ee2f31eaa7f6a41761bebed906f1e9b53", "message": "Merge branch 'master' into 2020-11-24-record-timestamp-field-range-in-index-metadata", "committedDate": "2020-11-30T17:25:34Z", "type": "commit"}, {"oid": "a4e43c01123ebb684994d43a5a1729d943ec1548", "url": "https://github.com/elastic/elasticsearch/commit/a4e43c01123ebb684994d43a5a1729d943ec1548", "message": "D'oh", "committedDate": "2020-11-30T17:56:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE3Mjc3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533172771", "bodyText": "I think this should be MUTABLE? We should only return empty when mappedFieldType == null.", "author": "henningandersen", "createdAt": "2020-12-01T08:55:21Z", "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -1715,6 +1718,46 @@ public RecoveryState recoveryState() {\n         return this.recoveryState;\n     }\n \n+    @Override\n+    public ShardLongFieldRange getTimestampMillisRange() {\n+        assert isReadAllowed();\n+\n+        if (mapperService() == null) {\n+            return ShardLongFieldRange.MUTABLE; // no mapper service, no idea if the field even exists\n+        }\n+        final MappedFieldType mappedFieldType = mapperService().fieldType(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD);\n+        final boolean hasMappedTimestampField = mappedFieldType instanceof DateFieldMapper.DateFieldType;\n+\n+        final Engine engine = getEngine();\n+        final ShardLongFieldRange rawTimestampFieldRange;\n+        try {\n+            rawTimestampFieldRange = engine.getRawFieldRange(DataStream.TimestampField.FIXED_TIMESTAMP_FIELD, hasMappedTimestampField);\n+        } catch (IOException e) {\n+            logger.debug(\"exception obtaining range for timestamp field\", e);\n+            return ShardLongFieldRange.MUTABLE;\n+        }\n+        if (rawTimestampFieldRange == ShardLongFieldRange.MUTABLE) {\n+            return ShardLongFieldRange.MUTABLE;\n+        }\n+        if (rawTimestampFieldRange == ShardLongFieldRange.EMPTY) {\n+            return ShardLongFieldRange.EMPTY;\n+        }\n+\n+        if (hasMappedTimestampField == false) {\n+            return ShardLongFieldRange.EMPTY;", "originalCommit": "a4e43c01123ebb684994d43a5a1729d943ec1548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1MDM4NA==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533350384", "bodyText": "My expectation was that if we have a field called @timestamp that isn't mapped as a date, and the query contains a date-range filter on the @timestamp field, then this shard simply doesn't match. @fcofdez since you're thinking about the logic on the coordinating node, what would you prefer here?", "author": "DaveCTurner", "createdAt": "2020-12-01T11:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE3Mjc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2NTEzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533365139", "bodyText": "I think it would make sense to return a MUTABLE instance, and rely on the actual mappings to decide wether or not to apply the filtering?", "author": "fcofdez", "createdAt": "2020-12-01T12:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE3Mjc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2NjQ1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533366452", "bodyText": "Ok, done in c0b0ea3.", "author": "DaveCTurner", "createdAt": "2020-12-01T12:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE3Mjc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2NjYyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533366629", "bodyText": "The implicit thinking behind making it MUTABLE here is that it is the better way to inform the search part that this is not a date field. This would at least avoid the coordinator having to figure out if a range query for @timestamp targets a date field or not. Initially, we intended no mapping info to be available on the coordinator making this important. It still feels more right to me, since we then avoid checking if the mapping is a date mapping on coordinator.", "author": "henningandersen", "createdAt": "2020-12-01T12:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE3Mjc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2OTU0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533369549", "bodyText": "Eh actually it's never false by the time we get here so the point is moot. I switched it for an assertion in 04bd754.", "author": "DaveCTurner", "createdAt": "2020-12-01T12:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE3Mjc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3NjQ2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533376467", "bodyText": "ahh, but then the interpretation of the isMappedField flag in ReadOnlyEngine is imprecise, since it assumes that it is not mapped at all, while it could be mapped just not as a date. I wonder if we should just skip calling the engine if it is mapped as anything but a date, returning UNKNOWN in that case?", "author": "henningandersen", "createdAt": "2020-12-01T12:37:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE3Mjc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4OTgxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533389811", "bodyText": "Ah, good point, this is the actual location of the logic we're discussing. Yes, having it return UNKNOWN there in any case without even hitting the engine is fine, see c4b497e.", "author": "DaveCTurner", "createdAt": "2020-12-01T13:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE3Mjc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI2ODE2NA==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533268164", "bodyText": "I would prefer to rename MUTABLE to UNKNOWN and use UNFILLED (or a nicer english word) for the no information case.\nI think UNKNOWN better captures the state where we do started shards but do not know the range.", "author": "henningandersen", "createdAt": "2020-12-01T10:08:33Z", "path": "server/src/main/java/org/elasticsearch/index/shard/IndexLongFieldRange.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.index.shard.ShardLongFieldRange.LONG_FIELD_RANGE_VERSION_INTRODUCED;\n+\n+/**\n+ * Class representing an (inclusive) range of {@code long} values in a field in an index which may comprise multiple shards. This\n+ * information is accumulated shard-by-shard, and we keep track of which shards are represented in this value. Only once all shards are\n+ * represented should this information be considered accurate for the index.\n+ */\n+public class IndexLongFieldRange implements Writeable, ToXContentFragment {\n+\n+    /**\n+     * Sentinel value indicating that no information is currently available, for instance because the index has just been created.\n+     */\n+    public static final IndexLongFieldRange UNKNOWN = new IndexLongFieldRange(new int[0], Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating an empty range, for instance because the field is missing or has no values in any shard.\n+     */\n+    public static final IndexLongFieldRange EMPTY = new IndexLongFieldRange(null, Long.MAX_VALUE, Long.MIN_VALUE);\n+\n+    /**\n+     * Sentinel value indicating the actual range may change in the future.\n+     */\n+    public static final IndexLongFieldRange MUTABLE = new IndexLongFieldRange(null, Long.MIN_VALUE, Long.MAX_VALUE);", "originalCommit": "a4e43c01123ebb684994d43a5a1729d943ec1548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1OTY4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533359686", "bodyText": "I initially rejected UNKNOWN here since I felt it might be taken as an implication that it might become known in future, whereas MUTABLE is more immutable \ud83d\ude01 But I'm ok with this renaming. I've renamed UNKNOWN to NO_SHARDS too.", "author": "DaveCTurner", "createdAt": "2020-12-01T12:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI2ODE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3NTIwMA==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533275200", "bodyText": "I think we could allow going from MUTABLE to UNKNOWN in the single shard case, i.e., move this below the if-statement below?", "author": "henningandersen", "createdAt": "2020-12-01T10:14:35Z", "path": "server/src/main/java/org/elasticsearch/index/shard/IndexLongFieldRange.java", "diffHunk": "@@ -335,4 +342,30 @@ public int hashCode() {\n         result = 31 * result + Arrays.hashCode(shards);\n         return result;\n     }\n+\n+    /**\n+     * Remove the given shard from the set of known shards, possibly without adjusting the min and max. Used when allocating a stale primary\n+     * which may have a different range from the original, so we must allow the range to grow. Note that this doesn't usually allow the\n+     * range to shrink, so we may in theory hit this shard more than needed after allocating a stale primary.\n+     */\n+    public IndexLongFieldRange removeShard(int shardId, int numberOfShards) {\n+        assert 0 <= shardId && shardId < numberOfShards : shardId + \" vs \" + numberOfShards;\n+\n+        if (shards != null && Arrays.stream(shards).noneMatch(i -> i == shardId)) {\n+            return this;\n+        }\n+        if (this == MUTABLE) {", "originalCommit": "a4e43c01123ebb684994d43a5a1729d943ec1548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2MDAxMA==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533360010", "bodyText": "True, addressed in 5bc657e.", "author": "DaveCTurner", "createdAt": "2020-12-01T12:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3NTIwMA=="}], "type": "inlineReview"}, {"oid": "f2f71d92730008334491d736f7dfb081d729f1bb", "url": "https://github.com/elastic/elasticsearch/commit/f2f71d92730008334491d736f7dfb081d729f1bb", "message": "Merge branch 'master' into 2020-11-24-record-timestamp-field-range-in-index-metadata", "committedDate": "2020-12-01T11:47:47Z", "type": "commit"}, {"oid": "2c08ee780013b8c270a1d381612bc9386a3c685d", "url": "https://github.com/elastic/elasticsearch/commit/2c08ee780013b8c270a1d381612bc9386a3c685d", "message": "Rename ILFR: UNKNOWN -> NO_SHARDS and MUTABLE -> UNKNOWN", "committedDate": "2020-12-01T11:56:38Z", "type": "commit"}, {"oid": "c2d15b258161f4714682d47949b0d3734d8aff33", "url": "https://github.com/elastic/elasticsearch/commit/c2d15b258161f4714682d47949b0d3734d8aff33", "message": "Rename SLFR: MUTABLE -> UNKNOWN", "committedDate": "2020-12-01T11:58:52Z", "type": "commit"}, {"oid": "5bc657e3a069cbb97683897cb41308c36ce80cbe", "url": "https://github.com/elastic/elasticsearch/commit/5bc657e3a069cbb97683897cb41308c36ce80cbe", "message": "One-shard case can move back to NO_SHARDS", "committedDate": "2020-12-01T12:03:00Z", "type": "commit"}, {"oid": "c0b0ea373b142a03796db0bdc852d19bffe307d7", "url": "https://github.com/elastic/elasticsearch/commit/c0b0ea373b142a03796db0bdc852d19bffe307d7", "message": "UNKNOWN if timestamp field isn't a timestamp", "committedDate": "2020-12-01T12:18:53Z", "type": "commit"}, {"oid": "04bd7541a4aeaa05850e364054df9fe9c019694b", "url": "https://github.com/elastic/elasticsearch/commit/04bd7541a4aeaa05850e364054df9fe9c019694b", "message": "Never false, so assert", "committedDate": "2020-12-01T12:24:36Z", "type": "commit"}, {"oid": "c4b497e0a241429082f5ac43bf0b8e5487ffe50b", "url": "https://github.com/elastic/elasticsearch/commit/c4b497e0a241429082f5ac43bf0b8e5487ffe50b", "message": "Return UNKNOWN if field is missing or not a date", "committedDate": "2020-12-01T12:55:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5MzA0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533393045", "bodyText": "nit: rename:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testMutableShardImpliesMutableIndex() {\n          \n          \n            \n                public void testUnknownShardImpliesUnknownIndex() {", "author": "henningandersen", "createdAt": "2020-12-01T13:07:05Z", "path": "server/src/test/java/org/elasticsearch/index/shard/IndexLongFieldRangeTests.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.index.shard.IndexLongFieldRangeTestUtils.randomSpecificRange;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class IndexLongFieldRangeTests extends ESTestCase {\n+\n+    public void testMutableShardImpliesMutableIndex() {", "originalCommit": "c4b497e0a241429082f5ac43bf0b8e5487ffe50b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5MzUzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65564#discussion_r533393539", "bodyText": "nit: rename:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testExtendMutableRangeIsNoOp() {\n          \n          \n            \n                public void testExtendUnknownRangeIsNoOp() {", "author": "henningandersen", "createdAt": "2020-12-01T13:07:58Z", "path": "server/src/test/java/org/elasticsearch/index/shard/IndexLongFieldRangeTests.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.index.shard.IndexLongFieldRangeTestUtils.randomSpecificRange;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.sameInstance;\n+\n+public class IndexLongFieldRangeTests extends ESTestCase {\n+\n+    public void testMutableShardImpliesMutableIndex() {\n+        final IndexLongFieldRange range = randomSpecificRange(false);\n+        assertThat(range.extendWithShardRange(\n+                IntStream.of(range.getShards()).max().orElse(0) + 1,\n+                between(1, 10),\n+                ShardLongFieldRange.UNKNOWN),\n+                sameInstance(IndexLongFieldRange.UNKNOWN));\n+    }\n+\n+    public void testExtendWithKnownShardIsNoOp() {\n+        IndexLongFieldRange range = randomSpecificRange();\n+        if (range == IndexLongFieldRange.NO_SHARDS) {\n+            // need at least one known shard\n+            range = range.extendWithShardRange(between(0, 5), 5, ShardLongFieldRange.EMPTY);\n+        }\n+\n+        final ShardLongFieldRange shardRange;\n+        if (range.getMinUnsafe() == IndexLongFieldRange.EMPTY.getMinUnsafe()\n+                && range.getMaxUnsafe() == IndexLongFieldRange.EMPTY.getMaxUnsafe()) {\n+            shardRange = ShardLongFieldRange.EMPTY;\n+        } else {\n+            final long min = randomLongBetween(range.getMinUnsafe(), range.getMaxUnsafe());\n+            final long max = randomLongBetween(min, range.getMaxUnsafe());\n+            shardRange = randomBoolean() ? ShardLongFieldRange.EMPTY : ShardLongFieldRange.of(min, max);\n+        }\n+\n+        assertThat(range.extendWithShardRange(\n+                range.isComplete() ? between(1, 10) : randomFrom(IntStream.of(range.getShards()).boxed().collect(Collectors.toList())),\n+                between(1, 10),\n+                shardRange),\n+                sameInstance(range));\n+    }\n+\n+    public void testExtendMutableRangeIsNoOp() {", "originalCommit": "c4b497e0a241429082f5ac43bf0b8e5487ffe50b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "962cae18e0142759999b1e56c62b48e23e4247c0", "url": "https://github.com/elastic/elasticsearch/commit/962cae18e0142759999b1e56c62b48e23e4247c0", "message": "Test names", "committedDate": "2020-12-01T13:41:00Z", "type": "commit"}]}