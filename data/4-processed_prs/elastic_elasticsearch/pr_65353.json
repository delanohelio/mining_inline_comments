{"pr_number": 65353, "pr_title": "QL: Combine multiple equal queries into In", "pr_createdAt": "2020-11-23T11:20:53Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65353", "timeline": [{"oid": "437b89310d6fd731214739f08be36748864231e4", "url": "https://github.com/elastic/elasticsearch/commit/437b89310d6fd731214739f08be36748864231e4", "message": "QL: Combine multiple equal queries into In\n\nSome queries can have an excessive number of OR clauses on the same\nfield (typically by being generated). This can lead to large query\nrequests that can cause SO errors.\nThis PR tries to address this pattern by combining the equals into an\nIn expression which in turn gets compressed into a terms query vs one\nterm query per entry.\n\nFix #62804\nFix #46477", "committedDate": "2020-11-23T11:21:44Z", "type": "forcePushed"}, {"oid": "593c63dae6cb74f9517b11af7a1eb75a5b286b72", "url": "https://github.com/elastic/elasticsearch/commit/593c63dae6cb74f9517b11af7a1eb75a5b286b72", "message": "QL: Combine multiple equal queries into In\n\nSome queries can have an excessive number of OR clauses on the same\nfield (typically by being generated). This can lead to large query\nrequests that can cause SO errors.\nThis PR tries to address this pattern by combining the equals into an\nIn expression which in turn gets compressed into a terms query vs one\nterm query per entry.\n\nFix #62804\nFix #46477", "committedDate": "2020-11-23T11:41:31Z", "type": "forcePushed"}, {"oid": "4509198c29d1290315a91ba10cb04ef2c6b451c6", "url": "https://github.com/elastic/elasticsearch/commit/4509198c29d1290315a91ba10cb04ef2c6b451c6", "message": "Don't lose unpicked expressions", "committedDate": "2020-11-23T15:03:21Z", "type": "forcePushed"}, {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "url": "https://github.com/elastic/elasticsearch/commit/28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "message": "QL: Combine multiple equal queries into In\n\nSome queries can have an excessive number of OR clauses on the same\nfield (typically by being generated). This can lead to large query\nrequests that can cause SO errors.\nThis PR tries to address this pattern by combining the equals into an\nIn expression which in turn gets compressed into a terms query vs one\nterm query per entry.\n\nFix #62804\nFix #46477", "committedDate": "2020-11-23T15:38:38Z", "type": "commit"}, {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "url": "https://github.com/elastic/elasticsearch/commit/28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "message": "QL: Combine multiple equal queries into In\n\nSome queries can have an excessive number of OR clauses on the same\nfield (typically by being generated). This can lead to large query\nrequests that can cause SO errors.\nThis PR tries to address this pattern by combining the equals into an\nIn expression which in turn gets compressed into a terms query vs one\nterm query per entry.\n\nFix #62804\nFix #46477", "committedDate": "2020-11-23T15:38:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzY0NA==", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528823644", "bodyText": "Why do you need a second zoneid variable? You could use zoneId.", "author": "astefan", "createdAt": "2020-11-23T16:13:02Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables\n+                        if (eq.right().foldable()) {\n+                            found.computeIfAbsent(eq.left(), k -> new LinkedHashSet<>()).add(eq.right());\n+                        } else {\n+                            ors.add(exp);\n+                        }\n+                        if (zoneId == null) {\n+                            zoneId = eq.zoneId();\n+                        }\n+                    }\n+                    else if (exp instanceof In) {\n+                        In in = (In) exp;\n+                        found.computeIfAbsent(in.value(), k -> new LinkedHashSet<>()).addAll(in.list());\n+                        if (zoneId == null) {\n+                            zoneId = in.zoneId();\n+                        }\n+                    } else {\n+                        ors.add(exp);\n+                    }\n+                }\n+\n+                if (found.isEmpty() == false) {\n+                    // combine equals alongside the existing ors\n+                    ZoneId finalZoneId = zoneId;", "originalCommit": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzNTI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528835263", "bodyText": "Lambda usage - the variable needs to be final...", "author": "costin", "createdAt": "2020-11-23T16:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg0MDk0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528840942", "bodyText": "Doesn't hurt to have a final in front of it ;-).", "author": "astefan", "createdAt": "2020-11-23T16:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzMDEyMA==", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528830120", "bodyText": "Leftover?", "author": "astefan", "createdAt": "2020-11-23T16:21:45Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -106,6 +107,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.startsWith;\n \n+@TestLogging(value = \"org.elasticsearch.xpack.sql:TRACE\", reason = \"debug\")", "originalCommit": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528823997", "bodyText": "nit: any reason to use the proxy finalZoneId? good practice?", "author": "bpintea", "createdAt": "2020-11-23T16:13:37Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables\n+                        if (eq.right().foldable()) {\n+                            found.computeIfAbsent(eq.left(), k -> new LinkedHashSet<>()).add(eq.right());\n+                        } else {\n+                            ors.add(exp);\n+                        }\n+                        if (zoneId == null) {\n+                            zoneId = eq.zoneId();\n+                        }\n+                    }\n+                    else if (exp instanceof In) {\n+                        In in = (In) exp;\n+                        found.computeIfAbsent(in.value(), k -> new LinkedHashSet<>()).addAll(in.list());\n+                        if (zoneId == null) {\n+                            zoneId = in.zoneId();\n+                        }\n+                    } else {\n+                        ors.add(exp);\n+                    }\n+                }\n+\n+                if (found.isEmpty() == false) {\n+                    // combine equals alongside the existing ors\n+                    ZoneId finalZoneId = zoneId;", "originalCommit": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2Mzc2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528863765", "bodyText": "See the previous comment", "author": "costin", "createdAt": "2020-11-23T17:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzNDQxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528834419", "bodyText": "QQ: I guess the IN could contain non foldable expressions? Wouldn't a similar check be useful for IN's elements?", "author": "bpintea", "createdAt": "2020-11-23T16:27:39Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables", "originalCommit": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2MzU5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528863597", "bodyText": "In requires all values to be foldable and checks this inside its resolveType. Hence why any In produced will only have foldable expressions.", "author": "costin", "createdAt": "2020-11-23T17:09:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzNDQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzODQ0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528838445", "bodyText": "was this left intentionally?", "author": "bpintea", "createdAt": "2020-11-23T16:33:11Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -106,6 +107,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.startsWith;\n \n+@TestLogging(value = \"org.elasticsearch.xpack.sql:TRACE\", reason = \"debug\")", "originalCommit": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2MzgzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528863835", "bodyText": "See Andrei's comment", "author": "costin", "createdAt": "2020-11-23T17:09:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzODQ0NQ=="}], "type": "inlineReview"}, {"oid": "bae8eaf6d9314667a3d4ac7c5055230728a930a6", "url": "https://github.com/elastic/elasticsearch/commit/bae8eaf6d9314667a3d4ac7c5055230728a930a6", "message": "Apply semantic check", "committedDate": "2020-11-23T17:06:28Z", "type": "forcePushed"}, {"oid": "246a453df2307e4c8073bf38dddbf54a1b6a3e7e", "url": "https://github.com/elastic/elasticsearch/commit/246a453df2307e4c8073bf38dddbf54a1b6a3e7e", "message": "Apply semantic check", "committedDate": "2020-11-23T17:07:50Z", "type": "forcePushed"}, {"oid": "ed2f9bcafe95ee4f85bdb3b4fdb9daed60dd0500", "url": "https://github.com/elastic/elasticsearch/commit/ed2f9bcafe95ee4f85bdb3b4fdb9daed60dd0500", "message": "Apply semantic check", "committedDate": "2020-11-23T17:48:29Z", "type": "commit"}, {"oid": "ed2f9bcafe95ee4f85bdb3b4fdb9daed60dd0500", "url": "https://github.com/elastic/elasticsearch/commit/ed2f9bcafe95ee4f85bdb3b4fdb9daed60dd0500", "message": "Apply semantic check", "committedDate": "2020-11-23T17:48:29Z", "type": "forcePushed"}, {"oid": "e4ba0f99d6cf89e1986b365abb730c894e571aba", "url": "https://github.com/elastic/elasticsearch/commit/e4ba0f99d6cf89e1986b365abb730c894e571aba", "message": "Fix tests", "committedDate": "2020-11-23T21:29:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1MTA0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r529051047", "bodyText": "Typo.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(e, e);\n          \n          \n            \n                    assertEquals(or, e);", "author": "palesz", "createdAt": "2020-11-23T22:59:51Z", "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRulesTests.java", "diffHunk": "@@ -1377,10 +1382,131 @@ public void testExactMatchRLike() throws Exception {\n         RLikePattern pattern = new RLikePattern(\"abc\");\n         FieldAttribute fa = getFieldAttribute();\n         RLike l = new RLike(EMPTY, fa, pattern);\n-        Expression e = new OptimizerRules.ReplaceRegexMatch().rule(l);\n+        Expression e = new ReplaceRegexMatch().rule(l);\n         assertEquals(Equals.class, e.getClass());\n         Equals eq = (Equals) e;\n         assertEquals(fa, eq.left());\n         assertEquals(\"abc\", eq.right().fold());\n     }\n+\n+    //\n+    // CombineDisjunction in Equals\n+    //\n+    public void testTwoEqualsWithOr() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), equalsOf(fa, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testTwoEqualsWithSameValue() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), equalsOf(fa, one));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(Equals.class, e.getClass());\n+        Equals eq = (Equals) e;\n+        assertEquals(fa, eq.left());\n+        assertEquals(one, eq.right());\n+    }\n+\n+    public void testOneEqualsOneIn() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), new In(EMPTY, fa, singletonList(two)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testOneEqualsOneInWithSameValue() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), new In(EMPTY, fa, asList(one, two)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testSingleValueInToEquals() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+\n+        Equals equals = equalsOf(fa, one);\n+        Or or = new Or(EMPTY, equals, new In(EMPTY, fa, singletonList(one)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(equals, e);\n+    }\n+\n+    public void testEqualsBehindAnd() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        And and = new And(EMPTY, equalsOf(fa, one), equalsOf(fa, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(and);\n+        assertEquals(and, e);\n+    }\n+\n+    public void testTwoEqualsDifferentFields() throws Exception {\n+        FieldAttribute fieldOne = getFieldAttribute(\"one\");\n+        FieldAttribute fieldTwo = getFieldAttribute(\"two\");\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fieldOne, one), equalsOf(fieldTwo, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(e, e);", "originalCommit": "e4ba0f99d6cf89e1986b365abb730c894e571aba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1MzY4OA==", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r529053688", "bodyText": "Super nit-picky. Would just test that there are no changes:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(LessThan.class, or.right().getClass());\n          \n          \n            \n                    LessThan lt = (LessThan) or.right();\n          \n          \n            \n                    assertEquals(fa, lt.left());\n          \n          \n            \n                    assertEquals(two, lt.right());\n          \n          \n            \n                    assertEquals(or.right(), firstOr.right());", "author": "palesz", "createdAt": "2020-11-23T23:06:00Z", "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRulesTests.java", "diffHunk": "@@ -1377,10 +1382,131 @@ public void testExactMatchRLike() throws Exception {\n         RLikePattern pattern = new RLikePattern(\"abc\");\n         FieldAttribute fa = getFieldAttribute();\n         RLike l = new RLike(EMPTY, fa, pattern);\n-        Expression e = new OptimizerRules.ReplaceRegexMatch().rule(l);\n+        Expression e = new ReplaceRegexMatch().rule(l);\n         assertEquals(Equals.class, e.getClass());\n         Equals eq = (Equals) e;\n         assertEquals(fa, eq.left());\n         assertEquals(\"abc\", eq.right().fold());\n     }\n+\n+    //\n+    // CombineDisjunction in Equals\n+    //\n+    public void testTwoEqualsWithOr() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), equalsOf(fa, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testTwoEqualsWithSameValue() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), equalsOf(fa, one));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(Equals.class, e.getClass());\n+        Equals eq = (Equals) e;\n+        assertEquals(fa, eq.left());\n+        assertEquals(one, eq.right());\n+    }\n+\n+    public void testOneEqualsOneIn() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), new In(EMPTY, fa, singletonList(two)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testOneEqualsOneInWithSameValue() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), new In(EMPTY, fa, asList(one, two)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testSingleValueInToEquals() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+\n+        Equals equals = equalsOf(fa, one);\n+        Or or = new Or(EMPTY, equals, new In(EMPTY, fa, singletonList(one)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(equals, e);\n+    }\n+\n+    public void testEqualsBehindAnd() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        And and = new And(EMPTY, equalsOf(fa, one), equalsOf(fa, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(and);\n+        assertEquals(and, e);\n+    }\n+\n+    public void testTwoEqualsDifferentFields() throws Exception {\n+        FieldAttribute fieldOne = getFieldAttribute(\"one\");\n+        FieldAttribute fieldTwo = getFieldAttribute(\"two\");\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fieldOne, one), equalsOf(fieldTwo, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(e, e);\n+    }\n+\n+    public void testMultipleIn() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+        Literal three = of(3);\n+\n+        Or firstOr = new Or(EMPTY, new In(EMPTY, fa, singletonList(one)), new In(EMPTY, fa, singletonList(two)));\n+        Or secondOr = new Or(EMPTY, firstOr, new In(EMPTY, fa, singletonList(three)));\n+        Expression e = new CombineDisjunctionsToIn().rule(secondOr);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two, three));\n+    }\n+\n+    public void testOrWithNonCombinableExpressions() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+        Literal three = of(3);\n+\n+        Or firstOr = new Or(EMPTY, new In(EMPTY, fa, singletonList(one)), lessThanOf(fa, two));\n+        Or secondOr = new Or(EMPTY, firstOr, new In(EMPTY, fa, singletonList(three)));\n+        Expression e = new CombineDisjunctionsToIn().rule(secondOr);\n+        assertEquals(Or.class, e.getClass());\n+        Or or = (Or) e;\n+        assertEquals(LessThan.class, or.right().getClass());\n+        LessThan lt = (LessThan) or.right();\n+        assertEquals(fa, lt.left());\n+        assertEquals(two, lt.right());", "originalCommit": "e4ba0f99d6cf89e1986b365abb730c894e571aba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e80d4a4d1a41d4c9ec145d2f7011b55b78cce2d1", "url": "https://github.com/elastic/elasticsearch/commit/e80d4a4d1a41d4c9ec145d2f7011b55b78cce2d1", "message": "Polish", "committedDate": "2020-11-24T08:16:59Z", "type": "commit"}, {"oid": "3068ffbbcbff2b8e14383757568f9b88300235b8", "url": "https://github.com/elastic/elasticsearch/commit/3068ffbbcbff2b8e14383757568f9b88300235b8", "message": "Merge branch 'master' into fix/46477", "committedDate": "2020-11-24T14:18:43Z", "type": "commit"}]}