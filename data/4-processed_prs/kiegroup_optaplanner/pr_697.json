{"pr_number": 697, "pr_title": "PLANNER-1864 Introduce neutral impact() scoring to Constraint Streams", "pr_createdAt": "2020-02-19T13:24:21Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/697", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NjQxNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/697#discussion_r381286415", "bodyText": "FYI Addition to public API.", "author": "triceo", "createdAt": "2020-02-19T13:24:41Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Constraint.java", "diffHunk": "@@ -64,4 +64,10 @@ default String getConstraintId() {\n         return ConstraintMatchTotal.composeConstraintId(getConstraintPackage(), getConstraintName());\n     }\n \n+    /**\n+     * Whether this constraint penalizes, rewards or mixes both.\n+     * @return never null\n+     */\n+    ScoreImpactType getScoreImpactType();", "originalCommit": "5761f97731de09a5b168c750b57252e27be0c97a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMzODk3Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/697#discussion_r381338976", "bodyText": "Who will use this?\n\nIf it's an end-user, what's the use case?\nIf it's for us, to do InitializedTrend magic later, I 'd rather not expose it in the public API (especially because there's no POC of the InitializedTrend magic (for which there is no bandwidth now)). Otherwise we BC promise it.\n\nIn the second case, we can put it in an AbstractConstraint or InnerConstraint class (a new class between Constraint and Drools/BavetConstraint). Wdyt?", "author": "ge0ffrey", "createdAt": "2020-02-19T14:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NjQxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM1OTA3OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/697#discussion_r381359079", "bodyText": "Sure, no problem.", "author": "triceo", "createdAt": "2020-02-19T15:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NjQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NzIxNw==", "url": "https://github.com/kiegroup/optaplanner/pull/697#discussion_r381287217", "bodyText": "Both BavetConstraint and DroolsConstraint get a shared superclass, to get some code reuse in there.", "author": "triceo", "createdAt": "2020-02-19T13:26:17Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraint.java", "diffHunk": "@@ -21,42 +21,27 @@\n import java.util.function.Function;\n \n import org.optaplanner.core.api.score.Score;\n-import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ScoreImpactType;\n import org.optaplanner.core.impl.score.stream.bavet.common.BavetNodeBuildPolicy;\n import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFromUniConstraintStream;\n import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFromUniNode;\n+import org.optaplanner.core.impl.score.stream.common.AbstractConstraint;\n \n-public final class BavetConstraint<Solution_> implements Constraint {\n+public final class BavetConstraint<Solution_> extends AbstractConstraint<Solution_, BavetConstraintFactory<Solution_>> {", "originalCommit": "5761f97731de09a5b168c750b57252e27be0c97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4320f3e1546d557c2aa2fcfdf25a889614e3cacd", "url": "https://github.com/kiegroup/optaplanner/commit/4320f3e1546d557c2aa2fcfdf25a889614e3cacd", "message": "Add the API", "committedDate": "2020-02-19T13:28:20Z", "type": "commit"}, {"oid": "4c836586fbce2f5ad89f79f6d91bd99a36a9963a", "url": "https://github.com/kiegroup/optaplanner/commit/4c836586fbce2f5ad89f79f6d91bd99a36a9963a", "message": "Implement the API", "committedDate": "2020-02-19T13:28:21Z", "type": "commit"}, {"oid": "d77ea76eaf522d22c81d5dd839b1212f3c1ff9dc", "url": "https://github.com/kiegroup/optaplanner/commit/d77ea76eaf522d22c81d5dd839b1212f3c1ff9dc", "message": "Refactor constraints", "committedDate": "2020-02-19T13:28:21Z", "type": "commit"}, {"oid": "aa59d99ef3e8a49a45ae9e90c2f2ad1707a3594c", "url": "https://github.com/kiegroup/optaplanner/commit/aa59d99ef3e8a49a45ae9e90c2f2ad1707a3594c", "message": "Remove some API that is not useful", "committedDate": "2020-02-19T13:28:21Z", "type": "commit"}, {"oid": "aa59d99ef3e8a49a45ae9e90c2f2ad1707a3594c", "url": "https://github.com/kiegroup/optaplanner/commit/aa59d99ef3e8a49a45ae9e90c2f2ad1707a3594c", "message": "Remove some API that is not useful", "committedDate": "2020-02-19T13:28:21Z", "type": "forcePushed"}, {"oid": "9d9c5f223b3b204459362679b9b4c29f6e8565ef", "url": "https://github.com/kiegroup/optaplanner/commit/9d9c5f223b3b204459362679b9b4c29f6e8565ef", "message": "Fix assertion logic", "committedDate": "2020-02-19T13:55:39Z", "type": "commit"}, {"oid": "127197e7f2e083390ac00f32e01f25615f45ea36", "url": "https://github.com/kiegroup/optaplanner/commit/127197e7f2e083390ac00f32e01f25615f45ea36", "message": "Remove needless indirection", "committedDate": "2020-02-19T13:56:37Z", "type": "commit"}, {"oid": "55a55460174b1d8c3996a02e5d36896e0de7bc77", "url": "https://github.com/kiegroup/optaplanner/commit/55a55460174b1d8c3996a02e5d36896e0de7bc77", "message": "Fix Revapi", "committedDate": "2020-02-19T14:03:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM0MTQ3NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/697#discussion_r381341475", "bodyText": "This is changing the javadocs to the implementation reality (of CS-D), today.\nWe should investigate the work for the reverse: change the implementation reality to adhere to the javadocs :)\nIn theory, it's matter of deactiving rules if the constraintWeight is zero. We should reopen that discussion with Mario for Rule.setEnabled(false).", "author": "ge0ffrey", "createdAt": "2020-02-19T14:52:47Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintStream.java", "diffHunk": "@@ -124,7 +124,7 @@ default Constraint penalize(String constraintName, Score<?> constraintWeight) {\n      * <p>\n      * The constraintWeight comes from an {@link ConstraintWeight} annotated member on the {@link ConstraintConfiguration},\n      * so end users can change the constraint weights dynamically.\n-     * This constraint is deactivated if the {@link ConstraintWeight} is zero.\n+     * This constraint may be deactivated if the {@link ConstraintWeight} is zero.", "originalCommit": "55a55460174b1d8c3996a02e5d36896e0de7bc77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM2Mjg1OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/697#discussion_r381362859", "bodyText": "I'm OK with talking to Mario. Yet, the Javadocs - in reality - are lying to users now. :-)", "author": "triceo", "createdAt": "2020-02-19T15:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM0MTQ3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM3OTgwOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/697#discussion_r381379809", "bodyText": "There is another option. We could rebuild the KieBase every time we create a new session. (Because at that point, we already know which constraints should be disabled.)\nSince there isn't any compilation (we're doing straight executable model), it shouldn't be too slow.", "author": "triceo", "createdAt": "2020-02-19T16:14:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM0MTQ3NQ=="}], "type": "inlineReview"}, {"oid": "2c99ed659b1068cd05ccf64e2815ef4ee8ff9f90", "url": "https://github.com/kiegroup/optaplanner/commit/2c99ed659b1068cd05ccf64e2815ef4ee8ff9f90", "message": "Add tests for uni", "committedDate": "2020-02-19T15:12:55Z", "type": "commit"}, {"oid": "e68384528718f5cd5c8b03c27b5b39b4dc2a0ff4", "url": "https://github.com/kiegroup/optaplanner/commit/e68384528718f5cd5c8b03c27b5b39b4dc2a0ff4", "message": "Add tests for bi", "committedDate": "2020-02-19T15:31:51Z", "type": "commit"}, {"oid": "533bc7015fb5f275a9be7b6af7642cda46248357", "url": "https://github.com/kiegroup/optaplanner/commit/533bc7015fb5f275a9be7b6af7642cda46248357", "message": "Add tests for tri", "committedDate": "2020-02-19T15:40:16Z", "type": "commit"}, {"oid": "d710601c8f33e06e0dae9268685285bd57c8def5", "url": "https://github.com/kiegroup/optaplanner/commit/d710601c8f33e06e0dae9268685285bd57c8def5", "message": "Finish the test coverage", "committedDate": "2020-02-19T15:47:02Z", "type": "commit"}, {"oid": "c998eec99735e507d57b61e782af45539dd44b2d", "url": "https://github.com/kiegroup/optaplanner/commit/c998eec99735e507d57b61e782af45539dd44b2d", "message": "Address code review comment", "committedDate": "2020-02-19T15:49:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1ODE0OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/697#discussion_r381858149", "bodyText": "This link (and other links to impactConfigurable below) is broken; I haven't found such a method.\nThe same for Bi,Tri and QuadConstraintStream classes.", "author": "rsynek", "createdAt": "2020-02-20T08:51:59Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -947,4 +947,163 @@ default Constraint rewardConfigurableBigDecimal(String constraintName, Function<\n     Constraint rewardConfigurableBigDecimal(String constraintPackage, String constraintName,\n             Function<A, BigDecimal> matchWeigher);\n \n+    /**\n+     * Positively or negatively impact the {@link Score} by the constraintWeight multiplied by the match weight.\n+     * Otherwise as defined by {@link #impact(String, Score)}.\n+     * <p>\n+     * For non-int {@link Score} types use {@link #impactLong(String, Score, ToLongFunction)} or\n+     * {@link #impactBigDecimal(String, Score, Function)} instead.\n+     * <p>\n+     * Use {@code penalize(...)} or {@code reward(...)} unless you intend to mix positive and negative weights.\n+     * @param constraintName never null, shows up in {@link ConstraintMatchTotal} during score justification\n+     * @param constraintWeight never null\n+     * @param matchWeigher never null, the result of this function (matchWeight) is multiplied by the constraintWeight\n+     * @return never null\n+     */\n+    default Constraint impact(String constraintName, Score<?> constraintWeight, ToIntFunction<A> matchWeigher) {\n+        return impact(getConstraintFactory().getDefaultConstraintPackage(), constraintName, constraintWeight,\n+                matchWeigher);\n+    }\n+\n+    /**\n+     * As defined by {@link #impact(String, Score, ToIntFunction)}.\n+     * @param constraintPackage never null\n+     * @param constraintName never null\n+     * @param constraintWeight never null\n+     * @param matchWeigher never null\n+     * @return never null\n+     */\n+    Constraint impact(String constraintPackage, String constraintName, Score<?> constraintWeight,\n+            ToIntFunction<A> matchWeigher);\n+\n+    /**\n+     * Positively or negatively impact the {@link Score} by the constraintWeight multiplied by the match weight.\n+     * Otherwise as defined by {@link #impact(String, Score)}.\n+     * <p>\n+     * Use {@code penalizeLong(...)} or {@code rewardLong(...)} unless you intend to mix positive and negative weights.\n+     * @param constraintName never null, shows up in {@link ConstraintMatchTotal} during score justification\n+     * @param constraintWeight never null\n+     * @param matchWeigher never null, the result of this function (matchWeight) is multiplied by the constraintWeight\n+     * @return never null\n+     */\n+    default Constraint impactLong(String constraintName, Score<?> constraintWeight, ToLongFunction<A> matchWeigher) {\n+        return impactLong(getConstraintFactory().getDefaultConstraintPackage(), constraintName, constraintWeight,\n+                matchWeigher);\n+    }\n+\n+    /**\n+     * As defined by {@link #impactLong(String, Score, ToLongFunction)}.\n+     * @param constraintPackage never null\n+     * @param constraintName never null\n+     * @param constraintWeight never null\n+     * @param matchWeigher never null\n+     * @return never null\n+     */\n+    Constraint impactLong(String constraintPackage, String constraintName, Score<?> constraintWeight,\n+            ToLongFunction<A> matchWeigher);\n+\n+    /**\n+     * Positively or negatively impact the {@link Score} by the constraintWeight multiplied by the match weight.\n+     * Otherwise as defined by {@link #impact(String, Score)}.\n+     * <p>\n+     * Use {@code penalizeBigDecimal(...)} or {@code rewardBigDecimal(...)} unless you intend to mix positive and\n+     * negative weights.\n+     * @param constraintName never null, shows up in {@link ConstraintMatchTotal} during score justification\n+     * @param constraintWeight never null\n+     * @param matchWeigher never null, the result of this function (matchWeight) is multiplied by the constraintWeight\n+     * @return never null\n+     */\n+    default Constraint impactBigDecimal(String constraintName, Score<?> constraintWeight,\n+            Function<A, BigDecimal> matchWeigher) {\n+        return impactBigDecimal(getConstraintFactory().getDefaultConstraintPackage(), constraintName,\n+                constraintWeight, matchWeigher);\n+    }\n+\n+    /**\n+     * As defined by {@link #impactBigDecimal(String, Score, Function)}.\n+     * @param constraintPackage never null\n+     * @param constraintName never null\n+     * @param constraintWeight never null\n+     * @param matchWeigher never null\n+     * @return never null\n+     */\n+    Constraint impactBigDecimal(String constraintPackage, String constraintName, Score<?> constraintWeight,\n+            Function<A, BigDecimal> matchWeigher);\n+\n+    /**\n+     * Positively or negatively impact the {@link Score} by the {@link ConstraintWeight} multiplied by the match weight.\n+     * Otherwise as defined by {@link #impactConfigurable(String)}.", "originalCommit": "c998eec99735e507d57b61e782af45539dd44b2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg2NTQ5Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/697#discussion_r381865497", "bodyText": "Thanks, good catch.", "author": "triceo", "createdAt": "2020-02-20T09:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1ODE0OQ=="}], "type": "inlineReview"}, {"oid": "592827decd5c5484d8e1ba2afa874b01882b6b0d", "url": "https://github.com/kiegroup/optaplanner/commit/592827decd5c5484d8e1ba2afa874b01882b6b0d", "message": "Fix wrong reference in Javadoc", "committedDate": "2020-02-20T09:05:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MDg3Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/697#discussion_r381880877", "bodyText": "api -> impl", "author": "ge0ffrey", "createdAt": "2020-02-20T09:33:14Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ScoreImpactType.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.api.score.stream;\n+\n+public enum ScoreImpactType {", "originalCommit": "592827decd5c5484d8e1ba2afa874b01882b6b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "aa111ef0e3c4d447a10c516cf3d05bfe0e50f3f6", "url": "https://github.com/kiegroup/optaplanner/commit/aa111ef0e3c4d447a10c516cf3d05bfe0e50f3f6", "message": "Move ScoreImpactType out of public API", "committedDate": "2020-02-20T09:36:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4NjQ1Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/697#discussion_r381886452", "bodyText": "Soft suggestion:\nI'd use the word \"instead\" in these sentences for clarity.\nAlso \"you intend to mix positive and negative weights\" could be interpreted in general, not just for this constraint. We really want to discourage them using \"impact\".\nSuggestion:\n\"... unless you intend to mix positive and negative weights\"\n-> \"... instead, unless this constraint can both have positive and negative weights.\"\nAlso, I 'd always put it as the second paragraph, as I think this nudging (yes that's what it is :)), is more important what getConstraintPackage() etc default to.", "author": "ge0ffrey", "createdAt": "2020-02-20T09:42:57Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/quad/QuadConstraintStream.java", "diffHunk": "@@ -624,4 +625,184 @@ default Constraint rewardConfigurableBigDecimal(String constraintName,\n     Constraint rewardConfigurableBigDecimal(String constraintPackage, String constraintName,\n             QuadFunction<A, B, C, D, BigDecimal> matchWeigher);\n \n+    /**\n+     * Positively or negatively impact the {@link Score} by the constraintWeight multiplied by the match weight.\n+     * Otherwise as defined by {@link #impact(String, Score)}.\n+     * <p>\n+     * For non-int {@link Score} types use {@link #impactLong(String, Score, ToLongQuadFunction)} or\n+     * {@link #impactBigDecimal(String, Score, QuadFunction)} instead.\n+     * <p>\n+     * Use {@code penalize(...)} or {@code reward(...)} unless you intend to mix positive and negative weights.\n+     * @param constraintName never null, shows up in {@link ConstraintMatchTotal} during score justification\n+     * @param constraintWeight never null\n+     * @param matchWeigher never null, the result of this function (matchWeight) is multiplied by the constraintWeight\n+     * @return never null\n+     */\n+    default Constraint impact(String constraintName, Score<?> constraintWeight,\n+            ToIntQuadFunction<A, B, C, D> matchWeigher) {\n+        return impact(getConstraintFactory().getDefaultConstraintPackage(), constraintName, constraintWeight,\n+                matchWeigher);\n+    }\n+\n+    /**\n+     * As defined by {@link #impact(String, Score, ToIntQuadFunction)}.\n+     * @param constraintPackage never null\n+     * @param constraintName never null\n+     * @param constraintWeight never null\n+     * @param matchWeigher never null\n+     * @return never null\n+     */\n+    Constraint impact(String constraintPackage, String constraintName, Score<?> constraintWeight,\n+            ToIntQuadFunction<A, B, C, D> matchWeigher);\n+\n+    /**\n+     * Positively or negatively impact the {@link Score} by the constraintWeight multiplied by the match weight.\n+     * Otherwise as defined by {@link #impact(String, Score)}.\n+     * <p>\n+     * Use {@code penalizeLong(...)} or {@code rewardLong(...)} unless you intend to mix positive and negative weights.\n+     * @param constraintName never null, shows up in {@link ConstraintMatchTotal} during score justification\n+     * @param constraintWeight never null\n+     * @param matchWeigher never null, the result of this function (matchWeight) is multiplied by the constraintWeight\n+     * @return never null\n+     */\n+    default Constraint impactLong(String constraintName, Score<?> constraintWeight,\n+            ToLongQuadFunction<A, B, C, D> matchWeigher) {\n+        return impactLong(getConstraintFactory().getDefaultConstraintPackage(), constraintName, constraintWeight,\n+                matchWeigher);\n+    }\n+\n+    /**\n+     * As defined by {@link #impactLong(String, Score, ToLongQuadFunction)}.\n+     * @param constraintPackage never null\n+     * @param constraintName never null\n+     * @param constraintWeight never null\n+     * @param matchWeigher never null\n+     * @return never null\n+     */\n+    Constraint impactLong(String constraintPackage, String constraintName, Score<?> constraintWeight,\n+            ToLongQuadFunction<A, B, C, D> matchWeigher);\n+\n+    /**\n+     * Positively or negatively impact the {@link Score} by the constraintWeight multiplied by the match weight.\n+     * Otherwise as defined by {@link #impact(String, Score)}.\n+     * <p>\n+     * Use {@code penalizeBigDecimal(...)} or {@code rewardBigDecimal(...)} unless you intend to mix positive and\n+     * negative weights.\n+     * @param constraintName never null, shows up in {@link ConstraintMatchTotal} during score justification\n+     * @param constraintWeight never null\n+     * @param matchWeigher never null, the result of this function (matchWeight) is multiplied by the constraintWeight\n+     * @return never null\n+     */\n+    default Constraint impactBigDecimal(String constraintName, Score<?> constraintWeight,\n+            QuadFunction<A, B, C, D, BigDecimal> matchWeigher) {\n+        return impactBigDecimal(getConstraintFactory().getDefaultConstraintPackage(), constraintName,\n+                constraintWeight, matchWeigher);\n+    }\n+\n+    /**\n+     * As defined by {@link #impactBigDecimal(String, Score, QuadFunction)}.\n+     * @param constraintPackage never null\n+     * @param constraintName never null\n+     * @param constraintWeight never null\n+     * @param matchWeigher never null\n+     * @return never null\n+     */\n+    Constraint impactBigDecimal(String constraintPackage, String constraintName, Score<?> constraintWeight,\n+            QuadFunction<A, B, C, D, BigDecimal> matchWeigher);\n+\n+    /**\n+     * Positively or negatively impact the {@link Score} by the {@link ConstraintWeight} for each match.\n+     * <p>\n+     * The constraintWeight comes from an {@link ConstraintWeight} annotated member on the\n+     * {@link ConstraintConfiguration}, so end users can change the constraint weights dynamically.\n+     * This constraint may be deactivated if the {@link ConstraintWeight} is zero.\n+     * If there is no {@link ConstraintConfiguration}, use {@link #impact(String, Score)} instead.\n+     * <p>\n+     * The {@link Constraint#getConstraintPackage()} defaults to {@link ConstraintConfiguration#constraintPackage()}.\n+     * <p>\n+     * For non-int {@link Score} types use {@link #impactConfigurableLong(String, ToLongQuadFunction)} or\n+     * {@link #impactConfigurableBigDecimal(String, QuadFunction)} instead.\n+     * <p>\n+     * Use {@code penalizeConfigurable(...)} or {@code rewardConfigurable(...)} unless you intend to mix positive and\n+     * negative weights.\n+     * @param constraintName never null, shows up in {@link ConstraintMatchTotal} during score justification\n+     * @param matchWeigher never null, the result of this function (matchWeight) is multiplied by the constraintWeight\n+     * @return never null\n+     */\n+    default Constraint impactConfigurable(String constraintName, ToIntQuadFunction<A, B, C, D> matchWeigher) {\n+        return impactConfigurable(getConstraintFactory().getDefaultConstraintPackage(), constraintName, matchWeigher);\n+    }\n+\n+    /**\n+     * As defined by {@link #impactConfigurable(String, ToIntQuadFunction)}.\n+     * @param constraintPackage never null\n+     * @param constraintName never null\n+     * @param matchWeigher never null\n+     * @return never null\n+     */\n+    Constraint impactConfigurable(String constraintPackage, String constraintName,\n+            ToIntQuadFunction<A, B, C, D> matchWeigher);\n+\n+    /**\n+     * Positively or negatively impact the {@link Score} by the {@link ConstraintWeight} for each match.\n+     * <p>\n+     * The constraintWeight comes from an {@link ConstraintWeight} annotated member on the\n+     * {@link ConstraintConfiguration}, so end users can change the constraint weights dynamically.\n+     * This constraint may be deactivated if the {@link ConstraintWeight} is zero.\n+     * If there is no {@link ConstraintConfiguration}, use {@link #impact(String, Score)} instead.\n+     * <p>\n+     * The {@link Constraint#getConstraintPackage()} defaults to {@link ConstraintConfiguration#constraintPackage()}.\n+     * <p>\n+     * Use {@code penalizeConfigurableLong(...)} or {@code rewardConfigurableLong(...)} unless you intend to mix\n+     * positive and negative weights.", "originalCommit": "592827decd5c5484d8e1ba2afa874b01882b6b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "298550c52262b4d1a300360a3a794de4a2afff12", "url": "https://github.com/kiegroup/optaplanner/commit/298550c52262b4d1a300360a3a794de4a2afff12", "message": "Final Javadoc updates", "committedDate": "2020-02-20T09:55:27Z", "type": "commit"}]}