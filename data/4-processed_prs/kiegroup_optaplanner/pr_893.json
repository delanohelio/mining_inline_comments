{"pr_number": 893, "pr_title": "PLANNER-2116 Externalize build methods of entity and value selectors", "pr_createdAt": "2020-08-20T15:02:46Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/893", "timeline": [{"oid": "25096d8fb99105d990e31779cbec9854cc682d94", "url": "https://github.com/kiegroup/optaplanner/commit/25096d8fb99105d990e31779cbec9854cc682d94", "message": "Increase coverage of value and entity selection", "committedDate": "2020-08-21T06:45:41Z", "type": "forcePushed"}, {"oid": "53325e9463ef79cb7cc6a0331aed08a452937964", "url": "https://github.com/kiegroup/optaplanner/commit/53325e9463ef79cb7cc6a0331aed08a452937964", "message": "Check for entity class nullity", "committedDate": "2020-08-21T15:02:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzOTAwMg==", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475239002", "bodyText": "Please merge the assignment with the declaration.", "author": "triceo", "createdAt": "2020-08-23T16:33:34Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/AbstractFromConfigFactory.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.config.AbstractConfig;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+\n+public abstract class AbstractFromConfigFactory<Config_ extends AbstractConfig<Config_>> {\n+\n+    protected final Config_ config;\n+\n+    public AbstractFromConfigFactory(Config_ config) {\n+        this.config = config;\n+    }\n+\n+    protected EntityDescriptor deduceEntityDescriptor(SolutionDescriptor solutionDescriptor, Class<?> entityClass) {\n+        EntityDescriptor entityDescriptor;\n+        entityDescriptor = solutionDescriptor.getEntityDescriptorStrict(Objects.requireNonNull(entityClass));", "originalCommit": "53325e9463ef79cb7cc6a0331aed08a452937964", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzOTA3Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475239072", "bodyText": "Dtto.", "author": "triceo", "createdAt": "2020-08-23T16:34:15Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/AbstractFromConfigFactory.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.config.AbstractConfig;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+\n+public abstract class AbstractFromConfigFactory<Config_ extends AbstractConfig<Config_>> {\n+\n+    protected final Config_ config;\n+\n+    public AbstractFromConfigFactory(Config_ config) {\n+        this.config = config;\n+    }\n+\n+    protected EntityDescriptor deduceEntityDescriptor(SolutionDescriptor solutionDescriptor, Class<?> entityClass) {\n+        EntityDescriptor entityDescriptor;\n+        entityDescriptor = solutionDescriptor.getEntityDescriptorStrict(Objects.requireNonNull(entityClass));\n+        if (entityDescriptor == null) {\n+            throw new IllegalArgumentException(\"The config (\" + config\n+                    + \") has an entityClass (\" + entityClass + \") that is not a known planning entity.\\n\"\n+                    + \"Check your solver configuration. If that class (\" + entityClass.getSimpleName()\n+                    + \") is not in the entityClassSet (\" + solutionDescriptor.getEntityClassSet()\n+                    + \"), check your \" + PlanningSolution.class.getSimpleName()\n+                    + \" implementation's annotated methods too.\");\n+        }\n+        return entityDescriptor;\n+    }\n+\n+    protected EntityDescriptor deduceEntityDescriptor(SolutionDescriptor solutionDescriptor) {\n+        Collection<EntityDescriptor> entityDescriptors = solutionDescriptor.getGenuineEntityDescriptors();\n+        if (entityDescriptors.size() != 1) {\n+            throw new IllegalArgumentException(\"The config (\" + config\n+                    + \") has no entityClass configured and because there are multiple in the entityClassSet (\"\n+                    + solutionDescriptor.getEntityClassSet()\n+                    + \"), it cannot be deduced automatically.\");\n+        }\n+        return entityDescriptors.iterator().next();\n+    }\n+\n+    protected GenuineVariableDescriptor deduceVariableDescriptor(EntityDescriptor entityDescriptor, String variableName) {\n+        GenuineVariableDescriptor variableDescriptor;\n+        variableDescriptor = entityDescriptor.getGenuineVariableDescriptor(Objects.requireNonNull(variableName));", "originalCommit": "53325e9463ef79cb7cc6a0331aed08a452937964", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzOTY0OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475239649", "bodyText": "This could be a nice stream.\nreturn variableNameIncludeList.stream()\n    .map(n -> variableDescriptorList.stream()\n        .filter(d -> d.gerVariableName().equals(n))\n        .findFirst()\n        .orElseThrow(...))\n    .collect(Collectors.toList());\n\nIn my opinion, this reads better as you don't need to mentally track the state of found.", "author": "triceo", "createdAt": "2020-08-23T16:40:12Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/AbstractFromConfigFactory.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.config.AbstractConfig;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+\n+public abstract class AbstractFromConfigFactory<Config_ extends AbstractConfig<Config_>> {\n+\n+    protected final Config_ config;\n+\n+    public AbstractFromConfigFactory(Config_ config) {\n+        this.config = config;\n+    }\n+\n+    protected EntityDescriptor deduceEntityDescriptor(SolutionDescriptor solutionDescriptor, Class<?> entityClass) {\n+        EntityDescriptor entityDescriptor;\n+        entityDescriptor = solutionDescriptor.getEntityDescriptorStrict(Objects.requireNonNull(entityClass));\n+        if (entityDescriptor == null) {\n+            throw new IllegalArgumentException(\"The config (\" + config\n+                    + \") has an entityClass (\" + entityClass + \") that is not a known planning entity.\\n\"\n+                    + \"Check your solver configuration. If that class (\" + entityClass.getSimpleName()\n+                    + \") is not in the entityClassSet (\" + solutionDescriptor.getEntityClassSet()\n+                    + \"), check your \" + PlanningSolution.class.getSimpleName()\n+                    + \" implementation's annotated methods too.\");\n+        }\n+        return entityDescriptor;\n+    }\n+\n+    protected EntityDescriptor deduceEntityDescriptor(SolutionDescriptor solutionDescriptor) {\n+        Collection<EntityDescriptor> entityDescriptors = solutionDescriptor.getGenuineEntityDescriptors();\n+        if (entityDescriptors.size() != 1) {\n+            throw new IllegalArgumentException(\"The config (\" + config\n+                    + \") has no entityClass configured and because there are multiple in the entityClassSet (\"\n+                    + solutionDescriptor.getEntityClassSet()\n+                    + \"), it cannot be deduced automatically.\");\n+        }\n+        return entityDescriptors.iterator().next();\n+    }\n+\n+    protected GenuineVariableDescriptor deduceVariableDescriptor(EntityDescriptor entityDescriptor, String variableName) {\n+        GenuineVariableDescriptor variableDescriptor;\n+        variableDescriptor = entityDescriptor.getGenuineVariableDescriptor(Objects.requireNonNull(variableName));\n+        if (variableDescriptor == null) {\n+            throw new IllegalArgumentException(\"The config (\" + config\n+                    + \") has a variableName (\" + variableName\n+                    + \") which is not a valid planning variable on entityClass (\"\n+                    + entityDescriptor.getEntityClass() + \").\\n\"\n+                    + entityDescriptor.buildInvalidVariableNameExceptionMessage(variableName));\n+        }\n+        return variableDescriptor;\n+    }\n+\n+    protected GenuineVariableDescriptor deduceVariableDescriptor(EntityDescriptor entityDescriptor) {\n+        Collection<GenuineVariableDescriptor> variableDescriptors = entityDescriptor.getGenuineVariableDescriptors();\n+        if (variableDescriptors.size() != 1) {\n+            throw new IllegalArgumentException(\"The config (\" + config\n+                    + \") has no configured variableName for entityClass (\" + entityDescriptor.getEntityClass()\n+                    + \") and because there are multiple variableNames (\"\n+                    + entityDescriptor.getGenuineVariableNameSet()\n+                    + \"), it cannot be deduced automatically.\");\n+        }\n+        return variableDescriptors.iterator().next();\n+    }\n+\n+    protected List<GenuineVariableDescriptor> deduceVariableDescriptorList(EntityDescriptor entityDescriptor,\n+            List<String> variableNameIncludeList) {\n+        Objects.requireNonNull(entityDescriptor);\n+        List<GenuineVariableDescriptor> variableDescriptorList = entityDescriptor.getGenuineVariableDescriptorList();\n+        if (variableNameIncludeList == null) {\n+            return variableDescriptorList;\n+        }\n+        List<GenuineVariableDescriptor> resolvedVariableDescriptorList =\n+                new ArrayList<>(variableDescriptorList.size());\n+        for (String variableNameInclude : variableNameIncludeList) {\n+            boolean found = false;\n+            for (GenuineVariableDescriptor variableDescriptor : variableDescriptorList) {\n+                if (variableDescriptor.getVariableName().equals(variableNameInclude)) {\n+                    resolvedVariableDescriptorList.add(variableDescriptor);\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has a variableNameInclude (\" + variableNameInclude\n+                        + \") which does not exist in the entity (\" + entityDescriptor.getEntityClass()\n+                        + \")'s variableDescriptorList (\" + variableDescriptorList + \").\");\n+            }\n+        }\n+        return resolvedVariableDescriptorList;", "originalCommit": "53325e9463ef79cb7cc6a0331aed08a452937964", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM3MzAxNw==", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475373017", "bodyText": "I didn't touch the existing code if I wasn't changing it. That said, if there is an opportunity to improve it, I will take a look at this one and other suggestions you made.", "author": "rsynek", "createdAt": "2020-08-24T06:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzOTY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzOTk2OA==", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475239968", "bodyText": "How about:\nboolean distributionEnabled = false;\nswitch (nearbySelectionConfig.getNearbySelectionDistributionType()) {\n     case LINEAR_DISTRIBUTION:\n          distributionEnabled = nearbySelectionConfig.getLinearDistributionSizeMaximum() != null;\n          break;\n     ...\n}\n\nLess repetition, and in my opinion more clarity.", "author": "triceo", "createdAt": "2020-08-23T16:43:26Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/common/nearby/NearbyRandomFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.common.nearby;\n+\n+import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;\n+\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionConfig;\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionDistributionType;\n+\n+public class NearbyRandomFactory {\n+\n+    public static NearbyRandomFactory create(NearbySelectionConfig nearbySelectionConfig) {\n+        return new NearbyRandomFactory(nearbySelectionConfig);\n+    }\n+\n+    private final NearbySelectionConfig nearbySelectionConfig;\n+\n+    public NearbyRandomFactory(NearbySelectionConfig nearbySelectionConfig) {\n+        this.nearbySelectionConfig = nearbySelectionConfig;\n+    }\n+\n+    public NearbyRandom buildNearbyRandom(boolean randomSelection) {\n+        boolean blockDistributionEnabled =\n+                nearbySelectionConfig.getNearbySelectionDistributionType() == NearbySelectionDistributionType.BLOCK_DISTRIBUTION\n+                        || nearbySelectionConfig.getBlockDistributionSizeMinimum() != null\n+                        || nearbySelectionConfig.getBlockDistributionSizeMaximum() != null\n+                        || nearbySelectionConfig.getBlockDistributionSizeRatio() != null\n+                        || nearbySelectionConfig.getBlockDistributionUniformDistributionProbability() != null;\n+        boolean linearDistributionEnabled = nearbySelectionConfig\n+                .getNearbySelectionDistributionType() == NearbySelectionDistributionType.LINEAR_DISTRIBUTION\n+                || nearbySelectionConfig.getLinearDistributionSizeMaximum() != null;\n+        boolean parabolicDistributionEnabled = nearbySelectionConfig\n+                .getNearbySelectionDistributionType() == NearbySelectionDistributionType.PARABOLIC_DISTRIBUTION\n+                || nearbySelectionConfig.getParabolicDistributionSizeMaximum() != null;\n+        boolean betaDistributionEnabled =\n+                nearbySelectionConfig.getNearbySelectionDistributionType() == NearbySelectionDistributionType.BETA_DISTRIBUTION\n+                        || nearbySelectionConfig.getBetaDistributionAlpha() != null\n+                        || nearbySelectionConfig.getBetaDistributionBeta() != null;", "originalCommit": "53325e9463ef79cb7cc6a0331aed08a452937964", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMjE5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475422190", "bodyText": "Let me just answer this and the next two comments together, as they are connected with each other:\nThe method consists of 3 steps:\n\ndiscovers which distribution types are enabled\nfails fast if multiple distribution types have been configured\nreturns the computed distribution\n\nFrom your comments, I understand you suggest implementing all these steps in a single switch statement.\nTo implement step 2, the subsequent branches of the switch statement would have to depend on preceding ones. Each case would contain:\n\nthe logic for discovering its distribution type\nfail fast condition(s)\ninstantiation of the NearbyRandom\n\nSince the implementation of fail fast conditions requires avoiding break after any case, we cannot use the default branch, which is supposed to return LinearDistributionNearbyRandom(Integer.MAX_VALUE).\nTo sum this up, I don't think doing all 3 steps in the switch statement (while there will be additional if conditions after it anyway) is as an improvement. But I like the idea of using switch for the step 1.", "author": "rsynek", "createdAt": "2020-08-24T08:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzOTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4ODM0NA==", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475488344", "bodyText": "Actually even using switch just for step 1 wouldn't help, as the individual conditions are connected with logical OR.", "author": "rsynek", "createdAt": "2020-08-24T10:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzOTk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI0MDEwOA==", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475240108", "bodyText": "Implementing my previous comment would complicate this. But I suppose you could set these variables in the switch directly.", "author": "triceo", "createdAt": "2020-08-23T16:44:49Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/common/nearby/NearbyRandomFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.common.nearby;\n+\n+import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;\n+\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionConfig;\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionDistributionType;\n+\n+public class NearbyRandomFactory {\n+\n+    public static NearbyRandomFactory create(NearbySelectionConfig nearbySelectionConfig) {\n+        return new NearbyRandomFactory(nearbySelectionConfig);\n+    }\n+\n+    private final NearbySelectionConfig nearbySelectionConfig;\n+\n+    public NearbyRandomFactory(NearbySelectionConfig nearbySelectionConfig) {\n+        this.nearbySelectionConfig = nearbySelectionConfig;\n+    }\n+\n+    public NearbyRandom buildNearbyRandom(boolean randomSelection) {\n+        boolean blockDistributionEnabled =\n+                nearbySelectionConfig.getNearbySelectionDistributionType() == NearbySelectionDistributionType.BLOCK_DISTRIBUTION\n+                        || nearbySelectionConfig.getBlockDistributionSizeMinimum() != null\n+                        || nearbySelectionConfig.getBlockDistributionSizeMaximum() != null\n+                        || nearbySelectionConfig.getBlockDistributionSizeRatio() != null\n+                        || nearbySelectionConfig.getBlockDistributionUniformDistributionProbability() != null;\n+        boolean linearDistributionEnabled = nearbySelectionConfig\n+                .getNearbySelectionDistributionType() == NearbySelectionDistributionType.LINEAR_DISTRIBUTION\n+                || nearbySelectionConfig.getLinearDistributionSizeMaximum() != null;\n+        boolean parabolicDistributionEnabled = nearbySelectionConfig\n+                .getNearbySelectionDistributionType() == NearbySelectionDistributionType.PARABOLIC_DISTRIBUTION\n+                || nearbySelectionConfig.getParabolicDistributionSizeMaximum() != null;\n+        boolean betaDistributionEnabled =\n+                nearbySelectionConfig.getNearbySelectionDistributionType() == NearbySelectionDistributionType.BETA_DISTRIBUTION\n+                        || nearbySelectionConfig.getBetaDistributionAlpha() != null\n+                        || nearbySelectionConfig.getBetaDistributionBeta() != null;\n+        if (!randomSelection) {\n+            if (blockDistributionEnabled || linearDistributionEnabled || parabolicDistributionEnabled\n+                    || betaDistributionEnabled) {\n+                throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                        + \") with randomSelection (\" + randomSelection\n+                        + \") has distribution parameters.\");\n+            }\n+            return null;\n+        }\n+        if (blockDistributionEnabled && linearDistributionEnabled) {", "originalCommit": "53325e9463ef79cb7cc6a0331aed08a452937964", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI0MDI1Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475240253", "bodyText": "Personally, I'd make this part of the switch, too. There should only be one place where decisions are made from a single piece of data.", "author": "triceo", "createdAt": "2020-08-23T16:45:52Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/common/nearby/NearbyRandomFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.common.nearby;\n+\n+import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;\n+\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionConfig;\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionDistributionType;\n+\n+public class NearbyRandomFactory {\n+\n+    public static NearbyRandomFactory create(NearbySelectionConfig nearbySelectionConfig) {\n+        return new NearbyRandomFactory(nearbySelectionConfig);\n+    }\n+\n+    private final NearbySelectionConfig nearbySelectionConfig;\n+\n+    public NearbyRandomFactory(NearbySelectionConfig nearbySelectionConfig) {\n+        this.nearbySelectionConfig = nearbySelectionConfig;\n+    }\n+\n+    public NearbyRandom buildNearbyRandom(boolean randomSelection) {\n+        boolean blockDistributionEnabled =\n+                nearbySelectionConfig.getNearbySelectionDistributionType() == NearbySelectionDistributionType.BLOCK_DISTRIBUTION\n+                        || nearbySelectionConfig.getBlockDistributionSizeMinimum() != null\n+                        || nearbySelectionConfig.getBlockDistributionSizeMaximum() != null\n+                        || nearbySelectionConfig.getBlockDistributionSizeRatio() != null\n+                        || nearbySelectionConfig.getBlockDistributionUniformDistributionProbability() != null;\n+        boolean linearDistributionEnabled = nearbySelectionConfig\n+                .getNearbySelectionDistributionType() == NearbySelectionDistributionType.LINEAR_DISTRIBUTION\n+                || nearbySelectionConfig.getLinearDistributionSizeMaximum() != null;\n+        boolean parabolicDistributionEnabled = nearbySelectionConfig\n+                .getNearbySelectionDistributionType() == NearbySelectionDistributionType.PARABOLIC_DISTRIBUTION\n+                || nearbySelectionConfig.getParabolicDistributionSizeMaximum() != null;\n+        boolean betaDistributionEnabled =\n+                nearbySelectionConfig.getNearbySelectionDistributionType() == NearbySelectionDistributionType.BETA_DISTRIBUTION\n+                        || nearbySelectionConfig.getBetaDistributionAlpha() != null\n+                        || nearbySelectionConfig.getBetaDistributionBeta() != null;\n+        if (!randomSelection) {\n+            if (blockDistributionEnabled || linearDistributionEnabled || parabolicDistributionEnabled\n+                    || betaDistributionEnabled) {\n+                throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                        + \") with randomSelection (\" + randomSelection\n+                        + \") has distribution parameters.\");\n+            }\n+            return null;\n+        }\n+        if (blockDistributionEnabled && linearDistributionEnabled) {\n+            throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                    + \") has both blockDistribution and linearDistribution parameters.\");\n+        }\n+        if (blockDistributionEnabled && parabolicDistributionEnabled) {\n+            throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                    + \") has both blockDistribution and parabolicDistribution parameters.\");\n+        }\n+        if (blockDistributionEnabled && betaDistributionEnabled) {\n+            throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                    + \") has both blockDistribution and betaDistribution parameters.\");\n+        }\n+        if (linearDistributionEnabled && parabolicDistributionEnabled) {\n+            throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                    + \") has both linearDistribution and parabolicDistribution parameters.\");\n+        }\n+        if (linearDistributionEnabled && betaDistributionEnabled) {\n+            throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                    + \") has both linearDistribution and betaDistribution parameters.\");\n+        }\n+        if (parabolicDistributionEnabled && betaDistributionEnabled) {\n+            throw new IllegalArgumentException(\"The nearbySelectorConfig (\" + nearbySelectionConfig\n+                    + \") has both parabolicDistribution and betaDistribution parameters.\");\n+        }\n+        if (blockDistributionEnabled) {", "originalCommit": "53325e9463ef79cb7cc6a0331aed08a452937964", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI0MDMyMg==", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475240322", "bodyText": "Good that you're not doing mutation testing. You'd grow old testing all the permutations of this particular condition.", "author": "triceo", "createdAt": "2020-08-23T16:46:46Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/entity/EntitySelectorFactory.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.entity;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.common.decorator.SelectionSorterOrder;\n+import org.optaplanner.core.config.heuristic.selector.common.nearby.NearbySelectionConfig;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;\n+import org.optaplanner.core.config.util.ConfigUtils;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.selector.AbstractSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.ComparatorSelectionSorter;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionFilter;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionProbabilityWeightFactory;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorter;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.WeightFactorySelectionSorter;\n+import org.optaplanner.core.impl.heuristic.selector.common.nearby.NearbyDistanceMeter;\n+import org.optaplanner.core.impl.heuristic.selector.common.nearby.NearbyRandom;\n+import org.optaplanner.core.impl.heuristic.selector.common.nearby.NearbyRandomFactory;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.CachingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.FilteringEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.ProbabilityEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.SelectedCountLimitEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.ShufflingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.decorator.SortingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.mimic.EntityMimicRecorder;\n+import org.optaplanner.core.impl.heuristic.selector.entity.mimic.MimicRecordingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.mimic.MimicReplayingEntitySelector;\n+import org.optaplanner.core.impl.heuristic.selector.entity.nearby.NearEntityNearbyEntitySelector;\n+\n+public class EntitySelectorFactory extends AbstractSelectorFactory<EntitySelectorConfig> {\n+\n+    public static EntitySelectorFactory create(EntitySelectorConfig entitySelectorConfig) {\n+        return new EntitySelectorFactory(entitySelectorConfig);\n+    }\n+\n+    public EntitySelectorFactory(EntitySelectorConfig entitySelectorConfig) {\n+        super(entitySelectorConfig);\n+    }\n+\n+    public EntityDescriptor extractEntityDescriptor(HeuristicConfigPolicy configPolicy) {\n+        if (config.getEntityClass() != null) {\n+            SolutionDescriptor solutionDescriptor = configPolicy.getSolutionDescriptor();\n+            EntityDescriptor entityDescriptor = solutionDescriptor.getEntityDescriptorStrict(config.getEntityClass());\n+            if (entityDescriptor == null) {\n+                throw new IllegalArgumentException(\"The selectorConfig (\" + config\n+                        + \") has an entityClass (\" + config.getEntityClass() + \") that is not a known planning entity.\\n\"\n+                        + \"Check your solver configuration. If that class (\" + config.getEntityClass().getSimpleName()\n+                        + \") is not in the entityClassSet (\" + solutionDescriptor.getEntityClassSet()\n+                        + \"), check your \" + PlanningSolution.class.getSimpleName()\n+                        + \" implementation's annotated methods too.\");\n+            }\n+            return entityDescriptor;\n+        } else if (config.getMimicSelectorRef() != null) {\n+            return configPolicy.getEntityMimicRecorder(config.getMimicSelectorRef()).getEntityDescriptor();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param configPolicy never null\n+     * @param minimumCacheType never null, If caching is used (different from {@link SelectionCacheType#JUST_IN_TIME}),\n+     *        then it should be at least this {@link SelectionCacheType} because an ancestor already uses such caching\n+     *        and less would be pointless.\n+     * @param inheritedSelectionOrder never null\n+     * @return never null\n+     */\n+    public EntitySelector buildEntitySelector(HeuristicConfigPolicy configPolicy, SelectionCacheType minimumCacheType,\n+            SelectionOrder inheritedSelectionOrder) {\n+        if (config.getMimicSelectorRef() != null) {\n+            return buildMimicReplaying(configPolicy);\n+        }\n+        EntityDescriptor entityDescriptor =\n+                config.getEntityClass() == null ? deduceEntityDescriptor(configPolicy.getSolutionDescriptor())\n+                        : deduceEntityDescriptor(configPolicy.getSolutionDescriptor(), config.getEntityClass());\n+        SelectionCacheType resolvedCacheType = SelectionCacheType.resolve(config.getCacheType(), minimumCacheType);\n+        SelectionOrder resolvedSelectionOrder = SelectionOrder.resolve(config.getSelectionOrder(), inheritedSelectionOrder);\n+\n+        if (config.getNearbySelectionConfig() != null) {\n+            config.getNearbySelectionConfig().validateNearby(resolvedCacheType, resolvedSelectionOrder);\n+        }\n+        validateCacheTypeVersusSelectionOrder(resolvedCacheType, resolvedSelectionOrder);\n+        validateSorting(resolvedSelectionOrder);\n+        validateProbability(resolvedSelectionOrder);\n+        validateSelectedLimit(minimumCacheType);\n+\n+        // baseEntitySelector and lower should be SelectionOrder.ORIGINAL if they are going to get cached completely\n+        boolean baseRandomSelection = determineBaseRandomSelection(entityDescriptor, resolvedCacheType, resolvedSelectionOrder);\n+        SelectionCacheType baseSelectionCacheType = SelectionCacheType.max(minimumCacheType, resolvedCacheType);\n+        EntitySelector entitySelector = buildBaseEntitySelector(entityDescriptor, baseSelectionCacheType, baseRandomSelection);\n+        if (config.getNearbySelectionConfig() != null) {\n+            // TODO Static filtering (such as movableEntitySelectionFilter) should affect nearbySelection\n+            entitySelector = applyNearbySelection(configPolicy, config.getNearbySelectionConfig(), minimumCacheType,\n+                    resolvedSelectionOrder, entitySelector);\n+        }\n+        entitySelector = applyFiltering(entitySelector);\n+        entitySelector = applySorting(resolvedCacheType, resolvedSelectionOrder, entitySelector);\n+        entitySelector = applyProbability(resolvedCacheType, resolvedSelectionOrder, entitySelector);\n+        entitySelector = applyShuffling(resolvedCacheType, resolvedSelectionOrder, entitySelector);\n+        entitySelector = applyCaching(resolvedCacheType, resolvedSelectionOrder, entitySelector);\n+        entitySelector = applySelectedLimit(resolvedSelectionOrder, entitySelector);\n+        entitySelector = applyMimicRecording(configPolicy, entitySelector);\n+        return entitySelector;\n+    }\n+\n+    protected EntitySelector buildMimicReplaying(HeuristicConfigPolicy configPolicy) {\n+        if (config.getId() != null\n+                || config.getEntityClass() != null\n+                || config.getCacheType() != null\n+                || config.getSelectionOrder() != null\n+                || config.getNearbySelectionConfig() != null\n+                || config.getFilterClass() != null\n+                || config.getSorterManner() != null\n+                || config.getSorterComparatorClass() != null\n+                || config.getSorterWeightFactoryClass() != null\n+                || config.getSorterOrder() != null\n+                || config.getSorterClass() != null\n+                || config.getProbabilityWeightFactoryClass() != null\n+                || config.getSelectedCountLimit() != null) {", "originalCommit": "53325e9463ef79cb7cc6a0331aed08a452937964", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI0MDQ2Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475240467", "bodyText": "But to be constructive here - I'd add all of the calls into a stream, and then filter anything non null. That way, the code would  more readily express what you're trying to do.", "author": "triceo", "createdAt": "2020-08-23T16:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI0MDMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyNDMxNA==", "url": "https://github.com/kiegroup/optaplanner/pull/893#discussion_r475424314", "bodyText": "Good point, I used the same \"trick\" for resolving terminationConfigs; here it suits pretty well too.", "author": "rsynek", "createdAt": "2020-08-24T08:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI0MDMyMg=="}], "type": "inlineReview"}, {"oid": "47138bafba7e3b7064f1a21d0582ecb80cda6493", "url": "https://github.com/kiegroup/optaplanner/commit/47138bafba7e3b7064f1a21d0582ecb80cda6493", "message": "PLANNER-2116 Externalize build methods of Selectors", "committedDate": "2020-08-24T06:19:40Z", "type": "commit"}, {"oid": "01b80ddeaa5cf67d157c6b5563a8b2fa09d5f064", "url": "https://github.com/kiegroup/optaplanner/commit/01b80ddeaa5cf67d157c6b5563a8b2fa09d5f064", "message": "PLANNER-2116 Externalize build method of BestSolutionRecaller", "committedDate": "2020-08-24T06:19:40Z", "type": "commit"}, {"oid": "8ceceffefc59c6de78aa917e3724c832a55ff0f6", "url": "https://github.com/kiegroup/optaplanner/commit/8ceceffefc59c6de78aa917e3724c832a55ff0f6", "message": "Update revapi-config.json", "committedDate": "2020-08-24T06:19:40Z", "type": "commit"}, {"oid": "2f187cd2e7ed33a2cbc9955146cfc5c3575b4486", "url": "https://github.com/kiegroup/optaplanner/commit/2f187cd2e7ed33a2cbc9955146cfc5c3575b4486", "message": "Remove unused method parameters", "committedDate": "2020-08-24T06:19:40Z", "type": "commit"}, {"oid": "5c14620bbb73f6eef921c374776f24a1ae6f4623", "url": "https://github.com/kiegroup/optaplanner/commit/5c14620bbb73f6eef921c374776f24a1ae6f4623", "message": "Add QueuedValuePlacerFactoryTest", "committedDate": "2020-08-24T06:19:40Z", "type": "commit"}, {"oid": "5d045caa63ca78bff1ce56be364dbac09fb04883", "url": "https://github.com/kiegroup/optaplanner/commit/5d045caa63ca78bff1ce56be364dbac09fb04883", "message": "Add SubChainSelectorFactoryTest", "committedDate": "2020-08-24T06:19:40Z", "type": "commit"}, {"oid": "7999651332cda4286d9832c49e343f08e4414a98", "url": "https://github.com/kiegroup/optaplanner/commit/7999651332cda4286d9832c49e343f08e4414a98", "message": "Test applyFiltering in ValueSelectorFactory", "committedDate": "2020-08-24T06:19:40Z", "type": "commit"}, {"oid": "6549549a64865941f2b7b85545e716a4aa3207d3", "url": "https://github.com/kiegroup/optaplanner/commit/6549549a64865941f2b7b85545e716a4aa3207d3", "message": "Increase coverage of value and entity selection", "committedDate": "2020-08-24T06:19:40Z", "type": "commit"}, {"oid": "235a22787eafec8d0a5be84703692b12b290668e", "url": "https://github.com/kiegroup/optaplanner/commit/235a22787eafec8d0a5be84703692b12b290668e", "message": "Fix formatting", "committedDate": "2020-08-24T06:19:40Z", "type": "commit"}, {"oid": "ccdae7505a8525cbff7c851ac1d8d711a8ec5efd", "url": "https://github.com/kiegroup/optaplanner/commit/ccdae7505a8525cbff7c851ac1d8d711a8ec5efd", "message": "Increase coverage of move selector factories", "committedDate": "2020-08-24T06:19:40Z", "type": "commit"}, {"oid": "998a6f175de3e58c6726715bc3fc90e26ce9e7cb", "url": "https://github.com/kiegroup/optaplanner/commit/998a6f175de3e58c6726715bc3fc90e26ce9e7cb", "message": "Add test for configuration inheritance", "committedDate": "2020-08-24T06:19:40Z", "type": "commit"}, {"oid": "2a22bcf5ae02a278b81fca8cb72a6df80920cac1", "url": "https://github.com/kiegroup/optaplanner/commit/2a22bcf5ae02a278b81fca8cb72a6df80920cac1", "message": "Check for entity class nullity", "committedDate": "2020-08-24T06:19:40Z", "type": "commit"}, {"oid": "b1e638da6ac8ff38d2486727f01bc27e8d44aeb2", "url": "https://github.com/kiegroup/optaplanner/commit/b1e638da6ac8ff38d2486727f01bc27e8d44aeb2", "message": "Address review comments.", "committedDate": "2020-08-24T10:05:41Z", "type": "forcePushed"}, {"oid": "b045216c7c0d0d36852d621ad069463db0d30338", "url": "https://github.com/kiegroup/optaplanner/commit/b045216c7c0d0d36852d621ad069463db0d30338", "message": "Address review comments.", "committedDate": "2020-08-24T11:15:48Z", "type": "commit"}, {"oid": "b045216c7c0d0d36852d621ad069463db0d30338", "url": "https://github.com/kiegroup/optaplanner/commit/b045216c7c0d0d36852d621ad069463db0d30338", "message": "Address review comments.", "committedDate": "2020-08-24T11:15:48Z", "type": "forcePushed"}]}