{"pr_number": 1064, "pr_title": "PLANNER-2269: Proper CS-B node indexing", "pr_createdAt": "2020-12-03T15:53:40Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/1064", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1OTI4MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r535359281", "bodyText": "Don't like it, but I needed this for the test.\nThis is not public API, so we should be good.", "author": "triceo", "createdAt": "2020-12-03T15:55:24Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java", "diffHunk": "@@ -172,4 +172,11 @@ public void afterProblemFactRemoved(Object problemFact) {\n         super.afterProblemFactRemoved(problemFact);\n     }\n \n+    // ************************************************************************\n+    // Getters/setters\n+    // ************************************************************************\n+\n+    public ConstraintSession<Solution_, Score_> getSession() {\n+        return session;\n+    }", "originalCommit": "1abadeb996e5d33f537da94ce7ec6014adff6489", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NzMzNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536197335", "bodyText": "Ok. Someday we need to talk about merging ConstraintStreamSession and ConstraintStreamScoreDirector to avoid unneeded indirection :)", "author": "ge0ffrey", "createdAt": "2020-12-04T15:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1OTI4MQ=="}], "type": "inlineReview"}, {"oid": "5edeb52291e18cf365daf34b7ad2a42958e47364", "url": "https://github.com/kiegroup/optaplanner/commit/5edeb52291e18cf365daf34b7ad2a42958e47364", "message": "Finishing touches", "committedDate": "2020-12-03T16:01:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2NjA5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r535366090", "bodyText": "This is the test that checks, for a sufficiently complex stream, that the ordering is correct.", "author": "triceo", "createdAt": "2020-12-03T16:03:53Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintStreamNodeOrderingTest.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.bavet;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.api.score.buildin.simple.SimpleScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintStreamImplType;\n+import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirector;\n+import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirectorFactory;\n+import org.optaplanner.core.impl.score.stream.bavet.common.BavetScoringNode;\n+import org.optaplanner.core.impl.score.stream.bavet.tri.BavetScoringTriNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetAbstractUniNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFilterUniNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFromUniNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetJoinBridgeUniNode;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishEntity;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishSolution;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishValue;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishValueGroup;\n+\n+public class BavetConstraintStreamNodeOrderingTest {", "originalCommit": "5edeb52291e18cf365daf34b7ad2a42958e47364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMDk4NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r535710984", "bodyText": "This is not consistent with equals().", "author": "triceo", "createdAt": "2020-12-03T23:04:38Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java", "diffHunk": "@@ -21,20 +21,24 @@\n public class BavetAbstractNode implements BavetNode {\n \n     protected final BavetConstraintSession session;\n-    protected final int nodeOrder;\n+    protected final int nodeIndex;\n \n-    public BavetAbstractNode(BavetConstraintSession session, int nodeOrder) {\n+    public BavetAbstractNode(BavetConstraintSession session, int nodeIndex) {\n         this.session = session;\n-        this.nodeOrder = nodeOrder;\n+        this.nodeIndex = nodeIndex;\n     }\n \n     // ************************************************************************\n     // Getters/setters\n     // ************************************************************************\n \n     @Override\n-    public int getNodeOrder() {\n-        return nodeOrder;\n+    public int getNodeIndex() {\n+        return nodeIndex;\n     }\n \n+    @Override\n+    public int compareTo(BavetNode o) {\n+        return Integer.compare(this.nodeIndex, o.getNodeIndex());\n+    }", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMjI1OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r535712258", "bodyText": "All node indexes are unique now. Therefore this fail-fast makes no sense anymore.", "author": "triceo", "createdAt": "2020-12-03T23:06:22Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -37,18 +37,11 @@ public BavetNodeBuildPolicy(BavetConstraintSession session, int constraintCount)\n         constraintIdToScoringNodeMap = new LinkedHashMap<>(constraintCount);\n     }\n \n-    public void updateNodeOrderMaximum(int nodeOrder) {\n-        if (nodeOrderMaximum < nodeOrder) {\n-            nodeOrderMaximum = nodeOrder;\n-        }\n-    }\n-\n     public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n-        if (node.getNodeOrder() != sharedNode.getNodeOrder()) {\n-            throw new IllegalStateException(\"Impossible state: the node (\" + node\n-                    + \")'s nodeOrder (\" + node.getNodeOrder() + \") differs from the sharedNode (\" + sharedNode\n-                    + \")'s nodeOrder (\" + sharedNode.getNodeOrder() + \").\");", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNzc4Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536217783", "bodyText": "Crap, ideally when a node is replaced by a sharedNode, it doesn't take up an extra nodeIndex.\nBecause it does, the nodeSize will be actually bigger than the number of actual nodes in place. (so it shouldn't be called nodeSize indeed and a comment should specify that strange behaviour). So the queue will have a number of empty spaces. Actually, that hurts performance...\n... so we need to recycle nodeIndexes of nodes that get shared. Maybe upon sharing, call BuildPolicy.undoNextIndex() that does nextNodeIndex--?", "author": "ge0ffrey", "createdAt": "2020-12-04T16:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMjI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI2NzQzOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536267439", "bodyText": "This is not an issue. Node indexes are perfectly sequential, they are never duplicated. (The \"+1 trick\" takes care of that.)", "author": "triceo", "createdAt": "2020-12-04T17:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMjI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NzY4MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536197680", "bodyText": "Actually, this is now just nodeSize (the number of nodes), I'd argue. Wdyt?", "author": "ge0ffrey", "createdAt": "2020-12-04T15:52:46Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintSession.java", "diffHunk": "@@ -48,12 +49,12 @@\n     private final ScoreInliner<Score_> scoreInliner;\n \n     private final Map<Class<?>, BavetFromUniNode<Object>> declaredClassToNodeMap;\n-    private final int nodeOrderSize;\n+    private final int nodeIndexSize;", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMTkxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536211919", "bodyText": "I wouldn't write this as an else if because the 2 conditions are unrelated and it creates the confusion that they are.\nSuggestion: replace the else with a line break. - because the sharedNode check is a quick return (special condition for which the main content of this method doesn't apply).", "author": "ge0ffrey", "createdAt": "2020-12-04T16:13:43Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java", "diffHunk": "@@ -277,39 +277,35 @@ public final Constraint impactScoreConfigurableBigDecimal(String constraintPacka\n     // ************************************************************************\n \n     public BavetAbstractBiNode<A, B> createNodeChain(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<A, B> parentNode) {\n-        BavetAbstractBiNode<A, B> node = createNode(buildPolicy, constraintWeight, nodeOrder, parentNode);\n-        node = processNode(buildPolicy, nodeOrder, parentNode, node);\n-        createChildNodeChains(buildPolicy, constraintWeight, nodeOrder, node);\n+            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n+        BavetAbstractBiNode<A, B> node = createNode(buildPolicy, constraintWeight, parentNode);\n+        node = processNode(buildPolicy, parentNode, node);\n+        createChildNodeChains(buildPolicy, constraintWeight, node);\n         return node;\n     }\n \n-    protected BavetAbstractBiNode<A, B> processNode(BavetNodeBuildPolicy<Solution_> buildPolicy, int nodeOrder,\n+    protected BavetAbstractBiNode<A, B> processNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n             BavetAbstractBiNode<A, B> parentNode, BavetAbstractBiNode<A, B> node) {\n-        buildPolicy.updateNodeOrderMaximum(nodeOrder);\n         BavetAbstractBiNode<A, B> sharedNode = buildPolicy.retrieveSharedNode(node);\n-        if (sharedNode != node) {\n-            // Share node\n-            node = sharedNode;\n-        } else {\n-            if (parentNode != null) { // TODO remove null check and don't go through this code like this for from and joins\n-                parentNode.addChildNode(node);\n-            }\n+        if (sharedNode != node) { // Share node\n+            return sharedNode;\n+        } else if (parentNode != null) { // TODO remove null check and don't go through this for from and joins", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMjk2OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536212968", "bodyText": "(important)\nThis is very wierd.\nI would expect the it take as the next Index from the buildPolicy.\nThis way the next Index doesn't increment. That's a bug I think?", "author": "ge0ffrey", "createdAt": "2020-12-04T16:15:24Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java", "diffHunk": "@@ -51,8 +51,8 @@ public BavetFilterBiConstraintStream(BavetConstraintFactory<Solution_> constrain\n \n     @Override\n     protected BavetFilterBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<A, B> parentNode) {\n-        return new BavetFilterBiNode<>(buildPolicy.getSession(), nodeOrder, parentNode, predicate);\n+            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n+        return new BavetFilterBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 1, parentNode, predicate);", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI2ODEzMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536268131", "bodyText": "The index is incremented immediately after this, when the node is checked for sharing. There is a test that checks for this.\nI am interested in counter-examples.", "author": "triceo", "createdAt": "2020-12-04T17:43:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMjk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMzQwOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536213409", "bodyText": "No. This appraoch won't work with composition approaches. For complex networks we can't predict the gaps.", "author": "ge0ffrey", "createdAt": "2020-12-04T16:16:01Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java", "diffHunk": "@@ -50,19 +50,20 @@ public BavetGroupBiConstraintStream(BavetConstraintFactory<Solution_> constraint\n \n     @Override\n     public BavetGroupBiNode<GroupKey_, ResultContainer_, Result_> createNodeChain(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n+            Score<?> constraintWeight, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n         return (BavetGroupBiNode<GroupKey_, ResultContainer_, Result_>) super.createNodeChain(buildPolicy, constraintWeight,\n-                nodeOrder, parentNode);\n+                parentNode);\n     }\n \n     @Override\n     protected BavetGroupBiNode<GroupKey_, ResultContainer_, Result_> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n+            Score<?> constraintWeight, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n         if (parentNode != null) {\n             throw new IllegalStateException(\"Impossible state: the stream (\" + this\n                     + \") cannot have a parentNode (\" + parentNode + \").\");\n         }\n-        return new BavetGroupBiNode<>(buildPolicy.getSession(), nodeOrder, finisher);\n+        // GroupBridgeNodes are created after GroupNodes, so increment by 2 to create room for the bridge inbetween.\n+        return new BavetGroupBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 2, finisher);", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI2ODgxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536268819", "bodyText": "Assuming that Group is always preceded by a GroupBridge, this is perfectly safe.\nOtherwise I'll need to see an example of a network where that is not the case.", "author": "triceo", "createdAt": "2020-12-04T17:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMzQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNjA5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536216091", "bodyText": "My suggestion is to remove this field and instead have\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int nodeIndexMaximum = -1; // So that the first node starts at 0 when it increments.\n          \n          \n            \n                private int nextNodeIndex = 0;\n          \n          \n            \n                \n          \n          \n            \n                public int nextNodeIndex() {\n          \n          \n            \n                    return nextNodeIndex++;\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nEvery time a new node is created, it call this method and automatically gets the next one.\nRemember that join nodes are created after both bridges are created, so a join will never be before it's bridges or anything before it (but we should test those nodeIndexes with a unit test).", "author": "ge0ffrey", "createdAt": "2020-12-04T16:19:42Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -26,7 +26,7 @@\n \n     private final BavetConstraintSession session;\n \n-    private int nodeOrderMaximum = 0;\n+    private int nodeIndexMaximum = -1; // So that the first node starts at 0 when it increments.", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI2OTUxOA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536269518", "bodyText": "No. The entire algorithm depends on the fact, that nodeIndex is only ever actually incremented when node sharing is ruled out. It makes the algorithm incredibly simple and effective - no need for any sort of rollback.", "author": "triceo", "createdAt": "2020-12-04T17:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNjA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ0NzA3NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r537447074", "bodyText": "This is heavy. Thankfully it is only ever used in BavetConstraintSession constructor.\nConsidering that it gives us a fail-fast on a pretty important thing, I say we need it.", "author": "triceo", "createdAt": "2020-12-07T11:52:44Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -77,4 +86,22 @@ public int getNodeOrderMaximum() {\n         return joinConstraintStreamToJoinBridgeNodeMap;\n     }\n \n+    public List<BavetNode> getCreatedNodes() {\n+        // Make a sequential list of unique nodes.\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n+                constraintIdToScoringNodeMap.values().stream())\n+                .distinct()\n+                .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n+                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n+                }, TreeMap::new));\n+        // Ensure there are no gaps in that list.\n+        int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n+        int expectedMaxNodeIndex = nodeIndexToNodeMap.size() - 1;\n+        if (maxNodeIndex != expectedMaxNodeIndex) {\n+            throw new IllegalStateException(\"Impossible state: maximum node index (\" + maxNodeIndex +\n+                    \") does not match the expected maximum node count (\" + expectedMaxNodeIndex + \").\");\n+        }\n+        return Collections.unmodifiableList(new ArrayList<>(nodeIndexToNodeMap.values()));\n+    }", "originalCommit": "98513aa276d23bb2ceac3bfc7f897abc906c6777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzOTY0Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538239643", "bodyText": "100% agree that it is worth it.", "author": "ge0ffrey", "createdAt": "2020-12-08T10:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ0NzA3NA=="}], "type": "inlineReview"}, {"oid": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "url": "https://github.com/kiegroup/optaplanner/commit/6dee0a469c93a206012d395d5b6cc72aca40b2fd", "message": "NodeOrder becomes NodeIndex", "committedDate": "2020-12-07T13:24:23Z", "type": "commit"}, {"oid": "27fa44052c64164d4601346b7943f38c78c21e4d", "url": "https://github.com/kiegroup/optaplanner/commit/27fa44052c64164d4601346b7943f38c78c21e4d", "message": "BavetNode becomes Comparable", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "fd73950f91e6330bbf5fb96b90ceaaa145b63c5e", "url": "https://github.com/kiegroup/optaplanner/commit/fd73950f91e6330bbf5fb96b90ceaaa145b63c5e", "message": "Add a simple node index test", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "a577c40520644bf3c937f8264179be7ad88bfafe", "url": "https://github.com/kiegroup/optaplanner/commit/a577c40520644bf3c937f8264179be7ad88bfafe", "message": "processNode() does not need node index", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "05cd93dfd907bb33499b74c02647722c2cfda9e3", "url": "https://github.com/kiegroup/optaplanner/commit/05cd93dfd907bb33499b74c02647722c2cfda9e3", "message": "internalize node order maximum updates", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "66eaceb994ffd49a63b1050212006a93c3b4fd35", "url": "https://github.com/kiegroup/optaplanner/commit/66eaceb994ffd49a63b1050212006a93c3b4fd35", "message": "Order stuff properly", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "943539854e2fce9fb385cf7b038acf4d4af62eb2", "url": "https://github.com/kiegroup/optaplanner/commit/943539854e2fce9fb385cf7b038acf4d4af62eb2", "message": "Finally remove all node index arguments", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "9eee086026884c89f406ef9ee9f3f5c06079d728", "url": "https://github.com/kiegroup/optaplanner/commit/9eee086026884c89f406ef9ee9f3f5c06079d728", "message": "Finishing touches", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "d85f892cacea8d12965a891b40927b62a70dfe8b", "url": "https://github.com/kiegroup/optaplanner/commit/d85f892cacea8d12965a891b40927b62a70dfe8b", "message": "Remove a bit more code", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "4c0e92a181a7ab0f4daa502ba16352430beb8513", "url": "https://github.com/kiegroup/optaplanner/commit/4c0e92a181a7ab0f4daa502ba16352430beb8513", "message": "Remove some unused code", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "c7d6e55179f5eb79667316b4b446af33b7e4b247", "url": "https://github.com/kiegroup/optaplanner/commit/c7d6e55179f5eb79667316b4b446af33b7e4b247", "message": "Fix comment", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "fc41f88d9974326125ccaf02637d6d574378a1ac", "url": "https://github.com/kiegroup/optaplanner/commit/fc41f88d9974326125ccaf02637d6d574378a1ac", "message": "Create group bridges in sequence", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "6931a46f5fe4d2d5b83d735ab8ecdca95ebe3a0f", "url": "https://github.com/kiegroup/optaplanner/commit/6931a46f5fe4d2d5b83d735ab8ecdca95ebe3a0f", "message": "Better node indexing algorithm", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "e5154a1a05c9a512d6a903ea5a685467b20af7cc", "url": "https://github.com/kiegroup/optaplanner/commit/e5154a1a05c9a512d6a903ea5a685467b20af7cc", "message": "Fail fast on node indexing", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "fb1fec593b0245fd99cd51eff63dacae9e947d32", "url": "https://github.com/kiegroup/optaplanner/commit/fb1fec593b0245fd99cd51eff63dacae9e947d32", "message": "Make nodes available outside of the session", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "dcd96290c8cdddb8ddbd7d07e9b791bcebc64cf4", "url": "https://github.com/kiegroup/optaplanner/commit/dcd96290c8cdddb8ddbd7d07e9b791bcebc64cf4", "message": "Improve test", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "d356b05b228975847d87854ed088983cbbdc5e43", "url": "https://github.com/kiegroup/optaplanner/commit/d356b05b228975847d87854ed088983cbbdc5e43", "message": "Address code review comments", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "71b570172a360afbf4a710a5ef20bef1cf2a2b41", "url": "https://github.com/kiegroup/optaplanner/commit/71b570172a360afbf4a710a5ef20bef1cf2a2b41", "message": "Make the node list complete", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "fa8e08e69551986e0522a604deb3956a63936d09", "url": "https://github.com/kiegroup/optaplanner/commit/fa8e08e69551986e0522a604deb3956a63936d09", "message": "Remove unused code", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "f9a1e04141463e78f1a976ea90b6165268a2a710", "url": "https://github.com/kiegroup/optaplanner/commit/f9a1e04141463e78f1a976ea90b6165268a2a710", "message": "Nodes need not be Comparable", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "e483776c84cf3f5c3cf8842ef231c84d08106714", "url": "https://github.com/kiegroup/optaplanner/commit/e483776c84cf3f5c3cf8842ef231c84d08106714", "message": "Remove test that is no longer necessary", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "e483776c84cf3f5c3cf8842ef231c84d08106714", "url": "https://github.com/kiegroup/optaplanner/commit/e483776c84cf3f5c3cf8842ef231c84d08106714", "message": "Remove test that is no longer necessary", "committedDate": "2020-12-07T13:24:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjIwNA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r537556204", "bodyText": "Not useful anymore. We now have a better test, and that one checks the node indexes directly.", "author": "triceo", "createdAt": "2020-12-07T14:37:54Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStreamTest.java", "diffHunk": "@@ -1419,45 +1419,6 @@ public void duplicateConstraintId() {\n                 constraintStreamImplType));\n     }\n \n-    @TestTemplate\n-    public void globalNodeOrder() {", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0NDgzNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538244837", "bodyText": "By removing it, this test also doesn't run on CS-D any more?\n+0 to remove if it's fully duplicate for Bavet, including the actual scoreCalculation verification (which seems to be the case).\nYour call.\nIf we do keep it, maybe it should be renamed to something like \"nodeIndexChallenger\" or \"joinFilterLeftBridgeVersusJoinFilterRightBridge\"? Idunno.", "author": "ge0ffrey", "createdAt": "2020-12-08T11:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0Nzk5Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538247996", "bodyText": "CS-D never had node indexes, we need not worry about these things there.\nEverything else this test does is covered elsewhere.", "author": "triceo", "createdAt": "2020-12-08T11:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzMjkwNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538232907", "bodyText": "Interesting approach by pushing that here. It's inline with the rest of what Bavet currently does, so +1.", "author": "ge0ffrey", "createdAt": "2020-12-08T10:44:43Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBridgeBiConstraintStream.java", "diffHunk": "@@ -57,20 +57,23 @@ public void setGroupStream(BavetGroupBiConstraintStream<Solution_, NewA, ResultC\n \n     @Override\n     protected BavetAbstractBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<A, B> parentNode) {\n-        BavetGroupBiNode<NewA, ResultContainer_, NewB> groupNode = groupStream.createNodeChain(buildPolicy, constraintWeight,\n-                nodeOrder + 1, null);\n-        BavetGroupBridgeBiNode<A, B, NewA, ResultContainer_, NewB> node = new BavetGroupBridgeBiNode<>(\n-                buildPolicy.getSession(), nodeOrder, parentNode, groupKeyMapping, collector, groupNode);\n-        return node;\n+            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n+        return new BavetGroupBridgeBiNode<>(buildPolicy.getSession(), buildPolicy.nextNodeIndex(), parentNode,\n+                groupKeyMapping, collector);\n     }\n \n     @Override\n-    protected void createChildNodeChains(BavetNodeBuildPolicy<Solution_> buildPolicy, Score<?> constraintWeight, int nodeOrder,\n+    protected void createChildNodeChains(BavetNodeBuildPolicy<Solution_> buildPolicy, Score<?> constraintWeight,\n             BavetAbstractBiNode<A, B> node) {\n         if (!childStreamList.isEmpty()) {\n             throw new IllegalStateException(\"Impossible state: the stream (\" + this\n                     + \") has an non-empty childStreamList (\" + childStreamList + \") but it's a groupBy bridge.\");\n         }\n+        BavetGroupBiNode<NewA, ResultContainer_, NewB> groupNode = groupStream.createNodeChain(buildPolicy,\n+                constraintWeight, null);", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNTgxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538235819", "bodyText": "Adding that zero is strange. Use at least 16 (or better yet the default): the memory cost of 16 is triviial, especially as only a handfully policy elements will exist, while the cost of sharing 9 nodes will be quite significant already.\nBy the way, due to from() filtering on initialized variables only, there is pretty much always node sharing.\nSo my advise is to remove this line's change.", "author": "ge0ffrey", "createdAt": "2020-12-08T10:48:56Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -16,39 +16,39 @@\n \n package org.optaplanner.core.impl.score.stream.bavet.common;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n+import java.util.List;\n import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n import org.optaplanner.core.impl.score.stream.bavet.BavetConstraintSession;\n \n public class BavetNodeBuildPolicy<Solution_> {\n \n     private final BavetConstraintSession session;\n \n-    private int nodeOrderMaximum = 0;\n+    private int nextNodeIndex = 0;\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n-    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>();\n+    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>(0);", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNzc0NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538237745", "bodyText": "Why is the distinct needed on the nodes? I'd argue if they are not distinct, then node sharing is broken and we want it to fail fast.", "author": "ge0ffrey", "createdAt": "2020-12-08T10:51:45Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -77,4 +77,22 @@ public int getNodeOrderMaximum() {\n         return joinConstraintStreamToJoinBridgeNodeMap;\n     }\n \n+    public List<BavetNode> getCreatedNodes() {\n+        // Make a sequential list of unique nodes.\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n+                constraintIdToScoringNodeMap.values().stream())\n+                .distinct()", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzODYwMw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538238603", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n          \n          \n            \n                                throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b + \") share the same index (\" + a.getNodeIndex() + \").\");", "author": "ge0ffrey", "createdAt": "2020-12-08T10:52:57Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -77,4 +77,22 @@ public int getNodeOrderMaximum() {\n         return joinConstraintStreamToJoinBridgeNodeMap;\n     }\n \n+    public List<BavetNode> getCreatedNodes() {\n+        // Make a sequential list of unique nodes.\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n+                constraintIdToScoringNodeMap.values().stream())\n+                .distinct()\n+                .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n+                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzOTAzMA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538239030", "bodyText": "Motivation: grammar (\"the\", etc) and show the node index in that error message if we have it available anyway.", "author": "ge0ffrey", "createdAt": "2020-12-08T10:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzODYwMw=="}], "type": "inlineReview"}, {"oid": "d4d5d3ca1adfc00bfe1495e2121e83fc76555fe5", "url": "https://github.com/kiegroup/optaplanner/commit/d4d5d3ca1adfc00bfe1495e2121e83fc76555fe5", "message": "Update optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n\nCo-authored-by: Geoffrey De Smet <gds.geoffrey.de.smet@gmail.com>", "committedDate": "2020-12-08T11:07:46Z", "type": "commit"}, {"oid": "b496437ad158f4ae76af1f3602a74da64435f92b", "url": "https://github.com/kiegroup/optaplanner/commit/b496437ad158f4ae76af1f3602a74da64435f92b", "message": "Address code review comments", "committedDate": "2020-12-08T11:09:13Z", "type": "commit"}, {"oid": "64a07396c3afb79ad49c51513de8c2084bd8d9a0", "url": "https://github.com/kiegroup/optaplanner/commit/64a07396c3afb79ad49c51513de8c2084bd8d9a0", "message": "Fix bug", "committedDate": "2020-12-08T11:27:46Z", "type": "commit"}]}