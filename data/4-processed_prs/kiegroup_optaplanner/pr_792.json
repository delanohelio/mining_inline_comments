{"pr_number": 792, "pr_title": "PLANNER-1961 Only process trailing entities when there's supply", "pr_createdAt": "2020-05-28T08:16:56Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/792", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY2ODk0OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r431668949", "bodyText": "And this is why you don't put types of variables in variable names. This implementation detail now proliferated into places of this PR, which would otherwise be unaffected.", "author": "triceo", "createdAt": "2020-05-28T08:30:32Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java", "diffHunk": "@@ -90,26 +94,19 @@ public boolean supportsPhaseAndSolverCaching() {\n     public void solvingStarted(DefaultSolverScope solverScope) {\n         super.solvingStarted(solverScope);\n         if (anyChained) {\n-            inverseVariableSupplyList = new ArrayList<>(variableDescriptorList.size());\n             SupplyManager supplyManager = solverScope.getScoreDirector().getSupplyManager();\n-            for (GenuineVariableDescriptor variableDescriptor : variableDescriptorList) {\n-                SingletonInverseVariableSupply inverseVariableSupply;\n-                if (variableDescriptor.isChained()) {\n-                    inverseVariableSupply = supplyManager.demand(\n-                            new SingletonInverseVariableDemand(variableDescriptor));\n-                } else {\n-                    inverseVariableSupply = null;\n-                }\n-                inverseVariableSupplyList.add(inverseVariableSupply);\n-            }\n+            inverseVariableSupplyMap = variableDescriptorList.stream()\n+                    .filter(GenuineVariableDescriptor::isChained)\n+                    .collect(toMap(Functions.identity(), variableDescriptor -> supplyManager\n+                            .demand(new SingletonInverseVariableDemand(variableDescriptor))));\n         }\n     }\n \n     @Override\n     public void solvingEnded(DefaultSolverScope solverScope) {\n         super.solvingEnded(solverScope);\n         if (anyChained) {\n-            inverseVariableSupplyList = null;\n+            inverseVariableSupplyMap = null;", "originalCommit": "caf0ec79730961ed68545fb48958b397960ac89f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3Mzk4NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433073985", "bodyText": "So when I have a plannning entity LessonVisit with a chained planning variable previous and a non-chained planning variable room, this code will execute for the room  too? That room should behave like a normal swap. Does it?\nWhat happens to room if it's trailing entities are null, both left and right? I guess it behaves like a normal swap move indeed?", "author": "ge0ffrey", "createdAt": "2020-06-01T07:04:42Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "diffHunk": "@@ -74,8 +77,8 @@ protected void doMoveOnGenuineVariables(ScoreDirector<Solution_> scoreDirector)\n                     scoreDirector.changeVariableFacade(variableDescriptor, leftEntity, oldRightValue);\n                     scoreDirector.changeVariableFacade(variableDescriptor, rightEntity, oldLeftValue);\n                 } else {\n-                    Object oldLeftTrailingEntity = oldLeftTrailingEntityList.get(i);\n-                    Object oldRightTrailingEntity = oldRightTrailingEntityList.get(i);\n+                    Object oldLeftTrailingEntity = oldLeftTrailingEntityMap.get(variableDescriptor);\n+                    Object oldRightTrailingEntity = oldRightTrailingEntityMap.get(variableDescriptor);", "originalCommit": "caf0ec79730961ed68545fb48958b397960ac89f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NDI4NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433074285", "bodyText": "I think the code behaves correctly, but we should add a test for it.", "author": "ge0ffrey", "createdAt": "2020-06-01T07:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3Mzk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NDI2OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433074269", "bodyText": "This is where you put the null that is then thrown later.", "author": "triceo", "createdAt": "2020-06-01T07:05:34Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java", "diffHunk": "@@ -90,26 +94,19 @@ public boolean supportsPhaseAndSolverCaching() {\n     public void solvingStarted(DefaultSolverScope solverScope) {\n         super.solvingStarted(solverScope);\n         if (anyChained) {\n-            inverseVariableSupplyList = new ArrayList<>(variableDescriptorList.size());\n             SupplyManager supplyManager = solverScope.getScoreDirector().getSupplyManager();\n-            for (GenuineVariableDescriptor variableDescriptor : variableDescriptorList) {\n-                SingletonInverseVariableSupply inverseVariableSupply;\n-                if (variableDescriptor.isChained()) {\n-                    inverseVariableSupply = supplyManager.demand(\n-                            new SingletonInverseVariableDemand(variableDescriptor));\n-                } else {\n-                    inverseVariableSupply = null;", "originalCommit": "caf0ec79730961ed68545fb48958b397960ac89f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NDQ4OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433074489", "bodyText": "This is where the null would be thrown.\nI fix that by not iterating over the cases where the null would be thrown. (Non-chained vars.)", "author": "triceo", "createdAt": "2020-06-01T07:06:13Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "diffHunk": "@@ -31,26 +32,28 @@\n  */\n public class ChainedSwapMove<Solution_> extends SwapMove<Solution_> {\n \n-    protected final List<Object> oldLeftTrailingEntityList;\n-    protected final List<Object> oldRightTrailingEntityList;\n+    protected final Map<GenuineVariableDescriptor<Solution_>, Object> oldLeftTrailingEntityMap;\n+    protected final Map<GenuineVariableDescriptor<Solution_>, Object> oldRightTrailingEntityMap;\n \n     public ChainedSwapMove(List<GenuineVariableDescriptor<Solution_>> variableDescriptorList,\n-            List<SingletonInverseVariableSupply> inverseVariableSupplyList, Object leftEntity, Object rightEntity) {\n+            Map<GenuineVariableDescriptor<Solution_>, SingletonInverseVariableSupply> inverseVariableSupplyMap,\n+            Object leftEntity, Object rightEntity) {\n         super(variableDescriptorList, leftEntity, rightEntity);\n-        oldLeftTrailingEntityList = new ArrayList<>(inverseVariableSupplyList.size());\n-        oldRightTrailingEntityList = new ArrayList<>(inverseVariableSupplyList.size());\n-        for (SingletonInverseVariableSupply inverseVariableSupply : inverseVariableSupplyList) {\n-            oldLeftTrailingEntityList.add(inverseVariableSupply.getInverseSingleton(leftEntity));\n-            oldRightTrailingEntityList.add(inverseVariableSupply.getInverseSingleton(rightEntity));", "originalCommit": "caf0ec79730961ed68545fb48958b397960ac89f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NzcwMg==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433077702", "bodyText": "I'd iterate over them, to avoid changing an indexed lookup by a hashed lookup later on, but put in null if they don't exist, instead of throwing an NPE. wdyt?", "author": "ge0ffrey", "createdAt": "2020-06-01T07:15:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NDQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NzI2MA==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433077260", "bodyText": "These map calls are a performance loss. We're replacing an indexed lookup by a hash lookup.\nI'd keep the index lookup (so the trailingEntityList has the same size as variableDescriptorList and their indexes match), but given that \"Object oldLeftTrailingEntity \" can be null, I 'd put a null as an element where we cache that (move constructor)", "author": "ge0ffrey", "createdAt": "2020-06-01T07:14:37Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "diffHunk": "@@ -74,8 +77,8 @@ protected void doMoveOnGenuineVariables(ScoreDirector<Solution_> scoreDirector)\n                     scoreDirector.changeVariableFacade(variableDescriptor, leftEntity, oldRightValue);\n                     scoreDirector.changeVariableFacade(variableDescriptor, rightEntity, oldLeftValue);\n                 } else {\n-                    Object oldLeftTrailingEntity = oldLeftTrailingEntityList.get(i);\n-                    Object oldRightTrailingEntity = oldRightTrailingEntityList.get(i);\n+                    Object oldLeftTrailingEntity = oldLeftTrailingEntityMap.get(variableDescriptor);", "originalCommit": "caf0ec79730961ed68545fb48958b397960ac89f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "393961a4cdcd29ee810af182798127b841b27a7f", "url": "https://github.com/kiegroup/optaplanner/commit/393961a4cdcd29ee810af182798127b841b27a7f", "message": "PLANNER-1961 Only create inverse singletons for chained vars", "committedDate": "2020-06-01T14:55:31Z", "type": "commit"}, {"oid": "294762c60ba25c02317b187e2e9b7c3aaa392328", "url": "https://github.com/kiegroup/optaplanner/commit/294762c60ba25c02317b187e2e9b7c3aaa392328", "message": "PLANNER-1961 Add test for correct swap moves", "committedDate": "2020-06-01T15:25:40Z", "type": "commit"}, {"oid": "294762c60ba25c02317b187e2e9b7c3aaa392328", "url": "https://github.com/kiegroup/optaplanner/commit/294762c60ba25c02317b187e2e9b7c3aaa392328", "message": "PLANNER-1961 Add test for correct swap moves", "committedDate": "2020-06-01T15:25:40Z", "type": "forcePushed"}, {"oid": "eec39132a94378b750578cc8a2a566a4fb2c72d5", "url": "https://github.com/kiegroup/optaplanner/commit/eec39132a94378b750578cc8a2a566a4fb2c72d5", "message": "PLANNER-1961 Final fields", "committedDate": "2020-06-01T15:28:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzQ1OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433857459", "bodyText": "(very soft) I 'd have used TestdataValue as a type for unchainedObject, calling it unchainedValue instead, for consistency with other testdata. But it doesn't matter much.", "author": "ge0ffrey", "createdAt": "2020-06-02T13:03:17Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/chained/TestdataChainedEntity.java", "diffHunk": "@@ -39,7 +39,15 @@\n         return entityDescriptor.getGenuineVariableDescriptor(\"chainedObject\");\n     }\n \n+    public static GenuineVariableDescriptor<TestdataChainedSolution> buildVariableDescriptorForUnchainedObject() {\n+        SolutionDescriptor<TestdataChainedSolution> solutionDescriptor = TestdataChainedSolution.buildSolutionDescriptor();\n+        EntityDescriptor<TestdataChainedSolution> entityDescriptor = solutionDescriptor\n+                .findEntityDescriptorOrFail(TestdataChainedEntity.class);\n+        return entityDescriptor.getGenuineVariableDescriptor(\"unchainedObject\");\n+    }\n+\n     private TestdataChainedObject chainedObject;\n+    private TestdataObject unchainedObject;", "originalCommit": "eec39132a94378b750578cc8a2a566a4fb2c72d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c558c0d3d1d8cd8f3ac9938c7a9311d5fef0a8b6", "url": "https://github.com/kiegroup/optaplanner/commit/c558c0d3d1d8cd8f3ac9938c7a9311d5fef0a8b6", "message": "Address final review comment", "committedDate": "2020-06-02T13:18:34Z", "type": "commit"}]}