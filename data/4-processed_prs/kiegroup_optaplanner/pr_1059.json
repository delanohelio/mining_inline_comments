{"pr_number": 1059, "pr_title": "PLANNER-2264: Gizmo Member Accessor", "pr_createdAt": "2020-12-02T17:06:57Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/1059", "timeline": [{"oid": "73f68ab9de95dbfbf5fd5d02fa7e2b0fbee2bcb3", "url": "https://github.com/kiegroup/optaplanner/commit/73f68ab9de95dbfbf5fd5d02fa7e2b0fbee2bcb3", "message": "Organize wrapper classes, added comments to main generator", "committedDate": "2020-12-14T21:32:47Z", "type": "forcePushed"}, {"oid": "c573c771e287b1037058b488a0bb9a5d8ab94944", "url": "https://github.com/kiegroup/optaplanner/commit/c573c771e287b1037058b488a0bb9a5d8ab94944", "message": "Rebase fixup", "committedDate": "2020-12-16T19:23:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxODgxMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545718811", "bodyText": "Version properties must be in alphabetical order of groupId, no \"***\" lines etc", "author": "ge0ffrey", "createdAt": "2020-12-18T09:47:30Z", "path": "build/optaplanner-build-parent/pom.xml", "diffHunk": "@@ -31,6 +31,10 @@\n     <version.com.h2database>1.3.173</version.com.h2database>\n     <version.com.thoughtworks.xstream>1.4.14</version.com.thoughtworks.xstream>\n     <version.io.quarkus>1.10.0.Final</version.io.quarkus>\n+    <!-- keep these aligned with gizmo -->\n+    <version.io.quarkus.gizmo>1.0.4.Final</version.io.quarkus.gizmo>\n+    <version.org.jboss.jandex>2.1.3.Final</version.org.jboss.jandex>\n+    <!-- ***************************** -->", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyNDQwMA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545724400", "bodyText": "Every time we upgrade Quarkus, we need to upgrade Gizmo and Jandex (it's unlikely we every upgrade gizmo or jandex indepentenly of Quarkus).\nSo I'd remove this comment and add one above the Quarkus version:\n<-- Keep in sync with the versions of org.quarkus.gizmo and org.jboss.jandex -->\nThe Quarkus bom defines gizmo and jandex, but we only import it for optaplanner-quarkus-integration in fear of disrupting OptaPlanner's dependencies. We should set up a meeting with Radovan to see if we can and want to just import the quarkus-bom in optaplanner-build-parent (different issue). Meanwhile that comment will have to do.\n@rsynek Wdyt?", "author": "ge0ffrey", "createdAt": "2020-12-18T09:57:14Z", "path": "build/optaplanner-build-parent/pom.xml", "diffHunk": "@@ -31,6 +31,10 @@\n     <version.com.h2database>1.3.173</version.com.h2database>\n     <version.com.thoughtworks.xstream>1.4.14</version.com.thoughtworks.xstream>\n     <version.io.quarkus>1.10.0.Final</version.io.quarkus>\n+    <!-- keep these aligned with gizmo -->", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI5MjczMw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551292733", "bodyText": "Would importing the Quarkus BOM bring any version conflicts on our existing dependencies?)", "author": "rsynek", "createdAt": "2021-01-04T12:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyNDQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM3MTgzMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551371831", "bodyText": "@rsynek We should seriously consider doing that, importing the quarkus bom (not the quarkus platform bom!), but let's do that in a separate issue? Part of that issue would be researching which versions conflicts we have.", "author": "ge0ffrey", "createdAt": "2021-01-04T15:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyNDQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyNTE5OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545725198", "bodyText": "(important) Out of sync with our quarkus bom version.\nquarkus-bom 1.10.0.Final has\n\n        <jandex.version>2.2.1.Final</jandex.version>\n       ...\n        <gizmo.version>1.0.6.Final</gizmo.version>", "author": "ge0ffrey", "createdAt": "2020-12-18T09:58:29Z", "path": "build/optaplanner-build-parent/pom.xml", "diffHunk": "@@ -31,6 +31,10 @@\n     <version.com.h2database>1.3.173</version.com.h2database>\n     <version.com.thoughtworks.xstream>1.4.14</version.com.thoughtworks.xstream>\n     <version.io.quarkus>1.10.0.Final</version.io.quarkus>\n+    <!-- keep these aligned with gizmo -->\n+    <version.io.quarkus.gizmo>1.0.4.Final</version.io.quarkus.gizmo>\n+    <version.org.jboss.jandex>2.1.3.Final</version.org.jboss.jandex>", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyODI3Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545728276", "bodyText": "Should this be in package \"config\", \"api\" or \"impl\"?\nI'd argue \"api\", because I have a sneaking feeling we might see this in annotation parameters in the future too (see SolutionCloner parameters in @PlanningSolution).", "author": "ge0ffrey", "createdAt": "2020-12-18T10:04:36Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/DomainAccessType.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.config.solver;", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMjg4MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545732880", "bodyText": "package \"solver\" is not appropriate, we have the \"domain\" package which fits better (it doesn't matter that in config there is no domain package yet: if a subpackage exists in one of the 3 (api/config/impl), it exists in all three).\n\n\nIs this worthy to be directly in the domain package or does it need a subpackage? I 'd argue it's not important enough to be at the top. How about \"domain.common\", \"domain.lang\" or \"domain.access\"?\n\n\nProposal A) org.optaplanner.core.api.domain.common\nLet's meet up when @rsynek is available to decide on these naming discussions.", "author": "ge0ffrey", "createdAt": "2020-12-18T10:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyODI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTg1MTMyMA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r555851320", "bodyText": "Proposal A is decided in meeting.", "author": "ge0ffrey", "createdAt": "2021-01-12T15:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyODI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMzE1OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545733159", "bodyText": "Javadocs, see LookUpStrategyType on how the writing style looks.\nAlso on every enum.\nPut yourself in a user's shoe. What is important in their decision making process? Don't add all the information you know - only the information they would/should care about.\nFor example, for GIZMO, I'd start with \"Generate bytecode to ...\"", "author": "ge0ffrey", "createdAt": "2020-12-18T10:13:40Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/DomainAccessType.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.config.solver;\n+", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMzY2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545733665", "bodyText": "Naming: Do we access a domain? Or do we access a Member of the domain?\nProposal A) DomainAccessType\nProposal B) MemberAccessType\nI'd argue that B) is more appropriate", "author": "ge0ffrey", "createdAt": "2020-12-18T10:14:31Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/DomainAccessType.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.config.solver;\n+\n+public enum DomainAccessType {", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5ODYwOA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545898608", "bodyText": "This enum might also be used for the SolutionCloner (in which case DomainAccessType is probably more apt)", "author": "Christopher-Chianelli", "createdAt": "2020-12-18T15:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMzY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyMzQxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545923419", "bodyText": "Agreed, my bad.", "author": "ge0ffrey", "createdAt": "2020-12-18T15:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMzY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczNTQ4Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545735486", "bodyText": "Reflection is ambiguous. Does LamdbaMetaFactory count as reflection? And MethodHandles/VarHandles?\nSomething to discuss. I suspect we might want to offer all basic options (old school reflection, methodhandles, lamdba meta factory, gizmo) and then the advanced option (auto choose between old school reflection, methodhandles, lamdba meta factory), which is the default?\nBtw, GIZMO is a perfect name.", "author": "ge0ffrey", "createdAt": "2020-12-18T10:17:49Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/DomainAccessType.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.config.solver;\n+\n+public enum DomainAccessType {\n+    REFLECTION,", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc1ODE0Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545758142", "bodyText": "Putting in between solutionClass and entityClassList (in xsd, fields, get/set/with methods, etc) seems wierd, because:\n\nit applies to both\nif a user defines solutionClass, he/she defines entityClassList. But this new field is much rarer.\n\nProposal A) Put it under entityClassList, because the others are more important (important properties should go first)\nProposal B) Out it above solutionClass because it's a general property.\n+1 for A, +0 for B.", "author": "ge0ffrey", "createdAt": "2020-12-18T11:00:28Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/SolverConfig.java", "diffHunk": "@@ -235,6 +236,8 @@ public static SolverConfig createFromXmlReader(Reader reader, ClassLoader classL\n     protected Class<? extends ThreadFactory> threadFactoryClass = null;\n \n     protected Class<?> solutionClass = null;\n+\n+    protected DomainAccessType domainAccessType = null;", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI5NzI1NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551297254", "bodyText": "+1 to A. If you move the property, please don't forget to move also its mention in the @XmlType annotation over the class.", "author": "rsynek", "createdAt": "2021-01-04T12:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc1ODE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MTU1OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545761559", "bodyText": "Method signature: domainAccessType is less important to understand this code than member and FIELD_OR_READ_METHOD and even the PlanningId.class. Let's make that the last parameter.", "author": "ge0ffrey", "createdAt": "2020-12-18T11:07:07Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/util/ConfigUtils.java", "diffHunk": "@@ -401,8 +402,9 @@ public static int resolvePoolSize(String propertyName, String value, String... m\n                     + PlanningId.class.getSimpleName() + \" annotation.\");\n         }\n         Member member = memberList.get(0);\n-        MemberAccessor memberAccessor = MemberAccessorFactory.buildMemberAccessor(member, FIELD_OR_READ_METHOD,\n-                PlanningId.class);\n+        MemberAccessor memberAccessor =\n+                MemberAccessorFactory.buildMemberAccessor(domainAccessType, member, FIELD_OR_READ_METHOD,", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MTg4OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545761889", "bodyText": "Let's make domainAccessType the last parameter, because when reading code that calls this method, the clazz (= the what) is more important than the accesstype (the how)", "author": "ge0ffrey", "createdAt": "2020-12-18T11:07:50Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/util/ConfigUtils.java", "diffHunk": "@@ -390,7 +391,7 @@ public static int resolvePoolSize(String propertyName, String value, String... m\n         }\n     }\n \n-    public static <C> MemberAccessor findPlanningIdMemberAccessor(Class<C> clazz) {\n+    public static <C> MemberAccessor findPlanningIdMemberAccessor(DomainAccessType domainAccessType, Class<C> clazz) {", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MzA5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545763091", "bodyText": "Smells like code duplication with the lines above.\nWhat about an array of arrays - is that unit tested?", "author": "ge0ffrey", "createdAt": "2020-12-18T11:10:13Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoAnnotationWrappers.java", "diffHunk": "@@ -0,0 +1,690 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.IndexView;\n+import org.optaplanner.core.api.domain.autodiscover.AutoDiscoverMemberType;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfiguration;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfigurationProvider;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintWeight;\n+import org.optaplanner.core.api.domain.entity.PinningFilter;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.lookup.LookUpStrategyType;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.ProblemFactProperty;\n+import org.optaplanner.core.api.domain.solution.cloner.SolutionCloner;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableGraphType;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableReference;\n+import org.optaplanner.core.api.domain.variable.VariableListener;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.score.definition.ScoreDefinition;\n+\n+/**\n+ * Contains wrappers for Annotations so they may be\n+ * recorded in bytecode. The annotation's values are stored\n+ * in the wrapper's map.\n+ */\n+public class GizmoAnnotationWrappers {\n+\n+    enum AllOptaPlannerAnnotationEnum {\n+        CONSTRAINT_CONFIGURATION(ConstraintConfiguration.class,\n+                ConstraintConfigurationWrapper::new),\n+        CONSTRAINT_CONFIGURATION_PROVIDER(ConstraintConfigurationProvider.class,\n+                ConstraintConfigurationProviderWrapper::new),\n+        CONSTRAINT_WEIGHT(ConstraintWeight.class, ConstraintWeightWrapper::new),\n+        PLANNING_ENTITY(PlanningEntity.class, PlanningEntityWrapper::new),\n+        PLANNING_PIN(PlanningPin.class, PlanningPinWrapper::new),\n+        PLANNING_ID(PlanningId.class, PlanningIdWrapper::new),\n+        PLANNING_ENTITY_COLLECTION_PROPERTY(PlanningEntityCollectionProperty.class,\n+                PlanningEntityCollectionPropertyWrapper::new),\n+        PLANNING_ENTITY_PROPERTY(PlanningEntityProperty.class,\n+                PlanningEntityPropertyWrapper::new),\n+        PLANNING_SCORE(PlanningScore.class, PlanningScoreWrapper::new),\n+        PLANNING_SOLUTION(PlanningSolution.class, PlanningSolutionWrapper::new),\n+        PROBLEM_FACT_COLLECTION_PROPERTY(ProblemFactCollectionProperty.class,\n+                ProblemFactCollectionPropertyWrapper::new),\n+        PROBLEM_FACT_PROPERTY(ProblemFactProperty.class, ProblemFactPropertyWrapper::new),\n+        VALUE_RANGE_PROVIDER(ValueRangeProvider.class, ValueRangeProviderWrapper::new),\n+        ANCHOR_SHADOW_VARIABLE(AnchorShadowVariable.class, AnchorShadowVariableWrapper::new),\n+        CUSTOM_SHADOW_VARIABLE(CustomShadowVariable.class, CustomShadowVariableWrapper::new),\n+        INVERSE_RELATION_SHADOW_VARIABLE(InverseRelationShadowVariable.class,\n+                InverseRelationShadowVariableWrapper::new),\n+        PLANNING_VARIABLE(PlanningVariable.class, PlanningVariableWrapper::new),\n+        PLANNING_VARIABLE_REFERENCE(PlanningVariableReference.class, PlanningVariableReferenceWrapper::new);\n+\n+        Class<?> annotationClass;\n+        Function<Map<String, Object>, Annotation> mapper;\n+\n+        <T extends Annotation> AllOptaPlannerAnnotationEnum(Class<? extends T> annotationClass,\n+                Function<Map<String, Object>, T> mapper) {\n+            this.annotationClass = annotationClass;\n+            this.mapper = (Function<Map<String, Object>, Annotation>) mapper;\n+        }\n+\n+        public Annotation get(Map<String, Object> values) {\n+            return mapper.apply(values);\n+        }\n+\n+        public static Annotation getForClass(Class<? extends Annotation> annotationClass, Map<String, Object> values) {\n+            for (AllOptaPlannerAnnotationEnum annotationType : AllOptaPlannerAnnotationEnum.values()) {\n+                if (annotationClass.equals(annotationType.annotationClass)) {\n+                    return annotationType.get(values);\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Missing case for \" + annotationClass);\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(Class<? extends Annotation> annotationClass) {\n+            return isOptaPlannerAnnotation(annotationClass.getName());\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(String annotationClass) {\n+            return annotationClass.startsWith(\"org.optaplanner.\");\n+        }\n+    }\n+\n+    public static class AnnotationWrapper implements Supplier<Annotation> {\n+        Class<? extends Annotation> annotationType;\n+        Map<String, Object> annotationValues = new HashMap<String, Object>();\n+        Annotation annotation;\n+\n+        public AnnotationWrapper() {\n+        }\n+\n+        public AnnotationWrapper(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+\n+        public AnnotationWrapper(AnnotationInstance annotationInstance, IndexView indexView) {\n+            try {\n+                annotationType = (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(e);\n+            }\n+            annotationValues = new HashMap<>();\n+            if (AllOptaPlannerAnnotationEnum.isOptaPlannerAnnotation(annotationType)) {\n+                annotationInstance.valuesWithDefaults(indexView).forEach((value) -> {\n+                    switch (value.kind()) {\n+                        case BYTE:\n+                            annotationValues.put(value.name(),\n+                                    value.asByte());\n+                            break;\n+                        case SHORT:\n+                            annotationValues.put(value.name(),\n+                                    value.asShort());\n+                            break;\n+                        case INTEGER:\n+                            annotationValues.put(value.name(),\n+                                    value.asInt());\n+                            break;\n+                        case CHARACTER:\n+                            annotationValues.put(value.name(),\n+                                    value.asChar());\n+                            break;\n+                        case FLOAT:\n+                            annotationValues.put(value.name(),\n+                                    value.asFloat());\n+                            break;\n+                        case DOUBLE:\n+                            annotationValues.put(value.name(),\n+                                    value.asDouble());\n+                            break;\n+                        case LONG:\n+                            annotationValues.put(value.name(),\n+                                    value.asLong());\n+                            break;\n+                        case BOOLEAN:\n+                            annotationValues.put(value.name(),\n+                                    value.asBoolean());\n+                            break;\n+                        case CLASS:\n+                            try {\n+                                annotationValues.put(value.name(),\n+                                        Class.forName(value.asClass().toString()));\n+                            } catch (ClassNotFoundException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                            break;\n+                        case STRING:\n+                            annotationValues.put(value.name(),\n+                                    value.asString());\n+                            break;\n+                        case ENUM:\n+                            annotationValues.put(value.name(),\n+                                    value.asEnum());\n+                            break;\n+                        case ARRAY:\n+                            switch (value.componentKind()) {\n+                                case BYTE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asByteArray());\n+                                    break;", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4ODMzMg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552188332", "bodyText": "According to Jandex javadocs, arrays of arrays do not exists as an annotation value:\nAn annotation value represents a specific name and value combination in the parameter list of an annotation instance. It also can represent a nested array element in the case of an array value.\nAn annotation value can be any Java primitive:\n\nbyte\nshort\nint\nchar\nfloat\ndouble\nlong\nboolean\n\n\nAs well as any the following specialty types:\n\nString\nClass\nEnum\nNested annotation\n\n\nIn addition a value can be a single-dimension array of any of the above types\nTo access a value, the proper typed method must be used that matches the expected type of the annotation parameter. In addition, some methods will allow conversion of different types. For example, a byte can be returned as an integer using asInt(). Also all value types support a String representation.\nTo determine the underlying type, kind() can be used.", "author": "Christopher-Chianelli", "createdAt": "2021-01-05T20:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MzA5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4ODk2Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552188963", "bodyText": "(also cannot remove the duplication; different methods are used for arrays/single)", "author": "Christopher-Chianelli", "createdAt": "2021-01-05T20:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MzA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MzUyMA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545763520", "bodyText": "Don't sweep anything under the carpet.\nEither it works, or fail fast. That's the 2 options.", "author": "ge0ffrey", "createdAt": "2020-12-18T11:10:53Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoAnnotationWrappers.java", "diffHunk": "@@ -0,0 +1,690 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.IndexView;\n+import org.optaplanner.core.api.domain.autodiscover.AutoDiscoverMemberType;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfiguration;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfigurationProvider;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintWeight;\n+import org.optaplanner.core.api.domain.entity.PinningFilter;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.lookup.LookUpStrategyType;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.ProblemFactProperty;\n+import org.optaplanner.core.api.domain.solution.cloner.SolutionCloner;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableGraphType;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableReference;\n+import org.optaplanner.core.api.domain.variable.VariableListener;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.score.definition.ScoreDefinition;\n+\n+/**\n+ * Contains wrappers for Annotations so they may be\n+ * recorded in bytecode. The annotation's values are stored\n+ * in the wrapper's map.\n+ */\n+public class GizmoAnnotationWrappers {\n+\n+    enum AllOptaPlannerAnnotationEnum {\n+        CONSTRAINT_CONFIGURATION(ConstraintConfiguration.class,\n+                ConstraintConfigurationWrapper::new),\n+        CONSTRAINT_CONFIGURATION_PROVIDER(ConstraintConfigurationProvider.class,\n+                ConstraintConfigurationProviderWrapper::new),\n+        CONSTRAINT_WEIGHT(ConstraintWeight.class, ConstraintWeightWrapper::new),\n+        PLANNING_ENTITY(PlanningEntity.class, PlanningEntityWrapper::new),\n+        PLANNING_PIN(PlanningPin.class, PlanningPinWrapper::new),\n+        PLANNING_ID(PlanningId.class, PlanningIdWrapper::new),\n+        PLANNING_ENTITY_COLLECTION_PROPERTY(PlanningEntityCollectionProperty.class,\n+                PlanningEntityCollectionPropertyWrapper::new),\n+        PLANNING_ENTITY_PROPERTY(PlanningEntityProperty.class,\n+                PlanningEntityPropertyWrapper::new),\n+        PLANNING_SCORE(PlanningScore.class, PlanningScoreWrapper::new),\n+        PLANNING_SOLUTION(PlanningSolution.class, PlanningSolutionWrapper::new),\n+        PROBLEM_FACT_COLLECTION_PROPERTY(ProblemFactCollectionProperty.class,\n+                ProblemFactCollectionPropertyWrapper::new),\n+        PROBLEM_FACT_PROPERTY(ProblemFactProperty.class, ProblemFactPropertyWrapper::new),\n+        VALUE_RANGE_PROVIDER(ValueRangeProvider.class, ValueRangeProviderWrapper::new),\n+        ANCHOR_SHADOW_VARIABLE(AnchorShadowVariable.class, AnchorShadowVariableWrapper::new),\n+        CUSTOM_SHADOW_VARIABLE(CustomShadowVariable.class, CustomShadowVariableWrapper::new),\n+        INVERSE_RELATION_SHADOW_VARIABLE(InverseRelationShadowVariable.class,\n+                InverseRelationShadowVariableWrapper::new),\n+        PLANNING_VARIABLE(PlanningVariable.class, PlanningVariableWrapper::new),\n+        PLANNING_VARIABLE_REFERENCE(PlanningVariableReference.class, PlanningVariableReferenceWrapper::new);\n+\n+        Class<?> annotationClass;\n+        Function<Map<String, Object>, Annotation> mapper;\n+\n+        <T extends Annotation> AllOptaPlannerAnnotationEnum(Class<? extends T> annotationClass,\n+                Function<Map<String, Object>, T> mapper) {\n+            this.annotationClass = annotationClass;\n+            this.mapper = (Function<Map<String, Object>, Annotation>) mapper;\n+        }\n+\n+        public Annotation get(Map<String, Object> values) {\n+            return mapper.apply(values);\n+        }\n+\n+        public static Annotation getForClass(Class<? extends Annotation> annotationClass, Map<String, Object> values) {\n+            for (AllOptaPlannerAnnotationEnum annotationType : AllOptaPlannerAnnotationEnum.values()) {\n+                if (annotationClass.equals(annotationType.annotationClass)) {\n+                    return annotationType.get(values);\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Missing case for \" + annotationClass);\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(Class<? extends Annotation> annotationClass) {\n+            return isOptaPlannerAnnotation(annotationClass.getName());\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(String annotationClass) {\n+            return annotationClass.startsWith(\"org.optaplanner.\");\n+        }\n+    }\n+\n+    public static class AnnotationWrapper implements Supplier<Annotation> {\n+        Class<? extends Annotation> annotationType;\n+        Map<String, Object> annotationValues = new HashMap<String, Object>();\n+        Annotation annotation;\n+\n+        public AnnotationWrapper() {\n+        }\n+\n+        public AnnotationWrapper(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+\n+        public AnnotationWrapper(AnnotationInstance annotationInstance, IndexView indexView) {\n+            try {\n+                annotationType = (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(e);\n+            }\n+            annotationValues = new HashMap<>();\n+            if (AllOptaPlannerAnnotationEnum.isOptaPlannerAnnotation(annotationType)) {\n+                annotationInstance.valuesWithDefaults(indexView).forEach((value) -> {\n+                    switch (value.kind()) {\n+                        case BYTE:\n+                            annotationValues.put(value.name(),\n+                                    value.asByte());\n+                            break;\n+                        case SHORT:\n+                            annotationValues.put(value.name(),\n+                                    value.asShort());\n+                            break;\n+                        case INTEGER:\n+                            annotationValues.put(value.name(),\n+                                    value.asInt());\n+                            break;\n+                        case CHARACTER:\n+                            annotationValues.put(value.name(),\n+                                    value.asChar());\n+                            break;\n+                        case FLOAT:\n+                            annotationValues.put(value.name(),\n+                                    value.asFloat());\n+                            break;\n+                        case DOUBLE:\n+                            annotationValues.put(value.name(),\n+                                    value.asDouble());\n+                            break;\n+                        case LONG:\n+                            annotationValues.put(value.name(),\n+                                    value.asLong());\n+                            break;\n+                        case BOOLEAN:\n+                            annotationValues.put(value.name(),\n+                                    value.asBoolean());\n+                            break;\n+                        case CLASS:\n+                            try {\n+                                annotationValues.put(value.name(),\n+                                        Class.forName(value.asClass().toString()));\n+                            } catch (ClassNotFoundException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                            break;\n+                        case STRING:\n+                            annotationValues.put(value.name(),\n+                                    value.asString());\n+                            break;\n+                        case ENUM:\n+                            annotationValues.put(value.name(),\n+                                    value.asEnum());\n+                            break;\n+                        case ARRAY:\n+                            switch (value.componentKind()) {\n+                                case BYTE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asByteArray());\n+                                    break;\n+                                case SHORT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asShortArray());\n+                                    break;\n+                                case INTEGER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asIntArray());\n+                                    break;\n+                                case CHARACTER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asCharArray());\n+                                    break;\n+                                case FLOAT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asFloatArray());\n+                                    break;\n+                                case DOUBLE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asDoubleArray());\n+                                    break;\n+                                case LONG:\n+                                    annotationValues.put(value.name(),\n+                                            value.asLongArray());\n+                                    break;\n+                                case BOOLEAN:\n+                                    annotationValues.put(value.name(),\n+                                            value.asBooleanArray());\n+                                    break;\n+                                case CLASS:\n+                                    Class[] valueArr = Arrays.stream(value.asClassArray())\n+                                            .map(v -> {\n+                                                try {\n+                                                    return Class.forName(v.toString());\n+                                                } catch (ClassNotFoundException e) {\n+                                                    throw new IllegalStateException(e);\n+                                                }\n+                                            })\n+                                            .collect(Collectors.toList()).toArray(new Class[0]);\n+                                    annotationValues.put(value.name(),\n+                                            valueArr);\n+                                    break;\n+                                case STRING:\n+                                    annotationValues.put(value.name(),\n+                                            value.asStringArray());\n+                                    break;\n+                                case ENUM:\n+                                    annotationValues.put(value.name(),\n+                                            value.asEnumArray());\n+                                    break;\n+                                case ARRAY:\n+                                case NESTED:\n+                                case UNKNOWN:\n+                                    break;", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE3Nzc2NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552177764", "bodyText": "Done (Nested now handled for Arrays and single; Unknown handled for arrays; Arrays of arrays and Unknown single are unsupported (and I think impossible); throws exception, along with default.", "author": "Christopher-Chianelli", "createdAt": "2021-01-05T20:32:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MzUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NDMyMA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545764320", "bodyText": "All switch statements must have a default that fails fast. For example:\n          switch (type) {\n               case EQUAL:\n               ...\n               default:\n                   throw new UnsupportedOperationException(\"Unsupported joiner type (\" + type + \").\");\n           }", "author": "ge0ffrey", "createdAt": "2020-12-18T11:12:17Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoAnnotationWrappers.java", "diffHunk": "@@ -0,0 +1,690 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.IndexView;\n+import org.optaplanner.core.api.domain.autodiscover.AutoDiscoverMemberType;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfiguration;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfigurationProvider;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintWeight;\n+import org.optaplanner.core.api.domain.entity.PinningFilter;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.lookup.LookUpStrategyType;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.ProblemFactProperty;\n+import org.optaplanner.core.api.domain.solution.cloner.SolutionCloner;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableGraphType;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableReference;\n+import org.optaplanner.core.api.domain.variable.VariableListener;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.score.definition.ScoreDefinition;\n+\n+/**\n+ * Contains wrappers for Annotations so they may be\n+ * recorded in bytecode. The annotation's values are stored\n+ * in the wrapper's map.\n+ */\n+public class GizmoAnnotationWrappers {\n+\n+    enum AllOptaPlannerAnnotationEnum {\n+        CONSTRAINT_CONFIGURATION(ConstraintConfiguration.class,\n+                ConstraintConfigurationWrapper::new),\n+        CONSTRAINT_CONFIGURATION_PROVIDER(ConstraintConfigurationProvider.class,\n+                ConstraintConfigurationProviderWrapper::new),\n+        CONSTRAINT_WEIGHT(ConstraintWeight.class, ConstraintWeightWrapper::new),\n+        PLANNING_ENTITY(PlanningEntity.class, PlanningEntityWrapper::new),\n+        PLANNING_PIN(PlanningPin.class, PlanningPinWrapper::new),\n+        PLANNING_ID(PlanningId.class, PlanningIdWrapper::new),\n+        PLANNING_ENTITY_COLLECTION_PROPERTY(PlanningEntityCollectionProperty.class,\n+                PlanningEntityCollectionPropertyWrapper::new),\n+        PLANNING_ENTITY_PROPERTY(PlanningEntityProperty.class,\n+                PlanningEntityPropertyWrapper::new),\n+        PLANNING_SCORE(PlanningScore.class, PlanningScoreWrapper::new),\n+        PLANNING_SOLUTION(PlanningSolution.class, PlanningSolutionWrapper::new),\n+        PROBLEM_FACT_COLLECTION_PROPERTY(ProblemFactCollectionProperty.class,\n+                ProblemFactCollectionPropertyWrapper::new),\n+        PROBLEM_FACT_PROPERTY(ProblemFactProperty.class, ProblemFactPropertyWrapper::new),\n+        VALUE_RANGE_PROVIDER(ValueRangeProvider.class, ValueRangeProviderWrapper::new),\n+        ANCHOR_SHADOW_VARIABLE(AnchorShadowVariable.class, AnchorShadowVariableWrapper::new),\n+        CUSTOM_SHADOW_VARIABLE(CustomShadowVariable.class, CustomShadowVariableWrapper::new),\n+        INVERSE_RELATION_SHADOW_VARIABLE(InverseRelationShadowVariable.class,\n+                InverseRelationShadowVariableWrapper::new),\n+        PLANNING_VARIABLE(PlanningVariable.class, PlanningVariableWrapper::new),\n+        PLANNING_VARIABLE_REFERENCE(PlanningVariableReference.class, PlanningVariableReferenceWrapper::new);\n+\n+        Class<?> annotationClass;\n+        Function<Map<String, Object>, Annotation> mapper;\n+\n+        <T extends Annotation> AllOptaPlannerAnnotationEnum(Class<? extends T> annotationClass,\n+                Function<Map<String, Object>, T> mapper) {\n+            this.annotationClass = annotationClass;\n+            this.mapper = (Function<Map<String, Object>, Annotation>) mapper;\n+        }\n+\n+        public Annotation get(Map<String, Object> values) {\n+            return mapper.apply(values);\n+        }\n+\n+        public static Annotation getForClass(Class<? extends Annotation> annotationClass, Map<String, Object> values) {\n+            for (AllOptaPlannerAnnotationEnum annotationType : AllOptaPlannerAnnotationEnum.values()) {\n+                if (annotationClass.equals(annotationType.annotationClass)) {\n+                    return annotationType.get(values);\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Missing case for \" + annotationClass);\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(Class<? extends Annotation> annotationClass) {\n+            return isOptaPlannerAnnotation(annotationClass.getName());\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(String annotationClass) {\n+            return annotationClass.startsWith(\"org.optaplanner.\");\n+        }\n+    }\n+\n+    public static class AnnotationWrapper implements Supplier<Annotation> {\n+        Class<? extends Annotation> annotationType;\n+        Map<String, Object> annotationValues = new HashMap<String, Object>();\n+        Annotation annotation;\n+\n+        public AnnotationWrapper() {\n+        }\n+\n+        public AnnotationWrapper(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+\n+        public AnnotationWrapper(AnnotationInstance annotationInstance, IndexView indexView) {\n+            try {\n+                annotationType = (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(e);\n+            }\n+            annotationValues = new HashMap<>();\n+            if (AllOptaPlannerAnnotationEnum.isOptaPlannerAnnotation(annotationType)) {\n+                annotationInstance.valuesWithDefaults(indexView).forEach((value) -> {\n+                    switch (value.kind()) {\n+                        case BYTE:\n+                            annotationValues.put(value.name(),\n+                                    value.asByte());\n+                            break;\n+                        case SHORT:\n+                            annotationValues.put(value.name(),\n+                                    value.asShort());\n+                            break;\n+                        case INTEGER:\n+                            annotationValues.put(value.name(),\n+                                    value.asInt());\n+                            break;\n+                        case CHARACTER:\n+                            annotationValues.put(value.name(),\n+                                    value.asChar());\n+                            break;\n+                        case FLOAT:\n+                            annotationValues.put(value.name(),\n+                                    value.asFloat());\n+                            break;\n+                        case DOUBLE:\n+                            annotationValues.put(value.name(),\n+                                    value.asDouble());\n+                            break;\n+                        case LONG:\n+                            annotationValues.put(value.name(),\n+                                    value.asLong());\n+                            break;\n+                        case BOOLEAN:\n+                            annotationValues.put(value.name(),\n+                                    value.asBoolean());\n+                            break;\n+                        case CLASS:\n+                            try {\n+                                annotationValues.put(value.name(),\n+                                        Class.forName(value.asClass().toString()));\n+                            } catch (ClassNotFoundException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                            break;\n+                        case STRING:\n+                            annotationValues.put(value.name(),\n+                                    value.asString());\n+                            break;\n+                        case ENUM:\n+                            annotationValues.put(value.name(),\n+                                    value.asEnum());\n+                            break;\n+                        case ARRAY:\n+                            switch (value.componentKind()) {\n+                                case BYTE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asByteArray());\n+                                    break;\n+                                case SHORT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asShortArray());\n+                                    break;\n+                                case INTEGER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asIntArray());\n+                                    break;\n+                                case CHARACTER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asCharArray());\n+                                    break;\n+                                case FLOAT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asFloatArray());\n+                                    break;\n+                                case DOUBLE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asDoubleArray());\n+                                    break;\n+                                case LONG:\n+                                    annotationValues.put(value.name(),\n+                                            value.asLongArray());\n+                                    break;\n+                                case BOOLEAN:\n+                                    annotationValues.put(value.name(),\n+                                            value.asBooleanArray());\n+                                    break;\n+                                case CLASS:\n+                                    Class[] valueArr = Arrays.stream(value.asClassArray())\n+                                            .map(v -> {\n+                                                try {\n+                                                    return Class.forName(v.toString());\n+                                                } catch (ClassNotFoundException e) {\n+                                                    throw new IllegalStateException(e);\n+                                                }\n+                                            })\n+                                            .collect(Collectors.toList()).toArray(new Class[0]);\n+                                    annotationValues.put(value.name(),\n+                                            valueArr);\n+                                    break;\n+                                case STRING:\n+                                    annotationValues.put(value.name(),\n+                                            value.asStringArray());\n+                                    break;\n+                                case ENUM:\n+                                    annotationValues.put(value.name(),\n+                                            value.asEnumArray());\n+                                    break;\n+                                case ARRAY:\n+                                case NESTED:\n+                                case UNKNOWN:\n+                                    break;\n+                            }\n+                            break;\n+                        case NESTED:\n+                        case UNKNOWN:\n+                            break;", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NDk0Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545764942", "bodyText": "Naming: This cannot be named GizmoMemberAccessor, because it does not implement MemberAccessor (nor should it).\nWhat does it really do?", "author": "ge0ffrey", "createdAt": "2020-12-18T11:13:32Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessor.java", "diffHunk": "@@ -0,0 +1,637 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+public class GizmoMemberAccessor {", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5OTY3NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545899675", "bodyText": "This probably should be called GizmoMemberAccessorGenerator; it generates the code of GizmoMemberAccessors.", "author": "Christopher-Chianelli", "createdAt": "2020-12-18T15:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NDk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4Njk5Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552186996", "bodyText": "Changed to GizmoMemberAccessorImplementor inline with how other Quarkus extensions name their Gizmo generating code", "author": "Christopher-Chianelli", "createdAt": "2021-01-05T20:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NDk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NTQxNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545765415", "bodyText": "the acess type last", "author": "ge0ffrey", "createdAt": "2020-12-18T11:14:32Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/constraintweight/descriptor/ConstraintConfigurationDescriptor.java", "diffHunk": "@@ -78,7 +79,8 @@ public String getConstraintPackage() {\n     // Lifecycle methods\n     // ************************************************************************\n \n-    public void processAnnotations(DescriptorPolicy descriptorPolicy, ScoreDefinition scoreDefinition) {\n+    public void processAnnotations(DomainAccessType domainAccessType, DescriptorPolicy descriptorPolicy,\n+            ScoreDefinition scoreDefinition) {", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk2MDA0NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551960044", "bodyText": "DomainAccessType is merged into DescriptorPolicy per discussion", "author": "Christopher-Chianelli", "createdAt": "2021-01-05T14:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NTQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NjA4NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545766085", "bodyText": "Instead of passing the access type everywhere can't we just make it part of DescriptorPolicy?\nThe Policy objects are exactly created for this purpose: a bunch of general information that is passed to all the build/create/policy methods.", "author": "ge0ffrey", "createdAt": "2020-12-18T11:15:54Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/entity/descriptor/EntityDescriptor.java", "diffHunk": "@@ -205,16 +206,18 @@ private void processDifficulty(DescriptorPolicy descriptorPolicy, PlanningEntity\n         }\n     }\n \n-    private void processValueRangeProviderAnnotation(DescriptorPolicy descriptorPolicy, Member member) {\n+    private void processValueRangeProviderAnnotation(DomainAccessType domainAccessType, DescriptorPolicy descriptorPolicy,\n+            Member member) {\n         if (((AnnotatedElement) member).isAnnotationPresent(ValueRangeProvider.class)) {\n-            MemberAccessor memberAccessor = MemberAccessorFactory.buildMemberAccessor(\n+            MemberAccessor memberAccessor = MemberAccessorFactory.buildMemberAccessor(domainAccessType,\n                     member, FIELD_OR_READ_METHOD, ValueRangeProvider.class);\n             descriptorPolicy.addFromEntityValueRangeProvider(\n                     memberAccessor);\n         }\n     }\n \n-    private void processPlanningVariableAnnotation(DescriptorPolicy descriptorPolicy, Member member) {\n+    private void processPlanningVariableAnnotation(DomainAccessType domainAccessType, DescriptorPolicy descriptorPolicy,\n+            Member member) {", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NzA5Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545767097", "bodyText": "IMPORTANT\nSwitching method references to anonymous methods that call it can cause performance regression if used within ConstrainStreams, because Foo::getBar == Foo::getBar returns true but foo -> foo.getBar() == foo -> foo.getBar() returns false and this impacts node sharing.", "author": "ge0ffrey", "createdAt": "2020-12-18T11:18:02Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/lookup/ClassAndPlanningIdComparator.java", "diffHunk": "@@ -51,9 +58,9 @@ public int compare(Object a, Object b) {\n             return aClass.getName().compareTo(bClass.getName());\n         }\n         MemberAccessor aMemberAccessor = decisionCache.computeIfAbsent(aClass,\n-                ConfigUtils::findPlanningIdMemberAccessor);\n+                clazz -> ConfigUtils.findPlanningIdMemberAccessor(domainAccessType, clazz));\n         MemberAccessor bMemberAccessor = decisionCache.computeIfAbsent(bClass,\n-                ConfigUtils::findPlanningIdMemberAccessor);\n+                clazz -> ConfigUtils.findPlanningIdMemberAccessor(domainAccessType, clazz));", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkwMjA2Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545902066", "bodyText": "Method References are not stable\nhttps://stackoverflow.com/a/50748788\nIt doesn't forbid reuse of the same lambda, but the spec doesn't guarantee that.", "author": "Christopher-Chianelli", "createdAt": "2020-12-18T15:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NzA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkwNjg3Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545906876", "bodyText": "More details on when exactly it will be shared/unshared in the Oracle JVM (different JVM may differ: https://stackoverflow.com/a/23991339)", "author": "Christopher-Chianelli", "createdAt": "2020-12-18T15:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NzA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MDY5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545770690", "bodyText": "nitpick: we usually call this field \"pinned\" in the examples, instead of \"isPinned\".\nGreat that this is being tested!", "author": "ge0ffrey", "createdAt": "2020-12-18T11:25:44Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/gizmo/GizmoTestdataEntity.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.optaplanner.core.impl.testdata.domain.gizmo;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.impl.testdata.domain.TestdataValue;\n+\n+@PlanningEntity\n+public class GizmoTestdataEntity {\n+\n+    private String id;\n+\n+    @PlanningVariable\n+    public TestdataValue value;\n+\n+    @PlanningPin\n+    public boolean isPinned;", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MTUyNg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545771526", "bodyText": "-1 Let's not commit this.\nA great way to avoid these uninteded \"tmp local changes\" is to make a change list in IntelliJ and put that file in that changelist. (I call that change list \"dnc\" which stands for \"Do Not Commit\").", "author": "ge0ffrey", "createdAt": "2020-12-18T11:27:34Z", "path": "optaplanner-examples/src/main/resources/org/optaplanner/examples/tsp/solver/tspSolverConfig.xml", "diffHunk": "@@ -10,8 +10,8 @@\n   <scoreDirectorFactory>\n     <!--<easyScoreCalculatorClass>org.optaplanner.examples.tsp.optional.score.TspEasyScoreCalculator</easyScoreCalculatorClass>-->\n     <!--<constraintProviderClass>org.optaplanner.examples.tsp.optional.score.TspConstraintProvider</constraintProviderClass>-->\n-    <!--<incrementalScoreCalculatorClass>org.optaplanner.examples.tsp.optional.score.TspIncrementalScoreCalculator</incrementalScoreCalculatorClass>-->\n-    <scoreDrl>org/optaplanner/examples/tsp/solver/tspConstraints.drl</scoreDrl>\n+    <incrementalScoreCalculatorClass>org.optaplanner.examples.tsp.optional.score.TspIncrementalScoreCalculator</incrementalScoreCalculatorClass>\n+    <!-- <scoreDrl>org/optaplanner/examples/tsp/solver/tspConstraints.drl</scoreDrl> -->", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MzQ3NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545773475", "bodyText": "Order: PLANNING_VARIABLE before any the shadow vars types.\nTypical order is something like this: solution related stuff, entity related stuff, genuine planning variable related stuff (IIRC including value range providers), shadow vars related.\nBAsically, when the annotations are parsed by the Descriptors, their order is the order in which they get parsed, mostly.\nMotivation for why order matter: if code always handles a set of aspects in the same order, it is much, much clearer to notice while reading when something is missing, or something is unused. It's also easier to determine in which order they get filled in (important to avoid chicken-and-egg situations if they depend on each other) and sometimes even avoids a deadlock.", "author": "ge0ffrey", "createdAt": "2020-12-18T11:31:46Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/DotNames.java", "diffHunk": "@@ -27,11 +42,48 @@\n \n     static final DotName PLANNING_SOLUTION = DotName.createSimple(PlanningSolution.class.getName());\n     static final DotName PLANNING_ENTITY = DotName.createSimple(PlanningEntity.class.getName());\n+\n+    static final DotName CONSTRAINT_CONFIGURATION_PROVIDER =\n+            DotName.createSimple(ConstraintConfigurationProvider.class.getName());\n+    static final DotName CONSTRAINT_WEIGHT = DotName.createSimple(ConstraintWeight.class.getName());\n+    static final DotName PLANNING_PIN = DotName.createSimple(PlanningPin.class.getName());\n+    static final DotName PLANNING_ID = DotName.createSimple(PlanningId.class.getName());\n+    static final DotName PLANNING_ENTITY_COLLECTION_PROPERTY =\n+            DotName.createSimple(PlanningEntityCollectionProperty.class.getName());\n+    static final DotName PLANNING_ENTITY_PROPERTY = DotName.createSimple(PlanningEntityProperty.class.getName());\n+    static final DotName PLANNING_SCORE = DotName.createSimple(PlanningScore.class.getName());\n+    static final DotName PROBLEM_FACT_COLLECTION_PROPERTY = DotName.createSimple(ProblemFactCollectionProperty.class.getName());\n+    static final DotName PROBLEM_FACT_PROPERTY = DotName.createSimple(ProblemFactProperty.class.getName());\n+    static final DotName VALUE_RANGE_PROVIDER = DotName.createSimple(ValueRangeProvider.class.getName());\n+    static final DotName ANCHOR_SHADOW_VARIABLE = DotName.createSimple(AnchorShadowVariable.class.getName());\n+    static final DotName CUSTOM_SHADOW_VARIABLE = DotName.createSimple(CustomShadowVariable.class.getName());\n+    static final DotName INVERSE_RELATION_SHADOW_VARIABLE = DotName.createSimple(InverseRelationShadowVariable.class.getName());\n+    static final DotName PLANNING_VARIABLE = DotName.createSimple(PlanningVariable.class.getName());\n+    static final DotName PLANNING_VARIABLE_REFERENCE = DotName.createSimple(PlanningVariableReference.class.getName());", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3NDUwMw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545774503", "bodyText": "In other quarkus extensions, written by the masters (so hibernate, resteasy etc), do they also call this kind of class typically a Creator? (I don't know)", "author": "ge0ffrey", "createdAt": "2020-12-18T11:34:01Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorCreator.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorCreator {", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQzNjIxNA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551436214", "bodyText": "I noticed that often call the classes generating byte code via Gizmo \"Implementor\", e.g. https://github.com/quarkusio/quarkus/blob/master/extensions/panache/rest-data-panache/deployment/src/main/java/io/quarkus/rest/data/panache/deployment/JaxRsResourceImplementor.java", "author": "rsynek", "createdAt": "2021-01-04T16:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3NDUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk2MTk0Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551961947", "bodyText": "Can confirm Implementor seems to be the most common name by a long shot (did a search of Creator which shows all code that use Gizmo to generate code (Gizmo uses Creator). The other contender (with less use) is Generator", "author": "Christopher-Chianelli", "createdAt": "2021-01-05T14:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3NDUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3NTYyMg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545775622", "bodyText": "When chaining an exception, always add a message and then the cause. The message should indicate, at the very least, what action is failing. So here that owuld be something like \"Unable to define assessor for member (\"+ member + \").\", e). That mentioning of the member's value is very handy when this occurs in a production log.", "author": "ge0ffrey", "createdAt": "2020-12-18T11:36:20Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorCreator.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorCreator {\n+\n+    private static Set<FieldInfo> visitedFields = new HashSet<>();\n+    private static Set<MethodInfo> visitedMethods = new HashSet<>();\n+\n+    public static void addVirtualFieldGetter(ClassInfo classInfo, FieldInfo fieldInfo,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedFields.contains(fieldInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerFieldEnhancingClassVisitor(classInfo, classVisitor,\n+                            fieldInfo)));\n+            visitedFields.add(fieldInfo);\n+        }\n+    }\n+\n+    public static Optional<MethodDescriptor> addVirtualMethodGetter(ClassInfo classInfo, MethodInfo methodInfo, String name,\n+            Optional<MethodDescriptor> setterDescriptor,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedMethods.contains(methodInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerMethodEnhancingClassVisitor(classInfo, classVisitor, methodInfo,\n+                            name, setterDescriptor)));\n+            visitedMethods.add(methodInfo);\n+        }\n+        return setterDescriptor.map(md -> MethodDescriptor\n+                .ofMethod(classInfo.name().toString(), getVirtualSetterName(name),\n+                        md.getReturnType(), md.getParameterTypes()));\n+    }\n+\n+    public static String getVirtualGetterName(String name) {\n+        return \"$get$optaplanner$__\" + name;\n+    }\n+\n+    public static String getVirtualSetterName(String name) {\n+        return \"$set$optaplanner$__\" + name;\n+    }\n+\n+    public static void generateFieldAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            FieldInfo fieldInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + fieldInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessor.MemberDescriptor member;\n+        if (Modifier.isPublic(fieldInfo.flags())) {\n+            member = new GizmoMemberAccessor.MemberDescriptor(fieldInfo, indexView);\n+        } else {\n+            addVirtualFieldGetter(classInfo, fieldInfo, transformers);\n+            String methodName = getVirtualGetterName(fieldInfo.name());\n+            MethodDescriptor setterDescriptor = MethodDescriptor.ofMethod(fieldInfo.declaringClass().name().toString(),\n+                    getVirtualSetterName(fieldInfo.name()),\n+                    \"void\",\n+                    fieldInfo.type().name().toString());\n+            MethodInfo methodInfo = MethodInfo.create(classInfo, methodName, new org.jboss.jandex.Type[] {}, fieldInfo.type(),\n+                    (short) Modifier.PUBLIC);\n+            member = new GizmoMemberAccessor.MemberDescriptor(fieldInfo, methodInfo, Optional.of(setterDescriptor), indexView,\n+                    fieldInfo.name());\n+        }\n+        try {\n+            GizmoMemberAccessor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));\n+            classCreator.close();\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e);", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3NzQzOA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545777438", "bodyText": "Soft suggestion nitpick: active tense + more concrete by calling out a specific annotation\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Needed so Annotation information in the index\n          \n          \n            \n                    // Add @PlanningEntity and other annotations in the Jandex index for Gizmo", "author": "ge0ffrey", "createdAt": "2020-12-18T11:40:14Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -84,14 +101,22 @@ HotDeploymentWatchedFileBuildItem watchConstraintsDrl() {\n         return new HotDeploymentWatchedFileBuildItem(constraintsDrl);\n     }\n \n+    @BuildStep\n+    IndexDependencyBuildItem indexDependencyBuildItem() {\n+        // Needed so Annotation information in the index", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3Nzk0OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545777948", "bodyText": "important\nNo System.out's or printStackTraces() in committed code", "author": "ge0ffrey", "createdAt": "2020-12-18T11:41:25Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -343,4 +386,60 @@ private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n         }\n     }\n \n+    private OptaPlannerGizmoInfo generateDomainAccessors(IndexView indexView,\n+            BuildProducer<GeneratedClassBuildItem> generatedClasses,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        Collection<AnnotationInstance> membersToGeneratedAccessorsFor = new ArrayList<>();\n+        ClassOutput classOutput = new GeneratedClassGizmoAdaptor(generatedClasses, true);\n+        ClassOutput debuggableClassOutput = (className, bytes) -> {\n+            final String DEBUG_CLASSES_DIR = \"target/optaplanner-generated-classes\";\n+            if (DEBUG_CLASSES_DIR != null) {\n+                Path pathToFile = Paths.get(DEBUG_CLASSES_DIR, className.replace('.', '/') + \".class\");\n+                try {\n+                    Files.createDirectories(pathToFile.getParent());\n+                    Files.write(pathToFile, bytes);\n+                } catch (IOException e) {\n+                    System.out.println(\"Failed writing debug class: \" + pathToFile);\n+                    e.printStackTrace();", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3ODI5OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545778298", "bodyText": "error messages: put values between braces, so it's clear what is static text and dynamic text. (important if their planning variable is a field called variable.)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                throw new IllegalStateException(annotatedMember + \" is not on a field or method.\");\n          \n          \n            \n                                throw new IllegalStateException(\"The member (\" + annotatedMember + \") is not on a field or method.\");", "author": "ge0ffrey", "createdAt": "2020-12-18T11:42:09Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -343,4 +386,60 @@ private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n         }\n     }\n \n+    private OptaPlannerGizmoInfo generateDomainAccessors(IndexView indexView,\n+            BuildProducer<GeneratedClassBuildItem> generatedClasses,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        Collection<AnnotationInstance> membersToGeneratedAccessorsFor = new ArrayList<>();\n+        ClassOutput classOutput = new GeneratedClassGizmoAdaptor(generatedClasses, true);\n+        ClassOutput debuggableClassOutput = (className, bytes) -> {\n+            final String DEBUG_CLASSES_DIR = \"target/optaplanner-generated-classes\";\n+            if (DEBUG_CLASSES_DIR != null) {\n+                Path pathToFile = Paths.get(DEBUG_CLASSES_DIR, className.replace('.', '/') + \".class\");\n+                try {\n+                    Files.createDirectories(pathToFile.getParent());\n+                    Files.write(pathToFile, bytes);\n+                } catch (IOException e) {\n+                    System.out.println(\"Failed writing debug class: \" + pathToFile);\n+                    e.printStackTrace();\n+                }\n+            }\n+            classOutput.write(className, bytes);\n+        };\n+\n+        Map<String, java.lang.reflect.Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+        Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+        GizmoMemberAccessor.setGizmoClassLoader(Thread.currentThread().getContextClassLoader(),\n+                gizmoMemberAccessorNameToGenericType,\n+                gizmoMemberAccessorNameToAnnotatedElement);\n+        for (DotName dotName : DotNames.GIZMO_MEMBER_ACCESSOR_ANNOTATIONS) {\n+            membersToGeneratedAccessorsFor.addAll(indexView.getAnnotations(dotName));\n+        }\n+        for (AnnotationInstance annotatedMember : membersToGeneratedAccessorsFor) {\n+            switch (annotatedMember.target().kind()) {\n+                case FIELD: {\n+                    FieldInfo fieldInfo = annotatedMember.target().asField();\n+                    ClassInfo classInfo = fieldInfo.declaringClass();\n+                    GizmoMemberAccessorCreator.generateFieldAccessor(annotatedMember, indexView, debuggableClassOutput,\n+                            classInfo,\n+                            fieldInfo, transformers);\n+                    break;\n+                }\n+                case METHOD: {\n+                    MethodInfo methodInfo = annotatedMember.target().asMethod();\n+                    ClassInfo classInfo = methodInfo.declaringClass();\n+                    GizmoMemberAccessorCreator.generateMethodAccessor(annotatedMember, indexView, debuggableClassOutput,\n+                            classInfo,\n+                            methodInfo, transformers);\n+                    break;\n+                }\n+                default: {\n+                    throw new IllegalStateException(annotatedMember + \" is not on a field or method.\");", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3OTMyMg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545779322", "bodyText": "We typically call such things dummy, so DummyConstraintProvider.\nWe might have one like that around already.", "author": "ge0ffrey", "createdAt": "2020-12-18T11:44:17Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/test/java/org/optaplanner/quarkus/testdata/gizmo/KitchenSinkConstraintProvider.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package org.optaplanner.quarkus.testdata.gizmo;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+\n+public class KitchenSinkConstraintProvider implements ConstraintProvider {", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3OTk5Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545779997", "bodyText": "Naming, the other TestData objects start with TestData.", "author": "ge0ffrey", "createdAt": "2020-12-18T11:45:38Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/test/java/org/optaplanner/quarkus/testdata/gizmo/KitchenSinkTestDataEntity.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.optaplanner.quarkus.testdata.gizmo;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+// Should have one of every annotation, even annotations that\n+// don't make sense on an entity, to make sure everything works\n+// a-ok\n+@PlanningEntity\n+public class KitchenSinkTestDataEntity {", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyNTMwMw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r545925303", "bodyText": "Do we have an integration-chapter.adoc entry?", "author": "ge0ffrey", "createdAt": "2020-12-18T15:54:23Z", "path": "optaplanner-spring-integration/optaplanner-spring-boot-autoconfigure/src/main/java/org/optaplanner/spring/boot/autoconfigure/SolverProperties.java", "diffHunk": "@@ -26,6 +27,15 @@\n      * Defaults to \"REPRODUCIBLE\".\n      */\n     private EnvironmentMode environmentMode;\n+\n+    /**\n+     * Determines how Domain Accessors are created. Defaults\n+     * to \"REFLECTION\". To use \"GIZMO\", io.quarkus.gizmo:gizmo\n+     * MUST be in your classpath, and all OptaPlanner annotations\n+     * must be on public members.\n+     */\n+    private DomainAccessType domainAccessType;", "originalCommit": "c573c771e287b1037058b488a0bb9a5d8ab94944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTg5Mjk0MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r555892941", "bodyText": "New section after \"4.2.3. Annotation alternatives\"", "author": "ge0ffrey", "createdAt": "2021-01-12T16:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyNTMwMw=="}], "type": "inlineReview"}, {"oid": "3a0f8e164b37aaa113730699b808e0c8880aa008", "url": "https://github.com/kiegroup/optaplanner/commit/3a0f8e164b37aaa113730699b808e0c8880aa008", "message": "Rebase fixup", "committedDate": "2020-12-18T21:15:11Z", "type": "forcePushed"}, {"oid": "e2f25955a542798ad5d37431c08229eec85d7b06", "url": "https://github.com/kiegroup/optaplanner/commit/e2f25955a542798ad5d37431c08229eec85d7b06", "message": "Put DomainAccessType in DescriptorPolicy\n\n- Also use correct Gizmo + Jandex versions", "committedDate": "2021-01-04T16:55:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI5ODczOA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551298738", "bodyText": "If the comment stays, I suggest turning it into a multi-line comment and finish the sentence with '.'", "author": "rsynek", "createdAt": "2021-01-04T12:50:38Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/test/java/org/optaplanner/quarkus/testdata/gizmo/KitchenSinkTestDataEntity.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.optaplanner.quarkus.testdata.gizmo;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+// Should have one of every annotation, even annotations that\n+// don't make sense on an entity, to make sure everything works\n+// a-ok", "originalCommit": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM3Njc0NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551376744", "bodyText": "Why do we define the (empty) maps here, to only have them filled later by the GizmoMemberAccessorCreator.generateFieldAccessor and GizmoMemberAccessorCreator.generateMethodAccessor ?", "author": "rsynek", "createdAt": "2021-01-04T15:14:41Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -343,4 +386,60 @@ private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n         }\n     }\n \n+    private OptaPlannerGizmoInfo generateDomainAccessors(IndexView indexView,\n+            BuildProducer<GeneratedClassBuildItem> generatedClasses,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        Collection<AnnotationInstance> membersToGeneratedAccessorsFor = new ArrayList<>();\n+        ClassOutput classOutput = new GeneratedClassGizmoAdaptor(generatedClasses, true);\n+        ClassOutput debuggableClassOutput = (className, bytes) -> {\n+            final String DEBUG_CLASSES_DIR = \"target/optaplanner-generated-classes\";\n+            if (DEBUG_CLASSES_DIR != null) {\n+                Path pathToFile = Paths.get(DEBUG_CLASSES_DIR, className.replace('.', '/') + \".class\");\n+                try {\n+                    Files.createDirectories(pathToFile.getParent());\n+                    Files.write(pathToFile, bytes);\n+                } catch (IOException e) {\n+                    System.out.println(\"Failed writing debug class: \" + pathToFile);\n+                    e.printStackTrace();\n+                }\n+            }\n+            classOutput.write(className, bytes);\n+        };\n+\n+        Map<String, java.lang.reflect.Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+        Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();", "originalCommit": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ4NTA2MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551485060", "bodyText": "They are passed to\nGizmoMemberAccessor.setGizmoClassLoader(Thread.currentThread().getContextClassLoader(),\n                gizmoMemberAccessorNameToGenericType,\n                gizmoMemberAccessorNameToAnnotatedElement);\n\n\nwhich tells the Gizmo code generator to use those maps to store/read generic type/annotated element data. We also need to pass those maps to OptaPlannerGizmoInfo, which is used by OptaPlannerBeanProvider to set up the class loader and generic type/annotated element maps.", "author": "Christopher-Chianelli", "createdAt": "2021-01-04T18:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM3Njc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM3NzI5NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551377294", "bodyText": "Formatting - unnecessary line.", "author": "rsynek", "createdAt": "2021-01-04T15:15:33Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -343,4 +386,60 @@ private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n         }\n     }\n \n+    private OptaPlannerGizmoInfo generateDomainAccessors(IndexView indexView,\n+            BuildProducer<GeneratedClassBuildItem> generatedClasses,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        Collection<AnnotationInstance> membersToGeneratedAccessorsFor = new ArrayList<>();\n+        ClassOutput classOutput = new GeneratedClassGizmoAdaptor(generatedClasses, true);\n+        ClassOutput debuggableClassOutput = (className, bytes) -> {\n+            final String DEBUG_CLASSES_DIR = \"target/optaplanner-generated-classes\";\n+            if (DEBUG_CLASSES_DIR != null) {\n+                Path pathToFile = Paths.get(DEBUG_CLASSES_DIR, className.replace('.', '/') + \".class\");\n+                try {\n+                    Files.createDirectories(pathToFile.getParent());\n+                    Files.write(pathToFile, bytes);\n+                } catch (IOException e) {\n+                    System.out.println(\"Failed writing debug class: \" + pathToFile);\n+                    e.printStackTrace();\n+                }\n+            }\n+            classOutput.write(className, bytes);\n+        };\n+\n+        Map<String, java.lang.reflect.Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+        Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+        GizmoMemberAccessor.setGizmoClassLoader(Thread.currentThread().getContextClassLoader(),\n+                gizmoMemberAccessorNameToGenericType,\n+                gizmoMemberAccessorNameToAnnotatedElement);\n+        for (DotName dotName : DotNames.GIZMO_MEMBER_ACCESSOR_ANNOTATIONS) {\n+            membersToGeneratedAccessorsFor.addAll(indexView.getAnnotations(dotName));\n+        }\n+        for (AnnotationInstance annotatedMember : membersToGeneratedAccessorsFor) {\n+            switch (annotatedMember.target().kind()) {\n+                case FIELD: {\n+                    FieldInfo fieldInfo = annotatedMember.target().asField();\n+                    ClassInfo classInfo = fieldInfo.declaringClass();\n+                    GizmoMemberAccessorCreator.generateFieldAccessor(annotatedMember, indexView, debuggableClassOutput,\n+                            classInfo,\n+                            fieldInfo, transformers);", "originalCommit": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM3NzM3MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551377371", "bodyText": "Formatting - unnecessary line.", "author": "rsynek", "createdAt": "2021-01-04T15:15:40Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -343,4 +386,60 @@ private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n         }\n     }\n \n+    private OptaPlannerGizmoInfo generateDomainAccessors(IndexView indexView,\n+            BuildProducer<GeneratedClassBuildItem> generatedClasses,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        Collection<AnnotationInstance> membersToGeneratedAccessorsFor = new ArrayList<>();\n+        ClassOutput classOutput = new GeneratedClassGizmoAdaptor(generatedClasses, true);\n+        ClassOutput debuggableClassOutput = (className, bytes) -> {\n+            final String DEBUG_CLASSES_DIR = \"target/optaplanner-generated-classes\";\n+            if (DEBUG_CLASSES_DIR != null) {\n+                Path pathToFile = Paths.get(DEBUG_CLASSES_DIR, className.replace('.', '/') + \".class\");\n+                try {\n+                    Files.createDirectories(pathToFile.getParent());\n+                    Files.write(pathToFile, bytes);\n+                } catch (IOException e) {\n+                    System.out.println(\"Failed writing debug class: \" + pathToFile);\n+                    e.printStackTrace();\n+                }\n+            }\n+            classOutput.write(className, bytes);\n+        };\n+\n+        Map<String, java.lang.reflect.Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+        Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+        GizmoMemberAccessor.setGizmoClassLoader(Thread.currentThread().getContextClassLoader(),\n+                gizmoMemberAccessorNameToGenericType,\n+                gizmoMemberAccessorNameToAnnotatedElement);\n+        for (DotName dotName : DotNames.GIZMO_MEMBER_ACCESSOR_ANNOTATIONS) {\n+            membersToGeneratedAccessorsFor.addAll(indexView.getAnnotations(dotName));\n+        }\n+        for (AnnotationInstance annotatedMember : membersToGeneratedAccessorsFor) {\n+            switch (annotatedMember.target().kind()) {\n+                case FIELD: {\n+                    FieldInfo fieldInfo = annotatedMember.target().asField();\n+                    ClassInfo classInfo = fieldInfo.declaringClass();\n+                    GizmoMemberAccessorCreator.generateFieldAccessor(annotatedMember, indexView, debuggableClassOutput,\n+                            classInfo,\n+                            fieldInfo, transformers);\n+                    break;\n+                }\n+                case METHOD: {\n+                    MethodInfo methodInfo = annotatedMember.target().asMethod();\n+                    ClassInfo classInfo = methodInfo.declaringClass();\n+                    GizmoMemberAccessorCreator.generateMethodAccessor(annotatedMember, indexView, debuggableClassOutput,\n+                            classInfo,\n+                            methodInfo, transformers);", "originalCommit": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM3ODAwNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551378007", "bodyText": "In my opinion too much detail for this method, which is growing bigger and bigger.", "author": "rsynek", "createdAt": "2021-01-04T15:16:39Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -131,6 +156,14 @@ void recordAndRegisterBeans(OptaPlannerRecorder recorder, RecorderContext record\n                                     || dotName.toString().startsWith(\"org.optaplanner\"))\n                     .build());\n         }\n+\n+        OptaPlannerGizmoInfo gizmoInfo;\n+        if (solverConfig.getDomainAccessType() == DomainAccessType.GIZMO) {\n+            gizmoInfo = generateDomainAccessors(indexView, generatedClasses, transformers);\n+        } else {\n+            gizmoInfo = new OptaPlannerGizmoInfo(Collections.emptyMap(), Collections.emptyMap());\n+        }", "originalCommit": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ4ODI5Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551488293", "bodyText": "I can probably move it to its own method, but it leads to the issue where the recorder is recorded in two seperate methods\n(note it defined here as OptaPlannerGizmoInfo is used by the recorder, which in turn used by the OptaPlannerBeanProvider)\n        syntheticBeanBuildItemBuildProducer.produce(SyntheticBeanBuildItem.configure(SolverConfig.class)\n                .scope(Singleton.class)\n                .defaultBean()\n                .supplier(recorder.solverConfigSupplier(solverConfig)).done());\n\n        syntheticBeanBuildItemBuildProducer.produce(SyntheticBeanBuildItem.configure(SolverManagerConfig.class)\n                .scope(Singleton.class)\n                .defaultBean()\n                .supplier(recorder.solverManagerConfig(solverManagerConfig)).done());\n\n        syntheticBeanBuildItemBuildProducer.produce(SyntheticBeanBuildItem.configure(OptaPlannerGizmoInfo.class)\n                .scope(Singleton.class)\n                .defaultBean()\n                .supplier(recorder.optaPlannerGizmoInfoSupplier(gizmoInfo)).done());", "author": "Christopher-Chianelli", "createdAt": "2021-01-04T18:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM3ODAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxNjAyMg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r553216022", "bodyText": "In my opinion it's fine if the instance is recorded here, but the method should care only about recording instances and delegate details of creating them to other methods.", "author": "rsynek", "createdAt": "2021-01-07T09:42:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM3ODAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0MzY1OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551443659", "bodyText": "This line repeats for the boolean getter too. Maybe a method that just figures out the setter's name would do it (and make the code more testable).", "author": "rsynek", "createdAt": "2021-01-04T17:00:55Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorCreator.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorCreator {\n+\n+    private static Set<FieldInfo> visitedFields = new HashSet<>();\n+    private static Set<MethodInfo> visitedMethods = new HashSet<>();\n+\n+    public static void addVirtualFieldGetter(ClassInfo classInfo, FieldInfo fieldInfo,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedFields.contains(fieldInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerFieldEnhancingClassVisitor(classInfo, classVisitor,\n+                            fieldInfo)));\n+            visitedFields.add(fieldInfo);\n+        }\n+    }\n+\n+    public static Optional<MethodDescriptor> addVirtualMethodGetter(ClassInfo classInfo, MethodInfo methodInfo, String name,\n+            Optional<MethodDescriptor> setterDescriptor,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedMethods.contains(methodInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerMethodEnhancingClassVisitor(classInfo, classVisitor, methodInfo,\n+                            name, setterDescriptor)));\n+            visitedMethods.add(methodInfo);\n+        }\n+        return setterDescriptor.map(md -> MethodDescriptor\n+                .ofMethod(classInfo.name().toString(), getVirtualSetterName(name),\n+                        md.getReturnType(), md.getParameterTypes()));\n+    }\n+\n+    public static String getVirtualGetterName(String name) {\n+        return \"$get$optaplanner$__\" + name;\n+    }\n+\n+    public static String getVirtualSetterName(String name) {\n+        return \"$set$optaplanner$__\" + name;\n+    }\n+\n+    public static void generateFieldAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            FieldInfo fieldInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + fieldInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessor.MemberDescriptor member;\n+        if (Modifier.isPublic(fieldInfo.flags())) {\n+            member = new GizmoMemberAccessor.MemberDescriptor(fieldInfo, indexView);\n+        } else {\n+            addVirtualFieldGetter(classInfo, fieldInfo, transformers);\n+            String methodName = getVirtualGetterName(fieldInfo.name());\n+            MethodDescriptor setterDescriptor = MethodDescriptor.ofMethod(fieldInfo.declaringClass().name().toString(),\n+                    getVirtualSetterName(fieldInfo.name()),\n+                    \"void\",\n+                    fieldInfo.type().name().toString());\n+            MethodInfo methodInfo = MethodInfo.create(classInfo, methodName, new org.jboss.jandex.Type[] {}, fieldInfo.type(),\n+                    (short) Modifier.PUBLIC);\n+            member = new GizmoMemberAccessor.MemberDescriptor(fieldInfo, methodInfo, Optional.of(setterDescriptor), indexView,\n+                    fieldInfo.name());\n+        }\n+        try {\n+            GizmoMemberAccessor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));\n+            classCreator.close();\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    public static void generateMethodAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            MethodInfo methodInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + methodInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessor.MemberDescriptor member;\n+        String name;\n+        MethodInfo setterMethod;\n+\n+        if (methodInfo.name().startsWith(\"get\")) {\n+            name = methodInfo.name().substring(3, 4).toLowerCase(Locale.ROOT) + methodInfo.name().substring(4);\n+            setterMethod = classInfo.method(\"set\" + name.substring(0, 1).toUpperCase(Locale.ROOT) + name.substring(1),", "originalCommit": "4dce320f9cba9f4ab56e8a474ed0e256311aaf6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE3ODY0NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552178645", "bodyText": "Done (Refactored to two methods (one for name, one for setter)", "author": "Christopher-Chianelli", "createdAt": "2021-01-05T20:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0MzY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0ODk5Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551448993", "bodyText": "Why is it necessary to use directly ASM?", "author": "rsynek", "createdAt": "2021-01-04T17:10:05Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorCreator.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorCreator {\n+\n+    private static Set<FieldInfo> visitedFields = new HashSet<>();\n+    private static Set<MethodInfo> visitedMethods = new HashSet<>();\n+\n+    public static void addVirtualFieldGetter(ClassInfo classInfo, FieldInfo fieldInfo,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedFields.contains(fieldInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerFieldEnhancingClassVisitor(classInfo, classVisitor,\n+                            fieldInfo)));\n+            visitedFields.add(fieldInfo);\n+        }\n+    }\n+\n+    public static Optional<MethodDescriptor> addVirtualMethodGetter(ClassInfo classInfo, MethodInfo methodInfo, String name,\n+            Optional<MethodDescriptor> setterDescriptor,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedMethods.contains(methodInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerMethodEnhancingClassVisitor(classInfo, classVisitor, methodInfo,\n+                            name, setterDescriptor)));\n+            visitedMethods.add(methodInfo);\n+        }\n+        return setterDescriptor.map(md -> MethodDescriptor\n+                .ofMethod(classInfo.name().toString(), getVirtualSetterName(name),\n+                        md.getReturnType(), md.getParameterTypes()));\n+    }\n+\n+    public static String getVirtualGetterName(String name) {\n+        return \"$get$optaplanner$__\" + name;\n+    }\n+\n+    public static String getVirtualSetterName(String name) {\n+        return \"$set$optaplanner$__\" + name;\n+    }\n+\n+    public static void generateFieldAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            FieldInfo fieldInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + fieldInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessor.MemberDescriptor member;\n+        if (Modifier.isPublic(fieldInfo.flags())) {\n+            member = new GizmoMemberAccessor.MemberDescriptor(fieldInfo, indexView);\n+        } else {\n+            addVirtualFieldGetter(classInfo, fieldInfo, transformers);\n+            String methodName = getVirtualGetterName(fieldInfo.name());\n+            MethodDescriptor setterDescriptor = MethodDescriptor.ofMethod(fieldInfo.declaringClass().name().toString(),\n+                    getVirtualSetterName(fieldInfo.name()),\n+                    \"void\",\n+                    fieldInfo.type().name().toString());\n+            MethodInfo methodInfo = MethodInfo.create(classInfo, methodName, new org.jboss.jandex.Type[] {}, fieldInfo.type(),\n+                    (short) Modifier.PUBLIC);\n+            member = new GizmoMemberAccessor.MemberDescriptor(fieldInfo, methodInfo, Optional.of(setterDescriptor), indexView,\n+                    fieldInfo.name());\n+        }\n+        try {\n+            GizmoMemberAccessor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));\n+            classCreator.close();\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    public static void generateMethodAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            MethodInfo methodInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + methodInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessor.MemberDescriptor member;\n+        String name;\n+        MethodInfo setterMethod;\n+\n+        if (methodInfo.name().startsWith(\"get\")) {\n+            name = methodInfo.name().substring(3, 4).toLowerCase(Locale.ROOT) + methodInfo.name().substring(4);\n+            setterMethod = classInfo.method(\"set\" + name.substring(0, 1).toUpperCase(Locale.ROOT) + name.substring(1),\n+                    methodInfo.returnType());\n+        } else if (methodInfo.name().startsWith(\"is\")) {\n+            name = methodInfo.name().substring(2, 3).toLowerCase(Locale.ROOT) + methodInfo.name().substring(3);\n+            setterMethod = classInfo.method(\"set\" + name.substring(0, 1).toUpperCase(Locale.ROOT) + name.substring(1),\n+                    methodInfo.returnType());\n+        } else {\n+            name = methodInfo.name();\n+            setterMethod = null;\n+        }\n+\n+        Optional<MethodDescriptor> setterDescriptor = Optional.ofNullable(setterMethod).map(MethodDescriptor::of);\n+        if (Modifier.isPublic(methodInfo.flags())) {\n+            member = new GizmoMemberAccessor.MemberDescriptor(methodInfo, methodInfo, setterDescriptor, indexView, name);\n+        } else {\n+            setterDescriptor = addVirtualMethodGetter(classInfo, methodInfo, name, setterDescriptor, transformers);\n+            String methodName = getVirtualGetterName(name);\n+            MethodInfo newMethodInfo = classInfo.method(methodName);\n+            member = new GizmoMemberAccessor.MemberDescriptor(methodInfo, newMethodInfo, setterDescriptor, indexView, name);\n+        }\n+        try {\n+            GizmoMemberAccessor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));\n+            classCreator.close();\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private static class OptaPlannerFieldEnhancingClassVisitor extends ClassVisitor {\n+        private final FieldInfo fieldInfo;\n+        private final Class<?> clazz;\n+        private final String fieldTypeDescriptor;\n+\n+        public OptaPlannerFieldEnhancingClassVisitor(ClassInfo classInfo, ClassVisitor outputClassVisitor,\n+                FieldInfo fieldInfo) {\n+            super(Gizmo.ASM_API_VERSION, outputClassVisitor);\n+            this.fieldInfo = fieldInfo;\n+            try {\n+                clazz = Class.forName(classInfo.name().toString(), false, Thread.currentThread().getContextClassLoader());\n+                fieldTypeDescriptor = DescriptorUtils.typeToString(fieldInfo.type());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void visitEnd() {\n+            super.visitEnd();\n+            addGetter(this.cv);\n+            addSetter(this.cv);\n+        }\n+\n+        private void addSetter(ClassVisitor classWriter) {", "originalCommit": "e2f25955a542798ad5d37431c08229eec85d7b06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ4MTIwMg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551481202", "bodyText": "Cannot use Gizmo for argumentation (modifying existing classes, which we do so we have a public getter/setter if their field/method is private)", "author": "Christopher-Chianelli", "createdAt": "2021-01-04T18:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0ODk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk3OTE1MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551979151", "bodyText": "The <optional>true</optional> is necessary for the dependencies, but not he dependencyManagement.", "author": "rsynek", "createdAt": "2021-01-05T14:50:29Z", "path": "build/optaplanner-build-parent/pom.xml", "diffHunk": "@@ -159,6 +161,18 @@\n <!--          </exclusion>-->\n         </exclusions>\n       </dependency>\n+      <dependency>\n+        <groupId>io.quarkus.gizmo</groupId>\n+        <artifactId>gizmo</artifactId>\n+        <version>${version.io.quarkus.gizmo}</version>\n+        <optional>true</optional>", "originalCommit": "e2f25955a542798ad5d37431c08229eec85d7b06", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NDA1MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r551984050", "bodyText": "Please provide a message for this exception (and there are two more below).", "author": "rsynek", "createdAt": "2021-01-05T14:58:02Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoTypeWrappers.java", "diffHunk": "@@ -0,0 +1,387 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.AnnotatedType;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.jandex.PrimitiveType;\n+\n+/**\n+ * Contains wrappers for types so they may be\n+ * recorded in bytecode.\n+ */\n+public class GizmoTypeWrappers {\n+\n+    public static Type getTypeForJandex(IndexView indexView, org.jboss.jandex.Type jandexType) {\n+        if (jandexType == null) {\n+            return null;\n+        }\n+\n+        switch (jandexType.kind()) {\n+            case CLASS:\n+                try {\n+                    return Class.forName(jandexType.asClassType().name().toString(), false,\n+                            Thread.currentThread().getContextClassLoader());\n+                } catch (ClassNotFoundException e) {\n+                    throw new IllegalStateException(e);", "originalCommit": "e2f25955a542798ad5d37431c08229eec85d7b06", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAzMTQyMw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552031423", "bodyText": "The setter is not just setting the classloader, but also the maps - the method should do what it says it does.", "author": "rsynek", "createdAt": "2021-01-05T16:09:48Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessor.java", "diffHunk": "@@ -0,0 +1,637 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+public class GizmoMemberAccessor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,", "originalCommit": "e2f25955a542798ad5d37431c08229eec85d7b06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc3Mjg2Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552772866", "bodyText": "Thinking\nWhat about renaming the method to\nusePregeneratedBytecodeAndMaps\nand changing useClassloader to usePregeneratedBytecodeFromClassLoader?", "author": "Christopher-Chianelli", "createdAt": "2021-01-06T16:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAzMTQyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxMzkxMw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r553213913", "bodyText": "Sounds much better!\nA related question: when do we take these maps from outside Quarkus?", "author": "rsynek", "createdAt": "2021-01-07T09:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAzMTQyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyMjEyNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r553422127", "bodyText": "When the OptaPlanner ScoreFactory bean get initialized from Quarkus. (Outside Quarkus, this would only be called if the bytecode was already generated (say via a build time processor or equivalent).", "author": "Christopher-Chianelli", "createdAt": "2021-01-07T16:03:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAzMTQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNzMzNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552437337", "bodyText": "A suggestion in order not to repeat the map in every annotation wrapper: declare an abstract super class.", "author": "rsynek", "createdAt": "2021-01-06T08:38:00Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoAnnotationWrappers.java", "diffHunk": "@@ -0,0 +1,740 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.IndexView;\n+import org.optaplanner.core.api.domain.autodiscover.AutoDiscoverMemberType;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfiguration;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfigurationProvider;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintWeight;\n+import org.optaplanner.core.api.domain.entity.PinningFilter;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.lookup.LookUpStrategyType;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.ProblemFactProperty;\n+import org.optaplanner.core.api.domain.solution.cloner.SolutionCloner;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableGraphType;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableReference;\n+import org.optaplanner.core.api.domain.variable.VariableListener;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.score.definition.ScoreDefinition;\n+\n+/**\n+ * Contains wrappers for Annotations so they may be\n+ * recorded in bytecode. The annotation's values are stored\n+ * in the wrapper's map.\n+ *\n+ * When bytecode is being recorded in Quarkus (i.e. an\n+ * object is passed to a recorder), the following restrictions apply:\n+ *\n+ * - Classes without public getters/setters for all fields,\n+ * a constructor annotated with @RecordableConstructor with parameter names that match field names or a\n+ * registered substitution cannot be recorded. (https://quarkus.io/guides/writing-extensions#bytecode-recording)\n+ *\n+ * Annotations and Generic Types do not satisfy the above criteria, so they cannot be\n+ * recorded directly at build time. However, we don't want to use reflection at runtime,\n+ * and we want to build the GizmoMemberAccessors at build time. So we need to create\n+ * wrappers for the annotations and types so they can be recorded.\n+ */\n+public class GizmoAnnotationWrappers {\n+\n+    enum AllOptaPlannerAnnotationEnum {\n+        CONSTRAINT_CONFIGURATION(ConstraintConfiguration.class,\n+                ConstraintConfigurationWrapper::new),\n+        CONSTRAINT_CONFIGURATION_PROVIDER(ConstraintConfigurationProvider.class,\n+                ConstraintConfigurationProviderWrapper::new),\n+        CONSTRAINT_WEIGHT(ConstraintWeight.class, ConstraintWeightWrapper::new),\n+        PLANNING_ENTITY(PlanningEntity.class, PlanningEntityWrapper::new),\n+        PLANNING_PIN(PlanningPin.class, PlanningPinWrapper::new),\n+        PLANNING_ID(PlanningId.class, PlanningIdWrapper::new),\n+        PLANNING_ENTITY_COLLECTION_PROPERTY(PlanningEntityCollectionProperty.class,\n+                PlanningEntityCollectionPropertyWrapper::new),\n+        PLANNING_ENTITY_PROPERTY(PlanningEntityProperty.class,\n+                PlanningEntityPropertyWrapper::new),\n+        PLANNING_SCORE(PlanningScore.class, PlanningScoreWrapper::new),\n+        PLANNING_SOLUTION(PlanningSolution.class, PlanningSolutionWrapper::new),\n+        PROBLEM_FACT_COLLECTION_PROPERTY(ProblemFactCollectionProperty.class,\n+                ProblemFactCollectionPropertyWrapper::new),\n+        PROBLEM_FACT_PROPERTY(ProblemFactProperty.class, ProblemFactPropertyWrapper::new),\n+        VALUE_RANGE_PROVIDER(ValueRangeProvider.class, ValueRangeProviderWrapper::new),\n+        ANCHOR_SHADOW_VARIABLE(AnchorShadowVariable.class, AnchorShadowVariableWrapper::new),\n+        CUSTOM_SHADOW_VARIABLE(CustomShadowVariable.class, CustomShadowVariableWrapper::new),\n+        INVERSE_RELATION_SHADOW_VARIABLE(InverseRelationShadowVariable.class,\n+                InverseRelationShadowVariableWrapper::new),\n+        PLANNING_VARIABLE(PlanningVariable.class, PlanningVariableWrapper::new),\n+        PLANNING_VARIABLE_REFERENCE(PlanningVariableReference.class, PlanningVariableReferenceWrapper::new);\n+\n+        Class<?> annotationClass;\n+        Function<Map<String, Object>, Annotation> mapper;\n+\n+        <T extends Annotation> AllOptaPlannerAnnotationEnum(Class<? extends T> annotationClass,\n+                Function<Map<String, Object>, T> mapper) {\n+            this.annotationClass = annotationClass;\n+            this.mapper = (Function<Map<String, Object>, Annotation>) mapper;\n+        }\n+\n+        public Annotation get(Map<String, Object> values) {\n+            return mapper.apply(values);\n+        }\n+\n+        public static Annotation getForClass(Class<? extends Annotation> annotationClass, Map<String, Object> values) {\n+            for (AllOptaPlannerAnnotationEnum annotationType : AllOptaPlannerAnnotationEnum.values()) {\n+                if (annotationClass.equals(annotationType.annotationClass)) {\n+                    return annotationType.get(values);\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Missing case for \" + annotationClass);\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(Class<? extends Annotation> annotationClass) {\n+            return isOptaPlannerAnnotation(annotationClass.getName());\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(String annotationClass) {\n+            return annotationClass.startsWith(\"org.optaplanner.\");\n+        }\n+    }\n+\n+    public static class AnnotationWrapper implements Supplier<Annotation> {\n+        Class<? extends Annotation> annotationType;\n+        Map<String, Object> annotationValues = new HashMap<String, Object>();\n+        Annotation annotation;\n+\n+        public AnnotationWrapper() {\n+        }\n+\n+        public AnnotationWrapper(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+\n+        public AnnotationWrapper(AnnotationInstance annotationInstance, IndexView indexView) {\n+            try {\n+                annotationType = (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(e);\n+            }\n+            annotationValues = new HashMap<>();\n+            if (AllOptaPlannerAnnotationEnum.isOptaPlannerAnnotation(annotationType)) {\n+                // Annotation is an OptaPlanner annotation (i.e.\n+                // is a subpackage of org.optaplanner)\n+                annotationInstance.valuesWithDefaults(indexView).forEach((value) -> {\n+                    switch (value.kind()) {\n+                        case BYTE:\n+                            annotationValues.put(value.name(),\n+                                    value.asByte());\n+                            break;\n+                        case SHORT:\n+                            annotationValues.put(value.name(),\n+                                    value.asShort());\n+                            break;\n+                        case INTEGER:\n+                            annotationValues.put(value.name(),\n+                                    value.asInt());\n+                            break;\n+                        case CHARACTER:\n+                            annotationValues.put(value.name(),\n+                                    value.asChar());\n+                            break;\n+                        case FLOAT:\n+                            annotationValues.put(value.name(),\n+                                    value.asFloat());\n+                            break;\n+                        case DOUBLE:\n+                            annotationValues.put(value.name(),\n+                                    value.asDouble());\n+                            break;\n+                        case LONG:\n+                            annotationValues.put(value.name(),\n+                                    value.asLong());\n+                            break;\n+                        case BOOLEAN:\n+                            annotationValues.put(value.name(),\n+                                    value.asBoolean());\n+                            break;\n+                        case CLASS:\n+                            try {\n+                                annotationValues.put(value.name(),\n+                                        Class.forName(value.asClass().toString()));\n+                            } catch (ClassNotFoundException e) {\n+                                throw new IllegalStateException(e);\n+                            }\n+                            break;\n+                        case STRING:\n+                            annotationValues.put(value.name(),\n+                                    value.asString());\n+                            break;\n+                        case ENUM:\n+                            annotationValues.put(value.name(),\n+                                    value.asEnum());\n+                            break;\n+                        case ARRAY:\n+                            switch (value.componentKind()) {\n+                                case BYTE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asByteArray());\n+                                    break;\n+                                case SHORT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asShortArray());\n+                                    break;\n+                                case INTEGER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asIntArray());\n+                                    break;\n+                                case CHARACTER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asCharArray());\n+                                    break;\n+                                case FLOAT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asFloatArray());\n+                                    break;\n+                                case DOUBLE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asDoubleArray());\n+                                    break;\n+                                case LONG:\n+                                    annotationValues.put(value.name(),\n+                                            value.asLongArray());\n+                                    break;\n+                                case BOOLEAN:\n+                                    annotationValues.put(value.name(),\n+                                            value.asBooleanArray());\n+                                    break;\n+                                case CLASS: {\n+                                    Class[] valueArr = Arrays.stream(value.asClassArray())\n+                                            .map(v -> {\n+                                                try {\n+                                                    return Class.forName(v.toString());\n+                                                } catch (ClassNotFoundException e) {\n+                                                    throw new IllegalStateException(e);\n+                                                }\n+                                            })\n+                                            .collect(Collectors.toList()).toArray(new Class[0]);\n+                                    annotationValues.put(value.name(),\n+                                            valueArr);\n+                                    break;\n+                                }\n+                                case STRING:\n+                                    annotationValues.put(value.name(),\n+                                            value.asStringArray());\n+                                    break;\n+                                case ENUM:\n+                                    annotationValues.put(value.name(),\n+                                            value.asEnumArray());\n+                                    break;\n+                                case NESTED: {\n+                                    Annotation[] valueArr = Arrays.stream(value.asNestedArray())\n+                                            .map(v -> new AnnotationWrapper(v, indexView).get())\n+                                            .collect(Collectors.toList()).toArray(new Annotation[0]);\n+                                    annotationValues.put(value.name(),\n+                                            valueArr);\n+                                    break;\n+                                }\n+                                case UNKNOWN:\n+                                    // Note: If an array is empty, it is unknown, but\n+                                    // Jandex doesn't provide a way to check array length\n+                                    // According to Jandex javadoc:\n+                                    //\n+                                    // A special AnnotationValue.Kind.UNKNOWN kind is used to refer to\n+                                    // components of zero-length arrays, as the underlying type is not known.\n+                                    //\n+                                    // So it safe to use an empty Object array\n+                                    annotationValues.put(value.name(),\n+                                            new Object[] {});\n+                                    break;\n+                                case ARRAY:\n+                                default:\n+                                    throw new IllegalStateException(\"Arrays of \" + value.componentKind() +\n+                                            \" are unsupported in the enum parser.\" +\n+                                            \" This exception was caused by a\" +\n+                                            \" @\" + annotationInstance.name() + \" annotation\" +\n+                                            \" for parameter \" + value.name() + \".\" +\n+                                            \" Maybe put \" + annotationInstance.name() +\n+                                            \" not in a subpackage of org.optaplanner?\");\n+                            }\n+                            break;\n+                        case NESTED:\n+                            AnnotationWrapper wrapper = new AnnotationWrapper(value.asNested(), indexView);\n+                            annotationValues.put(value.name(), wrapper.get());\n+                            break;\n+                        case UNKNOWN:\n+                        default:\n+                            throw new IllegalStateException(value.componentKind() +\n+                                    \" are unsupported in the enum parser.\" +\n+                                    \" This exception was caused by a\" +\n+                                    \" @\" + annotationInstance.name() + \" annotation\" +\n+                                    \" for parameter \" + value.name() + \".\" +\n+                                    \" Maybe put \" + annotationInstance.name() +\n+                                    \" not in a subpackage of org.optaplanner?\");\n+                    }\n+                });\n+            }\n+        }\n+\n+        @Override\n+        public Annotation get() {\n+            if (annotation != null) {\n+                return annotation;\n+            } else {\n+                return AllOptaPlannerAnnotationEnum.getForClass(annotationType, annotationValues);\n+            }\n+        }\n+\n+        public Class<? extends Annotation> getAnnotationType() {\n+            return annotationType;\n+        }\n+\n+        public void setAnnotationType(Class<? extends Annotation> annotationType) {\n+            this.annotationType = annotationType;\n+        }\n+\n+        public Map<String, Object> getAnnotationValues() {\n+            return annotationValues;\n+        }\n+\n+        public void setAnnotationValues(Map<String, Object> annotationValues) {\n+            this.annotationValues = annotationValues;\n+        }\n+\n+        public Annotation getAnnotation() {\n+            return annotation;\n+        }\n+\n+        public void setAnnotation(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+    }\n+\n+    public static class ConstraintConfigurationWrapper implements ConstraintConfiguration {\n+        public Map<String, Object> map;", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUyMTA5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r553521091", "bodyText": "I debated this, and wonder about how clear it would be map was a public variable from its superclass. Perhaps I can replace using the map with a generic method", "author": "Christopher-Chianelli", "createdAt": "2021-01-07T18:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQzNzMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MTM1MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552441351", "bodyText": "Redundant block of code; in fact, it's a single line.", "author": "rsynek", "createdAt": "2021-01-06T08:47:10Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoTypeWrappers.java", "diffHunk": "@@ -0,0 +1,400 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.AnnotatedType;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.jandex.PrimitiveType;\n+\n+/**\n+ * Contains wrappers for types so they may be\n+ * recorded in bytecode.\n+ *\n+ * When bytecode is being recorded in Quarkus (i.e. an\n+ * object is passed to a recorder), the following restrictions apply:\n+ *\n+ * - Classes without public getters/setters for all fields,\n+ * a constructor annotated with @RecordableConstructor with parameter names that match field names or a\n+ * registered substitution cannot be recorded. (https://quarkus.io/guides/writing-extensions#bytecode-recording)\n+ *\n+ * Annotations and Generic Types do not satisfy the above criteria, so they cannot be\n+ * recorded directly at build time. However, we don't want to use reflection at runtime,\n+ * and we want to build the GizmoMemberAccessors at build time. So we need to create\n+ * wrappers for the annotations and types so they can be recorded.\n+ */\n+public class GizmoTypeWrappers {\n+\n+    public static Type getTypeForJandex(IndexView indexView, org.jboss.jandex.Type jandexType) {\n+        if (jandexType == null) {\n+            return null;\n+        }\n+\n+        switch (jandexType.kind()) {\n+            case CLASS:\n+                try {\n+                    // Classes do not need a wrapper, so we can just return the Class object\n+                    return Class.forName(jandexType.asClassType().name().toString(), false,\n+                            Thread.currentThread().getContextClassLoader());\n+                } catch (ClassNotFoundException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            case ARRAY:\n+                return new GizmoTypeWrappers.ArrayTypeWrapper(\n+                        getTypeForJandex(indexView, jandexType.asArrayType().component()));\n+            case PRIMITIVE:\n+                return lookupPrimitiveType(jandexType.asPrimitiveType().primitive());\n+            case VOID:\n+                return void.class;\n+            case TYPE_VARIABLE: {", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyMzM4OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r553423388", "bodyText": "Habit from liking to use same variable names in multiple switch cases that only have a few lines.", "author": "Christopher-Chianelli", "createdAt": "2021-01-07T16:05:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MTM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MjE4MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552442181", "bodyText": "Such a switch statement with block of code under individual cases is difficult to test.\nSuggestion: if any CASE is not a one-liner, move the block of code to a method, which can be easily unit-tested.", "author": "rsynek", "createdAt": "2021-01-06T08:49:09Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoTypeWrappers.java", "diffHunk": "@@ -0,0 +1,400 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.AnnotatedType;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.jandex.PrimitiveType;\n+\n+/**\n+ * Contains wrappers for types so they may be\n+ * recorded in bytecode.\n+ *\n+ * When bytecode is being recorded in Quarkus (i.e. an\n+ * object is passed to a recorder), the following restrictions apply:\n+ *\n+ * - Classes without public getters/setters for all fields,\n+ * a constructor annotated with @RecordableConstructor with parameter names that match field names or a\n+ * registered substitution cannot be recorded. (https://quarkus.io/guides/writing-extensions#bytecode-recording)\n+ *\n+ * Annotations and Generic Types do not satisfy the above criteria, so they cannot be\n+ * recorded directly at build time. However, we don't want to use reflection at runtime,\n+ * and we want to build the GizmoMemberAccessors at build time. So we need to create\n+ * wrappers for the annotations and types so they can be recorded.\n+ */\n+public class GizmoTypeWrappers {\n+\n+    public static Type getTypeForJandex(IndexView indexView, org.jboss.jandex.Type jandexType) {\n+        if (jandexType == null) {\n+            return null;\n+        }\n+\n+        switch (jandexType.kind()) {", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU0OTQwNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r553549405", "bodyText": "I moved the logic into the corresponding constructors", "author": "Christopher-Chianelli", "createdAt": "2021-01-07T19:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MjE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0MzEzNg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552443136", "bodyText": "Formatting: the sentence fits a single line.", "author": "rsynek", "createdAt": "2021-01-06T08:51:18Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NzExMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552447111", "bodyText": "I haven't found any usage of the method; why do we define it and return an empty string?", "author": "rsynek", "createdAt": "2021-01-06T09:00:12Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjczODI0Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552738243", "bodyText": "Here a pain; it an abstract method in Java 11, but doesn't exists in Java 8. So I cannot use @Override without breaking Java 8. It needed to be compliant with Java 11.", "author": "Christopher-Chianelli", "createdAt": "2021-01-06T15:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NzExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxMjM5NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r553212394", "bodyText": "If the method needs to stay, why not returning some meaningful name of the classloader?", "author": "rsynek", "createdAt": "2021-01-07T09:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NzExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNzcwOA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r553427708", "bodyText": "It does (I fixed in a previous commit that also add a comment why there no Override): \"OptaPlanner Gizmo MemberAccessor ClassLoader\"", "author": "Christopher-Chianelli", "createdAt": "2021-01-07T16:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NzExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1MjAyNg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552452026", "bodyText": "One-line lambdas can be written like follows (soft suggestion):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ClassOutput classOutput = (path, byteCode) -> {\n          \n          \n            \n                        classBytecodeHolder[0] = byteCode;\n          \n          \n            \n                    };\n          \n          \n            \n                    ClassOutput classOutput = (path, byteCode) -> classBytecodeHolder[0] = byteCode;", "author": "rsynek", "createdAt": "2021-01-06T09:10:22Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjczOTQ1OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552739458", "bodyText": "I don't like assignments as a one-line lambda; IMO, doesn't look as nice, and can be confused with ==", "author": "Christopher-Chianelli", "createdAt": "2021-01-06T15:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1MjAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1MjY2NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552452664", "bodyText": "Unused parameters.", "author": "rsynek", "createdAt": "2021-01-06T09:11:37Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };\n+        ClassCreator classCreator = ClassCreator.builder()\n+                .className(className)\n+                .interfaces(MemberAccessor.class)\n+                .superClass(Object.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        MemberDescriptor memberDescriptor = new MemberDescriptor(member);\n+        defineAccessorFor(classCreator, memberDescriptor, annotationClass);\n+\n+        classCreator.close();\n+        byte[] classBytecode = classBytecodeHolder[0];\n+\n+        classNameToBytecode.put(className, classBytecode);\n+        return createInstance(className);\n+    }\n+\n+    private static MemberAccessor createInstance(String className) {\n+        try {\n+            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n+                    .getConstructor().newInstance();\n+        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | ClassNotFoundException\n+                | NoSuchMethodException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Generic Type that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The generic type gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getGenericType\n+     */\n+    public static Type getGenericTypeFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToGenericType.get(gizmoMemberAccessorName);\n+    }\n+\n+    /**\n+     * Returns the AnnotatedElement that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The AnnotatedElement gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getAnnotatedElement\n+     */\n+    public static AnnotatedElement getAnnotatedElementFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToAnnotatedElement.get(gizmoMemberAccessorName);\n+    }\n+\n+    // ************************************************************************\n+    // MemberAccessor methods\n+    // ************************************************************************\n+\n+    private static MethodCreator getMethodCreator(ClassCreator classCreator, String methodName, Class<?>... parameters) {\n+        try {\n+            return classCreator.getMethodCreator(\n+                    MethodDescriptor.ofMethod(MemberAccessor.class.getMethod(methodName, parameters)));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createConstructor(ClassCreator classCreator, MemberDescriptor member,", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc0MjcxNA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552742714", "bodyText": "I mainly include all possible parameters for all implementor methods for consistency. That way parameter 1 is always X, parameter 2 is always Y, and it easy to write/add new methods.", "author": "Christopher-Chianelli", "createdAt": "2021-01-06T16:00:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1MjY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxMDEwNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r553210107", "bodyText": "I see the point, but for me it's more relevant for a hierarchy of classes sharing the same signature of some method. If we always want to pass the same parameters into every method, regardless if they are going to be used, consider wrapping them by a new data class.", "author": "rsynek", "createdAt": "2021-01-07T09:32:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1MjY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1NjI0Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552456243", "bodyText": "A formatting suggestion (please consider for other methods as well):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Class getDeclaringClass() {\n          \n          \n            \n                 * return ClassThatDeclaredMember.class;\n          \n          \n            \n                 * }\n          \n          \n            \n                 * <pre>\n          \n          \n            \n                 *     Class getDeclaringClass() {\n          \n          \n            \n                 *         return ClassThatDeclaredMember.class;\n          \n          \n            \n                 *     }\n          \n          \n            \n                 * </pre>", "author": "rsynek", "createdAt": "2021-01-06T09:18:51Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };\n+        ClassCreator classCreator = ClassCreator.builder()\n+                .className(className)\n+                .interfaces(MemberAccessor.class)\n+                .superClass(Object.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        MemberDescriptor memberDescriptor = new MemberDescriptor(member);\n+        defineAccessorFor(classCreator, memberDescriptor, annotationClass);\n+\n+        classCreator.close();\n+        byte[] classBytecode = classBytecodeHolder[0];\n+\n+        classNameToBytecode.put(className, classBytecode);\n+        return createInstance(className);\n+    }\n+\n+    private static MemberAccessor createInstance(String className) {\n+        try {\n+            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n+                    .getConstructor().newInstance();\n+        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | ClassNotFoundException\n+                | NoSuchMethodException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Generic Type that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The generic type gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getGenericType\n+     */\n+    public static Type getGenericTypeFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToGenericType.get(gizmoMemberAccessorName);\n+    }\n+\n+    /**\n+     * Returns the AnnotatedElement that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The AnnotatedElement gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getAnnotatedElement\n+     */\n+    public static AnnotatedElement getAnnotatedElementFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToAnnotatedElement.get(gizmoMemberAccessorName);\n+    }\n+\n+    // ************************************************************************\n+    // MemberAccessor methods\n+    // ************************************************************************\n+\n+    private static MethodCreator getMethodCreator(ClassCreator classCreator, String methodName, Class<?>... parameters) {\n+        try {\n+            return classCreator.getMethodCreator(\n+                    MethodDescriptor.ofMethod(MemberAccessor.class.getMethod(methodName, parameters)));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createConstructor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator =\n+                classCreator.getMethodCreator(MethodDescriptor.ofConstructor(classCreator.getClassName()));\n+\n+        ResultHandle thisObj = methodCreator.getThis();\n+\n+        // Invoke Object's constructor\n+        methodCreator.invokeSpecialMethod(MethodDescriptor.ofConstructor(Object.class), thisObj);\n+\n+        // Return this (it a constructor)\n+        methodCreator.returnValue(thisObj);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getDeclaringClass() {\n+     * return ClassThatDeclaredMember.class;\n+     * }", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1NjY0MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552456640", "bodyText": "The annotationClass parameter is not used (please check also other methods below).", "author": "rsynek", "createdAt": "2021-01-06T09:19:29Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };\n+        ClassCreator classCreator = ClassCreator.builder()\n+                .className(className)\n+                .interfaces(MemberAccessor.class)\n+                .superClass(Object.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        MemberDescriptor memberDescriptor = new MemberDescriptor(member);\n+        defineAccessorFor(classCreator, memberDescriptor, annotationClass);\n+\n+        classCreator.close();\n+        byte[] classBytecode = classBytecodeHolder[0];\n+\n+        classNameToBytecode.put(className, classBytecode);\n+        return createInstance(className);\n+    }\n+\n+    private static MemberAccessor createInstance(String className) {\n+        try {\n+            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n+                    .getConstructor().newInstance();\n+        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | ClassNotFoundException\n+                | NoSuchMethodException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Generic Type that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The generic type gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getGenericType\n+     */\n+    public static Type getGenericTypeFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToGenericType.get(gizmoMemberAccessorName);\n+    }\n+\n+    /**\n+     * Returns the AnnotatedElement that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The AnnotatedElement gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getAnnotatedElement\n+     */\n+    public static AnnotatedElement getAnnotatedElementFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToAnnotatedElement.get(gizmoMemberAccessorName);\n+    }\n+\n+    // ************************************************************************\n+    // MemberAccessor methods\n+    // ************************************************************************\n+\n+    private static MethodCreator getMethodCreator(ClassCreator classCreator, String methodName, Class<?>... parameters) {\n+        try {\n+            return classCreator.getMethodCreator(\n+                    MethodDescriptor.ofMethod(MemberAccessor.class.getMethod(methodName, parameters)));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createConstructor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator =\n+                classCreator.getMethodCreator(MethodDescriptor.ofConstructor(classCreator.getClassName()));\n+\n+        ResultHandle thisObj = methodCreator.getThis();\n+\n+        // Invoke Object's constructor\n+        methodCreator.invokeSpecialMethod(MethodDescriptor.ofConstructor(Object.class), thisObj);\n+\n+        // Return this (it a constructor)\n+        methodCreator.returnValue(thisObj);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getDeclaringClass() {\n+     * return ClassThatDeclaredMember.class;\n+     * }\n+     */\n+    private static void createGetDeclaringClass(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc0NDcwMg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552744702", "bodyText": "See above; it is used in one method for an exception message (fails MemberAccessor tests that check for a specific error message otherwise). (So to be consistent, it included in all methods)", "author": "Christopher-Chianelli", "createdAt": "2021-01-06T16:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ1NjY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ4NzUzOA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552487538", "bodyText": "May be reused as a standalone method.", "author": "rsynek", "createdAt": "2021-01-06T10:17:33Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };\n+        ClassCreator classCreator = ClassCreator.builder()\n+                .className(className)\n+                .interfaces(MemberAccessor.class)\n+                .superClass(Object.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        MemberDescriptor memberDescriptor = new MemberDescriptor(member);\n+        defineAccessorFor(classCreator, memberDescriptor, annotationClass);\n+\n+        classCreator.close();\n+        byte[] classBytecode = classBytecodeHolder[0];\n+\n+        classNameToBytecode.put(className, classBytecode);\n+        return createInstance(className);\n+    }\n+\n+    private static MemberAccessor createInstance(String className) {\n+        try {\n+            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n+                    .getConstructor().newInstance();\n+        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | ClassNotFoundException\n+                | NoSuchMethodException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Generic Type that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The generic type gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getGenericType\n+     */\n+    public static Type getGenericTypeFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToGenericType.get(gizmoMemberAccessorName);\n+    }\n+\n+    /**\n+     * Returns the AnnotatedElement that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The AnnotatedElement gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getAnnotatedElement\n+     */\n+    public static AnnotatedElement getAnnotatedElementFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToAnnotatedElement.get(gizmoMemberAccessorName);\n+    }\n+\n+    // ************************************************************************\n+    // MemberAccessor methods\n+    // ************************************************************************\n+\n+    private static MethodCreator getMethodCreator(ClassCreator classCreator, String methodName, Class<?>... parameters) {\n+        try {\n+            return classCreator.getMethodCreator(\n+                    MethodDescriptor.ofMethod(MemberAccessor.class.getMethod(methodName, parameters)));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createConstructor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator =\n+                classCreator.getMethodCreator(MethodDescriptor.ofConstructor(classCreator.getClassName()));\n+\n+        ResultHandle thisObj = methodCreator.getThis();\n+\n+        // Invoke Object's constructor\n+        methodCreator.invokeSpecialMethod(MethodDescriptor.ofConstructor(Object.class), thisObj);\n+\n+        // Return this (it a constructor)\n+        methodCreator.returnValue(thisObj);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getDeclaringClass() {\n+     * return ClassThatDeclaredMember.class;\n+     * }\n+     */\n+    private static void createGetDeclaringClass(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getDeclaringClass\");\n+        ResultHandle out = methodCreator.loadClass(member.getDeclaringClassName());\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Asserts method is a getter or read method\n+     *\n+     * @param method Method to assert is getter or read\n+     * @param annotationClass Used in exception message\n+     */\n+    private static void assertIsGoodMethod(MethodDescriptor method, Class<? extends Annotation> annotationClass) {\n+        if (method.getParameterTypes().length != 0) {\n+            // not read or getter method\n+            throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                    + annotationClass.getSimpleName() + \" annotation must not have any parameters (\"\n+                    + Arrays.toString(method.getParameterTypes()) + \").\");\n+        }\n+        String methodName = method.getName();\n+        if (methodName.startsWith(\"get\")) {\n+            if (method.getReturnType().equals(\"void\")) {\n+                throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a non-void return type (\"\n+                        + method.getReturnType() + \").\");\n+            }\n+        } else if (methodName.startsWith(\"is\")) {\n+            if (!method.getReturnType().equals(\"boolean\")) {\n+                throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a primitive boolean return type (\"\n+                        + method.getReturnType() + \") or use another prefix in its methodName (\"\n+                        + methodName + \").\");\n+            }\n+        } else {\n+            // must be a read method\n+            if (method.getReturnType().equals(\"void\")) {\n+                throw new IllegalStateException(\"The readMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a non-void return type (\"\n+                        + method.getReturnType() + \").\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * String getName() {\n+     * return \"fieldOrMethodName\";\n+     * }\n+     *\n+     * If it is a getter method, \"get\" is removed and the first\n+     * letter become lowercase\n+     */\n+    private static void createGetName(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getName\");\n+\n+        // If it is a method, assert that it has the required\n+        // properties\n+        member.whenIsMethod(method -> {\n+            assertIsGoodMethod(method, annotationClass);\n+        });\n+\n+        String fieldName = member.getName();\n+        ResultHandle out = methodCreator.load(fieldName);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getType() {\n+     * return FieldTypeOrMethodReturnType.class;\n+     * }\n+     */\n+    private static void createGetType(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getType\");\n+        ResultHandle out = methodCreator.loadClass(member.getTypeName());\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Type getGenericType() {\n+     * return GizmoMemberAccessorImplementor.getGenericTypeFor(this.getClass().getName());\n+     * }\n+     *\n+     * We are unable to load a non-primitive object constant, so we need to store it\n+     * in the implementor, which then can return us the Type when needed. The type\n+     * is stored in gizmoMemberAccessorNameToGenericType when this method is called.\n+     */\n+    private static void createGetGenericType(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getGenericType\");\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+\n+        // Put the member generic type in the map\n+        gizmoMemberAccessorNameToGenericType.put(gizmoMemberAccessorName,\n+                member.getType());\n+\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+\n+        // Use getGenericTypeFor to receive the generic type that\n+        // was put in the map\n+        ResultHandle out = methodCreator.invokeStaticMethod(\n+                MethodDescriptor.ofMethod(GizmoMemberAccessorImplementor.class,\n+                        \"getGenericTypeFor\",\n+                        Type.class,\n+                        String.class),\n+                gizmoMemberAccessorNameResult);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field\n+     * Object executeGetter(Object bean) {\n+     * return ((DeclaringClass) bean).field;\n+     * }\n+     *\n+     * // for a method\n+     * Object executeGetter(Object bean) {\n+     * return ((DeclaringClass) bean).method();\n+     * }\n+     *\n+     * The member MUST be public if not called in Quarkus\n+     * (i.e. we don't delegate to the field getter/setter).\n+     * In Quarkus, we generate simple getter/setter for the\n+     * member if it is private (which get passed to the MemberDescriptor).\n+     */\n+    private static void createExecuteGetter(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"executeGetter\", Object.class);\n+        ResultHandle bean = methodCreator.getMethodParam(0);\n+\n+        member.whenIsMethod(method -> {\n+            assertIsGoodMethod(method, annotationClass);\n+            ResultHandle out;\n+            if (member.isInterfaceMethod()) {\n+                out = methodCreator.invokeInterfaceMethod(method, bean);\n+            } else {\n+                out = methodCreator.invokeVirtualMethod(method, bean);\n+            }", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ5NTkyNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552495927", "bodyText": "A good old if-else would make it clear it's either a method or a field, never both.", "author": "rsynek", "createdAt": "2021-01-06T10:34:49Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };\n+        ClassCreator classCreator = ClassCreator.builder()\n+                .className(className)\n+                .interfaces(MemberAccessor.class)\n+                .superClass(Object.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        MemberDescriptor memberDescriptor = new MemberDescriptor(member);\n+        defineAccessorFor(classCreator, memberDescriptor, annotationClass);\n+\n+        classCreator.close();\n+        byte[] classBytecode = classBytecodeHolder[0];\n+\n+        classNameToBytecode.put(className, classBytecode);\n+        return createInstance(className);\n+    }\n+\n+    private static MemberAccessor createInstance(String className) {\n+        try {\n+            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n+                    .getConstructor().newInstance();\n+        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | ClassNotFoundException\n+                | NoSuchMethodException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Generic Type that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The generic type gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getGenericType\n+     */\n+    public static Type getGenericTypeFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToGenericType.get(gizmoMemberAccessorName);\n+    }\n+\n+    /**\n+     * Returns the AnnotatedElement that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The AnnotatedElement gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getAnnotatedElement\n+     */\n+    public static AnnotatedElement getAnnotatedElementFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToAnnotatedElement.get(gizmoMemberAccessorName);\n+    }\n+\n+    // ************************************************************************\n+    // MemberAccessor methods\n+    // ************************************************************************\n+\n+    private static MethodCreator getMethodCreator(ClassCreator classCreator, String methodName, Class<?>... parameters) {\n+        try {\n+            return classCreator.getMethodCreator(\n+                    MethodDescriptor.ofMethod(MemberAccessor.class.getMethod(methodName, parameters)));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createConstructor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator =\n+                classCreator.getMethodCreator(MethodDescriptor.ofConstructor(classCreator.getClassName()));\n+\n+        ResultHandle thisObj = methodCreator.getThis();\n+\n+        // Invoke Object's constructor\n+        methodCreator.invokeSpecialMethod(MethodDescriptor.ofConstructor(Object.class), thisObj);\n+\n+        // Return this (it a constructor)\n+        methodCreator.returnValue(thisObj);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getDeclaringClass() {\n+     * return ClassThatDeclaredMember.class;\n+     * }\n+     */\n+    private static void createGetDeclaringClass(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getDeclaringClass\");\n+        ResultHandle out = methodCreator.loadClass(member.getDeclaringClassName());\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Asserts method is a getter or read method\n+     *\n+     * @param method Method to assert is getter or read\n+     * @param annotationClass Used in exception message\n+     */\n+    private static void assertIsGoodMethod(MethodDescriptor method, Class<? extends Annotation> annotationClass) {\n+        if (method.getParameterTypes().length != 0) {\n+            // not read or getter method\n+            throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                    + annotationClass.getSimpleName() + \" annotation must not have any parameters (\"\n+                    + Arrays.toString(method.getParameterTypes()) + \").\");\n+        }\n+        String methodName = method.getName();\n+        if (methodName.startsWith(\"get\")) {\n+            if (method.getReturnType().equals(\"void\")) {\n+                throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a non-void return type (\"\n+                        + method.getReturnType() + \").\");\n+            }\n+        } else if (methodName.startsWith(\"is\")) {\n+            if (!method.getReturnType().equals(\"boolean\")) {\n+                throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a primitive boolean return type (\"\n+                        + method.getReturnType() + \") or use another prefix in its methodName (\"\n+                        + methodName + \").\");\n+            }\n+        } else {\n+            // must be a read method\n+            if (method.getReturnType().equals(\"void\")) {\n+                throw new IllegalStateException(\"The readMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a non-void return type (\"\n+                        + method.getReturnType() + \").\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * String getName() {\n+     * return \"fieldOrMethodName\";\n+     * }\n+     *\n+     * If it is a getter method, \"get\" is removed and the first\n+     * letter become lowercase\n+     */\n+    private static void createGetName(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getName\");\n+\n+        // If it is a method, assert that it has the required\n+        // properties\n+        member.whenIsMethod(method -> {\n+            assertIsGoodMethod(method, annotationClass);\n+        });\n+\n+        String fieldName = member.getName();\n+        ResultHandle out = methodCreator.load(fieldName);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getType() {\n+     * return FieldTypeOrMethodReturnType.class;\n+     * }\n+     */\n+    private static void createGetType(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getType\");\n+        ResultHandle out = methodCreator.loadClass(member.getTypeName());\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Type getGenericType() {\n+     * return GizmoMemberAccessorImplementor.getGenericTypeFor(this.getClass().getName());\n+     * }\n+     *\n+     * We are unable to load a non-primitive object constant, so we need to store it\n+     * in the implementor, which then can return us the Type when needed. The type\n+     * is stored in gizmoMemberAccessorNameToGenericType when this method is called.\n+     */\n+    private static void createGetGenericType(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getGenericType\");\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+\n+        // Put the member generic type in the map\n+        gizmoMemberAccessorNameToGenericType.put(gizmoMemberAccessorName,\n+                member.getType());\n+\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+\n+        // Use getGenericTypeFor to receive the generic type that\n+        // was put in the map\n+        ResultHandle out = methodCreator.invokeStaticMethod(\n+                MethodDescriptor.ofMethod(GizmoMemberAccessorImplementor.class,\n+                        \"getGenericTypeFor\",\n+                        Type.class,\n+                        String.class),\n+                gizmoMemberAccessorNameResult);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field\n+     * Object executeGetter(Object bean) {\n+     * return ((DeclaringClass) bean).field;\n+     * }\n+     *\n+     * // for a method\n+     * Object executeGetter(Object bean) {\n+     * return ((DeclaringClass) bean).method();\n+     * }\n+     *\n+     * The member MUST be public if not called in Quarkus\n+     * (i.e. we don't delegate to the field getter/setter).\n+     * In Quarkus, we generate simple getter/setter for the\n+     * member if it is private (which get passed to the MemberDescriptor).\n+     */\n+    private static void createExecuteGetter(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"executeGetter\", Object.class);\n+        ResultHandle bean = methodCreator.getMethodParam(0);\n+\n+        member.whenIsMethod(method -> {\n+            assertIsGoodMethod(method, annotationClass);\n+            ResultHandle out;\n+            if (member.isInterfaceMethod()) {\n+                out = methodCreator.invokeInterfaceMethod(method, bean);\n+            } else {\n+                out = methodCreator.invokeVirtualMethod(method, bean);\n+            }\n+            methodCreator.returnValue(out);\n+        });\n+\n+        member.whenIsField(field -> {\n+            ResultHandle out = methodCreator.readInstanceField(field, bean);\n+            methodCreator.returnValue(out);\n+        });\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field or a getter method that also have a corresponding setter\n+     * boolean supportSetter() {\n+     * return true;\n+     * }\n+     *\n+     * // for a read method or a getter method without a setter\n+     * boolean supportSetter() {\n+     * return false;\n+     * }\n+     */\n+    private static void createSupportSetter(ClassCreator classCreator, MemberDescriptor member, Class<?> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"supportSetter\");\n+        member.whenIsMethod(method -> {\n+            boolean supportSetter = member.getSetter().isPresent();\n+            ResultHandle out = methodCreator.load(supportSetter);\n+            methodCreator.returnValue(out);\n+        });\n+        member.whenIsField(field -> {\n+            ResultHandle out = methodCreator.load(true);\n+            methodCreator.returnValue(out);\n+        });\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field\n+     * void executeSetter(Object bean, Object value) {\n+     * return ((DeclaringClass) bean).field = value;\n+     * }\n+     *\n+     * // for a getter method with a corresponding setter\n+     * void executeSetter(Object bean, Object value) {\n+     * return ((DeclaringClass) bean).setValue(value);\n+     * }\n+     *\n+     * // for a read method or a getter method without a setter\n+     * void executeSetter(Object bean, Object value) {\n+     * throw new UnsupportedOperationException(\"Setter not supported\");\n+     * }\n+     */\n+    private static void createExecuteSetter(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"executeSetter\", Object.class,\n+                Object.class);\n+\n+        member.whenIsMethod(method -> {", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjczMzYzOA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552733638", "bodyText": "The if-else have the disadvantage of allowing invalid operations (in particular, getMethodDescriptor() without isMethod() or getFieldDescriptor() without isField()). By using a consumer based approach, such invalid operations are impossible.", "author": "Christopher-Chianelli", "createdAt": "2021-01-06T15:49:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ5NTkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxMTI4Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r553211283", "bodyText": "No strong opinion here; it's rather a matter of style, your call.", "author": "rsynek", "createdAt": "2021-01-07T09:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ5NTkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUxODc4Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552518787", "bodyText": "When there are several constructors with various combinations of parameters, it's often better to reuse the most general one that takes all the possible parameters, possibly together with factory methods.", "author": "rsynek", "createdAt": "2021-01-06T11:25:30Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java", "diffHunk": "@@ -0,0 +1,842 @@\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Generates the bytecode for the MemberAccessor\n+ * of a particular Member\n+ */\n+public class GizmoMemberAccessorImplementor {\n+\n+    /**\n+     * Stores the generic type of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getGenericTypeFor\n+     */\n+    private static Map<String, Type> gizmoMemberAccessorNameToGenericType = new HashMap<>();\n+\n+    /**\n+     * Stores the annotated element of a member (required\n+     * as we cannot hard code a non-primitive object\n+     * instance in Gizmo code); will be accessed\n+     * from generated Gizmo code via getAnnotatedElementFor\n+     */\n+    private static Map<String, AnnotatedElement> gizmoMemberAccessorNameToAnnotatedElement = new HashMap<>();\n+\n+    /**\n+     * The Gizmo generated bytecode. Used by\n+     * gizmoClassLoader when not run in Quarkus\n+     * in order to create an instance of the Member\n+     * Accessor\n+     */\n+    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();\n+\n+    /**\n+     * A custom classloader that looks for the class in\n+     * classNameToBytecode\n+     */\n+    private static ClassLoader gizmoClassLoader = new ClassLoader() {\n+        public String getName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (classNameToBytecode.containsKey(name)) {\n+                // Gizmo generated class\n+                byte[] byteCode = classNameToBytecode.get(name);\n+                return defineClass(name, byteCode, 0, byteCode.length);\n+            } else {\n+                // Not a Gizmo generated class; load from context class loader\n+                return Thread.currentThread().getContextClassLoader().loadClass(name);\n+            }\n+        }\n+    };\n+\n+    private static boolean useClassLoader = false;\n+\n+    /**\n+     * Call this method if you generated the bytecode\n+     * during the build process (ex: Quarkus)\n+     *\n+     * @param classLoader The classloader that contains the generated\n+     *        gizmo classes.\n+     *\n+     * @param newGizmoMemberAccessorNameToGenericType The map from\n+     *        member accessor class name\n+     *        to its generic type\n+     * @param newGizmoMemberAccessorNameToAnnotatedElement The map from\n+     *        member accessor class name\n+     *        to its annotated Element.\n+     */\n+    public static void setGizmoClassLoader(ClassLoader classLoader, Map<String, Type> newGizmoMemberAccessorNameToGenericType,\n+            Map<String, AnnotatedElement> newGizmoMemberAccessorNameToAnnotatedElement) {\n+        gizmoClassLoader = classLoader;\n+        gizmoMemberAccessorNameToGenericType = newGizmoMemberAccessorNameToGenericType;\n+        gizmoMemberAccessorNameToAnnotatedElement = newGizmoMemberAccessorNameToAnnotatedElement;\n+        useClassLoader = true;\n+    }\n+\n+    /**\n+     * Generates the constructor and implementations of MemberAccessor\n+     * methods for the given MemberDescriptor using the given ClassCreator\n+     *\n+     * @param classCreator ClassCreator to write output to\n+     * @param member Member to generate MemberAccessor methods implementation for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     */\n+    public static void defineAccessorFor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        // ************************************************************************\n+        // MemberAccessor methods\n+        // ************************************************************************\n+        createConstructor(classCreator, member, annotationClass);\n+        createGetDeclaringClass(classCreator, member, annotationClass);\n+        createGetType(classCreator, member, annotationClass);\n+        createGetGenericType(classCreator, member, annotationClass);\n+        createGetName(classCreator, member, annotationClass);\n+        createGetSpeedNote(classCreator, member, annotationClass);\n+        createSupportSetter(classCreator, member, annotationClass);\n+        createExecuteGetter(classCreator, member, annotationClass);\n+        createExecuteSetter(classCreator, member, annotationClass);\n+\n+        // ************************************************************************\n+        // AnnotatedElement methods\n+        // ************************************************************************\n+        createAnnotatedElement(classCreator, member);\n+\n+        createIsAnnotationPresent(classCreator, member, annotationClass);\n+        createGetAnnotation(classCreator, member, annotationClass);\n+        createGetAnnotations(classCreator, member, annotationClass);\n+        createGetDeclaredAnnotations(classCreator, member, annotationClass);\n+    }\n+\n+    /**\n+     * Returns the generated class name for a given member\n+     *\n+     * @param member The member to get the generated class name for\n+     * @return The generated class name for member\n+     */\n+    public static String getGeneratedClassName(Member member) {\n+        return member.getDeclaringClass().getPackage().getName() + \".$optaplanner$__\"\n+                + member.getDeclaringClass().getSimpleName() + \"$__\" + member.getName();\n+    }\n+\n+    /**\n+     * Creates a MemberAccessor for a given member, generating\n+     * the MemberAccessor bytecode if required\n+     *\n+     * @param member The member to generate a MemberAccessor for\n+     * @param annotationClass The annotation it was annotated with (used for\n+     *        error reporting)\n+     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n+     *         Will generate the bytecode the first type it is called\n+     *         for a member, unless a classloader has been set,\n+     *         in which case no Gizmo code will be generated.\n+     */\n+    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass) {\n+        String className = getGeneratedClassName(member);\n+        if (useClassLoader || classNameToBytecode.containsKey(className)) {\n+            return createInstance(className);\n+        }\n+        final byte[][] classBytecodeHolder = new byte[1][];\n+        ClassOutput classOutput = (path, byteCode) -> {\n+            classBytecodeHolder[0] = byteCode;\n+        };\n+        ClassCreator classCreator = ClassCreator.builder()\n+                .className(className)\n+                .interfaces(MemberAccessor.class)\n+                .superClass(Object.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        MemberDescriptor memberDescriptor = new MemberDescriptor(member);\n+        defineAccessorFor(classCreator, memberDescriptor, annotationClass);\n+\n+        classCreator.close();\n+        byte[] classBytecode = classBytecodeHolder[0];\n+\n+        classNameToBytecode.put(className, classBytecode);\n+        return createInstance(className);\n+    }\n+\n+    private static MemberAccessor createInstance(String className) {\n+        try {\n+            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n+                    .getConstructor().newInstance();\n+        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | ClassNotFoundException\n+                | NoSuchMethodException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Generic Type that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The generic type gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getGenericType\n+     */\n+    public static Type getGenericTypeFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToGenericType.get(gizmoMemberAccessorName);\n+    }\n+\n+    /**\n+     * Returns the AnnotatedElement that a particular\n+     * MemberAccessor should return. Used in generated\n+     * Gizmo code.\n+     *\n+     * @param gizmoMemberAccessorName The MemberAccessor that is being queried\n+     * @return The AnnotatedElement gizmoMemberAccessorName should return\n+     *         in MemberAccessor.getAnnotatedElement\n+     */\n+    public static AnnotatedElement getAnnotatedElementFor(String gizmoMemberAccessorName) {\n+        return gizmoMemberAccessorNameToAnnotatedElement.get(gizmoMemberAccessorName);\n+    }\n+\n+    // ************************************************************************\n+    // MemberAccessor methods\n+    // ************************************************************************\n+\n+    private static MethodCreator getMethodCreator(ClassCreator classCreator, String methodName, Class<?>... parameters) {\n+        try {\n+            return classCreator.getMethodCreator(\n+                    MethodDescriptor.ofMethod(MemberAccessor.class.getMethod(methodName, parameters)));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createConstructor(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator =\n+                classCreator.getMethodCreator(MethodDescriptor.ofConstructor(classCreator.getClassName()));\n+\n+        ResultHandle thisObj = methodCreator.getThis();\n+\n+        // Invoke Object's constructor\n+        methodCreator.invokeSpecialMethod(MethodDescriptor.ofConstructor(Object.class), thisObj);\n+\n+        // Return this (it a constructor)\n+        methodCreator.returnValue(thisObj);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getDeclaringClass() {\n+     * return ClassThatDeclaredMember.class;\n+     * }\n+     */\n+    private static void createGetDeclaringClass(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getDeclaringClass\");\n+        ResultHandle out = methodCreator.loadClass(member.getDeclaringClassName());\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Asserts method is a getter or read method\n+     *\n+     * @param method Method to assert is getter or read\n+     * @param annotationClass Used in exception message\n+     */\n+    private static void assertIsGoodMethod(MethodDescriptor method, Class<? extends Annotation> annotationClass) {\n+        if (method.getParameterTypes().length != 0) {\n+            // not read or getter method\n+            throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                    + annotationClass.getSimpleName() + \" annotation must not have any parameters (\"\n+                    + Arrays.toString(method.getParameterTypes()) + \").\");\n+        }\n+        String methodName = method.getName();\n+        if (methodName.startsWith(\"get\")) {\n+            if (method.getReturnType().equals(\"void\")) {\n+                throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a non-void return type (\"\n+                        + method.getReturnType() + \").\");\n+            }\n+        } else if (methodName.startsWith(\"is\")) {\n+            if (!method.getReturnType().equals(\"boolean\")) {\n+                throw new IllegalStateException(\"The getterMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a primitive boolean return type (\"\n+                        + method.getReturnType() + \") or use another prefix in its methodName (\"\n+                        + methodName + \").\");\n+            }\n+        } else {\n+            // must be a read method\n+            if (method.getReturnType().equals(\"void\")) {\n+                throw new IllegalStateException(\"The readMethod (\" + method + \") with a \"\n+                        + annotationClass.getSimpleName() + \" annotation must have a non-void return type (\"\n+                        + method.getReturnType() + \").\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * String getName() {\n+     * return \"fieldOrMethodName\";\n+     * }\n+     *\n+     * If it is a getter method, \"get\" is removed and the first\n+     * letter become lowercase\n+     */\n+    private static void createGetName(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getName\");\n+\n+        // If it is a method, assert that it has the required\n+        // properties\n+        member.whenIsMethod(method -> {\n+            assertIsGoodMethod(method, annotationClass);\n+        });\n+\n+        String fieldName = member.getName();\n+        ResultHandle out = methodCreator.load(fieldName);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Class getType() {\n+     * return FieldTypeOrMethodReturnType.class;\n+     * }\n+     */\n+    private static void createGetType(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getType\");\n+        ResultHandle out = methodCreator.loadClass(member.getTypeName());\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Type getGenericType() {\n+     * return GizmoMemberAccessorImplementor.getGenericTypeFor(this.getClass().getName());\n+     * }\n+     *\n+     * We are unable to load a non-primitive object constant, so we need to store it\n+     * in the implementor, which then can return us the Type when needed. The type\n+     * is stored in gizmoMemberAccessorNameToGenericType when this method is called.\n+     */\n+    private static void createGetGenericType(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getGenericType\");\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+\n+        // Put the member generic type in the map\n+        gizmoMemberAccessorNameToGenericType.put(gizmoMemberAccessorName,\n+                member.getType());\n+\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+\n+        // Use getGenericTypeFor to receive the generic type that\n+        // was put in the map\n+        ResultHandle out = methodCreator.invokeStaticMethod(\n+                MethodDescriptor.ofMethod(GizmoMemberAccessorImplementor.class,\n+                        \"getGenericTypeFor\",\n+                        Type.class,\n+                        String.class),\n+                gizmoMemberAccessorNameResult);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field\n+     * Object executeGetter(Object bean) {\n+     * return ((DeclaringClass) bean).field;\n+     * }\n+     *\n+     * // for a method\n+     * Object executeGetter(Object bean) {\n+     * return ((DeclaringClass) bean).method();\n+     * }\n+     *\n+     * The member MUST be public if not called in Quarkus\n+     * (i.e. we don't delegate to the field getter/setter).\n+     * In Quarkus, we generate simple getter/setter for the\n+     * member if it is private (which get passed to the MemberDescriptor).\n+     */\n+    private static void createExecuteGetter(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"executeGetter\", Object.class);\n+        ResultHandle bean = methodCreator.getMethodParam(0);\n+\n+        member.whenIsMethod(method -> {\n+            assertIsGoodMethod(method, annotationClass);\n+            ResultHandle out;\n+            if (member.isInterfaceMethod()) {\n+                out = methodCreator.invokeInterfaceMethod(method, bean);\n+            } else {\n+                out = methodCreator.invokeVirtualMethod(method, bean);\n+            }\n+            methodCreator.returnValue(out);\n+        });\n+\n+        member.whenIsField(field -> {\n+            ResultHandle out = methodCreator.readInstanceField(field, bean);\n+            methodCreator.returnValue(out);\n+        });\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field or a getter method that also have a corresponding setter\n+     * boolean supportSetter() {\n+     * return true;\n+     * }\n+     *\n+     * // for a read method or a getter method without a setter\n+     * boolean supportSetter() {\n+     * return false;\n+     * }\n+     */\n+    private static void createSupportSetter(ClassCreator classCreator, MemberDescriptor member, Class<?> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"supportSetter\");\n+        member.whenIsMethod(method -> {\n+            boolean supportSetter = member.getSetter().isPresent();\n+            ResultHandle out = methodCreator.load(supportSetter);\n+            methodCreator.returnValue(out);\n+        });\n+        member.whenIsField(field -> {\n+            ResultHandle out = methodCreator.load(true);\n+            methodCreator.returnValue(out);\n+        });\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * // for a field\n+     * void executeSetter(Object bean, Object value) {\n+     * return ((DeclaringClass) bean).field = value;\n+     * }\n+     *\n+     * // for a getter method with a corresponding setter\n+     * void executeSetter(Object bean, Object value) {\n+     * return ((DeclaringClass) bean).setValue(value);\n+     * }\n+     *\n+     * // for a read method or a getter method without a setter\n+     * void executeSetter(Object bean, Object value) {\n+     * throw new UnsupportedOperationException(\"Setter not supported\");\n+     * }\n+     */\n+    private static void createExecuteSetter(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"executeSetter\", Object.class,\n+                Object.class);\n+\n+        member.whenIsMethod(method -> {\n+            Optional<MethodDescriptor> setter = member.getSetter();\n+            if (setter.isPresent()) {\n+                ResultHandle bean = methodCreator.getMethodParam(0);\n+                ResultHandle value = methodCreator.getMethodParam(1);\n+                if (member.isInterfaceMethod()) {\n+                    methodCreator.invokeInterfaceMethod(setter.get(), bean, value);\n+                } else {\n+                    methodCreator.invokeVirtualMethod(setter.get(), bean, value);\n+                }\n+                methodCreator.returnValue(null);\n+            } else {\n+                methodCreator.throwException(UnsupportedOperationException.class, \"Setter not supported\");\n+            }\n+        });\n+\n+        member.whenIsField(field -> {\n+            ResultHandle bean = methodCreator.getMethodParam(0);\n+            ResultHandle value = methodCreator.getMethodParam(1);\n+            methodCreator.writeInstanceField(field, bean, value);\n+            methodCreator.returnValue(null);\n+        });\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * String getSpeedNote() {\n+     * return \"Fast access with generated bytecode\";\n+     * }\n+     */\n+    private static void createGetSpeedNote(ClassCreator classCreator, MemberDescriptor member, Class<?> annotationClass) {\n+        MethodCreator methodCreator = getMethodCreator(classCreator, \"getSpeedNote\");\n+        ResultHandle out = methodCreator.load(\"Fast access with generated bytecode\");\n+        methodCreator.returnValue(out);\n+    }\n+\n+    // ************************************************************************\n+    // AnnotatedElement methods\n+    // ************************************************************************\n+    private static MethodCreator getAnnotationMethodCreator(ClassCreator classCreator, String methodName,\n+            Class<?>... parameters) {\n+        return classCreator.getMethodCreator(getAnnotationMethod(methodName, parameters));\n+    }\n+\n+    private static MethodDescriptor getAnnotationMethod(String methodName, Class<?>... parameters) {\n+        try {\n+            return MethodDescriptor.ofMethod(AnnotatedElement.class.getMethod(methodName, parameters));\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalStateException(\"No such method: \" + methodName, e);\n+        }\n+    }\n+\n+    private static void createAnnotatedElement(ClassCreator classCreator, MemberDescriptor member) {\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+        AnnotatedElement annotatedElement = member.getAnnotatedElement();\n+        gizmoMemberAccessorNameToAnnotatedElement.put(gizmoMemberAccessorName, annotatedElement);\n+    }\n+\n+    private static MethodDescriptor getAnnotatedElementGetter() {\n+        return MethodDescriptor.ofMethod(GizmoMemberAccessorImplementor.class, \"getAnnotatedElementFor\",\n+                AnnotatedElement.class, String.class);\n+    }\n+\n+    // These methods all delegate to an AnnotatedElement we store in\n+    // gizmoMemberAccessorNameToAnnotatedElement\n+\n+    // getAnnotatedElementGetter() simply returns the method descriptor for getAnnotatedElementFor\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * boolean isAnnotationPresent(Class annotationClass) {\n+     * AnnotatedElement annotatedElement = GizmoMemberAccessorImplementor\n+     * .getAnnotatedElementFor(this.getClass().getName());\n+     * return annotatedElement.isAnnotationPresent(annotationClass);\n+     * }\n+     */\n+    private static void createIsAnnotationPresent(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getAnnotationMethodCreator(classCreator, \"isAnnotationPresent\",\n+                Class.class);\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+        ResultHandle annotatedElement = methodCreator.invokeStaticMethod(getAnnotatedElementGetter(),\n+                gizmoMemberAccessorNameResult);\n+        ResultHandle query = methodCreator.getMethodParam(0);\n+        ResultHandle out = methodCreator.invokeInterfaceMethod(getAnnotationMethod(\"isAnnotationPresent\", Class.class),\n+                annotatedElement, query);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Object getAnnotation(Class annotationClass) {\n+     * AnnotatedElement annotatedElement = GizmoMemberAccessorImplementor\n+     * .getAnnotatedElementFor(this.getClass().getName());\n+     * return annotatedElement.getAnnotation(annotationClass);\n+     * }\n+     */\n+    private static void createGetAnnotation(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getAnnotationMethodCreator(classCreator, \"getAnnotation\",\n+                Class.class);\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+        ResultHandle annotatedElement = methodCreator.invokeStaticMethod(getAnnotatedElementGetter(),\n+                gizmoMemberAccessorNameResult);\n+        ResultHandle query = methodCreator.getMethodParam(0);\n+        ResultHandle out = methodCreator.invokeInterfaceMethod(getAnnotationMethod(\"getAnnotation\", Class.class),\n+                annotatedElement, query);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Object[] getAnnotations() {\n+     * AnnotatedElement annotatedElement = GizmoMemberAccessorImplementor\n+     * .getAnnotatedElementFor(this.getClass().getName());\n+     * return annotatedElement.getAnnotations();\n+     * }\n+     */\n+    private static void createGetAnnotations(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getAnnotationMethodCreator(classCreator, \"getAnnotations\");\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+        ResultHandle annotatedElement = methodCreator.invokeStaticMethod(getAnnotatedElementGetter(),\n+                gizmoMemberAccessorNameResult);\n+        ResultHandle out = methodCreator.invokeInterfaceMethod(getAnnotationMethod(\"getAnnotations\"),\n+                annotatedElement);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Generates the following code:\n+     *\n+     * Object[] getDeclaredAnnotations() {\n+     * AnnotatedElement annotatedElement = GizmoMemberAccessorImplementor\n+     * .getAnnotatedElementFor(this.getClass().getName());\n+     * return annotatedElement.getDeclaredAnnotations();\n+     * }\n+     */\n+    private static void createGetDeclaredAnnotations(ClassCreator classCreator, MemberDescriptor member,\n+            Class<? extends Annotation> annotationClass) {\n+        MethodCreator methodCreator = getAnnotationMethodCreator(classCreator, \"getDeclaredAnnotations\");\n+        String gizmoMemberAccessorName = classCreator.getClassName();\n+        ResultHandle gizmoMemberAccessorNameResult = methodCreator.load(gizmoMemberAccessorName);\n+        ResultHandle annotatedElement = methodCreator.invokeStaticMethod(getAnnotatedElementGetter(),\n+                gizmoMemberAccessorNameResult);\n+        ResultHandle out = methodCreator.invokeInterfaceMethod(getAnnotationMethod(\"getDeclaredAnnotations\"),\n+                annotatedElement);\n+        methodCreator.returnValue(out);\n+    }\n+\n+    /**\n+     * Describe and provide simplified/unified access for a Member\n+     */\n+    public static class MemberDescriptor {\n+\n+        /**\n+         * The name of a member. For a field, it the field name.\n+         * For a method, if it is a getter, the method name without \"get\"/\"is\"\n+         * and the first letter lowercase; otherwise, the method name.\n+         */\n+        String name;\n+\n+        /**\n+         * If the member is a field, the FieldDescriptor of the member\n+         * If the member is a method, the MethodDescriptor of the member\n+         */\n+        Object memberDescriptor;\n+\n+        /**\n+         * If the member is a normal member, the class that declared it\n+         * If the member is from Jandex, the Jandex ClassInfo of the class that declared it\n+         */\n+        Object declaringClass;\n+\n+        /**\n+         * The member as an AnnotatedElement\n+         */\n+        AnnotatedElement annotatedElement;\n+\n+        /**\n+         * The MethodDescriptor of the corresponding setter. Is empty if not present.\n+         */\n+        Optional<MethodDescriptor> setter;\n+\n+        /**\n+         * The generic type of the member\n+         */\n+        Type type;\n+\n+        public MemberDescriptor(Member member) {\n+            declaringClass = member.getDeclaringClass();\n+            if (member instanceof Field) {\n+                memberDescriptor = FieldDescriptor.of((Field) member);\n+                name = member.getName();\n+                annotatedElement = (Field) member;\n+                type = ((Field) member).getGenericType();\n+                setter = lookupSetter();\n+            } else if (member instanceof Method) {\n+                memberDescriptor = MethodDescriptor.ofMethod((Method) member);\n+                annotatedElement = (Method) member;\n+                if (ReflectionHelper.isGetterMethod((Method) member)) {\n+                    name = ReflectionHelper.getGetterPropertyName(member);\n+                } else {\n+                    name = member.getName();\n+                }\n+                type = ((Method) member).getGenericReturnType();\n+                setter = lookupSetter();\n+            } else {\n+                throw new IllegalArgumentException(member + \" is not a Method or a Field.\");\n+            }\n+        }\n+\n+        // For Quarkus\n+        // (Cannot move to Quarkus module; get runtime\n+        //  exception since objects created here use classes\n+        //  from another ClassLoader).\n+        public MemberDescriptor(FieldInfo fieldInfo, IndexView indexView) {", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUyNjE2Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552526163", "bodyText": "Please add a message explaining what is the consequence of the CNFE here.", "author": "rsynek", "createdAt": "2021-01-06T11:43:20Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorEntityEnhancer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessorImplementor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorEntityEnhancer {\n+\n+    private static Set<FieldInfo> visitedFields = new HashSet<>();\n+    private static Set<MethodInfo> visitedMethods = new HashSet<>();\n+\n+    public static void addVirtualFieldGetter(ClassInfo classInfo, FieldInfo fieldInfo,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedFields.contains(fieldInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerFieldEnhancingClassVisitor(classInfo, classVisitor,\n+                            fieldInfo)));\n+            visitedFields.add(fieldInfo);\n+        }\n+    }\n+\n+    public static Optional<MethodDescriptor> addVirtualMethodGetter(ClassInfo classInfo, MethodInfo methodInfo, String name,\n+            Optional<MethodDescriptor> setterDescriptor,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedMethods.contains(methodInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerMethodEnhancingClassVisitor(classInfo, classVisitor, methodInfo,\n+                            name, setterDescriptor)));\n+            visitedMethods.add(methodInfo);\n+        }\n+        return setterDescriptor.map(md -> MethodDescriptor\n+                .ofMethod(classInfo.name().toString(), getVirtualSetterName(name),\n+                        md.getReturnType(), md.getParameterTypes()));\n+    }\n+\n+    public static String getVirtualGetterName(String name) {\n+        return \"$get$optaplanner$__\" + name;\n+    }\n+\n+    public static String getVirtualSetterName(String name) {\n+        return \"$set$optaplanner$__\" + name;\n+    }\n+\n+    /**\n+     * Generates the bytecode for the member accessor for the specified field.\n+     * Additionally enhances the class that declares the field with public simple\n+     * getters/setters methods for the field if the field is private.\n+     *\n+     * @param annotationInstance The annotations on the field\n+     * @param indexView The index view (needed to get default values of annotations)\n+     * @param classOutput Where to output the bytecode\n+     * @param classInfo The declaring class for the field\n+     * @param fieldInfo The field to generate the MemberAccessor for\n+     * @param transformers BuildProducer of BytecodeTransformers\n+     */\n+    public static void generateFieldAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            FieldInfo fieldInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + fieldInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessorImplementor.MemberDescriptor member;\n+        if (Modifier.isPublic(fieldInfo.flags())) {\n+            member = new GizmoMemberAccessorImplementor.MemberDescriptor(fieldInfo, indexView);\n+        } else {\n+            addVirtualFieldGetter(classInfo, fieldInfo, transformers);\n+            String methodName = getVirtualGetterName(fieldInfo.name());\n+            MethodDescriptor setterDescriptor = MethodDescriptor.ofMethod(fieldInfo.declaringClass().name().toString(),\n+                    getVirtualSetterName(fieldInfo.name()),\n+                    \"void\",\n+                    fieldInfo.type().name().toString());\n+            MethodInfo methodInfo = MethodInfo.create(classInfo, methodName, new org.jboss.jandex.Type[] {}, fieldInfo.type(),\n+                    (short) Modifier.PUBLIC);\n+            member = new GizmoMemberAccessorImplementor.MemberDescriptor(fieldInfo, methodInfo, Optional.of(setterDescriptor),\n+                    indexView,\n+                    fieldInfo.name());\n+        }\n+        try {\n+            GizmoMemberAccessorImplementor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));\n+            classCreator.close();\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private static String getMemberName(MethodInfo methodInfo) {\n+        if (methodInfo.name().startsWith(\"get\")) { // Case 1: Getter method\n+            return methodInfo.name().substring(3, 4).toLowerCase(Locale.ROOT) + methodInfo.name().substring(4);\n+        } else if (methodInfo.name().startsWith(\"is\")) { // Case 2: Getter method for boolean\n+            return methodInfo.name().substring(2, 3).toLowerCase(Locale.ROOT) + methodInfo.name().substring(3);\n+        } else { // Case 3: Read method\n+            return methodInfo.name();\n+        }\n+    }\n+\n+    private static Optional<MethodDescriptor> getSetterDescriptor(ClassInfo classInfo, MethodInfo methodInfo, String name) {\n+        if (methodInfo.name().startsWith(\"get\") || methodInfo.name().startsWith(\"is\")) {\n+            // ex: for methodInfo = Integer getValue(), name = value,\n+            // return void setValue(Integer value)\n+            // i.e. capitalize first letter of name, and take a parameter\n+            // of the getter return type.\n+            return Optional.ofNullable(classInfo.method(\"set\" + name.substring(0, 1)\n+                    .toUpperCase(Locale.ROOT) +\n+                    name.substring(1),\n+                    methodInfo.returnType())).map(MethodDescriptor::of);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Generates the bytecode for the member accessor for the specified method.\n+     * Additionally enhances the class that declares the method with public simple\n+     * read/(optionally write if getter method and setter present) methods for the method\n+     * if the method is private.\n+     *\n+     * @param annotationInstance The annotations on the field\n+     * @param indexView The index view (needed to get default values of annotations)\n+     * @param classOutput Where to output the bytecode\n+     * @param classInfo The declaring class for the field\n+     * @param methodInfo The method to generate the MemberAccessor for\n+     * @param transformers BuildProducer of BytecodeTransformers\n+     */\n+    public static void generateMethodAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            MethodInfo methodInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + methodInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessorImplementor.MemberDescriptor member;\n+        String name = getMemberName(methodInfo);\n+        Optional<MethodDescriptor> setterDescriptor = getSetterDescriptor(classInfo, methodInfo, name);\n+\n+        if (Modifier.isPublic(methodInfo.flags())) {\n+            member = new GizmoMemberAccessorImplementor.MemberDescriptor(methodInfo, methodInfo, setterDescriptor, indexView,\n+                    name);\n+        } else {\n+            setterDescriptor = addVirtualMethodGetter(classInfo, methodInfo, name, setterDescriptor, transformers);\n+            String methodName = getVirtualGetterName(name);\n+            MethodInfo newMethodInfo = classInfo.method(methodName);\n+            member = new GizmoMemberAccessorImplementor.MemberDescriptor(methodInfo, newMethodInfo, setterDescriptor, indexView,\n+                    name);\n+        }\n+        try {\n+            GizmoMemberAccessorImplementor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));\n+            classCreator.close();\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e);", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUzMTc0MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552531741", "bodyText": "If I understand it correctly, we have a class with a field and an annotation on top of it like follows:\nclass SomeClass {\n  @SomeAnnotation\n  SomeMember member;\n}\n\nHere we load the annotation using the classloader of this class, but when we load the SomeClass here, we use the Thread.currentThread().getContextClassLoader() ?", "author": "rsynek", "createdAt": "2021-01-06T11:55:35Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/deployment/src/main/java/org/optaplanner/quarkus/deployment/GizmoMemberAccessorEntityEnhancer.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.optaplanner.quarkus.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IRETURN;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.FieldInfo;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Type;\n+import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n+import org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessorImplementor;\n+\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodDescriptor;\n+\n+public class GizmoMemberAccessorEntityEnhancer {\n+\n+    private static Set<FieldInfo> visitedFields = new HashSet<>();\n+    private static Set<MethodInfo> visitedMethods = new HashSet<>();\n+\n+    public static void addVirtualFieldGetter(ClassInfo classInfo, FieldInfo fieldInfo,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedFields.contains(fieldInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerFieldEnhancingClassVisitor(classInfo, classVisitor,\n+                            fieldInfo)));\n+            visitedFields.add(fieldInfo);\n+        }\n+    }\n+\n+    public static Optional<MethodDescriptor> addVirtualMethodGetter(ClassInfo classInfo, MethodInfo methodInfo, String name,\n+            Optional<MethodDescriptor> setterDescriptor,\n+            BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        if (!visitedMethods.contains(methodInfo)) {\n+            transformers.produce(new BytecodeTransformerBuildItem(classInfo.name().toString(),\n+                    (className, classVisitor) -> new OptaPlannerMethodEnhancingClassVisitor(classInfo, classVisitor, methodInfo,\n+                            name, setterDescriptor)));\n+            visitedMethods.add(methodInfo);\n+        }\n+        return setterDescriptor.map(md -> MethodDescriptor\n+                .ofMethod(classInfo.name().toString(), getVirtualSetterName(name),\n+                        md.getReturnType(), md.getParameterTypes()));\n+    }\n+\n+    public static String getVirtualGetterName(String name) {\n+        return \"$get$optaplanner$__\" + name;\n+    }\n+\n+    public static String getVirtualSetterName(String name) {\n+        return \"$set$optaplanner$__\" + name;\n+    }\n+\n+    /**\n+     * Generates the bytecode for the member accessor for the specified field.\n+     * Additionally enhances the class that declares the field with public simple\n+     * getters/setters methods for the field if the field is private.\n+     *\n+     * @param annotationInstance The annotations on the field\n+     * @param indexView The index view (needed to get default values of annotations)\n+     * @param classOutput Where to output the bytecode\n+     * @param classInfo The declaring class for the field\n+     * @param fieldInfo The field to generate the MemberAccessor for\n+     * @param transformers BuildProducer of BytecodeTransformers\n+     */\n+    public static void generateFieldAccessor(AnnotationInstance annotationInstance, IndexView indexView,\n+            ClassOutput classOutput, ClassInfo classInfo,\n+            FieldInfo fieldInfo, BuildProducer<BytecodeTransformerBuildItem> transformers) {\n+        String generatedClassName = classInfo.name().prefix().toString() + \".$optaplanner$__\"\n+                + classInfo.name().withoutPackagePrefix() + \"$__\" + fieldInfo.name();\n+        ClassCreator classCreator = ClassCreator\n+                .builder()\n+                .className(generatedClassName)\n+                .interfaces(MemberAccessor.class)\n+                .classOutput(classOutput)\n+                .build();\n+\n+        GizmoMemberAccessorImplementor.MemberDescriptor member;\n+        if (Modifier.isPublic(fieldInfo.flags())) {\n+            member = new GizmoMemberAccessorImplementor.MemberDescriptor(fieldInfo, indexView);\n+        } else {\n+            addVirtualFieldGetter(classInfo, fieldInfo, transformers);\n+            String methodName = getVirtualGetterName(fieldInfo.name());\n+            MethodDescriptor setterDescriptor = MethodDescriptor.ofMethod(fieldInfo.declaringClass().name().toString(),\n+                    getVirtualSetterName(fieldInfo.name()),\n+                    \"void\",\n+                    fieldInfo.type().name().toString());\n+            MethodInfo methodInfo = MethodInfo.create(classInfo, methodName, new org.jboss.jandex.Type[] {}, fieldInfo.type(),\n+                    (short) Modifier.PUBLIC);\n+            member = new GizmoMemberAccessorImplementor.MemberDescriptor(fieldInfo, methodInfo, Optional.of(setterDescriptor),\n+                    indexView,\n+                    fieldInfo.name());\n+        }\n+        try {\n+            GizmoMemberAccessorImplementor.defineAccessorFor(classCreator, member,\n+                    (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString()));", "originalCommit": "da26442d15e9b9a5c576dee926017ce74dd7a4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjczNTg3OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r552735878", "bodyText": "Probably should change that location to Thread.currentThread().getContextClassLoader(); thanks!", "author": "Christopher-Chianelli", "createdAt": "2021-01-06T15:52:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUzMTc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkyOTAzMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r554929031", "bodyText": "Dependencies are also in alphabetical order according to groupId, artifactId.", "author": "ge0ffrey", "createdAt": "2021-01-11T09:53:58Z", "path": "build/optaplanner-build-parent/pom.xml", "diffHunk": "@@ -159,6 +161,16 @@\n <!--          </exclusion>-->\n         </exclusions>\n       </dependency>\n+      <dependency>\n+        <groupId>io.quarkus.gizmo</groupId>", "originalCommit": "c02661847e2b207da15b06bcda21a26001df8995", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMTExMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r554931111", "bodyText": "We like the order of the \"with\" method (just like the getter/setters) to be in the order of the fields.\nso withDomainAccesType() method after withEntityClassList() and also after withEntityClasses().\nMotivation: It's just easier to see if a get/set/with method is lacking. Less chaotic.", "author": "ge0ffrey", "createdAt": "2021-01-11T09:57:24Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/SolverConfig.java", "diffHunk": "@@ -445,6 +456,11 @@ public SolverConfig withSolutionClass(Class<?> solutionClass) {\n         return this;\n     }\n \n+    public SolverConfig withDomainAccessType(DomainAccessType domainAccessType) {", "originalCommit": "c02661847e2b207da15b06bcda21a26001df8995", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMTQxOA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r554931418", "bodyText": "We like the order of the \"get/set\" method combo to be in the order of the fields.\nso both after setEntityClassList().\nMotivation: It's just easier to see if a get/set/with method is lacking. Less chaotic.", "author": "ge0ffrey", "createdAt": "2021-01-11T09:57:51Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/SolverConfig.java", "diffHunk": "@@ -364,6 +367,14 @@ public void setSolutionClass(Class<?> solutionClass) {\n         this.solutionClass = solutionClass;\n     }\n \n+    public DomainAccessType getDomainAccessType() {\n+        return domainAccessType;\n+    }\n+\n+    public void setDomainAccessType(DomainAccessType domainAccessType) {\n+        this.domainAccessType = domainAccessType;\n+    }", "originalCommit": "c02661847e2b207da15b06bcda21a26001df8995", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk0MDY5Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r554940692", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * to \"REFLECTION\". To use \"GIZMO\", io.quarkus.gizmo:gizmo\n          \n          \n            \n                 * to {@link DomainAccessType#REFLECTION}. To use {@link DomainAccessType#GIZMO}, io.quarkus.gizmo:gizmo", "author": "ge0ffrey", "createdAt": "2021-01-11T10:14:14Z", "path": "optaplanner-spring-integration/optaplanner-spring-boot-autoconfigure/src/main/java/org/optaplanner/spring/boot/autoconfigure/SolverProperties.java", "diffHunk": "@@ -26,6 +27,15 @@\n      * Defaults to \"REPRODUCIBLE\".\n      */\n     private EnvironmentMode environmentMode;\n+\n+    /**\n+     * Determines how Domain Accessors are created. Defaults\n+     * to \"REFLECTION\". To use \"GIZMO\", io.quarkus.gizmo:gizmo", "originalCommit": "c02661847e2b207da15b06bcda21a26001df8995", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk1MzcyMg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r554953722", "bodyText": "Very important:\n\nFail fast with a clear error message when they use domainAccessType=GIZMO without gizmo in the classpath.\nA `Class.forName() based on a String after the if statement here probably does the trick. Make sure to pick a class to check for that is very very unlikely to disappear in a future Gizmo release.\n\nSuggestion for error message: \"When using the domainAccessType (\" + domainAccessType  + \") the classpath or modulepath must contain io.quarkus.gizmo:gizmo.\\nMaybe add a dependency to io.quarkus.gizmo:gizmo.\");\nHere's what I get on spring-school-timetabling as-is with optaplanner.solver.domainAccessType=GIZMO in application.properties.\nCaused by: java.lang.NoClassDefFoundError: io/quarkus/gizmo/ClassOutput\n        at org.optaplanner.core.impl.domain.common.accessor.gizmo.GizmoMemberAccessorImplementor.createAccessorFor(GizmoMemberAccessorImplementor.java:163)\n        at org.optaplanner.core.impl.domain.common.accessor.MemberAccessorFactory.buildMemberAccessor(MemberAccessorFactory.java:40)\n        at org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor.processPlanningEntityPropertyAnnotation(SolutionDescriptor.java:472)", "author": "ge0ffrey", "createdAt": "2021-01-11T10:36:33Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/MemberAccessorFactory.java", "diffHunk": "@@ -32,7 +34,12 @@\n             SolverFactory.class.getSimpleName() + \".create...() method call.\";\n \n     public static MemberAccessor buildMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n-            Class<? extends Annotation> annotationClass) {\n+            Class<? extends Annotation> annotationClass,\n+            DomainAccessType domainAccessType) {\n+        if (domainAccessType == DomainAccessType.GIZMO) {\n+            return GizmoMemberAccessorImplementor.createAccessorFor(member, annotationClass);", "originalCommit": "c02661847e2b207da15b06bcda21a26001df8995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk1NjY4OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r554956688", "bodyText": "Similar, if they do have gizmo in there, but have a non-public member, the exception message should be clear state which member isn't on a public member.\n\nHere's what I get if I do that on the spring boot quickstart:\n        Suppressed: java.lang.NullPointerException: null\n                at org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirector.close(ConstraintStreamScoreDirector.java:105)\n                at org.optaplanner.core.impl.score.DefaultScoreManager.updateScore(DefaultScoreManager.java:48)\n                ... 51 common frames omitted\n\nHmm, wait a minute. In that stacktrace the real error got eaten by ConstraintStreamScoreDirector. @triceo .\nSo I am not sure the error message is already clean. Let me first fix that eating of the error message upstream.", "author": "ge0ffrey", "createdAt": "2021-01-11T10:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk1MzcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk2MDkxNg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r554960916", "bodyText": "(important)\nThis is the exception that got eaten. Btw, it appears at runtime when going to localhost, not at bootstrap time when starting the server (nor at build time).\njava.lang.IllegalAccessError: class com.example.schooltimetabling.domain.$optaplanner$__TimeTable$__lessonList tried to access private field com.example.schooltimetabling.domain.TimeTable.lessonList (com.example.schooltimetabling.domain.$optaplanner$__TimeTable$__lessonList is in unnamed module of loader 'OptaPlanner Gizmo MemberAccessor ClassLoader' @4a18e0f1; com.example.schooltimetabling.domain.TimeTable is in unnamed module of loader 'app')\n\tat com.example.schooltimetabling.domain.$optaplanner$__TimeTable$__lessonList.executeGetter($optaplanner$__TimeTable$__lessonList.zig:107)\n\tat org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor.extractMemberCollectionOrArray(SolutionDescriptor.java:1147)\n\nThis too should fail fast during bootstrap when the descriptors are created with a clear error message.", "author": "ge0ffrey", "createdAt": "2021-01-11T10:49:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk1MzcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA5MTExNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r555091117", "bodyText": "The exception isn't eaten btw. The close exception is a \"supressed exception\", but that real exception is right above in the stacktrace. So no upstream issue.", "author": "ge0ffrey", "createdAt": "2021-01-11T14:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk1MzcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMwODUzOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r555308539", "bodyText": "Done; thrown during bytecode generation (which is when the solverfactory is created)", "author": "Christopher-Chianelli", "createdAt": "2021-01-11T20:10:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk1MzcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTg1NjUxMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r555856511", "bodyText": "Javadoc proposal: Uses Gizmo generated bytecode to access members (field and method) of the domain for performance, instead of reflection. When used without Quarkus, the planning annotations must be on public members and Gizmo must be added on the classpath or modulepath.", "author": "ge0ffrey", "createdAt": "2021-01-12T15:25:48Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/solver/DomainAccessType.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.config.solver;\n+\n+public enum DomainAccessType {\n+    REFLECTION,\n+    GIZMO", "originalCommit": "1e30fa668fd548870cc1432d969a72f28504f5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTg3OTU2MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r555879561", "bodyText": "Add // TODO This will break Quarkus once we don't open up the domain hierarchy for reflection any more", "author": "ge0ffrey", "createdAt": "2021-01-12T15:53:36Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/lookup/ClassAndPlanningIdComparator.java", "diffHunk": "@@ -21,18 +21,25 @@\n import java.util.Map;\n \n import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.config.solver.DomainAccessType;\n import org.optaplanner.core.config.util.ConfigUtils;\n import org.optaplanner.core.impl.domain.common.accessor.MemberAccessor;\n \n public class ClassAndPlanningIdComparator implements Comparator<Object> {\n \n     private boolean failFastIfNoPlanningId;\n+    private DomainAccessType domainAccessType;\n \n     public ClassAndPlanningIdComparator() {\n-        this(true);\n+        this(DomainAccessType.REFLECTION, true);", "originalCommit": "1e30fa668fd548870cc1432d969a72f28504f5c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e18200a0144b64c3d5dbd7555049abd23f6d090b", "url": "https://github.com/kiegroup/optaplanner/commit/e18200a0144b64c3d5dbd7555049abd23f6d090b", "message": "Change DomainAccessType package, add Javadocs + docs, fix native factory", "committedDate": "2021-01-12T18:51:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjAzMzM0Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r556033346", "bodyText": "So, I was thinking... why does the user need to make this choice?\n\nWe can detect if Gizmo is on the classpath/modulepath. In that case, we can just enable it.\nLikewise, we can detect if the user has annotations on non-public members.\n\nTherefore - why not simply use Gizmo when present and possible, and use reflection for the rest?\nI'm sure I'm missing some consideration, but from where I'm standing, it seems like we could just make the best choice for the user, instead of forcing them to think about this.", "author": "triceo", "createdAt": "2021-01-12T19:41:44Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/domain/common/DomainAccessType.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.api.domain.common;\n+\n+/**\n+ * Determines how members (fields and methods) of\n+ * the domain are accessed.\n+ */\n+public enum DomainAccessType {\n+    /**\n+     * Use reflection to read the member. Always work, but slow.\n+     */\n+    REFLECTION,\n+\n+    /**\n+     * Uses Gizmo generated bytecode to access members (field and method)\n+     * of the domain for performance, instead of reflection. When used without Quarkus,\n+     * the planning annotations must be on public members and Gizmo must be added\n+     * on the classpath or modulepath.\n+     */\n+    GIZMO\n+}", "originalCommit": "e18200a0144b64c3d5dbd7555049abd23f6d090b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA0MDQ5OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r556040499", "bodyText": "The main issue is unexpected performance changes; changing a member from public to private or vice versa could cause quite a change to performance and the user wouldn't understand why. Both of the above things are checkable and can be done on a per-member basis (which mean you could have a mix of Gizmo member accessors and Reflection member accessors). Removing the choice would fix the one remaining Reflection instance done when GIZMO is used (in the PlanningIdComparator, which is used in ConstraintMatch).", "author": "Christopher-Chianelli", "createdAt": "2021-01-12T19:51:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjAzMzM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxMDU2OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r562510569", "bodyText": "Lukas, yes for predictability. There might be some other reasons.\nThe logic we came up with Radovan during the meeting is in this document (although a cat won't find its kittens in there):\nhttps://docs.google.com/document/d/1igSwaVuZA5_5ht-3nHmND6GBNvUQpDwvIoQMzshB7vg/edit", "author": "ge0ffrey", "createdAt": "2021-01-22T09:46:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjAzMzM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxMjE1MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r562512150", "bodyText": "Basically, if they explicitly ask for GIZMO or REFLECTION, that is what they get (or an error if it's not possible).\nOtherwise, they get gizmo on quarkus and reflection otherwise. Simple & predictable.\nChanging the behavior depending on a dependency on the classpath is something I'd like to avoid, especially with transitive dependencies. Image that a user uses optaplannercore and JasperReports and 5months later they upgrade to a new version of JasperReports that suddenly has a gizmo dependency.\nQuarkus doesn't count because that's a build/platform difference, not just another jar on the classpath.", "author": "ge0ffrey", "createdAt": "2021-01-22T09:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjAzMzM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjAzNDEyNA==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r556034124", "bodyText": "I see we actually detect if Gizmo is present. So the only thing to make my previous comment happen is the detection of annotations on private fields.", "author": "triceo", "createdAt": "2021-01-12T19:42:52Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/MemberAccessorFactory.java", "diffHunk": "@@ -32,7 +34,22 @@\n             SolverFactory.class.getSimpleName() + \".create...() method call.\";\n \n     public static MemberAccessor buildMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n-            Class<? extends Annotation> annotationClass) {\n+            Class<? extends Annotation> annotationClass,\n+            DomainAccessType domainAccessType) {\n+        if (domainAccessType == DomainAccessType.GIZMO) {\n+            try {\n+                // Check if Gizmo on the classpath by verifying we can access one of its classes\n+                Class.forName(\"io.quarkus.gizmo.ClassCreator\", false,\n+                        Thread.currentThread().getContextClassLoader());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(\"When using the domainAccessType (\" +\n+                        domainAccessType +\n+                        \") the classpath or modulepath must contain io.quarkus.gizmo:gizmo.\\n\" +\n+                        \"Maybe add a dependency to io.quarkus.gizmo:gizmo.\");\n+            }", "originalCommit": "e18200a0144b64c3d5dbd7555049abd23f6d090b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY0OTEzOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r556649139", "bodyText": "I suggest these be extracted to separate top-level classes. 700-line long classes that consist pretty much of other classes should IMO be avoided.", "author": "triceo", "createdAt": "2021-01-13T16:14:58Z", "path": "optaplanner-quarkus-integration/optaplanner-quarkus/runtime/src/main/java/org/optaplanner/quarkus/gizmo/GizmoAnnotationWrappers.java", "diffHunk": "@@ -0,0 +1,726 @@\n+package org.optaplanner.quarkus.gizmo;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.autodiscover.AutoDiscoverMemberType;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfiguration;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintConfigurationProvider;\n+import org.optaplanner.core.api.domain.constraintweight.ConstraintWeight;\n+import org.optaplanner.core.api.domain.entity.PinningFilter;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.entity.PlanningPin;\n+import org.optaplanner.core.api.domain.lookup.LookUpStrategyType;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningEntityProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.ProblemFactProperty;\n+import org.optaplanner.core.api.domain.solution.cloner.SolutionCloner;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.domain.variable.AnchorShadowVariable;\n+import org.optaplanner.core.api.domain.variable.CustomShadowVariable;\n+import org.optaplanner.core.api.domain.variable.InverseRelationShadowVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableGraphType;\n+import org.optaplanner.core.api.domain.variable.PlanningVariableReference;\n+import org.optaplanner.core.api.domain.variable.VariableListener;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionSorterWeightFactory;\n+import org.optaplanner.core.impl.score.definition.ScoreDefinition;\n+\n+/**\n+ * Contains wrappers for Annotations so they may be\n+ * recorded in bytecode. The annotation's values are stored\n+ * in the wrapper's map.\n+ *\n+ * When bytecode is being recorded in Quarkus (i.e. an\n+ * object is passed to a recorder), the following restrictions apply:\n+ *\n+ * - Classes without public getters/setters for all fields,\n+ * a constructor annotated with @RecordableConstructor with parameter names that match field names or a\n+ * registered substitution cannot be recorded. (https://quarkus.io/guides/writing-extensions#bytecode-recording)\n+ *\n+ * Annotations and Generic Types do not satisfy the above criteria, so they cannot be\n+ * recorded directly at build time. However, we don't want to use reflection at runtime,\n+ * and we want to build the GizmoMemberAccessors at build time. So we need to create\n+ * wrappers for the annotations and types so they can be recorded.\n+ */\n+public class GizmoAnnotationWrappers {\n+\n+    enum AllOptaPlannerAnnotationEnum {\n+        PLANNING_SOLUTION(PlanningSolution.class, PlanningSolutionWrapper::new),\n+        PLANNING_SCORE(PlanningScore.class, PlanningScoreWrapper::new),\n+        PLANNING_ENTITY_COLLECTION_PROPERTY(PlanningEntityCollectionProperty.class,\n+                PlanningEntityCollectionPropertyWrapper::new),\n+        PLANNING_ENTITY_PROPERTY(PlanningEntityProperty.class,\n+                PlanningEntityPropertyWrapper::new),\n+        PROBLEM_FACT_COLLECTION_PROPERTY(ProblemFactCollectionProperty.class,\n+                ProblemFactCollectionPropertyWrapper::new),\n+        PROBLEM_FACT_PROPERTY(ProblemFactProperty.class, ProblemFactPropertyWrapper::new),\n+        CONSTRAINT_CONFIGURATION(ConstraintConfiguration.class,\n+                ConstraintConfigurationWrapper::new),\n+        CONSTRAINT_CONFIGURATION_PROVIDER(ConstraintConfigurationProvider.class,\n+                ConstraintConfigurationProviderWrapper::new),\n+        CONSTRAINT_WEIGHT(ConstraintWeight.class, ConstraintWeightWrapper::new),\n+        PLANNING_ENTITY(PlanningEntity.class, PlanningEntityWrapper::new),\n+        PLANNING_PIN(PlanningPin.class, PlanningPinWrapper::new),\n+        PLANNING_ID(PlanningId.class, PlanningIdWrapper::new),\n+        PLANNING_VARIABLE(PlanningVariable.class, PlanningVariableWrapper::new),\n+        PLANNING_VARIABLE_REFERENCE(PlanningVariableReference.class, PlanningVariableReferenceWrapper::new),\n+        VALUE_RANGE_PROVIDER(ValueRangeProvider.class, ValueRangeProviderWrapper::new),\n+        ANCHOR_SHADOW_VARIABLE(AnchorShadowVariable.class, AnchorShadowVariableWrapper::new),\n+        CUSTOM_SHADOW_VARIABLE(CustomShadowVariable.class, CustomShadowVariableWrapper::new),\n+        INVERSE_RELATION_SHADOW_VARIABLE(InverseRelationShadowVariable.class,\n+                InverseRelationShadowVariableWrapper::new);\n+\n+        Class<?> annotationClass;\n+        Function<Map<String, Object>, Annotation> mapper;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        <T extends Annotation> AllOptaPlannerAnnotationEnum(Class<? extends T> annotationClass,\n+                Function<Map<String, Object>, T> mapper) {\n+            this.annotationClass = annotationClass;\n+            this.mapper = (Function<Map<String, Object>, Annotation>) mapper;\n+        }\n+\n+        public Annotation get(Map<String, Object> values) {\n+            return mapper.apply(values);\n+        }\n+\n+        public static Annotation getForClass(Class<? extends Annotation> annotationClass, Map<String, Object> values) {\n+            for (AllOptaPlannerAnnotationEnum annotationType : AllOptaPlannerAnnotationEnum.values()) {\n+                if (annotationClass.equals(annotationType.annotationClass)) {\n+                    return annotationType.get(values);\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Missing case for \" + annotationClass);\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(Class<? extends Annotation> annotationClass) {\n+            return isOptaPlannerAnnotation(annotationClass.getName());\n+        }\n+\n+        public static boolean isOptaPlannerAnnotation(String annotationClass) {\n+            return annotationClass.startsWith(\"org.optaplanner.\");\n+        }\n+    }\n+\n+    public static class AnnotationWrapper implements Supplier<Annotation> {\n+        Class<? extends Annotation> annotationType;\n+        Map<String, Object> annotationValues = new HashMap<String, Object>();\n+        Annotation annotation;\n+\n+        public AnnotationWrapper() {\n+        }\n+\n+        public AnnotationWrapper(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+\n+        public AnnotationWrapper(AnnotationInstance annotationInstance, IndexView indexView) {\n+            try {\n+                annotationType = (Class<? extends Annotation>) Class.forName(annotationInstance.name().toString());\n+            } catch (ClassNotFoundException e) {\n+                throw new IllegalStateException(e);\n+            }\n+            annotationValues = new HashMap<>();\n+            if (AllOptaPlannerAnnotationEnum.isOptaPlannerAnnotation(annotationType)) {\n+                // Annotation is an OptaPlanner annotation (i.e.\n+                // is a subpackage of org.optaplanner)\n+                annotationInstance.valuesWithDefaults(indexView).forEach((value) -> {\n+                    switch (value.kind()) {\n+                        case BYTE:\n+                            annotationValues.put(value.name(),\n+                                    value.asByte());\n+                            break;\n+                        case SHORT:\n+                            annotationValues.put(value.name(),\n+                                    value.asShort());\n+                            break;\n+                        case INTEGER:\n+                            annotationValues.put(value.name(),\n+                                    value.asInt());\n+                            break;\n+                        case CHARACTER:\n+                            annotationValues.put(value.name(),\n+                                    value.asChar());\n+                            break;\n+                        case FLOAT:\n+                            annotationValues.put(value.name(),\n+                                    value.asFloat());\n+                            break;\n+                        case DOUBLE:\n+                            annotationValues.put(value.name(),\n+                                    value.asDouble());\n+                            break;\n+                        case LONG:\n+                            annotationValues.put(value.name(),\n+                                    value.asLong());\n+                            break;\n+                        case BOOLEAN:\n+                            annotationValues.put(value.name(),\n+                                    value.asBoolean());\n+                            break;\n+                        case CLASS:\n+                            annotationValues.put(value.name(),\n+                                    findClass(annotationInstance, value.asClass()));\n+                            break;\n+                        case STRING:\n+                            annotationValues.put(value.name(),\n+                                    value.asString());\n+                            break;\n+                        case ENUM:\n+                            annotationValues.put(value.name(),\n+                                    value.asEnum());\n+                            break;\n+                        case ARRAY:\n+                            switch (value.componentKind()) {\n+                                case BYTE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asByteArray());\n+                                    break;\n+                                case SHORT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asShortArray());\n+                                    break;\n+                                case INTEGER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asIntArray());\n+                                    break;\n+                                case CHARACTER:\n+                                    annotationValues.put(value.name(),\n+                                            value.asCharArray());\n+                                    break;\n+                                case FLOAT:\n+                                    annotationValues.put(value.name(),\n+                                            value.asFloatArray());\n+                                    break;\n+                                case DOUBLE:\n+                                    annotationValues.put(value.name(),\n+                                            value.asDoubleArray());\n+                                    break;\n+                                case LONG:\n+                                    annotationValues.put(value.name(),\n+                                            value.asLongArray());\n+                                    break;\n+                                case BOOLEAN:\n+                                    annotationValues.put(value.name(),\n+                                            value.asBooleanArray());\n+                                    break;\n+                                case CLASS:\n+                                    annotationValues.put(value.name(),\n+                                            Arrays.stream(value.asClassArray())\n+                                                    .map(v -> findClass(annotationInstance, v))\n+                                                    .collect(Collectors.toList()).toArray(new Class[0]));\n+                                    break;\n+                                case STRING:\n+                                    annotationValues.put(value.name(),\n+                                            value.asStringArray());\n+                                    break;\n+                                case ENUM:\n+                                    annotationValues.put(value.name(),\n+                                            value.asEnumArray());\n+                                    break;\n+                                case NESTED:\n+                                    annotationValues.put(value.name(),\n+                                            Arrays.stream(value.asNestedArray())\n+                                                    .map(v -> new AnnotationWrapper(v, indexView).get())\n+                                                    .collect(Collectors.toList())\n+                                                    .toArray(new Annotation[0]));\n+                                    break;\n+                                case UNKNOWN:\n+                                    // Note: If an array is empty, it is unknown, but\n+                                    // Jandex doesn't provide a way to check array length\n+                                    // According to Jandex javadoc:\n+                                    //\n+                                    // A special AnnotationValue.Kind.UNKNOWN kind is used to refer to\n+                                    // components of zero-length arrays, as the underlying type is not known.\n+                                    //\n+                                    // So it safe to use an empty Object array\n+                                    annotationValues.put(value.name(),\n+                                            new Object[] {});\n+                                    break;\n+                                case ARRAY:\n+                                default:\n+                                    throw new IllegalStateException(\"Arrays of \" + value.componentKind() +\n+                                            \" are unsupported in the enum parser.\" +\n+                                            \" This exception was caused by a\" +\n+                                            \" @\" + annotationInstance.name() + \" annotation\" +\n+                                            \" for parameter \" + value.name() + \".\" +\n+                                            \" Maybe put \" + annotationInstance.name() +\n+                                            \" not in a subpackage of org.optaplanner?\");\n+                            }\n+                            break;\n+                        case NESTED:\n+                            annotationValues.put(value.name(),\n+                                    new AnnotationWrapper(value.asNested(), indexView).get());\n+                            break;\n+                        case UNKNOWN:\n+                        default:\n+                            throw new IllegalStateException(value.componentKind() +\n+                                    \" are unsupported in the enum parser.\" +\n+                                    \" This exception was caused by a\" +\n+                                    \" @\" + annotationInstance.name() + \" annotation\" +\n+                                    \" for parameter \" + value.name() + \".\" +\n+                                    \" Maybe put \" + annotationInstance.name() +\n+                                    \" not in a subpackage of org.optaplanner?\");\n+                    }\n+                });\n+            }\n+        }\n+\n+        @Override\n+        public Annotation get() {\n+            if (annotation != null) {\n+                return annotation;\n+            } else {\n+                return AllOptaPlannerAnnotationEnum.getForClass(annotationType, annotationValues);\n+            }\n+        }\n+\n+        public Class<? extends Annotation> getAnnotationType() {\n+            return annotationType;\n+        }\n+\n+        public void setAnnotationType(Class<? extends Annotation> annotationType) {\n+            this.annotationType = annotationType;\n+        }\n+\n+        public Map<String, Object> getAnnotationValues() {\n+            return annotationValues;\n+        }\n+\n+        public void setAnnotationValues(Map<String, Object> annotationValues) {\n+            this.annotationValues = annotationValues;\n+        }\n+\n+        public Annotation getAnnotation() {\n+            return annotation;\n+        }\n+\n+        public void setAnnotation(Annotation annotation) {\n+            this.annotation = annotation;\n+        }\n+    }\n+\n+    private static Class<?> findClass(AnnotationInstance annotationInstance, Type type) {", "originalCommit": "0b2cf2df648d282fcd33413747e18b0527e12bf8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4494972aa90a488e685f7ead6214cd84a0b024ac", "url": "https://github.com/kiegroup/optaplanner/commit/4494972aa90a488e685f7ead6214cd84a0b024ac", "message": "Fixup docs", "committedDate": "2021-01-13T22:38:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzExNDk1Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r557114952", "bodyText": "Sonar doesn't like this, and I agree. Optional method argument is a good sign that you need two methods instead. One without the argument, which could delegate to the one with the argument.", "author": "triceo", "createdAt": "2021-01-14T07:40:39Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/common/accessor/gizmo/GizmoMemberDescriptor.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.impl.domain.common.accessor.gizmo;\n+\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import org.optaplanner.core.impl.domain.common.ReflectionHelper;\n+\n+import io.quarkus.gizmo.BytecodeCreator;\n+import io.quarkus.gizmo.FieldDescriptor;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+/**\n+ * Describe and provide simplified/unified access for a Member\n+ */\n+public class GizmoMemberDescriptor {\n+\n+    /**\n+     * The name of a member. For a field, it the field name.\n+     * For a method, if it is a getter, the method name without \"get\"/\"is\"\n+     * and the first letter lowercase; otherwise, the method name.\n+     */\n+    String name;\n+\n+    /**\n+     * If the member is a field, the FieldDescriptor of the member\n+     * If the member is a method, the MethodDescriptor of the member\n+     */\n+    Object memberDescriptor;\n+\n+    /**\n+     * If the member is a normal member, the class that declared it\n+     * If the member is from Jandex, the Jandex ClassInfo of the class that declared it\n+     */\n+    Class<?> declaringClass;\n+\n+    /**\n+     * The member as an AnnotatedElement\n+     */\n+    AnnotatedElement annotatedElement;\n+\n+    /**\n+     * The MethodDescriptor of the corresponding setter. Is empty if not present.\n+     */\n+    Optional<MethodDescriptor> setter;\n+\n+    /**\n+     * The generic type of the member\n+     */\n+    Type type;\n+\n+    public GizmoMemberDescriptor(Member member) {\n+        declaringClass = member.getDeclaringClass();\n+        if (!Modifier.isPublic(member.getModifiers())) {\n+            throw new IllegalStateException(\"Member (\" + member.getName() + \") of class (\" +\n+                    member.getDeclaringClass().getName() + \") is not public and domainAccessType is GIZMO.\\n\" +\n+                    ((member instanceof Field) ? \"Maybe put the annotations onto the public getter of the field.\\n\" : \"\") +\n+                    \"Maybe use domainAccessType REFLECTION instead of GIZMO.\");\n+        }\n+        if (member instanceof Field) {\n+            memberDescriptor = FieldDescriptor.of((Field) member);\n+            name = member.getName();\n+            annotatedElement = (Field) member;\n+            type = ((Field) member).getGenericType();\n+            setter = lookupSetter();\n+        } else if (member instanceof Method) {\n+            memberDescriptor = MethodDescriptor.ofMethod((Method) member);\n+            annotatedElement = (Method) member;\n+            if (ReflectionHelper.isGetterMethod((Method) member)) {\n+                name = ReflectionHelper.getGetterPropertyName(member);\n+            } else {\n+                name = member.getName();\n+            }\n+            type = ((Method) member).getGenericReturnType();\n+            setter = lookupSetter();\n+        } else {\n+            throw new IllegalArgumentException(member + \" is not a Method or a Field.\");\n+        }\n+    }\n+\n+    // For Quarkus\n+    // (Cannot move to Quarkus module; get runtime\n+    //  exception since objects created here use classes\n+    //  from another ClassLoader).\n+    public GizmoMemberDescriptor(String name, Object memberDescriptor, Class<?> declaringClass,\n+            AnnotatedElement annotatedElement, Type type) {\n+        this(name, memberDescriptor, declaringClass, annotatedElement, type, null);\n+    }\n+\n+    public GizmoMemberDescriptor(String name, Object memberDescriptor, Class<?> declaringClass,\n+            AnnotatedElement annotatedElement, Type type,\n+            Optional<MethodDescriptor> setterDescriptor) {", "originalCommit": "4494972aa90a488e685f7ead6214cd84a0b024ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUwMTk2Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1059#discussion_r557501962", "bodyText": "Sonar doesn't like this because I use null, empty, and present (for the sake of having one constructor delegate to another; null means lookup, otherwise use directly the Optional). The Optional is the method descriptor of the setter; the one without the Optional is already taken (it for the lookup case). I could use Optional.ofNullable, but that involves unwrapping an already Optional value.", "author": "Christopher-Chianelli", "createdAt": "2021-01-14T15:57:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzExNDk1Mg=="}], "type": "inlineReview"}, {"oid": "1ff98b2b86a22ebd23fb50c0d5f449b6d3807920", "url": "https://github.com/kiegroup/optaplanner/commit/1ff98b2b86a22ebd23fb50c0d5f449b6d3807920", "message": "Fixup docs", "committedDate": "2021-01-14T17:03:27Z", "type": "forcePushed"}, {"oid": "40a2f33609d90cee940e35d650d8835edbd17f5e", "url": "https://github.com/kiegroup/optaplanner/commit/40a2f33609d90cee940e35d650d8835edbd17f5e", "message": "Add tests for private methods, remove unused classes", "committedDate": "2021-01-19T14:28:18Z", "type": "forcePushed"}, {"oid": "405b0868fb81b2400d33d5dd0ae769b8bccbf94f", "url": "https://github.com/kiegroup/optaplanner/commit/405b0868fb81b2400d33d5dd0ae769b8bccbf94f", "message": "Add tests for private methods, remove unused classes", "committedDate": "2021-01-19T14:48:28Z", "type": "forcePushed"}, {"oid": "ee0e0aa741c21427c201f8c222314f6c9cff198c", "url": "https://github.com/kiegroup/optaplanner/commit/ee0e0aa741c21427c201f8c222314f6c9cff198c", "message": "PLANNER-2264: Gizmo Member Accessor", "committedDate": "2021-01-20T15:04:54Z", "type": "commit"}, {"oid": "ee0e0aa741c21427c201f8c222314f6c9cff198c", "url": "https://github.com/kiegroup/optaplanner/commit/ee0e0aa741c21427c201f8c222314f6c9cff198c", "message": "PLANNER-2264: Gizmo Member Accessor", "committedDate": "2021-01-20T15:04:54Z", "type": "forcePushed"}, {"oid": "efbfefc4d01e52ee73ee3a0472447f1f58cea472", "url": "https://github.com/kiegroup/optaplanner/commit/efbfefc4d01e52ee73ee3a0472447f1f58cea472", "message": "Merge branch 'master' into PLANNER-2264", "committedDate": "2021-01-22T09:52:37Z", "type": "commit"}]}