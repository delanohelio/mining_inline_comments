{"pr_number": 951, "pr_title": "PLANNER-2181 Encapsulate reflection operations in SolutionDescriptor", "pr_createdAt": "2020-09-30T15:46:30Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/951", "timeline": [{"oid": "e35bc132f6deb64ef3ba40c674d639ec4ec7414b", "url": "https://github.com/kiegroup/optaplanner/commit/e35bc132f6deb64ef3ba40c674d639ec4ec7414b", "message": "PLANNER-2181 Encapsulate reflection operations in SolutionDescriptor", "committedDate": "2020-09-30T15:44:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIwMDg1NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/951#discussion_r498200855", "bodyText": "I think the problemFactClassSet should be a cached as a field on the SolutionDescriptor, so this code runs once.\nThis code to fill in that new field could run at the end of SolutionDescriptor.processProblemFactPropertyAnnotation() (or at the end of SolutionDescriptor.processFactEntityOrScoreAnnotation() if it relies on entities too).\nA basic rule around reflection is to scan each class only once for the same thing.\nThat rule is violated as this code calls extractCollectionGenericTypeParameter() (which uses reflection) for every from() call.\nAlso, as this code calls that reflection method, thinking Quarkus wise, it's much better if it already runs during SolutinDescriptor creation.", "author": "ge0ffrey", "createdAt": "2020-10-01T12:21:52Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/solution/descriptor/SolutionDescriptor.java", "diffHunk": "@@ -712,6 +714,23 @@ public ScoreDefinition getScoreDefinition() {\n         return memberNames;\n     }\n \n+    public Set<Class<?>> getProblemFactClassSet() {\n+        Stream<Class<?>> factClassStream = getProblemFactMemberAccessorMap()\n+                .values()\n+                .stream()\n+                .map(MemberAccessor::getType);\n+        Stream<Class<?>> factCollectionClassStream = getProblemFactCollectionMemberAccessorMap()\n+                .entrySet()\n+                .stream()\n+                .map(entry -> {\n+                    MemberAccessor accessor = entry.getValue();\n+                    return ConfigUtils.extractCollectionGenericTypeParameter(\"solutionClass\", getSolutionClass(),\n+                            accessor.getType(), accessor.getGenericType(), ProblemFactCollectionProperty.class, entry.getKey());", "originalCommit": "e35bc132f6deb64ef3ba40c674d639ec4ec7414b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIwMjA4MA==", "url": "https://github.com/kiegroup/optaplanner/pull/951#discussion_r498202080", "bodyText": "I think we don't need a field problemFactClassSet on SolutionDescriptor, but a problemFactOrEntityClassSet (== allAcceptedClassSet) field instead? That would avoid this mapping too and the problemFactOrEntityClassSet is only used here.", "author": "ge0ffrey", "createdAt": "2020-10-01T12:24:02Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java", "diffHunk": "@@ -82,22 +81,11 @@\n \n     public <A> void assertValidFromType(Class<A> fromType) {\n         SolutionDescriptor<Solution_> solutionDescriptor = getSolutionDescriptor();\n-        Stream<Class> entityClassStream = solutionDescriptor.getEntityDescriptors().stream()\n+        Stream<Class<?>> entityClassStream = solutionDescriptor.getEntityDescriptors().stream()\n                 .map(EntityDescriptor::getEntityClass);", "originalCommit": "e35bc132f6deb64ef3ba40c674d639ec4ec7414b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2088a9daa6d68b3e4f677dd9940654231ea833a4", "url": "https://github.com/kiegroup/optaplanner/commit/2088a9daa6d68b3e4f677dd9940654231ea833a4", "message": "Address code review comments", "committedDate": "2020-10-01T12:44:57Z", "type": "commit"}, {"oid": "519aaf9806441aa86c4c1bb18f15c9fce3d48c8c", "url": "https://github.com/kiegroup/optaplanner/commit/519aaf9806441aa86c4c1bb18f15c9fce3d48c8c", "message": "This impl will stick", "committedDate": "2020-10-01T12:59:16Z", "type": "commit"}, {"oid": "6d18316f662d4c01f52b8b0c9395ed67ea7e8b04", "url": "https://github.com/kiegroup/optaplanner/commit/6d18316f662d4c01f52b8b0c9395ed67ea7e8b04", "message": "Minor optimization", "committedDate": "2020-10-01T13:03:24Z", "type": "commit"}, {"oid": "522fe428058353026bff34f855449a34f59166dd", "url": "https://github.com/kiegroup/optaplanner/commit/522fe428058353026bff34f855449a34f59166dd", "message": "Attempt to fix the unfixable", "committedDate": "2020-10-01T13:22:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MDI4NA==", "url": "https://github.com/kiegroup/optaplanner/pull/951#discussion_r498240284", "bodyText": "The fail-fast is incorrect here. Raw Collection is not an untyped collection. It's Collection<Object>. This should not fail.", "author": "triceo", "createdAt": "2020-10-01T13:23:30Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/util/ConfigUtils.java", "diffHunk": "@@ -347,14 +347,7 @@ public static int resolvePoolSize(String propertyName, String value, String... m\n             Class<?> type, Type genericType,\n             Class<? extends Annotation> annotationClass, String memberName) {\n         if (!(genericType instanceof ParameterizedType)) {\n-            throw new IllegalArgumentException(\"The \" + parentClassConcept + \" (\" + parentClass + \") has a \"\n-                    + (annotationClass == null ? \"auto discovered\" : annotationClass.getSimpleName() + \" annotated\")\n-                    + \" member (\" + memberName\n-                    + \") with a member type (\" + type\n-                    + \") that returns a \" + Collection.class.getSimpleName()\n-                    + \" which has no generic parameters.\\n\"\n-                    + \"Maybe the member (\" + memberName + \") should return a typed \"\n-                    + Collection.class.getSimpleName() + \".\");\n+            return Object.class;", "originalCommit": "522fe428058353026bff34f855449a34f59166dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2MDM2Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/951#discussion_r498260363", "bodyText": "Actually, I could use this argument for the entire method. It should never throw, it should just return Object. The correct answer is always Object, unless we can detect a more specific answer.", "author": "triceo", "createdAt": "2020-10-01T13:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MDI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4OTcxNA==", "url": "https://github.com/kiegroup/optaplanner/pull/951#discussion_r498389714", "bodyText": "That's true unless that boolean autoDiscovered is true IIRC. Because with @PlanningSolution set to auto discover, IIRC, raw types don't work well and that stuff reuses this method too.", "author": "ge0ffrey", "createdAt": "2020-10-01T16:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MDI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ3MTIwNA==", "url": "https://github.com/kiegroup/optaplanner/pull/951#discussion_r499471204", "bodyText": "As discussed, we want to move the auto discover fail fast out of this method, into the SolutionDescriptor. This indeed should return Object.", "author": "ge0ffrey", "createdAt": "2020-10-05T09:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MDI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MTEzMA==", "url": "https://github.com/kiegroup/optaplanner/pull/951#discussion_r498241130", "bodyText": "Another instance of an over-eager fail-fast. Collection<Something<T>> shouldn't fail just because we don't know what T is. It's a Collection<Something> then.", "author": "triceo", "createdAt": "2020-10-01T13:24:40Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/config/util/ConfigUtils.java", "diffHunk": "@@ -390,6 +383,9 @@ public static int resolvePoolSize(String propertyName, String value, String... m\n                 typeArgument = upperBounds[0];\n             }\n         }\n+        if (typeArgument instanceof ParameterizedType) {\n+            return (Class) ((ParameterizedType) typeArgument).getRawType();\n+        }", "originalCommit": "522fe428058353026bff34f855449a34f59166dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5MTA2MA==", "url": "https://github.com/kiegroup/optaplanner/pull/951#discussion_r498391060", "bodyText": "This the same code as on line 375/365? So that code is already there?", "author": "ge0ffrey", "createdAt": "2020-10-01T17:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MTEzMA=="}], "type": "inlineReview"}, {"oid": "c1fffbcb72971c0d0c12940a656daf0019b7d420", "url": "https://github.com/kiegroup/optaplanner/commit/c1fffbcb72971c0d0c12940a656daf0019b7d420", "message": "Move one fail-fast", "committedDate": "2020-10-05T09:51:15Z", "type": "commit"}, {"oid": "24ad819875ba60ec458368e74f63840c46c88f2b", "url": "https://github.com/kiegroup/optaplanner/commit/24ad819875ba60ec458368e74f63840c46c88f2b", "message": "Fix logic", "committedDate": "2020-10-05T10:02:00Z", "type": "commit"}]}