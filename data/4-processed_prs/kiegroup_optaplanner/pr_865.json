{"pr_number": 865, "pr_title": "PLANNER-2078: Add Overlaps Joiners", "pr_createdAt": "2020-07-30T20:13:44Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/865", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI2NzA1NA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463267054", "bodyText": "Considering that these are not simple Joiners anymore, I would:\n\nExtract their implementations into their own class.\nSo that the tests for each also get their own class.\nAnd in that class, I'd make sure I cover all the boundary conditions in different test methods.", "author": "triceo", "createdAt": "2020-07-30T20:57:48Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -151,6 +152,23 @@\n     // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n     // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n     // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlapsOrMeets(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(lessThanOrEqual(leftStartMapping, rightEndMapping),", "originalCommit": "83a13331d007733cf9e0ee81292d1f25719c8678", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTE0OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463331149", "bodyText": "But then how will people know these Joiners exists? People might already be used to all the Joiners being in the class Joiners. If we move it to a new class, we should at least mention it in the Javadocs of Joiners so they know there are other classes that contain Joiners (but not everyone read Javadocs; I suspect some people just use their IDE auto-complete which will hide the existence of these Joiners)", "author": "Christopher-Chianelli", "createdAt": "2020-07-30T23:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI2NzA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ0NzA1NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463447055", "bodyText": "Don't get me wrong. I think that the factory methods should stay in this class. But the implementations of those Joiners should be outside.", "author": "triceo", "createdAt": "2020-07-31T07:21:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI2NzA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MDIyMg==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463270222", "bodyText": "I think this a bit over-engineered. You don't need the factory, just use the Interval constructor directly.\nThese are tests - we're not looking for memory efficiency or performance, we're looking for maintainable code that is easy to understand.", "author": "triceo", "createdAt": "2020-07-30T21:04:03Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/JoinersTest.java", "diffHunk": "@@ -300,9 +308,163 @@ public void greaterThanOrEqualPenta() {\n                 (AbstractPentaJoiner<BigInteger, BigInteger, BigInteger, BigInteger, BigDecimal>) Joiners\n                         .greaterThanOrEqual(leftMapping, rightMapping);\n         assertSoftly(softly -> {\n-            softly.assertThat(joiner.matches(TEN, ZERO, ZERO, ZERO, BigDecimal.TEN)).isTrue();\n-            softly.assertThat(joiner.matches(TEN, ZERO, ZERO, ZERO, BigDecimal.ONE)).isTrue();\n-            softly.assertThat(joiner.matches(ZERO, ZERO, ZERO, ZERO, BigDecimal.ONE)).isFalse();\n+            softly.assertThat(joiner.matches(BigInteger.TEN, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO,\n+                    BigDecimal.TEN)).isTrue();\n+            softly.assertThat(joiner.matches(BigInteger.TEN, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO,\n+                    BigDecimal.ONE)).isTrue();\n+            softly.assertThat(joiner.matches(BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO,\n+                    BigDecimal.ONE)).isFalse();\n+        });\n+    }\n+\n+    private static final class Interval<A, B> {\n+        final A start;\n+        final A end;\n+        final Function<A, B> map;\n+\n+        public Interval(A start, A end, Function<A, B> map) {\n+            this.start = start;\n+            this.end = end;\n+            this.map = map;\n+        }\n+\n+        public B getStart() {\n+            return map.apply(start);\n+        }\n+\n+        public B getEnd() {\n+            return map.apply(end);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"(\" + start.toString() + \", \" + end.toString() + \")\";\n+        }\n+\n+        public static <A, B, C> IntervalFactory<A, B, C> createFactory(Function<C, A> constructorMap, Function<A, B> map) {\n+            return new IntervalFactory<A, B, C>(constructorMap, map);\n+        }\n+\n+        private final static class IntervalFactory<A, B, C> {\n+            final Function<C, A> constructorMap;\n+            final Function<A, B> map;\n+\n+            public IntervalFactory(Function<C, A> constructorMap, Function<A, B> map) {\n+                this.constructorMap = constructorMap;\n+                this.map = map;\n+            }\n+\n+            public Interval<A, B> of(C start, C end) {\n+                return new Interval<A, B>(constructorMap.apply(start), constructorMap.apply(end), map);\n+            }\n+        }\n+    }\n+\n+    private final Interval.IntervalFactory<BigInteger, Long, Long> bigIntInterval =\n+            Interval.createFactory(BigInteger::valueOf, BigInteger::longValue);\n+\n+    private final Interval.IntervalFactory<BigDecimal, Long, Long> bigDecimalInterval =\n+            Interval.createFactory(BigDecimal::valueOf, BigDecimal::longValue);", "originalCommit": "83a13331d007733cf9e0ee81292d1f25719c8678", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3NTE3OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463275179", "bodyText": "To clarify: I prefer BigDecimalInterval and BigIntegerInterval to the factory that effectively does the same thing, only with a level of indirection.\nIf you prefer not having so many specializations of the Interval class, just create a Interval.ofBigDecimal() method etc.", "author": "triceo", "createdAt": "2020-07-30T21:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MDIyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMDM1OA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463330358", "bodyText": "I personally think calling assert with new Interval(...) doesn't look pretty, which was the main reason why I created the factories.", "author": "Christopher-Chianelli", "createdAt": "2020-07-30T23:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MDIyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ0ODIxMA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463448210", "bodyText": "Therefore my second comment - if you create factory methods directly on Interval, the code will still be easier to understand. The current IntervalFactory approach creates indirection that is harder to see through.", "author": "triceo", "createdAt": "2020-07-31T07:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MDIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MTc3Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463271772", "bodyText": "Now that the Joiners are actually relatively complex, I think that the comment before these assertions (Case A = B) should instead be turned into .as(...) on the assertion itself. The assertion messages will become so much better for it.", "author": "triceo", "createdAt": "2020-07-30T21:07:23Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/JoinersTest.java", "diffHunk": "@@ -300,9 +308,163 @@ public void greaterThanOrEqualPenta() {\n                 (AbstractPentaJoiner<BigInteger, BigInteger, BigInteger, BigInteger, BigDecimal>) Joiners\n                         .greaterThanOrEqual(leftMapping, rightMapping);\n         assertSoftly(softly -> {\n-            softly.assertThat(joiner.matches(TEN, ZERO, ZERO, ZERO, BigDecimal.TEN)).isTrue();\n-            softly.assertThat(joiner.matches(TEN, ZERO, ZERO, ZERO, BigDecimal.ONE)).isTrue();\n-            softly.assertThat(joiner.matches(ZERO, ZERO, ZERO, ZERO, BigDecimal.ONE)).isFalse();\n+            softly.assertThat(joiner.matches(BigInteger.TEN, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO,\n+                    BigDecimal.TEN)).isTrue();\n+            softly.assertThat(joiner.matches(BigInteger.TEN, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO,\n+                    BigDecimal.ONE)).isTrue();\n+            softly.assertThat(joiner.matches(BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO, BigInteger.ZERO,\n+                    BigDecimal.ONE)).isFalse();\n+        });\n+    }\n+\n+    private static final class Interval<A, B> {\n+        final A start;\n+        final A end;\n+        final Function<A, B> map;\n+\n+        public Interval(A start, A end, Function<A, B> map) {\n+            this.start = start;\n+            this.end = end;\n+            this.map = map;\n+        }\n+\n+        public B getStart() {\n+            return map.apply(start);\n+        }\n+\n+        public B getEnd() {\n+            return map.apply(end);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"(\" + start.toString() + \", \" + end.toString() + \")\";\n+        }\n+\n+        public static <A, B, C> IntervalFactory<A, B, C> createFactory(Function<C, A> constructorMap, Function<A, B> map) {\n+            return new IntervalFactory<A, B, C>(constructorMap, map);\n+        }\n+\n+        private final static class IntervalFactory<A, B, C> {\n+            final Function<C, A> constructorMap;\n+            final Function<A, B> map;\n+\n+            public IntervalFactory(Function<C, A> constructorMap, Function<A, B> map) {\n+                this.constructorMap = constructorMap;\n+                this.map = map;\n+            }\n+\n+            public Interval<A, B> of(C start, C end) {\n+                return new Interval<A, B>(constructorMap.apply(start), constructorMap.apply(end), map);\n+            }\n+        }\n+    }\n+\n+    private final Interval.IntervalFactory<BigInteger, Long, Long> bigIntInterval =\n+            Interval.createFactory(BigInteger::valueOf, BigInteger::longValue);\n+\n+    private final Interval.IntervalFactory<BigDecimal, Long, Long> bigDecimalInterval =\n+            Interval.createFactory(BigDecimal::valueOf, BigDecimal::longValue);\n+\n+    @Test\n+    public void overlapsBi() {\n+        Function<Interval<BigInteger, Long>, Long> leftStartMapping = Interval::getStart;\n+        Function<Interval<BigInteger, Long>, Long> leftEndMapping = Interval::getEnd;\n+        Function<Interval<BigDecimal, Long>, Long> rightStartMapping = Interval::getStart;\n+        Function<Interval<BigDecimal, Long>, Long> rightEndMapping = Interval::getEnd;\n+\n+        AbstractBiJoiner<Interval<BigInteger, Long>, Interval<BigDecimal, Long>> joiner =\n+                (AbstractBiJoiner<Interval<BigInteger, Long>, Interval<BigDecimal, Long>>) Joiners.overlaps(leftStartMapping,\n+                        leftEndMapping, rightStartMapping, rightEndMapping);\n+\n+        assertSoftly(softly -> {\n+            // Case A = B\n+            softly.assertThat(joiner.matches(bigIntInterval.of(1L, 5L),", "originalCommit": "83a13331d007733cf9e0ee81292d1f25719c8678", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI4NzY2MA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463287660", "bodyText": "(Which wouldn't be necessary if each of the cases had their own properly named test methods, as I suggest above. Either is fine with me.)", "author": "triceo", "createdAt": "2020-07-30T21:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MTc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MzMwMg==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463273302", "bodyText": "Let's make sure we have proper Javadocs for these factory methods. This is public API after all.", "author": "triceo", "createdAt": "2020-07-30T21:10:46Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -151,6 +152,23 @@\n     // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n     // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n     // then keep an index from every period to all talks in an overlapping period (possible the same period)", "originalCommit": "83a13331d007733cf9e0ee81292d1f25719c8678", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3Mzg2Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463273867", "bodyText": "Did you consider any other way of specifying the intervals?\n(I'm not saying this one is bad. Just making sure we went over all the options before we picked a public API to be with us forever.)", "author": "triceo", "createdAt": "2020-07-30T21:11:53Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -151,6 +152,23 @@\n     // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n     // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n     // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlapsOrMeets(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(lessThanOrEqual(leftStartMapping, rightEndMapping),\n+                greaterThanOrEqual(leftEndMapping, rightStartMapping));\n+    }\n+\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {", "originalCommit": "83a13331d007733cf9e0ee81292d1f25719c8678", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyOTU5OA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463329598", "bodyText": "An other way would be startA, startB, endA, endB\nWhen generalizing this to higher cardinality, it looks like this:\noverlaps((a,b) -> a.start, c -> c.start, (a,b) -> a.end, c -> c.end)\n\nMeanwhile, with the current definition, it be generalized like this:\noverlaps((a,b) -> a.start, (a,b) -> a.end, c -> c.start, c -> c.end)\n\nI see these as the two main contenders if we use a Function -> Comparable API for the following reasons:\n\nThe other joiners have the \"main\" stream as the first argument (this eliminates (start2,  ...) (end2, ...))\nThe main convention I see in other code is either (start1,end1,start2,end2)  (first interval followed by second interval) or  (start1,start2,end1,end2) (start points followed by end points)\n\nThe alternative way of defining it is to have a \"Duration\" (ex: 2 hour shift that start at 3am), but that requires an additional method to \"add\" a point and the point must still be comparable, so I don't see any advantage to that approach.", "author": "Christopher-Chianelli", "createdAt": "2020-07-30T23:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3Mzg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ1MzY3NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463453675", "bodyText": "The idea of (startA, durationA, startB, durationB) is intriguing. Not as the only option, but as an alternative API alongside the (start1, end1, start2, end2). The former can just delegate to the latter. Why?\nIn order to support a wider range of data models:\n\nPeople who have a data model with start date and job length, they use the former, without having to have complex lambdas like a -> // add duration to the start date.\nPeople who have a data model with a start/end dates, they use the latter.\n\nA win-win, I'd say.", "author": "triceo", "createdAt": "2020-07-31T07:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3Mzg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYxOTU4MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463619581", "bodyText": "That requires the duration to be of type Duration. Some people might use int, doubles etc. for durations. So we need an 'add' method for this to be generic, or we need to create a Temporal, Duration special case.", "author": "Christopher-Chianelli", "createdAt": "2020-07-31T13:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3Mzg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzMDYzNg==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r463830636", "bodyText": "I think it's a safe bet that, if they have startDate  as OffsetDateTime, they'd have a job length as Duration. Otherwise, if it's just an int for example, they're making life harder for themselves - and the API will work for that anyway (Duration.of(...) or OffsetDateTime.plus(...)). So yes, I do think we should have a specialization for Duration. (I think we already do that in ConstraintCollectors.)", "author": "triceo", "createdAt": "2020-07-31T20:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3Mzg2Nw=="}], "type": "inlineReview"}, {"oid": "af66d519dfda5c3093905f1c3c896916fc0b00cf", "url": "https://github.com/kiegroup/optaplanner/commit/af66d519dfda5c3093905f1c3c896916fc0b00cf", "message": "PLANNER-2078: Add Overlaps BiJoiner; remove static field imports in test to make it\nclear what type the field is.", "committedDate": "2020-09-10T18:13:32Z", "type": "commit"}, {"oid": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "url": "https://github.com/kiegroup/optaplanner/commit/15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "message": "Move interval joiners impl. to own file, add During joiner", "committedDate": "2020-09-10T20:31:48Z", "type": "commit"}, {"oid": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "url": "https://github.com/kiegroup/optaplanner/commit/15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "message": "Move interval joiners impl. to own file, add During joiner", "committedDate": "2020-09-10T20:31:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyODA5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r486628091", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param leftStartMapping Maps the first argument to the first interval start point\n          \n          \n            \n                 * @param leftStartMapping maps the first argument to the first interval start point\n          \n      \n    \n    \n  \n\nI believe we don't treat these as sentences, therefore the first letter is not capitalized.", "author": "triceo", "createdAt": "2020-09-10T20:55:37Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +148,103 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those\n+     * pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and\n+     * x in [c,d)). These are exactly the pairs where\n+     * a < d and b > c (or in other words, when the first\n+     * interval starts before the second one ends and the\n+     * first interval ends after the second interval begins).\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first argument to the first interval start point", "originalCommit": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyOTI2Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r486629263", "bodyText": "Considering that this is not a public API, I think we don't need such a comprehensive Javadoc.\nFeel free to keep it, but considering that everything important should be said on the public API already, this may be too much to maintain going forward, for little benefit.", "author": "triceo", "createdAt": "2020-09-10T20:57:48Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/common/IntervalJoiners.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.common;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.function.QuadFunction;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiJoiner;\n+import org.optaplanner.core.api.score.stream.penta.PentaJoiner;\n+import org.optaplanner.core.api.score.stream.quad.QuadJoiner;\n+import org.optaplanner.core.api.score.stream.tri.TriJoiner;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.penta.AbstractPentaJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.AbstractQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+\n+/**\n+ * Creates an {@link BiJoiner}, {@link TriJoiner}, ... instance\n+ * for data types that can be described as intervals (for instance,\n+ * time slots and numeric ranges). Based on Allen's Interval Algebra.\n+ * See https://en.wikipedia.org/wiki/Allen%27s_interval_algebra\n+ */\n+public class IntervalJoiners {", "originalCommit": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMDUxMA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r486630510", "bodyText": "In fact, now that I see how little code there actually is in this class, makes me think that maybe IntervalJoiners class is unnecessary and the methods could just be inlined into Joiners?\nWhen I was making this suggestion, I was somehow expecting that there would be more code here.", "author": "triceo", "createdAt": "2020-09-10T21:00:18Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/common/IntervalJoiners.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.common;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.function.QuadFunction;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiJoiner;\n+import org.optaplanner.core.api.score.stream.penta.PentaJoiner;\n+import org.optaplanner.core.api.score.stream.quad.QuadJoiner;\n+import org.optaplanner.core.api.score.stream.tri.TriJoiner;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.penta.AbstractPentaJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.AbstractQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+\n+/**\n+ * Creates an {@link BiJoiner}, {@link TriJoiner}, ... instance\n+ * for data types that can be described as intervals (for instance,\n+ * time slots and numeric ranges). Based on Allen's Interval Algebra.\n+ * See https://en.wikipedia.org/wiki/Allen%27s_interval_algebra\n+ */\n+public class IntervalJoiners {\n+\n+    // BiJoiners\n+\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those\n+     * pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and\n+     * x in [c,d)). These are exactly the pairs where\n+     * a < d and b > c (or in other words, when the first\n+     * interval starts before the second one ends and the\n+     * first interval ends after the second interval begins).\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first argument to the first interval start point\n+     * @param leftEndMapping Maps the first argument to the first interval end point\n+     * @param rightStartMapping Maps the second argument to the second interval start point\n+     * @param rightEndMapping Maps the second argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B) where A's and B's intervals (as defined by the function mapping)\n+     *         overlap.\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #overlaps(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code overlaps(startMapping, endMapping, startMapping, endMapping)}.\n+     * \n+     * @param <A> The type of both the first and second argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param startMapping Maps the argument to the start point of its interval\n+     * @param endMapping Maps the argument to the end point of its interval\n+     * \n+     * @return See {@link #overlaps(Function, Function, Function, Function)}\n+     */\n+    public static <A, Property_ extends Comparable<Property_>> BiJoiner<A, A> overlaps(\n+            Function<A, Property_> startMapping,\n+            Function<A, Property_> endMapping) {\n+        return overlaps(startMapping, endMapping, startMapping, endMapping);\n+    }\n+\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those\n+     * pairs where [a,b) contains [c,d) (or, in other\n+     * words, for any x in [c, d), x is also in [a,b)). These are exactly the pairs\n+     * where a <= c and b >= d (or in other words, when the first\n+     * interval starts before the second one starts and the\n+     * first interval ends after the second interval ends).\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first argument to the first interval start point\n+     * @param leftEndMapping Maps the first argument to the first interval end point\n+     * @param rightStartMapping Maps the second argument to the second interval start point\n+     * @param rightEndMapping Maps the second argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B) where A's interval contains B's interval (as defined by the function mapping)\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> during(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThanOrEqual(leftStartMapping, rightStartMapping),\n+                Joiners.greaterThanOrEqual(leftEndMapping, rightEndMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #during(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code during(startMapping, endMapping, startMapping, endMapping)}.\n+     * \n+     * @param <A> The type of both the first and second argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param startMapping Maps the argument to the start point of its interval\n+     * @param endMapping Maps the argument to the end point of its interval\n+     * \n+     * @return See {@link #during(Function, Function, Function, Function)}\n+     */\n+    public static <A, Property_ extends Comparable<Property_>> BiJoiner<A, A> during(\n+            Function<A, Property_> startMapping,\n+            Function<A, Property_> endMapping) {\n+        return during(startMapping, endMapping, startMapping, endMapping);\n+    }\n+\n+    // TriJoiners\n+    /**\n+     * Like {@link #overlaps(Function, Function, Function, Function)}, but for\n+     * TriConstraintStream.\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <C> The type of the third argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first and second arguments to the first interval start point\n+     * @param leftEndMapping Maps the first and second arguments to the first interval end point\n+     * @param rightStartMapping Maps the third argument to the second interval start point\n+     * @param rightEndMapping Maps the third argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B,C) where (A,B)'s and C's intervals (as defined by the function mapping)\n+     *         overlap.\n+     */\n+    public static <A, B, C, Property_ extends Comparable<Property_>> TriJoiner<A, B, C> overlaps(\n+            BiFunction<A, B, Property_> leftStartMapping,\n+            BiFunction<A, B, Property_> leftEndMapping,\n+            Function<C, Property_> rightStartMapping,\n+            Function<C, Property_> rightEndMapping) {\n+        return AbstractTriJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Like {@link #during(Function, Function, Function, Function)}, but for\n+     * TriConstraintStream.\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <C> The type of the third argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first and second arguments to the first interval start point\n+     * @param leftEndMapping Maps the first and second arguments to the first interval end point\n+     * @param rightStartMapping Maps the third argument to the second interval start point\n+     * @param rightEndMapping Maps the third argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B,C) where (A,B)'s interval contains C's interval (as defined by the function mapping)\n+     */\n+    public static <A, B, C, Property_ extends Comparable<Property_>> TriJoiner<A, B, C> during(\n+            BiFunction<A, B, Property_> leftStartMapping,\n+            BiFunction<A, B, Property_> leftEndMapping,\n+            Function<C, Property_> rightStartMapping,\n+            Function<C, Property_> rightEndMapping) {\n+        return AbstractTriJoiner.merge(Joiners.lessThanOrEqual(leftStartMapping, rightStartMapping),\n+                Joiners.greaterThanOrEqual(leftEndMapping, rightEndMapping));\n+    }\n+\n+    // QuadJoiners\n+    /**\n+     * Like {@link #overlaps(Function, Function, Function, Function)}, but for\n+     * QuadConstraintStream.\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <C> The type of the third argument\n+     * @param <D> The type of the fourth argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first, second and third arguments to the first interval start point\n+     * @param leftEndMapping Maps the first, second and third arguments to the first interval end point\n+     * @param rightStartMapping Maps the fourth argument to the second interval start point\n+     * @param rightEndMapping Maps the fourth argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B,C,D) where (A,B,C)'s and D's intervals (as defined by the function mapping)\n+     *         overlap.\n+     */\n+    public static <A, B, C, D, Property_ extends Comparable<Property_>> QuadJoiner<A, B, C, D> overlaps(\n+            TriFunction<A, B, C, Property_> leftStartMapping,\n+            TriFunction<A, B, C, Property_> leftEndMapping,\n+            Function<D, Property_> rightStartMapping,\n+            Function<D, Property_> rightEndMapping) {\n+        return AbstractQuadJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Like {@link #during(Function, Function, Function, Function)}, but for\n+     * QuadConstraintStream.\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <C> The type of the third argument\n+     * @param <D> The type of the fourth argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first, second and third arguments to the first interval start point\n+     * @param leftEndMapping Maps the first, second and third arguments to the first interval end point\n+     * @param rightStartMapping Maps the fourth argument to the second interval start point\n+     * @param rightEndMapping Maps the fourth argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B,C,D) where (A,B,C)'s interval contains D's interval (as defined by the function mapping)\n+     */\n+    public static <A, B, C, D, Property_ extends Comparable<Property_>> QuadJoiner<A, B, C, D> during(\n+            TriFunction<A, B, C, Property_> leftStartMapping,\n+            TriFunction<A, B, C, Property_> leftEndMapping,\n+            Function<D, Property_> rightStartMapping,\n+            Function<D, Property_> rightEndMapping) {\n+        return AbstractQuadJoiner.merge(Joiners.lessThanOrEqual(leftStartMapping, rightStartMapping),\n+                Joiners.greaterThanOrEqual(leftEndMapping, rightEndMapping));\n+    }\n+\n+    // PentaJoiners\n+    /**\n+     * Like {@link #overlaps(Function, Function, Function, Function)}, but for\n+     * PentaConstraintStream.\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <C> The type of the third argument\n+     * @param <D> The type of the fourth argument\n+     * @param <E> The type of the fifth argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first, second, third and fourth arguments to the first interval start point\n+     * @param leftEndMapping Maps the first, second, third and fourth arguments to the first interval end point\n+     * @param rightStartMapping Maps the fifth argument to the second interval start point\n+     * @param rightEndMapping Maps the fifth argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B,C,D,E) where (A,B,C,D)'s and E's intervals (as defined by the function mapping)\n+     *         overlap.\n+     */\n+    public static <A, B, C, D, E, Property_ extends Comparable<Property_>> PentaJoiner<A, B, C, D, E> overlaps(\n+            QuadFunction<A, B, C, D, Property_> leftStartMapping,\n+            QuadFunction<A, B, C, D, Property_> leftEndMapping,\n+            Function<E, Property_> rightStartMapping,\n+            Function<E, Property_> rightEndMapping) {\n+        return AbstractPentaJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Like {@link #during(Function, Function, Function, Function)}, but for\n+     * PentaConstraintStream.\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <C> The type of the third argument\n+     * @param <D> The type of the fourth argument\n+     * @param <E> The type of the fifth argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first, second, third and fourth arguments to the first interval start point\n+     * @param leftEndMapping Maps the first, second, third and fourth arguments to the first interval end point\n+     * @param rightStartMapping Maps the fifth argument to the second interval start point\n+     * @param rightEndMapping Maps the fifth argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B,C,D,E) where (A,B,C,D)'s interval contains E's interval (as defined by the function mapping)\n+     */\n+    public static <A, B, C, D, E, Property_ extends Comparable<Property_>> PentaJoiner<A, B, C, D, E> during(\n+            QuadFunction<A, B, C, D, Property_> leftStartMapping,\n+            QuadFunction<A, B, C, D, Property_> leftEndMapping,\n+            Function<E, Property_> rightStartMapping,\n+            Function<E, Property_> rightEndMapping) {\n+        return AbstractPentaJoiner.merge(Joiners.lessThanOrEqual(leftStartMapping, rightStartMapping),\n+                Joiners.greaterThanOrEqual(leftEndMapping, rightEndMapping));", "originalCommit": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2NTgyMg==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487065822", "bodyText": "Probably from the 13 cases required to ensure full checking of joiner correctness (4! = 24, but pairs (a,b) where a > b are invalid, which cut it in half, and one additional case for equals). Simple code may not have so simple tests.", "author": "Christopher-Chianelli", "createdAt": "2020-09-11T14:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMDUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMTcyNw==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r486631727", "bodyText": "Two rules for our Javadocs:\n\nUse the full line length, which is 120 chars.\nEach sentence starts on a new line.", "author": "triceo", "createdAt": "2020-09-10T21:02:48Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +148,103 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those\n+     * pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and\n+     * x in [c,d)). These are exactly the pairs where\n+     * a < d and b > c (or in other words, when the first\n+     * interval starts before the second one ends and the\n+     * first interval ends after the second interval begins).", "originalCommit": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMjI5NA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r486632294", "bodyText": "We usually start with never null, an indexed joiner... And since it doesn't start with a capital letter, it doesn't end with a full stop.", "author": "triceo", "createdAt": "2020-09-10T21:03:54Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +148,103 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those\n+     * pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and\n+     * x in [c,d)). These are exactly the pairs where\n+     * a < d and b > c (or in other words, when the first\n+     * interval starts before the second one ends and the\n+     * first interval ends after the second interval begins).\n+     * \n+     * @param <A> The type of the first argument\n+     * @param <B> The type of the second argument\n+     * @param <Property_> The type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping Maps the first argument to the first interval start point\n+     * @param leftEndMapping Maps the first argument to the first interval end point\n+     * @param rightStartMapping Maps the second argument to the second interval start point\n+     * @param rightEndMapping Maps the second argument to the second interval end point\n+     * \n+     * @return An indexed joiner that filters the constraint stream to only include\n+     *         elements (A,B) where A's and B's intervals (as defined by the function mapping)\n+     *         overlap.", "originalCommit": "15b387f0a41ed13ee11809b59b3e5ecdc4c441c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "35e0ee56541bffd50e5f1e8a0f49f8d2f460994f", "url": "https://github.com/kiegroup/optaplanner/commit/35e0ee56541bffd50e5f1e8a0f49f8d2f460994f", "message": "Fixup interval joiners Javadoc, move impl. to Joiners, add missing test cases", "committedDate": "2020-09-11T15:02:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyMzAxNA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487123014", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param leftStartMapping maps the first argument to the first interval start point\n          \n          \n            \n                 * @param leftEndMapping maps the first argument to the first interval end point\n          \n          \n            \n                 * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n          \n          \n            \n                 * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n          \n      \n    \n    \n  \n\nOne last comment on the Javadocs: The method description marks the intervals [a, b), which is the correct mathematical notation for an interval open on the right, but let's make it crystal clear.", "author": "triceo", "createdAt": "2020-09-11T15:30:11Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point\n+     * @param leftEndMapping maps the first argument to the first interval end point", "originalCommit": "35e0ee56541bffd50e5f1e8a0f49f8d2f460994f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "39e5ed15f651d41b0eae2e71c468f8eefc14e366", "url": "https://github.com/kiegroup/optaplanner/commit/39e5ed15f651d41b0eae2e71c468f8eefc14e366", "message": "Make it clear starts are inclusive and end are exclusive, use correct terms in tests", "committedDate": "2020-09-11T17:06:24Z", "type": "commit"}, {"oid": "671103550e740d691524256ea572ffc5b1e642ee", "url": "https://github.com/kiegroup/optaplanner/commit/671103550e740d691524256ea572ffc5b1e642ee", "message": "Modify ConstraintProviders to use overlaps", "committedDate": "2020-09-11T17:42:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2MjYwNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487862605", "bodyText": "style: type params are typically the last in the javadocs @ list", "author": "ge0ffrey", "createdAt": "2020-09-14T12:11:18Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2MzQ3OA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487863478", "bodyText": "method name => overlapping (because it needs to be an adjective like other method names filtering, intersecting, equal, ...)", "author": "ge0ffrey", "createdAt": "2020-09-14T12:12:51Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's and B's intervals (as defined by the function mapping) overlap\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NDIyMw==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487864223", "bodyText": "\"maps the first argument to the first interval start point \" the double \"first\" could be confusing, suggestion:\n=> maps the first argument to its interval start point\"", "author": "ge0ffrey", "createdAt": "2020-09-14T12:14:15Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NDk5Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487864993", "bodyText": "This second sentance seems to repeat the first sentence. I don't think it brings additional clarity, so I'd remove it.", "author": "ge0ffrey", "createdAt": "2020-09-14T12:15:43Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NjkzOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487866939", "bodyText": "All joiners should probably have a first general line concept line, how about something like:\n\"Joins every A and B that overlap for an interval which is specified by a start and end property on both A and B.\"", "author": "ge0ffrey", "createdAt": "2020-09-14T12:19:17Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NzkyNA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487867924", "bodyText": "We should probably use the same trick here as we do for all overloaded methods in the UniConstraintStream API javadocs etc: the first one has the full javadoc, but the others simply put As defined by {@link #overlapping(...)}. and then still specify the @param and @return etc.", "author": "ge0ffrey", "createdAt": "2020-09-14T12:21:05Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's and B's intervals (as defined by the function mapping) overlap\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #overlaps(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code overlaps(startMapping, endMapping, startMapping, endMapping)}.", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2OTE2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487869165", "bodyText": "Method ordering: the other methods in the class such as equal(A) are ordered before equal(A, B). Let's keep that consistent for easier maintenance? So this method before the previous one.", "author": "ge0ffrey", "createdAt": "2020-09-14T12:23:23Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's and B's intervals (as defined by the function mapping) overlap\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #overlaps(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code overlaps(startMapping, endMapping, startMapping, endMapping)}.\n+     * \n+     * @param <A> the type of both the first and second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param startMapping maps the argument to the start point of its interval (inclusive)\n+     * @param endMapping maps the argument to the end point of its interval (exclusive)\n+     * \n+     * @return see {@link #overlaps(Function, Function, Function, Function)}\n+     */\n+    public static <A, Property_ extends Comparable<Property_>> BiJoiner<A, A> overlaps(", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2OTk1Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487869957", "bodyText": "Note that I expect that like equal, this method will be use far more than the (A, B) one, and therefor this deserves the javadoc and the other the \"as defined by\".", "author": "ge0ffrey", "createdAt": "2020-09-14T12:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2OTE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MTgwMg==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487871802", "bodyText": "Adding x complicates things. I am sure mathematicians love the \"for any x\" definition, but our audience, programmers, are better off with a simple statement a <= c and b <= d (or is it the other way around? see comment below), so no need for adding an x.", "author": "ge0ffrey", "createdAt": "2020-09-14T12:27:32Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's and B's intervals (as defined by the function mapping) overlap\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #overlaps(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code overlaps(startMapping, endMapping, startMapping, endMapping)}.\n+     * \n+     * @param <A> the type of both the first and second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param startMapping maps the argument to the start point of its interval (inclusive)\n+     * @param endMapping maps the argument to the end point of its interval (exclusive)\n+     * \n+     * @return see {@link #overlaps(Function, Function, Function, Function)}\n+     */\n+    public static <A, Property_ extends Comparable<Property_>> BiJoiner<A, A> overlaps(\n+            Function<A, Property_> startMapping,\n+            Function<A, Property_> endMapping) {\n+        return overlaps(startMapping, endMapping, startMapping, endMapping);\n+    }\n+\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) contains [c,d) (or, in other\n+     * words, for any x in [c, d), x is also in [a,b)).", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MzA3MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487873071", "bodyText": "Unlike in overlapping (and addition), for duration (like for substraction) it really important as to which is which.\nWhich of these is true?\n\nduring(summer 2020, year 2020)\nduring(year 2020, summer 2020)\n\nThe method name and the javadocs must make that crystal clear with no verbosity", "author": "ge0ffrey", "createdAt": "2020-09-14T12:29:39Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's and B's intervals (as defined by the function mapping) overlap\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #overlaps(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code overlaps(startMapping, endMapping, startMapping, endMapping)}.\n+     * \n+     * @param <A> the type of both the first and second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param startMapping maps the argument to the start point of its interval (inclusive)\n+     * @param endMapping maps the argument to the end point of its interval (exclusive)\n+     * \n+     * @return see {@link #overlaps(Function, Function, Function, Function)}\n+     */\n+    public static <A, Property_ extends Comparable<Property_>> BiJoiner<A, A> overlaps(\n+            Function<A, Property_> startMapping,\n+            Function<A, Property_> endMapping) {\n+        return overlaps(startMapping, endMapping, startMapping, endMapping);\n+    }\n+\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) contains [c,d) (or, in other\n+     * words, for any x in [c, d), x is also in [a,b)).\n+     * These are exactly the pairs where {@code a <= c} and {@code b >= d} (or in other words, when the first interval\n+     * starts before the second one starts and the first interval ends after the second interval ends).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NDIwNg==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487874206", "bodyText": "-1 on \"during\" as method name because it presumes the notion of time.\nThis method applies not just to LocalDate etc, but also Integer, Long, BigDecimal and anything else that is Comparable.\nNot just intervals, but any type of range.", "author": "ge0ffrey", "createdAt": "2020-09-14T12:31:28Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -147,10 +151,99 @@\n      * }\n      */\n \n-    // TODO\n-    // join(..., planningVariableContainsCached(Talk::getPeriod, (Period a, Period b) -> a.overlaps(b)))\n-    // get the period value range, does a cartesian product on it, so it maps every period to an overlapping periodList\n-    // then keep an index from every period to all talks in an overlapping period (possible the same period)\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) and [c,d) overlap (or, in other\n+     * words, there exists an x such that x in [a,b) and x in [c,d)).\n+     * These are exactly the pairs where {@code a < d} and {@code b > c} (or in other words, when the first interval\n+     * starts before the second one ends and the first interval ends after the second interval begins).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's and B's intervals (as defined by the function mapping) overlap\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> overlaps(\n+            Function<A, Property_> leftStartMapping,\n+            Function<A, Property_> leftEndMapping,\n+            Function<B, Property_> rightStartMapping,\n+            Function<B, Property_> rightEndMapping) {\n+        return AbstractBiJoiner.merge(Joiners.lessThan(leftStartMapping, rightEndMapping),\n+                Joiners.greaterThan(leftEndMapping, rightStartMapping));\n+    }\n+\n+    /**\n+     * Syntactic sugar for {@link #overlaps(Function, Function, Function, Function)} where\n+     * both elements of the tuple (A,B) are the same type and have the same interval\n+     * defining function. Identical to\n+     * {@code overlaps(startMapping, endMapping, startMapping, endMapping)}.\n+     * \n+     * @param <A> the type of both the first and second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param startMapping maps the argument to the start point of its interval (inclusive)\n+     * @param endMapping maps the argument to the end point of its interval (exclusive)\n+     * \n+     * @return see {@link #overlaps(Function, Function, Function, Function)}\n+     */\n+    public static <A, Property_ extends Comparable<Property_>> BiJoiner<A, A> overlaps(\n+            Function<A, Property_> startMapping,\n+            Function<A, Property_> endMapping) {\n+        return overlaps(startMapping, endMapping, startMapping, endMapping);\n+    }\n+\n+    /**\n+     * For pairs of intervals [a,b) and [c,d), returns only those pairs where [a,b) contains [c,d) (or, in other\n+     * words, for any x in [c, d), x is also in [a,b)).\n+     * These are exactly the pairs where {@code a <= c} and {@code b >= d} (or in other words, when the first interval\n+     * starts before the second one starts and the first interval ends after the second interval ends).\n+     * \n+     * @param <A> the type of the first argument\n+     * @param <B> the type of the second argument\n+     * @param <Property_> the type used to define the interval, comparable\n+     * \n+     * @param leftStartMapping maps the first argument to the first interval start point (inclusive)\n+     * @param leftEndMapping maps the first argument to the first interval end point (exclusive)\n+     * @param rightStartMapping maps the second argument to the second interval start point (inclusive)\n+     * @param rightEndMapping maps the second argument to the second interval end point (exclusive)\n+     * \n+     * @return never null, an indexed joiner that filters the constraint stream to only include elements (A,B) where\n+     *         A's interval contains B's interval (as defined by the function mapping)\n+     */\n+    public static <A, B, Property_ extends Comparable<Property_>> BiJoiner<A, B> during(", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NTc0NA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487875744", "bodyText": "I've opened a zulip chat on this, this is something we need to resolve before merging I think, as it gets written in stone in the API.", "author": "ge0ffrey", "createdAt": "2020-09-14T12:33:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NDIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NzA3NA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487877074", "bodyText": "All unit tests for the class Joiners should be in JoinersTests normally, so it's easier to find them. It's harder to know that this class exists, because it's not classname +\"Test\"", "author": "ge0ffrey", "createdAt": "2020-09-14T12:36:17Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/IntervalJoinersTest.java", "diffHunk": "@@ -0,0 +1,951 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.api.score.stream;\n+\n+import static org.assertj.core.api.SoftAssertions.assertSoftly;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.api.function.QuadFunction;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.penta.AbstractPentaJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.AbstractQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+\n+public class IntervalJoinersTest {", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA1OTQ2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r488059465", "bodyText": "Issue is the Interval Joiner tests are a lot more complicated than the normal joiner tests as there are 13 test cases we need to go through instead of the typical 2. So adding it to JoinersTests will make it massive: ~800 lines. As we add more and more Joiners, eventually JoinersTests will be a couple thousand lines and get harder and harder to maintain. Since 800 isn't too bad, I'll merge it, but we should separate the tests if we add more joiners (in particular, those with non-trivial testing)", "author": "Christopher-Chianelli", "createdAt": "2020-09-14T16:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NzA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3ODAxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487878019", "bodyText": "Please create a Testdata class for this instead, in the testdata package.\n@triceo Do we have any testdata classes already that are only for ConstraintStream testing and don't have any @planning* annotations?", "author": "ge0ffrey", "createdAt": "2020-09-14T12:37:52Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/IntervalJoinersTest.java", "diffHunk": "@@ -0,0 +1,951 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.api.score.stream;\n+\n+import static org.assertj.core.api.SoftAssertions.assertSoftly;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.api.function.QuadFunction;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.penta.AbstractPentaJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.AbstractQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+\n+public class IntervalJoinersTest {\n+    private static final class Interval<A, B> {", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MzI3MA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487883270", "bodyText": "No, and personally I don't see the need to do that. I'd rather keep single use classes limited in scope to where they're declared.", "author": "triceo", "createdAt": "2020-09-14T12:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3ODAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3ODc2MA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487878760", "bodyText": "How does overlapsBiShort() improve the test coverage over overlapsBi? What does the \"short\" mean?", "author": "ge0ffrey", "createdAt": "2020-09-14T12:39:03Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/IntervalJoinersTest.java", "diffHunk": "@@ -0,0 +1,951 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.optaplanner.core.api.score.stream;\n+\n+import static org.assertj.core.api.SoftAssertions.assertSoftly;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.api.function.QuadFunction;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.penta.AbstractPentaJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.AbstractQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+\n+public class IntervalJoinersTest {\n+    private static final class Interval<A, B> {\n+        final A start;\n+        final A end;\n+        final Function<A, B> map;\n+\n+        public Interval(A start, A end, Function<A, B> map) {\n+            this.start = start;\n+            this.end = end;\n+            this.map = map;\n+        }\n+\n+        public B getStart() {\n+            return map.apply(start);\n+        }\n+\n+        public B getEnd() {\n+            return map.apply(end);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"(\" + start.toString() + \", \" + end.toString() + \")\";\n+        }\n+\n+        public static Interval<Long, BigDecimal> ofBigDecimal(Long start, Long end) {\n+            return new Interval<>(start, end, BigDecimal::valueOf);\n+        }\n+\n+        public static Interval<Long, BigInteger> ofBigInt(Long start, Long end) {\n+            return new Interval<>(start, end, BigInteger::valueOf);\n+        }\n+    }\n+\n+    @Test\n+    public void overlapsBi() {\n+        Function<Interval<Long, BigInteger>, Long> leftStartMapping = interval -> interval.getStart().longValue();\n+        Function<Interval<Long, BigInteger>, Long> leftEndMapping = interval -> interval.getEnd().longValue();\n+        Function<Interval<Long, BigDecimal>, Long> rightStartMapping = interval -> interval.getStart().longValue();\n+        Function<Interval<Long, BigDecimal>, Long> rightEndMapping = interval -> interval.getEnd().longValue();\n+\n+        AbstractBiJoiner<Interval<Long, BigInteger>, Interval<Long, BigDecimal>> joiner =\n+                (AbstractBiJoiner<Interval<Long, BigInteger>, Interval<Long, BigDecimal>>) Joiners.overlaps(leftStartMapping,\n+                        leftEndMapping, rightStartMapping, rightEndMapping);\n+\n+        assertSoftly(softly -> {\n+            // True cases (equals, overlaps, contains, starts, ends)\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 5L),\n+                    Interval.ofBigDecimal(1L, 5L)))\n+                    .as(\"Case A = B\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(3L, 7L),\n+                    Interval.ofBigDecimal(1L, 5L)))\n+                    .as(\"B starts before A, A ends after B\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 5L),\n+                    Interval.ofBigDecimal(3L, 7L)))\n+                    .as(\"A starts before B, B ends after A\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(3L, 5L),\n+                    Interval.ofBigDecimal(1L, 7L)))\n+                    .as(\"B contains A\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 7L),\n+                    Interval.ofBigDecimal(3L, 5L)))\n+                    .as(\"A contains B\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 7L),\n+                    Interval.ofBigDecimal(1L, 3L)))\n+                    .as(\"A started by B\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 3L),\n+                    Interval.ofBigDecimal(1L, 7L)))\n+                    .as(\"B started by A\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 7L),\n+                    Interval.ofBigDecimal(3L, 7L)))\n+                    .as(\"A ended by B\").isTrue();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(3L, 7L),\n+                    Interval.ofBigDecimal(1L, 7L)))\n+                    .as(\"B ended by A\").isTrue();\n+\n+            // False Cases (before, after, meets)\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 3L),\n+                    Interval.ofBigDecimal(5L, 7L)))\n+                    .as(\"A before B\").isFalse();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(5L, 7L),\n+                    Interval.ofBigDecimal(1L, 3L)))\n+                    .as(\"B before A\").isFalse();\n+\n+            // This is false since typically, when overlaps is used,\n+            // end is exclusive, and start is inclusive,\n+            // so 0-5, 5-10 do not overlap\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(1L, 3L),\n+                    Interval.ofBigDecimal(3L, 7L)))\n+                    .as(\"A meets B\").isFalse();\n+\n+            softly.assertThat(joiner.matches(Interval.ofBigInt(3L, 7L),\n+                    Interval.ofBigDecimal(1L, 3L)))\n+                    .as(\"B meets A\").isFalse();\n+        });\n+    }\n+\n+    @Test\n+    public void overlapsBiShort() {", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0Njk3MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r488046971", "bodyText": "It for the short form of the overlapping method for the same type (i.e. overlapping(Function, Function) NOT overlapping(Function, Function, Function, Function))", "author": "Christopher-Chianelli", "createdAt": "2020-09-14T16:00:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3ODc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA4MTQ5OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r488081499", "bodyText": "Changed to overlapsDifferentTypes and overlapsSameTypes", "author": "Christopher-Chianelli", "createdAt": "2020-09-14T16:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3ODc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MDIxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487880219", "bodyText": "Great to see this!\nSmall suggestion: revmove Joiners. for consistency because the other ConstraintProviders seem to do a static import of all Joiners methods.", "author": "ge0ffrey", "createdAt": "2020-09-14T12:41:22Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/flightcrewscheduling/optional/score/FlightCrewSchedulingConstraintProvider.java", "diffHunk": "@@ -35,8 +35,9 @@ private Constraint requiredSkill(ConstraintFactory constraintFactory) {\n     }\n \n     private Constraint flightConflict(ConstraintFactory constraintFactory) {\n-        return constraintFactory.fromUniquePair(FlightAssignment.class, Joiners.equal(FlightAssignment::getEmployee))\n-                .filter((first, second) -> second.getFlight().overlaps(first.getFlight()))\n+        return constraintFactory.fromUniquePair(FlightAssignment.class, Joiners.equal(FlightAssignment::getEmployee),\n+                Joiners.overlaps(fa -> fa.getFlight().getDepartureUTCDateTime(),\n+                        fa -> fa.getFlight().getArrivalUTCDateTime()))", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4Mjc3MA==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r487882770", "bodyText": "(not a change request)\nThis brings up an interesting question: often the overlap is penalized. For example in conference scheduling, the overlap of 2 somehow conflicting talks is penalized.\nWe must have the overlap/duration API to allow for indexing. Should we also provide a helper method to calculate the overlap during penalization? Probably we can't: LocalDate and Integer don't have a common interface with a \"subtract\" method.", "author": "ge0ffrey", "createdAt": "2020-09-14T12:45:29Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -86,8 +89,12 @@ protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFact\n                         equal((leftRequiredAttendance, rightRequiredAttendance, leftAssignment) -> rightRequiredAttendance\n                                 .getMeeting(),\n                                 MeetingAssignment::getMeeting),\n-                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n-                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                        overlaps((attendee1, attendee2, assignment) -> assignment.getStartingTimeGrain().getGrainIndex(),\n+                                (attendee1, attendee2, assignment) -> assignment.getStartingTimeGrain().getGrainIndex() +\n+                                        assignment.getMeeting().getDurationInGrains(),\n+                                assignment -> assignment.getStartingTimeGrain().getGrainIndex(),\n+                                assignment -> assignment.getStartingTimeGrain().getGrainIndex() +\n+                                        assignment.getMeeting().getDurationInGrains()))\n                 .penalizeConfigurable(\"Required attendance conflict\",\n                         (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n                                 .calculateOverlap(leftAssignment));", "originalCommit": "671103550e740d691524256ea572ffc5b1e642ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA3MTM4MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/865#discussion_r488071381", "bodyText": "If there was such an interface, it would have to allow the following operations: LocalDate - LocalDate -> Period, Integer - Integer -> Integer, LocalDateTime - LocalDateTime -> Duration, etc. overlapping can be done for any Comparable class, overlappingAmount cannot; it requires an additional interface difference(a,b). No such interface exists that all implement, although each class has their subtract method.\nWhat we can do is help something like this:\nPair<T,T> overlappingRange(interval1, interval2)\nwhich returns (max(A.start, B.start), min(A.end, B.end)) (which is the \"area\" of overlap). Then they can do the subtract operation on those two points (or can provide a function that that turns it into a number) See https://stackoverflow.com/a/36035369", "author": "Christopher-Chianelli", "createdAt": "2020-09-14T16:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4Mjc3MA=="}], "type": "inlineReview"}, {"oid": "18284554f62ed5a776c180e433c3abe420a6399e", "url": "https://github.com/kiegroup/optaplanner/commit/18284554f62ed5a776c180e433c3abe420a6399e", "message": "Edit JavaDoc, remove during joiner, move IntervalJoinerTests to JoinerTests", "committedDate": "2020-09-14T16:51:34Z", "type": "commit"}, {"oid": "18284554f62ed5a776c180e433c3abe420a6399e", "url": "https://github.com/kiegroup/optaplanner/commit/18284554f62ed5a776c180e433c3abe420a6399e", "message": "Edit JavaDoc, remove during joiner, move IntervalJoinerTests to JoinerTests", "committedDate": "2020-09-14T16:51:34Z", "type": "forcePushed"}]}