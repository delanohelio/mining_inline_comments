{"pr_number": 695, "pr_title": "PLANNER-1836 SolverManager.terminateEarly() must cancel an un-started SolverJob", "pr_createdAt": "2020-02-18T15:38:17Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/695", "timeline": [{"oid": "6c52bdad604f45662345251ef0000aa3aee25391", "url": "https://github.com/kiegroup/optaplanner/commit/6c52bdad604f45662345251ef0000aa3aee25391", "message": "PLANNER-1836 SolverManager.terminateEarly() must cancel a non-started SolverJob", "committedDate": "2020-02-18T15:37:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc1ODAxMg==", "url": "https://github.com/kiegroup/optaplanner/pull/695#discussion_r380758012", "bodyText": "@michaltomco An attempt at trying to explain how I changed this test:\n\nThe original test uses waitForJobStatusChangeOrTimeout() - but these are race condition sensitive. For example, presume we wait for SOLVING_ACTIVE. In theory, it's possible that the solver runs so quick, that between polling it goes from SOLVING_SCHEDULED to SOLVING_ACTIVE to NOT_SOLVING, without the polling every seeing SOLVING_ACTIVE.\nFurthermore - the TimeUnit.MILLISECONDS.sleep(5) could be both too quick (see \"live lock\" in Brian Goetz's book) and too slow (increases total unit testing time, which is a cost for CI and all developers for every commit). Whenever possible, avoiding it is nice.\n\nThe latches approach follows a differently philosophy. Instead of trying to \"poll\" at the right time (retrying if needed) to confirm the sequence of events happens in the order we except them to happen, we pause the sequence of events with latches, at which point we can guarantee the solving status.", "author": "ge0ffrey", "createdAt": "2020-02-18T15:46:47Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -238,110 +237,70 @@ public void skipAhead() throws ExecutionException, InterruptedException {\n                 solverConfig, new SolverManagerConfig().withParallelSolverCount(\"1\"));\n         AtomicInteger eventCount = new AtomicInteger();\n         SolverJob<TestdataSolution, Long> solverJob1 = solverManager.solveAndListen(1L,\n-                                                                                    problemId -> PlannerTestUtils.generateTestdataSolution(\"s1\", 4),\n-                                                                                    bestSolution -> {\n-                                                                                        if (bestSolution.getEntityList().get(1).getValue() == null) {\n-                                                                                            // The problem itself causes a best solution event. TODO Do we really want that behavior?\n-                                                                                            return;\n-                                                                                        }\n-                                                                                        eventCount.incrementAndGet();\n-                                                                                        if (bestSolution.getEntityList().get(2).getValue() == null) {\n-                                                                                            try {\n-                                                                                                latch.await();\n-                                                                                            } catch (InterruptedException e) {\n-                                                                                                fail(\"Latch failed.\");\n-                                                                                            }\n-                                                                                        } else if (bestSolution.getEntityList().get(3).getValue() == null) {\n-                                                                                            fail(\"No skip ahead occurred: both e2 and e3 are null in a best solution event.\");\n-                                                                                        }\n-                                                                                    });\n+                problemId -> PlannerTestUtils.generateTestdataSolution(\"s1\", 4),\n+                bestSolution -> {\n+                    if (bestSolution.getEntityList().get(1).getValue() == null) {\n+                        // The problem itself causes a best solution event. TODO Do we really want that behavior?\n+                        return;\n+                    }\n+                    eventCount.incrementAndGet();\n+                    if (bestSolution.getEntityList().get(2).getValue() == null) {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            fail(\"Latch failed.\");\n+                        }\n+                    } else if (bestSolution.getEntityList().get(3).getValue() == null) {\n+                        fail(\"No skip ahead occurred: both e2 and e3 are null in a best solution event.\");\n+                    }\n+                });\n         assertSolutionInitialized(solverJob1.getFinalBestSolution());\n         // EventCount can be 2 or 3, depending on the race, but it can never be 4.\n         assertTrue(eventCount.get() < 4);\n     }\n \n-    /**\n-     * In order to effectively test the terminateEarly() and close() methods there had to be a way how to make the job\n-     * status change in a deterministic way while solving jobs on separate threads. The test waits for a status change in\n-     * a loop and time-outs when it doesn't reach it's expected status.\n-     */\n-    @Ignore(\"https://issues.redhat.com/browse/PLANNER-1836\")\n-    @Test\n-    public void terminateEarlyAndClose() throws InterruptedException {\n+    @Test(timeout = 600_000L)\n+    public void terminateEarly() throws InterruptedException {", "originalCommit": "6c52bdad604f45662345251ef0000aa3aee25391", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1NjI3MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/695#discussion_r381156271", "bodyText": "Thanks for the explanation Geoffrey, I agree it is safer this way after reading your arguments.", "author": "michaltomco", "createdAt": "2020-02-19T09:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc1ODAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc2MjA3OA==", "url": "https://github.com/kiegroup/optaplanner/pull/695#discussion_r380762078", "bodyText": "Yes, I used a logger.warn() here. Usually, that's not a good idea.\nMotivation:\nA) When things go wrong during a normal shutdown, I want it to stick out, so we can figure out what's going on. Doing logger.info or lower means we'll never know.\nB) Fail fasting by throwing an exception, might cause more havoc than it's worth? During shutdown, it's fairly normal that ALL threads get interrupted, just before the JVM exits. I 'd presume that the \"shutdown thread\" isn't getting interrupted (that would be stupid) and that that one will call terminateEarly() (actually, it will call solverManager.shutdown(), so this discussion is void!).\nI am fairly convinced of not doing A) (an info or lower log), except if users start complaining later. I am less convinced for B)\nWdyt? Should we fail fast instead?", "author": "ge0ffrey", "createdAt": "2020-02-18T15:52:22Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/solver/DefaultSolverJob.java", "diffHunk": "@@ -109,7 +116,20 @@ public Solution_ call() {\n \n     @Override\n     public void terminateEarly() {\n-        solver.terminateEarly();\n+        boolean cancelled = future.cancel(false);\n+        if (cancelled) {\n+            solverStatus = SolverStatus.NOT_SOLVING;\n+        } else {\n+            // The solver is either actively solving or has already terminated\n+            solver.terminateEarly();\n+            try {\n+                // Don't return until bestSolutionConsumer won't be called any more\n+                terminatedLatch.await();\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                logger.warn(\"The terminateEarly() call is interrupted.\", e);", "originalCommit": "6c52bdad604f45662345251ef0000aa3aee25391", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2MTM1OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/695#discussion_r381161359", "bodyText": "Wouldn't it be better to import only the asserts used instead of using org.junit.Assert.*?", "author": "michaltomco", "createdAt": "2020-02-19T09:14:04Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/solver/SolverManagerTest.java", "diffHunk": "@@ -49,11 +48,11 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-import static org.optaplanner.core.impl.testdata.util.PlannerAssert.assertSolutionInitialized;\n+import static org.junit.Assert.*;", "originalCommit": "6c52bdad604f45662345251ef0000aa3aee25391", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2ODU0Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/695#discussion_r381168542", "bodyText": "We more-or-less have an exception for static star imports for Assert and Mockito.\nI'd love for us to just follow the quarkus code style and enforce their style in the build just like they do. I don't know if they allow static star imports.\nBut trying to change or synchronize Code Style is a religious discussion. Such discussions always spiral out of control, take a lot of energy and kill productivity.\nSo let's not discuss whether or not star static imports are a good thing. Let's discuss whether we \"just want to follow quarkus's style\" (or spring's) and be done with it. And if so, when and who wants to investigate that effort.", "author": "ge0ffrey", "createdAt": "2020-02-19T09:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2MTM1OQ=="}], "type": "inlineReview"}]}