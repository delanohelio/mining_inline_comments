{"pr_number": 745, "pr_title": "PLANNER-1861 Constraint Verifier documentation", "pr_createdAt": "2020-04-14T10:17:29Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/745", "timeline": [{"oid": "c6ea9faa91840c4b2706d77f9eb2eeb177637382", "url": "https://github.com/kiegroup/optaplanner/commit/c6ea9faa91840c4b2706d77f9eb2eeb177637382", "message": "PLANNER-1861 Constraint Verifier documentation", "committedDate": "2020-04-14T10:17:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMjc4NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408032785", "bodyText": "Don't use \". Use _ for emphasis or * for bold.", "author": "ge0ffrey", "createdAt": "2020-04-14T10:29:17Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,121 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".", "originalCommit": "c6ea9faa91840c4b2706d77f9eb2eeb177637382", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIyODQ3OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408228479", "bodyText": "Suggestion:\nConstraint streams include the Constraint Verifier unit testing harness.", "author": "emmurphy1", "createdAt": "2020-04-14T15:28:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMjc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMzMwMw==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408033303", "bodyText": "\"this is how\" = too indirect, too verbose. Start with the important keywords.\nTry something like \"A simple unit test for this constraint looks like this:\"", "author": "ge0ffrey", "createdAt": "2020-04-14T10:30:15Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,121 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:", "originalCommit": "c6ea9faa91840c4b2706d77f9eb2eeb177637382", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzMjExMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408232111", "bodyText": "The following example uses the Constraint Verifier API to create a simple unit test for the preceding constrain stream:", "author": "emmurphy1", "createdAt": "2020-04-14T15:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMzMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMzgyOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408033829", "bodyText": "Docs (unlike blogs) should be formal and avoid \"Let's\".\n@emmurphy1 wdyt?", "author": "ge0ffrey", "createdAt": "2020-04-14T10:31:18Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,121 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the \"Horizontal conflict\" constraint gives a penalty of `1` when there are two queens on the\n+same row.\n+Let's take a look at the test in detail.", "originalCommit": "c6ea9faa91840c4b2706d77f9eb2eeb177637382", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzNjE0Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408236142", "bodyText": "Yes. Also, don't use \" to denote names. I would capitalize Horizontal Conflict. Or you can just make both l/c as I don't see that this is used elsewhere. Either is fine IMO.\nThis test ensures that the  horizontal conflict constraint assigns a penalty of 1 when there are two queens on the\nsame row.\nI would just delete the linking text Let's take a look at the test in detail.", "author": "emmurphy1", "createdAt": "2020-04-14T15:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMzgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzNjA0OA==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408036048", "bodyText": "Every? Are we sure? Also Spock (= very different from junit)?\nWe could mention Junit, AssertJ and maybe TestNG by name.\nHow about something like \"Constraint Verifier works with JUnit, AssertJ and many others.\"", "author": "ge0ffrey", "createdAt": "2020-04-14T10:35:07Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,121 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the \"Horizontal conflict\" constraint gives a penalty of `1` when there are two queens on the\n+same row.\n+Let's take a look at the test in detail.\n+The following line creates a shared `ConstraintVerifier` instance, initializing it with the `NQueensConstraintProvider`\n+that is being tested, as well as the planning solution (`NQueens`) and the planning entity (`Queen`).\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+----\n+\n+The `@Test` annotation indicates that the method is a unit test in a testing framework of your choice.\n+Constraint Verifier works with every unit testing framework.", "originalCommit": "c6ea9faa91840c4b2706d77f9eb2eeb177637382", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0MTI3NA==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408241274", "bodyText": "Mabye:\nConstraint Verifier works with many testing freameworks including JUnit and AssertJ.\nIn this case 'others' is implied.", "author": "emmurphy1", "createdAt": "2020-04-14T15:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzNjA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzNjE1Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408036156", "bodyText": "avoid \"we\"\nuse active tense \"Prepare two instances ...\"\nor in worst case, use \"you\". Never \"we\" or \"I\"", "author": "ge0ffrey", "createdAt": "2020-04-14T10:35:20Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,121 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the \"Horizontal conflict\" constraint gives a penalty of `1` when there are two queens on the\n+same row.\n+Let's take a look at the test in detail.\n+The following line creates a shared `ConstraintVerifier` instance, initializing it with the `NQueensConstraintProvider`\n+that is being tested, as well as the planning solution (`NQueens`) and the planning entity (`Queen`).\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+----\n+\n+The `@Test` annotation indicates that the method is a unit test in a testing framework of your choice.\n+Constraint Verifier works with every unit testing framework.\n+\n+First part of the test does nothing but prepare the test data.\n+In this case, we create two instances of the `Queen` planning entity and their dependencies (`Row`, `Column`):", "originalCommit": "c6ea9faa91840c4b2706d77f9eb2eeb177637382", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzNjczNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408036735", "bodyText": "do not use \"will\"\nuse present tense", "author": "ge0ffrey", "createdAt": "2020-04-14T10:36:25Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,121 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the \"Horizontal conflict\" constraint gives a penalty of `1` when there are two queens on the\n+same row.\n+Let's take a look at the test in detail.\n+The following line creates a shared `ConstraintVerifier` instance, initializing it with the `NQueensConstraintProvider`\n+that is being tested, as well as the planning solution (`NQueens`) and the planning entity (`Queen`).\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+----\n+\n+The `@Test` annotation indicates that the method is a unit test in a testing framework of your choice.\n+Constraint Verifier works with every unit testing framework.\n+\n+First part of the test does nothing but prepare the test data.\n+In this case, we create two instances of the `Queen` planning entity and their dependencies (`Row`, `Column`):\n+\n+[source,java,options=\"nowrap\"]\n+----\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+----\n+\n+Having done that, we can move on to testing the constraint:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+            .given(queen1, queen2)\n+            .penalizesBy(1);\n+----\n+\n+On the first line, we use the `verifyThat(...)` call to specify a method on the `NQueensConstraintProvider` class which\n+we want to test.\n+This method must be visible to the test class, which the Java compiler will enforce.", "originalCommit": "c6ea9faa91840c4b2706d77f9eb2eeb177637382", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "42af506526adbc73c6973061de95fbc1fcb53d03", "url": "https://github.com/kiegroup/optaplanner/commit/42af506526adbc73c6973061de95fbc1fcb53d03", "message": "Remove \"we\"", "committedDate": "2020-04-14T10:43:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0MDI5Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408240292", "bodyText": "The following line creates a shared ConstraintVerifier instance, initializing it with the NQueensConstraintProvider.\nWhat is 'it'? The ContraintVerifier?\nThe following line creates a shared ConstraintVerifier instance and initialized the instance with the NQueensConstraintProvider", "author": "emmurphy1", "createdAt": "2020-04-14T15:44:08Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,120 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the \"Horizontal conflict\" constraint gives a penalty of `1` when there are two queens on the\n+same row.\n+Let's take a look at the test in detail.\n+The following line creates a shared `ConstraintVerifier` instance, initializing it with the `NQueensConstraintProvider`", "originalCommit": "42af506526adbc73c6973061de95fbc1fcb53d03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0MTQ1Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408241453", "bodyText": "The first part of the test prepares the test data. In this case, the test data includes two instances of the Queen planning entity and their dependencies (Row, Column):", "author": "emmurphy1", "createdAt": "2020-04-14T15:45:41Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,120 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the \"Horizontal conflict\" constraint gives a penalty of `1` when there are two queens on the\n+same row.\n+Let's take a look at the test in detail.\n+The following line creates a shared `ConstraintVerifier` instance, initializing it with the `NQueensConstraintProvider`\n+that is being tested, as well as the planning solution (`NQueens`) and the planning entity (`Queen`).\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+----\n+\n+The `@Test` annotation indicates that the method is a unit test in a testing framework of your choice.\n+Constraint Verifier works with every unit testing framework.\n+\n+First part of the test prepares the test data.", "originalCommit": "42af506526adbc73c6973061de95fbc1fcb53d03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0MjU3NA==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408242574", "bodyText": "tests the constraint...", "author": "emmurphy1", "createdAt": "2020-04-14T15:47:11Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,120 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the \"Horizontal conflict\" constraint gives a penalty of `1` when there are two queens on the\n+same row.\n+Let's take a look at the test in detail.\n+The following line creates a shared `ConstraintVerifier` instance, initializing it with the `NQueensConstraintProvider`\n+that is being tested, as well as the planning solution (`NQueens`) and the planning entity (`Queen`).\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+----\n+\n+The `@Test` annotation indicates that the method is a unit test in a testing framework of your choice.\n+Constraint Verifier works with every unit testing framework.\n+\n+First part of the test prepares the test data.\n+In this case, two instances of the `Queen` planning entity and their dependencies (`Row`, `Column`):\n+\n+[source,java,options=\"nowrap\"]\n+----\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+----\n+\n+Further down, the following code test the constraint itself:", "originalCommit": "42af506526adbc73c6973061de95fbc1fcb53d03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0NDYzMw==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408244633", "bodyText": "In this case, the given(...) operates on the  queen1 and queen2 instances previously created.\nNot sure if operates is the correct verb. Substitute or rewrite if need. Just make sure you do include a verb.", "author": "emmurphy1", "createdAt": "2020-04-14T15:49:53Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,120 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the \"Horizontal conflict\" constraint gives a penalty of `1` when there are two queens on the\n+same row.\n+Let's take a look at the test in detail.\n+The following line creates a shared `ConstraintVerifier` instance, initializing it with the `NQueensConstraintProvider`\n+that is being tested, as well as the planning solution (`NQueens`) and the planning entity (`Queen`).\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+----\n+\n+The `@Test` annotation indicates that the method is a unit test in a testing framework of your choice.\n+Constraint Verifier works with every unit testing framework.\n+\n+First part of the test prepares the test data.\n+In this case, two instances of the `Queen` planning entity and their dependencies (`Row`, `Column`):\n+\n+[source,java,options=\"nowrap\"]\n+----\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+----\n+\n+Further down, the following code test the constraint itself:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+            .given(queen1, queen2)\n+            .penalizesBy(1);\n+----\n+\n+The `verifyThat(...)` call is used to specify a method on the `NQueensConstraintProvider` class which is under test.\n+This method must be visible to the test class, which the Java compiler will enforce.\n+\n+The `given(...)` call is used to enumerate all the facts that the constraint stream will operate on.\n+In this case, the `queen1` and `queen2` instances previously created.", "originalCommit": "42af506526adbc73c6973061de95fbc1fcb53d03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0NTEwMg==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408245102", "bodyText": "Don't use '' to set apart.", "author": "emmurphy1", "createdAt": "2020-04-14T15:50:34Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,120 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the \"Horizontal conflict\" constraint gives a penalty of `1` when there are two queens on the\n+same row.\n+Let's take a look at the test in detail.\n+The following line creates a shared `ConstraintVerifier` instance, initializing it with the `NQueensConstraintProvider`\n+that is being tested, as well as the planning solution (`NQueens`) and the planning entity (`Queen`).\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+----\n+\n+The `@Test` annotation indicates that the method is a unit test in a testing framework of your choice.\n+Constraint Verifier works with every unit testing framework.\n+\n+First part of the test prepares the test data.\n+In this case, two instances of the `Queen` planning entity and their dependencies (`Row`, `Column`):\n+\n+[source,java,options=\"nowrap\"]\n+----\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+----\n+\n+Further down, the following code test the constraint itself:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+            .given(queen1, queen2)\n+            .penalizesBy(1);\n+----\n+\n+The `verifyThat(...)` call is used to specify a method on the `NQueensConstraintProvider` class which is under test.\n+This method must be visible to the test class, which the Java compiler will enforce.\n+\n+The `given(...)` call is used to enumerate all the facts that the constraint stream will operate on.\n+In this case, the `queen1` and `queen2` instances previously created.\n+Alternatively, you can use a `givenSolution(...)` call here and provide a planning solution instead.\n+\n+Finally, the `penalizesBy(...)` call completes the test, making sure that the \"Horizontal conflict\" constraint, given\n+one `Queen`, results in a penalty of `1`.", "originalCommit": "42af506526adbc73c6973061de95fbc1fcb53d03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0NjQxNg==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408246416", "bodyText": "individual constraints\nyou can test the entire (remove also, redundant)\n...test the entire ConstraintProvider(what))?\nNoun needed after ConstraintProvider", "author": "emmurphy1", "createdAt": "2020-04-14T15:52:17Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,120 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the \"Horizontal conflict\" constraint gives a penalty of `1` when there are two queens on the\n+same row.\n+Let's take a look at the test in detail.\n+The following line creates a shared `ConstraintVerifier` instance, initializing it with the `NQueensConstraintProvider`\n+that is being tested, as well as the planning solution (`NQueens`) and the planning entity (`Queen`).\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+----\n+\n+The `@Test` annotation indicates that the method is a unit test in a testing framework of your choice.\n+Constraint Verifier works with every unit testing framework.\n+\n+First part of the test prepares the test data.\n+In this case, two instances of the `Queen` planning entity and their dependencies (`Row`, `Column`):\n+\n+[source,java,options=\"nowrap\"]\n+----\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+----\n+\n+Further down, the following code test the constraint itself:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+            .given(queen1, queen2)\n+            .penalizesBy(1);\n+----\n+\n+The `verifyThat(...)` call is used to specify a method on the `NQueensConstraintProvider` class which is under test.\n+This method must be visible to the test class, which the Java compiler will enforce.\n+\n+The `given(...)` call is used to enumerate all the facts that the constraint stream will operate on.\n+In this case, the `queen1` and `queen2` instances previously created.\n+Alternatively, you can use a `givenSolution(...)` call here and provide a planning solution instead.\n+\n+Finally, the `penalizesBy(...)` call completes the test, making sure that the \"Horizontal conflict\" constraint, given\n+one `Queen`, results in a penalty of `1`.\n+This number is a product of multiplying the match weight, as defined in the constraint stream, by the number of matches.\n+\n+Alternatively, you can use a `rewardsWith(...)` call to check for rewards instead of penalties.\n+The method to use here depends on whether the constraint stream in question is terminated with a `penalize` or a\n+`reward` building block.\n+\n+[[constraintStreamsIntegrationTesting]]\n+=== Integration testing\n+\n+In addition to testing individual constraint, you can also test the entire `ConstraintProvider`.", "originalCommit": "42af506526adbc73c6973061de95fbc1fcb53d03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0NzExMw==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408247113", "bodyText": "ConstraintProvider`  (what)\nTo illustrate, you correctly say the verifyThat() call. Need something similar for ConstraintProvider`", "author": "emmurphy1", "createdAt": "2020-04-14T15:53:14Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,120 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the \"Horizontal conflict\" constraint gives a penalty of `1` when there are two queens on the\n+same row.\n+Let's take a look at the test in detail.\n+The following line creates a shared `ConstraintVerifier` instance, initializing it with the `NQueensConstraintProvider`\n+that is being tested, as well as the planning solution (`NQueens`) and the planning entity (`Queen`).\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+----\n+\n+The `@Test` annotation indicates that the method is a unit test in a testing framework of your choice.\n+Constraint Verifier works with every unit testing framework.\n+\n+First part of the test prepares the test data.\n+In this case, two instances of the `Queen` planning entity and their dependencies (`Row`, `Column`):\n+\n+[source,java,options=\"nowrap\"]\n+----\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+----\n+\n+Further down, the following code test the constraint itself:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+            .given(queen1, queen2)\n+            .penalizesBy(1);\n+----\n+\n+The `verifyThat(...)` call is used to specify a method on the `NQueensConstraintProvider` class which is under test.\n+This method must be visible to the test class, which the Java compiler will enforce.\n+\n+The `given(...)` call is used to enumerate all the facts that the constraint stream will operate on.\n+In this case, the `queen1` and `queen2` instances previously created.\n+Alternatively, you can use a `givenSolution(...)` call here and provide a planning solution instead.\n+\n+Finally, the `penalizesBy(...)` call completes the test, making sure that the \"Horizontal conflict\" constraint, given\n+one `Queen`, results in a penalty of `1`.\n+This number is a product of multiplying the match weight, as defined in the constraint stream, by the number of matches.\n+\n+Alternatively, you can use a `rewardsWith(...)` call to check for rewards instead of penalties.\n+The method to use here depends on whether the constraint stream in question is terminated with a `penalize` or a\n+`reward` building block.\n+\n+[[constraintStreamsIntegrationTesting]]\n+=== Integration testing\n+\n+In addition to testing individual constraint, you can also test the entire `ConstraintProvider`.\n+Consider the following test:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    @Test\n+    public void givenFactsMultipleConstraints() {\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row2, column2);\n+        Queen queen3 = new Queen(2, row3, column3);\n+        constraintVerifier.verifyThat()\n+                .given(queen1, queen2, queen3)\n+                .scores(SimpleScore.of(-3));\n+    }\n+----\n+\n+There are only two notable differences to the previous example.\n+First, the `verifyThat()` call takes no argument here, signifying that the entire `ConstraintProvider` is being tested.", "originalCommit": "42af506526adbc73c6973061de95fbc1fcb53d03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0ODkzOA==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408248938", "bodyText": "Minor: I prefer ensure to make sure.", "author": "emmurphy1", "createdAt": "2020-04-14T15:55:37Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,120 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams come with a unit testing harness, called \"Constraint Verifier\".\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+This is how a simple unit test for this constraint looks, using the Constraint Verifier API:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the \"Horizontal conflict\" constraint gives a penalty of `1` when there are two queens on the\n+same row.\n+Let's take a look at the test in detail.\n+The following line creates a shared `ConstraintVerifier` instance, initializing it with the `NQueensConstraintProvider`\n+that is being tested, as well as the planning solution (`NQueens`) and the planning entity (`Queen`).\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+----\n+\n+The `@Test` annotation indicates that the method is a unit test in a testing framework of your choice.\n+Constraint Verifier works with every unit testing framework.\n+\n+First part of the test prepares the test data.\n+In this case, two instances of the `Queen` planning entity and their dependencies (`Row`, `Column`):\n+\n+[source,java,options=\"nowrap\"]\n+----\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+----\n+\n+Further down, the following code test the constraint itself:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+            .given(queen1, queen2)\n+            .penalizesBy(1);\n+----\n+\n+The `verifyThat(...)` call is used to specify a method on the `NQueensConstraintProvider` class which is under test.\n+This method must be visible to the test class, which the Java compiler will enforce.\n+\n+The `given(...)` call is used to enumerate all the facts that the constraint stream will operate on.\n+In this case, the `queen1` and `queen2` instances previously created.\n+Alternatively, you can use a `givenSolution(...)` call here and provide a planning solution instead.\n+\n+Finally, the `penalizesBy(...)` call completes the test, making sure that the \"Horizontal conflict\" constraint, given\n+one `Queen`, results in a penalty of `1`.\n+This number is a product of multiplying the match weight, as defined in the constraint stream, by the number of matches.\n+\n+Alternatively, you can use a `rewardsWith(...)` call to check for rewards instead of penalties.\n+The method to use here depends on whether the constraint stream in question is terminated with a `penalize` or a\n+`reward` building block.\n+\n+[[constraintStreamsIntegrationTesting]]\n+=== Integration testing\n+\n+In addition to testing individual constraint, you can also test the entire `ConstraintProvider`.\n+Consider the following test:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    @Test\n+    public void givenFactsMultipleConstraints() {\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row2, column2);\n+        Queen queen3 = new Queen(2, row3, column3);\n+        constraintVerifier.verifyThat()\n+                .given(queen1, queen2, queen3)\n+                .scores(SimpleScore.of(-3));\n+    }\n+----\n+\n+There are only two notable differences to the previous example.\n+First, the `verifyThat()` call takes no argument here, signifying that the entire `ConstraintProvider` is being tested.\n+Second, instead of either a `penalizesBy()` or `rewardsWith()` call, the `scores(...)` method is used.\n+This runs the `ConstraintProvider` on the given facts and returns a sum of `Score`s of all constraint matches resulting\n+from the given facts.\n+\n+Using this method, you can make sure that the constraint provider does not miss any constraints and that the scoring", "originalCommit": "42af506526adbc73c6973061de95fbc1fcb53d03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a9720897ab9d61e489ad3989b1031c42650849d5", "url": "https://github.com/kiegroup/optaplanner/commit/a9720897ab9d61e489ad3989b1031c42650849d5", "message": "Resolve review comments", "committedDate": "2020-04-14T18:21:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5OTMwOA==", "url": "https://github.com/kiegroup/optaplanner/pull/745#discussion_r408699308", "bodyText": "I am not 100% confortable with calling this \"integration testing\". It's definitely wider than testing a single constraint unit but it still just testing a ConstraintProvider unit, still far away from end-to-end integration testing on the spectrum.\nHow about we call this \"=== Testing all constraints together\" and add a subsection for the first part called \"=== Testing each constraint in isolation\"?", "author": "ge0ffrey", "createdAt": "2020-04-15T09:17:52Z", "path": "optaplanner-docs/src/main/asciidoc/ConstraintStreams/ConstraintStreams-chapter.adoc", "diffHunk": "@@ -574,6 +574,122 @@ the stream.\n ====\n \n \n+[[constraintStreamsTesting]]\n+== Testing a constraint stream\n+\n+Constraint streams include the Constraint Verifier unit testing harness.\n+Consider the following constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    protected Constraint horizontalConflict(ConstraintFactory factory) {\n+        return factory\n+                .fromUniquePair(Queen.class, equal(Queen::getRowIndex))\n+                .penalize(\"Horizontal conflict\", SimpleScore.ONE);\n+    }\n+----\n+\n+The following example uses the Constraint Verifier API to create a simple unit test for the preceding constraint stream:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+\n+    @Test\n+    public void horizontalConflictWithTwoQueens() {\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+        constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+                .given(queen1, queen2)\n+                .penalizesBy(1);\n+    }\n+----\n+\n+This test ensures that the horizontal conflict constraint assigns a penalty of `1` when there are two queens on the same\n+row.\n+The following line creates a shared `ConstraintVerifier` instance and initializes the instance with the\n+`NQueensConstraintProvider`:\n+\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    private ConstraintVerifier<NQueensConstraintProvider, NQueens> constraintVerifier\n+            = ConstraintVerifier.build(new NQueensConstraintProvider(), NQueens.class, Queen.class);\n+----\n+\n+The `@Test` annotation indicates that the method is a unit test in a testing framework of your choice.\n+Constraint Verifier works with many testing frameworks including JUnit and AssertJ.\n+\n+The first part of the test prepares the test data.\n+In this case, the test data includes two instances of the `Queen` planning entity and their dependencies\n+(`Row`, `Column`):\n+\n+[source,java,options=\"nowrap\"]\n+----\n+        Row row1 = new Row(0);\n+        Column column1 = new Column(0);\n+        Column column2 = new Column(1);\n+        Queen queen1 = new Queen(0, row1, column1);\n+        Queen queen2 = new Queen(1, row1, column2);\n+----\n+\n+Further down, the following code test the constraint:\n+\n+[source,java,options=\"nowrap\"]\n+----\n+    constraintVerifier.verifyThat(NQueensConstraintProvider::horizontalConflict)\n+            .given(queen1, queen2)\n+            .penalizesBy(1);\n+----\n+\n+The `verifyThat(...)` call is used to specify a method on the `NQueensConstraintProvider` class which is under test.\n+This method must be visible to the test class, which the Java compiler will enforce.\n+\n+The `given(...)` call is used to enumerate all the facts that the constraint stream will operate on.\n+In this case, the `given(...)` call takes the `queen1` and `queen2` instances previously created.\n+Alternatively, you can use a `givenSolution(...)` method here and provide a planning solution instead.\n+\n+Finally, the `penalizesBy(...)` call completes the test, making sure that the horizontal conflict constraint, given\n+one `Queen`, results in a penalty of `1`.\n+This number is a product of multiplying the match weight, as defined in the constraint stream, by the number of matches.\n+\n+Alternatively, you can use a `rewardsWith(...)` call to check for rewards instead of penalties.\n+The method to use here depends on whether the constraint stream in question is terminated with a `penalize` or a\n+`reward` building block.\n+\n+[[constraintStreamsIntegrationTesting]]\n+=== Integration testing", "originalCommit": "a9720897ab9d61e489ad3989b1031c42650849d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}