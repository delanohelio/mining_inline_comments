{"pr_number": 2676, "pr_title": "Allow specifying PropagationPolicy when using deleteExisting", "pr_createdAt": "2020-12-17T15:30:50Z", "pr_url": "https://github.com/fabric8io/kubernetes-client/pull/2676", "timeline": [{"oid": "49d2eae7dbde5f871066ed5098498a162d5d11f1", "url": "https://github.com/fabric8io/kubernetes-client/commit/49d2eae7dbde5f871066ed5098498a162d5d11f1", "message": "Make PropagationPolicy configurable when deletingExisting is configured", "committedDate": "2020-12-17T16:02:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMwNTk0MA==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2676#discussion_r545305940", "bodyText": "I don't think this is related to my original change to support PropagationPolicy, but my new integration test caught this issue. The default grace period is 30s, so unless you explicitly specify 0 seconds (which we don't here and probably shouldn't if we could) it's possible that the DELETE call returns a 202 instead of 200, meaning it hasn't actually been deleted yet.\nBaseOperation/OperationSupport/etc assume that a non-error response means the item was deleted. This is sort of true, but not really since it may have actually been queued for asynchronous deletion (per the 202 response). I looked into whether I could pipe the response Status through as the return value of the various delete() functions, but that proved to be a significant change (and probably a breaking one, since right now we expect to return a simple Boolean).\nThe simpler fix here seems to be to add a waiting period as I did here. Alternatively we could continually retry createTask for a period of time, but this might be less impactful on API servers?", "author": "bbeaudreault", "createdAt": "2020-12-17T18:23:38Z", "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/utils/DeleteAndCreateHelper.java", "diffHunk": "@@ -40,15 +50,40 @@ public T deleteAndCreate(T item) {\n     if (Boolean.FALSE.equals(deleted)) {\n       throw new KubernetesClientException(\"Failed to delete existing item:\" + item.getMetadata().getName());\n     }\n-    return createTask.apply(item);\n+    try {\n+      return createTask.apply(item);\n+    } catch (KubernetesClientException e) {", "originalCommit": "63d9f26fd266db032addc26d4823746a184fff19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "173ab63c4a711bfff3a3ad1f5254d366a38176f8", "url": "https://github.com/fabric8io/kubernetes-client/commit/173ab63c4a711bfff3a3ad1f5254d366a38176f8", "message": "Make PropagationPolicy configurable when deletingExisting is configured\n\nawait for deletion if the just-deleted resource still exists when trying to create", "committedDate": "2020-12-17T21:12:00Z", "type": "commit"}, {"oid": "173ab63c4a711bfff3a3ad1f5254d366a38176f8", "url": "https://github.com/fabric8io/kubernetes-client/commit/173ab63c4a711bfff3a3ad1f5254d366a38176f8", "message": "Make PropagationPolicy configurable when deletingExisting is configured\n\nawait for deletion if the just-deleted resource still exists when trying to create", "committedDate": "2020-12-17T21:12:00Z", "type": "forcePushed"}, {"oid": "c7ae84f3cdd9bba65c0a9ec370069cbbea0b79dd", "url": "https://github.com/fabric8io/kubernetes-client/commit/c7ae84f3cdd9bba65c0a9ec370069cbbea0b79dd", "message": "Merge branch 'master' into propagation-policy-delete-existing", "committedDate": "2020-12-18T12:04:01Z", "type": "commit"}, {"oid": "7903ebee2d26a83bf8481fa6a5c5a5a258eb9289", "url": "https://github.com/fabric8io/kubernetes-client/commit/7903ebee2d26a83bf8481fa6a5c5a5a258eb9289", "message": "trigger build", "committedDate": "2020-12-18T13:06:36Z", "type": "commit"}, {"oid": "2703800ee7b9a7b535e79fb4195d367050074d12", "url": "https://github.com/fabric8io/kubernetes-client/commit/2703800ee7b9a7b535e79fb4195d367050074d12", "message": "fix resource test. fix DeleteAndCreateHelper so we don't fail on deleted=false, and update tests", "committedDate": "2020-12-18T23:08:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5OTI5MA==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2676#discussion_r546199290", "bodyText": "Is this comment still accurate?", "author": "metacosm", "createdAt": "2020-12-19T06:21:00Z", "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/utils/DeleteAndCreateHelper.java", "diffHunk": "@@ -23,32 +23,75 @@\n import io.fabric8.kubernetes.client.ResourceHandler;\n import okhttp3.OkHttpClient;\n \n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n import java.util.function.Function;\n import java.util.function.UnaryOperator;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n public class DeleteAndCreateHelper<T extends HasMetadata> {\n+  private static final Logger LOG = LoggerFactory.getLogger(DeleteAndCreateHelper.class);\n+\n   private final UnaryOperator<T> createTask;\n+  private final Function<T, Boolean> awaitDeleteTask;\n   private final Function<T, Boolean> deleteTask;\n \n-  public DeleteAndCreateHelper(UnaryOperator<T> createTask, Function<T, Boolean> deleteTask) {\n+  public DeleteAndCreateHelper(UnaryOperator<T> createTask, Function<T, Boolean> deleteTask, Function<T, Boolean> awaitDeleteTask) {\n     this.createTask = createTask;\n+    this.awaitDeleteTask = awaitDeleteTask;\n     this.deleteTask = deleteTask;\n   }\n \n   public T deleteAndCreate(T item) {\n     Boolean deleted = deleteTask.apply(item);\n-    if (Boolean.FALSE.equals(deleted)) {\n-      throw new KubernetesClientException(\"Failed to delete existing item:\" + item.getMetadata().getName());\n+    if (!deleted) {\n+      LOG.debug(\"did not delete because item did not exist, continuing to create {}\", item.getMetadata().getName());\n+    }\n+\n+    try {\n+      return createTask.apply(item);\n+    } catch (KubernetesClientException e) {\n+      // depending on the grace period, the object might not actually be deleted by the time we try to create\n+      // if that's the case, give it some time.", "originalCommit": "2703800ee7b9a7b535e79fb4195d367050074d12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIyODAyMw==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2676#discussion_r546228023", "bodyText": "Yes, still accurate. All of the stuff I mentioned about DELETE returning a 200 or 202 still applies. So we still need to wait for the deletion to occur before creating, otherwise we'll get a conflict.", "author": "bbeaudreault", "createdAt": "2020-12-19T11:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5OTI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1MTQzMg==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2676#discussion_r546651432", "bodyText": "It would make sense to at least declare 30 as a static constant.", "author": "manusa", "createdAt": "2020-12-21T11:21:03Z", "path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/utils/DeleteAndCreateHelper.java", "diffHunk": "@@ -23,32 +23,75 @@\n import io.fabric8.kubernetes.client.ResourceHandler;\n import okhttp3.OkHttpClient;\n \n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n import java.util.function.Function;\n import java.util.function.UnaryOperator;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n public class DeleteAndCreateHelper<T extends HasMetadata> {\n+  private static final Logger LOG = LoggerFactory.getLogger(DeleteAndCreateHelper.class);\n+\n   private final UnaryOperator<T> createTask;\n+  private final Function<T, Boolean> awaitDeleteTask;\n   private final Function<T, Boolean> deleteTask;\n \n-  public DeleteAndCreateHelper(UnaryOperator<T> createTask, Function<T, Boolean> deleteTask) {\n+  public DeleteAndCreateHelper(UnaryOperator<T> createTask, Function<T, Boolean> deleteTask, Function<T, Boolean> awaitDeleteTask) {\n     this.createTask = createTask;\n+    this.awaitDeleteTask = awaitDeleteTask;\n     this.deleteTask = deleteTask;\n   }\n \n   public T deleteAndCreate(T item) {\n     Boolean deleted = deleteTask.apply(item);\n-    if (Boolean.FALSE.equals(deleted)) {\n-      throw new KubernetesClientException(\"Failed to delete existing item:\" + item.getMetadata().getName());\n+    if (!deleted) {\n+      LOG.debug(\"did not delete because item did not exist, continuing to create {}\", item.getMetadata().getName());\n+    }\n+\n+    try {\n+      return createTask.apply(item);\n+    } catch (KubernetesClientException e) {\n+      // depending on the grace period, the object might not actually be deleted by the time we try to create\n+      // if that's the case, give it some time.\n+      if (e.getCode() == HttpURLConnection.HTTP_CONFLICT) {\n+        if (!deleted) {\n+          LOG.error(\"there was no item to delete, but received HTTP_CONFLICT response upon creation of item {}\", item.getMetadata().getName(), e);\n+          throw e;\n+        }\n+\n+        if (Boolean.FALSE.equals(awaitDeleteTask.apply(item))) {\n+          throw new KubernetesClientException(\"Timed out waiting for item to be deleted before recreating: \" + item.getMetadata().getName(), e);\n+        }\n+\n+        return createTask.apply(item);\n+      }\n+\n+      throw e;\n     }\n-    return createTask.apply(item);\n   }\n \n   public static HasMetadata deleteAndCreateItem(OkHttpClient client, Config config, HasMetadata meta, ResourceHandler<HasMetadata, HasMetadataVisitiableBuilder> h, String namespaceToUse, DeletionPropagation propagationPolicy) {\n     DeleteAndCreateHelper<HasMetadata> deleteAndCreateHelper = new DeleteAndCreateHelper<>(\n       m -> h.create(client, config, namespaceToUse, m),\n-      m -> h.delete(client, config, namespaceToUse, propagationPolicy, m)\n+      m -> h.delete(client, config, namespaceToUse, propagationPolicy, m),\n+      waitUntilDeletedOrInterrupted(client, config, h, namespaceToUse)\n     );\n \n     return deleteAndCreateHelper.deleteAndCreate(meta);\n   }\n+\n+  private static <T extends HasMetadata> Function<T, Boolean> waitUntilDeletedOrInterrupted(OkHttpClient client, Config config, ResourceHandler<HasMetadata, HasMetadataVisitiableBuilder> h, String namespaceToUse) {\n+    return m -> {\n+      try {\n+        return h.waitUntilCondition(client, config, namespaceToUse, m, Objects::isNull, 30 , TimeUnit.SECONDS) == null;", "originalCommit": "2703800ee7b9a7b535e79fb4195d367050074d12", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7d3a46e9f22eddf2bb39432f7f86d2f66336f3b2", "url": "https://github.com/fabric8io/kubernetes-client/commit/7d3a46e9f22eddf2bb39432f7f86d2f66336f3b2", "message": "Make it a constant", "committedDate": "2020-12-21T12:00:36Z", "type": "commit"}]}