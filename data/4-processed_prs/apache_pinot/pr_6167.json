{"pr_number": 6167, "pr_title": "Support reloading upsert table", "pr_createdAt": "2020-10-21T01:50:05Z", "pr_url": "https://github.com/apache/pinot/pull/6167", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5MTAxMA==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r508991010", "bodyText": "Not sure if this old segment check is necessary:\n\nsince the old segment will be replaced, it shall be safe to update the valid doc, since it will be gone anyway?\nif so, then the handling is identical to the branch above, and therefore can be merged?", "author": "yupeng9", "createdAt": "2020-10-21T05:02:01Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -29,97 +30,142 @@\n \n /**\n  * Manages the upsert metadata per partition.\n+ * <p>For multiple records with the same timestamp, there is no guarantee on which record to be preserved.\n+ * <p>There will be short term inconsistency when updating the upsert metadata, but should be consistent after the\n+ * operation is done:\n+ * <ul>\n+ *   <li>\n+ *     When updating a new record, it first removes the doc id from the current location, then update the new location.\n+ *   </li>\n+ *   <li>\n+ *     When adding a new segment, it removes the doc ids from the current locations before the segment being added to\n+ *     the RealtimeTableDataManager.\n+ *   </li>\n+ *   <li>\n+ *     When replacing an existing segment, the updates applied to the new segment won't be reflected to the replaced\n+ *     segment.\n+ *   </li>\n+ * </ul>\n  */\n @ThreadSafe\n public class PartitionUpsertMetadataManager {\n   private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n \n   // TODO(upset): consider an off-heap KV store to persist this index to improve the recovery speed.\n-  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap =\n-      new ConcurrentHashMap<>();\n-  // the mapping between the (sealed) segment and its validDocuments\n-  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIdsMap =\n-      new ConcurrentHashMap<>();\n+  @VisibleForTesting\n+  final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap = new ConcurrentHashMap<>();\n \n   /**\n-   * Creates the valid doc ids for the given (immutable) segment.\n+   * Initializes the upsert metadata for the given immutable segment, returns the valid doc ids for the segment.\n    */\n-  public ThreadSafeMutableRoaringBitmap createValidDocIds(String segmentName) {\n-    LOGGER.info(\"Creating valid doc ids for segment: {}\", segmentName);\n+  public ThreadSafeMutableRoaringBitmap addSegment(String segmentName, Iterator<RecordInfo> recordInfoIterator) {\n+    LOGGER.info(\"Adding upsert metadata for segment: {}\", segmentName);\n+\n     ThreadSafeMutableRoaringBitmap validDocIds = new ThreadSafeMutableRoaringBitmap();\n-    if (_segmentToValidDocIdsMap.put(segmentName, validDocIds) != null) {\n-      LOGGER.warn(\"Valid doc ids exist for segment: {}, replacing it\", segmentName);\n+    while (recordInfoIterator.hasNext()) {\n+      RecordInfo recordInfo = recordInfoIterator.next();\n+      _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+        if (currentRecordLocation != null) {\n+          // Existing primary key\n+\n+          if (segmentName.equals(currentRecordLocation.getSegmentName())) {\n+            // The current record location has the same segment name\n+\n+            if (validDocIds == currentRecordLocation.getValidDocIds()) {\n+              // The current record location is pointing to the new segment being loaded\n+\n+              // Update the record location when getting a newer timestamp\n+              if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+                validDocIds.remove(currentRecordLocation.getDocId());\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            } else {\n+              // The current record location is pointing to the old segment being replaced. This could happen when\n+              // committing a consuming segment, or reloading a completed segment.\n+\n+              // Update the record location when the new timestamp is greater than or equal to the current timestamp.\n+              // Update the record location when there is a tie because the record locations should point to the new\n+              // segment instead of the old segment being replaced. Also, do not update the valid doc ids for the old\n+              // segment because it has not been replaced yet.", "originalCommit": "60b932cf4bdd7c903e168d0f473151428a7db60f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUzNTg1MA==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509535850", "bodyText": "When we commit a consuming segment, or reload a completed segment, the data will be identical (could be re-ordered). If we update the valid doc, before we replace the old segment in the data manager, all the docs in the old segment will be invalidated. Even though it can recover after the segment is replaced, we will observe data loss before that.", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5MTAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MTE5MQ==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509741191", "bodyText": "ah I see. So the window could be until the segment seal. Makes sense.", "author": "yupeng9", "createdAt": "2020-10-21T22:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5MTAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5MzExNA==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r508993114", "bodyText": "wrap this in the else branch for better readability.", "author": "yupeng9", "createdAt": "2020-10-21T05:10:04Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -29,97 +30,142 @@\n \n /**\n  * Manages the upsert metadata per partition.\n+ * <p>For multiple records with the same timestamp, there is no guarantee on which record to be preserved.\n+ * <p>There will be short term inconsistency when updating the upsert metadata, but should be consistent after the\n+ * operation is done:\n+ * <ul>\n+ *   <li>\n+ *     When updating a new record, it first removes the doc id from the current location, then update the new location.\n+ *   </li>\n+ *   <li>\n+ *     When adding a new segment, it removes the doc ids from the current locations before the segment being added to\n+ *     the RealtimeTableDataManager.\n+ *   </li>\n+ *   <li>\n+ *     When replacing an existing segment, the updates applied to the new segment won't be reflected to the replaced\n+ *     segment.\n+ *   </li>\n+ * </ul>\n  */\n @ThreadSafe\n public class PartitionUpsertMetadataManager {\n   private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n \n   // TODO(upset): consider an off-heap KV store to persist this index to improve the recovery speed.\n-  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap =\n-      new ConcurrentHashMap<>();\n-  // the mapping between the (sealed) segment and its validDocuments\n-  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIdsMap =\n-      new ConcurrentHashMap<>();\n+  @VisibleForTesting\n+  final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap = new ConcurrentHashMap<>();\n \n   /**\n-   * Creates the valid doc ids for the given (immutable) segment.\n+   * Initializes the upsert metadata for the given immutable segment, returns the valid doc ids for the segment.\n    */\n-  public ThreadSafeMutableRoaringBitmap createValidDocIds(String segmentName) {\n-    LOGGER.info(\"Creating valid doc ids for segment: {}\", segmentName);\n+  public ThreadSafeMutableRoaringBitmap addSegment(String segmentName, Iterator<RecordInfo> recordInfoIterator) {\n+    LOGGER.info(\"Adding upsert metadata for segment: {}\", segmentName);\n+\n     ThreadSafeMutableRoaringBitmap validDocIds = new ThreadSafeMutableRoaringBitmap();\n-    if (_segmentToValidDocIdsMap.put(segmentName, validDocIds) != null) {\n-      LOGGER.warn(\"Valid doc ids exist for segment: {}, replacing it\", segmentName);\n+    while (recordInfoIterator.hasNext()) {\n+      RecordInfo recordInfo = recordInfoIterator.next();\n+      _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+        if (currentRecordLocation != null) {\n+          // Existing primary key\n+\n+          if (segmentName.equals(currentRecordLocation.getSegmentName())) {\n+            // The current record location has the same segment name\n+\n+            if (validDocIds == currentRecordLocation.getValidDocIds()) {\n+              // The current record location is pointing to the new segment being loaded\n+\n+              // Update the record location when getting a newer timestamp\n+              if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+                validDocIds.remove(currentRecordLocation.getDocId());\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            } else {\n+              // The current record location is pointing to the old segment being replaced. This could happen when\n+              // committing a consuming segment, or reloading a completed segment.\n+\n+              // Update the record location when the new timestamp is greater than or equal to the current timestamp.\n+              // Update the record location when there is a tie because the record locations should point to the new\n+              // segment instead of the old segment being replaced. Also, do not update the valid doc ids for the old\n+              // segment because it has not been replaced yet.\n+              if (recordInfo._timestamp >= currentRecordLocation.getTimestamp()) {\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            }\n+            return currentRecordLocation;\n+          }\n+\n+          // Update the record location when getting a newer timestamp", "originalCommit": "60b932cf4bdd7c903e168d0f473151428a7db60f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU0NjQ4Nw==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509546487", "bodyText": "Good point, done", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5MzExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5NDAzOA==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r508994038", "bodyText": "Is it possible that this immutable segment is queried before the enableUpsert  is invoked?\nIf so, _validDocIndex  will be null and confuse the query plan", "author": "yupeng9", "createdAt": "2020-10-21T05:13:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/immutable/ImmutableSegmentImpl.java", "diffHunk": "@@ -50,25 +51,29 @@\n   private final SegmentMetadataImpl _segmentMetadata;\n   private final Map<String, ColumnIndexContainer> _indexContainerMap;\n   private final StarTreeIndexContainer _starTreeIndexContainer;\n-  private final PartitionUpsertMetadataManager _partitionUpsertMetadataManager;\n-  private final ValidDocIndexReader _validDocIndex;\n+\n+  // For upsert\n+  private PartitionUpsertMetadataManager _partitionUpsertMetadataManager;\n+  private ThreadSafeMutableRoaringBitmap _validDocIds;\n+  private ValidDocIndexReader _validDocIndex;\n \n   public ImmutableSegmentImpl(SegmentDirectory segmentDirectory, SegmentMetadataImpl segmentMetadata,\n       Map<String, ColumnIndexContainer> columnIndexContainerMap,\n-      @Nullable StarTreeIndexContainer starTreeIndexContainer,\n-      @Nullable PartitionUpsertMetadataManager partitionUpsertMetadataManager) {\n+      @Nullable StarTreeIndexContainer starTreeIndexContainer) {\n     _segmentDirectory = segmentDirectory;\n     _segmentMetadata = segmentMetadata;\n     _indexContainerMap = columnIndexContainerMap;\n     _starTreeIndexContainer = starTreeIndexContainer;\n-    if (partitionUpsertMetadataManager != null) {\n-      _partitionUpsertMetadataManager = partitionUpsertMetadataManager;\n-      _validDocIndex =\n-          new ValidDocIndexReaderImpl(partitionUpsertMetadataManager.createValidDocIds(getSegmentName()));\n-    } else {\n-      _partitionUpsertMetadataManager = null;\n-      _validDocIndex = null;\n-    }\n+  }\n+\n+  /**\n+   * Enables upsert for this segment.\n+   */\n+  public void enableUpsert(PartitionUpsertMetadataManager partitionUpsertMetadataManager,\n+      ThreadSafeMutableRoaringBitmap validDocIds) {\n+    _partitionUpsertMetadataManager = partitionUpsertMetadataManager;\n+    _validDocIds = validDocIds;\n+    _validDocIndex = new ValidDocIndexReaderImpl(validDocIds);", "originalCommit": "60b932cf4bdd7c903e168d0f473151428a7db60f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUzNjc2NA==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509536764", "bodyText": "No, the enableUpsert is called before adding the segment to the data manager.\nWill add more javadoc stating that", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5NDAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5NjUyOA==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r508996528", "bodyText": "does this check the case that a replaced segment shall not remove the keys of the newly loaded? Perhaps we shall consider a state of tracking the current segmentImpl (and its corresponding validDocIds) for a segment name?", "author": "yupeng9", "createdAt": "2020-10-21T05:21:52Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -29,97 +30,142 @@\n \n /**\n  * Manages the upsert metadata per partition.\n+ * <p>For multiple records with the same timestamp, there is no guarantee on which record to be preserved.\n+ * <p>There will be short term inconsistency when updating the upsert metadata, but should be consistent after the\n+ * operation is done:\n+ * <ul>\n+ *   <li>\n+ *     When updating a new record, it first removes the doc id from the current location, then update the new location.\n+ *   </li>\n+ *   <li>\n+ *     When adding a new segment, it removes the doc ids from the current locations before the segment being added to\n+ *     the RealtimeTableDataManager.\n+ *   </li>\n+ *   <li>\n+ *     When replacing an existing segment, the updates applied to the new segment won't be reflected to the replaced\n+ *     segment.\n+ *   </li>\n+ * </ul>\n  */\n @ThreadSafe\n public class PartitionUpsertMetadataManager {\n   private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n \n   // TODO(upset): consider an off-heap KV store to persist this index to improve the recovery speed.\n-  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap =\n-      new ConcurrentHashMap<>();\n-  // the mapping between the (sealed) segment and its validDocuments\n-  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIdsMap =\n-      new ConcurrentHashMap<>();\n+  @VisibleForTesting\n+  final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap = new ConcurrentHashMap<>();\n \n   /**\n-   * Creates the valid doc ids for the given (immutable) segment.\n+   * Initializes the upsert metadata for the given immutable segment, returns the valid doc ids for the segment.\n    */\n-  public ThreadSafeMutableRoaringBitmap createValidDocIds(String segmentName) {\n-    LOGGER.info(\"Creating valid doc ids for segment: {}\", segmentName);\n+  public ThreadSafeMutableRoaringBitmap addSegment(String segmentName, Iterator<RecordInfo> recordInfoIterator) {\n+    LOGGER.info(\"Adding upsert metadata for segment: {}\", segmentName);\n+\n     ThreadSafeMutableRoaringBitmap validDocIds = new ThreadSafeMutableRoaringBitmap();\n-    if (_segmentToValidDocIdsMap.put(segmentName, validDocIds) != null) {\n-      LOGGER.warn(\"Valid doc ids exist for segment: {}, replacing it\", segmentName);\n+    while (recordInfoIterator.hasNext()) {\n+      RecordInfo recordInfo = recordInfoIterator.next();\n+      _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+        if (currentRecordLocation != null) {\n+          // Existing primary key\n+\n+          if (segmentName.equals(currentRecordLocation.getSegmentName())) {\n+            // The current record location has the same segment name\n+\n+            if (validDocIds == currentRecordLocation.getValidDocIds()) {\n+              // The current record location is pointing to the new segment being loaded\n+\n+              // Update the record location when getting a newer timestamp\n+              if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+                validDocIds.remove(currentRecordLocation.getDocId());\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            } else {\n+              // The current record location is pointing to the old segment being replaced. This could happen when\n+              // committing a consuming segment, or reloading a completed segment.\n+\n+              // Update the record location when the new timestamp is greater than or equal to the current timestamp.\n+              // Update the record location when there is a tie because the record locations should point to the new\n+              // segment instead of the old segment being replaced. Also, do not update the valid doc ids for the old\n+              // segment because it has not been replaced yet.\n+              if (recordInfo._timestamp >= currentRecordLocation.getTimestamp()) {\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            }\n+            return currentRecordLocation;\n+          }\n+\n+          // Update the record location when getting a newer timestamp\n+          if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+            currentRecordLocation.getValidDocIds().remove(currentRecordLocation.getDocId());\n+            validDocIds.add(recordInfo._docId);\n+            return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+          } else {\n+            return currentRecordLocation;\n+          }\n+        } else {\n+          // New primary key\n+          validDocIds.add(recordInfo._docId);\n+          return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+        }\n+      });\n     }\n     return validDocIds;\n   }\n \n   /**\n-   * Returns the valid doc ids for the given (immutable) segment.\n-   */\n-  public ThreadSafeMutableRoaringBitmap getValidDocIds(String segmentName) {\n-    return Preconditions\n-        .checkNotNull(_segmentToValidDocIdsMap.get(segmentName), \"Failed to find valid doc ids for segment: %s\",\n-            segmentName);\n-  }\n-\n-  /**\n-   * Updates the record location of the given primary key if the given record location is newer than the current record\n-   * location. Also updates the valid doc ids accordingly if the record location is updated.\n+   * Updates the upsert metadata for a new consumed record in the given consuming segment.\n    */\n-  public void updateRecordLocation(PrimaryKey primaryKey, RecordLocation recordLocation,\n+  public synchronized void updateRecord(String segmentName, RecordInfo recordInfo,\n       ThreadSafeMutableRoaringBitmap validDocIds) {\n-    _primaryKeyToRecordLocationMap.compute(primaryKey, (k, v) -> {\n-      if (v != null) {\n+    _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+      if (currentRecordLocation != null) {\n         // Existing primary key\n \n-        if (recordLocation.getTimestamp() >= v.getTimestamp()) {\n-          // Update the record location\n-          // NOTE: Update the record location when there is a tie on the timestamp because during the segment\n-          //       commitment, when loading the committed segment, it should replace the old record locations in case\n-          //       the order of records changed.\n-\n-          // Remove the doc from the valid doc ids of the previous location\n-          if (v.isConsuming()) {\n-            // Previous location is a consuming segment, whose valid doc ids are maintained locally. Only update the\n-            // valid doc ids when the update is from the same segment.\n-            if (recordLocation.isConsuming() && recordLocation.getSegmentName().equals(v.getSegmentName())) {\n-              validDocIds.remove(v.getDocId());\n-            }\n-          } else {\n-            ThreadSafeMutableRoaringBitmap validDocIdsForPreviousLocation =\n-                _segmentToValidDocIdsMap.get(v.getSegmentName());\n-            if (validDocIdsForPreviousLocation != null) {\n-              validDocIdsForPreviousLocation.remove(v.getDocId());\n-            } else {\n-              LOGGER.warn(\"Failed to find valid doc ids for previous location: {}\", v.getSegmentName());\n-            }\n-          }\n-\n-          validDocIds.add(recordLocation.getDocId());\n-          return recordLocation;\n+        // Update the record location when getting a newer timestamp\n+        if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+          currentRecordLocation.getValidDocIds().remove(currentRecordLocation.getDocId());\n+          validDocIds.add(recordInfo._docId);\n+          return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n         } else {\n-          // No need to update\n-          return v;\n+          return currentRecordLocation;\n         }\n       } else {\n         // New primary key\n-        validDocIds.add(recordLocation.getDocId());\n-        return recordLocation;\n+        validDocIds.add(recordInfo._docId);\n+        return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n       }\n     });\n   }\n \n   /**\n-   * Removes the upsert metadata for the given segment.\n+   * Removes the upsert metadata for the given immutable segment. No need to remove the upsert metadata for the\n+   * consuming segment because it should be replaced by the committed segment.\n    */\n-  public void removeSegment(String segmentName) {\n+  public synchronized void removeSegment(String segmentName, ThreadSafeMutableRoaringBitmap validDocIds) {\n     LOGGER.info(\"Removing upsert metadata for segment: {}\", segmentName);\n-    _primaryKeyToRecordLocationMap.forEach((k, v) -> {\n-      if (v.getSegmentName().equals(segmentName)) {\n-        // NOTE: Check and remove to prevent removing the key that is just updated.\n-        _primaryKeyToRecordLocationMap.remove(k, v);\n-      }\n-    });\n-    _segmentToValidDocIdsMap.remove(segmentName);\n+\n+    if (!validDocIds.getMutableRoaringBitmap().isEmpty()) {", "originalCommit": "60b932cf4bdd7c903e168d0f473151428a7db60f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1MTAxNw==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509551017", "bodyText": "Yes, it removes the entry only when the reference of the valid doc ids are the same. It won't touch the upsert metadata for other segments.", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5NjUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMDI4NA==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509000284", "bodyText": "it's worth explaining this a bit on which data structures won't be reflected.", "author": "yupeng9", "createdAt": "2020-10-21T05:34:33Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -29,97 +30,142 @@\n \n /**\n  * Manages the upsert metadata per partition.\n+ * <p>For multiple records with the same timestamp, there is no guarantee on which record to be preserved.\n+ * <p>There will be short term inconsistency when updating the upsert metadata, but should be consistent after the\n+ * operation is done:\n+ * <ul>\n+ *   <li>\n+ *     When updating a new record, it first removes the doc id from the current location, then update the new location.\n+ *   </li>\n+ *   <li>\n+ *     When adding a new segment, it removes the doc ids from the current locations before the segment being added to\n+ *     the RealtimeTableDataManager.\n+ *   </li>\n+ *   <li>\n+ *     When replacing an existing segment, the updates applied to the new segment won't be reflected to the replaced", "originalCommit": "60b932cf4bdd7c903e168d0f473151428a7db60f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU0NTIzOQ==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509545239", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:18:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMDI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMDk1MQ==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509000951", "bodyText": "how is consuming segment related?", "author": "yupeng9", "createdAt": "2020-10-21T05:36:37Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManager.java", "diffHunk": "@@ -29,97 +30,142 @@\n \n /**\n  * Manages the upsert metadata per partition.\n+ * <p>For multiple records with the same timestamp, there is no guarantee on which record to be preserved.\n+ * <p>There will be short term inconsistency when updating the upsert metadata, but should be consistent after the\n+ * operation is done:\n+ * <ul>\n+ *   <li>\n+ *     When updating a new record, it first removes the doc id from the current location, then update the new location.\n+ *   </li>\n+ *   <li>\n+ *     When adding a new segment, it removes the doc ids from the current locations before the segment being added to\n+ *     the RealtimeTableDataManager.\n+ *   </li>\n+ *   <li>\n+ *     When replacing an existing segment, the updates applied to the new segment won't be reflected to the replaced\n+ *     segment.\n+ *   </li>\n+ * </ul>\n  */\n @ThreadSafe\n public class PartitionUpsertMetadataManager {\n   private static final Logger LOGGER = LoggerFactory.getLogger(PartitionUpsertMetadataManager.class);\n \n   // TODO(upset): consider an off-heap KV store to persist this index to improve the recovery speed.\n-  private final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap =\n-      new ConcurrentHashMap<>();\n-  // the mapping between the (sealed) segment and its validDocuments\n-  private final ConcurrentHashMap<String, ThreadSafeMutableRoaringBitmap> _segmentToValidDocIdsMap =\n-      new ConcurrentHashMap<>();\n+  @VisibleForTesting\n+  final ConcurrentHashMap<PrimaryKey, RecordLocation> _primaryKeyToRecordLocationMap = new ConcurrentHashMap<>();\n \n   /**\n-   * Creates the valid doc ids for the given (immutable) segment.\n+   * Initializes the upsert metadata for the given immutable segment, returns the valid doc ids for the segment.\n    */\n-  public ThreadSafeMutableRoaringBitmap createValidDocIds(String segmentName) {\n-    LOGGER.info(\"Creating valid doc ids for segment: {}\", segmentName);\n+  public ThreadSafeMutableRoaringBitmap addSegment(String segmentName, Iterator<RecordInfo> recordInfoIterator) {\n+    LOGGER.info(\"Adding upsert metadata for segment: {}\", segmentName);\n+\n     ThreadSafeMutableRoaringBitmap validDocIds = new ThreadSafeMutableRoaringBitmap();\n-    if (_segmentToValidDocIdsMap.put(segmentName, validDocIds) != null) {\n-      LOGGER.warn(\"Valid doc ids exist for segment: {}, replacing it\", segmentName);\n+    while (recordInfoIterator.hasNext()) {\n+      RecordInfo recordInfo = recordInfoIterator.next();\n+      _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+        if (currentRecordLocation != null) {\n+          // Existing primary key\n+\n+          if (segmentName.equals(currentRecordLocation.getSegmentName())) {\n+            // The current record location has the same segment name\n+\n+            if (validDocIds == currentRecordLocation.getValidDocIds()) {\n+              // The current record location is pointing to the new segment being loaded\n+\n+              // Update the record location when getting a newer timestamp\n+              if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+                validDocIds.remove(currentRecordLocation.getDocId());\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            } else {\n+              // The current record location is pointing to the old segment being replaced. This could happen when\n+              // committing a consuming segment, or reloading a completed segment.\n+\n+              // Update the record location when the new timestamp is greater than or equal to the current timestamp.\n+              // Update the record location when there is a tie because the record locations should point to the new\n+              // segment instead of the old segment being replaced. Also, do not update the valid doc ids for the old\n+              // segment because it has not been replaced yet.\n+              if (recordInfo._timestamp >= currentRecordLocation.getTimestamp()) {\n+                validDocIds.add(recordInfo._docId);\n+                return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+              }\n+            }\n+            return currentRecordLocation;\n+          }\n+\n+          // Update the record location when getting a newer timestamp\n+          if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+            currentRecordLocation.getValidDocIds().remove(currentRecordLocation.getDocId());\n+            validDocIds.add(recordInfo._docId);\n+            return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+          } else {\n+            return currentRecordLocation;\n+          }\n+        } else {\n+          // New primary key\n+          validDocIds.add(recordInfo._docId);\n+          return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n+        }\n+      });\n     }\n     return validDocIds;\n   }\n \n   /**\n-   * Returns the valid doc ids for the given (immutable) segment.\n-   */\n-  public ThreadSafeMutableRoaringBitmap getValidDocIds(String segmentName) {\n-    return Preconditions\n-        .checkNotNull(_segmentToValidDocIdsMap.get(segmentName), \"Failed to find valid doc ids for segment: %s\",\n-            segmentName);\n-  }\n-\n-  /**\n-   * Updates the record location of the given primary key if the given record location is newer than the current record\n-   * location. Also updates the valid doc ids accordingly if the record location is updated.\n+   * Updates the upsert metadata for a new consumed record in the given consuming segment.\n    */\n-  public void updateRecordLocation(PrimaryKey primaryKey, RecordLocation recordLocation,\n+  public synchronized void updateRecord(String segmentName, RecordInfo recordInfo,\n       ThreadSafeMutableRoaringBitmap validDocIds) {\n-    _primaryKeyToRecordLocationMap.compute(primaryKey, (k, v) -> {\n-      if (v != null) {\n+    _primaryKeyToRecordLocationMap.compute(recordInfo._primaryKey, (primaryKey, currentRecordLocation) -> {\n+      if (currentRecordLocation != null) {\n         // Existing primary key\n \n-        if (recordLocation.getTimestamp() >= v.getTimestamp()) {\n-          // Update the record location\n-          // NOTE: Update the record location when there is a tie on the timestamp because during the segment\n-          //       commitment, when loading the committed segment, it should replace the old record locations in case\n-          //       the order of records changed.\n-\n-          // Remove the doc from the valid doc ids of the previous location\n-          if (v.isConsuming()) {\n-            // Previous location is a consuming segment, whose valid doc ids are maintained locally. Only update the\n-            // valid doc ids when the update is from the same segment.\n-            if (recordLocation.isConsuming() && recordLocation.getSegmentName().equals(v.getSegmentName())) {\n-              validDocIds.remove(v.getDocId());\n-            }\n-          } else {\n-            ThreadSafeMutableRoaringBitmap validDocIdsForPreviousLocation =\n-                _segmentToValidDocIdsMap.get(v.getSegmentName());\n-            if (validDocIdsForPreviousLocation != null) {\n-              validDocIdsForPreviousLocation.remove(v.getDocId());\n-            } else {\n-              LOGGER.warn(\"Failed to find valid doc ids for previous location: {}\", v.getSegmentName());\n-            }\n-          }\n-\n-          validDocIds.add(recordLocation.getDocId());\n-          return recordLocation;\n+        // Update the record location when getting a newer timestamp\n+        if (recordInfo._timestamp > currentRecordLocation.getTimestamp()) {\n+          currentRecordLocation.getValidDocIds().remove(currentRecordLocation.getDocId());\n+          validDocIds.add(recordInfo._docId);\n+          return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n         } else {\n-          // No need to update\n-          return v;\n+          return currentRecordLocation;\n         }\n       } else {\n         // New primary key\n-        validDocIds.add(recordLocation.getDocId());\n-        return recordLocation;\n+        validDocIds.add(recordInfo._docId);\n+        return new RecordLocation(segmentName, recordInfo._docId, recordInfo._timestamp, validDocIds);\n       }\n     });\n   }\n \n   /**\n-   * Removes the upsert metadata for the given segment.\n+   * Removes the upsert metadata for the given immutable segment. No need to remove the upsert metadata for the\n+   * consuming segment because it should be replaced by the committed segment.", "originalCommit": "60b932cf4bdd7c903e168d0f473151428a7db60f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1MDAzOA==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509550038", "bodyText": "Just some explanation on why we don't need to call this method for the consuming segment when it is destroyed", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMDk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMTM5Mg==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509001392", "bodyText": "not sure if ThreadSafeMutableRoaringBitmap  is the best identifier of the containing segment. Perhaps the segmentImpl itself, in case ThreadSafeMutableRoaringBitmap  itself may be replaced?", "author": "yupeng9", "createdAt": "2020-10-21T05:38:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/upsert/RecordLocation.java", "diffHunk": "@@ -28,13 +28,13 @@\n   private final String _segmentName;\n   private final int _docId;\n   private final long _timestamp;\n-  private final boolean _isConsuming;\n+  private final ThreadSafeMutableRoaringBitmap _validDocIds;\n \n-  public RecordLocation(String segmentName, int docId, long timestamp, boolean isConsuming) {\n+  public RecordLocation(String segmentName, int docId, long timestamp, ThreadSafeMutableRoaringBitmap validDocIds) {", "originalCommit": "60b932cf4bdd7c903e168d0f473151428a7db60f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1MzQ1MA==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509553450", "bodyText": "I don't want to put too many unrelated info here. If we decide to use another data structure, we can change the constructor. This class is just a wrapper, not an interface, so changing constructor should be fine.", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMTM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MjU5OQ==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509742599", "bodyText": "sgtm", "author": "yupeng9", "createdAt": "2020-10-21T22:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMTM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMjIzOA==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509002238", "bodyText": "nit: I think it's preferred to enable it as early as possible (i.e in the constructor), we know this segment will be an upsert one.", "author": "yupeng9", "createdAt": "2020-10-21T05:40:44Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/plan/maker/MetadataAndDictionaryAggregationPlanMakerTest.java", "diffHunk": "@@ -117,8 +119,9 @@ public void buildSegment()\n   public void loadSegment()\n       throws Exception {\n     _indexSegment = ImmutableSegmentLoader.load(new File(INDEX_DIR, SEGMENT_NAME), ReadMode.heap);\n-    _upsertIndexSegment = ImmutableSegmentLoader\n-        .load(new File(INDEX_DIR, SEGMENT_NAME), ReadMode.heap, new PartitionUpsertMetadataManager());\n+    _upsertIndexSegment = ImmutableSegmentLoader.load(new File(INDEX_DIR, SEGMENT_NAME), ReadMode.heap);\n+    ((ImmutableSegmentImpl) _upsertIndexSegment)\n+        .enableUpsert(new PartitionUpsertMetadataManager(), new ThreadSafeMutableRoaringBitmap());", "originalCommit": "60b932cf4bdd7c903e168d0f473151428a7db60f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1ODg3Nw==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509558877", "bodyText": "I moved this method out of the constructor because the segment loader doesn't need to know whether the segment has upsert enabled or not, and upsert metadata is updated after the segment is loaded.\nDecoupling upsert from the segment loader help simplify the code path for the loading part, and keep all the upsert handling at the same place: RealtimeTableDataManager.addSegment(ImmutableSegment immutableSegment)", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:32:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMjIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MzM2MQ==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509743361", "bodyText": "okay, that's fair", "author": "yupeng9", "createdAt": "2020-10-21T22:07:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMjIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMzEzOA==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509003138", "bodyText": "shall we include the removal as part of the replace? the removal of the old shall be after the addition of the new?", "author": "yupeng9", "createdAt": "2020-10-21T05:43:36Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/upsert/PartitionUpsertMetadataManagerTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.upsert;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.realtime.impl.ThreadSafeMutableRoaringBitmap;\n+import org.apache.pinot.core.upsert.PartitionUpsertMetadataManager.RecordInfo;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertSame;\n+\n+\n+public class PartitionUpsertMetadataManagerTest {\n+  private static final String SEGMENT_PREFIX = \"testSegment\";\n+\n+  @Test\n+  public void testAddSegment() {\n+    PartitionUpsertMetadataManager upsertMetadataManager = new PartitionUpsertMetadataManager();\n+    Map<PrimaryKey, RecordLocation> recordLocationMap = upsertMetadataManager._primaryKeyToRecordLocationMap;\n+\n+    // Add the first segment\n+    String segment1 = SEGMENT_PREFIX + 1;\n+    List<RecordInfo> recordInfoList1 = new ArrayList<>();\n+    recordInfoList1.add(new RecordInfo(getPrimaryKey(0), 0, 100));\n+    recordInfoList1.add(new RecordInfo(getPrimaryKey(1), 1, 100));\n+    recordInfoList1.add(new RecordInfo(getPrimaryKey(2), 2, 100));\n+    recordInfoList1.add(new RecordInfo(getPrimaryKey(0), 3, 80));\n+    recordInfoList1.add(new RecordInfo(getPrimaryKey(1), 4, 120));\n+    recordInfoList1.add(new RecordInfo(getPrimaryKey(0), 5, 100));\n+    ThreadSafeMutableRoaringBitmap validDocIds1 =\n+        upsertMetadataManager.addSegment(segment1, recordInfoList1.iterator());\n+    // segment1: 0 -> {0, 100}, 1 -> {4, 120}, 2 -> {2, 100}\n+    checkRecordLocation(recordLocationMap, 0, segment1, 0, 100);\n+    checkRecordLocation(recordLocationMap, 1, segment1, 4, 120);\n+    checkRecordLocation(recordLocationMap, 2, segment1, 2, 100);\n+    assertEquals(validDocIds1.getMutableRoaringBitmap().toArray(), new int[]{0, 2, 4});\n+\n+    // Add the second segment\n+    String segment2 = SEGMENT_PREFIX + 2;\n+    List<RecordInfo> recordInfoList2 = new ArrayList<>();\n+    recordInfoList2.add(new RecordInfo(getPrimaryKey(0), 0, 100));\n+    recordInfoList2.add(new RecordInfo(getPrimaryKey(1), 1, 100));\n+    recordInfoList2.add(new RecordInfo(getPrimaryKey(2), 2, 120));\n+    recordInfoList2.add(new RecordInfo(getPrimaryKey(3), 3, 80));\n+    recordInfoList2.add(new RecordInfo(getPrimaryKey(0), 4, 80));\n+    ThreadSafeMutableRoaringBitmap validDocIds2 =\n+        upsertMetadataManager.addSegment(segment2, recordInfoList2.iterator());\n+    // segment1: 0 -> {0, 100}, 1 -> {4, 120}\n+    // segment2: 2 -> {2, 120}, 3 -> {3, 80}\n+    checkRecordLocation(recordLocationMap, 0, segment1, 0, 100);\n+    checkRecordLocation(recordLocationMap, 1, segment1, 4, 120);\n+    checkRecordLocation(recordLocationMap, 2, segment2, 2, 120);\n+    checkRecordLocation(recordLocationMap, 3, segment2, 3, 80);\n+    assertEquals(validDocIds1.getMutableRoaringBitmap().toArray(), new int[]{0, 4});\n+    assertEquals(validDocIds2.getMutableRoaringBitmap().toArray(), new int[]{2, 3});\n+\n+    // Replace (reload) the first segment\n+    ThreadSafeMutableRoaringBitmap newValidDocIds1 =\n+        upsertMetadataManager.addSegment(segment1, recordInfoList1.iterator());\n+    // original segment1: 0 -> {0, 100}, 1 -> {4, 120}", "originalCommit": "60b932cf4bdd7c903e168d0f473151428a7db60f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1OTg3NA==", "url": "https://github.com/apache/pinot/pull/6167#discussion_r509559874", "bodyText": "Good point, added", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:33:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMzEzOA=="}], "type": "inlineReview"}, {"oid": "a413132d0be8fe54ffef0523ef208c627d848706", "url": "https://github.com/apache/pinot/commit/a413132d0be8fe54ffef0523ef208c627d848706", "message": "Support reloading upsert table", "committedDate": "2020-10-21T18:37:42Z", "type": "commit"}, {"oid": "392dfed95f4eee2116bea415a7fd418dd970bd79", "url": "https://github.com/apache/pinot/commit/392dfed95f4eee2116bea415a7fd418dd970bd79", "message": "Address comments", "committedDate": "2020-10-21T18:37:42Z", "type": "commit"}, {"oid": "392dfed95f4eee2116bea415a7fd418dd970bd79", "url": "https://github.com/apache/pinot/commit/392dfed95f4eee2116bea415a7fd418dd970bd79", "message": "Address comments", "committedDate": "2020-10-21T18:37:42Z", "type": "forcePushed"}, {"oid": "e7789b56d5598cc52df7d6218a9baa72a0ec0231", "url": "https://github.com/apache/pinot/commit/e7789b56d5598cc52df7d6218a9baa72a0ec0231", "message": "UpsertQuickStart minor fixed", "committedDate": "2020-10-21T19:53:39Z", "type": "commit"}]}