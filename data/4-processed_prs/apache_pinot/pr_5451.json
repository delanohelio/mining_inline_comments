{"pr_number": 5451, "pr_title": "Refactor DistinctTable to use PriorityQueue based algorithm", "pr_createdAt": "2020-05-27T02:09:23Z", "pr_url": "https://github.com/apache/pinot/pull/5451", "timeline": [{"oid": "ed0897f9d1cba8d0fb6a3bbaebc5dcfa37a0e070", "url": "https://github.com/apache/pinot/commit/ed0897f9d1cba8d0fb6a3bbaebc5dcfa37a0e070", "message": "Refactor DistinctTable to use PriorityQueue based algorithm\n\nCurrently DISTINCT query is solved the same way as GROUP-BY queries,\nwhich is not necessary (consume much more memory and CPU) and does\nnot guarantee accuracy of the result.\n\nInstead, DISTINCT query can be solved by a set and a heap efficiently\n(similar to SelectionOrderBy but unique records need to be tracked).\n\nThe new DistinctTable does not implement the Table interface because\nthe table interface is designed mostly for the GROUP-BY queries, and\nis not efficient for DISTINCT. If in the future we want to use Table\ninterface to uniform all the input/output, we can redesign the Table\ninterface to make it suitable for all types of queries.", "committedDate": "2020-05-27T02:10:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODg1OQ==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432678859", "bodyText": "I think this for loop should be written separately for order by and non order by.\nFor order by, there is no early termination so if check can be avoided since the return value will always be true.\nFor non order, after adding every record, check the return value to see if limit has been reached and terminate early within the loop", "author": "siddharthteotia", "createdAt": "2020-05-29T19:01:25Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctAggregationFunction.java", "diffHunk": "@@ -123,21 +120,20 @@ public void aggregate(int length, AggregationResultHolder aggregationResultHolde\n         columnDataTypes[i] = ColumnDataType.fromDataTypeSV(blockValSetMap.get(_inputExpressions.get(i)).getValueType());\n       }\n       DataSchema dataSchema = new DataSchema(_columns, columnDataTypes);\n-      distinctTable = new DistinctTable(dataSchema, _orderBy, _capacity);\n+      distinctTable = new DistinctTable(dataSchema, _orderBy, _limit);\n       aggregationResultHolder.setValue(distinctTable);\n+    } else if (distinctTable.shouldNotAddMore()) {\n+      return;\n     }\n \n-    // TODO: Follow up PR will make few changes to start using DictionaryBasedAggregationOperator\n-    // for DISTINCT queries without filter.\n+    // TODO: Follow up PR will make few changes to start using DictionaryBasedAggregationOperator for DISTINCT queries\n+    //       without filter.\n     RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n \n-    // TODO: Do early termination in the operator itself which should\n-    // not call aggregate function at all if the limit has reached\n-    // that will require the interface change since this function\n-    // has to communicate back that required number of records have\n-    // been collected\n     for (int i = 0; i < length; i++) {\n-      distinctTable.upsert(new Record(blockValueFetcher.getRow(i)));\n+      if (!distinctTable.add(new Record(blockValueFetcher.getRow(i)))) {", "originalCommit": "ed0897f9d1cba8d0fb6a3bbaebc5dcfa37a0e070", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxMTYzNA==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432711634", "bodyText": "Good point, added", "author": "Jackie-Jiang", "createdAt": "2020-05-29T20:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODkyOA==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432678928", "bodyText": "A comment that \"list is not used on the server and/or is only for broker deserialized and reduce\" would be good to have.", "author": "siddharthteotia", "createdAt": "2020-05-29T19:01:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/customobject/DistinctTable.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function.customobject;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.apache.pinot.common.request.SelectionSort;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataTable;\n+import org.apache.pinot.core.common.datatable.DataTableBuilder;\n+import org.apache.pinot.core.common.datatable.DataTableFactory;\n+import org.apache.pinot.core.data.table.Record;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * The {@code DistinctTable} class serves as the intermediate result of {@code DistinctAggregationFunction}.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class DistinctTable {\n+  private static final int MAX_INITIAL_CAPACITY = 10000;\n+\n+  private final DataSchema _dataSchema;\n+  private final int _limit;\n+  private final Set<Record> _uniqueRecords;\n+  private final PriorityQueue<Record> _sortedRecords;\n+  private final List<Record> _records;", "originalCommit": "ed0897f9d1cba8d0fb6a3bbaebc5dcfa37a0e070", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0Mjk0Nw==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432742947", "bodyText": "Added more javadoc and comments", "author": "Jackie-Jiang", "createdAt": "2020-05-29T21:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODk1OA==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432678958", "bodyText": "We should not be checking for contains() on every add(). This will hurt performance since the add() method on the hashset() later on will anyway do a contains internally and will accordingly decide to add or ignore the new item. It will also return true or false if the item was added or not. At least, the java hashset works like this.\nI don't see the purpose of this if-check in lines 126-128. There are two cases:\n\nNo order by: simply do.add() and return if the limit has been reached or not\nOrder by: If limit hasn't reached, add to both set and PQ. Else poll from PQ, delete from set and add to both. Always return true in this case.\n\nLines 129-145 handle both the cases.", "author": "siddharthteotia", "createdAt": "2020-05-29T19:01:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/customobject/DistinctTable.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function.customobject;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.apache.pinot.common.request.SelectionSort;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataTable;\n+import org.apache.pinot.core.common.datatable.DataTableBuilder;\n+import org.apache.pinot.core.common.datatable.DataTableFactory;\n+import org.apache.pinot.core.data.table.Record;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * The {@code DistinctTable} class serves as the intermediate result of {@code DistinctAggregationFunction}.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class DistinctTable {\n+  private static final int MAX_INITIAL_CAPACITY = 10000;\n+\n+  private final DataSchema _dataSchema;\n+  private final int _limit;\n+  private final Set<Record> _uniqueRecords;\n+  private final PriorityQueue<Record> _sortedRecords;\n+  private final List<Record> _records;\n+\n+  /**\n+   * Constructor of the main {@code DistinctTable} which can be used to add records and merge other\n+   * {@code DistinctTable}s.\n+   */\n+  public DistinctTable(DataSchema dataSchema, @Nullable List<SelectionSort> orderBy, int limit) {\n+    _dataSchema = dataSchema;\n+    _limit = limit;\n+\n+    // TODO: see if 10k is the right max initial capacity to use\n+    // NOTE: When LIMIT is smaller than or equal to the MAX_INITIAL_CAPACITY, no resize is required.\n+    int initialCapacity = Math.min(limit, MAX_INITIAL_CAPACITY);\n+    _uniqueRecords = new ObjectOpenHashSet<>(initialCapacity);\n+    if (orderBy != null) {\n+      String[] columns = dataSchema.getColumnNames();\n+      int numColumns = columns.length;\n+      Object2IntOpenHashMap<String> columnIndexMap = new Object2IntOpenHashMap<>(numColumns);\n+      for (int i = 0; i < numColumns; i++) {\n+        columnIndexMap.put(columns[i], i);\n+      }\n+      int numOrderByColumns = orderBy.size();\n+      int[] orderByColumnIndexes = new int[numOrderByColumns];\n+      boolean[] orderByAsc = new boolean[numOrderByColumns];\n+      for (int i = 0; i < numOrderByColumns; i++) {\n+        SelectionSort selectionSort = orderBy.get(i);\n+        orderByColumnIndexes[i] = columnIndexMap.getInt(selectionSort.getColumn());\n+        orderByAsc[i] = selectionSort.isIsAsc();\n+      }\n+      _sortedRecords = new PriorityQueue<>(initialCapacity, (record1, record2) -> {\n+        Object[] values1 = record1.getValues();\n+        Object[] values2 = record2.getValues();\n+        for (int i = 0; i < numOrderByColumns; i++) {\n+          Comparable valueToCompare1 = (Comparable) values1[orderByColumnIndexes[i]];\n+          Comparable valueToCompare2 = (Comparable) values2[orderByColumnIndexes[i]];\n+          int result =\n+              orderByAsc[i] ? valueToCompare2.compareTo(valueToCompare1) : valueToCompare1.compareTo(valueToCompare2);\n+          if (result != 0) {\n+            return result;\n+          }\n+        }\n+        return 0;\n+      });\n+    } else {\n+      _sortedRecords = null;\n+    }\n+    _records = null;\n+  }\n+\n+  /**\n+   * Returns the {@code DataSchema} of the {@code DistinctTable}.\n+   */\n+  public DataSchema getDataSchema() {\n+    return _dataSchema;\n+  }\n+\n+  /**\n+   * Returns the number of unique records within the {@code DistinctTable}.\n+   */\n+  public int size() {\n+    if (_uniqueRecords != null) {\n+      // Server-side\n+      return _uniqueRecords.size();\n+    } else {\n+      // Broker-side\n+      return _records.size();\n+    }\n+  }\n+\n+  /**\n+   * Adds a record into the DistinctTable and returns whether more records should be added. No more records should be\n+   * added iff there is no order-by column and enough unique records have been collected.\n+   */\n+  public boolean add(Record record) {\n+    if (_uniqueRecords.contains(record)) {", "originalCommit": "ed0897f9d1cba8d0fb6a3bbaebc5dcfa37a0e070", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc3NDI3Ng==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432774276", "bodyText": "For non-order-by, yes we can save this extra contains check.\nFor order-by, we should still first check if it contains the record to avoid the unnecessary remove. More importantly, blindly adding record can result in unexpected expanding of the map.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T22:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODk3OQ==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432678979", "bodyText": "A comment stating \"order by\" would be nice. Similarly \"no order by\" before line 144.", "author": "siddharthteotia", "createdAt": "2020-05-29T19:01:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/customobject/DistinctTable.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function.customobject;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.apache.pinot.common.request.SelectionSort;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataTable;\n+import org.apache.pinot.core.common.datatable.DataTableBuilder;\n+import org.apache.pinot.core.common.datatable.DataTableFactory;\n+import org.apache.pinot.core.data.table.Record;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * The {@code DistinctTable} class serves as the intermediate result of {@code DistinctAggregationFunction}.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class DistinctTable {\n+  private static final int MAX_INITIAL_CAPACITY = 10000;\n+\n+  private final DataSchema _dataSchema;\n+  private final int _limit;\n+  private final Set<Record> _uniqueRecords;\n+  private final PriorityQueue<Record> _sortedRecords;\n+  private final List<Record> _records;\n+\n+  /**\n+   * Constructor of the main {@code DistinctTable} which can be used to add records and merge other\n+   * {@code DistinctTable}s.\n+   */\n+  public DistinctTable(DataSchema dataSchema, @Nullable List<SelectionSort> orderBy, int limit) {\n+    _dataSchema = dataSchema;\n+    _limit = limit;\n+\n+    // TODO: see if 10k is the right max initial capacity to use\n+    // NOTE: When LIMIT is smaller than or equal to the MAX_INITIAL_CAPACITY, no resize is required.\n+    int initialCapacity = Math.min(limit, MAX_INITIAL_CAPACITY);\n+    _uniqueRecords = new ObjectOpenHashSet<>(initialCapacity);\n+    if (orderBy != null) {\n+      String[] columns = dataSchema.getColumnNames();\n+      int numColumns = columns.length;\n+      Object2IntOpenHashMap<String> columnIndexMap = new Object2IntOpenHashMap<>(numColumns);\n+      for (int i = 0; i < numColumns; i++) {\n+        columnIndexMap.put(columns[i], i);\n+      }\n+      int numOrderByColumns = orderBy.size();\n+      int[] orderByColumnIndexes = new int[numOrderByColumns];\n+      boolean[] orderByAsc = new boolean[numOrderByColumns];\n+      for (int i = 0; i < numOrderByColumns; i++) {\n+        SelectionSort selectionSort = orderBy.get(i);\n+        orderByColumnIndexes[i] = columnIndexMap.getInt(selectionSort.getColumn());\n+        orderByAsc[i] = selectionSort.isIsAsc();\n+      }\n+      _sortedRecords = new PriorityQueue<>(initialCapacity, (record1, record2) -> {\n+        Object[] values1 = record1.getValues();\n+        Object[] values2 = record2.getValues();\n+        for (int i = 0; i < numOrderByColumns; i++) {\n+          Comparable valueToCompare1 = (Comparable) values1[orderByColumnIndexes[i]];\n+          Comparable valueToCompare2 = (Comparable) values2[orderByColumnIndexes[i]];\n+          int result =\n+              orderByAsc[i] ? valueToCompare2.compareTo(valueToCompare1) : valueToCompare1.compareTo(valueToCompare2);\n+          if (result != 0) {\n+            return result;\n+          }\n+        }\n+        return 0;\n+      });\n+    } else {\n+      _sortedRecords = null;\n+    }\n+    _records = null;\n+  }\n+\n+  /**\n+   * Returns the {@code DataSchema} of the {@code DistinctTable}.\n+   */\n+  public DataSchema getDataSchema() {\n+    return _dataSchema;\n+  }\n+\n+  /**\n+   * Returns the number of unique records within the {@code DistinctTable}.\n+   */\n+  public int size() {\n+    if (_uniqueRecords != null) {\n+      // Server-side\n+      return _uniqueRecords.size();\n+    } else {\n+      // Broker-side\n+      return _records.size();\n+    }\n+  }\n+\n+  /**\n+   * Adds a record into the DistinctTable and returns whether more records should be added. No more records should be\n+   * added iff there is no order-by column and enough unique records have been collected.\n+   */\n+  public boolean add(Record record) {\n+    if (_uniqueRecords.contains(record)) {\n+      return true;\n+    }\n+    if (_sortedRecords != null) {\n+      if (_sortedRecords.size() < _limit) {", "originalCommit": "ed0897f9d1cba8d0fb6a3bbaebc5dcfa37a0e070", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc3NDM3OA==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432774378", "bodyText": "Re-structured the code to separate order-by and non-order-by", "author": "Jackie-Jiang", "createdAt": "2020-05-29T22:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3OTAwMw==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432679003", "bodyText": "So this can be useful for early termination for DISTINCT queries without ORDER BY?", "author": "siddharthteotia", "createdAt": "2020-05-29T19:01:47Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/customobject/DistinctTable.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function.customobject;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.apache.pinot.common.request.SelectionSort;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataTable;\n+import org.apache.pinot.core.common.datatable.DataTableBuilder;\n+import org.apache.pinot.core.common.datatable.DataTableFactory;\n+import org.apache.pinot.core.data.table.Record;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * The {@code DistinctTable} class serves as the intermediate result of {@code DistinctAggregationFunction}.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class DistinctTable {\n+  private static final int MAX_INITIAL_CAPACITY = 10000;\n+\n+  private final DataSchema _dataSchema;\n+  private final int _limit;\n+  private final Set<Record> _uniqueRecords;\n+  private final PriorityQueue<Record> _sortedRecords;\n+  private final List<Record> _records;\n+\n+  /**\n+   * Constructor of the main {@code DistinctTable} which can be used to add records and merge other\n+   * {@code DistinctTable}s.\n+   */\n+  public DistinctTable(DataSchema dataSchema, @Nullable List<SelectionSort> orderBy, int limit) {\n+    _dataSchema = dataSchema;\n+    _limit = limit;\n+\n+    // TODO: see if 10k is the right max initial capacity to use\n+    // NOTE: When LIMIT is smaller than or equal to the MAX_INITIAL_CAPACITY, no resize is required.\n+    int initialCapacity = Math.min(limit, MAX_INITIAL_CAPACITY);\n+    _uniqueRecords = new ObjectOpenHashSet<>(initialCapacity);\n+    if (orderBy != null) {\n+      String[] columns = dataSchema.getColumnNames();\n+      int numColumns = columns.length;\n+      Object2IntOpenHashMap<String> columnIndexMap = new Object2IntOpenHashMap<>(numColumns);\n+      for (int i = 0; i < numColumns; i++) {\n+        columnIndexMap.put(columns[i], i);\n+      }\n+      int numOrderByColumns = orderBy.size();\n+      int[] orderByColumnIndexes = new int[numOrderByColumns];\n+      boolean[] orderByAsc = new boolean[numOrderByColumns];\n+      for (int i = 0; i < numOrderByColumns; i++) {\n+        SelectionSort selectionSort = orderBy.get(i);\n+        orderByColumnIndexes[i] = columnIndexMap.getInt(selectionSort.getColumn());\n+        orderByAsc[i] = selectionSort.isIsAsc();\n+      }\n+      _sortedRecords = new PriorityQueue<>(initialCapacity, (record1, record2) -> {\n+        Object[] values1 = record1.getValues();\n+        Object[] values2 = record2.getValues();\n+        for (int i = 0; i < numOrderByColumns; i++) {\n+          Comparable valueToCompare1 = (Comparable) values1[orderByColumnIndexes[i]];\n+          Comparable valueToCompare2 = (Comparable) values2[orderByColumnIndexes[i]];\n+          int result =\n+              orderByAsc[i] ? valueToCompare2.compareTo(valueToCompare1) : valueToCompare1.compareTo(valueToCompare2);\n+          if (result != 0) {\n+            return result;\n+          }\n+        }\n+        return 0;\n+      });\n+    } else {\n+      _sortedRecords = null;\n+    }\n+    _records = null;\n+  }\n+\n+  /**\n+   * Returns the {@code DataSchema} of the {@code DistinctTable}.\n+   */\n+  public DataSchema getDataSchema() {\n+    return _dataSchema;\n+  }\n+\n+  /**\n+   * Returns the number of unique records within the {@code DistinctTable}.\n+   */\n+  public int size() {\n+    if (_uniqueRecords != null) {\n+      // Server-side\n+      return _uniqueRecords.size();\n+    } else {\n+      // Broker-side\n+      return _records.size();\n+    }\n+  }\n+\n+  /**\n+   * Adds a record into the DistinctTable and returns whether more records should be added. No more records should be\n+   * added iff there is no order-by column and enough unique records have been collected.\n+   */\n+  public boolean add(Record record) {\n+    if (_uniqueRecords.contains(record)) {\n+      return true;\n+    }\n+    if (_sortedRecords != null) {\n+      if (_sortedRecords.size() < _limit) {\n+        _uniqueRecords.add(record);\n+        _sortedRecords.offer(record);\n+      } else {\n+        Record leastRecord = _sortedRecords.peek();\n+        if (_sortedRecords.comparator().compare(record, leastRecord) > 0) {\n+          _uniqueRecords.remove(leastRecord);\n+          _uniqueRecords.add(record);\n+          _sortedRecords.poll();\n+          _sortedRecords.offer(record);\n+        }\n+      }\n+      return true;\n+    } else {\n+      _uniqueRecords.add(record);\n+      return _uniqueRecords.size() < _limit;\n+    }\n+  }\n+\n+  /**\n+   * Returns {@code true} if no more records should be added, {@code false otherwise}. No more records should be added\n+   * iff there is no order-by columns and enough unique records have been collected.\n+   */\n+  public boolean shouldNotAddMore() {", "originalCommit": "ed0897f9d1cba8d0fb6a3bbaebc5dcfa37a0e070", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc3NDg1NA==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432774854", "bodyText": "It can save the creation of RowBasedBlockValueFetcher within the DistinctAggregationFunction.aggregate()", "author": "Jackie-Jiang", "createdAt": "2020-05-29T22:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3OTAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3OTAyNw==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432679027", "bodyText": "Here we seem to be doing extra check on the return value of add() for each record. If there is order by, add() will never return false right?", "author": "siddharthteotia", "createdAt": "2020-05-29T19:01:50Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/customobject/DistinctTable.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function.customobject;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.apache.pinot.common.request.SelectionSort;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataTable;\n+import org.apache.pinot.core.common.datatable.DataTableBuilder;\n+import org.apache.pinot.core.common.datatable.DataTableFactory;\n+import org.apache.pinot.core.data.table.Record;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * The {@code DistinctTable} class serves as the intermediate result of {@code DistinctAggregationFunction}.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class DistinctTable {\n+  private static final int MAX_INITIAL_CAPACITY = 10000;\n+\n+  private final DataSchema _dataSchema;\n+  private final int _limit;\n+  private final Set<Record> _uniqueRecords;\n+  private final PriorityQueue<Record> _sortedRecords;\n+  private final List<Record> _records;\n+\n+  /**\n+   * Constructor of the main {@code DistinctTable} which can be used to add records and merge other\n+   * {@code DistinctTable}s.\n+   */\n+  public DistinctTable(DataSchema dataSchema, @Nullable List<SelectionSort> orderBy, int limit) {\n+    _dataSchema = dataSchema;\n+    _limit = limit;\n+\n+    // TODO: see if 10k is the right max initial capacity to use\n+    // NOTE: When LIMIT is smaller than or equal to the MAX_INITIAL_CAPACITY, no resize is required.\n+    int initialCapacity = Math.min(limit, MAX_INITIAL_CAPACITY);\n+    _uniqueRecords = new ObjectOpenHashSet<>(initialCapacity);\n+    if (orderBy != null) {\n+      String[] columns = dataSchema.getColumnNames();\n+      int numColumns = columns.length;\n+      Object2IntOpenHashMap<String> columnIndexMap = new Object2IntOpenHashMap<>(numColumns);\n+      for (int i = 0; i < numColumns; i++) {\n+        columnIndexMap.put(columns[i], i);\n+      }\n+      int numOrderByColumns = orderBy.size();\n+      int[] orderByColumnIndexes = new int[numOrderByColumns];\n+      boolean[] orderByAsc = new boolean[numOrderByColumns];\n+      for (int i = 0; i < numOrderByColumns; i++) {\n+        SelectionSort selectionSort = orderBy.get(i);\n+        orderByColumnIndexes[i] = columnIndexMap.getInt(selectionSort.getColumn());\n+        orderByAsc[i] = selectionSort.isIsAsc();\n+      }\n+      _sortedRecords = new PriorityQueue<>(initialCapacity, (record1, record2) -> {\n+        Object[] values1 = record1.getValues();\n+        Object[] values2 = record2.getValues();\n+        for (int i = 0; i < numOrderByColumns; i++) {\n+          Comparable valueToCompare1 = (Comparable) values1[orderByColumnIndexes[i]];\n+          Comparable valueToCompare2 = (Comparable) values2[orderByColumnIndexes[i]];\n+          int result =\n+              orderByAsc[i] ? valueToCompare2.compareTo(valueToCompare1) : valueToCompare1.compareTo(valueToCompare2);\n+          if (result != 0) {\n+            return result;\n+          }\n+        }\n+        return 0;\n+      });\n+    } else {\n+      _sortedRecords = null;\n+    }\n+    _records = null;\n+  }\n+\n+  /**\n+   * Returns the {@code DataSchema} of the {@code DistinctTable}.\n+   */\n+  public DataSchema getDataSchema() {\n+    return _dataSchema;\n+  }\n+\n+  /**\n+   * Returns the number of unique records within the {@code DistinctTable}.\n+   */\n+  public int size() {\n+    if (_uniqueRecords != null) {\n+      // Server-side\n+      return _uniqueRecords.size();\n+    } else {\n+      // Broker-side\n+      return _records.size();\n+    }\n+  }\n+\n+  /**\n+   * Adds a record into the DistinctTable and returns whether more records should be added. No more records should be\n+   * added iff there is no order-by column and enough unique records have been collected.\n+   */\n+  public boolean add(Record record) {\n+    if (_uniqueRecords.contains(record)) {\n+      return true;\n+    }\n+    if (_sortedRecords != null) {\n+      if (_sortedRecords.size() < _limit) {\n+        _uniqueRecords.add(record);\n+        _sortedRecords.offer(record);\n+      } else {\n+        Record leastRecord = _sortedRecords.peek();\n+        if (_sortedRecords.comparator().compare(record, leastRecord) > 0) {\n+          _uniqueRecords.remove(leastRecord);\n+          _uniqueRecords.add(record);\n+          _sortedRecords.poll();\n+          _sortedRecords.offer(record);\n+        }\n+      }\n+      return true;\n+    } else {\n+      _uniqueRecords.add(record);\n+      return _uniqueRecords.size() < _limit;\n+    }\n+  }\n+\n+  /**\n+   * Returns {@code true} if no more records should be added, {@code false otherwise}. No more records should be added\n+   * iff there is no order-by columns and enough unique records have been collected.\n+   */\n+  public boolean shouldNotAddMore() {\n+    return _sortedRecords == null && _uniqueRecords.size() == _limit;\n+  }\n+\n+  /*\n+   * SERVER ONLY METHODS\n+   */\n+\n+  /**\n+   * (Server-side) Merges another {@code DistinctTable} into the current one.\n+   * <p>NOTE: {@code DistinctTable} on Server-side has non-null {@code _uniqueRecords}.\n+   */\n+  public void serverSideMerge(DistinctTable distinctTable) {\n+    if (shouldNotAddMore()) {\n+      return;\n+    }\n+    for (Record record : distinctTable._uniqueRecords) {\n+      if (!add(record)) {\n+        return;\n+      }", "originalCommit": "ed0897f9d1cba8d0fb6a3bbaebc5dcfa37a0e070", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc3NDkyMg==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432774922", "bodyText": "Yes, re-structured the code to avoid that", "author": "Jackie-Jiang", "createdAt": "2020-05-29T22:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3OTAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3OTIyMg==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432679222", "bodyText": "I think calling it \"main DistinctTable\" sort of confuses it. What we should say is that:\n\nServer merges 1st to (N-1)th DistinctTable into 0th DistinctTable\nBroker creates a brand new empty DistinctTable (which will have the final records) and merges 0th to (N-1)th DistinctTable from each server into the new table.\n\nIt looks like you are referring to the \"new table\" as the main table?", "author": "siddharthteotia", "createdAt": "2020-05-29T19:02:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/customobject/DistinctTable.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function.customobject;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.apache.pinot.common.request.SelectionSort;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataTable;\n+import org.apache.pinot.core.common.datatable.DataTableBuilder;\n+import org.apache.pinot.core.common.datatable.DataTableFactory;\n+import org.apache.pinot.core.data.table.Record;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * The {@code DistinctTable} class serves as the intermediate result of {@code DistinctAggregationFunction}.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class DistinctTable {\n+  private static final int MAX_INITIAL_CAPACITY = 10000;\n+\n+  private final DataSchema _dataSchema;\n+  private final int _limit;\n+  private final Set<Record> _uniqueRecords;\n+  private final PriorityQueue<Record> _sortedRecords;\n+  private final List<Record> _records;\n+\n+  /**\n+   * Constructor of the main {@code DistinctTable} which can be used to add records and merge other\n+   * {@code DistinctTable}s.\n+   */\n+  public DistinctTable(DataSchema dataSchema, @Nullable List<SelectionSort> orderBy, int limit) {\n+    _dataSchema = dataSchema;\n+    _limit = limit;\n+\n+    // TODO: see if 10k is the right max initial capacity to use\n+    // NOTE: When LIMIT is smaller than or equal to the MAX_INITIAL_CAPACITY, no resize is required.\n+    int initialCapacity = Math.min(limit, MAX_INITIAL_CAPACITY);\n+    _uniqueRecords = new ObjectOpenHashSet<>(initialCapacity);\n+    if (orderBy != null) {\n+      String[] columns = dataSchema.getColumnNames();\n+      int numColumns = columns.length;\n+      Object2IntOpenHashMap<String> columnIndexMap = new Object2IntOpenHashMap<>(numColumns);\n+      for (int i = 0; i < numColumns; i++) {\n+        columnIndexMap.put(columns[i], i);\n+      }\n+      int numOrderByColumns = orderBy.size();\n+      int[] orderByColumnIndexes = new int[numOrderByColumns];\n+      boolean[] orderByAsc = new boolean[numOrderByColumns];\n+      for (int i = 0; i < numOrderByColumns; i++) {\n+        SelectionSort selectionSort = orderBy.get(i);\n+        orderByColumnIndexes[i] = columnIndexMap.getInt(selectionSort.getColumn());\n+        orderByAsc[i] = selectionSort.isIsAsc();\n+      }\n+      _sortedRecords = new PriorityQueue<>(initialCapacity, (record1, record2) -> {\n+        Object[] values1 = record1.getValues();\n+        Object[] values2 = record2.getValues();\n+        for (int i = 0; i < numOrderByColumns; i++) {\n+          Comparable valueToCompare1 = (Comparable) values1[orderByColumnIndexes[i]];\n+          Comparable valueToCompare2 = (Comparable) values2[orderByColumnIndexes[i]];\n+          int result =\n+              orderByAsc[i] ? valueToCompare2.compareTo(valueToCompare1) : valueToCompare1.compareTo(valueToCompare2);\n+          if (result != 0) {\n+            return result;\n+          }\n+        }\n+        return 0;\n+      });\n+    } else {\n+      _sortedRecords = null;\n+    }\n+    _records = null;\n+  }\n+\n+  /**\n+   * Returns the {@code DataSchema} of the {@code DistinctTable}.\n+   */\n+  public DataSchema getDataSchema() {\n+    return _dataSchema;\n+  }\n+\n+  /**\n+   * Returns the number of unique records within the {@code DistinctTable}.\n+   */\n+  public int size() {\n+    if (_uniqueRecords != null) {\n+      // Server-side\n+      return _uniqueRecords.size();\n+    } else {\n+      // Broker-side\n+      return _records.size();\n+    }\n+  }\n+\n+  /**\n+   * Adds a record into the DistinctTable and returns whether more records should be added. No more records should be\n+   * added iff there is no order-by column and enough unique records have been collected.\n+   */\n+  public boolean add(Record record) {\n+    if (_uniqueRecords.contains(record)) {\n+      return true;\n+    }\n+    if (_sortedRecords != null) {\n+      if (_sortedRecords.size() < _limit) {\n+        _uniqueRecords.add(record);\n+        _sortedRecords.offer(record);\n+      } else {\n+        Record leastRecord = _sortedRecords.peek();\n+        if (_sortedRecords.comparator().compare(record, leastRecord) > 0) {\n+          _uniqueRecords.remove(leastRecord);\n+          _uniqueRecords.add(record);\n+          _sortedRecords.poll();\n+          _sortedRecords.offer(record);\n+        }\n+      }\n+      return true;\n+    } else {\n+      _uniqueRecords.add(record);\n+      return _uniqueRecords.size() < _limit;\n+    }\n+  }\n+\n+  /**\n+   * Returns {@code true} if no more records should be added, {@code false otherwise}. No more records should be added\n+   * iff there is no order-by columns and enough unique records have been collected.\n+   */\n+  public boolean shouldNotAddMore() {\n+    return _sortedRecords == null && _uniqueRecords.size() == _limit;\n+  }\n+\n+  /*\n+   * SERVER ONLY METHODS\n+   */\n+\n+  /**\n+   * (Server-side) Merges another {@code DistinctTable} into the current one.\n+   * <p>NOTE: {@code DistinctTable} on Server-side has non-null {@code _uniqueRecords}.\n+   */\n+  public void serverSideMerge(DistinctTable distinctTable) {\n+    if (shouldNotAddMore()) {\n+      return;\n+    }\n+    for (Record record : distinctTable._uniqueRecords) {\n+      if (!add(record)) {\n+        return;\n+      }\n+    }\n+  }\n+\n+  public byte[] toBytes()\n+      throws IOException {\n+    // NOTE: Serialize the DistinctTable as a DataTable\n+    DataTableBuilder dataTableBuilder = new DataTableBuilder(_dataSchema);\n+    DataSchema.ColumnDataType[] columnDataTypes = _dataSchema.getColumnDataTypes();\n+    int numColumns = columnDataTypes.length;\n+    for (Record record : _uniqueRecords) {\n+      dataTableBuilder.startRow();\n+      Object[] values = record.getValues();\n+      for (int i = 0; i < numColumns; i++) {\n+        switch (columnDataTypes[i]) {\n+          case INT:\n+            dataTableBuilder.setColumn(i, (int) values[i]);\n+            break;\n+          case LONG:\n+            dataTableBuilder.setColumn(i, (long) values[i]);\n+            break;\n+          case FLOAT:\n+            dataTableBuilder.setColumn(i, (float) values[i]);\n+            break;\n+          case DOUBLE:\n+            dataTableBuilder.setColumn(i, (double) values[i]);\n+            break;\n+          case STRING:\n+            dataTableBuilder.setColumn(i, (String) values[i]);\n+            break;\n+          case BYTES:\n+            dataTableBuilder.setColumn(i, (ByteArray) values[i]);\n+            break;\n+          // Add other distinct column type supports here\n+          default:\n+            throw new IllegalStateException();\n+        }\n+      }\n+      dataTableBuilder.finishRow();\n+    }\n+    return dataTableBuilder.build().toBytes();\n+  }\n+\n+  /*\n+   * BROKER ONLY METHODS\n+   */\n+\n+  /**\n+   * Broker-side constructor to deserialize the {@code DistinctTable} from a {@code ByteBuffer}. The\n+   * {@code DistinctTable} constructed this way cannot be used to add records or merge other {@code DistinctTable}s\n+   * but can only be merged into the main {@code DistinctTable} because the order-by and limit information is missing.", "originalCommit": "ed0897f9d1cba8d0fb6a3bbaebc5dcfa37a0e070", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc3NTM5Ng==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432775396", "bodyText": "There are 2 types of DistinctTables: Main DistinctTable and Deserialized DistinctTable. Added javadoc to explain them.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T23:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3OTIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3OTI3Nw==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432679277", "bodyText": "Same comment as above on serverSideMerge(). add() will not return false for order by queries so the check while merging each record is a penalty.", "author": "siddharthteotia", "createdAt": "2020-05-29T19:02:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/customobject/DistinctTable.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function.customobject;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.apache.pinot.common.request.SelectionSort;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataTable;\n+import org.apache.pinot.core.common.datatable.DataTableBuilder;\n+import org.apache.pinot.core.common.datatable.DataTableFactory;\n+import org.apache.pinot.core.data.table.Record;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * The {@code DistinctTable} class serves as the intermediate result of {@code DistinctAggregationFunction}.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class DistinctTable {\n+  private static final int MAX_INITIAL_CAPACITY = 10000;\n+\n+  private final DataSchema _dataSchema;\n+  private final int _limit;\n+  private final Set<Record> _uniqueRecords;\n+  private final PriorityQueue<Record> _sortedRecords;\n+  private final List<Record> _records;\n+\n+  /**\n+   * Constructor of the main {@code DistinctTable} which can be used to add records and merge other\n+   * {@code DistinctTable}s.\n+   */\n+  public DistinctTable(DataSchema dataSchema, @Nullable List<SelectionSort> orderBy, int limit) {\n+    _dataSchema = dataSchema;\n+    _limit = limit;\n+\n+    // TODO: see if 10k is the right max initial capacity to use\n+    // NOTE: When LIMIT is smaller than or equal to the MAX_INITIAL_CAPACITY, no resize is required.\n+    int initialCapacity = Math.min(limit, MAX_INITIAL_CAPACITY);\n+    _uniqueRecords = new ObjectOpenHashSet<>(initialCapacity);\n+    if (orderBy != null) {\n+      String[] columns = dataSchema.getColumnNames();\n+      int numColumns = columns.length;\n+      Object2IntOpenHashMap<String> columnIndexMap = new Object2IntOpenHashMap<>(numColumns);\n+      for (int i = 0; i < numColumns; i++) {\n+        columnIndexMap.put(columns[i], i);\n+      }\n+      int numOrderByColumns = orderBy.size();\n+      int[] orderByColumnIndexes = new int[numOrderByColumns];\n+      boolean[] orderByAsc = new boolean[numOrderByColumns];\n+      for (int i = 0; i < numOrderByColumns; i++) {\n+        SelectionSort selectionSort = orderBy.get(i);\n+        orderByColumnIndexes[i] = columnIndexMap.getInt(selectionSort.getColumn());\n+        orderByAsc[i] = selectionSort.isIsAsc();\n+      }\n+      _sortedRecords = new PriorityQueue<>(initialCapacity, (record1, record2) -> {\n+        Object[] values1 = record1.getValues();\n+        Object[] values2 = record2.getValues();\n+        for (int i = 0; i < numOrderByColumns; i++) {\n+          Comparable valueToCompare1 = (Comparable) values1[orderByColumnIndexes[i]];\n+          Comparable valueToCompare2 = (Comparable) values2[orderByColumnIndexes[i]];\n+          int result =\n+              orderByAsc[i] ? valueToCompare2.compareTo(valueToCompare1) : valueToCompare1.compareTo(valueToCompare2);\n+          if (result != 0) {\n+            return result;\n+          }\n+        }\n+        return 0;\n+      });\n+    } else {\n+      _sortedRecords = null;\n+    }\n+    _records = null;\n+  }\n+\n+  /**\n+   * Returns the {@code DataSchema} of the {@code DistinctTable}.\n+   */\n+  public DataSchema getDataSchema() {\n+    return _dataSchema;\n+  }\n+\n+  /**\n+   * Returns the number of unique records within the {@code DistinctTable}.\n+   */\n+  public int size() {\n+    if (_uniqueRecords != null) {\n+      // Server-side\n+      return _uniqueRecords.size();\n+    } else {\n+      // Broker-side\n+      return _records.size();\n+    }\n+  }\n+\n+  /**\n+   * Adds a record into the DistinctTable and returns whether more records should be added. No more records should be\n+   * added iff there is no order-by column and enough unique records have been collected.\n+   */\n+  public boolean add(Record record) {\n+    if (_uniqueRecords.contains(record)) {\n+      return true;\n+    }\n+    if (_sortedRecords != null) {\n+      if (_sortedRecords.size() < _limit) {\n+        _uniqueRecords.add(record);\n+        _sortedRecords.offer(record);\n+      } else {\n+        Record leastRecord = _sortedRecords.peek();\n+        if (_sortedRecords.comparator().compare(record, leastRecord) > 0) {\n+          _uniqueRecords.remove(leastRecord);\n+          _uniqueRecords.add(record);\n+          _sortedRecords.poll();\n+          _sortedRecords.offer(record);\n+        }\n+      }\n+      return true;\n+    } else {\n+      _uniqueRecords.add(record);\n+      return _uniqueRecords.size() < _limit;\n+    }\n+  }\n+\n+  /**\n+   * Returns {@code true} if no more records should be added, {@code false otherwise}. No more records should be added\n+   * iff there is no order-by columns and enough unique records have been collected.\n+   */\n+  public boolean shouldNotAddMore() {\n+    return _sortedRecords == null && _uniqueRecords.size() == _limit;\n+  }\n+\n+  /*\n+   * SERVER ONLY METHODS\n+   */\n+\n+  /**\n+   * (Server-side) Merges another {@code DistinctTable} into the current one.\n+   * <p>NOTE: {@code DistinctTable} on Server-side has non-null {@code _uniqueRecords}.\n+   */\n+  public void serverSideMerge(DistinctTable distinctTable) {\n+    if (shouldNotAddMore()) {\n+      return;\n+    }\n+    for (Record record : distinctTable._uniqueRecords) {\n+      if (!add(record)) {\n+        return;\n+      }\n+    }\n+  }\n+\n+  public byte[] toBytes()\n+      throws IOException {\n+    // NOTE: Serialize the DistinctTable as a DataTable\n+    DataTableBuilder dataTableBuilder = new DataTableBuilder(_dataSchema);\n+    DataSchema.ColumnDataType[] columnDataTypes = _dataSchema.getColumnDataTypes();\n+    int numColumns = columnDataTypes.length;\n+    for (Record record : _uniqueRecords) {\n+      dataTableBuilder.startRow();\n+      Object[] values = record.getValues();\n+      for (int i = 0; i < numColumns; i++) {\n+        switch (columnDataTypes[i]) {\n+          case INT:\n+            dataTableBuilder.setColumn(i, (int) values[i]);\n+            break;\n+          case LONG:\n+            dataTableBuilder.setColumn(i, (long) values[i]);\n+            break;\n+          case FLOAT:\n+            dataTableBuilder.setColumn(i, (float) values[i]);\n+            break;\n+          case DOUBLE:\n+            dataTableBuilder.setColumn(i, (double) values[i]);\n+            break;\n+          case STRING:\n+            dataTableBuilder.setColumn(i, (String) values[i]);\n+            break;\n+          case BYTES:\n+            dataTableBuilder.setColumn(i, (ByteArray) values[i]);\n+            break;\n+          // Add other distinct column type supports here\n+          default:\n+            throw new IllegalStateException();\n+        }\n+      }\n+      dataTableBuilder.finishRow();\n+    }\n+    return dataTableBuilder.build().toBytes();\n+  }\n+\n+  /*\n+   * BROKER ONLY METHODS\n+   */\n+\n+  /**\n+   * Broker-side constructor to deserialize the {@code DistinctTable} from a {@code ByteBuffer}. The\n+   * {@code DistinctTable} constructed this way cannot be used to add records or merge other {@code DistinctTable}s\n+   * but can only be merged into the main {@code DistinctTable} because the order-by and limit information is missing.\n+   */\n+  public DistinctTable(ByteBuffer byteBuffer)\n+      throws IOException {\n+    DataTable dataTable = DataTableFactory.getDataTable(byteBuffer);\n+    _dataSchema = dataTable.getDataSchema();\n+    _limit = Integer.MIN_VALUE;\n+    _uniqueRecords = null;\n+    _sortedRecords = null;\n+    int numRecords = dataTable.getNumberOfRows();\n+    DataSchema.ColumnDataType[] columnDataTypes = _dataSchema.getColumnDataTypes();\n+    int numColumns = columnDataTypes.length;\n+    _records = new ArrayList<>(numRecords);\n+    for (int i = 0; i < numRecords; i++) {\n+      Object[] values = new Object[numColumns];\n+      for (int j = 0; j < numColumns; j++) {\n+        switch (columnDataTypes[j]) {\n+          case INT:\n+            values[j] = dataTable.getInt(i, j);\n+            break;\n+          case LONG:\n+            values[j] = dataTable.getLong(i, j);\n+            break;\n+          case FLOAT:\n+            values[j] = dataTable.getFloat(i, j);\n+            break;\n+          case DOUBLE:\n+            values[j] = dataTable.getDouble(i, j);\n+            break;\n+          case STRING:\n+            values[j] = dataTable.getString(i, j);\n+            break;\n+          case BYTES:\n+            values[j] = dataTable.getBytes(i, j);\n+            break;\n+          // Add other distinct column type supports here\n+          default:\n+            throw new IllegalStateException();\n+        }\n+      }\n+      _records.add(new Record(values));\n+    }\n+  }\n+\n+  /**\n+   * (Broker-side) Merges another {@code DistinctTable} into the current one.\n+   * <p>NOTE: {@code DistinctTable} on Broker-side has non-null {@code _records}.\n+   */\n+  public void brokerSideMerge(DistinctTable distinctTable) {\n+    if (shouldNotAddMore()) {\n+      return;\n+    }\n+    for (Record record : distinctTable._records) {\n+      if (!add(record)) {\n+        return;", "originalCommit": "ed0897f9d1cba8d0fb6a3bbaebc5dcfa37a0e070", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3OTY1MA==", "url": "https://github.com/apache/pinot/pull/5451#discussion_r432679650", "bodyText": "The term \"main DistinctTable\" is confusing. We should consider changing it and elaborating it based on what I suggested above.", "author": "siddharthteotia", "createdAt": "2020-05-29T19:03:11Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/customobject/DistinctTable.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function.customobject;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.apache.pinot.common.request.SelectionSort;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataTable;\n+import org.apache.pinot.core.common.datatable.DataTableBuilder;\n+import org.apache.pinot.core.common.datatable.DataTableFactory;\n+import org.apache.pinot.core.data.table.Record;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * The {@code DistinctTable} class serves as the intermediate result of {@code DistinctAggregationFunction}.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class DistinctTable {\n+  private static final int MAX_INITIAL_CAPACITY = 10000;\n+\n+  private final DataSchema _dataSchema;\n+  private final int _limit;\n+  private final Set<Record> _uniqueRecords;\n+  private final PriorityQueue<Record> _sortedRecords;\n+  private final List<Record> _records;\n+\n+  /**\n+   * Constructor of the main {@code DistinctTable} which can be used to add records and merge other\n+   * {@code DistinctTable}s.\n+   */\n+  public DistinctTable(DataSchema dataSchema, @Nullable List<SelectionSort> orderBy, int limit) {\n+    _dataSchema = dataSchema;\n+    _limit = limit;\n+\n+    // TODO: see if 10k is the right max initial capacity to use\n+    // NOTE: When LIMIT is smaller than or equal to the MAX_INITIAL_CAPACITY, no resize is required.\n+    int initialCapacity = Math.min(limit, MAX_INITIAL_CAPACITY);\n+    _uniqueRecords = new ObjectOpenHashSet<>(initialCapacity);\n+    if (orderBy != null) {\n+      String[] columns = dataSchema.getColumnNames();\n+      int numColumns = columns.length;\n+      Object2IntOpenHashMap<String> columnIndexMap = new Object2IntOpenHashMap<>(numColumns);\n+      for (int i = 0; i < numColumns; i++) {\n+        columnIndexMap.put(columns[i], i);\n+      }\n+      int numOrderByColumns = orderBy.size();\n+      int[] orderByColumnIndexes = new int[numOrderByColumns];\n+      boolean[] orderByAsc = new boolean[numOrderByColumns];\n+      for (int i = 0; i < numOrderByColumns; i++) {\n+        SelectionSort selectionSort = orderBy.get(i);\n+        orderByColumnIndexes[i] = columnIndexMap.getInt(selectionSort.getColumn());\n+        orderByAsc[i] = selectionSort.isIsAsc();\n+      }\n+      _sortedRecords = new PriorityQueue<>(initialCapacity, (record1, record2) -> {\n+        Object[] values1 = record1.getValues();\n+        Object[] values2 = record2.getValues();\n+        for (int i = 0; i < numOrderByColumns; i++) {\n+          Comparable valueToCompare1 = (Comparable) values1[orderByColumnIndexes[i]];\n+          Comparable valueToCompare2 = (Comparable) values2[orderByColumnIndexes[i]];\n+          int result =\n+              orderByAsc[i] ? valueToCompare2.compareTo(valueToCompare1) : valueToCompare1.compareTo(valueToCompare2);\n+          if (result != 0) {\n+            return result;\n+          }\n+        }\n+        return 0;\n+      });\n+    } else {\n+      _sortedRecords = null;\n+    }\n+    _records = null;\n+  }\n+\n+  /**\n+   * Returns the {@code DataSchema} of the {@code DistinctTable}.\n+   */\n+  public DataSchema getDataSchema() {\n+    return _dataSchema;\n+  }\n+\n+  /**\n+   * Returns the number of unique records within the {@code DistinctTable}.\n+   */\n+  public int size() {\n+    if (_uniqueRecords != null) {\n+      // Server-side\n+      return _uniqueRecords.size();\n+    } else {\n+      // Broker-side\n+      return _records.size();\n+    }\n+  }\n+\n+  /**\n+   * Adds a record into the DistinctTable and returns whether more records should be added. No more records should be\n+   * added iff there is no order-by column and enough unique records have been collected.\n+   */\n+  public boolean add(Record record) {\n+    if (_uniqueRecords.contains(record)) {\n+      return true;\n+    }\n+    if (_sortedRecords != null) {\n+      if (_sortedRecords.size() < _limit) {\n+        _uniqueRecords.add(record);\n+        _sortedRecords.offer(record);\n+      } else {\n+        Record leastRecord = _sortedRecords.peek();\n+        if (_sortedRecords.comparator().compare(record, leastRecord) > 0) {\n+          _uniqueRecords.remove(leastRecord);\n+          _uniqueRecords.add(record);\n+          _sortedRecords.poll();\n+          _sortedRecords.offer(record);\n+        }\n+      }\n+      return true;\n+    } else {\n+      _uniqueRecords.add(record);\n+      return _uniqueRecords.size() < _limit;\n+    }\n+  }\n+\n+  /**\n+   * Returns {@code true} if no more records should be added, {@code false otherwise}. No more records should be added\n+   * iff there is no order-by columns and enough unique records have been collected.\n+   */\n+  public boolean shouldNotAddMore() {\n+    return _sortedRecords == null && _uniqueRecords.size() == _limit;\n+  }\n+\n+  /*\n+   * SERVER ONLY METHODS\n+   */\n+\n+  /**\n+   * (Server-side) Merges another {@code DistinctTable} into the current one.\n+   * <p>NOTE: {@code DistinctTable} on Server-side has non-null {@code _uniqueRecords}.\n+   */\n+  public void serverSideMerge(DistinctTable distinctTable) {\n+    if (shouldNotAddMore()) {\n+      return;\n+    }\n+    for (Record record : distinctTable._uniqueRecords) {\n+      if (!add(record)) {\n+        return;\n+      }\n+    }\n+  }\n+\n+  public byte[] toBytes()\n+      throws IOException {\n+    // NOTE: Serialize the DistinctTable as a DataTable\n+    DataTableBuilder dataTableBuilder = new DataTableBuilder(_dataSchema);\n+    DataSchema.ColumnDataType[] columnDataTypes = _dataSchema.getColumnDataTypes();\n+    int numColumns = columnDataTypes.length;\n+    for (Record record : _uniqueRecords) {\n+      dataTableBuilder.startRow();\n+      Object[] values = record.getValues();\n+      for (int i = 0; i < numColumns; i++) {\n+        switch (columnDataTypes[i]) {\n+          case INT:\n+            dataTableBuilder.setColumn(i, (int) values[i]);\n+            break;\n+          case LONG:\n+            dataTableBuilder.setColumn(i, (long) values[i]);\n+            break;\n+          case FLOAT:\n+            dataTableBuilder.setColumn(i, (float) values[i]);\n+            break;\n+          case DOUBLE:\n+            dataTableBuilder.setColumn(i, (double) values[i]);\n+            break;\n+          case STRING:\n+            dataTableBuilder.setColumn(i, (String) values[i]);\n+            break;\n+          case BYTES:\n+            dataTableBuilder.setColumn(i, (ByteArray) values[i]);\n+            break;\n+          // Add other distinct column type supports here\n+          default:\n+            throw new IllegalStateException();\n+        }\n+      }\n+      dataTableBuilder.finishRow();\n+    }\n+    return dataTableBuilder.build().toBytes();\n+  }\n+\n+  /*\n+   * BROKER ONLY METHODS\n+   */\n+\n+  /**\n+   * Broker-side constructor to deserialize the {@code DistinctTable} from a {@code ByteBuffer}. The\n+   * {@code DistinctTable} constructed this way cannot be used to add records or merge other {@code DistinctTable}s\n+   * but can only be merged into the main {@code DistinctTable} because the order-by and limit information is missing.\n+   */\n+  public DistinctTable(ByteBuffer byteBuffer)\n+      throws IOException {\n+    DataTable dataTable = DataTableFactory.getDataTable(byteBuffer);\n+    _dataSchema = dataTable.getDataSchema();\n+    _limit = Integer.MIN_VALUE;\n+    _uniqueRecords = null;\n+    _sortedRecords = null;\n+    int numRecords = dataTable.getNumberOfRows();\n+    DataSchema.ColumnDataType[] columnDataTypes = _dataSchema.getColumnDataTypes();\n+    int numColumns = columnDataTypes.length;\n+    _records = new ArrayList<>(numRecords);\n+    for (int i = 0; i < numRecords; i++) {\n+      Object[] values = new Object[numColumns];\n+      for (int j = 0; j < numColumns; j++) {\n+        switch (columnDataTypes[j]) {\n+          case INT:\n+            values[j] = dataTable.getInt(i, j);\n+            break;\n+          case LONG:\n+            values[j] = dataTable.getLong(i, j);\n+            break;\n+          case FLOAT:\n+            values[j] = dataTable.getFloat(i, j);\n+            break;\n+          case DOUBLE:\n+            values[j] = dataTable.getDouble(i, j);\n+            break;\n+          case STRING:\n+            values[j] = dataTable.getString(i, j);\n+            break;\n+          case BYTES:\n+            values[j] = dataTable.getBytes(i, j);\n+            break;\n+          // Add other distinct column type supports here\n+          default:\n+            throw new IllegalStateException();\n+        }\n+      }\n+      _records.add(new Record(values));\n+    }\n+  }\n+\n+  /**\n+   * (Broker-side) Merges another {@code DistinctTable} into the current one.\n+   * <p>NOTE: {@code DistinctTable} on Broker-side has non-null {@code _records}.\n+   */\n+  public void brokerSideMerge(DistinctTable distinctTable) {\n+    if (shouldNotAddMore()) {\n+      return;\n+    }\n+    for (Record record : distinctTable._records) {\n+      if (!add(record)) {\n+        return;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the final result (all unique records, sorted if ordering is required) of the {@code DistinctTable}.\n+   * <p>NOTE: This method should only be called from the main {@code DistinctTable}.\n+   */", "originalCommit": "ed0897f9d1cba8d0fb6a3bbaebc5dcfa37a0e070", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8d5d40a4c5464c29708824f8ed73a14d67522411", "url": "https://github.com/apache/pinot/commit/8d5d40a4c5464c29708824f8ed73a14d67522411", "message": "Refactor DistinctTable to use PriorityQueue based algorithm\n\nCurrently DISTINCT query is solved the same way as GROUP-BY queries,\nwhich is not necessary (consume much more memory and CPU) and does\nnot guarantee accuracy of the result.\n\nInstead, DISTINCT query can be solved by a set and a heap efficiently\n(similar to SelectionOrderBy but unique records need to be tracked).\n\nThe new DistinctTable does not implement the Table interface because\nthe table interface is designed mostly for the GROUP-BY queries, and\nis not efficient for DISTINCT. If in the future we want to use Table\ninterface to uniform all the input/output, we can redesign the Table\ninterface to make it suitable for all types of queries.", "committedDate": "2020-05-29T23:02:08Z", "type": "forcePushed"}, {"oid": "6fde4b2d99ec139f5995fd0430c13ac2697dc1ab", "url": "https://github.com/apache/pinot/commit/6fde4b2d99ec139f5995fd0430c13ac2697dc1ab", "message": "Refactor DistinctTable to use PriorityQueue based algorithm\n\nCurrently DISTINCT query is solved the same way as GROUP-BY queries,\nwhich is not necessary (consume much more memory and CPU) and does\nnot guarantee accuracy of the result.\n\nInstead, DISTINCT query can be solved by a set and a heap efficiently\n(similar to SelectionOrderBy but unique records need to be tracked).\n\nThe new DistinctTable does not implement the Table interface because\nthe table interface is designed mostly for the GROUP-BY queries, and\nis not efficient for DISTINCT. If in the future we want to use Table\ninterface to uniform all the input/output, we can redesign the Table\ninterface to make it suitable for all types of queries.", "committedDate": "2020-05-29T23:05:53Z", "type": "commit"}, {"oid": "6fde4b2d99ec139f5995fd0430c13ac2697dc1ab", "url": "https://github.com/apache/pinot/commit/6fde4b2d99ec139f5995fd0430c13ac2697dc1ab", "message": "Refactor DistinctTable to use PriorityQueue based algorithm\n\nCurrently DISTINCT query is solved the same way as GROUP-BY queries,\nwhich is not necessary (consume much more memory and CPU) and does\nnot guarantee accuracy of the result.\n\nInstead, DISTINCT query can be solved by a set and a heap efficiently\n(similar to SelectionOrderBy but unique records need to be tracked).\n\nThe new DistinctTable does not implement the Table interface because\nthe table interface is designed mostly for the GROUP-BY queries, and\nis not efficient for DISTINCT. If in the future we want to use Table\ninterface to uniform all the input/output, we can redesign the Table\ninterface to make it suitable for all types of queries.", "committedDate": "2020-05-29T23:05:53Z", "type": "forcePushed"}]}