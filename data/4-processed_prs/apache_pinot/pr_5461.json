{"pr_number": 5461, "pr_title": "Adding Support for SQL CASE Statement", "pr_createdAt": "2020-05-28T10:35:37Z", "pr_url": "https://github.com/apache/pinot/pull/5461", "timeline": [{"oid": "ceef9615ad511ce320343c77568db49e0eec5cc5", "url": "https://github.com/apache/pinot/commit/ceef9615ad511ce320343c77568db49e0eec5cc5", "message": "Adding transform function support for case-when-else", "committedDate": "2020-05-28T11:21:02Z", "type": "forcePushed"}, {"oid": "fbace8bc8959c3dae7405c08b893816a7ad9ae1f", "url": "https://github.com/apache/pinot/commit/fbace8bc8959c3dae7405c08b893816a7ad9ae1f", "message": "Adding transform function support for case-when-else", "committedDate": "2020-05-28T11:21:51Z", "type": "forcePushed"}, {"oid": "5667776b055edaa9ae0850d6fbb740a3742ad6ef", "url": "https://github.com/apache/pinot/commit/5667776b055edaa9ae0850d6fbb740a3742ad6ef", "message": "Adding transform function support for case-when-else", "committedDate": "2020-05-28T17:23:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MjU1Mw==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r432162553", "bodyText": "we should have two separate switch statements for left and right transform functions right?", "author": "kishoreg", "createdAt": "2020-05-28T22:39:10Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ *\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() != 2) {\n+      throw new IllegalArgumentException(\"Exact 2 arguments are required for greater transform function\");\n+    }\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    FieldSpec.DataType dataType = _leftTransformFunction.getResultMetadata().getDataType();", "originalCommit": "5667776b055edaa9ae0850d6fbb740a3742ad6ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNTA1OQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r432305059", "bodyText": "Yes.\nRight now I will also try to parse String to BigDecimal then do the comparison, as LiteralTransformFunction's result type is always String.", "author": "xiangfu0", "createdAt": "2020-05-29T07:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MjU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MjgzMg==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r432162832", "bodyText": "also, check that the return types are comparable, for e.g. if one returns string and other is int, we should throw exception", "author": "kishoreg", "createdAt": "2020-05-28T22:39:58Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ *\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() != 2) {", "originalCommit": "5667776b055edaa9ae0850d6fbb740a3742ad6ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMzE3NA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r432313174", "bodyText": "Added data type check.", "author": "xiangfu0", "createdAt": "2020-05-29T07:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MjgzMg=="}], "type": "inlineReview"}, {"oid": "385a8b8756699b0ee739e6a8c1f74f617d68ebb1", "url": "https://github.com/apache/pinot/commit/385a8b8756699b0ee739e6a8c1f74f617d68ebb1", "message": "Adding transform function support for case-when-else", "committedDate": "2020-05-29T07:46:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4ODQ5Nw==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r432688497", "bodyText": "we want to make add a validation that none of them are agg functions since current implementation only handles transform functions", "author": "kishoreg", "createdAt": "2020-05-29T19:23:49Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -610,6 +611,25 @@ private static Expression toExpression(SqlNode node) {\n         }\n         asFuncExpr.getFunctionCall().addToOperands(RequestUtils.getIdentifierExpression(aliasName));\n         return asFuncExpr;\n+      case CASE:\n+        // CASE WHEN Statement is model as a function with variable length parameters.\n+        // Assume N is number of WHEN Statements, total number of parameters is (2 * N + 1).\n+        // - N: Convert each WHEN Statement into a function Expression;\n+        // - N: Convert each THEN Statement into an Expression;\n+        // - 1: Convert ELSE Statement into an Expression.\n+        SqlCase caseSqlNode = (SqlCase) node;\n+        SqlNodeList whenOperands = caseSqlNode.getWhenOperands();\n+        SqlNodeList thenOperands = caseSqlNode.getThenOperands();\n+        SqlNode elseOperand = caseSqlNode.getElseOperand();\n+        Expression caseFuncExpr = RequestUtils.getFunctionExpression(SqlKind.CASE.name());\n+        for (SqlNode whenSqlNode : whenOperands.getList()) {", "originalCommit": "385a8b8756699b0ee739e6a8c1f74f617d68ebb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc2OTEyMA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r432769120", "bodyText": "Added.", "author": "xiangfu0", "createdAt": "2020-05-29T22:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4ODQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMTAzNg==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r434311036", "bodyText": "Any reason to not use Preconditions.checkArgument()?", "author": "mayankshriv", "createdAt": "2020-06-03T05:10:19Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    if (arguments.size() != 2) {", "originalCommit": "8e0051385fb824ae5e169439760086620d3ac2ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg4OTYyOA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r434889628", "bodyText": "Changed. I don't think we generally follow Preconditions.checkArgument() in TransformFunction. We can update that in a follow up PR.", "author": "xiangfu0", "createdAt": "2020-06-03T22:19:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMTAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMjEzNQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r434312135", "bodyText": "Isn't this as simple as:\nif (leftType == BYTES || rightType == BYTES) { Preconditions.checkState(leftType == BYTES && rightType == BYTES) }", "author": "mayankshriv", "createdAt": "2020-06-03T05:14:27Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    if (arguments.size() != 2) {\n+      throw new IllegalArgumentException(\"Exact 2 arguments are required for binary operator transform function\");\n+    }\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    switch (_leftDataType) {", "originalCommit": "8e0051385fb824ae5e169439760086620d3ac2ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5MDU5OA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r434890598", "bodyText": "Ah, this is good ;)", "author": "xiangfu0", "createdAt": "2020-06-03T22:22:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMjEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMzA1MQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r434313051", "bodyText": "Is the Transform function expected to treat operands as numbers and not comparable strings?", "author": "mayankshriv", "createdAt": "2020-06-03T05:17:48Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    if (arguments.size() != 2) {\n+      throw new IllegalArgumentException(\"Exact 2 arguments are required for binary operator transform function\");\n+    }\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    switch (_leftDataType) {\n+      case INT:\n+      case LONG:\n+      case FLOAT:\n+      case DOUBLE:\n+      case STRING:\n+        switch (_rightDataType) {\n+          case INT:\n+          case LONG:\n+          case FLOAT:\n+          case DOUBLE:\n+          case STRING:\n+            break;\n+          default:\n+            throw new IllegalStateException(String.format(\n+                \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+                _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+        }\n+        break;\n+      case BYTES:\n+        if (_rightDataType != FieldSpec.DataType.BYTES) {\n+          throw new IllegalStateException(String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(String.format(\n+            \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+            _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {\n+      case INT:\n+        int[] leftIntValues = _leftTransformFunction.transformToIntValuesSV(projectionBlock);\n+        switch (_rightDataType) {\n+          case INT:\n+            int[] rightIntValues = _rightTransformFunction.transformToIntValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Integer.compare(leftIntValues[i], rightIntValues[i]));\n+            }\n+            break;\n+          case LONG:\n+            long[] rightLongValues = _rightTransformFunction.transformToLongValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Long.compare(leftIntValues[i], rightLongValues[i]));\n+            }\n+            break;\n+          case FLOAT:\n+            float[] rightFloatValues = _rightTransformFunction.transformToFloatValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Double.compare(leftIntValues[i], rightFloatValues[i]));\n+            }\n+            break;\n+          case DOUBLE:\n+            double[] rightDoubleValues = _rightTransformFunction.transformToDoubleValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Double.compare(leftIntValues[i], rightDoubleValues[i]));\n+            }\n+            break;\n+          case STRING:\n+            String[] rightStringValues = _rightTransformFunction.transformToStringValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(\n+                  BigDecimal.valueOf(leftIntValues[i]).compareTo(new BigDecimal(rightStringValues[i])));", "originalCommit": "8e0051385fb824ae5e169439760086620d3ac2ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5OTgwNg==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r434899806", "bodyText": "Yes, if left side is int then right side should be a number, otherwise it's definitely wrong.\nWe only compare strings when both left and right sides are String.", "author": "xiangfu0", "createdAt": "2020-06-03T22:49:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMzA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxNDIyNA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r434314224", "bodyText": "The NxN combination makes me wonder if the code explosion is worth the performance gain over using non primitive objects temporarily? Will the usage be in the aggr/group-by path?", "author": "mayankshriv", "createdAt": "2020-06-03T05:22:09Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    if (arguments.size() != 2) {\n+      throw new IllegalArgumentException(\"Exact 2 arguments are required for binary operator transform function\");\n+    }\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    switch (_leftDataType) {\n+      case INT:\n+      case LONG:\n+      case FLOAT:\n+      case DOUBLE:\n+      case STRING:\n+        switch (_rightDataType) {\n+          case INT:\n+          case LONG:\n+          case FLOAT:\n+          case DOUBLE:\n+          case STRING:\n+            break;\n+          default:\n+            throw new IllegalStateException(String.format(\n+                \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+                _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+        }\n+        break;\n+      case BYTES:\n+        if (_rightDataType != FieldSpec.DataType.BYTES) {\n+          throw new IllegalStateException(String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(String.format(\n+            \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+            _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {", "originalCommit": "8e0051385fb824ae5e169439760086620d3ac2ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5ODg5OQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r434898899", "bodyText": "This part is tricky as each THEN statement may give different result type.\nEven if we use Object, we still need to infer type and do the conversion.\nAs:\n\nNo infer the correct literal types.\nNo support compatible data type conversion in transform functions. (if transformFunction gives int[], then getDoubleResult will throw exception)", "author": "xiangfu0", "createdAt": "2020-06-03T22:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxNDIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNjk2OA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435726968", "bodyText": "Can THEN part itself have a CASE statement or we can assume they will always be literal expressions?\n\n\nRight now we are only supporting as part of SELECT list?", "author": "siddharthteotia", "createdAt": "2020-06-05T07:02:55Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -610,6 +611,40 @@ private static Expression toExpression(SqlNode node) {\n         }\n         asFuncExpr.getFunctionCall().addToOperands(RequestUtils.getIdentifierExpression(aliasName));\n         return asFuncExpr;\n+      case CASE:\n+        // CASE WHEN Statement is model as a function with variable length parameters.\n+        // Assume N is number of WHEN Statements, total number of parameters is (2 * N + 1).\n+        // - N: Convert each WHEN Statement into a function Expression;\n+        // - N: Convert each THEN Statement into an Expression;\n+        // - 1: Convert ELSE Statement into an Expression.\n+        SqlCase caseSqlNode = (SqlCase) node;\n+        SqlNodeList whenOperands = caseSqlNode.getWhenOperands();\n+        SqlNodeList thenOperands = caseSqlNode.getThenOperands();\n+        SqlNode elseOperand = caseSqlNode.getElseOperand();\n+        Expression caseFuncExpr = RequestUtils.getFunctionExpression(SqlKind.CASE.name());\n+        for (SqlNode whenSqlNode : whenOperands.getList()) {\n+          Expression whenExpression = toExpression(whenSqlNode);\n+          if (isAggregateExpression(whenExpression)) {\n+            throw new SqlCompilationException(\n+                \"Aggregation functions inside WHEN Clause is not supported - \" + whenSqlNode);\n+          }\n+          caseFuncExpr.getFunctionCall().addToOperands(whenExpression);\n+        }\n+        for (SqlNode thenSqlNode : thenOperands.getList()) {", "originalCommit": "4fea059583332a723e215db327346b78f79cbb3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0NTAxOQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435745019", "bodyText": "For THEN part, we support both transform function and literal, technically it could be another CASE statement inside.\nSince it's modeled as a transform function, then it could be used any where allowing this. e.g. predicate, group bys.", "author": "xiangfu0", "createdAt": "2020-06-05T07:42:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNjk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzAwNw==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727007", "bodyText": "IIUC, this is used to model the WHEN part as a function expression (transform function)?", "author": "siddharthteotia", "createdAt": "2020-06-05T07:03:02Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {", "originalCommit": "4fea059583332a723e215db327346b78f79cbb3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0NjM2Ng==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435746366", "bodyText": "Yes, but not only limit to that.\nThe purpose of adding these functions is to support WHEN. However, since those BinaryOperators are modeled as transform function, so user could also put them into selection/predicate/groupby clauses.\nE.g.\nYou can also query like: SELECT a>b FROM myTable.\nThe results would be 1/0 which 1 means true and 0 means false.", "author": "xiangfu0", "createdAt": "2020-06-05T07:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzA0MA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727040", "bodyText": "If we can force left type is same as right type, we can get rid of switch on the right side. For example:\nWHEN price > 30\nif price is of type LONG, we typecast 30 to Long and accordingly create the literal transform function for it. So, we need switch only on the left side type. Right?", "author": "siddharthteotia", "createdAt": "2020-06-05T07:03:08Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"Exact 2 arguments are required for binary operator transform function\");\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    // Data type check: left and right types should be compatible.\n+    if (_leftDataType == FieldSpec.DataType.BYTES || _rightDataType == FieldSpec.DataType.BYTES) {\n+      Preconditions.checkState(_leftDataType == FieldSpec.DataType.BYTES && _rightDataType == FieldSpec.DataType.BYTES,\n+          String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {\n+      case INT:\n+        int[] leftIntValues = _leftTransformFunction.transformToIntValuesSV(projectionBlock);\n+        switch (_rightDataType) {", "originalCommit": "4fea059583332a723e215db327346b78f79cbb3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0NzkzOA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435747938", "bodyText": "Correct, if we can enforce that, then those code would be much simplified.\nAs I replied previously in @mayankshriv 's comment, the issue here is that we don't know right side types and it's often we get unsupported operation exception when from left side, we try to get IntValues, however right side is Double Type.\nAlso, current Literal is always treated as String.", "author": "xiangfu0", "createdAt": "2020-06-05T07:48:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzA1Ng==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727056", "bodyText": "Generally we should do this what databases actually do -- generate code at runtime for the exact types to avoid the interpretation overhead of gigantic switch blocks.\nSince we don't have that yet, may be we can consider (not necessarily in this PR), hand-writing type specific versions of this  -- IntBinaryOperatorTransformFunction, LongBinaryOperatorTransformFunction so that during execution there are minimal (probably none) branches and there is no interpretation overhead at the expense of duplicate code ?", "author": "siddharthteotia", "createdAt": "2020-06-05T07:03:12Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"Exact 2 arguments are required for binary operator transform function\");\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    // Data type check: left and right types should be compatible.\n+    if (_leftDataType == FieldSpec.DataType.BYTES || _rightDataType == FieldSpec.DataType.BYTES) {\n+      Preconditions.checkState(_leftDataType == FieldSpec.DataType.BYTES && _rightDataType == FieldSpec.DataType.BYTES,\n+          String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {\n+      case INT:\n+        int[] leftIntValues = _leftTransformFunction.transformToIntValuesSV(projectionBlock);\n+        switch (_rightDataType) {\n+          case INT:\n+            int[] rightIntValues = _rightTransformFunction.transformToIntValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Integer.compare(leftIntValues[i], rightIntValues[i]));", "originalCommit": "4fea059583332a723e215db327346b78f79cbb3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTcwMw==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435751703", "bodyText": "I feel those kind of nested function calls would be better to be handle by some middle layer to handle the type conversion. E.g _rightTransformFunction.transformToIntValuesSV(projectionBlock);\ncould become:\nBlockProvider.get(_rightTransformFunction.transformToSV(projectionBlock), FieldType.INT);\nThis middle layer will handle fetch from the underlying block and do type conversion to my expected results format.", "author": "xiangfu0", "createdAt": "2020-06-05T07:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5NDA2Ng==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436094066", "bodyText": "@fx19880617 The TransformFunction itself can handle the data type conversion (check BaseTransformFunction which is the middle layer you mentioned). You can use the left & right data type to decide the type of data to transform and directly compare.", "author": "Jackie-Jiang", "createdAt": "2020-06-05T18:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NzMyNQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436167325", "bodyText": "Sounds good, I will double check with that logic", "author": "xiangfu0", "createdAt": "2020-06-05T21:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzExOA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727118", "bodyText": "Can we say that for now THEN will always be a LiteralTransformFunction?", "author": "siddharthteotia", "createdAt": "2020-06-05T07:03:22Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>", "originalCommit": "4fea059583332a723e215db327346b78f79cbb3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0OTA3Nw==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435749077", "bodyText": "It could be Identifier/Literal/TransformFunction. See the test for more details.", "author": "xiangfu0", "createdAt": "2020-06-05T07:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzE2OQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727169", "bodyText": "So the size of this array is _whenStatements.size() + 1 ? If so, can we assert for this?", "author": "siddharthteotia", "createdAt": "2020-06-05T07:03:27Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();", "originalCommit": "4fea059583332a723e215db327346b78f79cbb3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MjI2Nw==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435752267", "bodyText": "yes, will add.\nThere is N WHEN statements and N THEN statements and 1 ELSE statement.", "author": "xiangfu0", "createdAt": "2020-06-05T07:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzIxMA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727210", "bodyText": "So this is gathering the bitmap by invoking the BinaryOperatorTransformFunction?", "author": "siddharthteotia", "createdAt": "2020-06-05T07:03:33Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {\n+    FieldSpec.DataType dataType = elseThenStatements.get(0).getResultMetadata().getDataType();\n+    for (int i = 1; i < elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = elseThenStatements.get(i).getResultMetadata();\n+      if (!resultMetadata.isSingleValue()) {\n+        throw new IllegalStateException(\n+            String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+      }\n+      switch (dataType) {\n+        case INT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+            case FLOAT:\n+            case DOUBLE:\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case LONG:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+              break;\n+            case FLOAT:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case FLOAT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+              break;\n+            case LONG:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case DOUBLE:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case STRING:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+            case STRING:\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        default:\n+          if (resultMetadata.getDataType() != dataType) {\n+            throw new IllegalStateException(\n+                String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+      }\n+    }\n+    return new TransformResultMetadata(dataType, true, false);\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return _resultMetadata;\n+  }\n+\n+  private int[] getSelectedArray(ProjectionBlock projectionBlock) {\n+    int[] selected = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];", "originalCommit": "4fea059583332a723e215db327346b78f79cbb3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MzAxNQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435753015", "bodyText": "selected array contains the value of ELSE(0)/THEN(1-N) index per record after evaluating the WHEN clause.", "author": "xiangfu0", "createdAt": "2020-06-05T07:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNjEyNA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436036124", "bodyText": "Can you please add some comments on this method?", "author": "siddharthteotia", "createdAt": "2020-06-05T16:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNDg3Ng==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436104876", "bodyText": "+1 for some comments. The algorithm is smart, but not very intuitive", "author": "Jackie-Jiang", "createdAt": "2020-06-05T18:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzI1NA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727254", "bodyText": "I am not sure why we need to have types here. If the THEN is a literal expression of type string (the value itself could be numerical), then we are always  going to project string values. Why do we need to run over types here?", "author": "siddharthteotia", "createdAt": "2020-06-05T07:03:41Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {\n+    FieldSpec.DataType dataType = elseThenStatements.get(0).getResultMetadata().getDataType();\n+    for (int i = 1; i < elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = elseThenStatements.get(i).getResultMetadata();\n+      if (!resultMetadata.isSingleValue()) {\n+        throw new IllegalStateException(\n+            String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+      }\n+      switch (dataType) {\n+        case INT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+            case FLOAT:\n+            case DOUBLE:\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case LONG:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+              break;\n+            case FLOAT:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case FLOAT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+              break;\n+            case LONG:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case DOUBLE:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case STRING:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+            case STRING:\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        default:\n+          if (resultMetadata.getDataType() != dataType) {\n+            throw new IllegalStateException(\n+                String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+      }\n+    }\n+    return new TransformResultMetadata(dataType, true, false);\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return _resultMetadata;\n+  }\n+\n+  private int[] getSelectedArray(ProjectionBlock projectionBlock) {\n+    int[] selected = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      TransformFunction transformFunction = _whenStatements.get(i);\n+      int[] conditions = transformFunction.transformToIntValuesSV(projectionBlock);\n+      for (int j = 0; j < conditions.length; j++) {\n+        if (selected[j] == 0 && conditions[j] == 1) {\n+          selected[j] = i + 1;\n+        }\n+      }\n+    }\n+    return selected;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    int[] selected = getSelectedArray(projectionBlock);\n+    int[] results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    for (int i = 0; i < _elseThenStatements.size(); i++) {\n+      TransformFunction transformFunction = _elseThenStatements.get(i);\n+      FieldSpec.DataType dataType = transformFunction.getResultMetadata().getDataType();\n+      switch (dataType) {\n+        case INT:\n+          int[] evalInts = transformFunction.transformToIntValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalInts[j];\n+            }\n+          }\n+          break;\n+        case LONG:\n+          long[] evalLongs = transformFunction.transformToLongValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = (int) evalLongs[j];\n+            }\n+          }\n+          break;\n+        case FLOAT:\n+          float[] evalFloats = transformFunction.transformToFloatValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = (int) evalFloats[j];\n+            }\n+          }\n+          break;\n+        case DOUBLE:\n+          double[] evalDoubles = transformFunction.transformToDoubleValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = (int) evalDoubles[j];\n+            }\n+          }\n+          break;\n+        case STRING:\n+          String[] evalStrings = transformFunction.transformToStringValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = new BigDecimal(evalStrings[i]).intValue();\n+            }\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(String\n+              .format(\"Cannot convert result type [%s] to [INT] for transform function [%s]\", dataType,\n+                  transformFunction));\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public long[] transformToLongValuesSV(ProjectionBlock projectionBlock) {\n+    int[] selected = getSelectedArray(projectionBlock);\n+    long[] results = new long[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    for (int i = 0; i < _elseThenStatements.size(); i++) {\n+      TransformFunction transformFunction = _elseThenStatements.get(i);\n+      FieldSpec.DataType dataType = transformFunction.getResultMetadata().getDataType();\n+      switch (dataType) {\n+        case INT:\n+          int[] evalInts = transformFunction.transformToIntValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalInts[j];\n+            }\n+          }\n+          break;\n+        case LONG:\n+          long[] evalLongs = transformFunction.transformToLongValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalLongs[j];\n+            }\n+          }\n+          break;\n+        case FLOAT:\n+          float[] evalFloats = transformFunction.transformToFloatValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = (long) evalFloats[j];\n+            }\n+          }\n+          break;\n+        case DOUBLE:\n+          double[] evalDoubles = transformFunction.transformToDoubleValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = (long) evalDoubles[j];\n+            }\n+          }\n+          break;\n+        case STRING:\n+          String[] evalStrings = transformFunction.transformToStringValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = new BigDecimal(evalStrings[i]).longValue();\n+            }\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(String\n+              .format(\"Cannot convert result type [%s] to [LONG] for transform function [%s]\", dataType,\n+                  transformFunction));\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public float[] transformToFloatValuesSV(ProjectionBlock projectionBlock) {\n+    int[] selected = getSelectedArray(projectionBlock);\n+    float[] results = new float[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    for (int i = 0; i < _elseThenStatements.size(); i++) {\n+      TransformFunction transformFunction = _elseThenStatements.get(i);\n+      FieldSpec.DataType dataType = transformFunction.getResultMetadata().getDataType();\n+      switch (dataType) {\n+        case INT:\n+          int[] evalInts = transformFunction.transformToIntValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalInts[j];\n+            }\n+          }\n+          break;\n+        case LONG:\n+          long[] evalLongs = transformFunction.transformToLongValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalLongs[j];\n+            }\n+          }\n+          break;\n+        case FLOAT:\n+          float[] evalFloats = transformFunction.transformToFloatValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalFloats[j];\n+            }\n+          }\n+          break;\n+        case DOUBLE:\n+          double[] evalDoubles = transformFunction.transformToDoubleValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = (float) evalDoubles[j];\n+            }\n+          }\n+          break;\n+        case STRING:\n+          String[] evalStrings = transformFunction.transformToStringValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = new BigDecimal(evalStrings[i]).floatValue();\n+            }\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(String\n+              .format(\"Cannot convert result type [%s] to [FLOAT] for transform function [%s]\", dataType,\n+                  transformFunction));\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    int[] selected = getSelectedArray(projectionBlock);\n+    double[] results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    for (int i = 0; i < _elseThenStatements.size(); i++) {\n+      TransformFunction transformFunction = _elseThenStatements.get(i);\n+      FieldSpec.DataType dataType = transformFunction.getResultMetadata().getDataType();\n+      switch (dataType) {\n+        case INT:\n+          int[] evalInts = transformFunction.transformToIntValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalInts[j];\n+            }\n+          }\n+          break;\n+        case LONG:\n+          long[] evalLongs = transformFunction.transformToLongValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalLongs[j];\n+            }\n+          }\n+          break;\n+        case FLOAT:\n+          float[] evalFloats = transformFunction.transformToFloatValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalFloats[j];\n+            }\n+          }\n+          break;\n+        case DOUBLE:\n+          double[] evalDoubles = transformFunction.transformToDoubleValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = evalDoubles[j];\n+            }\n+          }\n+          break;\n+        case STRING:\n+          String[] evalStrings = transformFunction.transformToStringValuesSV(projectionBlock);\n+          for (int j = 0; j < selected.length; j++) {\n+            if (selected[j] == i) {\n+              results[j] = new BigDecimal(evalStrings[i]).doubleValue();\n+            }\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(String\n+              .format(\"Cannot convert result type [%s] to [DOUBLE] for transform function [%s]\", dataType,\n+                  transformFunction));\n+      }\n+    }\n+    return results;\n+  }\n+\n+  @Override\n+  public String[] transformToStringValuesSV(ProjectionBlock projectionBlock) {", "originalCommit": "4fea059583332a723e215db327346b78f79cbb3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1NjM4NQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435756385", "bodyText": "Right side could also be identifier or transform function. So we cannot do simpler assumptions here.", "author": "xiangfu0", "createdAt": "2020-06-05T08:04:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzM2NQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435727365", "bodyText": "We can make this part of the base class?", "author": "siddharthteotia", "createdAt": "2020-06-05T07:03:58Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LessThanOrEqualTransformFunction.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.function.TransformFunctionType;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+\n+\n+/**\n+ * The <code>GreaterThanOrEqualTransformFunction</code> extends <code>BinaryOperatorTransformFunction</code> to\n+ * implement the binary operator(<=).\n+ *\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ *\n+ * SQL Syntax:\n+ *    columnA <= 12\n+ *    columnA <= 12.0\n+ *    columnA <= 'fooBar'\n+ *\n+ * Sample Usage:\n+ *    LESS_THAN_OR_EQUAL(columnA, 12)\n+ *    LESS_THAN_OR_EQUAL(columnA, 12.0)\n+ *    LESS_THAN_OR_EQUAL(columnA, 'fooBar')\n+ *\n+ */\n+public class LessThanOrEqualTransformFunction extends BinaryOperatorTransformFunction {\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    super.init(arguments, dataSourceMap);\n+  }\n+\n+  @Override\n+  int getBinaryFuncResult(int result) {\n+    return (result <= 0) ? 1 : 0;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return TransformFunctionType.LESS_THAN_OR_EQUAL.getName();\n+  }\n+\n+  @Override", "originalCommit": "4fea059583332a723e215db327346b78f79cbb3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1NzcxNw==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r435757717", "bodyText": "Good Catch!", "author": "xiangfu0", "createdAt": "2020-06-05T08:07:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNzM2NQ=="}], "type": "inlineReview"}, {"oid": "6fadc02e79034e90954bd009692ba2ff727ee40d", "url": "https://github.com/apache/pinot/commit/6fadc02e79034e90954bd009692ba2ff727ee40d", "message": "Address comments", "committedDate": "2020-06-05T08:08:21Z", "type": "forcePushed"}, {"oid": "f793defa49d562c5cea5fc0ecd0074d3c4380377", "url": "https://github.com/apache/pinot/commit/f793defa49d562c5cea5fc0ecd0074d3c4380377", "message": "Address comments", "committedDate": "2020-06-05T09:25:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5NjczNA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436096734", "bodyText": "Actually this is redundant check because you already check the number of arguments is odd", "author": "Jackie-Jiang", "createdAt": "2020-06-05T18:33:23Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    Preconditions.checkState(_elseThenStatements.size() == _numberWhenStatements + 1, \"Missing THEN/ELSE clause in CASE statement\");", "originalCommit": "f793defa49d562c5cea5fc0ecd0074d3c4380377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MTcwMw==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436241703", "bodyText": "removed", "author": "xiangfu0", "createdAt": "2020-06-06T05:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5NjczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5ODk1Ng==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436098956", "bodyText": "(nit) no need to pass in argument", "author": "Jackie-Jiang", "createdAt": "2020-06-05T18:37:48Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    Preconditions.checkState(_elseThenStatements.size() == _numberWhenStatements + 1, \"Missing THEN/ELSE clause in CASE statement\");\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {", "originalCommit": "f793defa49d562c5cea5fc0ecd0074d3c4380377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MTY5Ng==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436241696", "bodyText": "done", "author": "xiangfu0", "createdAt": "2020-06-06T05:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5ODk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwMDUyOQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436100529", "bodyText": "We can support MV right? I think we can add limitation of not supporting mixed SV and MV? Or for now not allowing MV at all? Add some comments and add TODO maybe?", "author": "Jackie-Jiang", "createdAt": "2020-06-05T18:41:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    Preconditions.checkState(_elseThenStatements.size() == _numberWhenStatements + 1, \"Missing THEN/ELSE clause in CASE statement\");\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {\n+    FieldSpec.DataType dataType = elseThenStatements.get(0).getResultMetadata().getDataType();\n+    for (int i = 1; i < elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = elseThenStatements.get(i).getResultMetadata();\n+      if (!resultMetadata.isSingleValue()) {", "originalCommit": "f793defa49d562c5cea5fc0ecd0074d3c4380377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwMTkwOQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436101909", "bodyText": "Also, the check for the first statement is missing", "author": "Jackie-Jiang", "createdAt": "2020-06-05T18:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwMDUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MTY0NQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436241645", "bodyText": "Yes we can.", "author": "xiangfu0", "createdAt": "2020-06-06T05:53:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwMDUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwMjM5NA==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436102394", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          dataType = resultMetadata.getDataType();\n          \n          \n            \n                          dataType = FieldSpec.DataType.STRING;", "author": "Jackie-Jiang", "createdAt": "2020-06-05T18:45:10Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    Preconditions.checkState(_elseThenStatements.size() == _numberWhenStatements + 1, \"Missing THEN/ELSE clause in CASE statement\");\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {\n+    FieldSpec.DataType dataType = elseThenStatements.get(0).getResultMetadata().getDataType();\n+    for (int i = 1; i < elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = elseThenStatements.get(i).getResultMetadata();\n+      if (!resultMetadata.isSingleValue()) {\n+        throw new IllegalStateException(\n+            String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+      }\n+      switch (dataType) {\n+        case INT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+            case FLOAT:\n+            case DOUBLE:\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case LONG:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+              break;\n+            case FLOAT:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case FLOAT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+              break;\n+            case LONG:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();", "originalCommit": "f793defa49d562c5cea5fc0ecd0074d3c4380377", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjc0NQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436106745", "bodyText": "Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other methods. You don't need a separate switch inside the method.", "author": "Jackie-Jiang", "createdAt": "2020-06-05T18:54:27Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    Preconditions.checkState(_elseThenStatements.size() == _numberWhenStatements + 1, \"Missing THEN/ELSE clause in CASE statement\");\n+    _resultMetadata = getResultMetadata(_elseThenStatements);\n+  }\n+\n+  private TransformResultMetadata getResultMetadata(List<TransformFunction> elseThenStatements) {\n+    FieldSpec.DataType dataType = elseThenStatements.get(0).getResultMetadata().getDataType();\n+    for (int i = 1; i < elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = elseThenStatements.get(i).getResultMetadata();\n+      if (!resultMetadata.isSingleValue()) {\n+        throw new IllegalStateException(\n+            String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+      }\n+      switch (dataType) {\n+        case INT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+            case FLOAT:\n+            case DOUBLE:\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case LONG:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+              break;\n+            case FLOAT:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case FLOAT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+              break;\n+            case LONG:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case DOUBLE:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case STRING:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+            case STRING:\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        default:\n+          if (resultMetadata.getDataType() != dataType) {\n+            throw new IllegalStateException(\n+                String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+      }\n+    }\n+    return new TransformResultMetadata(dataType, true, false);\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return _resultMetadata;\n+  }\n+\n+  private int[] getSelectedArray(ProjectionBlock projectionBlock) {\n+    int[] selected = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      TransformFunction transformFunction = _whenStatements.get(i);\n+      int[] conditions = transformFunction.transformToIntValuesSV(projectionBlock);\n+      for (int j = 0; j < conditions.length; j++) {\n+        if (selected[j] == 0 && conditions[j] == 1) {\n+          selected[j] = i + 1;\n+        }\n+      }\n+    }\n+    return selected;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {", "originalCommit": "f793defa49d562c5cea5fc0ecd0074d3c4380377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MTEyMw==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436241123", "bodyText": "done", "author": "xiangfu0", "createdAt": "2020-06-06T05:44:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNjc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwOTkxOQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436109919", "bodyText": "Also, why do we have compare here? It will make the BinaryOperator not suitable for other Functions other than comparison.\nFor performance concern, we should pass the array into the getBinaryFuncResult, where you can have one getBinaryFuncResult for each data type.", "author": "Jackie-Jiang", "createdAt": "2020-06-05T19:01:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"Exact 2 arguments are required for binary operator transform function\");\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    // Data type check: left and right types should be compatible.\n+    if (_leftDataType == FieldSpec.DataType.BYTES || _rightDataType == FieldSpec.DataType.BYTES) {\n+      Preconditions.checkState(_leftDataType == FieldSpec.DataType.BYTES && _rightDataType == FieldSpec.DataType.BYTES,\n+          String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    fillResultArray(projectionBlock);\n+    return _results;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {\n+      case INT:\n+        int[] leftIntValues = _leftTransformFunction.transformToIntValuesSV(projectionBlock);\n+        switch (_rightDataType) {\n+          case INT:\n+            int[] rightIntValues = _rightTransformFunction.transformToIntValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Integer.compare(leftIntValues[i], rightIntValues[i]));", "originalCommit": "f793defa49d562c5cea5fc0ecd0074d3c4380377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzNDQxOQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436234419", "bodyText": "This is only for comparison. The major point is that I don't want to write comparison for MxN data types in every class.", "author": "xiangfu0", "createdAt": "2020-06-06T03:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwOTkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMTE0OQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436121149", "bodyText": "Can we follow the same convention as in the ArrayCopyUtils so that the behavior is consistent everywhere? (Use Integer.parseInt, Long.parseLong, Float.parseFloat, Double.parseDouble, BytesUtils.toBytes)\nIf the String is not of the target value format, the current behavior is to throw exception.\nFor this PR, I don't think you need to change this class because the binary operator first check the data type and always fetch String value from Literal. Ideally it should check for Literal and call getLiteral()", "author": "Jackie-Jiang", "createdAt": "2020-06-05T19:27:30Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LiteralTransformFunction.java", "diffHunk": "@@ -75,22 +82,40 @@ public Dictionary getDictionary() {\n \n   @Override\n   public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n-    throw new UnsupportedOperationException();\n+    if (_intResult == null) {\n+      _intResult = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+      Arrays.fill(_intResult, Double.valueOf(_literal).intValue());", "originalCommit": "f793defa49d562c5cea5fc0ecd0074d3c4380377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MTExNg==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436241116", "bodyText": "Reverted the change on this.", "author": "xiangfu0", "createdAt": "2020-06-06T05:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMTE0OQ=="}], "type": "inlineReview"}, {"oid": "ff53c75284d19721723ada88b5bb1781ad719f46", "url": "https://github.com/apache/pinot/commit/ff53c75284d19721723ada88b5bb1781ad719f46", "message": "Address comments", "committedDate": "2020-06-06T05:54:26Z", "type": "forcePushed"}, {"oid": "1df11d2e796e3341d554a864a5f61223e713a251", "url": "https://github.com/apache/pinot/commit/1df11d2e796e3341d554a864a5f61223e713a251", "message": "Address comments", "committedDate": "2020-06-06T06:22:15Z", "type": "forcePushed"}, {"oid": "d61d9505714bb7e2a6fa7d5a2244bc4c1df10396", "url": "https://github.com/apache/pinot/commit/d61d9505714bb7e2a6fa7d5a2244bc4c1df10396", "message": "Address comments", "committedDate": "2020-06-06T20:18:02Z", "type": "forcePushed"}, {"oid": "41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b", "url": "https://github.com/apache/pinot/commit/41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b", "message": "Address comments", "committedDate": "2020-06-07T03:00:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNDAzOQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436904039", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          _results[i] = getBinaryFuncResult(Double.compare(leftIntValues[i], rightFloatValues[i]));\n          \n          \n            \n                          _results[i] = getBinaryFuncResult(Float.compare(leftIntValues[i], rightFloatValues[i]));", "author": "Jackie-Jiang", "createdAt": "2020-06-08T18:20:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BinaryOperatorTransformFunction.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+/**\n+ * <code>BinaryOperatorTransformFunction</code> abstracts common functions for binary operators (=, !=, >=, >, <=, <)\n+ * The results are in boolean format and stored as an integer array with 1 represents true and 0 represents false.\n+ */\n+public abstract class BinaryOperatorTransformFunction extends BaseTransformFunction {\n+\n+  protected TransformFunction _leftTransformFunction;\n+  protected TransformFunction _rightTransformFunction;\n+  protected FieldSpec.DataType _leftDataType;\n+  protected FieldSpec.DataType _rightDataType;\n+  protected int[] _results;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are exact 2 arguments\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"Exact 2 arguments are required for binary operator transform function\");\n+    _leftTransformFunction = arguments.get(0);\n+    _rightTransformFunction = arguments.get(1);\n+    _leftDataType = _leftTransformFunction.getResultMetadata().getDataType();\n+    _rightDataType = _rightTransformFunction.getResultMetadata().getDataType();\n+    // Data type check: left and right types should be compatible.\n+    if (_leftDataType == FieldSpec.DataType.BYTES || _rightDataType == FieldSpec.DataType.BYTES) {\n+      Preconditions.checkState(_leftDataType == FieldSpec.DataType.BYTES && _rightDataType == FieldSpec.DataType.BYTES,\n+          String.format(\n+              \"Unsupported data type for comparison: [Left Transform Function [%s] result type is [%s], Right Transform Function [%s] result type is [%s]]\",\n+              _leftTransformFunction.getName(), _leftDataType, _rightTransformFunction.getName(), _rightDataType));\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    fillResultArray(projectionBlock);\n+    return _results;\n+  }\n+\n+  protected void fillResultArray(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    int length = projectionBlock.getNumDocs();\n+    switch (_leftDataType) {\n+      case INT:\n+        int[] leftIntValues = _leftTransformFunction.transformToIntValuesSV(projectionBlock);\n+        switch (_rightDataType) {\n+          case INT:\n+            int[] rightIntValues = _rightTransformFunction.transformToIntValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Integer.compare(leftIntValues[i], rightIntValues[i]));\n+            }\n+            break;\n+          case LONG:\n+            long[] rightLongValues = _rightTransformFunction.transformToLongValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Long.compare(leftIntValues[i], rightLongValues[i]));\n+            }\n+            break;\n+          case FLOAT:\n+            float[] rightFloatValues = _rightTransformFunction.transformToFloatValuesSV(projectionBlock);\n+            for (int i = 0; i < length; i++) {\n+              _results[i] = getBinaryFuncResult(Double.compare(leftIntValues[i], rightFloatValues[i]));", "originalCommit": "41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNzQ3Nw==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436907477", "bodyText": "(nit) Readability\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (resultMetadata.isSingleValue() ^ isSingleValueField) {\n          \n          \n            \n                  if (resultMetadata.isSingleValue() != isSingleValueField) {", "author": "Jackie-Jiang", "createdAt": "2020-06-08T18:26:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.core.util.ArrayCopyUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+  private int[] _selectedResults;\n+  private int[] _intResults;\n+  private long[] _longResults;\n+  private float[] _floatResults;\n+  private double[] _doubleResults;\n+  private String[] _stringResults;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    getResultMetadata();\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    if (_resultMetadata != null) {\n+      return _resultMetadata;\n+    }\n+    FieldSpec.DataType dataType = _elseThenStatements.get(0).getResultMetadata().getDataType();\n+    boolean isSingleValueField = _elseThenStatements.get(0).getResultMetadata().isSingleValue();\n+    for (int i = 1; i < _elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = _elseThenStatements.get(i).getResultMetadata();\n+      if (resultMetadata.isSingleValue() ^ isSingleValueField) {", "originalCommit": "41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTYyNg==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r436915626", "bodyText": "You don't need to check data type here, but directly call evalInts = transformFunction.transformToIntValuesSV(projectionBlock);. The transformFunction can handle the type casting. Same for other places", "author": "Jackie-Jiang", "createdAt": "2020-06-08T18:41:22Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/CaseTransformFunction.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.core.util.ArrayCopyUtils;\n+import org.apache.pinot.spi.data.FieldSpec;\n+\n+\n+/**\n+ * The <code>CaseTransformFunction</code> class implements the CASE-WHEN-THEN-ELSE transformation.\n+ *\n+ * The SQL Syntax is:\n+ *    CASE\n+ *        WHEN condition1 THEN result1\n+ *        WHEN condition2 THEN result2\n+ *        WHEN conditionN THEN resultN\n+ *        ELSE result\n+ *    END;\n+ *\n+ * Usage:\n+ *    case(${WHEN_STATEMENT_1}, ..., ${WHEN_STATEMENT_N},\n+ *         ${THEN_EXPRESSION_1}, ..., ${THEN_EXPRESSION_N},\n+ *         ${ELSE_EXPRESSION})\n+ *\n+ * There are 2 * N + 1 arguments:\n+ *    <code>WHEN_STATEMENT_$i</code> is a <code>BinaryOperatorTransformFunction</code> represents <code>condition$i</code>\n+ *    <code>THEN_EXPRESSION_$i</code> is a <code>TransformFunction</code> represents <code>result$i</code>\n+ *    <code>ELSE_EXPRESSION</code> is a <code>TransformFunction</code> represents <code>result</code>\n+ *\n+ */\n+public class CaseTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"case\";\n+  private final List<TransformFunction> _whenStatements = new ArrayList<>();\n+  private final List<TransformFunction> _elseThenStatements = new ArrayList<>();\n+  private int _numberWhenStatements;\n+  private TransformResultMetadata _resultMetadata;\n+  private int[] _selectedResults;\n+  private int[] _intResults;\n+  private long[] _longResults;\n+  private float[] _floatResults;\n+  private double[] _doubleResults;\n+  private String[] _stringResults;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are more than 1 arguments\n+    if (arguments.size() % 2 != 1 || arguments.size() < 3) {\n+      throw new IllegalArgumentException(\"At least 3 odd number of arguments are required for CASE-WHEN-ELSE function\");\n+    }\n+    _numberWhenStatements = arguments.size() / 2;\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      _whenStatements.add(arguments.get(i));\n+    }\n+    // Add ELSE Statement first\n+    _elseThenStatements.add(arguments.get(_numberWhenStatements * 2));\n+    for (int i = _numberWhenStatements; i < _numberWhenStatements * 2; i++) {\n+      _elseThenStatements.add(arguments.get(i));\n+    }\n+    getResultMetadata();\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    if (_resultMetadata != null) {\n+      return _resultMetadata;\n+    }\n+    FieldSpec.DataType dataType = _elseThenStatements.get(0).getResultMetadata().getDataType();\n+    boolean isSingleValueField = _elseThenStatements.get(0).getResultMetadata().isSingleValue();\n+    for (int i = 1; i < _elseThenStatements.size(); i++) {\n+      TransformResultMetadata resultMetadata = _elseThenStatements.get(i).getResultMetadata();\n+      if (resultMetadata.isSingleValue() ^ isSingleValueField) {\n+        throw new IllegalStateException(\n+            String.format(\"Mixed Single/Multi Value results in expression types in THEN Clause [%s].\", resultMetadata));\n+      }\n+      switch (dataType) {\n+        case INT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+            case FLOAT:\n+            case DOUBLE:\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case LONG:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case LONG:\n+              break;\n+            case FLOAT:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case FLOAT:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+              break;\n+            case LONG:\n+            case DOUBLE:\n+              dataType = FieldSpec.DataType.DOUBLE;\n+              break;\n+            case STRING:\n+              dataType = FieldSpec.DataType.STRING;\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case DOUBLE:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+              break;\n+            case STRING:\n+              dataType = resultMetadata.getDataType();\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        case STRING:\n+          switch (resultMetadata.getDataType()) {\n+            case INT:\n+            case FLOAT:\n+            case LONG:\n+            case DOUBLE:\n+            case STRING:\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+          break;\n+        default:\n+          if (resultMetadata.getDataType() != dataType) {\n+            throw new IllegalStateException(\n+                String.format(\"Incompatible expression types in THEN Clause [%s].\", resultMetadata));\n+          }\n+      }\n+    }\n+    _resultMetadata = new TransformResultMetadata(dataType, true, false);\n+    return _resultMetadata;\n+  }\n+\n+  /**\n+   * Evaluate the ProjectionBlock for the WHEN statements, returns an array with the\n+   * index(1 to N) of matched WHEN clause, 0 means nothing matched, so go to ELSE.\n+   *\n+   * @param projectionBlock\n+   * @return\n+   */\n+  private int[] getSelectedArray(ProjectionBlock projectionBlock) {\n+    if (_selectedResults == null) {\n+      _selectedResults = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    } else {\n+      Arrays.fill(_selectedResults, 0);\n+    }\n+    for (int i = 0; i < _numberWhenStatements; i++) {\n+      TransformFunction transformFunction = _whenStatements.get(i);\n+      int[] conditions = transformFunction.transformToIntValuesSV(projectionBlock);\n+      for (int j = 0; j < conditions.length; j++) {\n+        if (_selectedResults[j] == 0 && conditions[j] == 1) {\n+          _selectedResults[j] = i + 1;\n+        }\n+      }\n+    }\n+    return _selectedResults;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    int[] selected = getSelectedArray(projectionBlock);\n+    if (_intResults == null) {\n+      _intResults = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    for (int i = 0; i < _elseThenStatements.size(); i++) {\n+      TransformFunction transformFunction = _elseThenStatements.get(i);\n+      FieldSpec.DataType dataType = transformFunction.getResultMetadata().getDataType();\n+      int blockNumDocs = projectionBlock.getNumDocs();\n+      int[] evalInts;\n+      if (dataType == FieldSpec.DataType.INT) {\n+        evalInts = transformFunction.transformToIntValuesSV(projectionBlock);\n+      } else {\n+        evalInts = new int[blockNumDocs];\n+        switch (dataType) {\n+          case LONG:\n+            ArrayCopyUtils.copy(transformFunction.transformToLongValuesSV(projectionBlock), evalInts, blockNumDocs);\n+            break;\n+          case FLOAT:\n+            ArrayCopyUtils.copy(transformFunction.transformToFloatValuesSV(projectionBlock), evalInts, blockNumDocs);\n+            break;\n+          case DOUBLE:\n+            ArrayCopyUtils.copy(transformFunction.transformToDoubleValuesSV(projectionBlock), evalInts, blockNumDocs);\n+            break;\n+          case STRING:\n+            ArrayCopyUtils.copy(transformFunction.transformToStringValuesSV(projectionBlock), evalInts, blockNumDocs);\n+            break;\n+          default:\n+            throw new IllegalStateException(String\n+                .format(\"Cannot convert result type [%s] to [INT] for transform function [%s]\", dataType,\n+                    transformFunction));\n+        }\n+      }", "originalCommit": "41aba47ab4cbc56cdfdde765af4b8cd04fa69b2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDM3Nw==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r437650377", "bodyText": "Not really, the issue is that the transform function may call IdentifierTransformFunction, which only supports one data type.", "author": "xiangfu0", "createdAt": "2020-06-09T18:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTYyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NDg3MQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r437654871", "bodyText": "E.g.\nSELECT\n  SUM(\n    CASE\n      WHEN price > 30 THEN price* 3\n      WHEN price > 20 THEN price *2\n      WHEN price > 10 THEN price\n      ELSE 0\n    END) AS weighted_price\nFROM\n    myTable\n\nThen else clause will result the result data type to STRING as 0 is represented as a String literal 0. meanwhile price is INT, price *2 is DOUBLE.\nWhen you try to get price from an IdentifierTransformFunction, it will try to get a String value and then get exceptions. The only thing is to check result data type and get value then copy to the data type of computed case statement.", "author": "xiangfu0", "createdAt": "2020-06-09T19:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTYyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NjA5MQ==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r437766091", "bodyText": "IdentifierTransformFunction should be able to do the casting. LiteralTransformFunction does not support casting, so you should explicitly check whether the transform function is literal and call LiteralTransformFunction.getLiteral().\nBesides, a lot of combinations are not possible. E.g. when the result is INT type, the _elseThenStatements will always be INT type.\nThis can simplify the code, but is a good to have but not must.", "author": "Jackie-Jiang", "createdAt": "2020-06-09T22:54:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTYyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MzM5Ng==", "url": "https://github.com/apache/pinot/pull/5461#discussion_r437853396", "bodyText": "This is a good point:\nBesides, a lot of combinations are not possible. E.g. when the result is INT type, the _elseThenStatements will always be INT type.", "author": "xiangfu0", "createdAt": "2020-06-10T04:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTYyNg=="}], "type": "inlineReview"}, {"oid": "d6c0ca86ed04eadbd46dac4bd830a0652643be54", "url": "https://github.com/apache/pinot/commit/d6c0ca86ed04eadbd46dac4bd830a0652643be54", "message": "Address comments", "committedDate": "2020-06-09T07:38:41Z", "type": "forcePushed"}, {"oid": "82955f60cac5da0afa8721666e52e54c16330967", "url": "https://github.com/apache/pinot/commit/82955f60cac5da0afa8721666e52e54c16330967", "message": "Address comments", "committedDate": "2020-06-09T18:58:12Z", "type": "forcePushed"}, {"oid": "496c44c4dcb267de09f90cdfcbb018ab40268690", "url": "https://github.com/apache/pinot/commit/496c44c4dcb267de09f90cdfcbb018ab40268690", "message": "Address comments", "committedDate": "2020-06-09T18:58:56Z", "type": "forcePushed"}, {"oid": "9fbd5899fd40f101b8400f045669fc90ee86913d", "url": "https://github.com/apache/pinot/commit/9fbd5899fd40f101b8400f045669fc90ee86913d", "message": "update case statement to skip some conditions won't happen", "committedDate": "2020-06-10T04:28:57Z", "type": "forcePushed"}, {"oid": "42bf64f27631011da7d748f62463a654848ea709", "url": "https://github.com/apache/pinot/commit/42bf64f27631011da7d748f62463a654848ea709", "message": "Adding case-when-else sql parsing statement", "committedDate": "2020-06-10T05:43:03Z", "type": "commit"}, {"oid": "35bbeb4c4776367beabb00de951bdb5c32d27233", "url": "https://github.com/apache/pinot/commit/35bbeb4c4776367beabb00de951bdb5c32d27233", "message": "Adding transform function support for case-when-else", "committedDate": "2020-06-10T05:43:03Z", "type": "commit"}, {"oid": "8f64bec216ade1d56fbb5e45173f8967d3edfe28", "url": "https://github.com/apache/pinot/commit/8f64bec216ade1d56fbb5e45173f8967d3edfe28", "message": "Checks on then statements result type", "committedDate": "2020-06-10T05:43:03Z", "type": "commit"}, {"oid": "d5315ce75f81fc7fdecd93b1f8494834e9967199", "url": "https://github.com/apache/pinot/commit/d5315ce75f81fc7fdecd93b1f8494834e9967199", "message": "Not allowing aggregation functions in case statements for now", "committedDate": "2020-06-10T05:43:03Z", "type": "commit"}, {"oid": "0a8ee5e7699455e108841e74a23a4ce3a8cfdaad", "url": "https://github.com/apache/pinot/commit/0a8ee5e7699455e108841e74a23a4ce3a8cfdaad", "message": "Address comments", "committedDate": "2020-06-10T05:43:03Z", "type": "commit"}, {"oid": "1f9ec7fc02e900a960ebe4dc863a986ae1ef99f8", "url": "https://github.com/apache/pinot/commit/1f9ec7fc02e900a960ebe4dc863a986ae1ef99f8", "message": "Address comments", "committedDate": "2020-06-10T05:43:03Z", "type": "commit"}, {"oid": "76e91030fe442b01360af3fd5cf07b4b0c166358", "url": "https://github.com/apache/pinot/commit/76e91030fe442b01360af3fd5cf07b4b0c166358", "message": "Address comments", "committedDate": "2020-06-10T05:43:03Z", "type": "commit"}, {"oid": "2efaa03b25843b5db0b1fd19292d62da4cd8f2be", "url": "https://github.com/apache/pinot/commit/2efaa03b25843b5db0b1fd19292d62da4cd8f2be", "message": "update case statement to skip some conditions won't happen", "committedDate": "2020-06-10T05:43:03Z", "type": "commit"}, {"oid": "eeccadb5b4b65e6ec528594fbf6302ad6c7da117", "url": "https://github.com/apache/pinot/commit/eeccadb5b4b65e6ec528594fbf6302ad6c7da117", "message": "Infer literal type in case-when statements", "committedDate": "2020-06-10T05:43:03Z", "type": "commit"}, {"oid": "eeccadb5b4b65e6ec528594fbf6302ad6c7da117", "url": "https://github.com/apache/pinot/commit/eeccadb5b4b65e6ec528594fbf6302ad6c7da117", "message": "Infer literal type in case-when statements", "committedDate": "2020-06-10T05:43:03Z", "type": "forcePushed"}]}