{"pr_number": 5013, "pr_title": "For RANGE predicate queries touching offline segments, use sorted inverted index if the column is sorted", "pr_createdAt": "2020-01-24T07:25:57Z", "pr_url": "https://github.com/apache/pinot/pull/5013", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3ODUzMg==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370778532", "bodyText": "This had to be fixed since DaysSinceEpoch is a sorted column and will be using sorted inverted index operator and doc id set. So the number of entries scanned in filter will be 0.", "author": "siddharthteotia", "createdAt": "2020-01-24T18:30:57Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java", "diffHunk": "@@ -418,7 +418,6 @@ public void testDictionaryBasedQueries()\n     pqlQuery = \"SELECT MAX(ArrTime) FROM \" + DEFAULT_TABLE_NAME + \" where DaysSinceEpoch > 16100\";\n     response = postQuery(pqlQuery);\n     assertTrue(response.get(\"numEntriesScannedPostFilter\").asLong() > 0);\n-    assertTrue(response.get(\"numEntriesScannedInFilter\").asLong() > 0);", "originalCommit": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDYwNA==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370800604", "bodyText": "Can you change it to  assertEquals(response.get(\"numEntriesScannedInFilter\").asLong(), 0)?", "author": "Jackie-Jiang", "createdAt": "2020-01-24T19:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3ODUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4OTQ4OQ==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370889489", "bodyText": "Done", "author": "siddharthteotia", "createdAt": "2020-01-24T23:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3ODUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDY3Mw==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370800673", "bodyText": "Same here", "author": "Jackie-Jiang", "createdAt": "2020-01-24T19:20:51Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java", "diffHunk": "@@ -469,7 +468,6 @@ public void testMetadataBasedQueries()\n     pqlQuery = \"SELECT COUNT(*) FROM \" + DEFAULT_TABLE_NAME + \" WHERE DaysSinceEpoch > 16100\";\n     response = postQuery(pqlQuery);\n     assertEquals(response.get(\"numEntriesScannedPostFilter\").asLong(), 0);\n-    assertTrue(response.get(\"numEntriesScannedInFilter\").asLong() > 0);", "originalCommit": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4Mzk2OQ==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370883969", "bodyText": "My bad -- should have actually done that instead of removing. Good catch", "author": "siddharthteotia", "createdAt": "2020-01-24T23:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDk4MQ==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370800981", "bodyText": "(nit) new line", "author": "Jackie-Jiang", "createdAt": "2020-01-24T19:21:34Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.queries;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.pinot.common.segment.ReadMode;\n+import org.apache.pinot.common.utils.Pairs;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.GenericRowRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentLoader;\n+import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n+import org.apache.pinot.core.operator.query.SelectionOnlyOperator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;\n+import org.apache.pinot.pql.parsers.Pql2Compiler;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.testng.collections.Lists;\n+\n+\n+public class TestRangePredicateWithSortedInvertedIndex extends BaseQueriesTest {\n+  private static final int NUM_ROWS = 30000;\n+\n+  private List<GenericRow> _rows = new ArrayList<>();\n+\n+  private static final String D1 = \"STRING_COL\";\n+  private static final String M1 = \"INT_COL\"; // sorted column\n+  private static final String M2 = \"LONG_COL\";\n+\n+  private static final int INT_BASE_VALUE = 0;\n+\n+  private static final String TABLE_NAME = \"TestTable\";\n+  private static final int NUM_SEGMENTS = 1;\n+  private static final String SEGMENT_NAME_1 = TABLE_NAME + \"_100000000_200000000\";\n+  private static final File INDEX_DIR = new File(FileUtils.getTempDirectory(), \"SortedRangeTest\");\n+\n+  private List<IndexSegment> _indexSegments = new ArrayList<>(NUM_SEGMENTS);\n+  private final String[] stringValues = new String[NUM_ROWS];\n+  private final long[] longValues = new long[NUM_ROWS];\n+\n+  private Schema _schema;\n+\n+  @BeforeClass\n+  public void setUp() {\n+    createPinotTableSchema();\n+    createTestData();\n+  }\n+\n+  @AfterClass\n+  public void tearDown() {\n+    FileUtils.deleteQuietly(INDEX_DIR);\n+  }\n+\n+  private void createPinotTableSchema() {\n+    _schema =\n+        new Schema.SchemaBuilder().setSchemaName(TABLE_NAME).addSingleValueDimension(D1, FieldSpec.DataType.STRING)\n+            .addMetric(M1, FieldSpec.DataType.INT).addMetric(M2, FieldSpec.DataType.LONG).build();\n+  }\n+\n+  private void createTestData() {\n+    Random random = new Random();\n+    for (int rowIndex = 0; rowIndex < NUM_ROWS; rowIndex++) {\n+      GenericRow row = new GenericRow();\n+      stringValues[rowIndex] = RandomStringUtils.randomAlphanumeric(10);\n+      row.putValue(D1, stringValues[rowIndex]);\n+      row.putValue(M1, INT_BASE_VALUE + rowIndex);\n+      longValues[rowIndex] = random.nextLong();\n+      row.putValue(M2, longValues[rowIndex]);\n+      _rows.add(row);\n+    }\n+  }\n+\n+  @Override\n+  protected String getFilter() {\n+    return \"\";\n+  }\n+\n+  @Override\n+  protected IndexSegment getIndexSegment() {\n+    return _indexSegments.get(0);\n+  }\n+\n+  @Override\n+  protected List<SegmentDataManager> getSegmentDataManagers() {\n+    return null;\n+  }\n+\n+  private void createSegment(Schema schema, RecordReader recordReader, String segmentName, String tableName)\n+      throws Exception {\n+    SegmentGeneratorConfig segmentGeneratorConfig = new SegmentGeneratorConfig(schema);\n+    segmentGeneratorConfig.setTableName(tableName);\n+    segmentGeneratorConfig.setOutDir(INDEX_DIR.getAbsolutePath());\n+    segmentGeneratorConfig.setSegmentName(segmentName);\n+\n+    SegmentIndexCreationDriverImpl driver = new SegmentIndexCreationDriverImpl();\n+    driver.init(segmentGeneratorConfig, recordReader);\n+    driver.build();\n+\n+    File segmentIndexDir = new File(INDEX_DIR.getAbsolutePath(), segmentName);\n+    if (!segmentIndexDir.exists()) {\n+      throw new IllegalStateException(\"Segment generation failed\");\n+    }\n+  }\n+\n+  private ImmutableSegment loadSegment(String segmentName)\n+      throws Exception {\n+    return ImmutableSegmentLoader.load(new File(INDEX_DIR, segmentName), ReadMode.heap);\n+  }\n+\n+  @Test\n+  public void testInnerSegmentQuery()\n+      throws Exception {\n+    Random random = new Random();\n+    try (RecordReader recordReader = new GenericRowRecordReader(_rows, _schema)) {\n+      createSegment(_schema, recordReader, SEGMENT_NAME_1, TABLE_NAME);\n+      final ImmutableSegment immutableSegment = loadSegment(SEGMENT_NAME_1);\n+      _indexSegments.add(immutableSegment);\n+\n+      String query = \"SELECT STRING_COL, INT_COL FROM TestTable WHERE INT_COL >= 20000 LIMIT 100000\";\n+      Pairs.IntPair pair = new Pairs.IntPair(20000, 29999);\n+      runQuery(query, 10000, Lists.newArrayList(pair), 2);\n+\n+      query = \"SELECT STRING_COL, INT_COL FROM TestTable WHERE INT_COL >= 20000 AND INT_COL <= 23666 LIMIT 100000\";\n+      pair = new Pairs.IntPair(20000, 23666);\n+      runQuery(query, 3667, Lists.newArrayList(pair), 2);\n+\n+      query = \"SELECT STRING_COL, INT_COL FROM TestTable WHERE INT_COL <= 20000 LIMIT 100000\";\n+      pair = new Pairs.IntPair(0, 20000);\n+      runQuery(query, 20001, Lists.newArrayList(pair), 2);\n+\n+      String filter = \"WHERE (INT_COL >= 15000 AND INT_COL <= 16665) OR (INT_COL >= 18000 AND INT_COL <= 19887)\";\n+      query = \"SELECT STRING_COL, INT_COL FROM TestTable \" + filter + \" LIMIT 100000\";\n+      pair = new Pairs.IntPair(15000, 16665);\n+      Pairs.IntPair pair1 = new Pairs.IntPair(18000, 19987);\n+      runQuery(query, 3554, Lists.newArrayList(pair, pair1), 2);\n+\n+      // range predicate on sorted column which will use sorted inverted index based iterator\n+      // along with range predicate on unsorted column that uses scan based iterator\n+      int index = random.nextInt(NUM_ROWS + 1);\n+      long longPredicateValue = longValues[index];\n+      int count = 0;\n+      List<Pairs.IntPair> pairs = new ArrayList<>();\n+      Pairs.IntPair current = null;\n+      for (int i = 0 ; i < longValues.length; i++) {\n+        if (longValues[i] >= longPredicateValue && i >= 15000 && i <= 16665) {\n+          if (current == null) {\n+            current = new Pairs.IntPair(i, i);\n+          } else {\n+            if (i == current.getRight() + 1) {\n+              current.setRight(i);\n+            } else {\n+              if (i <= longValues.length - 2) {\n+                pairs.add(current);\n+                current = new Pairs.IntPair(i, i);\n+              }\n+            }\n+          }\n+          count++;\n+        }\n+      }\n+      pairs.add(current);\n+      filter = \"WHERE INT_COL >= 15000 AND INT_COL <= 16665 AND LONG_COL >= \" + longPredicateValue;\n+      query = \"SELECT STRING_COL, INT_COL, LONG_COL FROM TestTable \" + filter + \" LIMIT 100000\";\n+      runQuery(query, count, pairs, 3);\n+    } finally {\n+      destroySegments();\n+    }\n+  }\n+\n+  private void runQuery(String query, int count, List<Pairs.IntPair> intPairs, int numColumns) {\n+    SelectionOnlyOperator operator = getOperatorForQuery(query);\n+    IntermediateResultsBlock block = operator.nextBlock();\n+    Collection<Serializable[]> rows = block.getSelectionResult();\n+    Assert.assertNotNull(rows);\n+    Assert.assertEquals(rows.size(), count);\n+    Pairs.IntPair pair = intPairs.get(0);\n+    int startPos = pair.getLeft();\n+    int pairPos = 0;\n+    for (Serializable[] row : rows) {\n+      Assert.assertEquals(numColumns, row.length);\n+      Assert.assertEquals(row[0], stringValues[startPos]);\n+      Assert.assertEquals(row[1], startPos);\n+      if (numColumns == 3) {\n+        Assert.assertEquals(row[2], longValues[startPos]);\n+      }\n+      startPos++;\n+      if (startPos > pair.getRight() && pairPos <= intPairs.size() - 2) {\n+        pairPos++;\n+        pair = intPairs.get(pairPos);\n+        startPos = pair.getLeft();\n+      }\n+    }\n+  }\n+\n+  private void destroySegments() {\n+    for (IndexSegment indexSegment : _indexSegments) {\n+      if (indexSegment != null) {\n+        indexSegment.destroy();\n+      }\n+    }\n+    _indexSegments.clear();\n+  }\n+}", "originalCommit": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4Mzg0NQ==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370883845", "bodyText": "Done", "author": "siddharthteotia", "createdAt": "2020-01-24T23:21:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNTk0NA==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370805944", "bodyText": "This is not efficient. We should add getStartDictId() and getEndDictId() to OfflineDictionaryBasedRangePredicateEvaluator, and directly get the start and end dict id.", "author": "Jackie-Jiang", "createdAt": "2020-01-24T19:32:39Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedInvertedIndexBasedFilterOperator.java", "diffHunk": "@@ -78,82 +79,92 @@ protected FilterBlock getNextBlock() {\n     int[] dictIds = exclusive ? _predicateEvaluator.getNonMatchingDictIds() : _predicateEvaluator.getMatchingDictIds();\n \n     if (0 < dictIds.length) {\n-      // Sort the dictIds in ascending order, so that their respective ranges are adjacent if their dictIds are adjacent\n-      Arrays.sort(dictIds);\n+      if (_predicateEvaluator instanceof RangePredicateEvaluatorFactory.OfflineDictionaryBasedRangePredicateEvaluator) {\n+        // optimized path for RANGE predicate evaluation using sorted index.\n+        // dictIds will already be sorted since we use sorted index based evaluation\n+        // for RANGE predicates only on offline segments.\n+        // so build a pair with startDocId and endDocId\n+        IntPair pair1 = invertedIndex.getDocIds(dictIds[0]);", "originalCommit": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4MjM5NA==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370882394", "bodyText": "Good suggestion. Done... no need to call getMatchingDictIds", "author": "siddharthteotia", "createdAt": "2020-01-24T23:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNTk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370807142", "bodyText": "I think checking dataSourceMetadata.isSorted() should be enough?", "author": "Jackie-Jiang", "createdAt": "2020-01-24T19:35:15Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java", "diffHunk": "@@ -56,16 +57,23 @@ public static BaseFilterOperator getLeafFilterOperator(PredicateEvaluator predic\n     // Use inverted index if the predicate type is not RANGE or REGEXP_LIKE for efficiency\n     DataSourceMetadata dataSourceMetadata = dataSource.getDataSourceMetadata();\n     Predicate.Type predicateType = predicateEvaluator.getPredicateType();\n-    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.RANGE) && (predicateType\n-        != Predicate.Type.REGEXP_LIKE)) {\n-      if (dataSourceMetadata.isSorted()) {\n+    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.REGEXP_LIKE)) {\n+      if (shouldUseSortedInvertedIndexOperator(dataSource, predicateType)) {", "originalCommit": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2NDI1Ng==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370864256", "bodyText": "The logic should be this right (also mentioned in the code comments)?\nwe use can sorted inverted index if:\n\ncolumn is sorted AND\npredicate is not RANGE OR predicate is RANGE but this physical plan is being built for offline segment", "author": "siddharthteotia", "createdAt": "2020-01-24T22:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5NTM4Mw==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370895383", "bodyText": "If the column is sorted, we can use sorted index if there is no RANGE predicate -- we do this today.\nIf the column is sorted and there is RANGE predicate, use sorted index only for offline segments.", "author": "siddharthteotia", "createdAt": "2020-01-25T00:24:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNDQzMg==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371404432", "bodyText": "Discussed offline.\ndataSourceMetadata.isSorted() is enough since dataSourceMetadata.isSorted() will always be false for realtime segments so we don't need an enhanced check.", "author": "siddharthteotia", "createdAt": "2020-01-27T18:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNTAxOA==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371405018", "bodyText": "You mean dataSourceMetadata.isSorted() is always false for realtime right?", "author": "Jackie-Jiang", "createdAt": "2020-01-27T18:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQxMDE2Mw==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371410163", "bodyText": "Exactly. Since MutableSegmentImpl calls the constructor of ColumnDataSource with isSorted as false.", "author": "siddharthteotia", "createdAt": "2020-01-27T18:34:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODcyMg==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370878722", "bodyText": "The condition here seems not consistent with the PR summary/title. For example, take the first part of OR in (2). It says sorted inverted index can be used if (1) column is sorted AND (2) predicate is not RANGE. This is not what the PR title means. Am I missing anything here?", "author": "chenboat", "createdAt": "2020-01-24T22:59:30Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java", "diffHunk": "@@ -56,16 +57,23 @@ public static BaseFilterOperator getLeafFilterOperator(PredicateEvaluator predic\n     // Use inverted index if the predicate type is not RANGE or REGEXP_LIKE for efficiency\n     DataSourceMetadata dataSourceMetadata = dataSource.getDataSourceMetadata();\n     Predicate.Type predicateType = predicateEvaluator.getPredicateType();\n-    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.RANGE) && (predicateType\n-        != Predicate.Type.REGEXP_LIKE)) {\n-      if (dataSourceMetadata.isSorted()) {\n+    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.REGEXP_LIKE)) {\n+      if (shouldUseSortedInvertedIndexOperator(dataSource, predicateType)) {\n         return new SortedInvertedIndexBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n-      } else {\n+      } else if (predicateType != Predicate.Type.RANGE) {\n+        // TODO: add support for bitmap inverted index operator can be used for RANGE predicate\n         return new BitmapBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n       }\n-    } else {\n-      return new ScanBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n     }\n+    return new ScanBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n+  }\n+\n+  private static boolean shouldUseSortedInvertedIndexOperator(DataSource dataSource, Predicate.Type predicateType) {\n+    boolean isSorted = dataSource.getDataSourceMetadata().isSorted();\n+    // we can sorted inverted index if:\n+    // 1. column is sorted AND\n+    // 2. predicate is not RANGE OR predicate is RANGE but this physical plan is being built for offline segment", "originalCommit": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4MzA1Nw==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370883057", "bodyText": "If the column is sorted, we can use sorted index if there is no RANGE predicate -- we do this today.\nIf the column is sorted and there is RANGE predicate, use sorted index only for offline segments.", "author": "siddharthteotia", "createdAt": "2020-01-24T23:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODcyMg=="}], "type": "inlineReview"}, {"oid": "754a54c17cd95ff878d6efd5c039240cfdbac8f2", "url": "https://github.com/apache/pinot/commit/754a54c17cd95ff878d6efd5c039240cfdbac8f2", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index.", "committedDate": "2020-01-24T23:54:13Z", "type": "forcePushed"}, {"oid": "c9ff3dd50952719e07842b5de7c5816257404880", "url": "https://github.com/apache/pinot/commit/c9ff3dd50952719e07842b5de7c5816257404880", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index.", "committedDate": "2020-01-27T18:24:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNDUyMg==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371404522", "bodyText": "Let's return _endDictId and do this -1 at the caller side with comments for readability", "author": "Jackie-Jiang", "createdAt": "2020-01-27T18:22:58Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/RangePredicateEvaluatorFactory.java", "diffHunk": "@@ -129,6 +129,14 @@ public static BaseRawValueBasedPredicateEvaluator newRawValueBasedEvaluator(Rang\n       }\n     }\n \n+    public int getStartDictId() {\n+      return _startDictId;\n+    }\n+\n+    public int getEndDictId() {\n+      return _endDictId - 1;", "originalCommit": "754a54c17cd95ff878d6efd5c039240cfdbac8f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQxNTk0Ng==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371415946", "bodyText": "Done.", "author": "siddharthteotia", "createdAt": "2020-01-27T18:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNDUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNTY2NQ==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371405665", "bodyText": "Can you rename this to RangePredicateWithSortedInvertedIndexTest?", "author": "Jackie-Jiang", "createdAt": "2020-01-27T18:25:18Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.queries;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.pinot.common.segment.ReadMode;\n+import org.apache.pinot.common.utils.Pairs;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.GenericRowRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentLoader;\n+import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n+import org.apache.pinot.core.operator.query.SelectionOnlyOperator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;\n+import org.apache.pinot.pql.parsers.Pql2Compiler;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.testng.collections.Lists;\n+\n+\n+public class TestRangePredicateWithSortedInvertedIndex extends BaseQueriesTest {", "originalCommit": "c9ff3dd50952719e07842b5de7c5816257404880", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQxNTk3Mg==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371415972", "bodyText": "Done", "author": "siddharthteotia", "createdAt": "2020-01-27T18:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNTY2NQ=="}], "type": "inlineReview"}, {"oid": "1728e1049d0504cf2c25a2e8252093ae90c2fd09", "url": "https://github.com/apache/pinot/commit/1728e1049d0504cf2c25a2e8252093ae90c2fd09", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index.", "committedDate": "2020-01-27T18:47:24Z", "type": "commit"}, {"oid": "1728e1049d0504cf2c25a2e8252093ae90c2fd09", "url": "https://github.com/apache/pinot/commit/1728e1049d0504cf2c25a2e8252093ae90c2fd09", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index.", "committedDate": "2020-01-27T18:47:24Z", "type": "forcePushed"}]}