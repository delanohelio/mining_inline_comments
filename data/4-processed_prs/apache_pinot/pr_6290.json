{"pr_number": 6290, "pr_title": "[TE]frontend - Build the tree parser for composite anomalies", "pr_createdAt": "2020-11-25T10:48:29Z", "pr_url": "https://github.com/apache/pinot/pull/6290", "timeline": [{"oid": "7589f594f9a3f99023f1f66e535887f6a725f551", "url": "https://github.com/apache/pinot/commit/7589f594f9a3f99023f1f66e535887f6a725f551", "message": "[TE]frontend - Build the tree parser for composite anomalies", "committedDate": "2020-11-25T10:57:08Z", "type": "forcePushed"}, {"oid": "9a6cd3d0406137a0329c956f11e3e1e0f35e12d5", "url": "https://github.com/apache/pinot/commit/9a6cd3d0406137a0329c956f11e3e1e0f35e12d5", "message": "[TE]frontend - Build the tree parser for composite anomalies", "committedDate": "2020-11-25T17:47:41Z", "type": "forcePushed"}, {"oid": "dcf352e0e03982aeec28fbaab61224c541e0d0e0", "url": "https://github.com/apache/pinot/commit/dcf352e0e03982aeec28fbaab61224c541e0d0e0", "message": "[TE]frontend - Build the tree parser for composite anomalies", "committedDate": "2020-11-25T18:14:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3NjEyOA==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r532776128", "bodyText": "please keep code style consistency. I remember we enable the single quote rule. You could run prettier to format it.", "author": "zhangloo333", "createdAt": "2020-11-30T17:35:34Z", "path": "thirdeye/thirdeye-frontend/app/utils/anomalies-tree-parser.js", "diffHunk": "@@ -0,0 +1,563 @@\n+import { isEmpty } from \"@ember/utils\";\n+import { set } from \"@ember/object\";\n+import moment from \"moment\";\n+\n+const CLASSIFICATIONS = {\n+  METRICS: {\n+    KEY: \"metrics\",", "originalCommit": "dcf352e0e03982aeec28fbaab61224c541e0d0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk3NDk4NA==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r532974984", "bodyText": "Can you tell me what is the exact command for it? Is it tied to your code changes in #6245? If so, I may not be able to do as your changes are not merged yet.", "author": "tejasajmera", "createdAt": "2020-11-30T23:39:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3NjEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxNjQzNQ==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r533016435", "bodyText": "I haven't realized my code hasn't merged yet. The command npm run eslint-app only can detect errors, but not fix them. You need to fix manually or set your vscode prettier with the rule of a single quote.", "author": "zhangloo333", "createdAt": "2020-12-01T01:39:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3NjEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTE5Mw==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r532779193", "bodyText": "I suggest you put this time format in the constant.js or to create a constant folder. it's a common useful variable. We can inject into the function.", "author": "zhangloo333", "createdAt": "2020-11-30T17:40:16Z", "path": "thirdeye/thirdeye-frontend/app/utils/anomalies-tree-parser.js", "diffHunk": "@@ -0,0 +1,563 @@\n+import { isEmpty } from \"@ember/utils\";\n+import { set } from \"@ember/object\";\n+import moment from \"moment\";\n+\n+const CLASSIFICATIONS = {\n+  METRICS: {\n+    KEY: \"metrics\",\n+    COMPONENT_PATH: \"entity-metrics\",\n+    DEFAULT_TITLE: \"Metric Anomalies\"\n+  },\n+  GROUPS: {\n+    KEY: \"groups\",\n+    COMPONENT_PATH: \"entity-groups\",\n+    DEFAULT_TITLE: \"ENTITY:\"\n+  },\n+  ENTITIES: {\n+    KEY: \"entities\",\n+    COMPONENT_PATH: \"parent-anomalies\",\n+    DEFAULT_TITLE: \"Entity\"\n+  }\n+};\n+const BREADCRUMB_TIME_DISPLAY_FORMAT = \"MMM D HH:mm\";", "originalCommit": "dcf352e0e03982aeec28fbaab61224c541e0d0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk3NTAyMw==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r532975023", "bodyText": "Sure.", "author": "tejasajmera", "createdAt": "2020-11-30T23:39:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MTk0OQ==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r532781949", "bodyText": "Please add parentheses for input to keep clarity and obey the eslint rule(arrow-parens).\nFor more detail to check 8.4 Always include parentheses around arguments for clarity and consistency. eslint: arrow-parens", "author": "zhangloo333", "createdAt": "2020-11-30T17:44:24Z", "path": "thirdeye/thirdeye-frontend/app/utils/anomalies-tree-parser.js", "diffHunk": "@@ -0,0 +1,563 @@\n+import { isEmpty } from \"@ember/utils\";\n+import { set } from \"@ember/object\";\n+import moment from \"moment\";\n+\n+const CLASSIFICATIONS = {\n+  METRICS: {\n+    KEY: \"metrics\",\n+    COMPONENT_PATH: \"entity-metrics\",\n+    DEFAULT_TITLE: \"Metric Anomalies\"\n+  },\n+  GROUPS: {\n+    KEY: \"groups\",\n+    COMPONENT_PATH: \"entity-groups\",\n+    DEFAULT_TITLE: \"ENTITY:\"\n+  },\n+  ENTITIES: {\n+    KEY: \"entities\",\n+    COMPONENT_PATH: \"parent-anomalies\",\n+    DEFAULT_TITLE: \"Entity\"\n+  }\n+};\n+const BREADCRUMB_TIME_DISPLAY_FORMAT = \"MMM D HH:mm\";\n+\n+/**\n+ * Format the timestamp into the form to be shown in the breadcrumb\n+ *\n+ * @param {Number} timestamp\n+ *   The timestamp of anomaly creation time in milliseconds\n+ *\n+ * @returns {String}\n+ *   Formatted timestamp. Example of the required format - \"Sep 15 16:49 EST\"\n+ */\n+const getFormattedBreadcrumbTime = timestamp => {\n+  const zoneName = moment.tz.guess();\n+  const timeZoneAbbreviation = moment.tz(zoneName).zoneAbbr();\n+\n+  return `${moment(timestamp).format(\n+    BREADCRUMB_TIME_DISPLAY_FORMAT\n+  )} ${timeZoneAbbreviation}`;\n+};\n+\n+/**\n+ * Parse the anomalies generated by the composite alert to populate parent-anomalies table with relevent details about\n+ * children for each anomaly.\n+ *\n+ * @param {Array<Object>} input\n+ *   The anomalies for composite alert.\n+ *\n+ * @returns {Array<Object>}\n+ *   Parsed out contents to populate parent-anomalies table\n+ */\n+const populateParentAnomaliesTable = input => {", "originalCommit": "dcf352e0e03982aeec28fbaab61224c541e0d0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk3NTA4MQ==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r532975081", "bodyText": "Sure.", "author": "tejasajmera", "createdAt": "2020-11-30T23:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MTk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MzU0Mw==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r532783543", "bodyText": "if there is no complicated logic, you could use the ternary to shorter logic and reduce code.", "author": "zhangloo333", "createdAt": "2020-11-30T17:46:44Z", "path": "thirdeye/thirdeye-frontend/app/utils/anomalies-tree-parser.js", "diffHunk": "@@ -0,0 +1,563 @@\n+import { isEmpty } from \"@ember/utils\";\n+import { set } from \"@ember/object\";\n+import moment from \"moment\";\n+\n+const CLASSIFICATIONS = {\n+  METRICS: {\n+    KEY: \"metrics\",\n+    COMPONENT_PATH: \"entity-metrics\",\n+    DEFAULT_TITLE: \"Metric Anomalies\"\n+  },\n+  GROUPS: {\n+    KEY: \"groups\",\n+    COMPONENT_PATH: \"entity-groups\",\n+    DEFAULT_TITLE: \"ENTITY:\"\n+  },\n+  ENTITIES: {\n+    KEY: \"entities\",\n+    COMPONENT_PATH: \"parent-anomalies\",\n+    DEFAULT_TITLE: \"Entity\"\n+  }\n+};\n+const BREADCRUMB_TIME_DISPLAY_FORMAT = \"MMM D HH:mm\";\n+\n+/**\n+ * Format the timestamp into the form to be shown in the breadcrumb\n+ *\n+ * @param {Number} timestamp\n+ *   The timestamp of anomaly creation time in milliseconds\n+ *\n+ * @returns {String}\n+ *   Formatted timestamp. Example of the required format - \"Sep 15 16:49 EST\"\n+ */\n+const getFormattedBreadcrumbTime = timestamp => {\n+  const zoneName = moment.tz.guess();\n+  const timeZoneAbbreviation = moment.tz(zoneName).zoneAbbr();\n+\n+  return `${moment(timestamp).format(\n+    BREADCRUMB_TIME_DISPLAY_FORMAT\n+  )} ${timeZoneAbbreviation}`;\n+};\n+\n+/**\n+ * Parse the anomalies generated by the composite alert to populate parent-anomalies table with relevent details about\n+ * children for each anomaly.\n+ *\n+ * @param {Array<Object>} input\n+ *   The anomalies for composite alert.\n+ *\n+ * @returns {Array<Object>}\n+ *   Parsed out contents to populate parent-anomalies table\n+ */\n+const populateParentAnomaliesTable = input => {\n+  const output = [];\n+\n+  for (const entry of input) {\n+    const { id, startTime, endTime, feedback, children } = entry;\n+    const entryOutput = {\n+      id,\n+      startTime,\n+      endTime,\n+      feedback\n+    };\n+\n+    const details = {};\n+    let item;\n+    if (children.length > 0) {\n+      for (const child of children) {\n+        const { metric, properties: { subEntityName } = {} } = child;\n+\n+        if (!isEmpty(metric)) {", "originalCommit": "dcf352e0e03982aeec28fbaab61224c541e0d0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk3ODI3Mg==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r532978272", "bodyText": "Will do.", "author": "tejasajmera", "createdAt": "2020-11-30T23:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4MzU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4NDgxNA==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r532784814", "bodyText": "ditto, coding style", "author": "zhangloo333", "createdAt": "2020-11-30T17:48:40Z", "path": "thirdeye/thirdeye-frontend/app/utils/anomalies-tree-parser.js", "diffHunk": "@@ -0,0 +1,563 @@\n+import { isEmpty } from \"@ember/utils\";\n+import { set } from \"@ember/object\";\n+import moment from \"moment\";\n+\n+const CLASSIFICATIONS = {\n+  METRICS: {\n+    KEY: \"metrics\",\n+    COMPONENT_PATH: \"entity-metrics\",\n+    DEFAULT_TITLE: \"Metric Anomalies\"\n+  },\n+  GROUPS: {\n+    KEY: \"groups\",\n+    COMPONENT_PATH: \"entity-groups\",\n+    DEFAULT_TITLE: \"ENTITY:\"\n+  },\n+  ENTITIES: {\n+    KEY: \"entities\",\n+    COMPONENT_PATH: \"parent-anomalies\",\n+    DEFAULT_TITLE: \"Entity\"\n+  }\n+};\n+const BREADCRUMB_TIME_DISPLAY_FORMAT = \"MMM D HH:mm\";\n+\n+/**\n+ * Format the timestamp into the form to be shown in the breadcrumb\n+ *\n+ * @param {Number} timestamp\n+ *   The timestamp of anomaly creation time in milliseconds\n+ *\n+ * @returns {String}\n+ *   Formatted timestamp. Example of the required format - \"Sep 15 16:49 EST\"\n+ */\n+const getFormattedBreadcrumbTime = timestamp => {\n+  const zoneName = moment.tz.guess();\n+  const timeZoneAbbreviation = moment.tz(zoneName).zoneAbbr();\n+\n+  return `${moment(timestamp).format(\n+    BREADCRUMB_TIME_DISPLAY_FORMAT\n+  )} ${timeZoneAbbreviation}`;\n+};\n+\n+/**\n+ * Parse the anomalies generated by the composite alert to populate parent-anomalies table with relevent details about\n+ * children for each anomaly.\n+ *\n+ * @param {Array<Object>} input\n+ *   The anomalies for composite alert.\n+ *\n+ * @returns {Array<Object>}\n+ *   Parsed out contents to populate parent-anomalies table\n+ */\n+const populateParentAnomaliesTable = input => {\n+  const output = [];\n+\n+  for (const entry of input) {\n+    const { id, startTime, endTime, feedback, children } = entry;\n+    const entryOutput = {\n+      id,\n+      startTime,\n+      endTime,\n+      feedback\n+    };\n+\n+    const details = {};\n+    let item;\n+    if (children.length > 0) {\n+      for (const child of children) {\n+        const { metric, properties: { subEntityName } = {} } = child;\n+\n+        if (!isEmpty(metric)) {\n+          item = metric;\n+        } else {\n+          item = subEntityName;\n+        }\n+\n+        if (item in details) {\n+          details[item]++;\n+        } else {\n+          details[item] = 1;\n+        }\n+      }\n+      entryOutput.details = details;\n+      output.push(entryOutput);\n+    }\n+  }\n+\n+  return output;\n+};\n+\n+/**\n+ * Parse the generated bucket for metric anomalies into the schema for the entity-metrics component\n+ *\n+ * @param {Object} input\n+ *   The metric anomalies bucket constituents\n+ *\n+ * @returns {Array<Object>}\n+ *   The content to be passed into the the leaf level entity-metrics component. Each item in the array represents\n+ *   contents for the row in the table.\n+ */\n+const parseMetricsBucket = input => {", "originalCommit": "dcf352e0e03982aeec28fbaab61224c541e0d0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk3NTEzOQ==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r532975139", "bodyText": "Sure.", "author": "tejasajmera", "createdAt": "2020-11-30T23:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4NDgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MDkwOA==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r532790908", "bodyText": "Please keep the code concise. If an if block always executes a return statement, the subsequent else block is unnecessary.\nPlease check the Airbnb rule. 16.3 or no-else-return", "author": "zhangloo333", "createdAt": "2020-11-30T17:58:00Z", "path": "thirdeye/thirdeye-frontend/app/utils/anomalies-tree-parser.js", "diffHunk": "@@ -0,0 +1,563 @@\n+import { isEmpty } from \"@ember/utils\";\n+import { set } from \"@ember/object\";\n+import moment from \"moment\";\n+\n+const CLASSIFICATIONS = {\n+  METRICS: {\n+    KEY: \"metrics\",\n+    COMPONENT_PATH: \"entity-metrics\",\n+    DEFAULT_TITLE: \"Metric Anomalies\"\n+  },\n+  GROUPS: {\n+    KEY: \"groups\",\n+    COMPONENT_PATH: \"entity-groups\",\n+    DEFAULT_TITLE: \"ENTITY:\"\n+  },\n+  ENTITIES: {\n+    KEY: \"entities\",\n+    COMPONENT_PATH: \"parent-anomalies\",\n+    DEFAULT_TITLE: \"Entity\"\n+  }\n+};\n+const BREADCRUMB_TIME_DISPLAY_FORMAT = \"MMM D HH:mm\";\n+\n+/**\n+ * Format the timestamp into the form to be shown in the breadcrumb\n+ *\n+ * @param {Number} timestamp\n+ *   The timestamp of anomaly creation time in milliseconds\n+ *\n+ * @returns {String}\n+ *   Formatted timestamp. Example of the required format - \"Sep 15 16:49 EST\"\n+ */\n+const getFormattedBreadcrumbTime = timestamp => {\n+  const zoneName = moment.tz.guess();\n+  const timeZoneAbbreviation = moment.tz(zoneName).zoneAbbr();\n+\n+  return `${moment(timestamp).format(\n+    BREADCRUMB_TIME_DISPLAY_FORMAT\n+  )} ${timeZoneAbbreviation}`;\n+};\n+\n+/**\n+ * Parse the anomalies generated by the composite alert to populate parent-anomalies table with relevent details about\n+ * children for each anomaly.\n+ *\n+ * @param {Array<Object>} input\n+ *   The anomalies for composite alert.\n+ *\n+ * @returns {Array<Object>}\n+ *   Parsed out contents to populate parent-anomalies table\n+ */\n+const populateParentAnomaliesTable = input => {\n+  const output = [];\n+\n+  for (const entry of input) {\n+    const { id, startTime, endTime, feedback, children } = entry;\n+    const entryOutput = {\n+      id,\n+      startTime,\n+      endTime,\n+      feedback\n+    };\n+\n+    const details = {};\n+    let item;\n+    if (children.length > 0) {\n+      for (const child of children) {\n+        const { metric, properties: { subEntityName } = {} } = child;\n+\n+        if (!isEmpty(metric)) {\n+          item = metric;\n+        } else {\n+          item = subEntityName;\n+        }\n+\n+        if (item in details) {\n+          details[item]++;\n+        } else {\n+          details[item] = 1;\n+        }\n+      }\n+      entryOutput.details = details;\n+      output.push(entryOutput);\n+    }\n+  }\n+\n+  return output;\n+};\n+\n+/**\n+ * Parse the generated bucket for metric anomalies into the schema for the entity-metrics component\n+ *\n+ * @param {Object} input\n+ *   The metric anomalies bucket constituents\n+ *\n+ * @returns {Array<Object>}\n+ *   The content to be passed into the the leaf level entity-metrics component. Each item in the array represents\n+ *   contents for the row in the table.\n+ */\n+const parseMetricsBucket = input => {\n+  return [input];\n+};\n+\n+/**\n+ * Parse the generated bucket for parent anomalies into the schema for the entity-groups component\n+ *\n+ * @param {Object} input\n+ *   The group anomalies bucket constituents\n+ *\n+ * @returns {Array<Object>}\n+ *   The content to be passed into the the entity-groups component. Each item in the array represents\n+ *   contents for the row in the table.\n+ */\n+const parseGroupsBucket = input => {\n+  const output = [];\n+\n+  for (const group in input) {\n+    output.push(input[group]);\n+  }\n+\n+  return output;\n+};\n+\n+/**\n+ * Parse the generated bucket for parent anomalies into the schema for the parent-anomalies component\n+ *\n+ * @param {Object} input\n+ *   The parent anomalies bucket constituents\n+ *\n+ * @returns {Array<Object>}\n+ *   The content to be passed into the parent-anomalies component. Each item in the array represents\n+ *   contents for the row in the table.\n+ */\n+const parseEntitiesBucket = input => {\n+  const output = [];\n+\n+  for (const entity in input) {\n+    const { componentPath, title, data } = input[entity];\n+\n+    output.push({\n+      componentPath,\n+      title,\n+      data: populateParentAnomaliesTable(data)\n+    });\n+  }\n+\n+  return output;\n+};\n+\n+/**\n+ * Add the anomaly referencing a metric to the metric bucket\n+ *\n+ * @param {Object} buckets\n+ *   The reference to buckets object within which the anomaly needs to be classified\n+ * @param {Object} anomaly\n+ *   The metric anomaly that needs be classified added to the metric bucket\n+ * @param {String} metric\n+ *   The metric for which this anomaly was generated\n+ */\n+const setMetricsBucket = (buckets, anomaly, metric) => {\n+  const {\n+    METRICS: { KEY: metricKey, DEFAULT_TITLE, COMPONENT_PATH }\n+  } = CLASSIFICATIONS;\n+  const { [metricKey]: { data } = {} } = buckets;\n+  const {\n+    id,\n+    startTime,\n+    endTime,\n+    feedback,\n+    avgCurrentVal: current,\n+    avgBaselineVal: predicted\n+  } = anomaly;\n+\n+  const metricTableRow = {\n+    id,\n+    startTime,\n+    endTime,\n+    metric,\n+    feedback,\n+    current,\n+    predicted\n+  };\n+\n+  if (isEmpty(data)) {\n+    const metricBucketObj = {\n+      componentPath: COMPONENT_PATH,\n+      title: DEFAULT_TITLE,\n+      data: [metricTableRow]\n+    };\n+\n+    set(buckets, `${metricKey}`, metricBucketObj);\n+  } else {\n+    data.push(metricTableRow);\n+  }\n+};\n+\n+/**\n+ * Add the anomaly referencing a group constitient to the right group characterized by the subEntityName\n+ *\n+ * @param {Object} buckets\n+ *   The reference to buckets object within which the anomaly needs to be classified\n+ * @param {Object} anomaly\n+ *   The anomaly produced due to the anomaly summarize grouper that needs be classified into the appropriate bucket\n+ * @param {String} subEntityName\n+ *   The entity name under which certain set of metrics would be grouped\n+ * @param {String} groupName\n+ *   The group constituent name. Each group constituent hosts anomalies from one metric.\n+ */\n+const setGroupsBucket = (buckets, anomaly, subEntityName, groupName) => {\n+  const {\n+    GROUPS: { KEY: groupKey, COMPONENT_PATH, DEFAULT_TITLE }\n+  } = CLASSIFICATIONS;\n+  const {\n+    id,\n+    startTime,\n+    endTime,\n+    feedback,\n+    avgCurrentVal: current,\n+    avgBaselineVal: predicted,\n+    properties: { groupScore: criticality }\n+  } = anomaly;\n+  const groupTableRow = {\n+    id,\n+    groupName,\n+    startTime,\n+    endTime,\n+    feedback,\n+    criticality,\n+    current,\n+    predicted\n+  };\n+\n+  if ([groupKey] in buckets) {\n+    if (subEntityName in buckets[groupKey]) {\n+      const {\n+        [subEntityName]: { data }\n+      } = buckets[groupKey];\n+\n+      data.push(groupTableRow);\n+    } else {\n+      set(buckets, `${groupKey}.${subEntityName}`, {\n+        componentPath: COMPONENT_PATH,\n+        title: `${DEFAULT_TITLE}${subEntityName}`,\n+        data: [groupTableRow]\n+      });\n+    }\n+  } else {\n+    set(buckets, `${groupKey}`, {\n+      [subEntityName]: {\n+        componentPath: COMPONENT_PATH,\n+        title: `${DEFAULT_TITLE}${subEntityName}`,\n+        data: [groupTableRow]\n+      }\n+    });\n+  }\n+};\n+\n+/**\n+ * Add the composite anomaly to the right bucket characterized by the subEntityName\n+ *\n+ * @param {Object} buckets\n+ *   The reference to buckets object within which the anomaly needs to be classified\n+ * @param {Object} anomaly\n+ *   The composite anomaly that needs be classified into the appropriate bucket\n+ * @param {String} subEntityName\n+ *   The entity name under which this anomaly falls\n+ */\n+const setEntitiesBucket = (buckets, anomaly, subEntityName) => {\n+  const {\n+    ENTITIES: { KEY: entityKey, COMPONENT_PATH }\n+  } = CLASSIFICATIONS;\n+  let title;\n+\n+  if (isEmpty(subEntityName)) {\n+    const {\n+      ENTITIES: { DEFAULT_TITLE }\n+    } = CLASSIFICATIONS;\n+\n+    title = DEFAULT_TITLE;\n+  } else {\n+    title = subEntityName;\n+  }\n+\n+  if ([entityKey] in buckets) {\n+    if (subEntityName in buckets[entityKey]) {\n+      const {\n+        [subEntityName]: { data }\n+      } = buckets[entityKey];\n+\n+      data.push(anomaly);\n+    } else {\n+      set(buckets, `${entityKey}.${subEntityName}`, {\n+        componentPath: COMPONENT_PATH,\n+        title: title,\n+        data: [anomaly]\n+      });\n+    }\n+  } else {\n+    set(buckets, `${entityKey}`, {\n+      [subEntityName]: {\n+        componentPath: COMPONENT_PATH,\n+        title: title,\n+        data: [anomaly]\n+      }\n+    });\n+  }\n+};\n+\n+/**\n+ * Classify the child anomalies of particular anomaly into metrics, groups and parent-anomalies\n+ *   -Anomalies of the yaml type METRIC_ALERT classify into \"metrics\"\n+ *   -Anomalies of the yaml type METRIC_ALERT and grouper as ANOMALY_SUMMARIZE classify into \"groups\"\n+ *   -Anomalies of the yaml type COMPOSITE_ALERT classify into \"parent-anomalies\"\n+ *\n+ * @param {Object} input\n+ *   The subtree structure that needs to be parsed\n+ *\n+ * @return {Object}\n+ *   The classification of children anomalies into the buckets of \"metrics\", \"groups\" and \"entities\".\n+ *   The structure will take the form as below\n+ *   {\n+ *     metrics: {\n+ *        componentPath: '',\n+ *        title: '',\n+ *        data:[{},{}] //anomaly entries\n+ *      },\n+ *     groups: {\n+ *         groupEntity1: {\n+ *            componentPath: '',\n+ *            title:'',\n+ *            data:[{},{}]  //each entry in array corresponds to information for 1 group constituent\n+ *         },\n+ *         groupEntity2: {\n+ *         }\n+ *      },\n+ *     entities: {\n+ *         entity1: {\n+ *           componentPath: '',\n+ *            title:'',\n+ *            data:[{},{}]\n+ *         },\n+ *         entity2: {\n+ *         }\n+ *     }\n+ *   }\n+ */\n+const generateBuckets = input => {\n+  const buckets = {};\n+  const { children } = input;\n+\n+  for (const child of children) {\n+    const {\n+      metric,\n+      properties: { detectorComponentName = \"\", subEntityName, groupKey } = {}\n+    } = child;\n+\n+    if (!isEmpty(metric)) {\n+      setMetricsBucket(buckets, child, metric);\n+    } else if (\n+      isEmpty(metric) &&\n+      detectorComponentName.includes(\"ANOMALY_SUMMARIZE\")\n+    ) {\n+      setGroupsBucket(buckets, child, subEntityName, groupKey);\n+    } else {\n+      setEntitiesBucket(buckets, child, subEntityName);\n+    }\n+  }\n+\n+  return buckets;\n+};\n+\n+/**\n+ * Perform drilldown of anomaly grouped by anomaly summarize grouper. This involves generating the breadcrumb information\n+ * and component details for the subtree for this anomaly.\n+ *\n+ * @param {Object} input\n+ *   The subtree structure that needs to be parsed\n+ *\n+ * @return {Object}\n+ *   The breadcrumb info and data for populating component comprising of group constituents\n+ */\n+const parseGroupAnomaly = input => {\n+  const output = [];\n+  const data = [];\n+  const {\n+    GROUPS: { DEFAULT_TITLE, COMPONENT_PATH }\n+  } = CLASSIFICATIONS;\n+  const {\n+    id,\n+    children,\n+    properties: { subEntityName, groupKey }\n+  } = input;\n+  const breadcrumbInfo = {\n+    title: `${subEntityName}/${groupKey}`,\n+    id\n+  };\n+\n+  for (const anomaly of children) {\n+    const {\n+      id,\n+      startTime,\n+      endTime,\n+      metric,\n+      dimensions,\n+      avgCurrentVal: current,\n+      avgBaselineVal: predicted,\n+      feedback\n+    } = anomaly;\n+\n+    data.push({\n+      id,\n+      startTime,\n+      endTime,\n+      feedback,\n+      metric,\n+      dimensions,\n+      current,\n+      predicted\n+    });\n+  }\n+\n+  output.push({\n+    componentPath: COMPONENT_PATH,\n+    title: DEFAULT_TITLE,\n+    data\n+  });\n+\n+  return { breadcrumbInfo, output };\n+};\n+\n+/**\n+ * Perform drilldown of composite anomaly. This involves generating the breadcrumb information\n+ * and component details for the subtree for the composite anomaly\n+ *\n+ * @param {Object} input\n+ *   The subtree structure that needs to be parsed\n+ *\n+ * @return {Object}\n+ *   The breadcrumb info and data for populating child components from input subtree.\n+ */\n+const parseCompositeAnomaly = input => {\n+  const output = [];\n+  const buckets = generateBuckets(input);\n+  const {\n+    METRICS: { KEY: metricKey },\n+    GROUPS: { KEY: groupKey }\n+  } = CLASSIFICATIONS;\n+  const { id, startTime } = input;\n+  const breadcrumbInfo = {\n+    id,\n+    title: getFormattedBreadcrumbTime(startTime)\n+  };\n+\n+  for (const key in buckets) {\n+    const entry = buckets[key];\n+\n+    if (key === metricKey) {\n+      output.push(...parseMetricsBucket(entry));\n+    } else if (key === groupKey) {\n+      output.push(...parseGroupsBucket(entry));\n+    } else {\n+      output.push(...parseEntitiesBucket(entry));\n+    }\n+  }\n+\n+  return { breadcrumbInfo, output };\n+};\n+\n+/**\n+ * Perform depth-first-search to retrieve anomaly in the tree\n+ *\n+ * @param {Number} id\n+ *   The id of the anomaly to be searched\n+ * @param {Object} input\n+ *   The subtree structure comprising the anomaly\n+ *\n+ * @return {Object}\n+ *   The anomaly referenced by id\n+ */\n+const findAnomaly = (id, input) => {\n+  const { id: anomalyId, children } = input;\n+\n+  if (anomalyId === id) {\n+    return input;\n+  } else {", "originalCommit": "dcf352e0e03982aeec28fbaab61224c541e0d0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk3ODg3NQ==", "url": "https://github.com/apache/pinot/pull/6290#discussion_r532978875", "bodyText": "Yeah more than aiming for conciseness I was just trying to keeping it explicit. Anyway will remove the else.", "author": "tejasajmera", "createdAt": "2020-11-30T23:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5MDkwOA=="}], "type": "inlineReview"}, {"oid": "e70edf2242a697a8340397a21fdc3a8fefda953e", "url": "https://github.com/apache/pinot/commit/e70edf2242a697a8340397a21fdc3a8fefda953e", "message": "[TE]frontend - Build the tree parser for composite anomalies", "committedDate": "2020-12-03T19:34:41Z", "type": "forcePushed"}, {"oid": "7d6c9468383e774ff65bd8b1bab0684ef670b365", "url": "https://github.com/apache/pinot/commit/7d6c9468383e774ff65bd8b1bab0684ef670b365", "message": "[TE]frontend - Build the tree parser for composite anomalies", "committedDate": "2020-12-03T22:20:33Z", "type": "commit"}, {"oid": "7d6c9468383e774ff65bd8b1bab0684ef670b365", "url": "https://github.com/apache/pinot/commit/7d6c9468383e774ff65bd8b1bab0684ef670b365", "message": "[TE]frontend - Build the tree parser for composite anomalies", "committedDate": "2020-12-03T22:20:33Z", "type": "forcePushed"}]}