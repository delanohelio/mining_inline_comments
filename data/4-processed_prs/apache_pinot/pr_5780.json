{"pr_number": 5780, "pr_title": "TableCache Enhancement", "pr_createdAt": "2020-07-31T01:56:34Z", "pr_url": "https://github.com/apache/pinot/pull/5780", "timeline": [{"oid": "d7b39b03e078128716f7f43e46fd94104e0a6dde", "url": "https://github.com/apache/pinot/commit/d7b39b03e078128716f7f43e46fd94104e0a6dde", "message": "Refactor TableCache", "committedDate": "2020-07-31T01:44:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyNDE1Mg==", "url": "https://github.com/apache/pinot/pull/5780#discussion_r463424152", "bodyText": "this will miss watches if there was a new table added while processing the callback right?", "author": "kishoreg", "createdAt": "2020-07-31T06:14:30Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/helix/TableCache.java", "diffHunk": "@@ -18,190 +18,308 @@\n  */\n package org.apache.pinot.common.utils.helix;\n \n-import java.util.Collection;\n+import com.google.common.base.Preconditions;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n import org.I0Itec.zkclient.IZkChildListener;\n import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.commons.collections.CollectionUtils;\n import org.apache.helix.AccessOption;\n import org.apache.helix.ZNRecord;\n import org.apache.helix.store.zk.ZkHelixPropertyStore;\n import org.apache.pinot.common.utils.SchemaUtils;\n import org.apache.pinot.common.utils.config.TableConfigUtils;\n import org.apache.pinot.spi.config.table.TableConfig;\n-import org.apache.pinot.spi.data.FieldSpec;\n import org.apache.pinot.spi.data.Schema;\n import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n /**\n- *  Caches table config and schema of a table.\n- *  At the start - loads all the table configs and schemas in map.\n- *  sets up a zookeeper listener that watches for any change and updates the cache.\n- *  TODO: optimize to load only changed table configs/schema on a callback.\n- *  TODO: Table deletes are not handled as of now\n- *  Goal is to eventually grow this into a PinotClusterDataAccessor\n+ * The {@code TableCache} caches all the table configs and schemas within the cluster, and listens on ZK changes to keep\n+ * them in sync. It also maintains the table name map and the column name map for case-insensitive queries.\n  */\n public class TableCache {\n   private static final Logger LOGGER = LoggerFactory.getLogger(TableCache.class);\n+  private static final String TABLE_CONFIG_PARENT_PATH = \"/CONFIGS/TABLE\";\n+  private static final String TABLE_CONFIG_PATH_PREFIX = \"/CONFIGS/TABLE/\";\n+  private static final String SCHEMA_PARENT_PATH = \"/SCHEMAS\";\n+  private static final String SCHEMA_PATH_PREFIX = \"/SCHEMAS/\";\n+  private static final String LOWER_CASE_OFFLINE_TABLE_SUFFIX = \"_offline\";\n+  private static final String LOWER_CASE_REALTIME_TABLE_SUFFIX = \"_realtime\";\n \n-  private static final String PROPERTYSTORE_SCHEMAS_PREFIX = \"/SCHEMAS\";\n-  private static final String PROPERTYSTORE_TABLE_CONFIGS_PREFIX = \"/CONFIGS/TABLE\";\n+  private final ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+  private final boolean _caseInsensitive;\n+  // For case insensitive, key is lower case table name, value is actual table name\n+  private final Map<String, String> _tableNameMap;\n \n-  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n-  TableConfigChangeListener _tableConfigChangeListener;\n-  SchemaChangeListener _schemaChangeListener;\n+  // Key is table name with type suffix\n+  private final TableConfigChangeListener _tableConfigChangeListener = new TableConfigChangeListener();\n+  private final Map<String, TableConfig> _tableConfigMap = new ConcurrentHashMap<>();\n+  // Key is raw table name\n+  private final SchemaChangeListener _schemaChangeListener = new SchemaChangeListener();\n+  private final Map<String, SchemaInfo> _schemaInfoMap = new ConcurrentHashMap<>();\n \n-  public TableCache(ZkHelixPropertyStore<ZNRecord> propertyStore) {\n+  public TableCache(ZkHelixPropertyStore<ZNRecord> propertyStore, boolean caseInsensitive) {\n     _propertyStore = propertyStore;\n-    _schemaChangeListener = new SchemaChangeListener();\n-    _schemaChangeListener.refresh();\n-    _tableConfigChangeListener = new TableConfigChangeListener();\n-    _tableConfigChangeListener.refresh();\n+    _caseInsensitive = caseInsensitive;\n+    _tableNameMap = caseInsensitive ? new ConcurrentHashMap<>() : null;\n+\n+    synchronized (_tableConfigChangeListener) {\n+      // Subscribe child changes before reading the data to avoid missing changes\n+      _propertyStore.subscribeChildChanges(TABLE_CONFIG_PARENT_PATH, _tableConfigChangeListener);\n+\n+      List<String> tables = _propertyStore.getChildNames(TABLE_CONFIG_PARENT_PATH, AccessOption.PERSISTENT);\n+      if (CollectionUtils.isNotEmpty(tables)) {\n+        List<String> pathsToAdd = new ArrayList<>(tables.size());\n+        for (String tableNameWithType : tables) {\n+          pathsToAdd.add(TABLE_CONFIG_PATH_PREFIX + tableNameWithType);\n+        }\n+        addTableConfigs(pathsToAdd);\n+      }\n+    }\n+\n+    synchronized (_schemaChangeListener) {\n+      // Subscribe child changes before reading the data to avoid missing changes\n+      _propertyStore.subscribeChildChanges(SCHEMA_PARENT_PATH, _schemaChangeListener);\n+\n+      List<String> tables = _propertyStore.getChildNames(SCHEMA_PARENT_PATH, AccessOption.PERSISTENT);\n+      if (CollectionUtils.isNotEmpty(tables)) {\n+        List<String> pathsToAdd = new ArrayList<>(tables.size());\n+        for (String rawTableName : tables) {\n+          pathsToAdd.add(SCHEMA_PATH_PREFIX + rawTableName);\n+        }\n+        addSchemas(pathsToAdd);\n+      }\n+    }\n+\n+    LOGGER.info(\"Initialized TableCache with caseInsensitive: {}\", caseInsensitive);\n   }\n \n-  public String getActualTableName(String tableName) {\n-    return _tableConfigChangeListener._tableNameMap.getOrDefault(tableName.toLowerCase(), tableName);\n+  /**\n+   * Returns {@code true} if the TableCache is case-insensitive, {@code false} otherwise.\n+   */\n+  public boolean isCaseInsensitive() {\n+    return _caseInsensitive;\n   }\n \n-  public boolean containsTable(String tableName) {\n-    return _tableConfigChangeListener._tableNameMap.containsKey(tableName.toLowerCase());\n+  /**\n+   * For case-insensitive only, returns the actual table name for the given case-insensitive table name (with or without\n+   * type suffix), or {@code null} if the table does not exist.\n+   */\n+  @Nullable\n+  public String getActualTableName(String caseInsensitiveTableName) {\n+    Preconditions.checkState(_caseInsensitive, \"TableCache is not case-insensitive\");\n+    return _tableNameMap.get(caseInsensitiveTableName.toLowerCase());\n   }\n \n-  public String getActualColumnName(String tableName, String columnName) {\n-    String schemaName = _tableConfigChangeListener._table2SchemaConfigMap.get(tableName.toLowerCase());\n-    if (schemaName != null) {\n-      String actualColumnName = _schemaChangeListener.getColumnName(schemaName, columnName);\n-      // If actual column name doesn't exist in schema, then return the origin column name.\n-      if (actualColumnName == null) {\n-        return columnName;\n+  /**\n+   * For case-insensitive only, returns a map from lower case column name to actual column name for the given table, or\n+   * {@code null} if the table schema does not exist.\n+   */\n+  @Nullable\n+  public Map<String, String> getColumnNameMap(String rawTableName) {\n+    Preconditions.checkState(_caseInsensitive, \"TableCache is not case-insensitive\");\n+    SchemaInfo schemaInfo = _schemaInfoMap.get(rawTableName);\n+    return schemaInfo != null ? schemaInfo._columnNameMap : null;\n+  }\n+\n+  /**\n+   * Returns the table config for the given table, or {@code null} if it does not exist.\n+   */\n+  @Nullable\n+  public TableConfig getTableConfig(String tableNameWithType) {\n+    return _tableConfigMap.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Returns the schema for the given table, or {@code null} if it does not exist.\n+   */\n+  @Nullable\n+  public Schema getSchema(String rawTableName) {\n+    SchemaInfo schemaInfo = _schemaInfoMap.get(rawTableName);\n+    return schemaInfo != null ? schemaInfo._schema : null;\n+  }\n+\n+  private void addTableConfigs(List<String> paths) {\n+    // Subscribe data changes before reading the data to avoid missing changes\n+    for (String path : paths) {\n+      _propertyStore.subscribeDataChanges(path, _tableConfigChangeListener);\n+    }\n+    List<ZNRecord> znRecords = _propertyStore.get(paths, null, AccessOption.PERSISTENT);\n+    for (ZNRecord znRecord : znRecords) {\n+      if (znRecord != null) {\n+        try {\n+          putTableConfig(znRecord);\n+        } catch (Exception e) {\n+          LOGGER.error(\"Caught exception while adding table config for ZNRecord: {}\", znRecord.getId(), e);\n+        }\n       }\n-      return actualColumnName;\n     }\n-    return columnName;\n   }\n \n-  public TableConfig getTableConfig(String tableName) {\n-    return _tableConfigChangeListener._tableConfigMap.get(tableName);\n+  private void putTableConfig(ZNRecord znRecord)\n+      throws IOException {\n+    TableConfig tableConfig = TableConfigUtils.fromZNRecord(znRecord);\n+    String tableNameWithType = tableConfig.getTableName();\n+    _tableConfigMap.put(tableNameWithType, tableConfig);\n+    if (_caseInsensitive) {\n+      _tableNameMap.put(tableNameWithType.toLowerCase(), tableNameWithType);\n+      String rawTableName = TableNameBuilder.extractRawTableName(tableNameWithType);\n+      _tableNameMap.put(rawTableName.toLowerCase(), rawTableName);\n+    }\n   }\n \n-  class TableConfigChangeListener implements IZkChildListener, IZkDataListener {\n-\n-    Map<String, TableConfig> _tableConfigMap = new ConcurrentHashMap<>();\n-    Map<String, String> _tableNameMap = new ConcurrentHashMap<>();\n-    Map<String, String> _table2SchemaConfigMap = new ConcurrentHashMap<>();\n-\n-    public synchronized void refresh() {\n-      try {\n-        //always subscribe first before reading, so that we dont miss any changes\n-        _propertyStore.subscribeChildChanges(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, _tableConfigChangeListener);\n-        _propertyStore.subscribeDataChanges(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, _tableConfigChangeListener);\n-        List<ZNRecord> children =\n-            _propertyStore.getChildren(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, null, AccessOption.PERSISTENT);\n-        if (children != null) {\n-          for (ZNRecord znRecord : children) {\n-            try {\n-              TableConfig tableConfig = TableConfigUtils.fromZNRecord(znRecord);\n-              String tableNameWithType = tableConfig.getTableName();\n-              _tableConfigMap.put(tableNameWithType, tableConfig);\n-              String rawTableName = TableNameBuilder.extractRawTableName(tableNameWithType);\n-              //create case insensitive mapping\n-              _tableNameMap.put(tableNameWithType.toLowerCase(), tableNameWithType);\n-              _tableNameMap.put(rawTableName.toLowerCase(), rawTableName);\n-              //create case insensitive mapping between table name and schemaName\n-              _table2SchemaConfigMap.put(tableNameWithType.toLowerCase(), rawTableName);\n-              _table2SchemaConfigMap.put(rawTableName.toLowerCase(), rawTableName);\n-            } catch (Exception e) {\n-              LOGGER.warn(\"Exception loading table config for: {}: {}\", znRecord.getId(), e.getMessage());\n-              //ignore\n-            }\n-          }\n+  private void removeTableConfig(String path) {\n+    _propertyStore.unsubscribeDataChanges(path, _tableConfigChangeListener);\n+    String tableNameWithType = path.substring(TABLE_CONFIG_PATH_PREFIX.length());\n+    _tableConfigMap.remove(tableNameWithType);\n+    if (_caseInsensitive) {\n+      _tableNameMap.remove(tableNameWithType.toLowerCase());\n+      String lowerCaseRawTableName = TableNameBuilder.extractRawTableName(tableNameWithType).toLowerCase();\n+      if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n+        if (!_tableNameMap.containsKey(lowerCaseRawTableName + LOWER_CASE_REALTIME_TABLE_SUFFIX)) {\n+          _tableNameMap.remove(lowerCaseRawTableName);\n+        }\n+      } else {\n+        if (!_tableNameMap.containsKey(lowerCaseRawTableName + LOWER_CASE_OFFLINE_TABLE_SUFFIX)) {\n+          _tableNameMap.remove(lowerCaseRawTableName);\n         }\n-      } catch (Exception e) {\n-        LOGGER.warn(\"Exception subscribing/reading tableconfigs\", e);\n-        //ignore\n       }\n     }\n+  }\n+\n+  private void addSchemas(List<String> paths) {\n+    // Subscribe data changes before reading the data to avoid missing changes\n+    for (String path : paths) {\n+      _propertyStore.subscribeDataChanges(path, _schemaChangeListener);\n+    }\n+    List<ZNRecord> znRecords = _propertyStore.get(paths, null, AccessOption.PERSISTENT);\n+    for (ZNRecord znRecord : znRecords) {\n+      if (znRecord != null) {\n+        try {\n+          putSchema(znRecord);\n+        } catch (Exception e) {\n+          LOGGER.error(\"Caught exception while adding schema for ZNRecord: {}\", znRecord.getId(), e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private void putSchema(ZNRecord znRecord)\n+      throws IOException {\n+    Schema schema = SchemaUtils.fromZNRecord(znRecord);\n+    String rawTableName = schema.getSchemaName();\n+    if (_caseInsensitive) {\n+      Map<String, String> columnNameMap = new HashMap<>();\n+      for (String columnName : schema.getColumnNames()) {\n+        columnNameMap.put(columnName.toLowerCase(), columnName);\n+      }\n+      _schemaInfoMap.put(rawTableName, new SchemaInfo(schema, columnNameMap));\n+    } else {\n+      _schemaInfoMap.put(rawTableName, new SchemaInfo(schema, null));\n+    }\n+  }\n+\n+  private void removeSchema(String path) {\n+    _propertyStore.unsubscribeDataChanges(path, _schemaChangeListener);\n+    String rawTableName = path.substring(SCHEMA_PATH_PREFIX.length());\n+    _schemaInfoMap.remove(rawTableName);\n+  }\n+\n+  private class TableConfigChangeListener implements IZkChildListener, IZkDataListener {\n \n     @Override\n-    public void handleChildChange(String s, List<String> list)\n-        throws Exception {\n-      refresh();\n+    public synchronized void handleChildChange(String path, List<String> tables) {", "originalCommit": "d7b39b03e078128716f7f43e46fd94104e0a6dde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgwMzExNA==", "url": "https://github.com/apache/pinot/pull/5780#discussion_r463803114", "bodyText": "We won't because internally it resubscribe the watches before reading the child names", "author": "Jackie-Jiang", "createdAt": "2020-07-31T19:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyNDE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyNDc0OA==", "url": "https://github.com/apache/pinot/pull/5780#discussion_r463424748", "bodyText": "this method was good, only thing we had to handle was calling subscribe on each child node. This is a much better way to handle ZK callbacks instead of trying to handle every callback with custom logic", "author": "kishoreg", "createdAt": "2020-07-31T06:16:23Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/helix/TableCache.java", "diffHunk": "@@ -18,190 +18,308 @@\n  */\n package org.apache.pinot.common.utils.helix;\n \n-import java.util.Collection;\n+import com.google.common.base.Preconditions;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n import org.I0Itec.zkclient.IZkChildListener;\n import org.I0Itec.zkclient.IZkDataListener;\n+import org.apache.commons.collections.CollectionUtils;\n import org.apache.helix.AccessOption;\n import org.apache.helix.ZNRecord;\n import org.apache.helix.store.zk.ZkHelixPropertyStore;\n import org.apache.pinot.common.utils.SchemaUtils;\n import org.apache.pinot.common.utils.config.TableConfigUtils;\n import org.apache.pinot.spi.config.table.TableConfig;\n-import org.apache.pinot.spi.data.FieldSpec;\n import org.apache.pinot.spi.data.Schema;\n import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n /**\n- *  Caches table config and schema of a table.\n- *  At the start - loads all the table configs and schemas in map.\n- *  sets up a zookeeper listener that watches for any change and updates the cache.\n- *  TODO: optimize to load only changed table configs/schema on a callback.\n- *  TODO: Table deletes are not handled as of now\n- *  Goal is to eventually grow this into a PinotClusterDataAccessor\n+ * The {@code TableCache} caches all the table configs and schemas within the cluster, and listens on ZK changes to keep\n+ * them in sync. It also maintains the table name map and the column name map for case-insensitive queries.\n  */\n public class TableCache {\n   private static final Logger LOGGER = LoggerFactory.getLogger(TableCache.class);\n+  private static final String TABLE_CONFIG_PARENT_PATH = \"/CONFIGS/TABLE\";\n+  private static final String TABLE_CONFIG_PATH_PREFIX = \"/CONFIGS/TABLE/\";\n+  private static final String SCHEMA_PARENT_PATH = \"/SCHEMAS\";\n+  private static final String SCHEMA_PATH_PREFIX = \"/SCHEMAS/\";\n+  private static final String LOWER_CASE_OFFLINE_TABLE_SUFFIX = \"_offline\";\n+  private static final String LOWER_CASE_REALTIME_TABLE_SUFFIX = \"_realtime\";\n \n-  private static final String PROPERTYSTORE_SCHEMAS_PREFIX = \"/SCHEMAS\";\n-  private static final String PROPERTYSTORE_TABLE_CONFIGS_PREFIX = \"/CONFIGS/TABLE\";\n+  private final ZkHelixPropertyStore<ZNRecord> _propertyStore;\n+  private final boolean _caseInsensitive;\n+  // For case insensitive, key is lower case table name, value is actual table name\n+  private final Map<String, String> _tableNameMap;\n \n-  private ZkHelixPropertyStore<ZNRecord> _propertyStore;\n-  TableConfigChangeListener _tableConfigChangeListener;\n-  SchemaChangeListener _schemaChangeListener;\n+  // Key is table name with type suffix\n+  private final TableConfigChangeListener _tableConfigChangeListener = new TableConfigChangeListener();\n+  private final Map<String, TableConfig> _tableConfigMap = new ConcurrentHashMap<>();\n+  // Key is raw table name\n+  private final SchemaChangeListener _schemaChangeListener = new SchemaChangeListener();\n+  private final Map<String, SchemaInfo> _schemaInfoMap = new ConcurrentHashMap<>();\n \n-  public TableCache(ZkHelixPropertyStore<ZNRecord> propertyStore) {\n+  public TableCache(ZkHelixPropertyStore<ZNRecord> propertyStore, boolean caseInsensitive) {\n     _propertyStore = propertyStore;\n-    _schemaChangeListener = new SchemaChangeListener();\n-    _schemaChangeListener.refresh();\n-    _tableConfigChangeListener = new TableConfigChangeListener();\n-    _tableConfigChangeListener.refresh();\n+    _caseInsensitive = caseInsensitive;\n+    _tableNameMap = caseInsensitive ? new ConcurrentHashMap<>() : null;\n+\n+    synchronized (_tableConfigChangeListener) {\n+      // Subscribe child changes before reading the data to avoid missing changes\n+      _propertyStore.subscribeChildChanges(TABLE_CONFIG_PARENT_PATH, _tableConfigChangeListener);\n+\n+      List<String> tables = _propertyStore.getChildNames(TABLE_CONFIG_PARENT_PATH, AccessOption.PERSISTENT);\n+      if (CollectionUtils.isNotEmpty(tables)) {\n+        List<String> pathsToAdd = new ArrayList<>(tables.size());\n+        for (String tableNameWithType : tables) {\n+          pathsToAdd.add(TABLE_CONFIG_PATH_PREFIX + tableNameWithType);\n+        }\n+        addTableConfigs(pathsToAdd);\n+      }\n+    }\n+\n+    synchronized (_schemaChangeListener) {\n+      // Subscribe child changes before reading the data to avoid missing changes\n+      _propertyStore.subscribeChildChanges(SCHEMA_PARENT_PATH, _schemaChangeListener);\n+\n+      List<String> tables = _propertyStore.getChildNames(SCHEMA_PARENT_PATH, AccessOption.PERSISTENT);\n+      if (CollectionUtils.isNotEmpty(tables)) {\n+        List<String> pathsToAdd = new ArrayList<>(tables.size());\n+        for (String rawTableName : tables) {\n+          pathsToAdd.add(SCHEMA_PATH_PREFIX + rawTableName);\n+        }\n+        addSchemas(pathsToAdd);\n+      }\n+    }\n+\n+    LOGGER.info(\"Initialized TableCache with caseInsensitive: {}\", caseInsensitive);\n   }\n \n-  public String getActualTableName(String tableName) {\n-    return _tableConfigChangeListener._tableNameMap.getOrDefault(tableName.toLowerCase(), tableName);\n+  /**\n+   * Returns {@code true} if the TableCache is case-insensitive, {@code false} otherwise.\n+   */\n+  public boolean isCaseInsensitive() {\n+    return _caseInsensitive;\n   }\n \n-  public boolean containsTable(String tableName) {\n-    return _tableConfigChangeListener._tableNameMap.containsKey(tableName.toLowerCase());\n+  /**\n+   * For case-insensitive only, returns the actual table name for the given case-insensitive table name (with or without\n+   * type suffix), or {@code null} if the table does not exist.\n+   */\n+  @Nullable\n+  public String getActualTableName(String caseInsensitiveTableName) {\n+    Preconditions.checkState(_caseInsensitive, \"TableCache is not case-insensitive\");\n+    return _tableNameMap.get(caseInsensitiveTableName.toLowerCase());\n   }\n \n-  public String getActualColumnName(String tableName, String columnName) {\n-    String schemaName = _tableConfigChangeListener._table2SchemaConfigMap.get(tableName.toLowerCase());\n-    if (schemaName != null) {\n-      String actualColumnName = _schemaChangeListener.getColumnName(schemaName, columnName);\n-      // If actual column name doesn't exist in schema, then return the origin column name.\n-      if (actualColumnName == null) {\n-        return columnName;\n+  /**\n+   * For case-insensitive only, returns a map from lower case column name to actual column name for the given table, or\n+   * {@code null} if the table schema does not exist.\n+   */\n+  @Nullable\n+  public Map<String, String> getColumnNameMap(String rawTableName) {\n+    Preconditions.checkState(_caseInsensitive, \"TableCache is not case-insensitive\");\n+    SchemaInfo schemaInfo = _schemaInfoMap.get(rawTableName);\n+    return schemaInfo != null ? schemaInfo._columnNameMap : null;\n+  }\n+\n+  /**\n+   * Returns the table config for the given table, or {@code null} if it does not exist.\n+   */\n+  @Nullable\n+  public TableConfig getTableConfig(String tableNameWithType) {\n+    return _tableConfigMap.get(tableNameWithType);\n+  }\n+\n+  /**\n+   * Returns the schema for the given table, or {@code null} if it does not exist.\n+   */\n+  @Nullable\n+  public Schema getSchema(String rawTableName) {\n+    SchemaInfo schemaInfo = _schemaInfoMap.get(rawTableName);\n+    return schemaInfo != null ? schemaInfo._schema : null;\n+  }\n+\n+  private void addTableConfigs(List<String> paths) {\n+    // Subscribe data changes before reading the data to avoid missing changes\n+    for (String path : paths) {\n+      _propertyStore.subscribeDataChanges(path, _tableConfigChangeListener);\n+    }\n+    List<ZNRecord> znRecords = _propertyStore.get(paths, null, AccessOption.PERSISTENT);\n+    for (ZNRecord znRecord : znRecords) {\n+      if (znRecord != null) {\n+        try {\n+          putTableConfig(znRecord);\n+        } catch (Exception e) {\n+          LOGGER.error(\"Caught exception while adding table config for ZNRecord: {}\", znRecord.getId(), e);\n+        }\n       }\n-      return actualColumnName;\n     }\n-    return columnName;\n   }\n \n-  public TableConfig getTableConfig(String tableName) {\n-    return _tableConfigChangeListener._tableConfigMap.get(tableName);\n+  private void putTableConfig(ZNRecord znRecord)\n+      throws IOException {\n+    TableConfig tableConfig = TableConfigUtils.fromZNRecord(znRecord);\n+    String tableNameWithType = tableConfig.getTableName();\n+    _tableConfigMap.put(tableNameWithType, tableConfig);\n+    if (_caseInsensitive) {\n+      _tableNameMap.put(tableNameWithType.toLowerCase(), tableNameWithType);\n+      String rawTableName = TableNameBuilder.extractRawTableName(tableNameWithType);\n+      _tableNameMap.put(rawTableName.toLowerCase(), rawTableName);\n+    }\n   }\n \n-  class TableConfigChangeListener implements IZkChildListener, IZkDataListener {\n-\n-    Map<String, TableConfig> _tableConfigMap = new ConcurrentHashMap<>();\n-    Map<String, String> _tableNameMap = new ConcurrentHashMap<>();\n-    Map<String, String> _table2SchemaConfigMap = new ConcurrentHashMap<>();\n-\n-    public synchronized void refresh() {\n-      try {\n-        //always subscribe first before reading, so that we dont miss any changes\n-        _propertyStore.subscribeChildChanges(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, _tableConfigChangeListener);\n-        _propertyStore.subscribeDataChanges(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, _tableConfigChangeListener);\n-        List<ZNRecord> children =\n-            _propertyStore.getChildren(PROPERTYSTORE_TABLE_CONFIGS_PREFIX, null, AccessOption.PERSISTENT);\n-        if (children != null) {\n-          for (ZNRecord znRecord : children) {\n-            try {\n-              TableConfig tableConfig = TableConfigUtils.fromZNRecord(znRecord);\n-              String tableNameWithType = tableConfig.getTableName();\n-              _tableConfigMap.put(tableNameWithType, tableConfig);\n-              String rawTableName = TableNameBuilder.extractRawTableName(tableNameWithType);\n-              //create case insensitive mapping\n-              _tableNameMap.put(tableNameWithType.toLowerCase(), tableNameWithType);\n-              _tableNameMap.put(rawTableName.toLowerCase(), rawTableName);\n-              //create case insensitive mapping between table name and schemaName\n-              _table2SchemaConfigMap.put(tableNameWithType.toLowerCase(), rawTableName);\n-              _table2SchemaConfigMap.put(rawTableName.toLowerCase(), rawTableName);\n-            } catch (Exception e) {\n-              LOGGER.warn(\"Exception loading table config for: {}: {}\", znRecord.getId(), e.getMessage());\n-              //ignore\n-            }\n-          }\n+  private void removeTableConfig(String path) {\n+    _propertyStore.unsubscribeDataChanges(path, _tableConfigChangeListener);\n+    String tableNameWithType = path.substring(TABLE_CONFIG_PATH_PREFIX.length());\n+    _tableConfigMap.remove(tableNameWithType);\n+    if (_caseInsensitive) {\n+      _tableNameMap.remove(tableNameWithType.toLowerCase());\n+      String lowerCaseRawTableName = TableNameBuilder.extractRawTableName(tableNameWithType).toLowerCase();\n+      if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n+        if (!_tableNameMap.containsKey(lowerCaseRawTableName + LOWER_CASE_REALTIME_TABLE_SUFFIX)) {\n+          _tableNameMap.remove(lowerCaseRawTableName);\n+        }\n+      } else {\n+        if (!_tableNameMap.containsKey(lowerCaseRawTableName + LOWER_CASE_OFFLINE_TABLE_SUFFIX)) {\n+          _tableNameMap.remove(lowerCaseRawTableName);\n         }\n-      } catch (Exception e) {\n-        LOGGER.warn(\"Exception subscribing/reading tableconfigs\", e);\n-        //ignore\n       }\n     }\n+  }\n+\n+  private void addSchemas(List<String> paths) {\n+    // Subscribe data changes before reading the data to avoid missing changes\n+    for (String path : paths) {\n+      _propertyStore.subscribeDataChanges(path, _schemaChangeListener);\n+    }\n+    List<ZNRecord> znRecords = _propertyStore.get(paths, null, AccessOption.PERSISTENT);\n+    for (ZNRecord znRecord : znRecords) {\n+      if (znRecord != null) {\n+        try {\n+          putSchema(znRecord);\n+        } catch (Exception e) {\n+          LOGGER.error(\"Caught exception while adding schema for ZNRecord: {}\", znRecord.getId(), e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private void putSchema(ZNRecord znRecord)\n+      throws IOException {\n+    Schema schema = SchemaUtils.fromZNRecord(znRecord);\n+    String rawTableName = schema.getSchemaName();\n+    if (_caseInsensitive) {\n+      Map<String, String> columnNameMap = new HashMap<>();\n+      for (String columnName : schema.getColumnNames()) {\n+        columnNameMap.put(columnName.toLowerCase(), columnName);\n+      }\n+      _schemaInfoMap.put(rawTableName, new SchemaInfo(schema, columnNameMap));\n+    } else {\n+      _schemaInfoMap.put(rawTableName, new SchemaInfo(schema, null));\n+    }\n+  }\n+\n+  private void removeSchema(String path) {\n+    _propertyStore.unsubscribeDataChanges(path, _schemaChangeListener);\n+    String rawTableName = path.substring(SCHEMA_PATH_PREFIX.length());\n+    _schemaInfoMap.remove(rawTableName);\n+  }\n+\n+  private class TableConfigChangeListener implements IZkChildListener, IZkDataListener {\n \n     @Override\n-    public void handleChildChange(String s, List<String> list)\n-        throws Exception {\n-      refresh();\n+    public synchronized void handleChildChange(String path, List<String> tables) {\n+      if (CollectionUtils.isEmpty(tables)) {\n+        return;\n+      }\n+\n+      // Only process new added table configs. Changed/removed table configs are handled by other callbacks.\n+      List<String> pathsToAdd = new ArrayList<>();\n+      for (String tableNameWithType : tables) {\n+        if (!_tableConfigMap.containsKey(tableNameWithType)) {\n+          pathsToAdd.add(TABLE_CONFIG_PATH_PREFIX + tableNameWithType);\n+        }\n+      }\n+      if (!pathsToAdd.isEmpty()) {\n+        addTableConfigs(pathsToAdd);\n+      }\n     }\n \n     @Override\n-    public void handleDataChange(String s, Object o)\n-        throws Exception {\n-      refresh();\n+    public synchronized void handleDataChange(String path, Object data) {\n+      if (data != null) {\n+        ZNRecord znRecord = (ZNRecord) data;\n+        try {\n+          putTableConfig(znRecord);\n+        } catch (Exception e) {\n+          LOGGER.error(\"Caught exception while refreshing table config for ZNRecord: {}\", znRecord.getId(), e);\n+        }\n+      }\n     }\n \n     @Override\n-    public void handleDataDeleted(String s)\n-        throws Exception {\n-      refresh();\n+    public synchronized void handleDataDeleted(String path) {\n+      // NOTE: The path here is the absolute ZK path instead of the relative path to the property store.\n+      String tableNameWithType = path.substring(path.lastIndexOf('/') + 1);\n+      removeTableConfig(TABLE_CONFIG_PATH_PREFIX + tableNameWithType);\n     }\n   }\n \n-  class SchemaChangeListener implements IZkChildListener, IZkDataListener {\n-    Map<String, Map<String, String>> _schemaColumnMap = new ConcurrentHashMap<>();\n-\n-    public synchronized void refresh() {", "originalCommit": "d7b39b03e078128716f7f43e46fd94104e0a6dde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgwNDQzOA==", "url": "https://github.com/apache/pinot/pull/5780#discussion_r463804438", "bodyText": "We want to avoid redundant ZK accesses. The current way will always read all table configs/schemas on every change. For a cluster with thousands of table, one node change should only requires one ZNRecord fetch (which is already done internally and passed to the callback) instead of thousands.", "author": "Jackie-Jiang", "createdAt": "2020-07-31T19:57:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyNDc0OA=="}], "type": "inlineReview"}]}