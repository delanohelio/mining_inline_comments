{"pr_number": 6050, "pr_title": "Minion taskExecutor for RealtimeToOfflineSegments task", "pr_createdAt": "2020-09-23T00:10:23Z", "pr_url": "https://github.com/apache/pinot/pull/6050", "timeline": [{"oid": "4435a5735f68b6fbb79e5feaef3be066ad2db6fb", "url": "https://github.com/apache/pinot/commit/4435a5735f68b6fbb79e5feaef3be066ad2db6fb", "message": "Minion taskExecutor for RealtimeToOfflineSegments task", "committedDate": "2020-09-23T16:59:39Z", "type": "commit"}, {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32", "url": "https://github.com/apache/pinot/commit/1010a8f3ac7717c63fd16fba600152fec7b31f32", "message": "Fix compilation issue", "committedDate": "2020-09-23T17:02:30Z", "type": "commit"}, {"oid": "1010a8f3ac7717c63fd16fba600152fec7b31f32", "url": "https://github.com/apache/pinot/commit/1010a8f3ac7717c63fd16fba600152fec7b31f32", "message": "Fix compilation issue", "committedDate": "2020-09-23T17:02:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQzODc1NA==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r494438754", "bodyText": "Can you use Preconditions instead of assert? Some runtime environments turns assert off. Thanks.", "author": "mcvsubbu", "createdAt": "2020-09-24T16:06:18Z", "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.minion.executor;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorFactory;\n+import org.apache.pinot.core.segment.processing.collector.ValueAggregatorFactory;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterConfig;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterFactory;\n+import org.apache.pinot.core.segment.processing.framework.SegmentConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorFramework;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerConfig;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerFactory;\n+import org.apache.pinot.core.segment.processing.transformer.RecordTransformerConfig;\n+import org.apache.pinot.spi.config.table.ColumnPartitionConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.data.DateTimeFieldSpec;\n+import org.apache.pinot.spi.data.DateTimeFormatSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A task to convert segments from a REALTIME table to segments for its corresponding OFFLINE table.\n+ * The realtime segments could span across multiple time windows. This task extracts data and creates segments for a configured time range.\n+ * The {@link SegmentProcessorFramework} is used for the segment conversion, which also does\n+ * 1. time column rollup\n+ * 2. time window extraction using filter function\n+ * 3. partitioning using table config's segmentPartitioningConfig\n+ * 4. aggregations and rollup\n+ * 5. data sorting\n+ */\n+public class RealtimeToOfflineSegmentsTaskExecutor extends BaseMultipleSegmentsConversionExecutor {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskExecutor.class);\n+  private static final String INPUT_SEGMENTS_DIR = \"input_segments\";\n+  private static final String OUTPUT_SEGMENTS_DIR = \"output_segments\";\n+\n+  @Override\n+  protected List<SegmentConversionResult> convert(PinotTaskConfig pinotTaskConfig, List<File> originalIndexDirs,\n+      File workingDir)\n+      throws Exception {\n+    String taskType = pinotTaskConfig.getTaskType();\n+    Map<String, String> configs = pinotTaskConfig.getConfigs();\n+    LOGGER.info(\"Starting task: {} with configs: {}\", taskType, configs);\n+\n+    String tableNameWithType = configs.get(MinionConstants.TABLE_NAME_KEY); // rawTableName_OFFLINE expected here\n+    TableConfig tableConfig = getTableConfig(tableNameWithType);\n+    Schema schema = getSchema(tableNameWithType);\n+    Set<String> schemaColumns = schema.getPhysicalColumnNames();\n+    String timeColumn = tableConfig.getValidationConfig().getTimeColumnName();\n+    DateTimeFieldSpec dateTimeFieldSpec = schema.getSpecForTimeColumn(timeColumn);\n+    assert dateTimeFieldSpec != null;", "originalCommit": "1010a8f3ac7717c63fd16fba600152fec7b31f32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0MTU5NQ==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r494441595", "bodyText": "Good to add a duration in this log.", "author": "mcvsubbu", "createdAt": "2020-09-24T16:10:35Z", "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.minion.executor;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorFactory;\n+import org.apache.pinot.core.segment.processing.collector.ValueAggregatorFactory;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterConfig;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterFactory;\n+import org.apache.pinot.core.segment.processing.framework.SegmentConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorFramework;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerConfig;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerFactory;\n+import org.apache.pinot.core.segment.processing.transformer.RecordTransformerConfig;\n+import org.apache.pinot.spi.config.table.ColumnPartitionConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.data.DateTimeFieldSpec;\n+import org.apache.pinot.spi.data.DateTimeFormatSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A task to convert segments from a REALTIME table to segments for its corresponding OFFLINE table.\n+ * The realtime segments could span across multiple time windows. This task extracts data and creates segments for a configured time range.\n+ * The {@link SegmentProcessorFramework} is used for the segment conversion, which also does\n+ * 1. time column rollup\n+ * 2. time window extraction using filter function\n+ * 3. partitioning using table config's segmentPartitioningConfig\n+ * 4. aggregations and rollup\n+ * 5. data sorting\n+ */\n+public class RealtimeToOfflineSegmentsTaskExecutor extends BaseMultipleSegmentsConversionExecutor {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskExecutor.class);\n+  private static final String INPUT_SEGMENTS_DIR = \"input_segments\";\n+  private static final String OUTPUT_SEGMENTS_DIR = \"output_segments\";\n+\n+  @Override\n+  protected List<SegmentConversionResult> convert(PinotTaskConfig pinotTaskConfig, List<File> originalIndexDirs,\n+      File workingDir)\n+      throws Exception {\n+    String taskType = pinotTaskConfig.getTaskType();\n+    Map<String, String> configs = pinotTaskConfig.getConfigs();\n+    LOGGER.info(\"Starting task: {} with configs: {}\", taskType, configs);\n+\n+    String tableNameWithType = configs.get(MinionConstants.TABLE_NAME_KEY); // rawTableName_OFFLINE expected here\n+    TableConfig tableConfig = getTableConfig(tableNameWithType);\n+    Schema schema = getSchema(tableNameWithType);\n+    Set<String> schemaColumns = schema.getPhysicalColumnNames();\n+    String timeColumn = tableConfig.getValidationConfig().getTimeColumnName();\n+    DateTimeFieldSpec dateTimeFieldSpec = schema.getSpecForTimeColumn(timeColumn);\n+    assert dateTimeFieldSpec != null;\n+\n+    long windowStartMs =\n+        Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_START_MILLIS_KEY));\n+    long windowEndMs = Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_END_MILLIS_KEY));\n+    String timeColumnTransformFunction =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.TIME_COLUMN_TRANSFORM_FUNCTION_KEY);\n+    String collectorTypeStr = configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.COLLECTOR_TYPE_KEY);\n+    Map<String, String> aggregatorConfigs = new HashMap<>();\n+    for (Map.Entry<String, String> entry : configs.entrySet()) {\n+      String key = entry.getKey();\n+      if (key.endsWith(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)) {\n+        String column = key.split(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)[0];\n+        aggregatorConfigs.put(column, entry.getValue());\n+      }\n+    }\n+    String numRecordsPerSegment =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.NUM_RECORDS_PER_SEGMENT_KEY);\n+\n+    SegmentProcessorConfig.Builder segmentProcessorConfigBuilder =\n+        new SegmentProcessorConfig.Builder().setTableConfig(tableConfig).setSchema(schema);\n+\n+    // Time rollup using configured time transformation function\n+    if (timeColumnTransformFunction != null) {\n+      RecordTransformerConfig recordTransformerConfig =\n+          getRecordTransformerConfigForTime(timeColumnTransformFunction, timeColumn);\n+      segmentProcessorConfigBuilder.setRecordTransformerConfig(recordTransformerConfig);\n+    }\n+\n+    // Filter function for extracting data between start and end time window\n+    RecordFilterConfig recordFilterConfig =\n+        getRecordFilterConfigForWindow(windowStartMs, windowEndMs, dateTimeFieldSpec, timeColumn);\n+    segmentProcessorConfigBuilder.setRecordFilterConfig(recordFilterConfig);\n+\n+    // Partitioner config from tableConfig\n+    if (tableConfig.getIndexingConfig().getSegmentPartitionConfig() != null) {\n+      Map<String, ColumnPartitionConfig> columnPartitionMap =\n+          tableConfig.getIndexingConfig().getSegmentPartitionConfig().getColumnPartitionMap();\n+      PartitionerConfig partitionerConfig = getPartitionerConfig(columnPartitionMap, tableNameWithType, schemaColumns);\n+      segmentProcessorConfigBuilder.setPartitionerConfigs(Lists.newArrayList(partitionerConfig));\n+    }\n+\n+    // Aggregations using configured Collector\n+    List<String> sortedColumns = tableConfig.getIndexingConfig().getSortedColumn();\n+    CollectorConfig collectorConfig =\n+        getCollectorConfig(collectorTypeStr, aggregatorConfigs, schemaColumns, sortedColumns);\n+    segmentProcessorConfigBuilder.setCollectorConfig(collectorConfig);\n+\n+    // Segment config\n+    if (numRecordsPerSegment != null) {\n+      SegmentConfig segmentConfig = getSegmentConfig(numRecordsPerSegment);\n+      segmentProcessorConfigBuilder.setSegmentConfig(segmentConfig);\n+    }\n+\n+    SegmentProcessorConfig segmentProcessorConfig = segmentProcessorConfigBuilder.build();\n+\n+    File inputSegmentsDir = new File(workingDir, INPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(inputSegmentsDir.mkdirs(), \"Failed to create input directory: %s for task: %s\",\n+        inputSegmentsDir.getAbsolutePath(), taskType);\n+    for (File indexDir : originalIndexDirs) {\n+      FileUtils.copyDirectoryToDirectory(indexDir, inputSegmentsDir);\n+    }\n+    File outputSegmentsDir = new File(workingDir, OUTPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(outputSegmentsDir.mkdirs(), \"Failed to create output directory: %s for task: %s\",\n+        outputSegmentsDir.getAbsolutePath(), taskType);\n+\n+    SegmentProcessorFramework segmentProcessorFramework =\n+        new SegmentProcessorFramework(inputSegmentsDir, segmentProcessorConfig, outputSegmentsDir);\n+    try {\n+      segmentProcessorFramework.processSegments();\n+    } finally {\n+      segmentProcessorFramework.cleanup();\n+    }\n+\n+    LOGGER.info(\"Finished task: {} with configs: {}\", taskType, configs);", "originalCommit": "1010a8f3ac7717c63fd16fba600152fec7b31f32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNjIwNw==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497016207", "bodyText": "+1", "author": "snleee", "createdAt": "2020-09-29T20:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0MTU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxMzg3OA==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r494513878", "bodyText": "why this check, given that we are pulling from tableconfig (at least in this task). If you are checking, then you should perhaps also check that this sorted column is not same as one of the aggregation columns?", "author": "mcvsubbu", "createdAt": "2020-09-24T18:10:07Z", "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.minion.executor;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorFactory;\n+import org.apache.pinot.core.segment.processing.collector.ValueAggregatorFactory;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterConfig;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterFactory;\n+import org.apache.pinot.core.segment.processing.framework.SegmentConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorFramework;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerConfig;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerFactory;\n+import org.apache.pinot.core.segment.processing.transformer.RecordTransformerConfig;\n+import org.apache.pinot.spi.config.table.ColumnPartitionConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.data.DateTimeFieldSpec;\n+import org.apache.pinot.spi.data.DateTimeFormatSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A task to convert segments from a REALTIME table to segments for its corresponding OFFLINE table.\n+ * The realtime segments could span across multiple time windows. This task extracts data and creates segments for a configured time range.\n+ * The {@link SegmentProcessorFramework} is used for the segment conversion, which also does\n+ * 1. time column rollup\n+ * 2. time window extraction using filter function\n+ * 3. partitioning using table config's segmentPartitioningConfig\n+ * 4. aggregations and rollup\n+ * 5. data sorting\n+ */\n+public class RealtimeToOfflineSegmentsTaskExecutor extends BaseMultipleSegmentsConversionExecutor {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskExecutor.class);\n+  private static final String INPUT_SEGMENTS_DIR = \"input_segments\";\n+  private static final String OUTPUT_SEGMENTS_DIR = \"output_segments\";\n+\n+  @Override\n+  protected List<SegmentConversionResult> convert(PinotTaskConfig pinotTaskConfig, List<File> originalIndexDirs,\n+      File workingDir)\n+      throws Exception {\n+    String taskType = pinotTaskConfig.getTaskType();\n+    Map<String, String> configs = pinotTaskConfig.getConfigs();\n+    LOGGER.info(\"Starting task: {} with configs: {}\", taskType, configs);\n+\n+    String tableNameWithType = configs.get(MinionConstants.TABLE_NAME_KEY); // rawTableName_OFFLINE expected here\n+    TableConfig tableConfig = getTableConfig(tableNameWithType);\n+    Schema schema = getSchema(tableNameWithType);\n+    Set<String> schemaColumns = schema.getPhysicalColumnNames();\n+    String timeColumn = tableConfig.getValidationConfig().getTimeColumnName();\n+    DateTimeFieldSpec dateTimeFieldSpec = schema.getSpecForTimeColumn(timeColumn);\n+    assert dateTimeFieldSpec != null;\n+\n+    long windowStartMs =\n+        Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_START_MILLIS_KEY));\n+    long windowEndMs = Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_END_MILLIS_KEY));\n+    String timeColumnTransformFunction =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.TIME_COLUMN_TRANSFORM_FUNCTION_KEY);\n+    String collectorTypeStr = configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.COLLECTOR_TYPE_KEY);\n+    Map<String, String> aggregatorConfigs = new HashMap<>();\n+    for (Map.Entry<String, String> entry : configs.entrySet()) {\n+      String key = entry.getKey();\n+      if (key.endsWith(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)) {\n+        String column = key.split(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)[0];\n+        aggregatorConfigs.put(column, entry.getValue());\n+      }\n+    }\n+    String numRecordsPerSegment =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.NUM_RECORDS_PER_SEGMENT_KEY);\n+\n+    SegmentProcessorConfig.Builder segmentProcessorConfigBuilder =\n+        new SegmentProcessorConfig.Builder().setTableConfig(tableConfig).setSchema(schema);\n+\n+    // Time rollup using configured time transformation function\n+    if (timeColumnTransformFunction != null) {\n+      RecordTransformerConfig recordTransformerConfig =\n+          getRecordTransformerConfigForTime(timeColumnTransformFunction, timeColumn);\n+      segmentProcessorConfigBuilder.setRecordTransformerConfig(recordTransformerConfig);\n+    }\n+\n+    // Filter function for extracting data between start and end time window\n+    RecordFilterConfig recordFilterConfig =\n+        getRecordFilterConfigForWindow(windowStartMs, windowEndMs, dateTimeFieldSpec, timeColumn);\n+    segmentProcessorConfigBuilder.setRecordFilterConfig(recordFilterConfig);\n+\n+    // Partitioner config from tableConfig\n+    if (tableConfig.getIndexingConfig().getSegmentPartitionConfig() != null) {\n+      Map<String, ColumnPartitionConfig> columnPartitionMap =\n+          tableConfig.getIndexingConfig().getSegmentPartitionConfig().getColumnPartitionMap();\n+      PartitionerConfig partitionerConfig = getPartitionerConfig(columnPartitionMap, tableNameWithType, schemaColumns);\n+      segmentProcessorConfigBuilder.setPartitionerConfigs(Lists.newArrayList(partitionerConfig));\n+    }\n+\n+    // Aggregations using configured Collector\n+    List<String> sortedColumns = tableConfig.getIndexingConfig().getSortedColumn();\n+    CollectorConfig collectorConfig =\n+        getCollectorConfig(collectorTypeStr, aggregatorConfigs, schemaColumns, sortedColumns);\n+    segmentProcessorConfigBuilder.setCollectorConfig(collectorConfig);\n+\n+    // Segment config\n+    if (numRecordsPerSegment != null) {\n+      SegmentConfig segmentConfig = getSegmentConfig(numRecordsPerSegment);\n+      segmentProcessorConfigBuilder.setSegmentConfig(segmentConfig);\n+    }\n+\n+    SegmentProcessorConfig segmentProcessorConfig = segmentProcessorConfigBuilder.build();\n+\n+    File inputSegmentsDir = new File(workingDir, INPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(inputSegmentsDir.mkdirs(), \"Failed to create input directory: %s for task: %s\",\n+        inputSegmentsDir.getAbsolutePath(), taskType);\n+    for (File indexDir : originalIndexDirs) {\n+      FileUtils.copyDirectoryToDirectory(indexDir, inputSegmentsDir);\n+    }\n+    File outputSegmentsDir = new File(workingDir, OUTPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(outputSegmentsDir.mkdirs(), \"Failed to create output directory: %s for task: %s\",\n+        outputSegmentsDir.getAbsolutePath(), taskType);\n+\n+    SegmentProcessorFramework segmentProcessorFramework =\n+        new SegmentProcessorFramework(inputSegmentsDir, segmentProcessorConfig, outputSegmentsDir);\n+    try {\n+      segmentProcessorFramework.processSegments();\n+    } finally {\n+      segmentProcessorFramework.cleanup();\n+    }\n+\n+    LOGGER.info(\"Finished task: {} with configs: {}\", taskType, configs);\n+    List<SegmentConversionResult> results = new ArrayList<>();\n+    for (File file : outputSegmentsDir.listFiles()) {\n+      String outputSegmentName = file.getName();\n+      results.add(new SegmentConversionResult.Builder().setFile(file).setSegmentName(outputSegmentName)\n+          .setTableNameWithType(tableNameWithType).build());\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Construct a {@link RecordTransformerConfig} for time column transformation\n+   */\n+  private RecordTransformerConfig getRecordTransformerConfigForTime(String timeColumnTransformFunction,\n+      String timeColumn) {\n+    Map<String, String> transformationsMap = new HashMap<>();\n+    transformationsMap.put(timeColumn, timeColumnTransformFunction);\n+    return new RecordTransformerConfig.Builder().setTransformFunctionsMap(transformationsMap).build();\n+  }\n+\n+  /**\n+   * Construct a {@link RecordFilterConfig} by setting a filter function on the time column, for extracting data between window start/end\n+   */\n+  private RecordFilterConfig getRecordFilterConfigForWindow(long windowStartMs, long windowEndMs,\n+      DateTimeFieldSpec dateTimeFieldSpec, String timeColumn) {\n+    String filterFunction;\n+    DateTimeFormatSpec dateTimeFormatSpec = new DateTimeFormatSpec(dateTimeFieldSpec.getFormat());\n+    TimeUnit timeUnit = dateTimeFormatSpec.getColumnUnit();\n+    DateTimeFieldSpec.TimeFormat timeFormat = dateTimeFormatSpec.getTimeFormat();\n+    if (timeUnit.equals(TimeUnit.MILLISECONDS) && timeFormat.equals(DateTimeFieldSpec.TimeFormat.EPOCH)) {\n+      // If time column is in EPOCH millis, use windowStart and windowEnd directly to filter\n+      filterFunction = getFilterFunctionLong(windowStartMs, windowEndMs, timeColumn);\n+    } else {\n+      // Convert windowStart and windowEnd to time format of the data\n+      if (dateTimeFormatSpec.getTimeFormat().equals(DateTimeFieldSpec.TimeFormat.EPOCH)) {\n+        long windowStart = dateTimeFormatSpec.fromMillisToFormat(windowStartMs, Long.class);\n+        long windowEnd = dateTimeFormatSpec.fromMillisToFormat(windowEndMs, Long.class);\n+        filterFunction = getFilterFunctionLong(windowStart, windowEnd, timeColumn);\n+      } else {\n+        String windowStart = dateTimeFormatSpec.fromMillisToFormat(windowStartMs, String.class);\n+        String windowEnd = dateTimeFormatSpec.fromMillisToFormat(windowEndMs, String.class);\n+        if (dateTimeFieldSpec.getDataType().isNumeric()) {\n+          filterFunction = getFilterFunctionLong(Long.parseLong(windowStart), Long.parseLong(windowEnd), timeColumn);\n+        } else {\n+          filterFunction = getFilterFunctionString(windowStart, windowEnd, timeColumn);\n+        }\n+      }\n+    }\n+    return new RecordFilterConfig.Builder().setRecordFilterType(RecordFilterFactory.RecordFilterType.FILTER_FUNCTION)\n+        .setFilterFunction(filterFunction).build();\n+  }\n+\n+  /**\n+   * Construct a {@link PartitionerConfig} using {@link org.apache.pinot.spi.config.table.SegmentPartitionConfig} from the table config\n+   */\n+  private PartitionerConfig getPartitionerConfig(Map<String, ColumnPartitionConfig> columnPartitionMap,\n+      String tableNameWithType, Set<String> schemaColumns) {\n+\n+    Preconditions.checkState(columnPartitionMap.size() == 1,\n+        \"Cannot partition using more than 1 ColumnPartitionConfig for table: %s\", tableNameWithType);\n+    String partitionColumn = columnPartitionMap.keySet().iterator().next();\n+    Preconditions.checkState(schemaColumns.contains(partitionColumn),\n+        \"Partition column: %s is not a physical column in the schema\", partitionColumn);\n+    return new PartitionerConfig.Builder().setPartitionerType(PartitionerFactory.PartitionerType.TABLE_PARTITION_CONFIG)\n+        .setColumnName(partitionColumn).setColumnPartitionConfig(columnPartitionMap.get(partitionColumn)).build();\n+  }\n+\n+  /**\n+   * Construct a {@link CollectorConfig} using configured collector configs and sorted columns from table config\n+   */\n+  private CollectorConfig getCollectorConfig(String collectorTypeStr, Map<String, String> aggregateConfigs,\n+      Set<String> schemaColumns, List<String> sortedColumns) {\n+    CollectorFactory.CollectorType collectorType = collectorTypeStr == null ? CollectorFactory.CollectorType.CONCAT\n+        : CollectorFactory.CollectorType.valueOf(collectorTypeStr.toUpperCase());\n+\n+    Map<String, ValueAggregatorFactory.ValueAggregatorType> aggregatorTypeMap = new HashMap<>();\n+    for (Map.Entry<String, String> entry : aggregateConfigs.entrySet()) {\n+      String column = entry.getKey();\n+      Preconditions\n+          .checkState(schemaColumns.contains(column), \"Aggregate column: %s is not a physical column in the schema\",\n+              column);\n+      aggregatorTypeMap.put(column, ValueAggregatorFactory.ValueAggregatorType.valueOf(entry.getValue().toUpperCase()));\n+    }\n+\n+    if (sortedColumns != null) {\n+      for (String column : sortedColumns) {", "originalCommit": "1010a8f3ac7717c63fd16fba600152fec7b31f32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzExNTEwNQ==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497115105", "bodyText": "Recent table config validation efforts showed that we hadn't been checking for validity of column names used in indexing config. I want to prevent failing in the SegmentProcessorFramework as much as possible, hence the check. If this check is not done, then we'd see failure in reduce step, after a lot of wasted computation.\nI don't think we need to check for sorted column not being a metric, as nothing is really stopping a user from setting it that way", "author": "npawar", "createdAt": "2020-09-29T22:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxMzg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE0NTgwNw==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497145807", "bodyText": "I meant if a column is present both as sortedColumn, but specified in aggregateConfigs above. Not sure if that case is handled correctly", "author": "mcvsubbu", "createdAt": "2020-09-29T23:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxMzg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY5MzA2OQ==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497693069", "bodyText": "that's a valid scenario imo", "author": "npawar", "createdAt": "2020-09-30T17:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxMzg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0NTM0Nw==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r496245347", "bodyText": "maxNumRecordsPerSegment makes more sense since this configuration is indeed the upper bound of the number of rows in the segment", "author": "snleee", "createdAt": "2020-09-28T21:33:42Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/MinionConstants.java", "diffHunk": "@@ -61,4 +61,17 @@ private MinionConstants() {\n     public static final String MERGE_TYPE_KEY = \"mergeTypeKey\";\n     public static final String MERGED_SEGMENT_NAME_KEY = \"mergedSegmentNameKey\";\n   }\n+\n+  public static class RealtimeToOfflineSegmentsTask {\n+    public static final String TASK_TYPE = \"realtimeToOfflineSegmentsTask\";\n+    // window\n+    public static final String WINDOW_START_MILLIS_KEY = \"windowStartMillis\";\n+    public static final String WINDOW_END_MILLIS_KEY = \"windowEndMillis\";\n+    // segment processing\n+    public static final String TIME_COLUMN_TRANSFORM_FUNCTION_KEY = \"timeColumnTransformFunction\";\n+    public static final String COLLECTOR_TYPE_KEY = \"collectorType\";\n+    public static final String AGGREGATION_TYPE_KEY_SUFFIX = \".aggregationType\";\n+    public static final String NUM_RECORDS_PER_SEGMENT_KEY = \"numRecordsPerSegment\";", "originalCommit": "1010a8f3ac7717c63fd16fba600152fec7b31f32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxMzI1MQ==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497013251", "bodyText": "Does this mean that we will drop the late data once the data from a window get moved to offline?\ne.g.\n\nday1 gets moved to offline table\nday1 data arrived late (this row shows up in the result because of realtime table will index and serve this row)\nday2 gets moved to offline table (the above late data will be dropped by the filter)", "author": "snleee", "createdAt": "2020-09-29T20:08:10Z", "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.minion.executor;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorFactory;\n+import org.apache.pinot.core.segment.processing.collector.ValueAggregatorFactory;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterConfig;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterFactory;\n+import org.apache.pinot.core.segment.processing.framework.SegmentConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorFramework;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerConfig;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerFactory;\n+import org.apache.pinot.core.segment.processing.transformer.RecordTransformerConfig;\n+import org.apache.pinot.spi.config.table.ColumnPartitionConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.data.DateTimeFieldSpec;\n+import org.apache.pinot.spi.data.DateTimeFormatSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A task to convert segments from a REALTIME table to segments for its corresponding OFFLINE table.\n+ * The realtime segments could span across multiple time windows. This task extracts data and creates segments for a configured time range.\n+ * The {@link SegmentProcessorFramework} is used for the segment conversion, which also does\n+ * 1. time column rollup\n+ * 2. time window extraction using filter function\n+ * 3. partitioning using table config's segmentPartitioningConfig\n+ * 4. aggregations and rollup\n+ * 5. data sorting\n+ */\n+public class RealtimeToOfflineSegmentsTaskExecutor extends BaseMultipleSegmentsConversionExecutor {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskExecutor.class);\n+  private static final String INPUT_SEGMENTS_DIR = \"input_segments\";\n+  private static final String OUTPUT_SEGMENTS_DIR = \"output_segments\";\n+\n+  @Override\n+  protected List<SegmentConversionResult> convert(PinotTaskConfig pinotTaskConfig, List<File> originalIndexDirs,\n+      File workingDir)\n+      throws Exception {\n+    String taskType = pinotTaskConfig.getTaskType();\n+    Map<String, String> configs = pinotTaskConfig.getConfigs();\n+    LOGGER.info(\"Starting task: {} with configs: {}\", taskType, configs);\n+\n+    String tableNameWithType = configs.get(MinionConstants.TABLE_NAME_KEY); // rawTableName_OFFLINE expected here\n+    TableConfig tableConfig = getTableConfig(tableNameWithType);\n+    Schema schema = getSchema(tableNameWithType);\n+    Set<String> schemaColumns = schema.getPhysicalColumnNames();\n+    String timeColumn = tableConfig.getValidationConfig().getTimeColumnName();\n+    DateTimeFieldSpec dateTimeFieldSpec = schema.getSpecForTimeColumn(timeColumn);\n+    assert dateTimeFieldSpec != null;\n+\n+    long windowStartMs =\n+        Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_START_MILLIS_KEY));\n+    long windowEndMs = Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_END_MILLIS_KEY));\n+    String timeColumnTransformFunction =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.TIME_COLUMN_TRANSFORM_FUNCTION_KEY);\n+    String collectorTypeStr = configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.COLLECTOR_TYPE_KEY);\n+    Map<String, String> aggregatorConfigs = new HashMap<>();\n+    for (Map.Entry<String, String> entry : configs.entrySet()) {\n+      String key = entry.getKey();\n+      if (key.endsWith(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)) {\n+        String column = key.split(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)[0];\n+        aggregatorConfigs.put(column, entry.getValue());\n+      }\n+    }\n+    String numRecordsPerSegment =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.NUM_RECORDS_PER_SEGMENT_KEY);\n+\n+    SegmentProcessorConfig.Builder segmentProcessorConfigBuilder =\n+        new SegmentProcessorConfig.Builder().setTableConfig(tableConfig).setSchema(schema);\n+\n+    // Time rollup using configured time transformation function\n+    if (timeColumnTransformFunction != null) {\n+      RecordTransformerConfig recordTransformerConfig =\n+          getRecordTransformerConfigForTime(timeColumnTransformFunction, timeColumn);\n+      segmentProcessorConfigBuilder.setRecordTransformerConfig(recordTransformerConfig);\n+    }\n+\n+    // Filter function for extracting data between start and end time window\n+    RecordFilterConfig recordFilterConfig =\n+        getRecordFilterConfigForWindow(windowStartMs, windowEndMs, dateTimeFieldSpec, timeColumn);\n+    segmentProcessorConfigBuilder.setRecordFilterConfig(recordFilterConfig);\n+\n+    // Partitioner config from tableConfig\n+    if (tableConfig.getIndexingConfig().getSegmentPartitionConfig() != null) {\n+      Map<String, ColumnPartitionConfig> columnPartitionMap =\n+          tableConfig.getIndexingConfig().getSegmentPartitionConfig().getColumnPartitionMap();\n+      PartitionerConfig partitionerConfig = getPartitionerConfig(columnPartitionMap, tableNameWithType, schemaColumns);\n+      segmentProcessorConfigBuilder.setPartitionerConfigs(Lists.newArrayList(partitionerConfig));\n+    }\n+\n+    // Aggregations using configured Collector\n+    List<String> sortedColumns = tableConfig.getIndexingConfig().getSortedColumn();\n+    CollectorConfig collectorConfig =\n+        getCollectorConfig(collectorTypeStr, aggregatorConfigs, schemaColumns, sortedColumns);\n+    segmentProcessorConfigBuilder.setCollectorConfig(collectorConfig);\n+\n+    // Segment config\n+    if (numRecordsPerSegment != null) {\n+      SegmentConfig segmentConfig = getSegmentConfig(numRecordsPerSegment);\n+      segmentProcessorConfigBuilder.setSegmentConfig(segmentConfig);\n+    }\n+\n+    SegmentProcessorConfig segmentProcessorConfig = segmentProcessorConfigBuilder.build();\n+\n+    File inputSegmentsDir = new File(workingDir, INPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(inputSegmentsDir.mkdirs(), \"Failed to create input directory: %s for task: %s\",\n+        inputSegmentsDir.getAbsolutePath(), taskType);\n+    for (File indexDir : originalIndexDirs) {\n+      FileUtils.copyDirectoryToDirectory(indexDir, inputSegmentsDir);\n+    }\n+    File outputSegmentsDir = new File(workingDir, OUTPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(outputSegmentsDir.mkdirs(), \"Failed to create output directory: %s for task: %s\",\n+        outputSegmentsDir.getAbsolutePath(), taskType);\n+\n+    SegmentProcessorFramework segmentProcessorFramework =\n+        new SegmentProcessorFramework(inputSegmentsDir, segmentProcessorConfig, outputSegmentsDir);\n+    try {\n+      segmentProcessorFramework.processSegments();\n+    } finally {\n+      segmentProcessorFramework.cleanup();\n+    }\n+\n+    LOGGER.info(\"Finished task: {} with configs: {}\", taskType, configs);\n+    List<SegmentConversionResult> results = new ArrayList<>();\n+    for (File file : outputSegmentsDir.listFiles()) {\n+      String outputSegmentName = file.getName();\n+      results.add(new SegmentConversionResult.Builder().setFile(file).setSegmentName(outputSegmentName)\n+          .setTableNameWithType(tableNameWithType).build());\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Construct a {@link RecordTransformerConfig} for time column transformation\n+   */\n+  private RecordTransformerConfig getRecordTransformerConfigForTime(String timeColumnTransformFunction,\n+      String timeColumn) {\n+    Map<String, String> transformationsMap = new HashMap<>();\n+    transformationsMap.put(timeColumn, timeColumnTransformFunction);\n+    return new RecordTransformerConfig.Builder().setTransformFunctionsMap(transformationsMap).build();\n+  }\n+\n+  /**\n+   * Construct a {@link RecordFilterConfig} by setting a filter function on the time column, for extracting data between window start/end\n+   */\n+  private RecordFilterConfig getRecordFilterConfigForWindow(long windowStartMs, long windowEndMs,", "originalCommit": "1010a8f3ac7717c63fd16fba600152fec7b31f32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzExNzgxMQ==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497117811", "bodyText": "yes this will happen. this has been called out in the design doc: https://docs.google.com/document/d/1-e_9aHQB4HXS38ONtofdxNvMsGmAoYfSnc2LP88MbIc/edit#heading=h.5lkm0pm6vp7o\nWe discussed that the only way to handle this is for user to set a sufficient \"bufferTime\".", "author": "npawar", "createdAt": "2020-09-29T23:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxMzI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNzU0OA==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497017548", "bodyText": "Let's move the segment processing framework related configs to a static separate class. These configs will also be used by other tasks.", "author": "snleee", "createdAt": "2020-09-29T20:16:22Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/MinionConstants.java", "diffHunk": "@@ -61,4 +61,17 @@ private MinionConstants() {\n     public static final String MERGE_TYPE_KEY = \"mergeTypeKey\";\n     public static final String MERGED_SEGMENT_NAME_KEY = \"mergedSegmentNameKey\";\n   }\n+\n+  public static class RealtimeToOfflineSegmentsTask {\n+    public static final String TASK_TYPE = \"realtimeToOfflineSegmentsTask\";\n+    // window", "originalCommit": "1010a8f3ac7717c63fd16fba600152fec7b31f32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzExODYxOA==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497118618", "bodyText": "Can we do that when we add these other tasks? It will read odd for this PR", "author": "npawar", "createdAt": "2020-09-29T23:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNzU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzEyNTc3OQ==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497125779", "bodyText": "I see. I will make the changes with my merge & roll-up task generator PR.", "author": "snleee", "createdAt": "2020-09-29T23:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNzU0OA=="}], "type": "inlineReview"}, {"oid": "e29fdda136d4fe982f502ffe4aa4ff7b448dfe43", "url": "https://github.com/apache/pinot/commit/e29fdda136d4fe982f502ffe4aa4ff7b448dfe43", "message": "Review comments", "committedDate": "2020-09-29T22:53:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1MzE2Mw==", "url": "https://github.com/apache/pinot/pull/6050#discussion_r497653163", "bodyText": "remove line", "author": "snleee", "createdAt": "2020-09-30T16:42:37Z", "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.minion.executor;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorConfig;\n+import org.apache.pinot.core.segment.processing.collector.CollectorFactory;\n+import org.apache.pinot.core.segment.processing.collector.ValueAggregatorFactory;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterConfig;\n+import org.apache.pinot.core.segment.processing.filter.RecordFilterFactory;\n+import org.apache.pinot.core.segment.processing.framework.SegmentConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorConfig;\n+import org.apache.pinot.core.segment.processing.framework.SegmentProcessorFramework;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerConfig;\n+import org.apache.pinot.core.segment.processing.partitioner.PartitionerFactory;\n+import org.apache.pinot.core.segment.processing.transformer.RecordTransformerConfig;\n+import org.apache.pinot.spi.config.table.ColumnPartitionConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.data.DateTimeFieldSpec;\n+import org.apache.pinot.spi.data.DateTimeFormatSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A task to convert segments from a REALTIME table to segments for its corresponding OFFLINE table.\n+ * The realtime segments could span across multiple time windows. This task extracts data and creates segments for a configured time range.\n+ * The {@link SegmentProcessorFramework} is used for the segment conversion, which also does\n+ * 1. time column rollup\n+ * 2. time window extraction using filter function\n+ * 3. partitioning using table config's segmentPartitioningConfig\n+ * 4. aggregations and rollup\n+ * 5. data sorting\n+ */\n+public class RealtimeToOfflineSegmentsTaskExecutor extends BaseMultipleSegmentsConversionExecutor {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskExecutor.class);\n+  private static final String INPUT_SEGMENTS_DIR = \"input_segments\";\n+  private static final String OUTPUT_SEGMENTS_DIR = \"output_segments\";\n+\n+  @Override\n+  protected List<SegmentConversionResult> convert(PinotTaskConfig pinotTaskConfig, List<File> originalIndexDirs,\n+      File workingDir)\n+      throws Exception {\n+    String taskType = pinotTaskConfig.getTaskType();\n+    Map<String, String> configs = pinotTaskConfig.getConfigs();\n+    LOGGER.info(\"Starting task: {} with configs: {}\", taskType, configs);\n+    long startMillis = System.currentTimeMillis();\n+\n+    String tableNameWithType = configs.get(MinionConstants.TABLE_NAME_KEY); // rawTableName_OFFLINE expected here\n+    TableConfig tableConfig = getTableConfig(tableNameWithType);\n+    Schema schema = getSchema(tableNameWithType);\n+    Set<String> schemaColumns = schema.getPhysicalColumnNames();\n+    String timeColumn = tableConfig.getValidationConfig().getTimeColumnName();\n+    DateTimeFieldSpec dateTimeFieldSpec = schema.getSpecForTimeColumn(timeColumn);\n+    Preconditions\n+        .checkState(dateTimeFieldSpec != null, \"No valid spec found for time column: %s in schema for table: %s\",\n+            timeColumn, tableNameWithType);\n+\n+    long windowStartMs =\n+        Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_START_MILLIS_KEY));\n+    long windowEndMs = Long.parseLong(configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.WINDOW_END_MILLIS_KEY));\n+    String timeColumnTransformFunction =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.TIME_COLUMN_TRANSFORM_FUNCTION_KEY);\n+    String collectorTypeStr = configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.COLLECTOR_TYPE_KEY);\n+    Map<String, String> aggregatorConfigs = new HashMap<>();\n+    for (Map.Entry<String, String> entry : configs.entrySet()) {\n+      String key = entry.getKey();\n+      if (key.endsWith(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)) {\n+        String column = key.split(MinionConstants.RealtimeToOfflineSegmentsTask.AGGREGATION_TYPE_KEY_SUFFIX)[0];\n+        aggregatorConfigs.put(column, entry.getValue());\n+      }\n+    }\n+    String numRecordsPerSegment =\n+        configs.get(MinionConstants.RealtimeToOfflineSegmentsTask.MAX_NUM_RECORDS_PER_SEGMENT_KEY);\n+\n+    SegmentProcessorConfig.Builder segmentProcessorConfigBuilder =\n+        new SegmentProcessorConfig.Builder().setTableConfig(tableConfig).setSchema(schema);\n+\n+    // Time rollup using configured time transformation function\n+    if (timeColumnTransformFunction != null) {\n+      RecordTransformerConfig recordTransformerConfig =\n+          getRecordTransformerConfigForTime(timeColumnTransformFunction, timeColumn);\n+      segmentProcessorConfigBuilder.setRecordTransformerConfig(recordTransformerConfig);\n+    }\n+\n+    // Filter function for extracting data between start and end time window\n+    RecordFilterConfig recordFilterConfig =\n+        getRecordFilterConfigForWindow(windowStartMs, windowEndMs, dateTimeFieldSpec, timeColumn);\n+    segmentProcessorConfigBuilder.setRecordFilterConfig(recordFilterConfig);\n+\n+    // Partitioner config from tableConfig\n+    if (tableConfig.getIndexingConfig().getSegmentPartitionConfig() != null) {\n+      Map<String, ColumnPartitionConfig> columnPartitionMap =\n+          tableConfig.getIndexingConfig().getSegmentPartitionConfig().getColumnPartitionMap();\n+      PartitionerConfig partitionerConfig = getPartitionerConfig(columnPartitionMap, tableNameWithType, schemaColumns);\n+      segmentProcessorConfigBuilder.setPartitionerConfigs(Lists.newArrayList(partitionerConfig));\n+    }\n+\n+    // Aggregations using configured Collector\n+    List<String> sortedColumns = tableConfig.getIndexingConfig().getSortedColumn();\n+    CollectorConfig collectorConfig =\n+        getCollectorConfig(collectorTypeStr, aggregatorConfigs, schemaColumns, sortedColumns);\n+    segmentProcessorConfigBuilder.setCollectorConfig(collectorConfig);\n+\n+    // Segment config\n+    if (numRecordsPerSegment != null) {\n+      SegmentConfig segmentConfig = getSegmentConfig(numRecordsPerSegment);\n+      segmentProcessorConfigBuilder.setSegmentConfig(segmentConfig);\n+    }\n+\n+    SegmentProcessorConfig segmentProcessorConfig = segmentProcessorConfigBuilder.build();\n+\n+    File inputSegmentsDir = new File(workingDir, INPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(inputSegmentsDir.mkdirs(), \"Failed to create input directory: %s for task: %s\",\n+        inputSegmentsDir.getAbsolutePath(), taskType);\n+    for (File indexDir : originalIndexDirs) {\n+      FileUtils.copyDirectoryToDirectory(indexDir, inputSegmentsDir);\n+    }\n+    File outputSegmentsDir = new File(workingDir, OUTPUT_SEGMENTS_DIR);\n+    Preconditions.checkState(outputSegmentsDir.mkdirs(), \"Failed to create output directory: %s for task: %s\",\n+        outputSegmentsDir.getAbsolutePath(), taskType);\n+\n+    SegmentProcessorFramework segmentProcessorFramework =\n+        new SegmentProcessorFramework(inputSegmentsDir, segmentProcessorConfig, outputSegmentsDir);\n+    try {\n+      segmentProcessorFramework.processSegments();\n+    } finally {\n+      segmentProcessorFramework.cleanup();\n+    }\n+\n+    long endMillis = System.currentTimeMillis();\n+    LOGGER.info(\"Finished task: {} with configs: {}. Total time: {}ms\", taskType, configs, (endMillis - startMillis));\n+    List<SegmentConversionResult> results = new ArrayList<>();\n+    for (File file : outputSegmentsDir.listFiles()) {\n+      String outputSegmentName = file.getName();\n+      results.add(new SegmentConversionResult.Builder().setFile(file).setSegmentName(outputSegmentName)\n+          .setTableNameWithType(tableNameWithType).build());\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Construct a {@link RecordTransformerConfig} for time column transformation\n+   */\n+  private RecordTransformerConfig getRecordTransformerConfigForTime(String timeColumnTransformFunction,\n+      String timeColumn) {\n+    Map<String, String> transformationsMap = new HashMap<>();\n+    transformationsMap.put(timeColumn, timeColumnTransformFunction);\n+    return new RecordTransformerConfig.Builder().setTransformFunctionsMap(transformationsMap).build();\n+  }\n+\n+  /**\n+   * Construct a {@link RecordFilterConfig} by setting a filter function on the time column, for extracting data between window start/end\n+   */\n+  private RecordFilterConfig getRecordFilterConfigForWindow(long windowStartMs, long windowEndMs,\n+      DateTimeFieldSpec dateTimeFieldSpec, String timeColumn) {\n+    String filterFunction;\n+    DateTimeFormatSpec dateTimeFormatSpec = new DateTimeFormatSpec(dateTimeFieldSpec.getFormat());\n+    TimeUnit timeUnit = dateTimeFormatSpec.getColumnUnit();\n+    DateTimeFieldSpec.TimeFormat timeFormat = dateTimeFormatSpec.getTimeFormat();\n+    if (timeUnit.equals(TimeUnit.MILLISECONDS) && timeFormat.equals(DateTimeFieldSpec.TimeFormat.EPOCH)) {\n+      // If time column is in EPOCH millis, use windowStart and windowEnd directly to filter\n+      filterFunction = getFilterFunctionLong(windowStartMs, windowEndMs, timeColumn);\n+    } else {\n+      // Convert windowStart and windowEnd to time format of the data\n+      if (dateTimeFormatSpec.getTimeFormat().equals(DateTimeFieldSpec.TimeFormat.EPOCH)) {\n+        long windowStart = dateTimeFormatSpec.fromMillisToFormat(windowStartMs, Long.class);\n+        long windowEnd = dateTimeFormatSpec.fromMillisToFormat(windowEndMs, Long.class);\n+        filterFunction = getFilterFunctionLong(windowStart, windowEnd, timeColumn);\n+      } else {\n+        String windowStart = dateTimeFormatSpec.fromMillisToFormat(windowStartMs, String.class);\n+        String windowEnd = dateTimeFormatSpec.fromMillisToFormat(windowEndMs, String.class);\n+        if (dateTimeFieldSpec.getDataType().isNumeric()) {\n+          filterFunction = getFilterFunctionLong(Long.parseLong(windowStart), Long.parseLong(windowEnd), timeColumn);\n+        } else {\n+          filterFunction = getFilterFunctionString(windowStart, windowEnd, timeColumn);\n+        }\n+      }\n+    }\n+    return new RecordFilterConfig.Builder().setRecordFilterType(RecordFilterFactory.RecordFilterType.FILTER_FUNCTION)\n+        .setFilterFunction(filterFunction).build();\n+  }\n+\n+  /**\n+   * Construct a {@link PartitionerConfig} using {@link org.apache.pinot.spi.config.table.SegmentPartitionConfig} from the table config\n+   */\n+  private PartitionerConfig getPartitionerConfig(Map<String, ColumnPartitionConfig> columnPartitionMap,\n+      String tableNameWithType, Set<String> schemaColumns) {\n+", "originalCommit": "e29fdda136d4fe982f502ffe4aa4ff7b448dfe43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c695ab2f06fe3af13daf17a3e3e36699bd474b89", "url": "https://github.com/apache/pinot/commit/c695ab2f06fe3af13daf17a3e3e36699bd474b89", "message": "Remove line", "committedDate": "2020-09-30T17:50:25Z", "type": "commit"}]}