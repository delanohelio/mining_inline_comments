{"pr_number": 5605, "pr_title": "[QueryContext] Use QueryContext in Operators and DataTableReducers", "pr_createdAt": "2020-06-22T23:54:03Z", "pr_url": "https://github.com/apache/pinot/pull/5605", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNzAwNQ==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r444417005", "bodyText": "Perhaps add something to indicate that this is the combine phase? For example, Caught exception in combine phase of group-by...?", "author": "mayankshriv", "createdAt": "2020-06-23T18:15:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/CombineGroupByOperator.java", "diffHunk": "@@ -174,8 +173,8 @@ public void runJob() {\n           } catch (EarlyTerminationException e) {\n             // Early-terminated because query times out or is already satisfied\n           } catch (Exception e) {\n-            LOGGER.error(\"Exception processing CombineGroupBy for index {}, operator {}, brokerRequest {}\", index,\n-                _operators.get(index).getClass().getName(), _brokerRequest, e);\n+            LOGGER.error(\"Caught exception while processing group-by for index: {}, operator: {}, queryContext: {}\",", "originalCommit": "9bca3ed7c22eaeb0cccf971f7c3d061c64cdd3c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2Njc0MA==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r444466740", "bodyText": "Added", "author": "Jackie-Jiang", "createdAt": "2020-06-23T19:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNzAwNQ=="}], "type": "inlineReview"}, {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f", "url": "https://github.com/apache/pinot/commit/d30362c59114fa71f9d03d30a55c64a54b10382f", "message": "[QueryContext] Use QueryContext in Operators and DataTableReducers\n\nReplace BrokerRequest with QueryContext in Operators (server side) and DataTableReducers (broker side)\nThe reason to put these 2 part in one PR is because they share the same code for selection queries\nThe change is backward-compatible because it does not involve any change on the wiring layer\n\nChanges for QueryContext:\n- Select expressions will contain both aggregation and non-aggregation expressions so that the columns in the result table can be correctly ordered\n- Change method signature from `getAlias(ExpressionCOntext expression)` to `getAliasMap()` and return an unmodifiable map to make it easier to use", "committedDate": "2020-06-23T19:48:00Z", "type": "commit"}, {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f", "url": "https://github.com/apache/pinot/commit/d30362c59114fa71f9d03d30a55c64a54b10382f", "message": "[QueryContext] Use QueryContext in Operators and DataTableReducers\n\nReplace BrokerRequest with QueryContext in Operators (server side) and DataTableReducers (broker side)\nThe reason to put these 2 part in one PR is because they share the same code for selection queries\nThe change is backward-compatible because it does not involve any change on the wiring layer\n\nChanges for QueryContext:\n- Select expressions will contain both aggregation and non-aggregation expressions so that the columns in the result table can be correctly ordered\n- Change method signature from `getAlias(ExpressionCOntext expression)` to `getAliasMap()` and return an unmodifiable map to make it easier to use", "committedDate": "2020-06-23T19:48:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMDA4Mg==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445110082", "bodyText": "Shouldn't this be replaced with FunctionContext?", "author": "siddharthteotia", "createdAt": "2020-06-24T19:06:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/table/SimpleIndexedTable.java", "diffHunk": "@@ -49,12 +50,12 @@\n    * Initializes the data structures needed for this Table\n    * @param dataSchema data schema of the record's keys and values\n    * @param aggregationFunctions aggregation functions for the record's values", "originalCommit": "d30362c59114fa71f9d03d30a55c64a54b10382f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzMjg1OA==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445132858", "bodyText": "No. AggregationFunction is the execution class instead of the info class. FunctionContext will replace AggregationInfo in the following PR of replacing BrokerRequest classes in aggregation and transform functions", "author": "Jackie-Jiang", "createdAt": "2020-06-24T19:50:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMDA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNzg5MQ==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445137891", "bodyText": "I am not sure why we had to change the logic. We already have support for schema mapping for a column right? getFinalSchemaMapIdx() is supposed to do that.", "author": "siddharthteotia", "createdAt": "2020-06-24T19:59:54Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -171,106 +160,81 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-\n+    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n-\n-    int[] finalSchemaMapIdx = null;\n-    if (_sqlSelectionList != null) {\n-      finalSchemaMapIdx = getFinalSchemaMapIdx();\n-    }\n-    List<Object[]> rows = new ArrayList<>();\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n-    int numRows = 0;\n-    while (numRows < _groupBy.getTopN() && sortedIterator.hasNext()) {\n-      Record nextRecord = sortedIterator.next();\n-      Object[] values = nextRecord.getValues();\n-\n-      int index = _numGroupBy;\n-      int aggNum = 0;\n-      while (index < _numColumns) {\n-        values[index] = AggregationFunctionUtils\n-            .getSerializableValue(_aggregationFunctions[aggNum++].extractFinalResult(values[index]));\n-        index++;\n+    int limit = _queryContext.getLimit();\n+    List<Object[]> rows = new ArrayList<>(limit);\n+\n+    if (_sqlQuery) {", "originalCommit": "d30362c59114fa71f9d03d30a55c64a54b10382f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MDc0MA==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445180740", "bodyText": "getFinalSchemaMapIdx is renamed to getSelectExpressionIndexMap for readability.\nThe existing logic keeps the sql query check inside the loop, which is not efficient and not as readable IMO. The change makes the sql query check at the top level, and once we move to SQL completely, we can simply remove the else part.", "author": "Jackie-Jiang", "createdAt": "2020-06-24T21:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNzg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzOTAwNQ==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445139005", "bodyText": "This existing logic seems simpler", "author": "siddharthteotia", "createdAt": "2020-06-24T20:01:57Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -171,106 +160,81 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-\n+    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n-\n-    int[] finalSchemaMapIdx = null;\n-    if (_sqlSelectionList != null) {\n-      finalSchemaMapIdx = getFinalSchemaMapIdx();\n-    }\n-    List<Object[]> rows = new ArrayList<>();\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n-    int numRows = 0;\n-    while (numRows < _groupBy.getTopN() && sortedIterator.hasNext()) {\n-      Record nextRecord = sortedIterator.next();\n-      Object[] values = nextRecord.getValues();\n-\n-      int index = _numGroupBy;\n-      int aggNum = 0;\n-      while (index < _numColumns) {\n-        values[index] = AggregationFunctionUtils\n-            .getSerializableValue(_aggregationFunctions[aggNum++].extractFinalResult(values[index]));\n-        index++;\n+    int limit = _queryContext.getLimit();\n+    List<Object[]> rows = new ArrayList<>(limit);\n+\n+    if (_sqlQuery) {\n+      // NOTE: For SQL query, need to reorder the columns in the data table based on the select expressions.\n+\n+      int[] selectExpressionIndexMap = getSelectExpressionIndexMap();\n+      int numSelectExpressions = selectExpressionIndexMap.length;\n+      String[] columnNames = resultTableSchema.getColumnNames();\n+      DataSchema.ColumnDataType[] columnDataTypes = resultTableSchema.getColumnDataTypes();\n+      String[] reorderedColumnNames = new String[numSelectExpressions];\n+      DataSchema.ColumnDataType[] reorderedColumnDataTypes = new DataSchema.ColumnDataType[numSelectExpressions];\n+      resultTableSchema = new DataSchema(reorderedColumnNames, reorderedColumnDataTypes);\n+      for (int i = 0; i < numSelectExpressions; i++) {\n+        reorderedColumnNames[i] = columnNames[selectExpressionIndexMap[i]];\n+        reorderedColumnDataTypes[i] = columnDataTypes[selectExpressionIndexMap[i]];\n       }\n-      if (_sqlSelectionList != null) {", "originalCommit": "d30362c59114fa71f9d03d30a55c64a54b10382f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MTU3MA==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445181570", "bodyText": "I don't think so. The existing logic have the same if condition in 3 places (line 178, 195, 208), and this one is even in a while loop. Instead, the change makes it one time branching, which is much more clear IMO.", "author": "Jackie-Jiang", "createdAt": "2020-06-24T21:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzOTAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0NTczNQ==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445145735", "bodyText": "We should actually consider deleting this. We should not mix PQL with SQL. This code path is for PQL execution but SQL response format. We should not let users avail that. Ideally, it should be\nSQL query -> SQL execution -> SQL response\nPQL query -> PQL execution -> PQL response\nThe functions in this class are extraordinarily large in size and the code looks very confusing because of these branches (not related to this PR)", "author": "siddharthteotia", "createdAt": "2020-06-24T20:15:23Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -486,69 +447,44 @@ private void setGroupByResults(BrokerResponseNative brokerResponseNative, boolea\n       finalResultMaps[i] = finalResultMap;\n     }\n \n-    int aggregationNumsInFinalResult = 0;\n-    for (int i = 0; i < _numAggregationFunctions; i++) {\n-      if (aggregationFunctionsSelectStatus[i]) {\n-        aggregationNumsInFinalResult++;\n-      }\n-    }\n-\n-    if (aggregationNumsInFinalResult > 0) {\n-      String[] finalColumnNames = new String[aggregationNumsInFinalResult];\n-      Map<String, Comparable>[] finalOutResultMaps = new Map[aggregationNumsInFinalResult];\n-      String[] finalResultTableAggNames = new String[aggregationNumsInFinalResult];\n-      AggregationFunction[] finalAggregationFunctions = new AggregationFunction[aggregationNumsInFinalResult];\n-      int count = 0;\n-      for (int i = 0; i < _numAggregationFunctions; i++) {\n-        if (aggregationFunctionsSelectStatus[i]) {\n-          finalColumnNames[count] = columnNames[i];\n-          finalOutResultMaps[count] = finalResultMaps[i];\n-          AggregationFunction aggregationFunction = _aggregationFunctions[i];\n-          finalResultTableAggNames[count] = aggregationFunction.getResultColumnName();\n-          finalAggregationFunctions[count] = aggregationFunction;\n-          count++;\n+    // Trim the final result maps and set them into the broker response.\n+    AggregationGroupByTrimmingService aggregationGroupByTrimmingService =\n+        new AggregationGroupByTrimmingService(_aggregationFunctions, _queryContext.getLimit());\n+    List<GroupByResult>[] groupByResultLists = aggregationGroupByTrimmingService.trimFinalResults(finalResultMaps);\n+\n+    if (_responseFormatSql) {", "originalCommit": "d30362c59114fa71f9d03d30a55c64a54b10382f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MjEzNg==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445182136", "bodyText": "Agree, but we have to keep this behavior for backward-compatibility.\nOnce we deprecate PQL semantic, all these checks will gone", "author": "Jackie-Jiang", "createdAt": "2020-06-24T21:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0NTczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0ODI5OQ==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445148299", "bodyText": "Looks like this piece of code was redundant and that'w why you invoke trimming on already computed finalResultMaps in the new code?", "author": "siddharthteotia", "createdAt": "2020-06-24T20:20:27Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -486,69 +447,44 @@ private void setGroupByResults(BrokerResponseNative brokerResponseNative, boolea\n       finalResultMaps[i] = finalResultMap;\n     }\n \n-    int aggregationNumsInFinalResult = 0;\n-    for (int i = 0; i < _numAggregationFunctions; i++) {\n-      if (aggregationFunctionsSelectStatus[i]) {\n-        aggregationNumsInFinalResult++;\n-      }\n-    }\n-\n-    if (aggregationNumsInFinalResult > 0) {", "originalCommit": "d30362c59114fa71f9d03d30a55c64a54b10382f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MzYyNw==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445183627", "bodyText": "The aggregationFunctionsSelectStatus is redundant (was introduced for HAVING clause), and thus this if check is no longer valid (always true). This part of the code is the same as before, the only change is the indentation.", "author": "Jackie-Jiang", "createdAt": "2020-06-24T21:31:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0ODI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyMTM2MQ==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445221361", "bodyText": "It will be good to add a comment here stating that this is for the code path for PQL query compiled by PQLCompiler but having both the options (groupByModeSql and responseFormatSqL to true).", "author": "siddharthteotia", "createdAt": "2020-06-24T23:13:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -171,106 +160,81 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-\n+    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n-\n-    int[] finalSchemaMapIdx = null;\n-    if (_sqlSelectionList != null) {\n-      finalSchemaMapIdx = getFinalSchemaMapIdx();\n-    }\n-    List<Object[]> rows = new ArrayList<>();\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n-    int numRows = 0;\n-    while (numRows < _groupBy.getTopN() && sortedIterator.hasNext()) {\n-      Record nextRecord = sortedIterator.next();\n-      Object[] values = nextRecord.getValues();\n-\n-      int index = _numGroupBy;\n-      int aggNum = 0;\n-      while (index < _numColumns) {\n-        values[index] = AggregationFunctionUtils\n-            .getSerializableValue(_aggregationFunctions[aggNum++].extractFinalResult(values[index]));\n-        index++;\n+    int limit = _queryContext.getLimit();\n+    List<Object[]> rows = new ArrayList<>(limit);\n+\n+    if (_sqlQuery) {\n+      // NOTE: For SQL query, need to reorder the columns in the data table based on the select expressions.\n+\n+      int[] selectExpressionIndexMap = getSelectExpressionIndexMap();\n+      int numSelectExpressions = selectExpressionIndexMap.length;\n+      String[] columnNames = resultTableSchema.getColumnNames();\n+      DataSchema.ColumnDataType[] columnDataTypes = resultTableSchema.getColumnDataTypes();\n+      String[] reorderedColumnNames = new String[numSelectExpressions];\n+      DataSchema.ColumnDataType[] reorderedColumnDataTypes = new DataSchema.ColumnDataType[numSelectExpressions];\n+      resultTableSchema = new DataSchema(reorderedColumnNames, reorderedColumnDataTypes);\n+      for (int i = 0; i < numSelectExpressions; i++) {\n+        reorderedColumnNames[i] = columnNames[selectExpressionIndexMap[i]];\n+        reorderedColumnDataTypes[i] = columnDataTypes[selectExpressionIndexMap[i]];\n       }\n-      if (_sqlSelectionList != null) {\n-        Object[] finalValues = new Object[_sqlSelectionList.size()];\n-        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n-          finalValues[i] = values[finalSchemaMapIdx[i]];\n+      while (rows.size() < limit && sortedIterator.hasNext()) {\n+        Record nextRecord = sortedIterator.next();\n+        Object[] values = nextRecord.getValues();\n+        for (int i = 0; i < _numAggregationFunctions; i++) {\n+          int valueIndex = i + _numGroupByExpressions;\n+          values[valueIndex] = AggregationFunctionUtils\n+              .getSerializableValue(_aggregationFunctions[i].extractFinalResult(values[valueIndex]));\n         }\n-        rows.add(finalValues);\n-      } else {\n-        rows.add(values);\n-      }\n-      numRows++;\n-    }\n \n-    DataSchema finalDataSchema = getSQLResultTableSchema(dataSchema);\n-    if (_sqlSelectionList != null) {\n-      int columnSize = _sqlSelectionList.size();\n-      String[] columns = new String[columnSize];\n-      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[columnSize];\n-      for (int i = 0; i < columnSize; i++) {\n-        columns[i] = finalDataSchema.getColumnName(finalSchemaMapIdx[i]);\n-        columnDataTypes[i] = finalDataSchema.getColumnDataType(finalSchemaMapIdx[i]);\n+        Object[] reorderedValues = new Object[numSelectExpressions];\n+        for (int i = 0; i < numSelectExpressions; i++) {\n+          reorderedValues[i] = values[selectExpressionIndexMap[i]];\n+        }\n+        rows.add(reorderedValues);\n       }\n-      finalDataSchema = new DataSchema(columns, columnDataTypes);\n-    }\n-    brokerResponseNative.setResultTable(new ResultTable(finalDataSchema, rows));\n-  }\n-\n-  /**\n-   * Generate index mapping based on selection expression to DataTable schema, which is groupBy columns,\n-   * then aggregation functions.\n-   *\n-   * @return a mapping from final schema idx to corresponding idx in data table schema.\n-   */\n-  private int[] getFinalSchemaMapIdx() {\n-    int[] finalSchemaMapIdx = new int[_sqlSelectionList.size()];\n-    int nextAggregationIdx = _numGroupBy;\n-    for (int i = 0; i < _sqlSelectionList.size(); i++) {\n-      finalSchemaMapIdx[i] = getExpressionMapIdx(_sqlSelectionList.get(i), nextAggregationIdx);\n-      if (finalSchemaMapIdx[i] == nextAggregationIdx) {\n-        nextAggregationIdx++;\n+    } else {\n+      while (rows.size() < limit && sortedIterator.hasNext()) {", "originalCommit": "d30362c59114fa71f9d03d30a55c64a54b10382f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyNzE3OA==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445227178", "bodyText": "Added", "author": "Jackie-Jiang", "createdAt": "2020-06-24T23:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyMTM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyMTgzMw==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445221833", "bodyText": "Should add a comment here that this is for SQL query compiled by calcite compiler, parser and having both the options (groupByModeSql and responseFormatSqL to true). Eventually we just want this path (SQL only) after PQL is completely deleted.", "author": "siddharthteotia", "createdAt": "2020-06-24T23:15:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -171,106 +160,81 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-\n+    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n-\n-    int[] finalSchemaMapIdx = null;\n-    if (_sqlSelectionList != null) {\n-      finalSchemaMapIdx = getFinalSchemaMapIdx();\n-    }\n-    List<Object[]> rows = new ArrayList<>();\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n-    int numRows = 0;\n-    while (numRows < _groupBy.getTopN() && sortedIterator.hasNext()) {\n-      Record nextRecord = sortedIterator.next();\n-      Object[] values = nextRecord.getValues();\n-\n-      int index = _numGroupBy;\n-      int aggNum = 0;\n-      while (index < _numColumns) {\n-        values[index] = AggregationFunctionUtils\n-            .getSerializableValue(_aggregationFunctions[aggNum++].extractFinalResult(values[index]));\n-        index++;\n+    int limit = _queryContext.getLimit();\n+    List<Object[]> rows = new ArrayList<>(limit);\n+\n+    if (_sqlQuery) {\n+      // NOTE: For SQL query, need to reorder the columns in the data table based on the select expressions.\n+\n+      int[] selectExpressionIndexMap = getSelectExpressionIndexMap();", "originalCommit": "d30362c59114fa71f9d03d30a55c64a54b10382f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyNjMxMg==", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445226312", "bodyText": "Good point, added", "author": "Jackie-Jiang", "createdAt": "2020-06-24T23:29:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyMTgzMw=="}], "type": "inlineReview"}, {"oid": "aef2c2090f9c61a216f816db88e434dd544ae39a", "url": "https://github.com/apache/pinot/commit/aef2c2090f9c61a216f816db88e434dd544ae39a", "message": "address comments", "committedDate": "2020-06-24T23:33:16Z", "type": "commit"}]}