{"pr_number": 6046, "pr_title": "Deep Extraction Support for ORC, Thrift, and ProtoBuf Records", "pr_createdAt": "2020-09-22T17:16:21Z", "pr_url": "https://github.com/apache/pinot/pull/6046", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MDM0MQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493140341", "bodyText": "Recommend not adding this generic type V as in most cases it is Object (the field can be of lots of types for the same file format)", "author": "Jackie-Jiang", "createdAt": "2020-09-23T01:52:52Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -27,8 +28,9 @@\n  * 2) Collections become Object[] i.e. multi-value column\n  * 3) Nested/Complex fields (e.g. json maps, avro maps, avro records) become Map<Object, Object>\n  * @param <T> The format of the input record\n+ * @param <V> The input record's field to be converted", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYxMzg5OQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495613899", "bodyText": "Makes sense. Will remove the generic type V.", "author": "timsants", "createdAt": "2020-09-27T20:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MDM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MTA4NA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493141084", "bodyText": "Put nullable annotation before fields", "author": "Jackie-Jiang", "createdAt": "2020-09-23T01:54:03Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -27,8 +28,9 @@\n  * 2) Collections become Object[] i.e. multi-value column\n  * 3) Nested/Complex fields (e.g. json maps, avro maps, avro records) become Map<Object, Object>\n  * @param <T> The format of the input record\n+ * @param <V> The input record's field to be converted\n  */\n-public interface RecordExtractor<T> {\n+public interface RecordExtractor<T, V> {\n \n   /**\n    * Initialize the record extractor with its config", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MzQzOQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493143439", "bodyText": "We should return byte[] instead of ByteBuffer", "author": "Jackie-Jiang", "createdAt": "2020-09-23T01:57:44Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -46,4 +48,16 @@\n    * @return The output GenericRow\n    */\n   GenericRow extract(T from, GenericRow to);\n+\n+  /**\n+   * Converts a field of the given input record. The field value will be converted to either a single value", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDU1Nw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493144557", "bodyText": "We might not want to pass null into the convert(). Check the value before calling convert()", "author": "Jackie-Jiang", "createdAt": "2020-09-23T01:59:24Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -46,4 +48,16 @@\n    * @return The output GenericRow\n    */\n   GenericRow extract(T from, GenericRow to);\n+\n+  /**\n+   * Converts a field of the given input record. The field value will be converted to either a single value\n+   * (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   *\n+   * @param value the field value to be converted\n+   * @return The converted field value\n+   */\n+  Object convert(@Nullable V value);", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYxNDQwOQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495614409", "bodyText": "I prefer handling null values in one place if we want consistent handling across all the extractors. But if you think that this treatment of null could differ across different data formats/types, we can put the null handling before calling convert().", "author": "timsants", "createdAt": "2020-09-27T20:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQzMTg2Mg==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496431862", "bodyText": "I prefer handling null explicitly before calling the method for readability and slightly better performance (save a method call), while this is personal preference so either way is fine", "author": "Jackie-Jiang", "createdAt": "2020-09-29T05:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3MjAxMA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r497972010", "bodyText": "That's a good point regarding performance. I can move the null handling before calling the method.", "author": "timsants", "createdAt": "2020-10-01T04:05:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NTUyMQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493145521", "bodyText": "Are we returning null for empty array/collection/map? If so, let's add the behavior to the javadoc and annotate the return value as nullable", "author": "Jackie-Jiang", "createdAt": "2020-09-23T02:00:50Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -46,4 +48,16 @@\n    * @return The output GenericRow\n    */\n   GenericRow extract(T from, GenericRow to);\n+\n+  /**\n+   * Converts a field of the given input record. The field value will be converted to either a single value\n+   * (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   *\n+   * @param value the field value to be converted\n+   * @return The converted field value\n+   */\n+  Object convert(@Nullable V value);", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1MjcxNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493152717", "bodyText": "Suggest renaming it to BaseRecordExtractor", "author": "Jackie-Jiang", "createdAt": "2020-09-23T02:12:43Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n+ */\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwNjA0Ng==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495606046", "bodyText": "Good suggestion. Renamed.", "author": "timsants", "createdAt": "2020-09-27T19:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1MjcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NDUzNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493154537", "bodyText": "Not sure how much value this generic type V can provide. IMO convertRecord(Object value) should be good enough (similar to convertMap(Object value) etc.)", "author": "Jackie-Jiang", "createdAt": "2020-09-23T02:15:33Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwNzczOQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495607739", "bodyText": "Yes I agree. The only use of the generic type V is for the Object conversion but this can easily be handled within the convertRecord implementation.", "author": "timsants", "createdAt": "2020-09-27T19:40:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NDUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NDkzOQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493154939", "bodyText": "Return false for default implementation?", "author": "Jackie-Jiang", "createdAt": "2020-09-23T02:16:09Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n+ */\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord((V) value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type.\n+   */\n+  protected abstract boolean isInstanceOfRecord(Object value);", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYxMzQ1NQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495613455", "bodyText": "Sounds good. This would help simplify the JSON extractor.", "author": "timsants", "createdAt": "2020-09-27T20:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NDkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NTEzNg==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493155136", "bodyText": "Throw UnsupportedOperationException for default implementation?", "author": "Jackie-Jiang", "createdAt": "2020-09-23T02:16:28Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n+ */\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord((V) value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type.\n+   */\n+  protected abstract boolean isInstanceOfRecord(Object value);\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format.\n+   */\n+  @Nullable\n+  protected abstract Object convertRecord(V value);", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NTQyNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493155427", "bodyText": "The argument will never be null", "author": "Jackie-Jiang", "createdAt": "2020-09-23T02:16:54Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n+ */\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord((V) value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type.\n+   */\n+  protected abstract boolean isInstanceOfRecord(Object value);\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format.\n+   */\n+  @Nullable\n+  protected abstract Object convertRecord(V value);\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = convert(element);\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {\n+      convertedMap.put(convertSingleValue(key), convert(map.get(key)));\n+    }\n+    return convertedMap;\n+  }\n+\n+  /**\n+   * Converts single value types. This should be overridden if the data format requires\n+   * a different conversion for its single values. Returns {@code null} for {@code null} input values.\n+   */\n+  @Nullable\n+  protected Object convertSingleValue(@Nullable Object value) {", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYxNTM2MA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495615360", "bodyText": "This method is called for converting map keys without checking for null. I believe it is possible to have a null map key but do we want to accept this case?", "author": "timsants", "createdAt": "2020-09-27T20:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NTQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NDI1Ng==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r494744256", "bodyText": "It'd be good to avoid using the non-functional way for performance concern. Please refer to the way that AvroRecordExtractor uses. Same to the other Extractors.", "author": "jackjlli", "createdAt": "2020-09-25T04:44:35Z", "path": "pinot-plugins/pinot-input-format/pinot-json/src/main/java/org/apache/pinot/plugin/inputformat/json/JSONRecordExtractor.java", "diffHunk": "@@ -45,18 +45,32 @@ public void init(Set<String> fields, @Nullable RecordExtractorConfig recordExtra\n   @Override\n   public GenericRow extract(Map<String, Object> from, GenericRow to) {\n     if (_extractAll) {\n-      from.forEach((fieldName, value) -> to.putValue(fieldName, JSONRecordExtractorUtils.convertValue(value)));\n+      from.forEach((fieldName, value) -> to.putValue(fieldName, convert(value)));", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYxMzQzNA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495613434", "bodyText": "Sure I can do that. But do you have any resources showing evidence for this? I thought the underlying implementation for .forEach would be similar to for (T t : iterable) given that it is not performed on a java .stream().", "author": "timsants", "createdAt": "2020-09-27T20:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NDI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYxOTQ4OQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495619489", "bodyText": "We had an internal meeting to discuss about the performance between functional and procedural method a year ago.\nHere's a doc on the performance of using functional method:\nhttps://www.beyondjava.net/performance-java-8-lambdas", "author": "jackjlli", "createdAt": "2020-09-27T21:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NDI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MDk0Mw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496140943", "bodyText": "I see. Thanks for the background info. I'll change the extractors such that they do not use the lambda expression then.", "author": "timsants", "createdAt": "2020-09-28T18:10:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NDI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDEzNA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496310134", "bodyText": "You can still use the method you added such as isInstanceOfRecord here. So in the method:\n  protected boolean isInstanceOfRecord(Object value) {\n    return (TypeDescription.Category) value == TypeDescription.Category.STRUCT;\n  }", "author": "jackjlli", "createdAt": "2020-09-29T00:39:53Z", "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -175,68 +186,102 @@ public GenericRow next(GenericRow reuse)\n       }\n       String field = _orcFields.get(i);\n       TypeDescription fieldType = _orcFieldTypes.get(i);\n-      TypeDescription.Category category = fieldType.getCategory();\n-      if (category == TypeDescription.Category.LIST) {\n-        // Multi-value field, extract to Object[]\n-        TypeDescription.Category childCategory = fieldType.getChildren().get(0).getCategory();\n-        ListColumnVector listColumnVector = (ListColumnVector) _rowBatch.cols[i];\n-        int rowId = listColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n-          int offset = (int) listColumnVector.offsets[rowId];\n-          int length = (int) listColumnVector.lengths[rowId];\n-          List<Object> values = new ArrayList<>(length);\n-          for (int j = 0; j < length; j++) {\n-            Object value = extractSingleValue(field, listColumnVector.child, offset + j, childCategory);\n-            // NOTE: Only keep non-null values\n-            // TODO: Revisit\n-            if (value != null) {\n-              values.add(value);\n-            }\n-          }\n-          if (!values.isEmpty()) {\n-            reuse.putValue(field, values.toArray());\n-          } else {\n-            // NOTE: Treat empty list as null\n-            // TODO: Revisit\n-            reuse.putValue(field, null);\n-          }\n-        } else {\n-          reuse.putValue(field, null);\n+      reuse.putValue(field, extractValue(field, _rowBatch.cols[i], fieldType, _nextRowId));\n+    }\n+\n+    if (++_nextRowId == _rowBatch.size) {\n+      _hasNext = _orcRecordReader.nextBatch(_rowBatch);\n+      _nextRowId = 0;\n+    }\n+    return reuse;\n+  }\n+\n+  /**\n+   * Extracts the values for a given column vector.\n+   *\n+   * @param field name of the field being extracted\n+   * @param columnVector contains values of the field and its sub-types\n+   * @param fieldType information about the field such as the category (STRUCT, LIST, MAP, INT, etc)\n+   * @param rowId the ID of the row value being extracted\n+   * @return extracted row value from the column\n+   */\n+  @Nullable\n+  private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n+    TypeDescription.Category category = fieldType.getCategory();\n+\n+    if (category == TypeDescription.Category.STRUCT) {", "originalCommit": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQyMjAwNQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r504422005", "bodyText": "Resolving since ORC extraction is different from the other extractors.", "author": "timsants", "createdAt": "2020-10-14T06:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDE3OQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496310179", "bodyText": "Same here.", "author": "jackjlli", "createdAt": "2020-09-29T00:40:02Z", "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -175,68 +186,102 @@ public GenericRow next(GenericRow reuse)\n       }\n       String field = _orcFields.get(i);\n       TypeDescription fieldType = _orcFieldTypes.get(i);\n-      TypeDescription.Category category = fieldType.getCategory();\n-      if (category == TypeDescription.Category.LIST) {\n-        // Multi-value field, extract to Object[]\n-        TypeDescription.Category childCategory = fieldType.getChildren().get(0).getCategory();\n-        ListColumnVector listColumnVector = (ListColumnVector) _rowBatch.cols[i];\n-        int rowId = listColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n-          int offset = (int) listColumnVector.offsets[rowId];\n-          int length = (int) listColumnVector.lengths[rowId];\n-          List<Object> values = new ArrayList<>(length);\n-          for (int j = 0; j < length; j++) {\n-            Object value = extractSingleValue(field, listColumnVector.child, offset + j, childCategory);\n-            // NOTE: Only keep non-null values\n-            // TODO: Revisit\n-            if (value != null) {\n-              values.add(value);\n-            }\n-          }\n-          if (!values.isEmpty()) {\n-            reuse.putValue(field, values.toArray());\n-          } else {\n-            // NOTE: Treat empty list as null\n-            // TODO: Revisit\n-            reuse.putValue(field, null);\n-          }\n-        } else {\n-          reuse.putValue(field, null);\n+      reuse.putValue(field, extractValue(field, _rowBatch.cols[i], fieldType, _nextRowId));\n+    }\n+\n+    if (++_nextRowId == _rowBatch.size) {\n+      _hasNext = _orcRecordReader.nextBatch(_rowBatch);\n+      _nextRowId = 0;\n+    }\n+    return reuse;\n+  }\n+\n+  /**\n+   * Extracts the values for a given column vector.\n+   *\n+   * @param field name of the field being extracted\n+   * @param columnVector contains values of the field and its sub-types\n+   * @param fieldType information about the field such as the category (STRUCT, LIST, MAP, INT, etc)\n+   * @param rowId the ID of the row value being extracted\n+   * @return extracted row value from the column\n+   */\n+  @Nullable\n+  private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n+    TypeDescription.Category category = fieldType.getCategory();\n+\n+    if (category == TypeDescription.Category.STRUCT) {\n+      StructColumnVector structColumnVector = (StructColumnVector) columnVector;\n+      if (!structColumnVector.isNull[rowId]) {\n+        List<TypeDescription> childrenFieldTypes = fieldType.getChildren();\n+        List<String> childrenFieldNames = fieldType.getFieldNames();\n+\n+        Map<Object, Object> convertedMap = new HashMap<>();\n+        for (int i = 0; i < childrenFieldNames.size(); i++) {\n+          convertedMap.put(childrenFieldNames.get(i),\n+              extractValue(childrenFieldNames.get(i), structColumnVector.fields[i], childrenFieldTypes.get(i), rowId));\n         }\n-      } else if (category == TypeDescription.Category.MAP) {\n-        // Map field\n-        List<TypeDescription> children = fieldType.getChildren();\n-        TypeDescription.Category keyCategory = children.get(0).getCategory();\n-        TypeDescription.Category valueCategory = children.get(1).getCategory();\n-        MapColumnVector mapColumnVector = (MapColumnVector) _rowBatch.cols[i];\n-        int rowId = mapColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((mapColumnVector.noNulls || !mapColumnVector.isNull[rowId])) {\n-          int offset = (int) mapColumnVector.offsets[rowId];\n-          int length = (int) mapColumnVector.lengths[rowId];\n-          Map<Object, Object> map = new HashMap<>();\n-          for (int j = 0; j < length; j++) {\n-            int childRowId = offset + j;\n-            Object key = extractSingleValue(field, mapColumnVector.keys, childRowId, keyCategory);\n-            Object value = extractSingleValue(field, mapColumnVector.values, childRowId, valueCategory);\n-            map.put(key, value);\n+        return convertedMap;\n+      } else {\n+        return null;\n+      }\n+    } else if (category == TypeDescription.Category.LIST) {", "originalCommit": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQyMTkwNA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r504421904", "bodyText": "Resolving since ORC extraction is different from the other extractors.", "author": "timsants", "createdAt": "2020-10-14T06:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDIyNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496310227", "bodyText": "Same here.", "author": "jackjlli", "createdAt": "2020-09-29T00:40:13Z", "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -175,68 +186,102 @@ public GenericRow next(GenericRow reuse)\n       }\n       String field = _orcFields.get(i);\n       TypeDescription fieldType = _orcFieldTypes.get(i);\n-      TypeDescription.Category category = fieldType.getCategory();\n-      if (category == TypeDescription.Category.LIST) {\n-        // Multi-value field, extract to Object[]\n-        TypeDescription.Category childCategory = fieldType.getChildren().get(0).getCategory();\n-        ListColumnVector listColumnVector = (ListColumnVector) _rowBatch.cols[i];\n-        int rowId = listColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n-          int offset = (int) listColumnVector.offsets[rowId];\n-          int length = (int) listColumnVector.lengths[rowId];\n-          List<Object> values = new ArrayList<>(length);\n-          for (int j = 0; j < length; j++) {\n-            Object value = extractSingleValue(field, listColumnVector.child, offset + j, childCategory);\n-            // NOTE: Only keep non-null values\n-            // TODO: Revisit\n-            if (value != null) {\n-              values.add(value);\n-            }\n-          }\n-          if (!values.isEmpty()) {\n-            reuse.putValue(field, values.toArray());\n-          } else {\n-            // NOTE: Treat empty list as null\n-            // TODO: Revisit\n-            reuse.putValue(field, null);\n-          }\n-        } else {\n-          reuse.putValue(field, null);\n+      reuse.putValue(field, extractValue(field, _rowBatch.cols[i], fieldType, _nextRowId));\n+    }\n+\n+    if (++_nextRowId == _rowBatch.size) {\n+      _hasNext = _orcRecordReader.nextBatch(_rowBatch);\n+      _nextRowId = 0;\n+    }\n+    return reuse;\n+  }\n+\n+  /**\n+   * Extracts the values for a given column vector.\n+   *\n+   * @param field name of the field being extracted\n+   * @param columnVector contains values of the field and its sub-types\n+   * @param fieldType information about the field such as the category (STRUCT, LIST, MAP, INT, etc)\n+   * @param rowId the ID of the row value being extracted\n+   * @return extracted row value from the column\n+   */\n+  @Nullable\n+  private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n+    TypeDescription.Category category = fieldType.getCategory();\n+\n+    if (category == TypeDescription.Category.STRUCT) {\n+      StructColumnVector structColumnVector = (StructColumnVector) columnVector;\n+      if (!structColumnVector.isNull[rowId]) {\n+        List<TypeDescription> childrenFieldTypes = fieldType.getChildren();\n+        List<String> childrenFieldNames = fieldType.getFieldNames();\n+\n+        Map<Object, Object> convertedMap = new HashMap<>();\n+        for (int i = 0; i < childrenFieldNames.size(); i++) {\n+          convertedMap.put(childrenFieldNames.get(i),\n+              extractValue(childrenFieldNames.get(i), structColumnVector.fields[i], childrenFieldTypes.get(i), rowId));\n         }\n-      } else if (category == TypeDescription.Category.MAP) {\n-        // Map field\n-        List<TypeDescription> children = fieldType.getChildren();\n-        TypeDescription.Category keyCategory = children.get(0).getCategory();\n-        TypeDescription.Category valueCategory = children.get(1).getCategory();\n-        MapColumnVector mapColumnVector = (MapColumnVector) _rowBatch.cols[i];\n-        int rowId = mapColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((mapColumnVector.noNulls || !mapColumnVector.isNull[rowId])) {\n-          int offset = (int) mapColumnVector.offsets[rowId];\n-          int length = (int) mapColumnVector.lengths[rowId];\n-          Map<Object, Object> map = new HashMap<>();\n-          for (int j = 0; j < length; j++) {\n-            int childRowId = offset + j;\n-            Object key = extractSingleValue(field, mapColumnVector.keys, childRowId, keyCategory);\n-            Object value = extractSingleValue(field, mapColumnVector.values, childRowId, valueCategory);\n-            map.put(key, value);\n+        return convertedMap;\n+      } else {\n+        return null;\n+      }\n+    } else if (category == TypeDescription.Category.LIST) {\n+      TypeDescription childType = fieldType.getChildren().get(0);\n+      ListColumnVector listColumnVector = (ListColumnVector) columnVector;\n+      if (columnVector.isRepeating) {\n+        rowId = 0;\n+      }\n+      if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n+        int offset = (int) listColumnVector.offsets[rowId];\n+        int length = (int) listColumnVector.lengths[rowId];\n+        List<Object> values = new ArrayList<>(length);\n+        for (int j = 0; j < length; j++) {\n+          Object value = extractValue(field, listColumnVector.child, childType,offset + j);\n+          // NOTE: Only keep non-null values\n+          if (value != null) {\n+            values.add(value);\n           }\n-          reuse.putValue(field, map);\n+        }\n+        if (!values.isEmpty()) {\n+          return values.toArray();\n         } else {\n-          reuse.putValue(field, null);\n+          // NOTE: Treat empty list as null\n+          return null;\n         }\n       } else {\n-        // Single-value field\n-        reuse.putValue(field, extractSingleValue(field, _rowBatch.cols[i], _nextRowId, category));\n+        return null;\n       }\n-    }\n+    } else if (category == TypeDescription.Category.MAP) {", "originalCommit": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQyMTkyOA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r504421928", "bodyText": "Resolving since ORC extraction is different from the other extractors.", "author": "timsants", "createdAt": "2020-10-14T06:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDcyNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496310727", "bodyText": "And pls adjust the sequence to make it consistent in all extractors (first check collection, then map, then record, and finally single value).", "author": "jackjlli", "createdAt": "2020-09-29T00:42:06Z", "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -175,68 +186,102 @@ public GenericRow next(GenericRow reuse)\n       }\n       String field = _orcFields.get(i);\n       TypeDescription fieldType = _orcFieldTypes.get(i);\n-      TypeDescription.Category category = fieldType.getCategory();\n-      if (category == TypeDescription.Category.LIST) {\n-        // Multi-value field, extract to Object[]\n-        TypeDescription.Category childCategory = fieldType.getChildren().get(0).getCategory();\n-        ListColumnVector listColumnVector = (ListColumnVector) _rowBatch.cols[i];\n-        int rowId = listColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n-          int offset = (int) listColumnVector.offsets[rowId];\n-          int length = (int) listColumnVector.lengths[rowId];\n-          List<Object> values = new ArrayList<>(length);\n-          for (int j = 0; j < length; j++) {\n-            Object value = extractSingleValue(field, listColumnVector.child, offset + j, childCategory);\n-            // NOTE: Only keep non-null values\n-            // TODO: Revisit\n-            if (value != null) {\n-              values.add(value);\n-            }\n-          }\n-          if (!values.isEmpty()) {\n-            reuse.putValue(field, values.toArray());\n-          } else {\n-            // NOTE: Treat empty list as null\n-            // TODO: Revisit\n-            reuse.putValue(field, null);\n-          }\n-        } else {\n-          reuse.putValue(field, null);\n+      reuse.putValue(field, extractValue(field, _rowBatch.cols[i], fieldType, _nextRowId));\n+    }\n+\n+    if (++_nextRowId == _rowBatch.size) {\n+      _hasNext = _orcRecordReader.nextBatch(_rowBatch);\n+      _nextRowId = 0;\n+    }\n+    return reuse;\n+  }\n+\n+  /**\n+   * Extracts the values for a given column vector.\n+   *\n+   * @param field name of the field being extracted\n+   * @param columnVector contains values of the field and its sub-types\n+   * @param fieldType information about the field such as the category (STRUCT, LIST, MAP, INT, etc)\n+   * @param rowId the ID of the row value being extracted\n+   * @return extracted row value from the column\n+   */\n+  @Nullable\n+  private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n+    TypeDescription.Category category = fieldType.getCategory();\n+\n+    if (category == TypeDescription.Category.STRUCT) {", "originalCommit": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMTQ1Ng==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496311456", "bodyText": "Can we have an extractor for ORC as the other RecordReaders do?", "author": "jackjlli", "createdAt": "2020-09-29T00:45:02Z", "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -72,7 +73,7 @@\n   private int _nextRowId;\n \n   @Override\n-  public void init(File dataFile, Set<String> fieldsToRead, @Nullable RecordReaderConfig recordReaderConfig)\n+  public void init(File dataFile, @Nullable Set<String> fieldsToRead, @Nullable RecordReaderConfig recordReaderConfig)", "originalCommit": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3MDU2Nw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r497970567", "bodyText": "I had the same initial thought and asked Neha the same thing.\nIts because ORC's columnar format doesn't quite fit the RecordExtractor interface. The method GenericRow extract(T from, GenericRow to) expects one record/row to be extracted but the ORC record reader is unique in how it reads rows in batches. In addition, ColumnVectors have an optimization in the case of repeating values in which the first row in the row batch contains the repeating value.", "author": "timsants", "createdAt": "2020-10-01T03:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMTQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMjk2Nw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499902967", "bodyText": "Suggest renaming some methods:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Object convertedValue;\n          \n          \n            \n                if (isInstanceOfMultiValue(value)) {\n          \n          \n            \n                  convertedValue = convertMultiValue(value);\n          \n          \n            \n                } else if (isInstanceOfMap(value)) {\n          \n          \n            \n                  convertedValue = convertMap(value);\n          \n          \n            \n                } else if (isInstanceOfRecord(value)) {\n          \n          \n            \n                  convertedValue = convertRecord(value);\n          \n          \n            \n                } else {\n          \n          \n            \n                  convertedValue = convertSingleValue(value);\n          \n          \n            \n                }\n          \n          \n            \n                return convertedValue;\n          \n          \n            \n                if (isMultiValue(value)) {\n          \n          \n            \n                  return convertMultiValue(value);\n          \n          \n            \n                } else if (isMap(value)) {\n          \n          \n            \n                  return convertMap(value);\n          \n          \n            \n                } else if (isRecord(value)) {\n          \n          \n            \n                  return convertRecord(value);\n          \n          \n            \n                } else {\n          \n          \n            \n                  return convertSingleValue(value);\n          \n          \n            \n                }", "author": "Jackie-Jiang", "createdAt": "2020-10-05T22:18:10Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNTA3Ng==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499905076", "bodyText": "Please double-check the current behavior of handling empty string. I think we should include them into the MV array", "author": "Jackie-Jiang", "createdAt": "2020-10-05T22:24:09Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2NzEwMA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502567100", "bodyText": "I believe this behavior is in line with the current. I checked AvroUtils, JsonRecordExtractorUtils and RecordReaderUtils, and they're all doing this same thing.", "author": "npawar", "createdAt": "2020-10-09T17:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNTA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNTQ1NA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499905454", "bodyText": "Use map.entrySet() to avoid the unnecessary lookups", "author": "Jackie-Jiang", "createdAt": "2020-10-05T22:25:13Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjEzNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499906137", "bodyText": "We don't allow either key or value as null inside the map because we don't allow null inside the MV and map is handled with MV columns", "author": "Jackie-Jiang", "createdAt": "2020-10-05T22:27:15Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {\n+      Object convertedValue = null;\n+      if (key != null) {\n+        convertedValue = convert(map.get(key));\n+      }\n+      convertedMap.put(convertSingleValue(key), convertedValue);", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyNzEwOA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503027108", "bodyText": "Makes sense. I'll add null checks for the map keys and values so that they are not inserted into the map.", "author": "timsants", "createdAt": "2020-10-12T04:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjQwMA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499906400", "bodyText": "Return null for empty map?", "author": "Jackie-Jiang", "createdAt": "2020-10-05T22:28:00Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {\n+      Object convertedValue = null;\n+      if (key != null) {\n+        convertedValue = convert(map.get(key));\n+      }\n+      convertedMap.put(convertSingleValue(key), convertedValue);\n+    }\n+    return convertedMap;", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyNzg0Mg==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503027842", "bodyText": "Yes I'll add that. It will be consistent with the handling of multi-values.", "author": "timsants", "createdAt": "2020-10-12T04:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjY1NQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499906655", "bodyText": "value should never be null here?", "author": "Jackie-Jiang", "createdAt": "2020-10-05T22:28:43Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {\n+      Object convertedValue = null;\n+      if (key != null) {\n+        convertedValue = convert(map.get(key));\n+      }\n+      convertedMap.put(convertSingleValue(key), convertedValue);\n+    }\n+    return convertedMap;\n+  }\n+\n+  /**\n+   * Converts single value types. This should be overridden if the data format requires\n+   * a different conversion for its single values. Returns {@code null} for {@code null} input values.\n+   */\n+  @Nullable\n+  protected Object convertSingleValue(@Nullable Object value) {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyODE3Nw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503028177", "bodyText": "Yes, that is now true with the changes to map conversion.", "author": "timsants", "createdAt": "2020-10-12T04:06:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU4ODgyNQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502588825", "bodyText": "For this method (and similarly all the ones in BaseRecordExtractor), please add a javadoc for value.\nPreviously we used to cast upfront and the param was directly the type (Collection, GenericRecord etc). But now, we are expecting the right type be provided in value, and casting here without any check. So it would be nice to have a description for the value for all the methods of this nature.", "author": "npawar", "createdAt": "2020-10-09T17:56:54Z", "path": "pinot-plugins/pinot-input-format/pinot-avro-base/src/main/java/org/apache/pinot/plugin/inputformat/avro/AvroRecordExtractor.java", "diffHunk": "@@ -49,13 +51,53 @@ public GenericRow extract(GenericRecord from, GenericRow to) {\n       List<Schema.Field> fields = from.getSchema().getFields();\n       for (Schema.Field field : fields) {\n         String fieldName = field.name();\n-        to.putValue(fieldName, AvroUtils.convert(from.get(fieldName)));\n+        Object value = from.get(fieldName);\n+        if (value != null) {\n+          value = convert(value);\n+        }\n+        to.putValue(fieldName, value);\n       }\n     } else {\n       for (String fieldName : _fields) {\n-        to.putValue(fieldName, AvroUtils.convert(from.get(fieldName)));\n+        Object value = from.get(fieldName);\n+        if (value != null) {\n+          value = convert(value);\n+        }\n+        to.putValue(fieldName, value);\n       }\n     }\n     return to;\n   }\n+\n+  /**\n+   * Returns whether the object is an Avro GenericRecord.\n+   */\n+  @Override\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return value instanceof GenericRecord;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the Avro GenericRecord.\n+   */\n+  @Override\n+  @Nullable\n+  protected Object convertRecord(Object value) {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzOTczNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503039737", "bodyText": "That's a good idea. Adding a description to these javadocs.", "author": "timsants", "createdAt": "2020-10-12T05:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU4ODgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5MTc4OQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502591789", "bodyText": "I think you missed removing this code from extract and also calling convert  above in the extract.", "author": "npawar", "createdAt": "2020-10-09T18:03:02Z", "path": "pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordExtractor.java", "diffHunk": "@@ -69,4 +70,32 @@ public GenericRow extract(CSVRecord from, GenericRow to) {\n     }\n     return to;\n   }\n+\n+  @Override\n+  @Nullable\n+  public Object convert(@Nullable Object value) {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyOTg2NQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503029865", "bodyText": "You're right, good catch.", "author": "timsants", "createdAt": "2020-10-12T04:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5MTc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5NTg5MQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502595891", "bodyText": "i see that in CSV case where fieldsToRead is null, we get fields to read in the RecordReader. Versus, in the JSON/AVRO case we used to make that decision inside the RecordExtractor.\nIs it possible to keep these consistent and always let the RecordExtractor make this decision?", "author": "npawar", "createdAt": "2020-10-09T18:11:25Z", "path": "pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordReader.java", "diffHunk": "@@ -95,8 +95,13 @@ public void init(File dataFile, Set<String> fieldsToRead, @Nullable RecordReader\n     _recordExtractor = new CSVRecordExtractor();\n     CSVRecordExtractorConfig recordExtractorConfig = new CSVRecordExtractorConfig();\n     recordExtractorConfig.setMultiValueDelimiter(multiValueDelimiter);\n-    _recordExtractor.init(fieldsToRead, recordExtractorConfig);\n+\n     init();\n+\n+    if (fieldsToRead == null || fieldsToRead.isEmpty()) {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzMTUwMA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503031500", "bodyText": "I had the same thought and was debating whether or not to follow the same pattern as the other extractors. I eventually decided to put the \"read all fields\" in the CSVRecordReader because the field names are accessible only through the CSV header and not in the record object being passed to the extract method.\nThe alternate implementation I was thinking of would require that all the CSV column names would be set in a new variable within CSVRecordExtractorConfig. But if most of the time,fieldsToRead is being set, then there would be a duplicated unused Set of field names that will be sent to the `CSVRecordExtractor.", "author": "timsants", "createdAt": "2020-10-12T04:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5NTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzODgxMA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r504138810", "bodyText": "I prefer the alternate implementation. Reason being, the RecordExtractor is a public API. They could be used in external applications. The external users should not have to know that all except CSVRecordExtractor expect fieldsToRead upfront.", "author": "npawar", "createdAt": "2020-10-13T17:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5NTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQxMTY0OQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r504411649", "bodyText": "After syncing over Slack, we decided to keep the decision to extract all fields within the extractor in case any other client directly calls the extractor.", "author": "timsants", "createdAt": "2020-10-14T05:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5NTg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNDc2Ng==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502624766", "bodyText": "if this is true for all extractor tests now, can we remove this method and just default to testing extractAll?", "author": "npawar", "createdAt": "2020-10-09T19:12:22Z", "path": "pinot-plugins/pinot-input-format/pinot-thrift/src/test/java/org/apache/pinot/plugin/inputformat/thrift/ThriftRecordExtractorTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.inputformat.thrift;\n+\n+import com.google.common.collect.Sets;\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.pinot.spi.data.readers.AbstractRecordExtractorTest;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.apache.thrift.TException;\n+import org.apache.thrift.protocol.TBinaryProtocol;\n+import org.apache.thrift.transport.TIOStreamTransport;\n+\n+\n+/**\n+ * Tests for the {@link ThriftRecordExtractor}\n+ */\n+public class ThriftRecordExtractorTest extends AbstractRecordExtractorTest {\n+\n+  private File _tempFile = new File(_tempDir, \"test_complex_thrift.data\");\n+\n+  private static final String INT_FIELD = \"intField\";\n+  private static final String LONG_FIELD = \"longField\";\n+  private static final String BOOL_FIELD = \"booleanField\";\n+  private static final String DOUBLE_FIELD = \"doubleField\";\n+  private static final String STRING_FIELD = \"stringField\";\n+  private static final String ENUM_FIELD = \"enumField\";\n+  private static final String OPTIONAL_STRING_FIELD = \"optionalStringField\";\n+  private static final String NESTED_STRUCT_FIELD = \"nestedStructField\";\n+  private static final String SIMPLE_LIST = \"simpleListField\";\n+  private static final String COMPLEX_LIST = \"complexListField\";\n+  private static final String SIMPLE_MAP = \"simpleMapField\";\n+  private static final String COMPLEX_MAP = \"complexMapField\";\n+  private static final String NESTED_STRING_FIELD = \"nestedStringField\";\n+  private static final String NESTED_INT_FIELD = \"nestedIntField\";\n+\n+  @Override\n+  protected List<Map<String, Object>> getInputRecords() {\n+    return Arrays.asList(createRecord1(), createRecord2());\n+  }\n+\n+  @Override\n+  protected Set<String> getSourceFields() {\n+    return Sets.newHashSet(INT_FIELD, LONG_FIELD, BOOL_FIELD, DOUBLE_FIELD, STRING_FIELD, ENUM_FIELD,\n+        OPTIONAL_STRING_FIELD, NESTED_STRUCT_FIELD, SIMPLE_LIST, COMPLEX_LIST, SIMPLE_MAP, COMPLEX_MAP);\n+  }\n+\n+  /**\n+   * Creates a ThriftRecordReader\n+   */\n+  @Override\n+  protected RecordReader createRecordReader(Set<String> fieldsToRead)\n+      throws IOException {\n+    ThriftRecordReader recordReader = new ThriftRecordReader();\n+    recordReader.init(_tempFile, getSourceFields(), getThriftRecordReaderConfig());\n+    return recordReader;\n+  }\n+\n+  private ThriftRecordReaderConfig getThriftRecordReaderConfig() {\n+    ThriftRecordReaderConfig config = new ThriftRecordReaderConfig();\n+    config.setThriftClass(\"org.apache.pinot.plugin.inputformat.thrift.ComplexTypes\");\n+    return config;\n+  }\n+\n+  /**\n+   * Create a data input file using input records containing various Thrift record types\n+   */\n+  @Override\n+  protected void createInputFile()\n+      throws IOException {\n+    List<ComplexTypes> thriftRecords = new ArrayList<>(2);\n+\n+    for (Map<String, Object> inputRecord : _inputRecords) {\n+      ComplexTypes thriftRecord = new ComplexTypes();\n+      thriftRecord.setIntField((int) inputRecord.get(INT_FIELD));\n+      thriftRecord.setLongField((long) inputRecord.get(LONG_FIELD));\n+\n+      Map<String, Object> nestedStructValues = (Map<String, Object>) inputRecord.get(NESTED_STRUCT_FIELD);\n+      thriftRecord.setNestedStructField(createNestedType(\n+          (String) nestedStructValues.get(NESTED_STRING_FIELD),\n+          (int) nestedStructValues.get(NESTED_INT_FIELD))\n+      );\n+\n+      thriftRecord.setSimpleListField((List<String>) inputRecord.get(SIMPLE_LIST));\n+\n+      List<NestedType> nestedTypeList = new ArrayList<>();\n+      for (Map element : (List<Map>) inputRecord.get(COMPLEX_LIST)) {\n+        nestedTypeList.add(createNestedType((String) element.get(NESTED_STRING_FIELD),\n+            (Integer) element.get(NESTED_INT_FIELD)));\n+      }\n+\n+      thriftRecord.setComplexListField(nestedTypeList);\n+      thriftRecord.setBooleanField(Boolean.valueOf((String) inputRecord.get(BOOL_FIELD)));\n+      thriftRecord.setDoubleField((Double) inputRecord.get(DOUBLE_FIELD));\n+      thriftRecord.setStringField((String) inputRecord.get(STRING_FIELD));\n+      thriftRecord.setEnumField(TestEnum.valueOf((String) inputRecord.get(ENUM_FIELD)));\n+      thriftRecord.setSimpleMapField((Map<String, Integer>) inputRecord.get(SIMPLE_MAP));\n+\n+      Map<String, NestedType> complexMap = new HashMap<>();\n+      for (Map.Entry<String, Map<String, Object>> entry :\n+          ((Map<String, Map<String, Object>>) inputRecord.get(COMPLEX_MAP)).entrySet()) {\n+        complexMap.put(entry.getKey(), createNestedType(\n+            (String) entry.getValue().get(NESTED_STRING_FIELD),\n+            (int) entry.getValue().get(NESTED_INT_FIELD)));\n+      }\n+      thriftRecord.setComplexMapField(complexMap);\n+      thriftRecords.add(thriftRecord);\n+    }\n+\n+    BufferedOutputStream bufferedOut = new BufferedOutputStream(new FileOutputStream(_tempFile));\n+    TBinaryProtocol binaryOut = new TBinaryProtocol(new TIOStreamTransport(bufferedOut));\n+    for (ComplexTypes record : thriftRecords) {\n+      try {\n+        record.write(binaryOut);\n+      } catch (TException e) {\n+        throw new IOException(e);\n+      }\n+    }\n+    bufferedOut.close();\n+  }\n+\n+  private Map<String, Object> createRecord1() {\n+    Map<String, Object> record = new HashMap<>();\n+    record.put(STRING_FIELD, \"hello\");\n+    record.put(INT_FIELD, 10);\n+    record.put(LONG_FIELD, 1000L);\n+    record.put(DOUBLE_FIELD, 1.0);\n+    record.put(BOOL_FIELD, \"false\");\n+    record.put(ENUM_FIELD, TestEnum.DELTA.toString());\n+    record.put(NESTED_STRUCT_FIELD, createNestedMap(NESTED_STRING_FIELD, \"ice cream\", NESTED_INT_FIELD, 5));\n+    record.put(SIMPLE_LIST, Arrays.asList(\"aaa\", \"bbb\", \"ccc\"));\n+    record.put(COMPLEX_LIST,\n+        Arrays.asList(\n+            createNestedMap(NESTED_STRING_FIELD, \"hows\", NESTED_INT_FIELD, 10),\n+            createNestedMap(NESTED_STRING_FIELD, \"it\", NESTED_INT_FIELD, 20),\n+            createNestedMap(NESTED_STRING_FIELD, \"going\", NESTED_INT_FIELD, 30)\n+        )\n+    );\n+    record.put(SIMPLE_MAP, createNestedMap(\"Tuesday\", 3, \"Wednesday\", 4));\n+    record.put(\n+        COMPLEX_MAP,\n+        createNestedMap(\n+            \"fruit1\", createNestedMap(NESTED_STRING_FIELD, \"apple\", NESTED_INT_FIELD, 1),\n+            \"fruit2\", createNestedMap(NESTED_STRING_FIELD, \"orange\", NESTED_INT_FIELD, 2)\n+        )\n+    );\n+    return record;\n+  }\n+\n+  private Map<String, Object> createRecord2() {\n+    Map<String, Object> record = new HashMap<>();\n+    record.put(STRING_FIELD, \"world\");\n+    record.put(INT_FIELD, 20);\n+    record.put(LONG_FIELD, 2000L);\n+    record.put(DOUBLE_FIELD, 2.0);\n+    record.put(BOOL_FIELD, \"false\");\n+    record.put(ENUM_FIELD, TestEnum.GAMMA.toString());\n+    record.put(NESTED_STRUCT_FIELD, createNestedMap(NESTED_STRING_FIELD, \"ice cream\", NESTED_INT_FIELD, 5));\n+    record.put(SIMPLE_LIST, Arrays.asList(\"aaa\", \"bbb\", \"ccc\"));\n+    record.put(COMPLEX_LIST,\n+        Arrays.asList(\n+            createNestedMap(NESTED_STRING_FIELD, \"hows\", NESTED_INT_FIELD, 10),\n+            createNestedMap(NESTED_STRING_FIELD, \"it\", NESTED_INT_FIELD, 20),\n+            createNestedMap(NESTED_STRING_FIELD, \"going\", NESTED_INT_FIELD, 30)\n+        )\n+    );\n+    record.put(SIMPLE_MAP, createNestedMap(\"Tuesday\", 3, \"Wednesday\", 4));\n+    record.put(\n+        COMPLEX_MAP,\n+        createNestedMap(\n+            \"fruit1\", createNestedMap(NESTED_STRING_FIELD, \"apple\", NESTED_INT_FIELD, 1),\n+            \"fruit2\", createNestedMap(NESTED_STRING_FIELD, \"orange\", NESTED_INT_FIELD, 2)\n+        )\n+    );\n+    return record;\n+  }\n+\n+  private Map<String, Object> createNestedMap(String key1, Object value1, String key2, Object value2) {\n+    Map<String, Object> nestedMap = new HashMap<>(2);\n+    nestedMap.put(key1, value1);\n+    nestedMap.put(key2, value2);\n+    return nestedMap;\n+  }\n+\n+  private NestedType createNestedType(String stringField, int intField) {\n+    NestedType nestedRecord = new NestedType();\n+    nestedRecord.setNestedStringField(stringField);\n+    nestedRecord.setNestedIntField(intField);\n+    return nestedRecord;\n+  }\n+\n+  @Override\n+  protected boolean testExtractAll() {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzNDAyOA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503034028", "bodyText": "Good call. We can remove this method now and testing the extract all code path will be part of all the tests.", "author": "timsants", "createdAt": "2020-10-12T04:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNDc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNjExNA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502626114", "bodyText": "I didn't follow this change, could you explain what's happening here?", "author": "npawar", "createdAt": "2020-10-09T19:15:34Z", "path": "pinot-plugins/pinot-input-format/pinot-thrift/src/main/java/org/apache/pinot/plugin/inputformat/thrift/ThriftRecordReader.java", "diffHunk": "@@ -61,12 +62,13 @@ public void init(File dataFile, Set<String> fieldsToRead, @Nullable RecordReader\n     } catch (Exception e) {\n       throw new RuntimeException(e);\n     }\n-    int index = 1;\n-    TFieldIdEnum tFieldIdEnum;\n-    while ((tFieldIdEnum = tObject.fieldForId(index)) != null) {\n-      _fieldIds.put(tFieldIdEnum.getFieldName(), index);\n-      index++;\n+", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzNTEwNg==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503035106", "bodyText": "As discussed over Slack, there was a bug in how we were parsing Thrift fields. Thrift field IDs are not guaranteed to be consecutive, which was previous assumed. If a Thrift record did not have consecutive field IDs, the extractor would break/incorrectly extract values.", "author": "timsants", "createdAt": "2020-10-12T04:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNjExNA=="}], "type": "inlineReview"}, {"oid": "6f17705d48d5dc1fade270134fd77c611c5c5343", "url": "https://github.com/apache/pinot/commit/6f17705d48d5dc1fade270134fd77c611c5c5343", "message": "Deep Extraction Support for ORC, Thrift, and ProtoBuf Records\n\n1. PR for issue #5507. ORC, Thrift, and ProtoBuf readers now convert:\n  - Nested structures to Map\n  - Collection to Object[]\n  - Number/String/bytebuffer to single value\n2. All extractors now support extracting all fields if fieldsToRead is null/empty (issue #5677). This support was\n   added to ORCRecordExtractor, ThriftRecordExtractor, ProtoBufRecordExtractor, and CSVRecordRecord.\n3. Extractor Util Cleanup:\n     There were duplicate implementations for extractors converters across RecordReaderUtils, JsonRecordExtractorUtils,\n     and AvroUtils. This PR adds a new method, \u201cObject convert(Object value)\u201d, to the RecordExtractor interface, as\n     this is a method that all extractors should implement to convert each field of the file format. A new abstract\n     class was created that extends RecordExtractor to contain the repeated logic across RecordReaderUtils,\n     JsonRecordExtractorUtils, and AvroUtils. The abstract class also defines the common methods for recursively\n     handling maps, collections, records and single values.", "committedDate": "2020-10-12T05:13:50Z", "type": "commit"}, {"oid": "d2c4a779e71e3d63d0bb18acf98b4ee5f730d3d0", "url": "https://github.com/apache/pinot/commit/d2c4a779e71e3d63d0bb18acf98b4ee5f730d3d0", "message": "Removed javax annotation from Thrift autogenerated Java files to be complaint with JDK11", "committedDate": "2020-10-12T05:13:50Z", "type": "commit"}, {"oid": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "url": "https://github.com/apache/pinot/commit/e1b352eb9c72d7cc9780e9953a13cb2db2248604", "message": "Changed name of AbstractDefaultRecordExtractor -> BaseRecordExtractor. Also removed unecessary generic type added to RecordExtractor.", "committedDate": "2020-10-12T05:13:50Z", "type": "commit"}, {"oid": "afa97cf21dafd8d3ea1136b4de85ed27271b7ec1", "url": "https://github.com/apache/pinot/commit/afa97cf21dafd8d3ea1136b4de85ed27271b7ec1", "message": "Removing the use of lambda expressions when extracting all fields", "committedDate": "2020-10-12T05:13:51Z", "type": "commit"}, {"oid": "522005d39776d495a3427d60134bfde442c3c11a", "url": "https://github.com/apache/pinot/commit/522005d39776d495a3427d60134bfde442c3c11a", "message": "Checking for null values before calling extractor convert. Also re-ordering the sequence of checks to be collection -> map -> record -> single-value in ORCRecordReader to be consistent with the other extractors.", "committedDate": "2020-10-12T05:13:51Z", "type": "commit"}, {"oid": "de8ad5e223e40aedec88ab8eab3a955e949c0b2e", "url": "https://github.com/apache/pinot/commit/de8ad5e223e40aedec88ab8eab3a955e949c0b2e", "message": "Made handling of null map keys/values consistent with multi-value. Added documentation for the value passed to the map, multivalue, and record converters.", "committedDate": "2020-10-12T05:13:52Z", "type": "commit"}, {"oid": "f528abdce161366cdc728e4032f2277463d26e14", "url": "https://github.com/apache/pinot/commit/f528abdce161366cdc728e4032f2277463d26e14", "message": "Move read all fields responsibility from CSVRecordReader to CSVRecordExtractor. Also making CSVRecordExtractor extend BaseRecordExtractor", "committedDate": "2020-10-14T06:00:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkxODYyOQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r505918629", "bodyText": "Shall we add some comments here about the behavior of the empty string?", "author": "Jackie-Jiang", "createdAt": "2020-10-15T23:22:56Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   *\n+   * @param value should be verified to be a record type prior to calling this method as it will be handled with this\n+   *              assumption\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   *\n+   * @param value should be verified to be a Collection type prior to calling this method as it will be casted\n+   *              to a Collection without checking\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {", "originalCommit": "f528abdce161366cdc728e4032f2277463d26e14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA0NjYzNQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r506046635", "bodyText": "I'll mention this nuance in the method's javadoc.", "author": "timsants", "createdAt": "2020-10-16T04:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkxODYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMDMxOQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r505920319", "bodyText": "We should also preserve byte[]\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (value instanceof Number) {\n          \n          \n            \n                if (value instanceof Number || value instanceof byte[]) {", "author": "Jackie-Jiang", "createdAt": "2020-10-15T23:28:26Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   *\n+   * @param value should be verified to be a record type prior to calling this method as it will be handled with this\n+   *              assumption\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   *\n+   * @param value should be verified to be a Collection type prior to calling this method as it will be casted\n+   *              to a Collection without checking\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   *\n+   * @param value should be verified to be a Map type prior to calling this method as it will be casted to a Map\n+   *              without checking\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map<Object, Object> map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Map.Entry<Object, Object> entry : map.entrySet()) {\n+      Object mapKey = entry.getKey();\n+      Object mapValue = entry.getValue();\n+      if (mapKey != null) {\n+        Object convertedMapValue = null;\n+        if (mapValue != null) {\n+          convertedMapValue = convert(mapValue);\n+        }\n+\n+        if (convertedMapValue != null) {\n+          convertedMap.put(convertSingleValue(entry.getKey()), convertedMapValue);\n+        }\n+      }\n+    }\n+\n+    if (convertedMap.isEmpty()) {\n+      return null;\n+    }\n+\n+    return convertedMap;\n+  }\n+\n+  /**\n+   * Converts single value types. This should be overridden if the data format requires\n+   * a different conversion for its single values.\n+   */\n+  protected Object convertSingleValue(Object value) {\n+    if (value instanceof ByteBuffer) {\n+      ByteBuffer byteBufferValue = (ByteBuffer) value;\n+\n+      // Use byteBufferValue.remaining() instead of byteBufferValue.capacity() so that it still works when buffer is\n+      // over-sized\n+      byte[] bytesValue = new byte[byteBufferValue.remaining()];\n+      byteBufferValue.get(bytesValue);\n+      return bytesValue;\n+    }\n+    if (value instanceof Number) {", "originalCommit": "f528abdce161366cdc728e4032f2277463d26e14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA0NTgxNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r506045817", "bodyText": "Yea that makes sense given that bytebuffer is converted to byte[].", "author": "timsants", "createdAt": "2020-10-16T04:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMDMxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA1MjM1MQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r506052351", "bodyText": "I'll make this change although I don't see any data formats that use this method returning byte[].", "author": "timsants", "createdAt": "2020-10-16T04:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMDMxOQ=="}], "type": "inlineReview"}, {"oid": "bd6618924809944ed92619fccef230ab1967c439", "url": "https://github.com/apache/pinot/commit/bd6618924809944ed92619fccef230ab1967c439", "message": "Adding comment for how empty string is handled for multivalues. Also preserving byte[] in single value conversion.", "committedDate": "2020-10-16T05:01:22Z", "type": "commit"}]}