{"pr_number": 6383, "pr_title": "Introduce 'LOOKUP' Transform Function", "pr_createdAt": "2020-12-25T00:07:53Z", "pr_url": "https://github.com/apache/pinot/pull/6383", "timeline": [{"oid": "fec8d8101b4c419821212bd5b2a19ca93d1e24fb", "url": "https://github.com/apache/pinot/commit/fec8d8101b4c419821212bd5b2a19ca93d1e24fb", "message": "Add 'lookUp' transform function", "committedDate": "2020-12-24T03:35:43Z", "type": "commit"}, {"oid": "1b141d893f73695b6363a12b3efdf2c93ca96ee5", "url": "https://github.com/apache/pinot/commit/1b141d893f73695b6363a12b3efdf2c93ca96ee5", "message": "Add sample lookup query to join quickstart", "committedDate": "2020-12-24T03:52:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMTg4MQ==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r548921881", "bodyText": "Do we need to assume a dim table is always an offline table?", "author": "xiangfu0", "createdAt": "2020-12-25T23:30:03Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";", "originalCommit": "1b141d893f73695b6363a12b3efdf2c93ca96ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3Nzg0OA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549177848", "bodyText": "Hi Xiang, yes you're right. In current design Dimension Table has the following constraints:\n\nMust be of OFFLINE type\nMust have a primary key (we support lookups by primary key for now)\nMust have ingestion type REFRESH\n\nPlease check out #6286 and #6346 to see implementation details.", "author": "cbalci", "createdAt": "2020-12-27T23:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMTg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMTk2MA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r548921960", "bodyText": "Can you update it with an ANSI SQL query here?\nE.g.\nSELECT baseballstats.playername,\n       baseballstats.teamid,\n       baseballteams.teamname\nFROM   baseballstats\n       JOIN baseballteams\n         ON baseballteams.teamid = baseballstats.teamid\nLIMIT  10", "author": "xiangfu0", "createdAt": "2020-12-25T23:32:05Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.", "originalCommit": "1b141d893f73695b6363a12b3efdf2c93ca96ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE4NjMzOA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549186338", "bodyText": "Updated.", "author": "cbalci", "createdAt": "2020-12-28T01:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMTk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMjQyMw==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r548922423", "bodyText": "format: identation.", "author": "xiangfu0", "createdAt": "2020-12-25T23:38:01Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {", "originalCommit": "1b141d893f73695b6363a12b3efdf2c93ca96ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE4NjM0Nw==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549186347", "bodyText": "Done.", "author": "cbalci", "createdAt": "2020-12-28T01:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODkyMjQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE1Mzg0Mw==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549153843", "bodyText": "takes", "author": "yupeng9", "createdAt": "2020-12-27T19:16:32Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:", "originalCommit": "1b141d893f73695b6363a12b3efdf2c93ca96ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE4NjM1NA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549186354", "bodyText": "Done.", "author": "cbalci", "createdAt": "2020-12-28T01:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE1Mzg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDE4Nw==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549174187", "bodyText": "also check that all the primary keys are provided.", "author": "yupeng9", "createdAt": "2020-12-27T23:02:54Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {\n+            TransformFunction dimJoinKeyFunction = joinArguments.get((i*2));\n+            Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+                \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+            _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+            TransformFunction factJoinValueFunction = joinArguments.get((i*2)+1);\n+            TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+            Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+                \"JoinValue argument must be a single value expression\");\n+            _joinValueFunctions.add(factJoinValueFunction);\n+        }\n+\n+        // Validate lookup table and relevant columns\n+        _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+        Preconditions.checkArgument(_dataManager != null,\n+                String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+        _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+        Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+                String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+        for (String joinKey: _joinKeys) {\n+            FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+            Preconditions.checkArgument(pkColumnSpec != null,", "originalCommit": "1b141d893f73695b6363a12b3efdf2c93ca96ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE5NDE4Ng==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549194186", "bodyText": "I'm assuming you are referring to the validation of the joinValue argument below.\nLOOKUP(tableName, columnName, joinKey, joinValue)\n\nUnlike the first three arguments, joinValue isn't a 'literal', so its value is only resolved when we get a projection block. So rather than validating at initialization stage, we check its existence in transformTo...Values methods, on a row by row basis.\nFor instance, take the sample query:\nSELECT\n    baseballStats.playerName,\n    baseballStats.teamID,\n    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\nFROM\n    baseballStats\nLIMIT 10\nWe can validate the first three arguments of the LOOKUP function without reading data from baseballStats. However the last argument is only available once we start reading table contents.\nHope this makes sense, and please let me know if I missed something.", "author": "cbalci", "createdAt": "2020-12-28T02:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTIzNjk0OQ==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549236949", "bodyText": "I meant checking the join keys are the same as the primary keys defined on a table. Assume a table has 2 columns of the primary key, then this lookup function shall take two join keys too, to ensure the same cardinality in the output.", "author": "yupeng9", "createdAt": "2020-12-28T06:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzNDI3MQ==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549534271", "bodyText": "Got it, this makes more sense. Just updated the validation logic to assert the provided key list is equal to primary key columns. Thanks for the suggestion.", "author": "cbalci", "createdAt": "2020-12-29T01:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDQzOA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549174438", "bodyText": "how about byte?", "author": "yupeng9", "createdAt": "2020-12-27T23:05:41Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+/**\n+ * LOOKUP function take 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] is supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code select playerName, teamID, lookup('baseballTeams', 'teamName', 'teamID', teamID) from baseballStats limit 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+    public static final String FUNCTION_NAME = \"lookUp\";\n+    private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+    // Lookup parameters\n+    private String _dimTableName;\n+    private String _dimColumnName;\n+    private final List<String> _joinKeys = new ArrayList<>();\n+    private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+    private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+    private DimensionTableDataManager _dataManager;\n+    private FieldSpec _lookupColumnFieldSpec;\n+\n+    @Override\n+    public String getName() {\n+        return FUNCTION_NAME;\n+    }\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        // Check that there are correct number of arguments\n+        Preconditions.checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function\");\n+        Preconditions.checkArgument(arguments.size() % 2 == 0,\n+            \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+        TransformFunction dimTableNameFunction = arguments.get(0);\n+        Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+            \"First argument must be a literal(string) representing the dimension table name\");\n+        _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+        TransformFunction dimColumnFunction = arguments.get(1);\n+        Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+            \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+        _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+        List<TransformFunction> joinArguments = arguments.subList(2,arguments.size());\n+        for (int i=0; i<joinArguments.size()/2; i++) {\n+            TransformFunction dimJoinKeyFunction = joinArguments.get((i*2));\n+            Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+                \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+            _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+            TransformFunction factJoinValueFunction = joinArguments.get((i*2)+1);\n+            TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+            Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+                \"JoinValue argument must be a single value expression\");\n+            _joinValueFunctions.add(factJoinValueFunction);\n+        }\n+\n+        // Validate lookup table and relevant columns\n+        _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+        Preconditions.checkArgument(_dataManager != null,\n+                String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+        _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+        Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+                String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+        for (String joinKey: _joinKeys) {\n+            FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+            Preconditions.checkArgument(pkColumnSpec != null,\n+                    String.format(\"Primary key column doesn't exist in dimension table: %s:%s\",_dimTableName, joinKey));\n+            _joinValueFieldSpecs.add(pkColumnSpec);\n+        }\n+    }\n+\n+    @Override\n+    public TransformResultMetadata getResultMetadata() {\n+        return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+            _lookupColumnFieldSpec.isSingleValueField(),\n+            false);\n+    }\n+\n+    private Object[] lookup(ProjectionBlock projectionBlock) {\n+        int numPkColumns = _joinKeys.size();\n+        int numDocuments = projectionBlock.getNumDocs();\n+        Object[][] pkColumns = new Object[numPkColumns][];\n+        for (int i=0; i<numPkColumns; i++) {\n+            FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+            TransformFunction tf = _joinValueFunctions.get(i);\n+            switch (colType) {\n+                case STRING:\n+                    pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+                    break;\n+                case INT:\n+                    pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+                    break;\n+                case LONG:\n+                    pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown column type for primary key\");", "originalCommit": "1b141d893f73695b6363a12b3efdf2c93ca96ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUwNTA0MA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549505040", "bodyText": "Updated to support all types: INT, LONG, FLOAT, DOUBLE, STRING, BYTES", "author": "cbalci", "createdAt": "2020-12-28T22:23:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyODUzMg==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549528532", "bodyText": "fyi, double is hard to check equality.", "author": "yupeng9", "createdAt": "2020-12-29T00:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzOTg1Mw==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549539853", "bodyText": "For lookupByPrimaryKey we are relying on the PrimaryKey.hashCode implementation you added here. Here is the dimension table HashMap which is keyed by 'PrimaryKey's. Let me know if you see any potential issues with this usage.", "author": "cbalci", "createdAt": "2020-12-29T01:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3NDQzOA=="}], "type": "inlineReview"}, {"oid": "345b1f77307724ae20d685650efcfc9c498bca4d", "url": "https://github.com/apache/pinot/commit/345b1f77307724ae20d685650efcfc9c498bca4d", "message": "Fix formatting and whitespace", "committedDate": "2020-12-28T01:24:19Z", "type": "commit"}, {"oid": "fc5a0ee3d64889303470b814f0b9b3ace2541a10", "url": "https://github.com/apache/pinot/commit/fc5a0ee3d64889303470b814f0b9b3ace2541a10", "message": "Small fix.", "committedDate": "2020-12-28T02:42:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDE0OA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549454148", "bodyText": "List the expected arguments in the message", "author": "Jackie-Jiang", "createdAt": "2020-12-28T19:00:45Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");", "originalCommit": "fc5a0ee3d64889303470b814f0b9b3ace2541a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMzk2Mg==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549533962", "bodyText": "Added.", "author": "cbalci", "createdAt": "2020-12-29T01:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDU1Ng==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549454556", "bodyText": "Handle table name with suffix\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n          \n          \n            \n                _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(((LiteralTransformFunction) dimTableNameFunction).getLiteral());", "author": "Jackie-Jiang", "createdAt": "2020-12-28T19:02:21Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();", "originalCommit": "fc5a0ee3d64889303470b814f0b9b3ace2541a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMzk0OQ==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549533949", "bodyText": "Thanks for the suggestion, added.", "author": "cbalci", "createdAt": "2020-12-29T01:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDYyOA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549454628", "bodyText": "Use TableNameBuilder instead", "author": "Jackie-Jiang", "createdAt": "2020-12-28T19:02:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";", "originalCommit": "fc5a0ee3d64889303470b814f0b9b3ace2541a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMzkzOA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549533938", "bodyText": "Done.", "author": "cbalci", "createdAt": "2020-12-29T01:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDkxMw==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549454913", "bodyText": "(nit) extract joinArguments.size() as a local variable", "author": "Jackie-Jiang", "createdAt": "2020-12-28T19:03:42Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {", "originalCommit": "fc5a0ee3d64889303470b814f0b9b3ace2541a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMzkyNA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549533924", "bodyText": "It is not really reused anywhere else. Let me know if you have a specific reason to extract.", "author": "cbalci", "createdAt": "2020-12-29T01:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Nzc4NQ==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549547785", "bodyText": "The for loop will keep calling joinArguments.size() for each iteration", "author": "Jackie-Jiang", "createdAt": "2020-12-29T02:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU3NjUyMQ==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549576521", "bodyText": ":) Alright, extracted.", "author": "cbalci", "createdAt": "2020-12-29T05:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NDkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MjIzMg==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549482232", "bodyText": "Please support all data types (usually we order them as followings: INT, LONG, FLOAT, DOUBLE, STRING, BYTES)", "author": "Jackie-Jiang", "createdAt": "2020-12-28T20:47:03Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+    Preconditions\n+        .checkArgument(_dataManager != null, String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {", "originalCommit": "fc5a0ee3d64889303470b814f0b9b3ace2541a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUwNTE2OA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549505168", "bodyText": "Updated to support all types", "author": "cbalci", "createdAt": "2020-12-28T22:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MjIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MjgwNQ==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549482805", "bodyText": "Need to check null, same for other places", "author": "Jackie-Jiang", "createdAt": "2020-12-28T20:49:35Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+    Preconditions\n+        .checkArgument(_dataManager != null, String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];\n+      for (int j = 0; j < numPkColumns; j++) {\n+        pkValues[j] = pkColumns[j][i];\n+      }\n+      // lookup\n+      GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));\n+      if (row != null && row.getFieldToValueMap().containsKey(_dimColumnName)) {\n+        resultSet[i] = row.getValue(_dimColumnName);\n+      }\n+    }\n+    return resultSet;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    Object[] lookupObjects = lookup(projectionBlock);\n+    int[] resultSet = new int[lookupObjects.length];\n+    Arrays.fill(resultSet, ((Number) _lookupColumnFieldSpec.getDefaultNullValue()).intValue());\n+    for (int i = 0; i < lookupObjects.length; i++) {\n+      resultSet[i] = ((Number) lookupObjects[i]).intValue();", "originalCommit": "fc5a0ee3d64889303470b814f0b9b3ace2541a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMzkwMQ==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549533901", "bodyText": "Great catch, thanks! Updated.", "author": "cbalci", "createdAt": "2020-12-29T01:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MjgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MzIwNA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549483204", "bodyText": "We can save one map lookup\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (row != null && row.getFieldToValueMap().containsKey(_dimColumnName)) {\n          \n          \n            \n                    resultSet[i] = row.getValue(_dimColumnName);\n          \n          \n            \n                  }\n          \n          \n            \n                  if (row != null) {\n          \n          \n            \n                    resultSet[i] = row.getValue(_dimColumnName);\n          \n          \n            \n                  }", "author": "Jackie-Jiang", "createdAt": "2020-12-28T20:51:29Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+  private static final String TABLE_NAME_SUFFIX = \"_OFFLINE\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4, \"At least 4 arguments are required for LOOKUP transform function\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = ((LiteralTransformFunction) dimTableNameFunction).getLiteral();\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    for (int i = 0; i < joinArguments.size() / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName + TABLE_NAME_SUFFIX);\n+    Preconditions\n+        .checkArgument(_dataManager != null, String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];\n+      for (int j = 0; j < numPkColumns; j++) {\n+        pkValues[j] = pkColumns[j][i];\n+      }\n+      // lookup\n+      GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));\n+      if (row != null && row.getFieldToValueMap().containsKey(_dimColumnName)) {\n+        resultSet[i] = row.getValue(_dimColumnName);\n+      }", "originalCommit": "fc5a0ee3d64889303470b814f0b9b3ace2541a10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzMzg3OA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549533878", "bodyText": "Right, looks like a useless check. Removed.", "author": "cbalci", "createdAt": "2020-12-29T01:11:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4MzIwNA=="}], "type": "inlineReview"}, {"oid": "cee23d70630c40a2f0efd9afd65ff999dea3f7c7", "url": "https://github.com/apache/pinot/commit/cee23d70630c40a2f0efd9afd65ff999dea3f7c7", "message": "Support all possible PK types", "committedDate": "2020-12-28T22:22:47Z", "type": "commit"}, {"oid": "91b635c4443e32631cd46c2274ff454fc55e9f48", "url": "https://github.com/apache/pinot/commit/91b635c4443e32631cd46c2274ff454fc55e9f48", "message": "Address review comments.", "committedDate": "2020-12-29T01:11:04Z", "type": "commit"}, {"oid": "1bc88ca3b4c97d263c1756c3fc45c59471e26433", "url": "https://github.com/apache/pinot/commit/1bc88ca3b4c97d263c1756c3fc45c59471e26433", "message": "Small fix", "committedDate": "2020-12-29T05:44:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzMTkwMw==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549831903", "bodyText": "(nit) no need to make a copy of the array (save the garbage). We don't usually guard the callers from modifying the list as it is internal code.", "author": "Jackie-Jiang", "createdAt": "2020-12-29T20:07:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/offline/DimensionTableDataManager.java", "diffHunk": "@@ -161,4 +168,8 @@ public GenericRow lookupRowByPrimaryKey(PrimaryKey pk) {\n   public FieldSpec getColumnFieldSpec(String columnName) {\n     return _tableSchema.getFieldSpecFor(columnName);\n   }\n+\n+  public List<String> getPrimaryKeyColumns() {\n+    return new ArrayList<>(_primaryKeyColumns);", "originalCommit": "1bc88ca3b4c97d263c1756c3fc45c59471e26433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4ODI5OA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549888298", "bodyText": "Removed.", "author": "cbalci", "createdAt": "2020-12-29T23:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzMTkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzMjU4NQ==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549832585", "bodyText": "No need to format string as Preconditions supports %s, same for other places", "author": "Jackie-Jiang", "createdAt": "2020-12-29T20:10:10Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));", "originalCommit": "1bc88ca3b4c97d263c1756c3fc45c59471e26433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4ODMwNg==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549888306", "bodyText": "Oh I didn't know about that, thanks for the tip. Updated.", "author": "cbalci", "createdAt": "2020-12-29T23:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzMjU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjIyNw==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549836227", "bodyText": "(nit) move STRING after DOUBLE for consistency", "author": "Jackie-Jiang", "createdAt": "2020-12-29T20:24:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:", "originalCommit": "1bc88ca3b4c97d263c1756c3fc45c59471e26433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4ODMxNw==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549888317", "bodyText": "Moved.", "author": "cbalci", "createdAt": "2020-12-29T23:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjQ1Nw==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549836457", "bodyText": "pkColumns should be stored as ByteArray[numDocuments]. Please add a test for all these data types to ensure them working", "author": "Jackie-Jiang", "createdAt": "2020-12-29T20:25:33Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];", "originalCommit": "1bc88ca3b4c97d263c1756c3fc45c59471e26433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4ODM0Ng==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549888346", "bodyText": "Double checked and can't see how this is wrong. What we are doing here is translating the output of the transform function from type byte[numDocuments][] to Byte[numDocuments][] so it can be passed back as Object[]. Second [] is indicating that we simply have 'byte arrays' for each row/entry. I'm updating the loop index variable name to make it a bit more clear.\nWe already have test coverage for this behavior here (as well as other types).\nLet me know if I missed something.", "author": "cbalci", "createdAt": "2020-12-29T23:40:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5MjAxNg==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549892016", "bodyText": "The equals() in PrimaryKey won't do deep comparison for array, and Byte[] won't be compared correctly (it will only compare the references). We use ByteArray as a wrapper to bypass this problem. It is used to store byte[] internally", "author": "Jackie-Jiang", "createdAt": "2020-12-30T00:01:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkxMjQ3NA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549912474", "bodyText": "Oh, I see what you mean, great catch. Looks like the reason unit tests didn't catch this was, I was mocking the lookupRowByPrimaryKey to match byte array type PKs by their string representation \ud83e\udd26. Fixed it and revamped all the test cases to match only by the 'hashCode' of the PK instance. Thanks \ud83d\udc4d", "author": "cbalci", "createdAt": "2020-12-30T02:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNjQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzAxMw==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549837013", "bodyText": "Reuse this Object[] instead of creating a new one per iteration", "author": "Jackie-Jiang", "createdAt": "2020-12-29T20:27:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];\n+          for (int n = 0; n < numDocuments; n++) {\n+            pkColumns[i][n] = ArrayUtils.toObject(primitiveValues[n]);\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];", "originalCommit": "1bc88ca3b4c97d263c1756c3fc45c59471e26433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4ODM2Ng==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549888366", "bodyText": "I can do something like:\n  Object[] resultSet = new Object[numDocuments];\n  Object[] pkValues = new Object[numPkColumns];\n  for (int i = 0; i < numDocuments; i++) {\n    // prepare pk\n    for (int j = 0; j < numPkColumns; j++) {\n      pkValues[j] = pkColumns[j][i];\n    }\n    // lookup\n    GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));\n    if (row != null) {\n      resultSet[i] = row.getValue(_dimColumnName);\n    }\n  }\nI don't see much point in doing the same for PrimaryKey though. We will only be reusing the pointer which is not really helpful.", "author": "cbalci", "createdAt": "2020-12-29T23:40:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5MjI5Nw==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549892297", "bodyText": "It will reuse the object instead of creating one per doc:\n  Object[] resultSet = new Object[numDocuments];\n  Object[] pkValues = new Object[numPkColumns];\n  PrimaryKey primaryKey = new PrimaryKey(pkValues);\n  for (int i = 0; i < numDocuments; i++) {\n    ...", "author": "Jackie-Jiang", "createdAt": "2020-12-30T00:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkxMzcyNA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549913724", "bodyText": "I don't think this will work. We have to create a new 'PrimaryKey' instance per document since the values (pkValues) are going to be different.", "author": "cbalci", "createdAt": "2020-12-30T02:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI5MTQ3OQ==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r550291479", "bodyText": "You can directly modify pkValues without changing primaryKey. They share the same reference.\nThis is not critical, so both ways are fine. It just saves minor garbages", "author": "Jackie-Jiang", "createdAt": "2020-12-30T18:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzIyMQ==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549837221", "bodyText": "PrimaryKey object can also be reused", "author": "Jackie-Jiang", "createdAt": "2020-12-29T20:28:19Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/LookupTransformFunction.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.transform.function;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.data.manager.offline.DimensionTableDataManager;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.PrimaryKey;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+\n+/**\n+ * LOOKUP function takes 4 or more arguments:\n+ * <ul>\n+ *   <li><b>TableName:</b> name of the dimension table which will be used</li>\n+ *   <li><b>ColumnName:</b> column name from the dimension table to look up</li>\n+ *   <li><b>JoinKey:</b> primary key column name for the dimension table. Note: Only primary key[s] are supported for JoinKey</li>\n+ *   <li><b>JoinValue:</b> primary key value</li>\n+ *   ...<br>\n+ *   *[If the dimension table has more then one primary keys (composite pk)]\n+ *     <li><b>JoinKey2</b></li>\n+ *     <li><b>JoinValue2</b></li>\n+ *   ...\n+ * </ul>\n+ * <br>\n+ * Example:\n+ * <pre>{@code SELECT\n+ *    baseballStats.playerName,\n+ *    baseballStats.teamID,\n+ *    LOOKUP('dimBaseballTeams', 'teamName', 'teamID', baseballStats.teamID)\n+ * FROM\n+ *    baseballStats\n+ * LIMIT 10}</pre>\n+ * <br>\n+ * Above example joins the dimension table 'baseballTeams' into regular table 'baseballStats' on 'teamID' key.\n+ * Lookup function returns the value of the column 'teamName'.\n+ */\n+public class LookupTransformFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"lookUp\";\n+\n+  // Lookup parameters\n+  private String _dimTableName;\n+  private String _dimColumnName;\n+  private final List<String> _joinKeys = new ArrayList<>();\n+  private final List<FieldSpec> _joinValueFieldSpecs = new ArrayList<>();\n+  private final List<TransformFunction> _joinValueFunctions = new ArrayList<>();\n+\n+  private DimensionTableDataManager _dataManager;\n+  private FieldSpec _lookupColumnFieldSpec;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    // Check that there are correct number of arguments\n+    Preconditions\n+        .checkArgument(arguments.size() >= 4,\n+            \"At least 4 arguments are required for LOOKUP transform function: \" +\n+            \"LOOKUP(TableName, ColumnName, JoinKey, JoinValue [, JoinKey2, JoinValue2 ...])\");\n+    Preconditions\n+        .checkArgument(arguments.size() % 2 == 0, \"Should have the same number of JoinKey and JoinValue arguments\");\n+\n+    TransformFunction dimTableNameFunction = arguments.get(0);\n+    Preconditions.checkArgument(dimTableNameFunction instanceof LiteralTransformFunction,\n+        \"First argument must be a literal(string) representing the dimension table name\");\n+    _dimTableName = TableNameBuilder.OFFLINE.tableNameWithType(\n+        ((LiteralTransformFunction) dimTableNameFunction).getLiteral());\n+\n+    TransformFunction dimColumnFunction = arguments.get(1);\n+    Preconditions.checkArgument(dimColumnFunction instanceof LiteralTransformFunction,\n+        \"Second argument must be a literal(string) representing the column name from dimension table to lookup\");\n+    _dimColumnName = ((LiteralTransformFunction) dimColumnFunction).getLiteral();\n+\n+    List<TransformFunction> joinArguments = arguments.subList(2, arguments.size());\n+    int numJoinArguments = joinArguments.size();\n+    for (int i = 0; i < numJoinArguments / 2; i++) {\n+      TransformFunction dimJoinKeyFunction = joinArguments.get((i * 2));\n+      Preconditions.checkArgument(dimJoinKeyFunction instanceof LiteralTransformFunction,\n+          \"JoinKey argument must be a literal(string) representing the primary key for the dimension table\");\n+      _joinKeys.add(((LiteralTransformFunction) dimJoinKeyFunction).getLiteral());\n+\n+      TransformFunction factJoinValueFunction = joinArguments.get((i * 2) + 1);\n+      TransformResultMetadata factJoinValueFunctionResultMetadata = factJoinValueFunction.getResultMetadata();\n+      Preconditions.checkArgument(factJoinValueFunctionResultMetadata.isSingleValue(),\n+          \"JoinValue argument must be a single value expression\");\n+      _joinValueFunctions.add(factJoinValueFunction);\n+    }\n+\n+    // Validate lookup table and relevant columns\n+    _dataManager = DimensionTableDataManager.getInstanceByTableName(_dimTableName);\n+    Preconditions.checkArgument(_dataManager != null,\n+            String.format(\"Dimension table does not exist: %s\", _dimTableName));\n+\n+    _lookupColumnFieldSpec = _dataManager.getColumnFieldSpec(_dimColumnName);\n+    Preconditions.checkArgument(_lookupColumnFieldSpec != null,\n+        String.format(\"Column does not exist in dimension table: %s:%s\", _dimTableName, _dimColumnName));\n+\n+    for (String joinKey : _joinKeys) {\n+      FieldSpec pkColumnSpec = _dataManager.getColumnFieldSpec(joinKey);\n+      Preconditions.checkArgument(pkColumnSpec != null,\n+          String.format(\"Primary key column doesn't exist in dimension table: %s:%s\", _dimTableName, joinKey));\n+      _joinValueFieldSpecs.add(pkColumnSpec);\n+    }\n+\n+    List<String> tablePrimaryKeyColumns = _dataManager.getPrimaryKeyColumns();\n+    Preconditions.checkArgument(_joinKeys.equals(tablePrimaryKeyColumns),\n+        String.format(\"Provided join keys (%s) must be the same as table primary keys: %s\", _joinKeys,\n+            tablePrimaryKeyColumns));\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return new TransformResultMetadata(_lookupColumnFieldSpec.getDataType(),\n+        _lookupColumnFieldSpec.isSingleValueField(), false);\n+  }\n+\n+  private Object[] lookup(ProjectionBlock projectionBlock) {\n+    int numPkColumns = _joinKeys.size();\n+    int numDocuments = projectionBlock.getNumDocs();\n+    Object[][] pkColumns = new Object[numPkColumns][];\n+    for (int i = 0; i < numPkColumns; i++) {\n+      FieldSpec.DataType colType = _joinValueFieldSpecs.get(i).getDataType();\n+      TransformFunction tf = _joinValueFunctions.get(i);\n+      switch (colType) {\n+        case STRING:\n+          pkColumns[i] = tf.transformToStringValuesSV(projectionBlock);\n+          break;\n+        case INT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToIntValuesSV(projectionBlock));\n+          break;\n+        case LONG:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToLongValuesSV(projectionBlock));\n+          break;\n+        case FLOAT:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToFloatValuesSV(projectionBlock));\n+          break;\n+        case DOUBLE:\n+          pkColumns[i] = ArrayUtils.toObject(tf.transformToDoubleValuesSV(projectionBlock));\n+          break;\n+        case BYTES:\n+          byte[][] primitiveValues = tf.transformToBytesValuesSV(projectionBlock);\n+          pkColumns[i] = new Byte[numDocuments][];\n+          for (int n = 0; n < numDocuments; n++) {\n+            pkColumns[i][n] = ArrayUtils.toObject(primitiveValues[n]);\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown column type for primary key\");\n+      }\n+    }\n+\n+    Object[] resultSet = new Object[numDocuments];\n+    for (int i = 0; i < numDocuments; i++) {\n+      // prepare pk\n+      Object[] pkValues = new Object[numPkColumns];\n+      for (int j = 0; j < numPkColumns; j++) {\n+        pkValues[j] = pkColumns[j][i];\n+      }\n+      // lookup\n+      GenericRow row = _dataManager.lookupRowByPrimaryKey(new PrimaryKey(pkValues));", "originalCommit": "1bc88ca3b4c97d263c1756c3fc45c59471e26433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4ODM5OA==", "url": "https://github.com/apache/pinot/pull/6383#discussion_r549888398", "bodyText": "Replied above", "author": "cbalci", "createdAt": "2020-12-29T23:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgzNzIyMQ=="}], "type": "inlineReview"}, {"oid": "77e5a779a4c26e04b62a1b6cfa5226dd4ae85637", "url": "https://github.com/apache/pinot/commit/77e5a779a4c26e04b62a1b6cfa5226dd4ae85637", "message": "Address review comments.", "committedDate": "2020-12-29T23:39:48Z", "type": "commit"}, {"oid": "4577c217f65ecabdc615174da7b3c0e7fbd17003", "url": "https://github.com/apache/pinot/commit/4577c217f65ecabdc615174da7b3c0e7fbd17003", "message": "Fix PK hash match issue for byte[] type columns", "committedDate": "2020-12-30T02:09:05Z", "type": "commit"}]}