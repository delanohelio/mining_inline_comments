{"pr_number": 6124, "pr_title": "RealtimeToOfflineSegments task generator", "pr_createdAt": "2020-10-08T22:30:44Z", "pr_url": "https://github.com/apache/pinot/pull/6124", "timeline": [{"oid": "cd79103717cc0de76525ef54150be23a1dbf6613", "url": "https://github.com/apache/pinot/commit/cd79103717cc0de76525ef54150be23a1dbf6613", "message": "RealtimeToOfflineSegments task generator", "committedDate": "2020-10-08T23:42:53Z", "type": "forcePushed"}, {"oid": "4c290c9e214b8ad81aec0fd873f8e6322691d2b4", "url": "https://github.com/apache/pinot/commit/4c290c9e214b8ad81aec0fd873f8e6322691d2b4", "message": "RealtimeToOfflineSegments task generator", "committedDate": "2020-10-08T23:45:19Z", "type": "forcePushed"}, {"oid": "bcf0fc434bbe470b39d128bf80e71bf5c4855365", "url": "https://github.com/apache/pinot/commit/bcf0fc434bbe470b39d128bf80e71bf5c4855365", "message": "RealtimeToOfflineSegments task generator", "committedDate": "2020-10-09T00:36:40Z", "type": "forcePushed"}, {"oid": "c9466df78e6c14740dbbfe91316650d0aaceb0f3", "url": "https://github.com/apache/pinot/commit/c9466df78e6c14740dbbfe91316650d0aaceb0f3", "message": "Task generator for RealtimeToOfflineSegments task", "committedDate": "2020-10-09T21:36:55Z", "type": "commit"}, {"oid": "c9466df78e6c14740dbbfe91316650d0aaceb0f3", "url": "https://github.com/apache/pinot/commit/c9466df78e6c14740dbbfe91316650d0aaceb0f3", "message": "Task generator for RealtimeToOfflineSegments task", "committedDate": "2020-10-09T21:36:55Z", "type": "forcePushed"}, {"oid": "c13c079ae63708cc0fa2505f70f991cebba0e5f7", "url": "https://github.com/apache/pinot/commit/c13c079ae63708cc0fa2505f70f991cebba0e5f7", "message": "RealtimeToOfflineSegments task generator", "committedDate": "2020-10-09T21:31:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3ODIzNg==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r503578236", "bodyText": "Maybe you want to log the first few of these ? If for any reason tasks start to get queued, we will have a long list here.", "author": "mcvsubbu", "createdAt": "2020-10-12T23:09:02Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/RealtimeToOfflineSegmentsTaskGenerator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion.generator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants.Segment;\n+import org.apache.pinot.controller.helix.core.minion.ClusterInfoProvider;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.common.MinionConstants.RealtimeToOfflineSegmentsTask;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.TimeUtils;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link PinotTaskGenerator} implementation for generating tasks of type {@link RealtimeToOfflineSegmentsTask}\n+ *\n+ * These will be generated only for REALTIME tables.\n+ * At any given time, only 1 task of this type should be generated for a table.\n+ *\n+ * Steps:\n+ *  - The watermarkMillis is read from the {@link RealtimeToOfflineSegmentsTaskMetadata} ZNode found at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *      In case of cold-start, no ZNode will exist.\n+ *      A new ZNode will be created, with watermarkMillis as the smallest time found in the COMPLETED segments (or using start time config)\n+ *  - The execution window for the task is calculated as, windowStartMillis = waterMarkMillis, windowEndMillis = windowStartMillis + bucketTimeMillis,\n+ *      where bucketTime can be provided in the taskConfigs (default 1d)\n+ *  - If the execution window is not older than bufferTimeMillis, no task will be generated,\n+ *      where bufferTime can be provided in the taskConfigs (default 2d)\n+ *  - Segment metadata is scanned for all COMPLETED segments, to pick those containing data in window [windowStartMillis, windowEndMillis)\n+ *  - A PinotTaskConfig is created, with segment information, execution window, and any config specific to the task\n+ */\n+public class RealtimeToOfflineSegmentsTaskGenerator implements PinotTaskGenerator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskGenerator.class);\n+\n+  private static final String DEFAULT_BUCKET_PERIOD = \"1d\";\n+  private static final String DEFAULT_BUFFER_PERIOD = \"2d\";\n+\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RealtimeToOfflineSegmentsTaskGenerator(ClusterInfoProvider clusterInfoProvider) {\n+    _clusterInfoProvider = clusterInfoProvider;\n+  }\n+\n+  @Override\n+  public String getTaskType() {\n+    return RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+  }\n+\n+  @Override\n+  public List<PinotTaskConfig> generateTasks(List<TableConfig> tableConfigs) {\n+    String taskType = RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+\n+    List<PinotTaskConfig> pinotTaskConfigs = new ArrayList<>();\n+\n+    for (TableConfig tableConfig : tableConfigs) {\n+      String tableName = tableConfig.getTableName();\n+\n+      if (tableConfig.getTableType() != TableType.REALTIME) {\n+        LOGGER.warn(\"Skip generating task: {} for non-REALTIME table: {}\", taskType, tableName);\n+        continue;\n+      }\n+\n+      String rawTableName = TableNameBuilder.extractRawTableName(tableName);\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+\n+      // Only schedule 1 task of this type, per table\n+      Map<String, TaskState> nonCompletedTasks =\n+          TaskGeneratorUtils.getNonCompletedTasks(taskType, realtimeTableName, _clusterInfoProvider);\n+      if (!nonCompletedTasks.isEmpty()) {\n+        LOGGER.warn(\"Found non-completed tasks: {} for same table: {}. Skipping scheduling new task.\",\n+            nonCompletedTasks.keySet(), realtimeTableName);", "originalCommit": "c9466df78e6c14740dbbfe91316650d0aaceb0f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc3NjE1Ng==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505776156", "bodyText": "IMO it is fine to log one warning per table. It is quite critical issue if minion stuck for this job (data loss if it doesn't move the segments on time), so we should detect it as soon as possible", "author": "Jackie-Jiang", "createdAt": "2020-10-15T19:06:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3ODIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3NzYxMg==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r506777612", "bodyText": "there shouldn't be more than 1 in this list, because this is just for 1 table.", "author": "npawar", "createdAt": "2020-10-17T01:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3ODIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3OTE2NQ==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r503579165", "bodyText": "if you use a method to get the current time, you can test the logic in this class by manipulating time to anything.", "author": "mcvsubbu", "createdAt": "2020-10-12T23:12:12Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/RealtimeToOfflineSegmentsTaskGenerator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion.generator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants.Segment;\n+import org.apache.pinot.controller.helix.core.minion.ClusterInfoProvider;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.common.MinionConstants.RealtimeToOfflineSegmentsTask;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.TimeUtils;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link PinotTaskGenerator} implementation for generating tasks of type {@link RealtimeToOfflineSegmentsTask}\n+ *\n+ * These will be generated only for REALTIME tables.\n+ * At any given time, only 1 task of this type should be generated for a table.\n+ *\n+ * Steps:\n+ *  - The watermarkMillis is read from the {@link RealtimeToOfflineSegmentsTaskMetadata} ZNode found at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *      In case of cold-start, no ZNode will exist.\n+ *      A new ZNode will be created, with watermarkMillis as the smallest time found in the COMPLETED segments (or using start time config)\n+ *  - The execution window for the task is calculated as, windowStartMillis = waterMarkMillis, windowEndMillis = windowStartMillis + bucketTimeMillis,\n+ *      where bucketTime can be provided in the taskConfigs (default 1d)\n+ *  - If the execution window is not older than bufferTimeMillis, no task will be generated,\n+ *      where bufferTime can be provided in the taskConfigs (default 2d)\n+ *  - Segment metadata is scanned for all COMPLETED segments, to pick those containing data in window [windowStartMillis, windowEndMillis)\n+ *  - A PinotTaskConfig is created, with segment information, execution window, and any config specific to the task\n+ */\n+public class RealtimeToOfflineSegmentsTaskGenerator implements PinotTaskGenerator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskGenerator.class);\n+\n+  private static final String DEFAULT_BUCKET_PERIOD = \"1d\";\n+  private static final String DEFAULT_BUFFER_PERIOD = \"2d\";\n+\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RealtimeToOfflineSegmentsTaskGenerator(ClusterInfoProvider clusterInfoProvider) {\n+    _clusterInfoProvider = clusterInfoProvider;\n+  }\n+\n+  @Override\n+  public String getTaskType() {\n+    return RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+  }\n+\n+  @Override\n+  public List<PinotTaskConfig> generateTasks(List<TableConfig> tableConfigs) {\n+    String taskType = RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+\n+    List<PinotTaskConfig> pinotTaskConfigs = new ArrayList<>();\n+\n+    for (TableConfig tableConfig : tableConfigs) {\n+      String tableName = tableConfig.getTableName();\n+\n+      if (tableConfig.getTableType() != TableType.REALTIME) {\n+        LOGGER.warn(\"Skip generating task: {} for non-REALTIME table: {}\", taskType, tableName);\n+        continue;\n+      }\n+\n+      String rawTableName = TableNameBuilder.extractRawTableName(tableName);\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+\n+      // Only schedule 1 task of this type, per table\n+      Map<String, TaskState> nonCompletedTasks =\n+          TaskGeneratorUtils.getNonCompletedTasks(taskType, realtimeTableName, _clusterInfoProvider);\n+      if (!nonCompletedTasks.isEmpty()) {\n+        LOGGER.warn(\"Found non-completed tasks: {} for same table: {}. Skipping scheduling new task.\",\n+            nonCompletedTasks.keySet(), realtimeTableName);\n+        continue;\n+      }\n+\n+      List<LLCRealtimeSegmentZKMetadata> realtimeSegmentsMetadataList =\n+          _clusterInfoProvider.getLLCRealtimeSegmentsMetadata(realtimeTableName);\n+      List<LLCRealtimeSegmentZKMetadata> completedSegmentsMetadataList = new ArrayList<>();\n+      for (LLCRealtimeSegmentZKMetadata metadata : realtimeSegmentsMetadataList) {\n+        if (metadata.getStatus().equals(Segment.Realtime.Status.DONE)) {\n+          completedSegmentsMetadataList.add(metadata);\n+        }\n+      }\n+      if (completedSegmentsMetadataList.isEmpty()) {\n+        LOGGER\n+            .info(\"No realtime completed segments found for table: {}, skipping task generation: {}\", realtimeTableName,\n+                taskType);\n+        continue;\n+      }\n+\n+      TableTaskConfig tableTaskConfig = tableConfig.getTaskConfig();\n+      Preconditions.checkState(tableTaskConfig != null);\n+      Map<String, String> taskConfigs = tableTaskConfig.getConfigsForTaskType(taskType);\n+      Preconditions.checkState(taskConfigs != null, \"Task config shouldn't be null for Table: {}\", tableName);\n+\n+      // Get the bucket size and buffer\n+      String bucketTimeStr =\n+          taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUCKET_TIME_PERIOD_KEY, DEFAULT_BUCKET_PERIOD);\n+      String bufferTimeStr =\n+          taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUFFER_TIME_PERIOD_KEY, DEFAULT_BUFFER_PERIOD);\n+      long bucketMillis = TimeUtils.convertPeriodToMillis(bucketTimeStr);\n+      long bufferMillis = TimeUtils.convertPeriodToMillis(bufferTimeStr);\n+\n+      // Fetch RealtimeToOfflineSegmentsTaskMetadata ZNode for reading watermark\n+      RealtimeToOfflineSegmentsTaskMetadata realtimeToOfflineSegmentsTaskMetadata =\n+          _clusterInfoProvider.getMinionRealtimeToOfflineSegmentsTaskMetadata(realtimeTableName);\n+\n+      if (realtimeToOfflineSegmentsTaskMetadata == null) {\n+        // No ZNode exists. Cold-start.\n+        long watermarkMillis;\n+\n+        String startTimeStr = taskConfigs.get(RealtimeToOfflineSegmentsTask.START_TIME_MILLIS_KEY);\n+        if (startTimeStr != null) {\n+          // Use startTime config if provided in taskConfigs\n+          watermarkMillis = Long.parseLong(startTimeStr);\n+        } else {\n+          // Find the smallest time from all segments\n+          RealtimeSegmentZKMetadata minSegmentZkMetadata = null;\n+          for (LLCRealtimeSegmentZKMetadata realtimeSegmentZKMetadata : completedSegmentsMetadataList) {\n+            if (minSegmentZkMetadata == null || realtimeSegmentZKMetadata.getStartTime() < minSegmentZkMetadata\n+                .getStartTime()) {\n+              minSegmentZkMetadata = realtimeSegmentZKMetadata;\n+            }\n+          }\n+          Preconditions.checkState(minSegmentZkMetadata != null);\n+\n+          // Convert the segment minTime to millis\n+          long minSegmentStartTimeMillis =\n+              minSegmentZkMetadata.getTimeUnit().toMillis(minSegmentZkMetadata.getStartTime());\n+\n+          // Round off according to the bucket. This ensures we align the offline segments to proper time boundaries\n+          // For example, if start time millis is 20200813T12:34:59, we want to create the first segment for window [20200813, 20200814)\n+          watermarkMillis = (minSegmentStartTimeMillis / bucketMillis) * bucketMillis;\n+        }\n+\n+        // Create RealtimeToOfflineSegmentsTaskMetadata ZNode using watermark calculated above\n+        realtimeToOfflineSegmentsTaskMetadata =\n+            new RealtimeToOfflineSegmentsTaskMetadata(realtimeTableName, watermarkMillis);\n+        _clusterInfoProvider.setRealtimeToOfflineSegmentsTaskMetadata(realtimeToOfflineSegmentsTaskMetadata);\n+      }\n+\n+      // WindowStart = watermark. WindowEnd = windowStart + bucket.\n+      long windowStartMillis = realtimeToOfflineSegmentsTaskMetadata.getWatermarkMillis();\n+      long windowEndMillis = windowStartMillis + bucketMillis;\n+\n+      // Check that execution window is older than bufferTime\n+      if (windowEndMillis > System.currentTimeMillis() - bufferMillis) {", "originalCommit": "c9466df78e6c14740dbbfe91316650d0aaceb0f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3OTYwOQ==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r503579609", "bodyText": "Instead of two lists, maybe you can have another list of LLCRealtimeSegmentZkMetadata?", "author": "mcvsubbu", "createdAt": "2020-10-12T23:13:55Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/RealtimeToOfflineSegmentsTaskGenerator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion.generator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants.Segment;\n+import org.apache.pinot.controller.helix.core.minion.ClusterInfoProvider;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.common.MinionConstants.RealtimeToOfflineSegmentsTask;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.TimeUtils;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link PinotTaskGenerator} implementation for generating tasks of type {@link RealtimeToOfflineSegmentsTask}\n+ *\n+ * These will be generated only for REALTIME tables.\n+ * At any given time, only 1 task of this type should be generated for a table.\n+ *\n+ * Steps:\n+ *  - The watermarkMillis is read from the {@link RealtimeToOfflineSegmentsTaskMetadata} ZNode found at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *      In case of cold-start, no ZNode will exist.\n+ *      A new ZNode will be created, with watermarkMillis as the smallest time found in the COMPLETED segments (or using start time config)\n+ *  - The execution window for the task is calculated as, windowStartMillis = waterMarkMillis, windowEndMillis = windowStartMillis + bucketTimeMillis,\n+ *      where bucketTime can be provided in the taskConfigs (default 1d)\n+ *  - If the execution window is not older than bufferTimeMillis, no task will be generated,\n+ *      where bufferTime can be provided in the taskConfigs (default 2d)\n+ *  - Segment metadata is scanned for all COMPLETED segments, to pick those containing data in window [windowStartMillis, windowEndMillis)\n+ *  - A PinotTaskConfig is created, with segment information, execution window, and any config specific to the task\n+ */\n+public class RealtimeToOfflineSegmentsTaskGenerator implements PinotTaskGenerator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskGenerator.class);\n+\n+  private static final String DEFAULT_BUCKET_PERIOD = \"1d\";\n+  private static final String DEFAULT_BUFFER_PERIOD = \"2d\";\n+\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RealtimeToOfflineSegmentsTaskGenerator(ClusterInfoProvider clusterInfoProvider) {\n+    _clusterInfoProvider = clusterInfoProvider;\n+  }\n+\n+  @Override\n+  public String getTaskType() {\n+    return RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+  }\n+\n+  @Override\n+  public List<PinotTaskConfig> generateTasks(List<TableConfig> tableConfigs) {\n+    String taskType = RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+\n+    List<PinotTaskConfig> pinotTaskConfigs = new ArrayList<>();\n+\n+    for (TableConfig tableConfig : tableConfigs) {\n+      String tableName = tableConfig.getTableName();\n+\n+      if (tableConfig.getTableType() != TableType.REALTIME) {\n+        LOGGER.warn(\"Skip generating task: {} for non-REALTIME table: {}\", taskType, tableName);\n+        continue;\n+      }\n+\n+      String rawTableName = TableNameBuilder.extractRawTableName(tableName);\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+\n+      // Only schedule 1 task of this type, per table\n+      Map<String, TaskState> nonCompletedTasks =\n+          TaskGeneratorUtils.getNonCompletedTasks(taskType, realtimeTableName, _clusterInfoProvider);\n+      if (!nonCompletedTasks.isEmpty()) {\n+        LOGGER.warn(\"Found non-completed tasks: {} for same table: {}. Skipping scheduling new task.\",\n+            nonCompletedTasks.keySet(), realtimeTableName);\n+        continue;\n+      }\n+\n+      List<LLCRealtimeSegmentZKMetadata> realtimeSegmentsMetadataList =\n+          _clusterInfoProvider.getLLCRealtimeSegmentsMetadata(realtimeTableName);\n+      List<LLCRealtimeSegmentZKMetadata> completedSegmentsMetadataList = new ArrayList<>();\n+      for (LLCRealtimeSegmentZKMetadata metadata : realtimeSegmentsMetadataList) {\n+        if (metadata.getStatus().equals(Segment.Realtime.Status.DONE)) {\n+          completedSegmentsMetadataList.add(metadata);\n+        }\n+      }\n+      if (completedSegmentsMetadataList.isEmpty()) {\n+        LOGGER\n+            .info(\"No realtime completed segments found for table: {}, skipping task generation: {}\", realtimeTableName,\n+                taskType);\n+        continue;\n+      }\n+\n+      TableTaskConfig tableTaskConfig = tableConfig.getTaskConfig();\n+      Preconditions.checkState(tableTaskConfig != null);\n+      Map<String, String> taskConfigs = tableTaskConfig.getConfigsForTaskType(taskType);\n+      Preconditions.checkState(taskConfigs != null, \"Task config shouldn't be null for Table: {}\", tableName);\n+\n+      // Get the bucket size and buffer\n+      String bucketTimeStr =\n+          taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUCKET_TIME_PERIOD_KEY, DEFAULT_BUCKET_PERIOD);\n+      String bufferTimeStr =\n+          taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUFFER_TIME_PERIOD_KEY, DEFAULT_BUFFER_PERIOD);\n+      long bucketMillis = TimeUtils.convertPeriodToMillis(bucketTimeStr);\n+      long bufferMillis = TimeUtils.convertPeriodToMillis(bufferTimeStr);\n+\n+      // Fetch RealtimeToOfflineSegmentsTaskMetadata ZNode for reading watermark\n+      RealtimeToOfflineSegmentsTaskMetadata realtimeToOfflineSegmentsTaskMetadata =\n+          _clusterInfoProvider.getMinionRealtimeToOfflineSegmentsTaskMetadata(realtimeTableName);\n+\n+      if (realtimeToOfflineSegmentsTaskMetadata == null) {\n+        // No ZNode exists. Cold-start.\n+        long watermarkMillis;\n+\n+        String startTimeStr = taskConfigs.get(RealtimeToOfflineSegmentsTask.START_TIME_MILLIS_KEY);\n+        if (startTimeStr != null) {\n+          // Use startTime config if provided in taskConfigs\n+          watermarkMillis = Long.parseLong(startTimeStr);\n+        } else {\n+          // Find the smallest time from all segments\n+          RealtimeSegmentZKMetadata minSegmentZkMetadata = null;\n+          for (LLCRealtimeSegmentZKMetadata realtimeSegmentZKMetadata : completedSegmentsMetadataList) {\n+            if (minSegmentZkMetadata == null || realtimeSegmentZKMetadata.getStartTime() < minSegmentZkMetadata\n+                .getStartTime()) {\n+              minSegmentZkMetadata = realtimeSegmentZKMetadata;\n+            }\n+          }\n+          Preconditions.checkState(minSegmentZkMetadata != null);\n+\n+          // Convert the segment minTime to millis\n+          long minSegmentStartTimeMillis =\n+              minSegmentZkMetadata.getTimeUnit().toMillis(minSegmentZkMetadata.getStartTime());\n+\n+          // Round off according to the bucket. This ensures we align the offline segments to proper time boundaries\n+          // For example, if start time millis is 20200813T12:34:59, we want to create the first segment for window [20200813, 20200814)\n+          watermarkMillis = (minSegmentStartTimeMillis / bucketMillis) * bucketMillis;\n+        }\n+\n+        // Create RealtimeToOfflineSegmentsTaskMetadata ZNode using watermark calculated above\n+        realtimeToOfflineSegmentsTaskMetadata =\n+            new RealtimeToOfflineSegmentsTaskMetadata(realtimeTableName, watermarkMillis);\n+        _clusterInfoProvider.setRealtimeToOfflineSegmentsTaskMetadata(realtimeToOfflineSegmentsTaskMetadata);\n+      }\n+\n+      // WindowStart = watermark. WindowEnd = windowStart + bucket.\n+      long windowStartMillis = realtimeToOfflineSegmentsTaskMetadata.getWatermarkMillis();\n+      long windowEndMillis = windowStartMillis + bucketMillis;\n+\n+      // Check that execution window is older than bufferTime\n+      if (windowEndMillis > System.currentTimeMillis() - bufferMillis) {\n+        LOGGER.info(\n+            \"Window with start: {} and end: {} is not older than buffer time: {} configured as {} ago. Skipping scheduling task: {}\",\n+            windowStartMillis, windowEndMillis, bufferMillis, bufferTimeStr, taskType);\n+      }\n+\n+      // Find all COMPLETED segments with data overlapping execution window: windowStart (inclusive) to windowEnd (exclusive)\n+      List<String> segmentNames = new ArrayList<>();", "originalCommit": "c9466df78e6c14740dbbfe91316650d0aaceb0f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3NzY4NA==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r506777684", "bodyText": "I did not follow. these lists are for setting comma separated segments and downloadURL into the task configs", "author": "npawar", "createdAt": "2020-10-17T01:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3OTYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MDEwOQ==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r503580109", "bodyText": "It will improve readability if you break this method down to call helpers.", "author": "mcvsubbu", "createdAt": "2020-10-12T23:15:46Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/RealtimeToOfflineSegmentsTaskGenerator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion.generator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants.Segment;\n+import org.apache.pinot.controller.helix.core.minion.ClusterInfoProvider;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.common.MinionConstants.RealtimeToOfflineSegmentsTask;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.TimeUtils;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link PinotTaskGenerator} implementation for generating tasks of type {@link RealtimeToOfflineSegmentsTask}\n+ *\n+ * These will be generated only for REALTIME tables.\n+ * At any given time, only 1 task of this type should be generated for a table.\n+ *\n+ * Steps:\n+ *  - The watermarkMillis is read from the {@link RealtimeToOfflineSegmentsTaskMetadata} ZNode found at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *      In case of cold-start, no ZNode will exist.\n+ *      A new ZNode will be created, with watermarkMillis as the smallest time found in the COMPLETED segments (or using start time config)\n+ *  - The execution window for the task is calculated as, windowStartMillis = waterMarkMillis, windowEndMillis = windowStartMillis + bucketTimeMillis,\n+ *      where bucketTime can be provided in the taskConfigs (default 1d)\n+ *  - If the execution window is not older than bufferTimeMillis, no task will be generated,\n+ *      where bufferTime can be provided in the taskConfigs (default 2d)\n+ *  - Segment metadata is scanned for all COMPLETED segments, to pick those containing data in window [windowStartMillis, windowEndMillis)\n+ *  - A PinotTaskConfig is created, with segment information, execution window, and any config specific to the task\n+ */\n+public class RealtimeToOfflineSegmentsTaskGenerator implements PinotTaskGenerator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskGenerator.class);\n+\n+  private static final String DEFAULT_BUCKET_PERIOD = \"1d\";\n+  private static final String DEFAULT_BUFFER_PERIOD = \"2d\";\n+\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RealtimeToOfflineSegmentsTaskGenerator(ClusterInfoProvider clusterInfoProvider) {\n+    _clusterInfoProvider = clusterInfoProvider;\n+  }\n+\n+  @Override\n+  public String getTaskType() {\n+    return RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+  }\n+\n+  @Override\n+  public List<PinotTaskConfig> generateTasks(List<TableConfig> tableConfigs) {", "originalCommit": "c9466df78e6c14740dbbfe91316650d0aaceb0f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MTY3NQ==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r503581675", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * e.g. if set to \"2d\", no task will be scheduled for a time window younger than 2 days\n          \n          \n            \n                 * e.g. if set to \"2d\", no task will be scheduled for a segments newer than 2 days\n          \n      \n    \n    \n  \n\n:)\nIs this interpretation correct?", "author": "mcvsubbu", "createdAt": "2020-10-12T23:21:41Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/MinionConstants.java", "diffHunk": "@@ -62,16 +62,35 @@ private MinionConstants() {\n     public static final String MERGED_SEGMENT_NAME_KEY = \"mergedSegmentNameKey\";\n   }\n \n+  /**\n+   * Creates segments for the OFFLINE table, using completed segments from the corresponding REALTIME table\n+   */\n   public static class RealtimeToOfflineSegmentsTask {\n     public static final String TASK_TYPE = \"realtimeToOfflineSegmentsTask\";\n-    // window\n+\n+    /**\n+     * The time window size for the task.\n+     * e.g. if set to \"1d\", then task is scheduled to run for a 1 day window\n+     */\n+    public static final String BUCKET_TIME_PERIOD_KEY = \"bucketTimePeriod\";\n+    /**\n+     * The time period to wait before picking segments for this task\n+     * e.g. if set to \"2d\", no task will be scheduled for a time window younger than 2 days", "originalCommit": "c9466df78e6c14740dbbfe91316650d0aaceb0f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5NDQxOA==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r503594418", "bodyText": "Why not make this a boolean return, so that if the pre-process fails we do not go further in the task execution? Not sure what helix does when we throw exceptions from the task executor -- probably retries the task, but that may not be good for us.", "author": "mcvsubbu", "createdAt": "2020-10-12T23:57:01Z", "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/PinotTaskExecutor.java", "diffHunk": "@@ -26,6 +26,12 @@\n  */\n public interface PinotTaskExecutor {\n \n+  /**\n+   * Pre processing operations to be done at the beginning of task execution\n+   */\n+  default void preProcess(PinotTaskConfig pinotTaskConfig) {", "originalCommit": "c9466df78e6c14740dbbfe91316650d0aaceb0f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0Mzg1OQ==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505843859", "bodyText": "Why not make this a boolean return, so that if the pre-process fails we do not go further in the task execution? Not sure what helix does when we throw exceptions from the task executor -- probably retries the task, but that may not be good for us.\n\nI prefer throwing exception when something went wrong to force the caller to handle the exception, or the caller could just ignore the return value, which could cause unexpected behavior. Minion code can handle the exception and fail the task", "author": "Jackie-Jiang", "createdAt": "2020-10-15T20:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5NDQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5NDc5Ng==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r503594796", "bodyText": "please move the log line to be below postProcess, since it says \"Done\"\nIt may be useful to have a log line after each phase", "author": "mcvsubbu", "createdAt": "2020-10-12T23:58:31Z", "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/BaseSingleSegmentConversionExecutor.java", "diffHunk": "@@ -135,6 +137,8 @@ public SegmentConversionResult executeTask(PinotTaskConfig pinotTaskConfig)\n           convertedSegmentTarFile);\n \n       LOGGER.info(\"Done executing {} on table: {}, segment: {}\", taskType, tableNameWithType, segmentName);\n+      postProcess(pinotTaskConfig);", "originalCommit": "c9466df78e6c14740dbbfe91316650d0aaceb0f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7577085056ede118116fb7ec6d0ef599d2a427d2", "url": "https://github.com/apache/pinot/commit/7577085056ede118116fb7ec6d0ef599d2a427d2", "message": "Window overlap with CONSUMING segments check", "committedDate": "2020-10-13T22:50:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE5MDE5Mg==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505190192", "bodyText": "watermarkInMillis?", "author": "snleee", "createdAt": "2020-10-15T06:16:05Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/minion/RealtimeToOfflineSegmentsTaskMetadata.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.minion;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import org.apache.helix.ZNRecord;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+\n+/**\n+ * Metadata for the minion task of type <code>realtimeToOfflineSegmentsTask</code>.\n+ * The <code>watermarkMillis</code> denotes the time (exclusive) upto which tasks have been executed.\n+ *\n+ * This gets serialized and stored in zookeeper under the path MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *\n+ * PinotTaskGenerator:\n+ * The <code>watermarkMillis</code>> is used by the <code>RealtimeToOfflineSegmentsTaskGenerator</code>,\n+ * to determine the window of execution for the task it is generating.\n+ * The window of execution will be [watermarkMillis, watermarkMillis + bucketSize)\n+ *\n+ * PinotTaskExecutor:\n+ * The same watermark is used by the <code>RealtimeToOfflineSegmentsTaskExecutor</code>, to:\n+ * - Verify that is is running the latest task scheduled by the task generator\n+ * - Update the watermark as the end of the window that it executed for\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class RealtimeToOfflineSegmentsTaskMetadata {\n+\n+  private static final String WATERMARK_KEY = \"watermarkMillis\";", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1NDE3MA==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505754170", "bodyText": "I would suggest watermarkMs to be consistent with other classes", "author": "Jackie-Jiang", "createdAt": "2020-10-15T18:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE5MDE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE5MDk0MQ==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505190941", "bodyText": "remove line", "author": "snleee", "createdAt": "2020-10-15T06:17:06Z", "path": "pinot-common/src/test/java/org/apache/pinot/common/metadata/RealtimeToOfflineSegmentsTaskMetadataTest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.metadata;\n+\n+import org.apache.helix.ZNRecord;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+\n+/**\n+ * Tests for converting to and from ZNRecord to {@link RealtimeToOfflineSegmentsTaskMetadata}\n+ */\n+public class RealtimeToOfflineSegmentsTaskMetadataTest {\n+\n+  @Test\n+  public void testToFromZNRecord() {\n+", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTI2MzQ5Ng==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505263496", "bodyText": "What is the recovery mechanism for tasks that are stuck? If the job is not completed after 1 day and the task is not complete, shouldn't we re-schedule the job?", "author": "snleee", "createdAt": "2020-10-15T07:28:25Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/RealtimeToOfflineSegmentsTaskGenerator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion.generator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants.Segment;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.controller.helix.core.minion.ClusterInfoProvider;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.common.MinionConstants.RealtimeToOfflineSegmentsTask;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.TimeUtils;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link PinotTaskGenerator} implementation for generating tasks of type {@link RealtimeToOfflineSegmentsTask}\n+ *\n+ * These will be generated only for REALTIME tables.\n+ * At any given time, only 1 task of this type should be generated for a table.\n+ *\n+ * Steps:\n+ *  - The watermarkMillis is read from the {@link RealtimeToOfflineSegmentsTaskMetadata} ZNode found at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *      In case of cold-start, no ZNode will exist.\n+ *      A new ZNode will be created, with watermarkMillis as the smallest time found in the COMPLETED segments (or using start time config)\n+ *  - The execution window for the task is calculated as, windowStartMillis = waterMarkMillis, windowEndMillis = windowStartMillis + bucketTimeMillis,\n+ *      where bucketTime can be provided in the taskConfigs (default 1d)\n+ *  - If the execution window is not older than bufferTimeMillis, no task will be generated,\n+ *      where bufferTime can be provided in the taskConfigs (default 2d)\n+ *  - Segment metadata is scanned for all COMPLETED segments, to pick those containing data in window [windowStartMillis, windowEndMillis)\n+ *  - A PinotTaskConfig is created, with segment information, execution window, and any config specific to the task\n+ */\n+public class RealtimeToOfflineSegmentsTaskGenerator implements PinotTaskGenerator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskGenerator.class);\n+\n+  private static final String DEFAULT_BUCKET_PERIOD = \"1d\";\n+  private static final String DEFAULT_BUFFER_PERIOD = \"2d\";\n+\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RealtimeToOfflineSegmentsTaskGenerator(ClusterInfoProvider clusterInfoProvider) {\n+    _clusterInfoProvider = clusterInfoProvider;\n+  }\n+\n+  @Override\n+  public String getTaskType() {\n+    return RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+  }\n+\n+  @Override\n+  public List<PinotTaskConfig> generateTasks(List<TableConfig> tableConfigs) {\n+    String taskType = RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+    List<PinotTaskConfig> pinotTaskConfigs = new ArrayList<>();\n+\n+    for (TableConfig tableConfig : tableConfigs) {\n+      String tableName = tableConfig.getTableName();\n+\n+      if (tableConfig.getTableType() != TableType.REALTIME) {\n+        LOGGER.warn(\"Skip generating task: {} for non-REALTIME table: {}\", taskType, tableName);\n+        continue;\n+      }\n+      LOGGER.info(\"Start generating task configs for table: {} for task: {}\", tableName, taskType);\n+\n+      String rawTableName = TableNameBuilder.extractRawTableName(tableName);\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+\n+      // Only schedule 1 task of this type, per table\n+      Map<String, TaskState> nonCompletedTasks =", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc3NDAzMA==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505774030", "bodyText": "We can keep the same logic as in TaskGeneratorUtils.getRunningSegments() to skip old tasks", "author": "Jackie-Jiang", "createdAt": "2020-10-15T19:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTI2MzQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTI5NDUxOQ==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505294519", "bodyText": "In my opinion, completedSegments is a little bit confusing because of nonCompletedTasks. At first glance, I thought completedSegments refer to the list of segments whose realtimeToOffline task is complete. However, they refer to the list of segment with COMPLETED state (i.e. committed segments). I don't think that we need to change the variable names but can you add a little bit more information on this as part of the comment?", "author": "snleee", "createdAt": "2020-10-15T07:54:24Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/RealtimeToOfflineSegmentsTaskGenerator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion.generator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants.Segment;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.controller.helix.core.minion.ClusterInfoProvider;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.common.MinionConstants.RealtimeToOfflineSegmentsTask;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.TimeUtils;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link PinotTaskGenerator} implementation for generating tasks of type {@link RealtimeToOfflineSegmentsTask}\n+ *\n+ * These will be generated only for REALTIME tables.\n+ * At any given time, only 1 task of this type should be generated for a table.\n+ *\n+ * Steps:\n+ *  - The watermarkMillis is read from the {@link RealtimeToOfflineSegmentsTaskMetadata} ZNode found at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *      In case of cold-start, no ZNode will exist.\n+ *      A new ZNode will be created, with watermarkMillis as the smallest time found in the COMPLETED segments (or using start time config)\n+ *  - The execution window for the task is calculated as, windowStartMillis = waterMarkMillis, windowEndMillis = windowStartMillis + bucketTimeMillis,\n+ *      where bucketTime can be provided in the taskConfigs (default 1d)\n+ *  - If the execution window is not older than bufferTimeMillis, no task will be generated,\n+ *      where bufferTime can be provided in the taskConfigs (default 2d)\n+ *  - Segment metadata is scanned for all COMPLETED segments, to pick those containing data in window [windowStartMillis, windowEndMillis)\n+ *  - A PinotTaskConfig is created, with segment information, execution window, and any config specific to the task\n+ */\n+public class RealtimeToOfflineSegmentsTaskGenerator implements PinotTaskGenerator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskGenerator.class);\n+\n+  private static final String DEFAULT_BUCKET_PERIOD = \"1d\";\n+  private static final String DEFAULT_BUFFER_PERIOD = \"2d\";\n+\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RealtimeToOfflineSegmentsTaskGenerator(ClusterInfoProvider clusterInfoProvider) {\n+    _clusterInfoProvider = clusterInfoProvider;\n+  }\n+\n+  @Override\n+  public String getTaskType() {\n+    return RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+  }\n+\n+  @Override\n+  public List<PinotTaskConfig> generateTasks(List<TableConfig> tableConfigs) {\n+    String taskType = RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+    List<PinotTaskConfig> pinotTaskConfigs = new ArrayList<>();\n+\n+    for (TableConfig tableConfig : tableConfigs) {\n+      String tableName = tableConfig.getTableName();\n+\n+      if (tableConfig.getTableType() != TableType.REALTIME) {\n+        LOGGER.warn(\"Skip generating task: {} for non-REALTIME table: {}\", taskType, tableName);\n+        continue;\n+      }\n+      LOGGER.info(\"Start generating task configs for table: {} for task: {}\", tableName, taskType);\n+\n+      String rawTableName = TableNameBuilder.extractRawTableName(tableName);\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+\n+      // Only schedule 1 task of this type, per table\n+      Map<String, TaskState> nonCompletedTasks =\n+          TaskGeneratorUtils.getNonCompletedTasks(taskType, realtimeTableName, _clusterInfoProvider);\n+      if (!nonCompletedTasks.isEmpty()) {\n+        LOGGER.warn(\"Found non-completed tasks: {} for same table: {}. Skipping task generation.\",\n+            nonCompletedTasks.keySet(), realtimeTableName);\n+        continue;\n+      }\n+\n+      // Get all completed segment metadata.\n+      List<LLCRealtimeSegmentZKMetadata> completedSegmentsMetadata = new ArrayList<>();", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3Nzc4MA==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r506777780", "bodyText": "Done", "author": "npawar", "createdAt": "2020-10-17T01:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTI5NDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1NjUwMg==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505756502", "bodyText": "This class does not need to be json compatible, as we always read/write it through ZNRecord", "author": "Jackie-Jiang", "createdAt": "2020-10-15T18:31:17Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/minion/RealtimeToOfflineSegmentsTaskMetadata.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.minion;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import org.apache.helix.ZNRecord;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+\n+/**\n+ * Metadata for the minion task of type <code>realtimeToOfflineSegmentsTask</code>.\n+ * The <code>watermarkMillis</code> denotes the time (exclusive) upto which tasks have been executed.\n+ *\n+ * This gets serialized and stored in zookeeper under the path MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *\n+ * PinotTaskGenerator:\n+ * The <code>watermarkMillis</code>> is used by the <code>RealtimeToOfflineSegmentsTaskGenerator</code>,\n+ * to determine the window of execution for the task it is generating.\n+ * The window of execution will be [watermarkMillis, watermarkMillis + bucketSize)\n+ *\n+ * PinotTaskExecutor:\n+ * The same watermark is used by the <code>RealtimeToOfflineSegmentsTaskExecutor</code>, to:\n+ * - Verify that is is running the latest task scheduled by the task generator\n+ * - Update the watermark as the end of the window that it executed for\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1Nzg5Nw==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505757897", "bodyText": "Should we change this to final and make the metadata immutable?", "author": "Jackie-Jiang", "createdAt": "2020-10-15T18:33:48Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/minion/RealtimeToOfflineSegmentsTaskMetadata.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.minion;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import org.apache.helix.ZNRecord;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+\n+/**\n+ * Metadata for the minion task of type <code>realtimeToOfflineSegmentsTask</code>.\n+ * The <code>watermarkMillis</code> denotes the time (exclusive) upto which tasks have been executed.\n+ *\n+ * This gets serialized and stored in zookeeper under the path MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *\n+ * PinotTaskGenerator:\n+ * The <code>watermarkMillis</code>> is used by the <code>RealtimeToOfflineSegmentsTaskGenerator</code>,\n+ * to determine the window of execution for the task it is generating.\n+ * The window of execution will be [watermarkMillis, watermarkMillis + bucketSize)\n+ *\n+ * PinotTaskExecutor:\n+ * The same watermark is used by the <code>RealtimeToOfflineSegmentsTaskExecutor</code>, to:\n+ * - Verify that is is running the latest task scheduled by the task generator\n+ * - Update the watermark as the end of the window that it executed for\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class RealtimeToOfflineSegmentsTaskMetadata {\n+\n+  private static final String WATERMARK_KEY = \"watermarkMillis\";\n+\n+  private final String _tableNameWithType;\n+  private long _watermarkMillis;", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc2MzIyMg==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505763222", "bodyText": "Let's not put writing method in this class. This class should only contain methods of reading metadata", "author": "Jackie-Jiang", "createdAt": "2020-10-15T18:43:03Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/ClusterInfoProvider.java", "diffHunk": "@@ -93,6 +97,38 @@ public Schema getTableSchema(String tableName) {\n         .getRealtimeSegmentZKMetadataListForTable(_pinotHelixResourceManager.getPropertyStore(), tableName);\n   }\n \n+  /**\n+   * Get all segment metadata for the given lowlevel REALTIME table name.\n+   *\n+   * @param tableName Table name with or without REALTIME type suffix\n+   * @return List of segment metadata\n+   */\n+  public List<LLCRealtimeSegmentZKMetadata> getLLCRealtimeSegmentsMetadata(String tableName) {\n+    return ZKMetadataProvider\n+        .getLLCRealtimeSegmentZKMetadataListForTable(_pinotHelixResourceManager.getPropertyStore(), tableName);\n+  }\n+\n+  /**\n+   * Fetches the {@link RealtimeToOfflineSegmentsTaskMetadata} from MINION_TASK_METADATA for given realtime table\n+   * @param tableNameWithType realtime table name\n+   */\n+  public RealtimeToOfflineSegmentsTaskMetadata getMinionRealtimeToOfflineSegmentsTaskMetadata(\n+      String tableNameWithType) {\n+    return MinionTaskMetadataUtils\n+        .getRealtimeToOfflineSegmentsTaskMetadata(_pinotHelixResourceManager.getPropertyStore(),\n+            MinionConstants.RealtimeToOfflineSegmentsTask.TASK_TYPE, tableNameWithType);\n+  }\n+\n+  /**\n+   * Sets the {@link RealtimeToOfflineSegmentsTaskMetadata} into MINION_TASK_METADATA\n+   * This call will override any previous metadata node\n+   */\n+  public void setRealtimeToOfflineSegmentsTaskMetadata(", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3Nzg0Ng==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r506777846", "bodyText": "Created a parallel class, ClusterUpdater, and moved the updater method into that. Lmk if that approach is fine", "author": "npawar", "createdAt": "2020-10-17T01:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc2MzIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc2NjA4Ng==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505766086", "bodyText": "(nit) No need to extract raw table name\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  String tableName = tableConfig.getTableName();\n          \n          \n            \n            \n          \n          \n            \n                  if (tableConfig.getTableType() != TableType.REALTIME) {\n          \n          \n            \n                    LOGGER.warn(\"Skip generating task: {} for non-REALTIME table: {}\", taskType, tableName);\n          \n          \n            \n                    continue;\n          \n          \n            \n                  }\n          \n          \n            \n                  LOGGER.info(\"Start generating task configs for table: {} for task: {}\", tableName, taskType);\n          \n          \n            \n            \n          \n          \n            \n                  String rawTableName = TableNameBuilder.extractRawTableName(tableName);\n          \n          \n            \n                  String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n          \n          \n            \n                  String realtimeTableName = tableConfig.getTableName();\n          \n          \n            \n            \n          \n          \n            \n                  if (tableConfig.getTableType() != TableType.REALTIME) {\n          \n          \n            \n                    LOGGER.warn(\"Skip generating task: {} for non-REALTIME table: {}\", taskType, realtimeTableName);\n          \n          \n            \n                    continue;\n          \n          \n            \n                  }\n          \n          \n            \n                  LOGGER.info(\"Start generating task configs for table: {} for task: {}\", realtimeTableName, taskType);", "author": "Jackie-Jiang", "createdAt": "2020-10-15T18:48:27Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/RealtimeToOfflineSegmentsTaskGenerator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion.generator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants.Segment;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.controller.helix.core.minion.ClusterInfoProvider;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.common.MinionConstants.RealtimeToOfflineSegmentsTask;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.TimeUtils;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link PinotTaskGenerator} implementation for generating tasks of type {@link RealtimeToOfflineSegmentsTask}\n+ *\n+ * These will be generated only for REALTIME tables.\n+ * At any given time, only 1 task of this type should be generated for a table.\n+ *\n+ * Steps:\n+ *  - The watermarkMillis is read from the {@link RealtimeToOfflineSegmentsTaskMetadata} ZNode found at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *      In case of cold-start, no ZNode will exist.\n+ *      A new ZNode will be created, with watermarkMillis as the smallest time found in the COMPLETED segments (or using start time config)\n+ *  - The execution window for the task is calculated as, windowStartMillis = waterMarkMillis, windowEndMillis = windowStartMillis + bucketTimeMillis,\n+ *      where bucketTime can be provided in the taskConfigs (default 1d)\n+ *  - If the execution window is not older than bufferTimeMillis, no task will be generated,\n+ *      where bufferTime can be provided in the taskConfigs (default 2d)\n+ *  - Segment metadata is scanned for all COMPLETED segments, to pick those containing data in window [windowStartMillis, windowEndMillis)\n+ *  - A PinotTaskConfig is created, with segment information, execution window, and any config specific to the task\n+ */\n+public class RealtimeToOfflineSegmentsTaskGenerator implements PinotTaskGenerator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskGenerator.class);\n+\n+  private static final String DEFAULT_BUCKET_PERIOD = \"1d\";\n+  private static final String DEFAULT_BUFFER_PERIOD = \"2d\";\n+\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RealtimeToOfflineSegmentsTaskGenerator(ClusterInfoProvider clusterInfoProvider) {\n+    _clusterInfoProvider = clusterInfoProvider;\n+  }\n+\n+  @Override\n+  public String getTaskType() {\n+    return RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+  }\n+\n+  @Override\n+  public List<PinotTaskConfig> generateTasks(List<TableConfig> tableConfigs) {\n+    String taskType = RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+    List<PinotTaskConfig> pinotTaskConfigs = new ArrayList<>();\n+\n+    for (TableConfig tableConfig : tableConfigs) {\n+      String tableName = tableConfig.getTableName();\n+\n+      if (tableConfig.getTableType() != TableType.REALTIME) {\n+        LOGGER.warn(\"Skip generating task: {} for non-REALTIME table: {}\", taskType, tableName);\n+        continue;\n+      }\n+      LOGGER.info(\"Start generating task configs for table: {} for task: {}\", tableName, taskType);\n+\n+      String rawTableName = TableNameBuilder.extractRawTableName(tableName);\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc3NjgyMA==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505776820", "bodyText": "Also skip HLC table here?", "author": "Jackie-Jiang", "createdAt": "2020-10-15T19:08:01Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/RealtimeToOfflineSegmentsTaskGenerator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion.generator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants.Segment;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.controller.helix.core.minion.ClusterInfoProvider;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.common.MinionConstants.RealtimeToOfflineSegmentsTask;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.TimeUtils;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link PinotTaskGenerator} implementation for generating tasks of type {@link RealtimeToOfflineSegmentsTask}\n+ *\n+ * These will be generated only for REALTIME tables.\n+ * At any given time, only 1 task of this type should be generated for a table.\n+ *\n+ * Steps:\n+ *  - The watermarkMillis is read from the {@link RealtimeToOfflineSegmentsTaskMetadata} ZNode found at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *      In case of cold-start, no ZNode will exist.\n+ *      A new ZNode will be created, with watermarkMillis as the smallest time found in the COMPLETED segments (or using start time config)\n+ *  - The execution window for the task is calculated as, windowStartMillis = waterMarkMillis, windowEndMillis = windowStartMillis + bucketTimeMillis,\n+ *      where bucketTime can be provided in the taskConfigs (default 1d)\n+ *  - If the execution window is not older than bufferTimeMillis, no task will be generated,\n+ *      where bufferTime can be provided in the taskConfigs (default 2d)\n+ *  - Segment metadata is scanned for all COMPLETED segments, to pick those containing data in window [windowStartMillis, windowEndMillis)\n+ *  - A PinotTaskConfig is created, with segment information, execution window, and any config specific to the task\n+ */\n+public class RealtimeToOfflineSegmentsTaskGenerator implements PinotTaskGenerator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskGenerator.class);\n+\n+  private static final String DEFAULT_BUCKET_PERIOD = \"1d\";\n+  private static final String DEFAULT_BUFFER_PERIOD = \"2d\";\n+\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RealtimeToOfflineSegmentsTaskGenerator(ClusterInfoProvider clusterInfoProvider) {\n+    _clusterInfoProvider = clusterInfoProvider;\n+  }\n+\n+  @Override\n+  public String getTaskType() {\n+    return RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+  }\n+\n+  @Override\n+  public List<PinotTaskConfig> generateTasks(List<TableConfig> tableConfigs) {\n+    String taskType = RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+    List<PinotTaskConfig> pinotTaskConfigs = new ArrayList<>();\n+\n+    for (TableConfig tableConfig : tableConfigs) {\n+      String tableName = tableConfig.getTableName();\n+\n+      if (tableConfig.getTableType() != TableType.REALTIME) {\n+        LOGGER.warn(\"Skip generating task: {} for non-REALTIME table: {}\", taskType, tableName);\n+        continue;\n+      }", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyNjA3MQ==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505826071", "bodyText": "Reformat this part of the javadoc (keep each line less than 120 characters)", "author": "Jackie-Jiang", "createdAt": "2020-10-15T20:36:38Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/RealtimeToOfflineSegmentsTaskGenerator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion.generator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants.Segment;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.controller.helix.core.minion.ClusterInfoProvider;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.common.MinionConstants.RealtimeToOfflineSegmentsTask;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.TimeUtils;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link PinotTaskGenerator} implementation for generating tasks of type {@link RealtimeToOfflineSegmentsTask}\n+ *\n+ * These will be generated only for REALTIME tables.\n+ * At any given time, only 1 task of this type should be generated for a table.\n+ *\n+ * Steps:\n+ *  - The watermarkMillis is read from the {@link RealtimeToOfflineSegmentsTaskMetadata} ZNode found at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMDM1OA==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505830358", "bodyText": "Do we need this config? This config can cause inconsistent query result when pushing the first offline segments, where the old real-time records that are not merged will be skipped.\nIs there any use case we want to configure this value?", "author": "Jackie-Jiang", "createdAt": "2020-10-15T20:42:03Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/MinionConstants.java", "diffHunk": "@@ -62,16 +62,35 @@ private MinionConstants() {\n     public static final String MERGED_SEGMENT_NAME_KEY = \"mergedSegmentNameKey\";\n   }\n \n+  /**\n+   * Creates segments for the OFFLINE table, using completed segments from the corresponding REALTIME table\n+   */\n   public static class RealtimeToOfflineSegmentsTask {\n     public static final String TASK_TYPE = \"realtimeToOfflineSegmentsTask\";\n-    // window\n+\n+    /**\n+     * The time window size for the task.\n+     * e.g. if set to \"1d\", then task is scheduled to run for a 1 day window\n+     */\n+    public static final String BUCKET_TIME_PERIOD_KEY = \"bucketTimePeriod\";\n+    /**\n+     * The time period to wait before picking segments for this task\n+     * e.g. if set to \"2d\", no task will be scheduled for a time window younger than 2 days\n+     */\n+    public static final String BUFFER_TIME_PERIOD_KEY = \"bufferTimePeriod\";\n+    /**\n+     * Config to manually provide start time for the very first task scheduled.\n+     * In the absence of this config, the very first window start is calculated as min(start time of all completed segments)\n+     */\n+    public static final String START_TIME_MILLIS_KEY = \"startTimeMillis\";", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3Nzk0NQ==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r506777945", "bodyText": "Probably not needed. Removed it", "author": "npawar", "createdAt": "2020-10-17T01:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMDM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMjQ3NQ==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505832475", "bodyText": "Do we do filtering before the transformation? Can filter be applied to the transformed columns?", "author": "Jackie-Jiang", "createdAt": "2020-10-15T20:44:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/processing/framework/SegmentMapper.java", "diffHunk": "@@ -101,14 +101,14 @@ public void map()\n     while (segmentRecordReader.hasNext()) {\n       reusableRow = segmentRecordReader.next(reusableRow);\n \n-      // Record transformation\n-      reusableRow = _recordTransformer.transformRecord(reusableRow);\n-\n       // Record filtering\n       if (_recordFilter.filter(reusableRow)) {\n         continue;\n       }\n \n+      // Record transformation", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMzU1MA==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505833550", "bodyText": "Is this related to this PR?", "author": "Jackie-Jiang", "createdAt": "2020-10-15T20:45:46Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/processing/framework/SegmentMapperTest.java", "diffHunk": "@@ -275,7 +275,7 @@ public void segmentMapperTest(String mapperId, SegmentMapperConfig segmentMapper\n     SegmentMapperConfig config11 = new SegmentMapperConfig(_pinotSchema,\n         new RecordTransformerConfig.Builder().setTransformFunctionsMap(transformFunctionMap).build(),\n         new RecordFilterConfig.Builder().setRecordFilterType(RecordFilterFactory.RecordFilterType.FILTER_FUNCTION)\n-            .setFilterFunction(\"Groovy({timeValue != 1597795200000}, timeValue)\").build(), Lists.newArrayList(\n+            .setFilterFunction(\"Groovy({timeValue < 1597795200000L|| timeValue >= 1597881600000}, timeValue)\").build(), Lists.newArrayList(", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3ODE3Nw==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r506778177", "bodyText": "This is due to changing filtering to be before transform.\nMoved filtering to before transform, because I realized while testing, that is transform happens before, user has to be aware of resulting values and apply filter accordingly.\nI feel filter then transform makes more sense.\nIf someone wants filter to apply to transformed column, they can include the transformation in the filter function", "author": "npawar", "createdAt": "2020-10-17T01:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMzU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNjUzMg==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505836532", "bodyText": "Also skip the old tasks?", "author": "Jackie-Jiang", "createdAt": "2020-10-15T20:49:08Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/TaskGeneratorUtils.java", "diffHunk": "@@ -68,4 +69,26 @@\n     }\n     return runningSegments;\n   }\n+\n+  /**\n+   * Gets all the tasks for the provided task type and tableName, which do not have TaskState COMPLETED\n+   * @return map containing task name to task state for non-completed tasks\n+   */\n+  public static Map<String, TaskState> getNonCompletedTasks(String taskType, String tableNameWithType,\n+      ClusterInfoProvider clusterInfoProvider) {\n+\n+    Map<String, TaskState> nonCompletedTasks = new HashMap<>();\n+    Map<String, TaskState> taskStates = clusterInfoProvider.getTaskStates(taskType);\n+    for (Map.Entry<String, TaskState> entry : taskStates.entrySet()) {\n+      if (entry.getValue() == TaskState.COMPLETED) {\n+        continue;\n+      }", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0NjI5Nw==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505846297", "bodyText": "I don't think we should put preProcess() and postProcess() into the interface. You can still keep them in the RealtimeToOfflineSegmentsTaskExecutor for better organization of the code.", "author": "Jackie-Jiang", "createdAt": "2020-10-15T21:00:50Z", "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/PinotTaskExecutor.java", "diffHunk": "@@ -26,6 +26,12 @@\n  */\n public interface PinotTaskExecutor {\n \n+  /**\n+   * Pre processing operations to be done at the beginning of task execution\n+   */\n+  default void preProcess(PinotTaskConfig pinotTaskConfig) {", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0NzgzNw==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505847837", "bodyText": "Put Integer.MIN_VALUE as the default? We don't want to override the ZNRecord if this is not correctly set", "author": "Jackie-Jiang", "createdAt": "2020-10-15T21:02:43Z", "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -54,17 +57,60 @@\n  * A task to convert segments from a REALTIME table to segments for its corresponding OFFLINE table.\n  * The realtime segments could span across multiple time windows. This task extracts data and creates segments for a configured time range.\n  * The {@link SegmentProcessorFramework} is used for the segment conversion, which also does\n- * 1. time column rollup\n- * 2. time window extraction using filter function\n+ * 1. time window extraction using filter function\n+ * 2. time column rollup\n  * 3. partitioning using table config's segmentPartitioningConfig\n  * 4. aggregations and rollup\n  * 5. data sorting\n+ *\n+ * Before beginning the task, the <code>watermarkMillis</code> is checked in the minion task metadata ZNode, located at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/<tableNameWithType>\n+ * It should match the <code>windowStartMillis</code>.\n+ * The version of the znode is cached.\n+ *\n+ * After the segments are uploaded, this task updates the <code>watermarkMillis</code> in the minion task metadata ZNode.\n+ * The znode version is checked during update, and update only succeeds if version matches with the previously cached version\n  */\n public class RealtimeToOfflineSegmentsTaskExecutor extends BaseMultipleSegmentsConversionExecutor {\n   private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskExecutor.class);\n   private static final String INPUT_SEGMENTS_DIR = \"input_segments\";\n   private static final String OUTPUT_SEGMENTS_DIR = \"output_segments\";\n \n+  private final MinionTaskZkMetadataManager _minionTaskZkMetadataManager;\n+  private int _expectedVersion = -1;", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg1MjE1MQ==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505852151", "bodyText": "No need to check version again, the setRealtimeToOfflineSegmentsTaskMetadata() can perform the version check", "author": "Jackie-Jiang", "createdAt": "2020-10-15T21:07:38Z", "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/RealtimeToOfflineSegmentsTaskExecutor.java", "diffHunk": "@@ -162,11 +212,34 @@\n     for (File file : outputSegmentsDir.listFiles()) {\n       String outputSegmentName = file.getName();\n       results.add(new SegmentConversionResult.Builder().setFile(file).setSegmentName(outputSegmentName)\n-          .setTableNameWithType(tableNameWithType).build());\n+          .setTableNameWithType(offlineTableName).build());\n     }\n     return results;\n   }\n \n+  /**\n+   * Fetches the realtimeToOfflineSegmentsTask metadata ZNode for the realtime table.\n+   * Checks that the version of the ZNode matches with the version cached earlier. If yes, proceeds to update watermark in the ZNode\n+   * TODO: Making the minion task update the ZK metadata is an anti-pattern, however cannot another way to do it\n+   */\n+  @Override\n+  public void postProcess(PinotTaskConfig pinotTaskConfig) {\n+    String realtimeTableName = pinotTaskConfig.getConfigs().get(MinionConstants.TABLE_NAME_KEY);\n+\n+    ZNRecord realtimeToOfflineSegmentsTaskRecord =", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwMTI0Ng==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505901246", "bodyText": "Same for other Millis\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  long bucketMillis = TimeUtils.convertPeriodToMillis(bucketTimeStr);\n          \n          \n            \n                  long bufferMillis = TimeUtils.convertPeriodToMillis(bufferTimeStr);\n          \n          \n            \n                  long bucketTimeMs = TimeUtils.convertPeriodToMillis(bucketTimeStr);\n          \n          \n            \n                  long bufferTimeMs = TimeUtils.convertPeriodToMillis(bufferTimeStr);", "author": "Jackie-Jiang", "createdAt": "2020-10-15T22:32:34Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/RealtimeToOfflineSegmentsTaskGenerator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion.generator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants.Segment;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.controller.helix.core.minion.ClusterInfoProvider;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.common.MinionConstants.RealtimeToOfflineSegmentsTask;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.TimeUtils;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link PinotTaskGenerator} implementation for generating tasks of type {@link RealtimeToOfflineSegmentsTask}\n+ *\n+ * These will be generated only for REALTIME tables.\n+ * At any given time, only 1 task of this type should be generated for a table.\n+ *\n+ * Steps:\n+ *  - The watermarkMillis is read from the {@link RealtimeToOfflineSegmentsTaskMetadata} ZNode found at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *      In case of cold-start, no ZNode will exist.\n+ *      A new ZNode will be created, with watermarkMillis as the smallest time found in the COMPLETED segments (or using start time config)\n+ *  - The execution window for the task is calculated as, windowStartMillis = waterMarkMillis, windowEndMillis = windowStartMillis + bucketTimeMillis,\n+ *      where bucketTime can be provided in the taskConfigs (default 1d)\n+ *  - If the execution window is not older than bufferTimeMillis, no task will be generated,\n+ *      where bufferTime can be provided in the taskConfigs (default 2d)\n+ *  - Segment metadata is scanned for all COMPLETED segments, to pick those containing data in window [windowStartMillis, windowEndMillis)\n+ *  - A PinotTaskConfig is created, with segment information, execution window, and any config specific to the task\n+ */\n+public class RealtimeToOfflineSegmentsTaskGenerator implements PinotTaskGenerator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskGenerator.class);\n+\n+  private static final String DEFAULT_BUCKET_PERIOD = \"1d\";\n+  private static final String DEFAULT_BUFFER_PERIOD = \"2d\";\n+\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RealtimeToOfflineSegmentsTaskGenerator(ClusterInfoProvider clusterInfoProvider) {\n+    _clusterInfoProvider = clusterInfoProvider;\n+  }\n+\n+  @Override\n+  public String getTaskType() {\n+    return RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+  }\n+\n+  @Override\n+  public List<PinotTaskConfig> generateTasks(List<TableConfig> tableConfigs) {\n+    String taskType = RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+    List<PinotTaskConfig> pinotTaskConfigs = new ArrayList<>();\n+\n+    for (TableConfig tableConfig : tableConfigs) {\n+      String tableName = tableConfig.getTableName();\n+\n+      if (tableConfig.getTableType() != TableType.REALTIME) {\n+        LOGGER.warn(\"Skip generating task: {} for non-REALTIME table: {}\", taskType, tableName);\n+        continue;\n+      }\n+      LOGGER.info(\"Start generating task configs for table: {} for task: {}\", tableName, taskType);\n+\n+      String rawTableName = TableNameBuilder.extractRawTableName(tableName);\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+\n+      // Only schedule 1 task of this type, per table\n+      Map<String, TaskState> nonCompletedTasks =\n+          TaskGeneratorUtils.getNonCompletedTasks(taskType, realtimeTableName, _clusterInfoProvider);\n+      if (!nonCompletedTasks.isEmpty()) {\n+        LOGGER.warn(\"Found non-completed tasks: {} for same table: {}. Skipping task generation.\",\n+            nonCompletedTasks.keySet(), realtimeTableName);\n+        continue;\n+      }\n+\n+      // Get all completed segment metadata.\n+      List<LLCRealtimeSegmentZKMetadata> completedSegmentsMetadata = new ArrayList<>();\n+      Map<Integer, String> partitionToLatestCompletedSegmentName = new HashMap<>();\n+      Set<Integer> allPartitions = new HashSet<>();\n+      getCompletedSegmentsInfo(realtimeTableName, completedSegmentsMetadata, partitionToLatestCompletedSegmentName,\n+          allPartitions);\n+      if (completedSegmentsMetadata.isEmpty()) {\n+        LOGGER\n+            .info(\"No realtime completed segments found for table: {}, skipping task generation: {}\", realtimeTableName,\n+                taskType);\n+        continue;\n+      }\n+      allPartitions.removeAll(partitionToLatestCompletedSegmentName.keySet());\n+      if (!allPartitions.isEmpty()) {\n+        LOGGER\n+            .info(\"Partitions: {} have no completed segments. Table: {} is not ready for {}. Skipping task generation.\",\n+                allPartitions, realtimeTableName, taskType);\n+        continue;\n+      }\n+\n+      TableTaskConfig tableTaskConfig = tableConfig.getTaskConfig();\n+      Preconditions.checkState(tableTaskConfig != null);\n+      Map<String, String> taskConfigs = tableTaskConfig.getConfigsForTaskType(taskType);\n+      Preconditions.checkState(taskConfigs != null, \"Task config shouldn't be null for table: {}\", tableName);\n+\n+      // Get the bucket size and buffer\n+      String bucketTimeStr =\n+          taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUCKET_TIME_PERIOD_KEY, DEFAULT_BUCKET_PERIOD);\n+      String bufferTimeStr =\n+          taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUFFER_TIME_PERIOD_KEY, DEFAULT_BUFFER_PERIOD);\n+      String startTimeStr = taskConfigs.get(RealtimeToOfflineSegmentsTask.START_TIME_MILLIS_KEY);\n+      long bucketMillis = TimeUtils.convertPeriodToMillis(bucketTimeStr);\n+      long bufferMillis = TimeUtils.convertPeriodToMillis(bufferTimeStr);", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwMTQyMw==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505901423", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  String bucketTimeStr =\n          \n          \n            \n                      taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUCKET_TIME_PERIOD_KEY, DEFAULT_BUCKET_PERIOD);\n          \n          \n            \n                  String bufferTimeStr =\n          \n          \n            \n                      taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUFFER_TIME_PERIOD_KEY, DEFAULT_BUFFER_PERIOD);\n          \n          \n            \n                  String bucketTimePeriod =\n          \n          \n            \n                      taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUCKET_TIME_PERIOD_KEY, DEFAULT_BUCKET_PERIOD);\n          \n          \n            \n                  String bufferTimePeriod =\n          \n          \n            \n                      taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUFFER_TIME_PERIOD_KEY, DEFAULT_BUFFER_PERIOD);", "author": "Jackie-Jiang", "createdAt": "2020-10-15T22:33:05Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/RealtimeToOfflineSegmentsTaskGenerator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion.generator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants.Segment;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.controller.helix.core.minion.ClusterInfoProvider;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.common.MinionConstants.RealtimeToOfflineSegmentsTask;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.TimeUtils;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link PinotTaskGenerator} implementation for generating tasks of type {@link RealtimeToOfflineSegmentsTask}\n+ *\n+ * These will be generated only for REALTIME tables.\n+ * At any given time, only 1 task of this type should be generated for a table.\n+ *\n+ * Steps:\n+ *  - The watermarkMillis is read from the {@link RealtimeToOfflineSegmentsTaskMetadata} ZNode found at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *      In case of cold-start, no ZNode will exist.\n+ *      A new ZNode will be created, with watermarkMillis as the smallest time found in the COMPLETED segments (or using start time config)\n+ *  - The execution window for the task is calculated as, windowStartMillis = waterMarkMillis, windowEndMillis = windowStartMillis + bucketTimeMillis,\n+ *      where bucketTime can be provided in the taskConfigs (default 1d)\n+ *  - If the execution window is not older than bufferTimeMillis, no task will be generated,\n+ *      where bufferTime can be provided in the taskConfigs (default 2d)\n+ *  - Segment metadata is scanned for all COMPLETED segments, to pick those containing data in window [windowStartMillis, windowEndMillis)\n+ *  - A PinotTaskConfig is created, with segment information, execution window, and any config specific to the task\n+ */\n+public class RealtimeToOfflineSegmentsTaskGenerator implements PinotTaskGenerator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskGenerator.class);\n+\n+  private static final String DEFAULT_BUCKET_PERIOD = \"1d\";\n+  private static final String DEFAULT_BUFFER_PERIOD = \"2d\";\n+\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RealtimeToOfflineSegmentsTaskGenerator(ClusterInfoProvider clusterInfoProvider) {\n+    _clusterInfoProvider = clusterInfoProvider;\n+  }\n+\n+  @Override\n+  public String getTaskType() {\n+    return RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+  }\n+\n+  @Override\n+  public List<PinotTaskConfig> generateTasks(List<TableConfig> tableConfigs) {\n+    String taskType = RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+    List<PinotTaskConfig> pinotTaskConfigs = new ArrayList<>();\n+\n+    for (TableConfig tableConfig : tableConfigs) {\n+      String tableName = tableConfig.getTableName();\n+\n+      if (tableConfig.getTableType() != TableType.REALTIME) {\n+        LOGGER.warn(\"Skip generating task: {} for non-REALTIME table: {}\", taskType, tableName);\n+        continue;\n+      }\n+      LOGGER.info(\"Start generating task configs for table: {} for task: {}\", tableName, taskType);\n+\n+      String rawTableName = TableNameBuilder.extractRawTableName(tableName);\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+\n+      // Only schedule 1 task of this type, per table\n+      Map<String, TaskState> nonCompletedTasks =\n+          TaskGeneratorUtils.getNonCompletedTasks(taskType, realtimeTableName, _clusterInfoProvider);\n+      if (!nonCompletedTasks.isEmpty()) {\n+        LOGGER.warn(\"Found non-completed tasks: {} for same table: {}. Skipping task generation.\",\n+            nonCompletedTasks.keySet(), realtimeTableName);\n+        continue;\n+      }\n+\n+      // Get all completed segment metadata.\n+      List<LLCRealtimeSegmentZKMetadata> completedSegmentsMetadata = new ArrayList<>();\n+      Map<Integer, String> partitionToLatestCompletedSegmentName = new HashMap<>();\n+      Set<Integer> allPartitions = new HashSet<>();\n+      getCompletedSegmentsInfo(realtimeTableName, completedSegmentsMetadata, partitionToLatestCompletedSegmentName,\n+          allPartitions);\n+      if (completedSegmentsMetadata.isEmpty()) {\n+        LOGGER\n+            .info(\"No realtime completed segments found for table: {}, skipping task generation: {}\", realtimeTableName,\n+                taskType);\n+        continue;\n+      }\n+      allPartitions.removeAll(partitionToLatestCompletedSegmentName.keySet());\n+      if (!allPartitions.isEmpty()) {\n+        LOGGER\n+            .info(\"Partitions: {} have no completed segments. Table: {} is not ready for {}. Skipping task generation.\",\n+                allPartitions, realtimeTableName, taskType);\n+        continue;\n+      }\n+\n+      TableTaskConfig tableTaskConfig = tableConfig.getTaskConfig();\n+      Preconditions.checkState(tableTaskConfig != null);\n+      Map<String, String> taskConfigs = tableTaskConfig.getConfigsForTaskType(taskType);\n+      Preconditions.checkState(taskConfigs != null, \"Task config shouldn't be null for table: {}\", tableName);\n+\n+      // Get the bucket size and buffer\n+      String bucketTimeStr =\n+          taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUCKET_TIME_PERIOD_KEY, DEFAULT_BUCKET_PERIOD);\n+      String bufferTimeStr =\n+          taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUFFER_TIME_PERIOD_KEY, DEFAULT_BUFFER_PERIOD);", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwNDMyMw==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r505904323", "bodyText": "+1", "author": "Jackie-Jiang", "createdAt": "2020-10-15T22:41:11Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/generator/RealtimeToOfflineSegmentsTaskGenerator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion.generator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.LLCRealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants.Segment;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.controller.helix.core.minion.ClusterInfoProvider;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.core.common.MinionConstants.RealtimeToOfflineSegmentsTask;\n+import org.apache.pinot.core.minion.PinotTaskConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.TimeUtils;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A {@link PinotTaskGenerator} implementation for generating tasks of type {@link RealtimeToOfflineSegmentsTask}\n+ *\n+ * These will be generated only for REALTIME tables.\n+ * At any given time, only 1 task of this type should be generated for a table.\n+ *\n+ * Steps:\n+ *  - The watermarkMillis is read from the {@link RealtimeToOfflineSegmentsTaskMetadata} ZNode found at MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWithType\n+ *      In case of cold-start, no ZNode will exist.\n+ *      A new ZNode will be created, with watermarkMillis as the smallest time found in the COMPLETED segments (or using start time config)\n+ *  - The execution window for the task is calculated as, windowStartMillis = waterMarkMillis, windowEndMillis = windowStartMillis + bucketTimeMillis,\n+ *      where bucketTime can be provided in the taskConfigs (default 1d)\n+ *  - If the execution window is not older than bufferTimeMillis, no task will be generated,\n+ *      where bufferTime can be provided in the taskConfigs (default 2d)\n+ *  - Segment metadata is scanned for all COMPLETED segments, to pick those containing data in window [windowStartMillis, windowEndMillis)\n+ *  - A PinotTaskConfig is created, with segment information, execution window, and any config specific to the task\n+ */\n+public class RealtimeToOfflineSegmentsTaskGenerator implements PinotTaskGenerator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RealtimeToOfflineSegmentsTaskGenerator.class);\n+\n+  private static final String DEFAULT_BUCKET_PERIOD = \"1d\";\n+  private static final String DEFAULT_BUFFER_PERIOD = \"2d\";\n+\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RealtimeToOfflineSegmentsTaskGenerator(ClusterInfoProvider clusterInfoProvider) {\n+    _clusterInfoProvider = clusterInfoProvider;\n+  }\n+\n+  @Override\n+  public String getTaskType() {\n+    return RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+  }\n+\n+  @Override\n+  public List<PinotTaskConfig> generateTasks(List<TableConfig> tableConfigs) {\n+    String taskType = RealtimeToOfflineSegmentsTask.TASK_TYPE;\n+    List<PinotTaskConfig> pinotTaskConfigs = new ArrayList<>();\n+\n+    for (TableConfig tableConfig : tableConfigs) {\n+      String tableName = tableConfig.getTableName();\n+\n+      if (tableConfig.getTableType() != TableType.REALTIME) {\n+        LOGGER.warn(\"Skip generating task: {} for non-REALTIME table: {}\", taskType, tableName);\n+        continue;\n+      }\n+      LOGGER.info(\"Start generating task configs for table: {} for task: {}\", tableName, taskType);\n+\n+      String rawTableName = TableNameBuilder.extractRawTableName(tableName);\n+      String realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(rawTableName);\n+\n+      // Only schedule 1 task of this type, per table\n+      Map<String, TaskState> nonCompletedTasks =\n+          TaskGeneratorUtils.getNonCompletedTasks(taskType, realtimeTableName, _clusterInfoProvider);\n+      if (!nonCompletedTasks.isEmpty()) {\n+        LOGGER.warn(\"Found non-completed tasks: {} for same table: {}. Skipping task generation.\",\n+            nonCompletedTasks.keySet(), realtimeTableName);\n+        continue;\n+      }\n+\n+      // Get all completed segment metadata.\n+      List<LLCRealtimeSegmentZKMetadata> completedSegmentsMetadata = new ArrayList<>();\n+      Map<Integer, String> partitionToLatestCompletedSegmentName = new HashMap<>();\n+      Set<Integer> allPartitions = new HashSet<>();\n+      getCompletedSegmentsInfo(realtimeTableName, completedSegmentsMetadata, partitionToLatestCompletedSegmentName,\n+          allPartitions);\n+      if (completedSegmentsMetadata.isEmpty()) {\n+        LOGGER\n+            .info(\"No realtime completed segments found for table: {}, skipping task generation: {}\", realtimeTableName,\n+                taskType);\n+        continue;\n+      }\n+      allPartitions.removeAll(partitionToLatestCompletedSegmentName.keySet());\n+      if (!allPartitions.isEmpty()) {\n+        LOGGER\n+            .info(\"Partitions: {} have no completed segments. Table: {} is not ready for {}. Skipping task generation.\",\n+                allPartitions, realtimeTableName, taskType);\n+        continue;\n+      }\n+\n+      TableTaskConfig tableTaskConfig = tableConfig.getTaskConfig();\n+      Preconditions.checkState(tableTaskConfig != null);\n+      Map<String, String> taskConfigs = tableTaskConfig.getConfigsForTaskType(taskType);\n+      Preconditions.checkState(taskConfigs != null, \"Task config shouldn't be null for table: {}\", tableName);\n+\n+      // Get the bucket size and buffer\n+      String bucketTimeStr =\n+          taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUCKET_TIME_PERIOD_KEY, DEFAULT_BUCKET_PERIOD);\n+      String bufferTimeStr =\n+          taskConfigs.getOrDefault(RealtimeToOfflineSegmentsTask.BUFFER_TIME_PERIOD_KEY, DEFAULT_BUFFER_PERIOD);\n+      String startTimeStr = taskConfigs.get(RealtimeToOfflineSegmentsTask.START_TIME_MILLIS_KEY);\n+      long bucketMillis = TimeUtils.convertPeriodToMillis(bucketTimeStr);\n+      long bufferMillis = TimeUtils.convertPeriodToMillis(bufferTimeStr);\n+\n+      // Get watermark from RealtimeToOfflineSegmentsTaskMetadata ZNode. WindowStart = watermark. WindowEnd = windowStart + bucket.\n+      long windowStartMillis =\n+          getWatermarkMillis(realtimeTableName, completedSegmentsMetadata, startTimeStr, bucketMillis);\n+      long windowEndMillis = windowStartMillis + bucketMillis;\n+\n+      // Check that execution window is older than bufferTime\n+      if (windowEndMillis > System.currentTimeMillis() - bufferMillis) {\n+        LOGGER.info(\n+            \"Window with start: {} and end: {} is not older than buffer time: {} configured as {} ago. Skipping task generation: {}\",\n+            windowStartMillis, windowEndMillis, bufferMillis, bufferTimeStr, taskType);\n+        continue;\n+      }\n+\n+      // Find all COMPLETED segments with data overlapping execution window: windowStart (inclusive) to windowEnd (exclusive)\n+      List<String> segmentNames = new ArrayList<>();\n+      List<String> downloadURLs = new ArrayList<>();\n+      Set<String> lastCompletedSegmentPerPartition = new HashSet<>(partitionToLatestCompletedSegmentName.values());\n+      boolean skipGenerate = false;\n+      for (LLCRealtimeSegmentZKMetadata realtimeSegmentZKMetadata : completedSegmentsMetadata) {\n+        String segmentName = realtimeSegmentZKMetadata.getSegmentName();\n+        TimeUnit timeUnit = realtimeSegmentZKMetadata.getTimeUnit();\n+        long segmentStartTimeMillis = timeUnit.toMillis(realtimeSegmentZKMetadata.getStartTime());\n+        long segmentEndTimeMillis = timeUnit.toMillis(realtimeSegmentZKMetadata.getEndTime());\n+\n+        // Check overlap with window\n+        if (windowStartMillis <= segmentEndTimeMillis && segmentStartTimeMillis < windowEndMillis) {\n+          // If last completed segment is being used, make sure that segment crosses over end of window.", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MjUxMA==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r506672510", "bodyText": "While I was trying to disable tests by following this class, I found that testReload still gets executed. You need to the following:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void testReload(boolean includeOfflineTable) {\n          \n          \n            \n              public void testReload() {", "author": "snleee", "createdAt": "2020-10-16T19:10:44Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/RealtimeToOfflineSegmentsMinionClusterIntegrationTest.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.integration.tests;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import org.apache.helix.task.TaskState;\n+import org.apache.pinot.common.metadata.segment.OfflineSegmentZKMetadata;\n+import org.apache.pinot.common.metadata.segment.RealtimeSegmentZKMetadata;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.controller.helix.core.PinotHelixResourceManager;\n+import org.apache.pinot.controller.helix.core.minion.PinotHelixTaskResourceManager;\n+import org.apache.pinot.controller.helix.core.minion.PinotTaskManager;\n+import org.apache.pinot.core.common.MinionConstants;\n+import org.apache.pinot.spi.config.table.TableTaskConfig;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.apache.pinot.util.TestUtils;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+/**\n+ * Integration test for minion task of type \"realtimeToOfflineSegmentsTask\"\n+ * With every task run, a new segment is created in the offline table for 1 day. Watermark also keeps progressing accordingly.\n+ */\n+public class RealtimeToOfflineSegmentsMinionClusterIntegrationTest extends RealtimeClusterIntegrationTest {\n+\n+  private PinotHelixTaskResourceManager _helixTaskResourceManager;\n+  private PinotTaskManager _taskManager;\n+  private PinotHelixResourceManager _pinotHelixResourceManager;\n+\n+  private long _dataSmallestTimeMillis;\n+  private long _dateSmallestDays;\n+  private String _realtimeTableName;\n+  private String _offlineTableName;\n+\n+  @Override\n+  protected TableTaskConfig getTaskConfig() {\n+    return new TableTaskConfig(\n+        Collections.singletonMap(MinionConstants.RealtimeToOfflineSegmentsTask.TASK_TYPE, new HashMap<>()));\n+  }\n+\n+  @Override\n+  protected boolean useLlc() {\n+    return true;\n+  }\n+\n+  @BeforeClass\n+  public void setUp()\n+      throws Exception {\n+    // Setup realtime table, and blank offline table\n+    super.setUp();\n+    addTableConfig(createOfflineTableConfig());\n+    startMinion(null, null);\n+\n+    _helixTaskResourceManager = _controllerStarter.getHelixTaskResourceManager();\n+    _taskManager = _controllerStarter.getTaskManager();\n+    _pinotHelixResourceManager = _controllerStarter.getHelixResourceManager();\n+\n+    _realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(getTableName());\n+    _offlineTableName = TableNameBuilder.OFFLINE.tableNameWithType(getTableName());\n+\n+    List<RealtimeSegmentZKMetadata> realtimeSegmentMetadata =\n+        _pinotHelixResourceManager.getRealtimeSegmentMetadata(_realtimeTableName);\n+    long minSegmentTime = Long.MAX_VALUE;\n+    for (RealtimeSegmentZKMetadata metadata : realtimeSegmentMetadata) {\n+      if (metadata.getStatus() == CommonConstants.Segment.Realtime.Status.DONE) {\n+        if (metadata.getStartTime() < minSegmentTime) {\n+          minSegmentTime = metadata.getStartTime();\n+        }\n+      }\n+    }\n+    _dataSmallestTimeMillis = minSegmentTime;\n+    _dateSmallestDays = minSegmentTime / 86400000;\n+  }\n+\n+  @Test\n+  public void testRealtimeToOfflineSegmentsTask() {\n+\n+    List<OfflineSegmentZKMetadata> offlineSegmentMetadata =\n+        _pinotHelixResourceManager.getOfflineSegmentMetadata(_offlineTableName);\n+    Assert.assertTrue(offlineSegmentMetadata.isEmpty());\n+\n+    long expectedWatermark = _dataSmallestTimeMillis;\n+    int numOfflineSegments = 0;\n+    long offlineSegmentTime = _dateSmallestDays;\n+    for (int i = 0; i < 3; i ++) {\n+      // Schedule task\n+      Assert\n+          .assertTrue(_taskManager.scheduleTasks().containsKey(MinionConstants.RealtimeToOfflineSegmentsTask.TASK_TYPE));\n+      Assert.assertTrue(_helixTaskResourceManager.getTaskQueues().contains(\n+          PinotHelixTaskResourceManager.getHelixJobQueueName(MinionConstants.RealtimeToOfflineSegmentsTask.TASK_TYPE)));\n+      // Should not generate more tasks\n+      Assert\n+          .assertFalse(_taskManager.scheduleTasks().containsKey(MinionConstants.RealtimeToOfflineSegmentsTask.TASK_TYPE));\n+\n+      expectedWatermark = expectedWatermark + 86400000;\n+      // Wait at most 600 seconds for all tasks COMPLETED\n+      waitForTaskToComplete(expectedWatermark);\n+      // check segment is in offline\n+      offlineSegmentMetadata = _pinotHelixResourceManager.getOfflineSegmentMetadata(_offlineTableName);\n+      Assert.assertEquals(offlineSegmentMetadata.size(), ++numOfflineSegments);\n+      Assert.assertEquals(offlineSegmentMetadata.get(i).getStartTime(), offlineSegmentTime);\n+      Assert.assertEquals(offlineSegmentMetadata.get(i).getEndTime(), offlineSegmentTime);\n+      offlineSegmentTime ++;\n+    }\n+    testHardcodedSqlQueries();\n+  }\n+\n+  private void waitForTaskToComplete(long expectedWatermark) {\n+    TestUtils.waitForCondition(input -> {\n+      // Check task state\n+      for (TaskState taskState : _helixTaskResourceManager\n+          .getTaskStates(MinionConstants.RealtimeToOfflineSegmentsTask.TASK_TYPE).values()) {\n+        if (taskState != TaskState.COMPLETED) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    }, 600_000L, \"Failed to complete task\");\n+\n+    // Check segment ZK metadata\n+    RealtimeToOfflineSegmentsTaskMetadata minionTaskMetadata =\n+        _taskManager.getClusterInfoProvider().getMinionRealtimeToOfflineSegmentsTaskMetadata(_realtimeTableName);\n+    Assert.assertNotNull(minionTaskMetadata);\n+    Assert.assertEquals(minionTaskMetadata.getWatermarkMillis(), expectedWatermark);\n+  }\n+\n+  @Test(enabled = false)\n+  public void testSegmentListApi() {\n+  }\n+\n+  @Test(enabled = false)\n+  public void testBrokerDebugOutput() {\n+  }\n+\n+  @Test(enabled = false)\n+  public void testBrokerDebugRoutingTableSQL() {\n+  }\n+\n+  @Test(enabled = false)\n+  public void testBrokerResponseMetadata() {\n+  }\n+\n+  @Test(enabled = false)\n+  public void testDictionaryBasedQueries() {\n+  }\n+\n+  @Test(enabled = false)\n+  public void testGeneratedQueriesWithMultiValues() {\n+  }\n+\n+  @Test(enabled = false)\n+  public void testGeneratedQueriesWithoutMultiValues() {\n+  }\n+\n+  @Test(enabled = false)\n+  public void testHardcodedQueries() {\n+  }\n+\n+  @Test(enabled = false)\n+  public void testHardcodedSqlQueries() {\n+  }\n+\n+  @Test(enabled = false)\n+  public void testInstanceShutdown() {\n+  }\n+\n+  @Test(enabled = false)\n+  public void testQueriesFromQueryFile() {\n+  }\n+\n+  @Test(enabled = false)\n+  public void testQueryExceptions() {\n+  }\n+\n+  @Test(enabled = false)\n+  public void testReload(boolean includeOfflineTable) {", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3ODI4Mg==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r506778282", "bodyText": "It doesn't show up for me. You're likely extending Hybrid or LLC integration test. I have Realtime integration test as parent, and it doesnt have the method you mention", "author": "npawar", "createdAt": "2020-10-17T01:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MjUxMA=="}], "type": "inlineReview"}, {"oid": "f6fe2017d1e773d84c3248db4eae7754c9149d49", "url": "https://github.com/apache/pinot/commit/f6fe2017d1e773d84c3248db4eae7754c9149d49", "message": "Review comments", "committedDate": "2020-10-17T01:14:12Z", "type": "commit"}, {"oid": "f6fe2017d1e773d84c3248db4eae7754c9149d49", "url": "https://github.com/apache/pinot/commit/f6fe2017d1e773d84c3248db4eae7754c9149d49", "message": "Review comments", "committedDate": "2020-10-17T01:14:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjMwOA==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r508092308", "bodyText": "Do we need to provide taskType here? It is always realtimeToOfflineSegmentsTask right?", "author": "Jackie-Jiang", "createdAt": "2020-10-19T22:11:04Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/minion/MinionTaskMetadataUtils.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.minion;\n+\n+import javax.annotation.Nullable;\n+import org.I0Itec.zkclient.exception.ZkException;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.pinot.common.metadata.ZKMetadataProvider;\n+import org.apache.zookeeper.data.Stat;\n+\n+\n+/**\n+ * Helper methods to fetch/persist ZNRecord for minion task metadata\n+ */\n+public final class MinionTaskMetadataUtils {\n+\n+  private MinionTaskMetadataUtils() {\n+\n+  }\n+\n+  /**\n+   * Fetches the ZNRecord for the given minion task and tableName, from MINION_TASK_METADATA/taskName/tableNameWthType\n+   */\n+  @Nullable\n+  public static ZNRecord fetchMinionTaskMetadataZNRecord(HelixPropertyStore<ZNRecord> propertyStore, String taskType,\n+      String tableNameWithType) {\n+    String path = ZKMetadataProvider.constructPropertyStorePathForMinionTaskMetadata(taskType, tableNameWithType);\n+    Stat stat = new Stat();\n+    ZNRecord znRecord = propertyStore.get(path, stat, AccessOption.PERSISTENT);\n+    if (znRecord != null) {\n+      znRecord.setVersion(stat.getVersion());\n+    }\n+    return znRecord;\n+  }\n+\n+  /**\n+   * Fetches the ZNRecord for realtimeToOfflineSegmentsTask for given tableNameWithType from MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWthType\n+   * and converts it to a {@link RealtimeToOfflineSegmentsTaskMetadata} object\n+   */\n+  @Nullable\n+  public static RealtimeToOfflineSegmentsTaskMetadata getRealtimeToOfflineSegmentsTaskMetadata(\n+      HelixPropertyStore<ZNRecord> propertyStore, String taskType, String tableNameWithType) {\n+    ZNRecord znRecord = fetchMinionTaskMetadataZNRecord(propertyStore, taskType, tableNameWithType);\n+    return znRecord != null ? RealtimeToOfflineSegmentsTaskMetadata.fromZNRecord(znRecord) : null;\n+  }\n+\n+  /**\n+   * Persists the provided {@link RealtimeToOfflineSegmentsTaskMetadata} to MINION_TASK_METADATA/realtimeToOfflineSegmentsTask/tableNameWthType.\n+   * Will fail if expectedVersion does not match.\n+   * Set expectedVersion -1 to override version check.\n+   */\n+  public static void persistRealtimeToOfflineSegmentsTaskMetadata(HelixPropertyStore<ZNRecord> propertyStore,\n+      String taskType, RealtimeToOfflineSegmentsTaskMetadata realtimeToOfflineSegmentsTaskMetadata,", "originalCommit": "7577085056ede118116fb7ec6d0ef599d2a427d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0NTY4MA==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r508945680", "bodyText": "MinionConstants is not accessible here. And I didn't want to have static variable String for it", "author": "npawar", "createdAt": "2020-10-21T02:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5NDA2Ng==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r508094066", "bodyText": "You can remove all the json-related stuff because this class does not need to be json compatible. It should always be constructed with fromZNRecord()", "author": "Jackie-Jiang", "createdAt": "2020-10-19T22:15:27Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/minion/RealtimeToOfflineSegmentsTaskMetadata.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.minion;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.helix.ZNRecord;\n+import org.apache.pinot.spi.utils.JsonUtils;", "originalCommit": "f6fe2017d1e773d84c3248db4eae7754c9149d49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMzUzMg==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r508103532", "bodyText": "After some reconsideration, I feel it might be easier to manage if we merge provider and updater to ClusterInfoAccessor in case we need update the metadata based on the current value in the future.\nSorry that I was suggesting separating it out in the previous review.", "author": "Jackie-Jiang", "createdAt": "2020-10-19T22:39:56Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/minion/ClusterUpdater.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.helix.core.minion;\n+\n+import org.apache.pinot.common.minion.MinionTaskMetadataUtils;\n+import org.apache.pinot.common.minion.RealtimeToOfflineSegmentsTaskMetadata;\n+import org.apache.pinot.controller.helix.core.PinotHelixResourceManager;\n+import org.apache.pinot.controller.helix.core.minion.generator.PinotTaskGenerator;\n+import org.apache.pinot.core.common.MinionConstants;\n+\n+\n+/**\n+ * An abstraction on top of {@link PinotHelixResourceManager}, created for the {@link PinotTaskGenerator},\n+ * with scope restricted to cluster updates.\n+ * This also helps in separating read and update methods from the {@link ClusterInfoProvider}\n+ */\n+public class ClusterUpdater {", "originalCommit": "f6fe2017d1e773d84c3248db4eae7754c9149d49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwNjQzMg==", "url": "https://github.com/apache/pinot/pull/6124#discussion_r508106432", "bodyText": "Move these 2 methods to the BaseMultipleSegmentsConversionExecutor where it is getting called. Usually we allow child class to override methods used in the parent class.", "author": "Jackie-Jiang", "createdAt": "2020-10-19T22:47:46Z", "path": "pinot-minion/src/main/java/org/apache/pinot/minion/executor/BaseTaskExecutor.java", "diffHunk": "@@ -43,9 +44,20 @@ protected TableConfig getTableConfig(String tableNameWithType) {\n   }\n \n   protected Schema getSchema(String tableName) {\n-    Schema schema =\n-        ZKMetadataProvider.getTableSchema(MINION_CONTEXT.getHelixPropertyStore(), tableName);\n+    Schema schema = ZKMetadataProvider.getTableSchema(MINION_CONTEXT.getHelixPropertyStore(), tableName);\n     Preconditions.checkState(schema != null, \"Failed to find schema for table: %s\", tableName);\n     return schema;\n   }\n+\n+  /**\n+   * Pre processing operations to be done at the beginning of task execution\n+   */\n+  protected void preProcess(PinotTaskConfig pinotTaskConfig) {", "originalCommit": "f6fe2017d1e773d84c3248db4eae7754c9149d49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b703ec34de6e309333e096012a987142666ea249", "url": "https://github.com/apache/pinot/commit/b703ec34de6e309333e096012a987142666ea249", "message": "Remove json annotations from metadata class, ClusterInfoAccessor", "committedDate": "2020-10-21T02:19:35Z", "type": "commit"}, {"oid": "57b683fbd41d7ff51b58267d75f4fa71a8143fee", "url": "https://github.com/apache/pinot/commit/57b683fbd41d7ff51b58267d75f4fa71a8143fee", "message": "Remove newline", "committedDate": "2020-10-21T02:25:24Z", "type": "commit"}]}