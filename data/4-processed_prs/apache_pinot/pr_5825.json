{"pr_number": 5825, "pr_title": "Enhance sql parser for having and post-aggregation", "pr_createdAt": "2020-08-07T00:27:35Z", "pr_url": "https://github.com/apache/pinot/pull/5825", "timeline": [{"oid": "3e5f01df27bf140feddddc554c679361e614fe82", "url": "https://github.com/apache/pinot/commit/3e5f01df27bf140feddddc554c679361e614fe82", "message": "Enhance sql parser for having and post-aggregation", "committedDate": "2020-08-07T00:58:14Z", "type": "forcePushed"}, {"oid": "e09a6b0c05d73548a82866aca5b88fdefd8be582", "url": "https://github.com/apache/pinot/commit/e09a6b0c05d73548a82866aca5b88fdefd8be582", "message": "Enhance sql parser for having and post-aggregation", "committedDate": "2020-08-07T01:00:27Z", "type": "forcePushed"}, {"oid": "fba6de2e5f0c446966300fb4b46edcbbde5fee31", "url": "https://github.com/apache/pinot/commit/fba6de2e5f0c446966300fb4b46edcbbde5fee31", "message": "Enhance sql parser for having and post-aggregation", "committedDate": "2020-08-07T02:09:17Z", "type": "forcePushed"}, {"oid": "e8b6d9ddf41fc68f14f87a9fe2037f416ef96442", "url": "https://github.com/apache/pinot/commit/e8b6d9ddf41fc68f14f87a9fe2037f416ef96442", "message": "Enhance sql parser for having and post-aggregation", "committedDate": "2020-08-07T02:10:22Z", "type": "forcePushed"}, {"oid": "a24010989d232de28c7eb0bb8371cc984b3c24b4", "url": "https://github.com/apache/pinot/commit/a24010989d232de28c7eb0bb8371cc984b3c24b4", "message": "Enhance sql parser for having and post-aggregation", "committedDate": "2020-08-07T02:29:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5ODk2Mg==", "url": "https://github.com/apache/pinot/pull/5825#discussion_r466798962", "bodyText": "@npawar I remember you had to relax the SQL parser to accept certain syntax. Was it Babel, or something else?", "author": "mayankshriv", "createdAt": "2020-08-07T03:21:44Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -74,6 +74,11 @@\n    * non-alphanumeric characters. */\n   private static final Lex PINOT_LEX = Lex.MYSQL_ANSI;\n \n+  // BABEL is a very liberal conformance value that allows anything supported by any dialect\n+  private static final SqlParser.Config PARSER_CONFIG =\n+      SqlParser.configBuilder().setLex(PINOT_LEX).setConformance(SqlConformanceEnum.BABEL)", "originalCommit": "a24010989d232de28c7eb0bb8371cc984b3c24b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMDI0OA==", "url": "https://github.com/apache/pinot/pull/5825#discussion_r466830248", "bodyText": "This is the same as the current behavior. Not sure why we need BABEL over the default", "author": "Jackie-Jiang", "createdAt": "2020-08-07T05:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5ODk2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0ODIyNA==", "url": "https://github.com/apache/pinot/pull/5825#discussion_r467348224", "bodyText": "IIRC BABEL was able to parse some of the PQL's that the default won't. And the intent was to start off with a mode that makes for a smoother transition.", "author": "mayankshriv", "createdAt": "2020-08-08T02:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5ODk2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1MDI0Mw==", "url": "https://github.com/apache/pinot/pull/5825#discussion_r467350243", "bodyText": "DEFAULT flagged a lot more words as reserved keywords (such as language, module, position etc). BABEL reduced  that set to just the very basic ones (like timestamp, time, date etc).\nBut like Jackie said, this looks exactly like what it was", "author": "npawar", "createdAt": "2020-08-08T02:26:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5ODk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5OTQ4Mg==", "url": "https://github.com/apache/pinot/pull/5825#discussion_r466799482", "bodyText": "@siddharthteotia, fyi, does this break any of your use cases for PQL -> SQL migration?", "author": "mayankshriv", "createdAt": "2020-08-07T03:24:11Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -397,7 +403,8 @@ private static void rewriteNonAggregationGroupByToDistinct(PinotQuery pinotQuery\n         pinotQuery.setGroupByList(Collections.emptyList());\n       } else {\n         selectIdentifiers.removeAll(groupByIdentifiers);\n-        throw new SqlCompilationException(String.format(\"For non-aggregation group by query, all the identifiers in select clause should be in groupBys. Found identifier: %s\",\n+        throw new SqlCompilationException(String.format(\n+            \"For non-aggregation group by query, all the identifiers in select clause should be in groupBys. Found identifier: %s\",", "originalCommit": "a24010989d232de28c7eb0bb8371cc984b3c24b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMDEyNw==", "url": "https://github.com/apache/pinot/pull/5825#discussion_r466830127", "bodyText": "This line is just auto-format", "author": "Jackie-Jiang", "createdAt": "2020-08-07T05:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5OTQ4Mg=="}], "type": "inlineReview"}, {"oid": "62c6ff4a253d1843286ed201ac9f4b78c63ef429", "url": "https://github.com/apache/pinot/commit/62c6ff4a253d1843286ed201ac9f4b78c63ef429", "message": "Enhance sql parser for having and post-aggregation", "committedDate": "2020-08-07T05:52:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg2MDM5Nw==", "url": "https://github.com/apache/pinot/pull/5825#discussion_r466860397", "bodyText": "We can add A OR B ( C AND D) OR E for completeness.\nYou covered the following:\n\nA AND B ( C AND D) AND E\nA OR B ( C OR D) OR E\nA AND B ( C OR D) AND E", "author": "snleee", "createdAt": "2020-08-07T07:05:38Z", "path": "pinot-common/src/test/java/org/apache/pinot/sql/parsers/CalciteSqlCompilerTest.java", "diffHunk": "@@ -1804,4 +1819,199 @@ public void testInvalidNonAggregationGroupBy() {\n       throw e;\n     }\n   }\n-}\n\\ No newline at end of file\n+\n+  @Test\n+  public void testFlattenAndOr() {\n+    {\n+      String query = \"SELECT * FROM foo WHERE col1 > 0 AND (col2 > 0 AND col3 > 0) AND col4 > 0\";\n+      PinotQuery pinotQuery = CalciteSqlParser.compileToPinotQuery(query);\n+      Function functionCall = pinotQuery.getFilterExpression().getFunctionCall();\n+      Assert.assertEquals(functionCall.getOperator(), SqlKind.AND.name());\n+      List<Expression> operands = functionCall.getOperands();\n+      Assert.assertEquals(operands.size(), 4);\n+      for (Expression operand : operands) {\n+        Assert.assertEquals(operand.getFunctionCall().getOperator(), SqlKind.GREATER_THAN.name());\n+      }\n+\n+      BrokerRequest brokerRequest = BROKER_REQUEST_CONVERTER.convert(pinotQuery);\n+      FilterQueryTree filterQueryTree = RequestUtils.generateFilterQueryTree(brokerRequest);\n+      Assert.assertEquals(filterQueryTree.getOperator(), FilterOperator.AND);\n+      List<FilterQueryTree> children = filterQueryTree.getChildren();\n+      Assert.assertEquals(children.size(), 4);\n+      for (FilterQueryTree child : children) {\n+        Assert.assertEquals(child.getOperator(), FilterOperator.RANGE);\n+      }\n+    }\n+\n+    {\n+      String query = \"SELECT * FROM foo WHERE col1 <= 0 OR col2 <= 0 OR (col3 <= 0 OR col4 <= 0)\";\n+      PinotQuery pinotQuery = CalciteSqlParser.compileToPinotQuery(query);\n+      Function functionCall = pinotQuery.getFilterExpression().getFunctionCall();\n+      Assert.assertEquals(functionCall.getOperator(), SqlKind.OR.name());\n+      List<Expression> operands = functionCall.getOperands();\n+      Assert.assertEquals(operands.size(), 4);\n+      for (Expression operand : operands) {\n+        Assert.assertEquals(operand.getFunctionCall().getOperator(), SqlKind.LESS_THAN_OR_EQUAL.name());\n+      }\n+\n+      BrokerRequest brokerRequest = BROKER_REQUEST_CONVERTER.convert(pinotQuery);\n+      FilterQueryTree filterQueryTree = RequestUtils.generateFilterQueryTree(brokerRequest);\n+      Assert.assertEquals(filterQueryTree.getOperator(), FilterOperator.OR);\n+      List<FilterQueryTree> children = filterQueryTree.getChildren();\n+      Assert.assertEquals(children.size(), 4);\n+      for (FilterQueryTree child : children) {\n+        Assert.assertEquals(child.getOperator(), FilterOperator.RANGE);\n+      }\n+    }\n+\n+    {\n+      String query =\n+          \"SELECT * FROM foo WHERE col1 > 0 AND col2 > 0 AND col3 > 0 AND (col1 <= 0 OR col2 <= 0 OR (col3 <= 0 OR col4 <= 0)) AND col4 > 0\";", "originalCommit": "62c6ff4a253d1843286ed201ac9f4b78c63ef429", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MTUyMQ==", "url": "https://github.com/apache/pinot/pull/5825#discussion_r467191521", "bodyText": "Modified the test to cover this", "author": "Jackie-Jiang", "createdAt": "2020-08-07T18:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg2MDM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg2MDg0Ng==", "url": "https://github.com/apache/pinot/pull/5825#discussion_r466860846", "bodyText": "Why this value get changed? Did we change the underlying data or query?", "author": "snleee", "createdAt": "2020-08-07T07:06:52Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/InterSegmentAggregationMultiValueQueriesTest.java", "diffHunk": "@@ -157,7 +157,7 @@ public void testCastCountMV() {\n     Assert.assertEquals(brokerResponse.getResultTable().getDataSchema().getColumnName(0), \"cnt_column6\");\n \n     brokerResponse = getBrokerResponseForSqlQueryWithFilter(query);\n-    QueriesTestUtils.testInterSegmentResultTable(brokerResponse, 62480L, 874176L, 62480L, 400000L,", "originalCommit": "62c6ff4a253d1843286ed201ac9f4b78c63ef429", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NzU3Ng==", "url": "https://github.com/apache/pinot/pull/5825#discussion_r467187576", "bodyText": "This value changes because with the AND/OR flattening, the filter is compiled the same way in SQL and PQL, thus this value becomes the same as compiling with PQL. This value increases by chance, not always.", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:56:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg2MDg0Ng=="}], "type": "inlineReview"}, {"oid": "e54a3ff91c6f82a01bc3f8b1a8eaab4c74b0afd4", "url": "https://github.com/apache/pinot/commit/e54a3ff91c6f82a01bc3f8b1a8eaab4c74b0afd4", "message": "Enhance sql parser for having and post-aggregation", "committedDate": "2020-08-07T18:03:36Z", "type": "commit"}, {"oid": "e54a3ff91c6f82a01bc3f8b1a8eaab4c74b0afd4", "url": "https://github.com/apache/pinot/commit/e54a3ff91c6f82a01bc3f8b1a8eaab4c74b0afd4", "message": "Enhance sql parser for having and post-aggregation", "committedDate": "2020-08-07T18:03:36Z", "type": "forcePushed"}]}