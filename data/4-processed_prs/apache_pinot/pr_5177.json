{"pr_number": 5177, "pr_title": "Lucene DocId to PinotDocId cache", "pr_createdAt": "2020-03-24T06:21:55Z", "pr_url": "https://github.com/apache/pinot/pull/5177", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM3NjU0OQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r397376549", "bodyText": "Please use computeIfAbsent instead", "author": "Jackie-Jiang", "createdAt": "2020-03-24T18:34:22Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -148,8 +153,12 @@ private MutableRoaringBitmap getPinotDocIds(MutableRoaringBitmap luceneDocIds) {\n     try {\n       while (luceneDocIDIterator.hasNext()) {\n         int luceneDocId = luceneDocIDIterator.next();\n-        Document document = _indexSearcher.doc(luceneDocId);\n-        int pinotDocId = Integer.valueOf(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+        Integer pinotDocId = _luceneDocIDToPinotDocIDCache.get(luceneDocId);", "originalCommit": "a9d171a0a93a946fbf781f2cf541cb796f9950b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0NjY3Nw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400346677", "bodyText": "I am not using this method anymore. The mapping is built once during segment load and memory mapped.", "author": "siddharthteotia", "createdAt": "2020-03-30T16:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM3NjU0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1ODMwOA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400358308", "bodyText": "Also added a TODO to consider building mapping on-the-fly during query processing -- we can have two methods and make it configurable based on number of docs per segment.", "author": "siddharthteotia", "createdAt": "2020-03-30T17:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM3NjU0OQ=="}], "type": "inlineReview"}, {"oid": "845f98d63073efc0edaa64a998b64fe1c2cf1212", "url": "https://github.com/apache/pinot/commit/845f98d63073efc0edaa64a998b64fe1c2cf1212", "message": "Lucene DocId to PinotDocId cache", "committedDate": "2020-03-30T16:55:16Z", "type": "forcePushed"}, {"oid": "26e88ea6b9c7ad48f583b526c19b2f8c153cbaba", "url": "https://github.com/apache/pinot/commit/26e88ea6b9c7ad48f583b526c19b2f8c153cbaba", "message": "Lucene DocId to PinotDocId cache", "committedDate": "2020-03-30T17:04:17Z", "type": "forcePushed"}, {"oid": "0db1d2e4a3623f87297fd652c66d4b7600594f9d", "url": "https://github.com/apache/pinot/commit/0db1d2e4a3623f87297fd652c66d4b7600594f9d", "message": "Lucene DocId to PinotDocId cache", "committedDate": "2020-03-30T17:13:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1OTk0MQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400359941", "bodyText": "Revert the change in this file?\nAlso suggesting rename the test to TextSearchQueriesTest for naming convention.", "author": "Jackie-Jiang", "createdAt": "2020-03-30T17:17:43Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/TestTextSearchQueries.java", "diffHunk": "@@ -89,7 +91,7 @@\n   private RecordReader _recordReader;\n   Schema _schema;\n \n-  private List<IndexSegment> _indexSegments = new ArrayList<>(1);\n+  private static List<IndexSegment> _indexSegments = new ArrayList<>(1);", "originalCommit": "0db1d2e4a3623f87297fd652c66d4b7600594f9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM4MTg2Mw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400381863", "bodyText": "oops. Sorry, this was due to local debugging. Will remove and also reformat", "author": "siddharthteotia", "createdAt": "2020-03-30T17:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1OTk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2MDMwNA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400360304", "bodyText": "private final", "author": "Jackie-Jiang", "createdAt": "2020-03-30T17:18:13Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -51,6 +54,9 @@\n   private final IndexSearcher _indexSearcher;\n   private final QueryParser _queryParser;\n   private final String _column;\n+  private DocIdReaderWriter _docIdReaderWriter;", "originalCommit": "0db1d2e4a3623f87297fd652c66d4b7600594f9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1MzMyNw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400553327", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-30T23:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2MDMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2NzM3NA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400367374", "bodyText": "We build the mapping every time we load the index? You saved the mapping into a file right?", "author": "Jackie-Jiang", "createdAt": "2020-03-30T17:29:09Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -70,6 +76,10 @@ public LuceneTextIndexReader(String column, File segmentIndexDir) {\n       // Disable Lucene query result cache. While it helps a lot with performance for\n       // repeated queries, on the downside it cause heap issues.\n       _indexSearcher.setQueryCache(null);\n+      // TODO: consider using a threshold of num docs per segment to decide between building\n+      // mapping file upfront on segment load v/s on-the-fly during query processing\n+      _docIdReaderWriter = new DocIdReaderWriter(segmentIndexDir, _column, numDocs);\n+      _docIdReaderWriter.buildDocIdMapping(numDocs);", "originalCommit": "0db1d2e4a3623f87297fd652c66d4b7600594f9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1MjI5OA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400552298", "bodyText": "We check for existence and return.", "author": "siddharthteotia", "createdAt": "2020-03-30T23:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2NzM3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1MjcwOA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400552708", "bodyText": "Also, I explored doing this in TextIndexHandler. But that is not good since it requires to open the lucene index, create searcher twice (both in handler and here anyway for query processing). I think it is better to avoid that and just open the lucene index reader and searcher just once per index.", "author": "siddharthteotia", "createdAt": "2020-03-30T23:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2NzM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2OTY2OA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400369668", "bodyText": "For segment refresh, this file should not exist as we delete the old segment", "author": "Jackie-Jiang", "createdAt": "2020-03-30T17:32:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,49 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs) throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // For newly added segments, this file will not exist.\n+      // For segment refresh, segment reload and server restart, file will exist,\n+      // but we don't know if we are here for refresh v/s reload v/s restart.\n+      // In case of refresh, we have to build the mapping again, but in case of", "originalCommit": "0db1d2e4a3623f87297fd652c66d4b7600594f9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MDQyOQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400370429", "bodyText": "For better performance, I would probably choose native order as this index is always local to one instance?", "author": "Jackie-Jiang", "createdAt": "2020-03-30T17:33:48Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,49 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs) throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // For newly added segments, this file will not exist.\n+      // For segment refresh, segment reload and server restart, file will exist,\n+      // but we don't know if we are here for refresh v/s reload v/s restart.\n+      // In case of refresh, we have to build the mapping again, but in case of\n+      // reload and restart, we don't. Also, reload has a sub-case where this text index\n+      // was indeed created during reload (user enabled on existing or newly added column).\n+      // Since there is no way to distinguish why we are here, we build the mapping again\n+      // regardless.\n+      // TODO: see if we can prefetch the pages\n+      _buffer =\n+          PinotDataBuffer.mapFile(docIdMappingFile, false, 0, length, ByteOrder.BIG_ENDIAN, getClass().getSimpleName());", "originalCommit": "0db1d2e4a3623f87297fd652c66d4b7600594f9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1MzY1Nw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400553657", "bodyText": "Yes, as discussed using Little Endian and indicated in the comments too. We are unlikely to run on Solaris/Sparc so using LE is fine which is the case on Linux/x86", "author": "siddharthteotia", "createdAt": "2020-03-30T23:25:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MDQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MTk5Mw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400371993", "bodyText": "Please include the column name into the description (last argument) to distinguish different columns", "author": "Jackie-Jiang", "createdAt": "2020-03-30T17:36:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,49 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs) throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // For newly added segments, this file will not exist.\n+      // For segment refresh, segment reload and server restart, file will exist,\n+      // but we don't know if we are here for refresh v/s reload v/s restart.\n+      // In case of refresh, we have to build the mapping again, but in case of\n+      // reload and restart, we don't. Also, reload has a sub-case where this text index\n+      // was indeed created during reload (user enabled on existing or newly added column).\n+      // Since there is no way to distinguish why we are here, we build the mapping again\n+      // regardless.\n+      // TODO: see if we can prefetch the pages\n+      _buffer =\n+          PinotDataBuffer.mapFile(docIdMappingFile, false, 0, length, ByteOrder.BIG_ENDIAN, getClass().getSimpleName());", "originalCommit": "0db1d2e4a3623f87297fd652c66d4b7600594f9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1MzY4MQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400553681", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-30T23:25:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MTk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MjU0Mw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400372543", "bodyText": "Throw this exception out instead of logging an ERROR. If this step fails, JVM will crash when reading the buffer.", "author": "Jackie-Jiang", "createdAt": "2020-03-30T17:37:07Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,49 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs) throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // For newly added segments, this file will not exist.\n+      // For segment refresh, segment reload and server restart, file will exist,\n+      // but we don't know if we are here for refresh v/s reload v/s restart.\n+      // In case of refresh, we have to build the mapping again, but in case of\n+      // reload and restart, we don't. Also, reload has a sub-case where this text index\n+      // was indeed created during reload (user enabled on existing or newly added column).\n+      // Since there is no way to distinguish why we are here, we build the mapping again\n+      // regardless.\n+      // TODO: see if we can prefetch the pages\n+      _buffer =\n+          PinotDataBuffer.mapFile(docIdMappingFile, false, 0, length, ByteOrder.BIG_ENDIAN, getClass().getSimpleName());\n+    }\n+\n+    public void buildDocIdMapping(int numDocs) {\n+      for (int i = 0; i < numDocs; i++) {\n+        try {\n+          Document document = _indexSearcher.doc(i);\n+          int pinotDocId = Integer.valueOf(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+          _buffer.putInt(i * Integer.BYTES, pinotDocId);\n+        } catch (Exception e) {\n+          LOGGER.error(\"Failed to build doc id mapping during segment load for column:{},docID:{},error:{}. Will continue and build mapping on the fly\",", "originalCommit": "0db1d2e4a3623f87297fd652c66d4b7600594f9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1MzcxMQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400553711", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-30T23:25:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM3MjU0Mw=="}], "type": "inlineReview"}, {"oid": "50855dcf42f06f5cb050263c14c96fb4135807f8", "url": "https://github.com/apache/pinot/commit/50855dcf42f06f5cb050263c14c96fb4135807f8", "message": "Lucene DocId to PinotDocId cache", "committedDate": "2020-03-30T23:19:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1NzUyOA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400557528", "bodyText": "Remove?", "author": "Jackie-Jiang", "createdAt": "2020-03-30T23:37:16Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/TextSearchQueriesTest.java", "diffHunk": "@@ -18,6 +18,7 @@\n  */\n package org.apache.pinot.queries;\n \n+import com.google.common.base.Stopwatch;", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDczNQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574735", "bodyText": "Done", "author": "siddharthteotia", "createdAt": "2020-03-31T00:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1NzUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1ODY2Mw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400558663", "bodyText": "By convention, we use indexDir for top level directory, and segmentDirectory for the direct directory (indexDir for v1, or v3 for v3). If you follow the same naming convention, it will be clearer.", "author": "Jackie-Jiang", "createdAt": "2020-03-30T23:40:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -154,6 +152,11 @@ private void createTextIndexForColumn(ColumnMetadata columnMetadata)\n     int numDocs = columnMetadata.getTotalDocs();\n     LOGGER.info(\"Creating new text index for column: {} in segment: {}\", column, _segmentName);\n     File segmentIndexDir = SegmentDirectoryPaths.segmentDirectoryFor(_indexDir, _segmentVersion);\n+    // The handlers are always invoked by the preprocessor. Before this ImmutableSegmentLoader would have already", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDc2MQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574761", "bodyText": "Done. Wasn't aware of this.", "author": "siddharthteotia", "createdAt": "2020-03-31T00:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1ODY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1OTEyMQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400559121", "bodyText": "Not related to this pr, but seems this file needs reformat", "author": "Jackie-Jiang", "createdAt": "2020-03-30T23:42:12Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -61,8 +61,26 @@\n import static org.apache.pinot.core.segment.creator.impl.V1Constants.MetadataKeys.Column.getKeyFor;\n \n \n+/**\n+ * Helper class for text indexes used by {@link org.apache.pinot.core.segment.index.loader.SegmentPreProcessor}.\n+ * to create text index for column during segment load time. Currently text index is always\n+ * created (if enabled on a column) during segment generation\n+ *\n+ * (1) A new segment with text index is created/refreshed. Server loads the segment. The handler\n+ * detects the existence of text index and returns.\n+ *\n+ * (2) A reload is issued on an existing segment with existing text index. The handler\n+ * detects the existence of text index and returns.\n+ *\n+ * (3) A reload is issued on an existing segment after text index is enabled on an existing\n+ * column. Read the forward index to create text index.\n+ *\n+ * (4) A reload is issued on an existing segment after text index is enabled on a newly\n+ * added column. In this case, the default column handler would have taken care of adding\n+ * forward index for the new column. Read the forward index to create text index.\n+ */\n public class TextIndexHandler {", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDgxMQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574811", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-31T00:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1OTEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2MDU1OQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400560559", "bodyText": "Not related to this pr, but can you make this method similar to copyForwardIndex() and call it in copyIndexData() based on the metadata?", "author": "Jackie-Jiang", "createdAt": "2020-03-30T23:46:48Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/converter/SegmentV1V2ToV3FormatConverter.java", "diffHunk": "@@ -241,6 +242,22 @@ public boolean accept(File dir, String name) {\n         Files.copy(indexFile.toPath(), v3LuceneIndexFile.toPath());\n       }\n     }\n+    // if segment reload is issued asking for up-conversion of", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3Njg3Ng==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400576876", "bodyText": "Lucene index files (created by Lucene) can't be copied as done in copyForwardIndex\nPinotDataBuffer oldBuffer = reader.getIndexFor(column, indexType); long oldBufferSize = oldBuffer.size(); PinotDataBuffer newBuffer = writer.newIndexFor(column, indexType, oldBufferSize); oldBuffer.copyTo(0, newBuffer, 0, oldBufferSize);\nThe only thing that can be copied as buffer is the mapping file that we create. I just wanted to keep everything related to lucene in a single method. I can explore how to clean this up.", "author": "siddharthteotia", "createdAt": "2020-03-31T00:42:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2MDU1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3ODg4MA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400578880", "bodyText": "Added a TODO -- I have couple of more PRs coming up  shortly for text. Will address this", "author": "siddharthteotia", "createdAt": "2020-03-31T00:49:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2MDU1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MDQyNw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400580427", "bodyText": "I was referring to the usage (check metadata and copy instead of filtering on file names). Not critical, you can address later", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2MDU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NDY3Mw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400564673", "bodyText": "final PinotDataBuffer _buffer (class itself is private)", "author": "Jackie-Jiang", "createdAt": "2020-03-30T23:59:57Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDgzMg==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574832", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-31T00:34:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NDY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NDcyOA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400564728", "bodyText": "private static class", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:00:06Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDg0Mw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574843", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-31T00:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NDcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NTAzOA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400565038", "bodyText": "Integer.parseInt()", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:01:10Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+    private final boolean _mappingExists;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _mappingExists = true;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      } else {\n+        _mappingExists = false;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ false, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      }\n+    }\n+\n+    public void buildDocIdMapping(int numDocs) {\n+      if (!_mappingExists) {\n+        for (int i = 0; i < numDocs; i++) {\n+          try {\n+            Document document = _indexSearcher.doc(i);\n+            int pinotDocId = Integer.valueOf(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDg0OQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574849", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-31T00:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NTAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NTUzOA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400565538", "bodyText": "Merge this into the constructor, no need to track an extra boolean.", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:02:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+    private final boolean _mappingExists;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _mappingExists = true;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      } else {\n+        _mappingExists = false;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ false, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      }\n+    }\n+\n+    public void buildDocIdMapping(int numDocs) {", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDg2NQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574865", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-31T00:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NTUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NTg3Mg==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400565872", "bodyText": "Recommend making second argument indexDir to denote that it is top level dir", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:04:03Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -60,7 +66,7 @@\n    * @param column column name\n    * @param segmentIndexDir segment index directory\n    */\n-  public LuceneTextIndexReader(String column, File segmentIndexDir) {\n+  public LuceneTextIndexReader(String column, File segmentIndexDir, int numDocs) {", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDg3Nw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574877", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-31T00:35:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NTg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NjExOA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400566118", "bodyText": "I prefer the original name", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:04:45Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -121,7 +131,7 @@ public MutableRoaringBitmap getDocIds(Object value) {\n     try {\n       Query query = _queryParser.parse(searchQuery);\n       _indexSearcher.search(query, docIDCollector);\n-      return getPinotDocIds(docIDs);\n+      return getPinotDocIdsFromMappingFile(docIDs);", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDkwMQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574901", "bodyText": "ohh yes, I was initially thinking of implementing two solutions. Reverted", "author": "siddharthteotia", "createdAt": "2020-03-31T00:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NjExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NjYyOA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400566628", "bodyText": "You don't really need to log the error if you are going to throw out the exception. The catcher will log it with the stack trace", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:06:25Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -121,7 +131,7 @@ public MutableRoaringBitmap getDocIds(Object value) {\n     try {\n       Query query = _queryParser.parse(searchQuery);\n       _indexSearcher.search(query, docIDCollector);\n-      return getPinotDocIds(docIDs);\n+      return getPinotDocIdsFromMappingFile(docIDs);\n     } catch (Exception e) {\n       LOGGER.error(\"Failed while searching the text index for column {}, search query {}, exception {}\", _column,", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDkxNg==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574916", "bodyText": "Removed the e.getMessage() from log. The log is still needed though since I want to capture column name and search expression for the failed query", "author": "siddharthteotia", "createdAt": "2020-03-31T00:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NjYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2Njc1OA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400566758", "bodyText": "No need to catch, you can directly throw the exception", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:06:54Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -142,18 +152,17 @@ public MutableRoaringBitmap getDocIds(Object value) {\n    *\n    * TODO: Explore optimizing this path to avoid building the second bitmap\n    */\n-  private MutableRoaringBitmap getPinotDocIds(MutableRoaringBitmap luceneDocIds) {\n+  private MutableRoaringBitmap getPinotDocIdsFromMappingFile(MutableRoaringBitmap luceneDocIds) {\n     IntIterator luceneDocIDIterator = luceneDocIds.getIntIterator();\n     MutableRoaringBitmap actualDocIDs = new MutableRoaringBitmap();\n     try {\n       while (luceneDocIDIterator.hasNext()) {\n         int luceneDocId = luceneDocIDIterator.next();\n-        Document document = _indexSearcher.doc(luceneDocId);\n-        int pinotDocId = Integer.valueOf(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+        int pinotDocId = _docIdReaderWriter.getInt(luceneDocId * Integer.BYTES);\n         actualDocIDs.add(pinotDocId);\n       }\n     } catch (Exception e) {\n-      throw new RuntimeException(\"Error: failed while retrieving document from index: \" + e);\n+      throw new RuntimeException(\"Error: failed while retrieving pinot doc id from mapping file: \" + e);", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDkzNA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574934", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-31T00:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2Njc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2ODA3Mg==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400568072", "bodyText": "\"Text index docId mapping buffer: \" + _column", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:11:10Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+    private final boolean _mappingExists;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _mappingExists = true;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDk0NA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574944", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-31T00:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2ODA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2ODQwNQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400568405", "bodyText": "int getPinotDocId(int luceneDocId) for better abstraction", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:12:24Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+    private final boolean _mappingExists;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _mappingExists = true;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      } else {\n+        _mappingExists = false;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ false, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      }\n+    }\n+\n+    public void buildDocIdMapping(int numDocs) {\n+      if (!_mappingExists) {\n+        for (int i = 0; i < numDocs; i++) {\n+          try {\n+            Document document = _indexSearcher.doc(i);\n+            int pinotDocId = Integer.valueOf(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+            _buffer.putInt(i * Integer.BYTES, pinotDocId);\n+          } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to build doc id mapping during segment load: \" + e);\n+          }\n+        }\n+      }\n+    }\n+\n+    int getInt(int offset) {", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDk1NQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574955", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-31T00:35:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2ODQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2ODk2Nw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400568967", "bodyText": "I would recommend renaming it to DocIdTranslator", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:14:06Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDk3Mg==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400574972", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-31T00:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2ODk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3Mjc2Mg==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400572762", "bodyText": "Can we reuse FixedByteReaderWriter?", "author": "kishoreg", "createdAt": "2020-03-31T00:27:16Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+    private final boolean _mappingExists;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _mappingExists = true;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN,", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3ODAxMA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400578010", "bodyText": "I explored existing reader/writer. Didn't use for the following reasons:\nFixedByteChunkReaderWriter uses direct memory (ByteBuffer.allocateDirect). Memory mapping is better.\nThe FixedBitIntReaderWriter (used for dictionary encoded forward index) has additional bells and whistles due to bit-packing. The return type is an array. I wanted to keep this simple since we use it in exactly one place in lucene code.", "author": "siddharthteotia", "createdAt": "2020-03-31T00:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3Mjc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3Mjg5Mw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400572893", "bodyText": ", e", "author": "kishoreg", "createdAt": "2020-03-31T00:27:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +178,57 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdReaderWriter.close();\n+  }\n+\n+  private class DocIdReaderWriter implements Closeable {\n+    private PinotDataBuffer _buffer;\n+    private final boolean _mappingExists;\n+\n+    DocIdReaderWriter(File segmentIndexDir, String column, int numDocs)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _mappingExists = true;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      } else {\n+        _mappingExists = false;\n+        _buffer = PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ false, 0, length, ByteOrder.LITTLE_ENDIAN,\n+            _column + getClass().getSimpleName());\n+      }\n+    }\n+\n+    public void buildDocIdMapping(int numDocs) {\n+      if (!_mappingExists) {\n+        for (int i = 0; i < numDocs; i++) {\n+          try {\n+            Document document = _indexSearcher.doc(i);\n+            int pinotDocId = Integer.valueOf(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+            _buffer.putInt(i * Integer.BYTES, pinotDocId);\n+          } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to build doc id mapping during segment load: \" + e);", "originalCommit": "8f6ad20cd28fafb5b63f9526b6b0a942c552ef4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3ODAzOA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400578038", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-31T00:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3Mjg5Mw=="}], "type": "inlineReview"}, {"oid": "c63bb40b1be47cab59a84e765d1a77c1bb00fcbf", "url": "https://github.com/apache/pinot/commit/c63bb40b1be47cab59a84e765d1a77c1bb00fcbf", "message": "Lucene DocId to PinotDocId cache", "committedDate": "2020-03-31T00:52:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MTI1NA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400581254", "bodyText": "If you want to keep the context of the exception, put it into the RuntimeException", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:57:41Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -123,8 +133,7 @@ public MutableRoaringBitmap getDocIds(Object value) {\n       _indexSearcher.search(query, docIDCollector);\n       return getPinotDocIds(docIDs);\n     } catch (Exception e) {\n-      LOGGER.error(\"Failed while searching the text index for column {}, search query {}, exception {}\", _column,\n-          searchQuery, e.getMessage());\n+      LOGGER.error(\"Failed while searching the text index for column {}, search query {},\", _column, searchQuery);", "originalCommit": "cf80eef3101b78c15ff4504e77c364324567b506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4ODgxMw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400588813", "bodyText": "used in message of RuntimeException", "author": "siddharthteotia", "createdAt": "2020-03-31T01:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MTI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MTg4Ng==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400581886", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new RuntimeException(\"Failed to build doc id mapping during segment load, \" + e);\n          \n          \n            \n                        throw new RuntimeException(\"Caught exception while building doc id mapping for text index column: \" + column, e);", "author": "Jackie-Jiang", "createdAt": "2020-03-31T00:59:53Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +173,50 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdTranslator.close();\n+  }\n+\n+  private static class DocIdTranslator implements Closeable {\n+    final PinotDataBuffer _buffer;\n+\n+    DocIdTranslator(File segmentIndexDir, String column, int numDocs, IndexSearcher indexSearcher)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      String desc = \"Text index docId mapping buffer: \" + column;\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _buffer =\n+            PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN, desc);\n+      } else {\n+        _buffer =\n+            PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ false, 0, length, ByteOrder.LITTLE_ENDIAN, desc);\n+        for (int i = 0; i < numDocs; i++) {\n+          try {\n+            Document document = indexSearcher.doc(i);\n+            int pinotDocId = Integer.parseInt(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+            _buffer.putInt(i * Integer.BYTES, pinotDocId);\n+          } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to build doc id mapping during segment load, \" + e);", "originalCommit": "cf80eef3101b78c15ff4504e77c364324567b506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4ODc5OQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400588799", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-03-31T01:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4Mjg0MQ==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400582841", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new RuntimeException(e);\n          \n          \n            \n                  throw new RuntimeException(\"Caught exception while searching the text index column: \" + _column + \" with query: \" + searchQuery, e);", "author": "Jackie-Jiang", "createdAt": "2020-03-31T01:03:18Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -123,8 +133,7 @@ public MutableRoaringBitmap getDocIds(Object value) {\n       _indexSearcher.search(query, docIDCollector);\n       return getPinotDocIds(docIDs);\n     } catch (Exception e) {\n-      LOGGER.error(\"Failed while searching the text index for column {}, search query {}, exception {}\", _column,\n-          searchQuery, e.getMessage());\n+      LOGGER.error(\"Failed while searching the text index for column {}, search query {},\", _column, searchQuery);\n       throw new RuntimeException(e);", "originalCommit": "cf80eef3101b78c15ff4504e77c364324567b506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MzMyMw==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400583323", "bodyText": "Pass in luceneDocId and wrap the _buffer.getInt(luceneDocId * Integer.BYTES) logic inside", "author": "Jackie-Jiang", "createdAt": "2020-03-31T01:04:54Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -169,5 +173,50 @@ public void close()\n       throws IOException {\n     _indexReader.close();\n     _indexDirectory.close();\n+    _docIdTranslator.close();\n+  }\n+\n+  private static class DocIdTranslator implements Closeable {\n+    final PinotDataBuffer _buffer;\n+\n+    DocIdTranslator(File segmentIndexDir, String column, int numDocs, IndexSearcher indexSearcher)\n+        throws Exception {\n+      int length = Integer.BYTES * numDocs;\n+      File docIdMappingFile = new File(SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir),\n+          column + LUCENE_TEXT_INDEX_DOCID_MAPPING_FILE_EXTENSION);\n+      // The mapping is local to a segment. It is created on the server during segment load.\n+      // Unless we are running Pinot on Solaris/SPARC, the underlying architecture is\n+      // LITTLE_ENDIAN (Linux/x86). So use that as byte order.\n+      String desc = \"Text index docId mapping buffer: \" + column;\n+      if (docIdMappingFile.exists()) {\n+        // we will be here for segment reload and server restart\n+        // for refresh, we will not be here since segment is deleted/replaced\n+        // TODO: see if we can prefetch the pages\n+        _buffer =\n+            PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ true, 0, length, ByteOrder.LITTLE_ENDIAN, desc);\n+      } else {\n+        _buffer =\n+            PinotDataBuffer.mapFile(docIdMappingFile, /* readOnly */ false, 0, length, ByteOrder.LITTLE_ENDIAN, desc);\n+        for (int i = 0; i < numDocs; i++) {\n+          try {\n+            Document document = indexSearcher.doc(i);\n+            int pinotDocId = Integer.parseInt(document.get(LuceneTextIndexCreator.LUCENE_INDEX_DOC_ID_COLUMN_NAME));\n+            _buffer.putInt(i * Integer.BYTES, pinotDocId);\n+          } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to build doc id mapping during segment load, \" + e);\n+          }\n+        }\n+      }\n+    }\n+\n+    int getPinotDocId(int offset) {", "originalCommit": "cf80eef3101b78c15ff4504e77c364324567b506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4ODgyNA==", "url": "https://github.com/apache/pinot/pull/5177#discussion_r400588824", "bodyText": "Good catch. Done", "author": "siddharthteotia", "createdAt": "2020-03-31T01:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MzMyMw=="}], "type": "inlineReview"}, {"oid": "b74c28c2e98185ecd545933208f35fed65724e40", "url": "https://github.com/apache/pinot/commit/b74c28c2e98185ecd545933208f35fed65724e40", "message": "Lucene DocId to PinotDocId cache", "committedDate": "2020-03-31T01:23:39Z", "type": "forcePushed"}, {"oid": "e46afb7b62ade04754530eacf3ac6309aeb9fa04", "url": "https://github.com/apache/pinot/commit/e46afb7b62ade04754530eacf3ac6309aeb9fa04", "message": "Lucene DocId to PinotDocId cache to improve performance", "committedDate": "2020-03-31T02:31:28Z", "type": "commit"}, {"oid": "e46afb7b62ade04754530eacf3ac6309aeb9fa04", "url": "https://github.com/apache/pinot/commit/e46afb7b62ade04754530eacf3ac6309aeb9fa04", "message": "Lucene DocId to PinotDocId cache to improve performance", "committedDate": "2020-03-31T02:31:28Z", "type": "forcePushed"}]}