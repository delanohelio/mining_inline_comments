{"pr_number": 5221, "pr_title": "Add a new server api for download of segments.", "pr_createdAt": "2020-04-07T22:18:51Z", "pr_url": "https://github.com/apache/pinot/pull/5221", "timeline": [{"oid": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "url": "https://github.com/apache/pinot/commit/ecf20a2b941574c3073a2db2aed32ab0d1607b31", "message": "Add a new server api for download of segments.", "committedDate": "2020-04-07T22:11:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODQzMg==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405188432", "bodyText": "tableName -> tableNameWithType?", "author": "snleee", "createdAt": "2020-04-08T00:21:31Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/TablesResource.java", "diffHunk": "@@ -175,4 +183,41 @@ public String getCrcMetadataForTable(\n       }\n     }\n   }\n+\n+  @GET\n+  @Produces(MediaType.APPLICATION_OCTET_STREAM)\n+  @Path(\"/tables/{tableName}/segments/{segmentName}\")\n+  @ApiOperation(value = \"Download a segment\", notes = \"Download a segment in zipped tar format\")\n+  public Response downloadSegment(\n+      @ApiParam(value = \"Name of the table with type REALTIME OR OFFLINE\", required = true, example = \"myTable_OFFLINE\") @PathParam(\"tableName\") String tableName,", "originalCommit": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4NzQyMw==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405887423", "bodyText": "done.", "author": "chenboat", "createdAt": "2020-04-09T00:18:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODc3Mw==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405188773", "bodyText": "/ -> File.separator", "author": "snleee", "createdAt": "2020-04-08T00:22:39Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/TablesResource.java", "diffHunk": "@@ -175,4 +183,41 @@ public String getCrcMetadataForTable(\n       }\n     }\n   }\n+\n+  @GET\n+  @Produces(MediaType.APPLICATION_OCTET_STREAM)\n+  @Path(\"/tables/{tableName}/segments/{segmentName}\")\n+  @ApiOperation(value = \"Download a segment\", notes = \"Download a segment in zipped tar format\")\n+  public Response downloadSegment(\n+      @ApiParam(value = \"Name of the table with type REALTIME OR OFFLINE\", required = true, example = \"myTable_OFFLINE\") @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @Context HttpHeaders httpHeaders)\n+      throws Exception {\n+    LOGGER.info(\"Get a request to download segment {} for table {}\", segmentName, tableName);\n+    TableDataManager tableDataManager = checkGetTableDataManager(tableName);\n+    SegmentDataManager segmentDataManager = tableDataManager.acquireSegment(segmentName);\n+    if (segmentDataManager == null) {\n+      throw new WebApplicationException(String.format(\"Table %s segments %s does not exist\", tableName, segmentName),\n+          Response.Status.NOT_FOUND);\n+    }\n+    try {\n+      String tableDir = tableDataManager.getTableDataDir();\n+      String tarFilePath = TarGzCompressionUtils.createTarGzOfDirectory(tableDir + \"/\" + segmentName);", "originalCommit": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5MTIzMg==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405191232", "bodyText": "Current API behavior will compress the segment file every time we hit this API. It looks a bit expensive operation. Does TarGzCompressionUtils.createTarGzOfDirectory  use tar -cvf or tar -czvf? cvf will simply group the multiple files/directories into a single file while czvf will do the compression. I guess that TarGzCompressionUtils.createTarGzOfDirectory  probably try to compress the file.\nDepending on the use case, compression may become the performance bottleneck. Imagine that a single server gets the download request for multiple segment at the similar time. Compressing multiple files concurrently will consume a lot of CPU resource.\nOne way to improve this is simply using the tar cvf equivalent logic (no compression) and send the file. Another approach is to keep compressed files in some directory and use it as a cache (then we also needs to handle invalidation). We don't need to address this for now but let's add at least a comment on this in case someone faces the bottleneck here..", "author": "snleee", "createdAt": "2020-04-08T00:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODc3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg5MTM3NQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405891375", "bodyText": "Definitely this is a place we need to monitor for performance and optimization if needed. Left TODO here as also suggested also by Subbu.\nTo you question if/which compression level is used, createTarGzOfDirectory() in Pinot TarGzCompressionUtils uses the default compression level by Gzip. We could also tune the level by specifying other levels (9 level in total) like BEST_SPEED/NO_COMPRESSION and so on.", "author": "chenboat", "createdAt": "2020-04-09T00:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4NzQ1Nw==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405187457", "bodyText": "this path is the deprecated one in the controller. Can we use the same as what the controller uses?\n/segments/{tableName}/{segmentName}. Please add this as a discussion point in your doc, and start an email discussion on this spec. Within a couple of days, we can get any feedback people may have", "author": "mcvsubbu", "createdAt": "2020-04-08T00:18:04Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/TablesResource.java", "diffHunk": "@@ -175,4 +183,41 @@ public String getCrcMetadataForTable(\n       }\n     }\n   }\n+\n+  @GET\n+  @Produces(MediaType.APPLICATION_OCTET_STREAM)\n+  @Path(\"/tables/{tableName}/segments/{segmentName}\")", "originalCommit": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4NzY0MA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405187640", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                LOGGER.info(\"Get a request to download segment {} for table {}\", segmentName, tableName);\n          \n          \n            \n                LOGGER.info(\"Received request to download segment {} for table {}\", segmentName, tableName);", "author": "mcvsubbu", "createdAt": "2020-04-08T00:18:43Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/TablesResource.java", "diffHunk": "@@ -175,4 +183,41 @@ public String getCrcMetadataForTable(\n       }\n     }\n   }\n+\n+  @GET\n+  @Produces(MediaType.APPLICATION_OCTET_STREAM)\n+  @Path(\"/tables/{tableName}/segments/{segmentName}\")\n+  @ApiOperation(value = \"Download a segment\", notes = \"Download a segment in zipped tar format\")\n+  public Response downloadSegment(\n+      @ApiParam(value = \"Name of the table with type REALTIME OR OFFLINE\", required = true, example = \"myTable_OFFLINE\") @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @Context HttpHeaders httpHeaders)\n+      throws Exception {\n+    LOGGER.info(\"Get a request to download segment {} for table {}\", segmentName, tableName);", "originalCommit": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2Nzg3Ng==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405867876", "bodyText": "Done.", "author": "chenboat", "createdAt": "2020-04-08T23:16:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4NzY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODM4Mw==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405188383", "bodyText": "Until now, the only way to download a segment was via controller API. With this, we have introduced a new API to download segment. So, we need to add the access control here. See PinotSegmentUploadDownloadRestletResource\nThe general approach we have take is to have different AccessControl interface and factory declarations for each component, so you should add one for the server.\nI am ok if it is done in a different PR, just mark as a TODO here. and include another independent PR", "author": "mcvsubbu", "createdAt": "2020-04-08T00:21:22Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/TablesResource.java", "diffHunk": "@@ -175,4 +183,41 @@ public String getCrcMetadataForTable(\n       }\n     }\n   }\n+\n+  @GET\n+  @Produces(MediaType.APPLICATION_OCTET_STREAM)\n+  @Path(\"/tables/{tableName}/segments/{segmentName}\")\n+  @ApiOperation(value = \"Download a segment\", notes = \"Download a segment in zipped tar format\")\n+  public Response downloadSegment(\n+      @ApiParam(value = \"Name of the table with type REALTIME OR OFFLINE\", required = true, example = \"myTable_OFFLINE\") @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @Context HttpHeaders httpHeaders)\n+      throws Exception {\n+    LOGGER.info(\"Get a request to download segment {} for table {}\", segmentName, tableName);\n+    TableDataManager tableDataManager = checkGetTableDataManager(tableName);\n+    SegmentDataManager segmentDataManager = tableDataManager.acquireSegment(segmentName);\n+    if (segmentDataManager == null) {\n+      throw new WebApplicationException(String.format(\"Table %s segments %s does not exist\", tableName, segmentName),\n+          Response.Status.NOT_FOUND);\n+    }\n+    try {", "originalCommit": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2ODczMQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405868731", "bodyText": "Done.", "author": "chenboat", "createdAt": "2020-04-08T23:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwNjMxMA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405906310", "bodyText": "@mcvsubbu Are we going to merge all these PRs together? We cannot deploy a version without access control on segment download", "author": "Jackie-Jiang", "createdAt": "2020-04-09T01:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM1NzA1Ng==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r406357056", "bodyText": "@Jackie-Jiang why do you think we cannot deploy a version without access control?", "author": "mcvsubbu", "createdAt": "2020-04-09T17:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM2NjI4NQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r406366285", "bodyText": "@mcvsubbu Because we are GDPR compliance. I don't think we should allow downloading without access control.", "author": "Jackie-Jiang", "createdAt": "2020-04-09T17:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MjI1MQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r406372251", "bodyText": "@Jackie-Jiang Pinot open source is not GDPR compliant. You can see that even though Controller APIs have a call out to Auth layer, the default is  allow-all authenticator. The same holds for the server as well.\nIt is up to the admins to decide how to plug-in  appropriate auth systems. I am expecting that @chenboat  will add an auth layer callout either in this or immediately following PR", "author": "mcvsubbu", "createdAt": "2020-04-09T17:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzMDM3MQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r406530371", "bodyText": "@mcvsubbu @Jackie-Jiang I prefer to adding the auth layer in a PR immediately following this one. Looking at PinotSegmentUploadDownloadRestletResource, it seems that we can reuse the same AccessControlFactory and AccessControl class, right?", "author": "chenboat", "createdAt": "2020-04-09T23:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzNDk4Mw==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r406534983", "bodyText": "Like I said before, I believe we named them the same, but they exist as different classes, one in each \"product\". So, you need to create one for server.  You cannot create a dependency from server onto controller", "author": "mcvsubbu", "createdAt": "2020-04-09T23:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0ODc5NQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r406548795", "bodyText": "I was thinking about moving AccessControlFactory and AccessControl classes to Pinot-common or core to reuse the classes. This will also avoid introduce server to controller dependency. Is any issue with this approach?", "author": "chenboat", "createdAt": "2020-04-10T00:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMjE5Ng==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r407802196", "bodyText": "These may not be common, and may evolve to be different classes. The kind of auth that one may want fo server may be very different from that of what is needed in Broker vs Controller. It is best to keep them apart.", "author": "mcvsubbu", "createdAt": "2020-04-14T00:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg4ODkzMg==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r407888932", "bodyText": "I will add a separate AccessControlFactory class in an immediate follow-on PR. The reason is to keep this PR's focus. @Jackie-Jiang, please let me know if you still have issue with this plan.", "author": "chenboat", "createdAt": "2020-04-14T06:10:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MTg1NA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r408341854", "bodyText": "@chenboat I'm okay addressing it later", "author": "Jackie-Jiang", "createdAt": "2020-04-14T18:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4ODM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5MDM1MA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405190350", "bodyText": "We may need to limit the number of simultaneous execution of this line. The server is serving queries, and can get overwhelmed and affect the response time if too many of these are execting.\nI am fine with noting this as a TODO here for now, and re-visiting if it becomes a problem.", "author": "mcvsubbu", "createdAt": "2020-04-08T00:28:02Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/TablesResource.java", "diffHunk": "@@ -175,4 +183,41 @@ public String getCrcMetadataForTable(\n       }\n     }\n   }\n+\n+  @GET\n+  @Produces(MediaType.APPLICATION_OCTET_STREAM)\n+  @Path(\"/tables/{tableName}/segments/{segmentName}\")\n+  @ApiOperation(value = \"Download a segment\", notes = \"Download a segment in zipped tar format\")\n+  public Response downloadSegment(\n+      @ApiParam(value = \"Name of the table with type REALTIME OR OFFLINE\", required = true, example = \"myTable_OFFLINE\") @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @Context HttpHeaders httpHeaders)\n+      throws Exception {\n+    LOGGER.info(\"Get a request to download segment {} for table {}\", segmentName, tableName);\n+    TableDataManager tableDataManager = checkGetTableDataManager(tableName);\n+    SegmentDataManager segmentDataManager = tableDataManager.acquireSegment(segmentName);\n+    if (segmentDataManager == null) {\n+      throw new WebApplicationException(String.format(\"Table %s segments %s does not exist\", tableName, segmentName),\n+          Response.Status.NOT_FOUND);\n+    }\n+    try {\n+      String tableDir = tableDataManager.getTableDataDir();\n+      String tarFilePath = TarGzCompressionUtils.createTarGzOfDirectory(tableDir + \"/\" + segmentName);", "originalCommit": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3MTI3OA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405871278", "bodyText": "TODO added.", "author": "chenboat", "createdAt": "2020-04-08T23:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5MDM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5MDc3MQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405190771", "bodyText": "nit: Use the TableNameBuilder. let TABLE_NAME still be there, and you can use the builder to derive the other two", "author": "mcvsubbu", "createdAt": "2020-04-08T00:29:05Z", "path": "pinot-server/src/test/java/org/apache/pinot/server/api/BaseResourceTest.java", "diffHunk": "@@ -55,11 +56,12 @@\n public abstract class BaseResourceTest {\n   private static final String AVRO_DATA_PATH = \"data/test_data-mv.avro\";\n   private static final File INDEX_DIR = new File(FileUtils.getTempDirectory(), \"BaseResourceTest\");\n-  protected static final String TABLE_NAME = \"testTable\";\n+  protected static final String REALTIME_TABLE_NAME = \"testTable_REALTIME\";", "originalCommit": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI3Njk5MA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405276990", "bodyText": "+1", "author": "jackjlli", "createdAt": "2020-04-08T06:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NzM0Ng==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405877346", "bodyText": "DONE.", "author": "chenboat", "createdAt": "2020-04-08T23:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5MDc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNjM5MQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405236391", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new WebApplicationException(String.format(\"Table %s segments %s does not exist\", tableName, segmentName),\n          \n          \n            \n                  throw new WebApplicationException(String.format(\"Table %s segment %s does not exist\", tableName, segmentName),", "author": "haibow", "createdAt": "2020-04-08T03:23:31Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/TablesResource.java", "diffHunk": "@@ -175,4 +183,41 @@ public String getCrcMetadataForTable(\n       }\n     }\n   }\n+\n+  @GET\n+  @Produces(MediaType.APPLICATION_OCTET_STREAM)\n+  @Path(\"/tables/{tableName}/segments/{segmentName}\")\n+  @ApiOperation(value = \"Download a segment\", notes = \"Download a segment in zipped tar format\")\n+  public Response downloadSegment(\n+      @ApiParam(value = \"Name of the table with type REALTIME OR OFFLINE\", required = true, example = \"myTable_OFFLINE\") @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @Context HttpHeaders httpHeaders)\n+      throws Exception {\n+    LOGGER.info(\"Get a request to download segment {} for table {}\", segmentName, tableName);\n+    TableDataManager tableDataManager = checkGetTableDataManager(tableName);\n+    SegmentDataManager segmentDataManager = tableDataManager.acquireSegment(segmentName);\n+    if (segmentDataManager == null) {\n+      throw new WebApplicationException(String.format(\"Table %s segments %s does not exist\", tableName, segmentName),", "originalCommit": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NzUyNg==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405877526", "bodyText": "Done", "author": "chenboat", "createdAt": "2020-04-08T23:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNjM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNjQxOA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405236418", "bodyText": "Could you try formatting this? Should not be in the same line.", "author": "haibow", "createdAt": "2020-04-08T03:23:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/BaseTableDataManager.java", "diffHunk": "@@ -211,4 +211,7 @@ private void closeSegment(SegmentDataManager segmentDataManager) {\n   public String getTableName() {\n     return _tableNameWithType;\n   }\n+\n+  @Override\n+  public String getTableDataDir() { return _tableDataDir; }", "originalCommit": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3Nzc4Mg==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405877782", "bodyText": "done.", "author": "chenboat", "createdAt": "2020-04-08T23:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNjQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI3OTQ4MQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405279481", "bodyText": "getTableSize() method is often used for offline table. Can you add the test for offline table as well?", "author": "jackjlli", "createdAt": "2020-04-08T06:09:23Z", "path": "pinot-server/src/test/java/org/apache/pinot/server/api/TableSizeResourceTest.java", "diffHunk": "@@ -37,9 +37,9 @@ public void testTableSizeNotFound() {\n   @Test\n   public void testTableSizeDetailed() {\n     TableSizeInfo tableSizeInfo = _webTarget.path(TABLE_SIZE_PATH).request().get(TableSizeInfo.class);\n-    ImmutableSegment defaultSegment = _indexSegments.get(0);\n+    ImmutableSegment defaultSegment = _realtimeIndexSegments.get(0);", "originalCommit": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4NjAyNg==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405886026", "bodyText": "done.", "author": "chenboat", "createdAt": "2020-04-09T00:13:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI3OTQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI4MDIyNA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405280224", "bodyText": "import java.nio.file.Path;", "author": "jackjlli", "createdAt": "2020-04-08T06:11:37Z", "path": "pinot-server/src/test/java/org/apache/pinot/server/api/TablesResourceTest.java", "diffHunk": "@@ -149,4 +160,62 @@ public void testSegmentCrcMetadata()\n       Assert.assertEquals(segmentsCrc.get(segmentName).asText(), crc);\n     }\n   }\n+\n+  @Test\n+  public void testDownloadSegments()\n+      throws Exception {\n+    // Verify the content of the downloaded segment from a realtime table.\n+    Assert.assertTrue(downLoadAndVerifySegmentContent(REALTIME_TABLE_NAME, _realtimeIndexSegments.get(0)));\n+    // Verify the content of the downloaded segment from an offline table.\n+    Assert.assertTrue(downLoadAndVerifySegmentContent(OFFLINE_TABLE_NAME, _offlineIndexSegments.get(0)));\n+\n+    // Verify non-existent table and segment download return NOT_FOUND status.\n+    Response response = _webTarget.path(\"/tables/UNKNOWN_REALTIME/segments/segmentname\").request()\n+        .get(Response.class);\n+    Assert.assertEquals(response.getStatus(), Response.Status.NOT_FOUND.getStatusCode());\n+\n+    response = _webTarget.path(\"/tables/\" + REALTIME_TABLE_NAME + \"/segments/UNKNOWN_SEGMENT\").request().get(Response.class);\n+    Assert.assertEquals(response.getStatus(), Response.Status.NOT_FOUND.getStatusCode());\n+  }\n+\n+  // Verify metadata file from segments.\n+  private boolean downLoadAndVerifySegmentContent(String tableNameWithType, IndexSegment segment) {\n+    String segmentPath = \"/tables/\" + tableNameWithType + \"/segments/\" + segment.getSegmentName();\n+\n+    // Download the segment and save to a temp local file.\n+    Response response = _webTarget.path(segmentPath).request().get(Response.class);\n+    Assert.assertEquals(response.getStatus(), Response.Status.OK.getStatusCode());\n+    File segmentFile = response.readEntity(File.class);\n+\n+    File tempMetadataDir = new File(FileUtils.getTempDirectory(), \"segment_metadata\");\n+    try (// Extract metadata.properties\n+        InputStream metadataPropertiesInputStream = TarGzCompressionUtils\n+            .unTarOneFile(new FileInputStream(segmentFile), V1Constants.MetadataKeys.METADATA_FILE_NAME);\n+        // Extract creation.meta\n+        InputStream creationMetaInputStream = TarGzCompressionUtils\n+            .unTarOneFile(new FileInputStream(segmentFile), V1Constants.SEGMENT_CREATION_META)) {\n+      Preconditions\n+          .checkState(tempMetadataDir.mkdirs(), \"Failed to create directory: %s\", tempMetadataDir.getAbsolutePath());\n+\n+      Preconditions.checkNotNull(metadataPropertiesInputStream, \"%s does not exist\",\n+          V1Constants.MetadataKeys.METADATA_FILE_NAME);\n+      java.nio.file.Path metadataPropertiesPath = FileSystems.getDefault()", "originalCommit": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4NjMzMQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405886331", "bodyText": "done.", "author": "chenboat", "createdAt": "2020-04-09T00:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI4MDIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI4MDUxOQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405280519", "bodyText": "May be good to log the exception here?", "author": "jackjlli", "createdAt": "2020-04-08T06:12:21Z", "path": "pinot-server/src/test/java/org/apache/pinot/server/api/TablesResourceTest.java", "diffHunk": "@@ -149,4 +160,62 @@ public void testSegmentCrcMetadata()\n       Assert.assertEquals(segmentsCrc.get(segmentName).asText(), crc);\n     }\n   }\n+\n+  @Test\n+  public void testDownloadSegments()\n+      throws Exception {\n+    // Verify the content of the downloaded segment from a realtime table.\n+    Assert.assertTrue(downLoadAndVerifySegmentContent(REALTIME_TABLE_NAME, _realtimeIndexSegments.get(0)));\n+    // Verify the content of the downloaded segment from an offline table.\n+    Assert.assertTrue(downLoadAndVerifySegmentContent(OFFLINE_TABLE_NAME, _offlineIndexSegments.get(0)));\n+\n+    // Verify non-existent table and segment download return NOT_FOUND status.\n+    Response response = _webTarget.path(\"/tables/UNKNOWN_REALTIME/segments/segmentname\").request()\n+        .get(Response.class);\n+    Assert.assertEquals(response.getStatus(), Response.Status.NOT_FOUND.getStatusCode());\n+\n+    response = _webTarget.path(\"/tables/\" + REALTIME_TABLE_NAME + \"/segments/UNKNOWN_SEGMENT\").request().get(Response.class);\n+    Assert.assertEquals(response.getStatus(), Response.Status.NOT_FOUND.getStatusCode());\n+  }\n+\n+  // Verify metadata file from segments.\n+  private boolean downLoadAndVerifySegmentContent(String tableNameWithType, IndexSegment segment) {\n+    String segmentPath = \"/tables/\" + tableNameWithType + \"/segments/\" + segment.getSegmentName();\n+\n+    // Download the segment and save to a temp local file.\n+    Response response = _webTarget.path(segmentPath).request().get(Response.class);\n+    Assert.assertEquals(response.getStatus(), Response.Status.OK.getStatusCode());\n+    File segmentFile = response.readEntity(File.class);\n+\n+    File tempMetadataDir = new File(FileUtils.getTempDirectory(), \"segment_metadata\");\n+    try (// Extract metadata.properties\n+        InputStream metadataPropertiesInputStream = TarGzCompressionUtils\n+            .unTarOneFile(new FileInputStream(segmentFile), V1Constants.MetadataKeys.METADATA_FILE_NAME);\n+        // Extract creation.meta\n+        InputStream creationMetaInputStream = TarGzCompressionUtils\n+            .unTarOneFile(new FileInputStream(segmentFile), V1Constants.SEGMENT_CREATION_META)) {\n+      Preconditions\n+          .checkState(tempMetadataDir.mkdirs(), \"Failed to create directory: %s\", tempMetadataDir.getAbsolutePath());\n+\n+      Preconditions.checkNotNull(metadataPropertiesInputStream, \"%s does not exist\",\n+          V1Constants.MetadataKeys.METADATA_FILE_NAME);\n+      java.nio.file.Path metadataPropertiesPath = FileSystems.getDefault()\n+          .getPath(tempMetadataDir.getAbsolutePath(), V1Constants.MetadataKeys.METADATA_FILE_NAME);\n+      Files.copy(metadataPropertiesInputStream, metadataPropertiesPath);\n+\n+      Preconditions.checkNotNull(creationMetaInputStream, \"%s does not exist\", V1Constants.SEGMENT_CREATION_META);\n+      java.nio.file.Path creationMetaPath =\n+          FileSystems.getDefault().getPath(tempMetadataDir.getAbsolutePath(), V1Constants.SEGMENT_CREATION_META);\n+      Files.copy(creationMetaInputStream, creationMetaPath);\n+      // Load segment metadata\n+      SegmentMetadataImpl metadata = new SegmentMetadataImpl(tempMetadataDir);\n+\n+      Assert.assertEquals(tableNameWithType, metadata.getTableName());\n+      return true;\n+    } catch (Exception e) {\n+      return false;", "originalCommit": "ecf20a2b941574c3073a2db2aed32ab0d1607b31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg5MjI0Ng==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405892246", "bodyText": "Done.", "author": "chenboat", "createdAt": "2020-04-09T00:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI4MDUxOQ=="}], "type": "inlineReview"}, {"oid": "3739885588c270184420aa4aed59216607478637", "url": "https://github.com/apache/pinot/commit/3739885588c270184420aa4aed59216607478637", "message": "Revise based on feedback.", "committedDate": "2020-04-09T00:34:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwNzYyOQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405907629", "bodyText": "Recommend returning an File to avoid the edge case of trailing \\", "author": "Jackie-Jiang", "createdAt": "2020-04-09T01:36:19Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/BaseTableDataManager.java", "diffHunk": "@@ -211,4 +211,9 @@ private void closeSegment(SegmentDataManager segmentDataManager) {\n   public String getTableName() {\n     return _tableNameWithType;\n   }\n+\n+  @Override\n+  public String getTableDataDir() {", "originalCommit": "3739885588c270184420aa4aed59216607478637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwOTA4Ng==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r406509086", "bodyText": "done.", "author": "chenboat", "createdAt": "2020-04-09T22:19:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwNzYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwODA1OQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r405908059", "bodyText": "You should put all .tar.gz file in some temporary directory, and clean them up whenever server restarted. Otherwise, if the server shut down when downloading the segment, the segment will remain there forever", "author": "Jackie-Jiang", "createdAt": "2020-04-09T01:38:03Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/TablesResource.java", "diffHunk": "@@ -175,4 +183,43 @@ public String getCrcMetadataForTable(\n       }\n     }\n   }\n+\n+  // TODO Add access control similar to PinotSegmentUploadDownloadRestletResource for segment download.\n+  @GET\n+  @Produces(MediaType.APPLICATION_OCTET_STREAM)\n+  @Path(\"/segments/{tableNameWithType}/{segmentName}\")\n+  @ApiOperation(value = \"Download a segment\", notes = \"Download a segment in zipped tar format\")\n+  public Response downloadSegment(\n+      @ApiParam(value = \"Name of the table with type REALTIME OR OFFLINE\", required = true, example = \"myTable_OFFLINE\") @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @Context HttpHeaders httpHeaders)\n+      throws Exception {\n+    LOGGER.info(\"Received a request to download segment {} for table {}\", segmentName, tableNameWithType);\n+    TableDataManager tableDataManager = checkGetTableDataManager(tableNameWithType);\n+    SegmentDataManager segmentDataManager = tableDataManager.acquireSegment(segmentName);\n+    if (segmentDataManager == null) {\n+      throw new WebApplicationException(\n+          String.format(\"Table %s segment %s does not exist\", tableNameWithType, segmentName),\n+          Response.Status.NOT_FOUND);\n+    }\n+    try {\n+      String tableDir = tableDataManager.getTableDataDir();\n+      // TODO Limit the number of concurrent downloads of segments because compression is an expensive operation.\n+      String tarFilePath = TarGzCompressionUtils.createTarGzOfDirectory(tableDir + File.separator + segmentName);", "originalCommit": "3739885588c270184420aa4aed59216607478637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwOTA0MA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r406509040", "bodyText": "How about adding a tarFile.deleteOnExit(); here so that the file will be deleted when the vm exits?", "author": "chenboat", "createdAt": "2020-04-09T22:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwODA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzNTI2MQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r406535261", "bodyText": "You can use the temp dir that is configured as segmentTarDir for the server", "author": "mcvsubbu", "createdAt": "2020-04-09T23:46:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwODA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzNjUzMw==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r406536533", "bodyText": "You have two options here:\n(1) Create a temporary tar file (unique name), and delete it soon after you send the segment out, in the finally block. In addition you can also mark it as deleteOnExit, in case things happen during tar/serving. In this case, use segmentTarDir config to drop the file for (one) serve to another host.\n(2) Create a semi-permanent tar file (non-unique name) so that it can be re-used when another request comes in for the same segment. In this case, you need to make sure that the file is not over-written when two requests come in for serving the same segment. In this case, I think the permanent tar file should be created in tableDataDir like you have done. But you do need to synchronize the creation of the file, and check if the file is already created by another thread, no?\nWhich technique do you want to go with?", "author": "mcvsubbu", "createdAt": "2020-04-09T23:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwODA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MDI1NA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r406550254", "bodyText": "I would go with (1) for now. (2) goes to the same line as the performance optimization we put as TODO here. The deleteOnExit has been added already. Using segmentTarDir config seems to be an extra protection against polluting server disk.", "author": "chenboat", "createdAt": "2020-04-10T00:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwODA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMTc3Mg==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r407801772", "bodyText": "The segmentTarDir may be configured to be the high performance disk (e.g. ssd)  as opposed to the disk for log messages (boot/hdd). So, we should use that for sure. Please go ahead and change it to use a unique name, and add a note that this may deteriorate performance if more than one replica asks to download segments.", "author": "mcvsubbu", "createdAt": "2020-04-14T00:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwODA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg4NzY3OQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r407887679", "bodyText": "Done using segmentTarDir to store the temporary file. TODO added.", "author": "chenboat", "createdAt": "2020-04-14T06:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwODA1OQ=="}], "type": "inlineReview"}, {"oid": "8e37cc9eb057c03a647e773b12ff7f53b7b5c15a", "url": "https://github.com/apache/pinot/commit/8e37cc9eb057c03a647e773b12ff7f53b7b5c15a", "message": "Revise the getTableDir and delete tar.gz files on exit.", "committedDate": "2020-04-09T22:21:06Z", "type": "commit"}, {"oid": "5db84ce7dfb0929ffac5252682c6db058d271683", "url": "https://github.com/apache/pinot/commit/5db84ce7dfb0929ffac5252682c6db058d271683", "message": "Store temp tar.gz file in the server's segment tar folder.", "committedDate": "2020-04-14T06:06:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNTY1Mg==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r408315652", "bodyText": "better to use UUID", "author": "mcvsubbu", "createdAt": "2020-04-14T17:36:20Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/TablesResource.java", "diffHunk": "@@ -175,4 +183,49 @@ public String getCrcMetadataForTable(\n       }\n     }\n   }\n+\n+  // TODO Add access control similar to PinotSegmentUploadDownloadRestletResource for segment download.\n+  @GET\n+  @Produces(MediaType.APPLICATION_OCTET_STREAM)\n+  @Path(\"/segments/{tableNameWithType}/{segmentName}\")\n+  @ApiOperation(value = \"Download a segment\", notes = \"Download a segment in zipped tar format\")\n+  public Response downloadSegment(\n+      @ApiParam(value = \"Name of the table with type REALTIME OR OFFLINE\", required = true, example = \"myTable_OFFLINE\") @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @Context HttpHeaders httpHeaders)\n+      throws Exception {\n+    LOGGER.info(\"Received a request to download segment {} for table {}\", segmentName, tableNameWithType);\n+    TableDataManager tableDataManager = checkGetTableDataManager(tableNameWithType);\n+    SegmentDataManager segmentDataManager = tableDataManager.acquireSegment(segmentName);\n+    if (segmentDataManager == null) {\n+      throw new WebApplicationException(\n+          String.format(\"Table %s segment %s does not exist\", tableNameWithType, segmentName),\n+          Response.Status.NOT_FOUND);\n+    }\n+    try {\n+      String tableDir = tableDataManager.getTableDataDir().getAbsolutePath();\n+      // TODO Limit the number of concurrent downloads of segments because compression is an expensive operation.\n+      // Store the tar.gz segment file in the server's segmentTarDir folder with a unique file name.\n+      // Note that two clients asking the same segment file will result in the same tar.gz files being created twice.\n+      // Will revisit for optimization if performance becomes an issue.\n+      String tarFilePath = TarGzCompressionUtils.createTarGzOfDirectory(tableDir + File.separator + segmentName,\n+          serverInstance.getInstanceDataManager().getSegmentFileDirectory() + File.separator + segmentName + \"-\"\n+              + System.currentTimeMillis());", "originalCommit": "5db84ce7dfb0929ffac5252682c6db058d271683", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MDQ3OQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r408340479", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return new File(_tableDataDir);\n          \n          \n            \n                return _indexDir;", "author": "Jackie-Jiang", "createdAt": "2020-04-14T18:16:54Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/BaseTableDataManager.java", "diffHunk": "@@ -211,4 +211,9 @@ private void closeSegment(SegmentDataManager segmentDataManager) {\n   public String getTableName() {\n     return _tableNameWithType;\n   }\n+\n+  @Override\n+  public File getTableDataDir() {\n+    return new File(_tableDataDir);", "originalCommit": "5db84ce7dfb0929ffac5252682c6db058d271683", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MjUzMQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r408342531", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  String tarFilePath = TarGzCompressionUtils.createTarGzOfDirectory(tableDir + File.separator + segmentName,\n          \n          \n            \n                  String tarFilePath = TarGzCompressionUtils.createTarGzOfDirectory(new File(tableDataManager.getTableDataDir(), segmentName).getAbsolutePath(),", "author": "Jackie-Jiang", "createdAt": "2020-04-14T18:20:22Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/TablesResource.java", "diffHunk": "@@ -175,4 +183,49 @@ public String getCrcMetadataForTable(\n       }\n     }\n   }\n+\n+  // TODO Add access control similar to PinotSegmentUploadDownloadRestletResource for segment download.\n+  @GET\n+  @Produces(MediaType.APPLICATION_OCTET_STREAM)\n+  @Path(\"/segments/{tableNameWithType}/{segmentName}\")\n+  @ApiOperation(value = \"Download a segment\", notes = \"Download a segment in zipped tar format\")\n+  public Response downloadSegment(\n+      @ApiParam(value = \"Name of the table with type REALTIME OR OFFLINE\", required = true, example = \"myTable_OFFLINE\") @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @Context HttpHeaders httpHeaders)\n+      throws Exception {\n+    LOGGER.info(\"Received a request to download segment {} for table {}\", segmentName, tableNameWithType);\n+    TableDataManager tableDataManager = checkGetTableDataManager(tableNameWithType);\n+    SegmentDataManager segmentDataManager = tableDataManager.acquireSegment(segmentName);\n+    if (segmentDataManager == null) {\n+      throw new WebApplicationException(\n+          String.format(\"Table %s segment %s does not exist\", tableNameWithType, segmentName),\n+          Response.Status.NOT_FOUND);\n+    }\n+    try {\n+      String tableDir = tableDataManager.getTableDataDir().getAbsolutePath();\n+      // TODO Limit the number of concurrent downloads of segments because compression is an expensive operation.\n+      // Store the tar.gz segment file in the server's segmentTarDir folder with a unique file name.\n+      // Note that two clients asking the same segment file will result in the same tar.gz files being created twice.\n+      // Will revisit for optimization if performance becomes an issue.\n+      String tarFilePath = TarGzCompressionUtils.createTarGzOfDirectory(tableDir + File.separator + segmentName,", "originalCommit": "5db84ce7dfb0929ffac5252682c6db058d271683", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0NjcwNg==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r408346706", "bodyText": "Make a separate directory (e.g. peerDownloadTemp) under segment file directory to hold all these files. Also good to keep the tableName for debugging purpose? You can refer to the name in SegmentFetcherAndLoader line 183", "author": "Jackie-Jiang", "createdAt": "2020-04-14T18:27:18Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/TablesResource.java", "diffHunk": "@@ -175,4 +183,49 @@ public String getCrcMetadataForTable(\n       }\n     }\n   }\n+\n+  // TODO Add access control similar to PinotSegmentUploadDownloadRestletResource for segment download.\n+  @GET\n+  @Produces(MediaType.APPLICATION_OCTET_STREAM)\n+  @Path(\"/segments/{tableNameWithType}/{segmentName}\")\n+  @ApiOperation(value = \"Download a segment\", notes = \"Download a segment in zipped tar format\")\n+  public Response downloadSegment(\n+      @ApiParam(value = \"Name of the table with type REALTIME OR OFFLINE\", required = true, example = \"myTable_OFFLINE\") @PathParam(\"tableNameWithType\") String tableNameWithType,\n+      @ApiParam(value = \"Name of the segment\", required = true) @PathParam(\"segmentName\") @Encoded String segmentName,\n+      @Context HttpHeaders httpHeaders)\n+      throws Exception {\n+    LOGGER.info(\"Received a request to download segment {} for table {}\", segmentName, tableNameWithType);\n+    TableDataManager tableDataManager = checkGetTableDataManager(tableNameWithType);\n+    SegmentDataManager segmentDataManager = tableDataManager.acquireSegment(segmentName);\n+    if (segmentDataManager == null) {\n+      throw new WebApplicationException(\n+          String.format(\"Table %s segment %s does not exist\", tableNameWithType, segmentName),\n+          Response.Status.NOT_FOUND);\n+    }\n+    try {\n+      String tableDir = tableDataManager.getTableDataDir().getAbsolutePath();\n+      // TODO Limit the number of concurrent downloads of segments because compression is an expensive operation.\n+      // Store the tar.gz segment file in the server's segmentTarDir folder with a unique file name.\n+      // Note that two clients asking the same segment file will result in the same tar.gz files being created twice.\n+      // Will revisit for optimization if performance becomes an issue.\n+      String tarFilePath = TarGzCompressionUtils.createTarGzOfDirectory(tableDir + File.separator + segmentName,\n+          serverInstance.getInstanceDataManager().getSegmentFileDirectory() + File.separator + segmentName + \"-\"", "originalCommit": "5db84ce7dfb0929ffac5252682c6db058d271683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4ODEzOA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r408488138", "bodyText": "done", "author": "chenboat", "createdAt": "2020-04-14T23:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0NjcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1MDQ1NA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r408350454", "bodyText": "Why do you need to separate realtime and offline segments? They should be handled in the same way right?\nAlso the realtime index segments are not CONSUMING segment, but COMPLETED segment, which is a little bit confusing.", "author": "Jackie-Jiang", "createdAt": "2020-04-14T18:33:36Z", "path": "pinot-server/src/test/java/org/apache/pinot/server/api/BaseResourceTest.java", "diffHunk": "@@ -58,8 +59,8 @@\n   protected static final String TABLE_NAME = \"testTable\";\n \n   private final Map<String, TableDataManager> _tableDataManagerMap = new HashMap<>();\n-  protected final List<ImmutableSegment> _indexSegments = new ArrayList<>();\n-\n+  protected final List<ImmutableSegment> _realtimeIndexSegments = new ArrayList<>();", "originalCommit": "5db84ce7dfb0929ffac5252682c6db058d271683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4NzkyOQ==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r408487929", "bodyText": "Before we talk about the separation of two kinds of segments, I want to point out this test was set up almost like a mini integration tests with mock servers and download clients. So ideally it should reflect a true Pinot server setup environment with proper directory naming associated with table name and type -- this was NOT done earlier i think (e.g., the test table name does not have type). The modified test code adheres to these expectations. The separation of segments also follows the same idea: they are just different segments.\nFor your comments about realtime index segment, I believe you are referring to the fact that CONSUMING segment could not be downloaded just like COMPLETED segment, right? Yes, that is true for now and we can add a note to API as well.\n.", "author": "chenboat", "createdAt": "2020-04-14T23:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1MDQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxODcxMg==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r408518712", "bodyText": "I agree the test setup should reflect the true cluster setup, where the table name should have the correct type suffix.\nMy concern about the CONSUMING segment is because the CONSUMING segment is not ImmutableSegment, so I'm not sure if adding separate realtime segments as a list of ImmutableSegment is the correct design.\nCurrently the test setup is mimicking a offline only table, so I would suggest introducing the realtime part as a separate PR (the fix for the table name is good).", "author": "Jackie-Jiang", "createdAt": "2020-04-15T00:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1MDQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4NjY5Nw==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r408586697", "bodyText": "To me, this new API and its test provides downloading of immutable (or non-consuming) segments. So I agree there is a subset of realtime segments not covered here. We can either rename the API or add notes for this important subtlety.  Given this API is so new and our main design is to download immutable segments, I added notes to the API to highlight this point.\nSince the code still allows immutable realtime segment downloads, I feel the test should also cover this case.", "author": "chenboat", "createdAt": "2020-04-15T05:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1MDQ1NA=="}], "type": "inlineReview"}, {"oid": "bae23b66c596aec3fe49e4914dbd41e6f7bcea25", "url": "https://github.com/apache/pinot/commit/bae23b66c596aec3fe49e4914dbd41e6f7bcea25", "message": "Further revision based on feedbacks.", "committedDate": "2020-04-14T23:12:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxODc2NA==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r408518764", "bodyText": "What about offline segments?", "author": "Jackie-Jiang", "createdAt": "2020-04-15T00:52:30Z", "path": "pinot-server/src/test/java/org/apache/pinot/server/api/BaseResourceTest.java", "diffHunk": "@@ -96,46 +103,47 @@ public void setUp()\n   @AfterClass\n   public void tearDown() {\n     _adminApiApplication.stop();\n-    for (ImmutableSegment immutableSegment : _indexSegments) {\n+    for (ImmutableSegment immutableSegment : _realtimeIndexSegments) {", "originalCommit": "bae23b66c596aec3fe49e4914dbd41e6f7bcea25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3OTU2Mg==", "url": "https://github.com/apache/pinot/pull/5221#discussion_r408579562", "bodyText": "Done.", "author": "chenboat", "createdAt": "2020-04-15T04:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxODc2NA=="}], "type": "inlineReview"}, {"oid": "358d85ff973fedf129fb79235684aab95912517f", "url": "https://github.com/apache/pinot/commit/358d85ff973fedf129fb79235684aab95912517f", "message": "Fix tests.", "committedDate": "2020-04-15T05:20:59Z", "type": "commit"}, {"oid": "f884bdc8b190d760d487555a4d6ed5bd26f7947f", "url": "https://github.com/apache/pinot/commit/f884bdc8b190d760d487555a4d6ed5bd26f7947f", "message": "Minor typo.", "committedDate": "2020-04-15T05:25:13Z", "type": "commit"}]}