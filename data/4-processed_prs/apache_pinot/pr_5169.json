{"pr_number": 5169, "pr_title": "Table level timeout implementation", "pr_createdAt": "2020-03-21T02:23:01Z", "pr_url": "https://github.com/apache/pinot/pull/5169", "timeline": [{"oid": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "url": "https://github.com/apache/pinot/commit/4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "message": "Table level timeout implementation\n\nIntroduced 3 levels of query timeout, where the first available one will be used:\n- Query-level: Passed under the query options with key 'timeoutMs'\n- Table-level: Configured under the QueryConfig inside TableConfig\n- Instance-level: Configured in the instance config, or default\n\nThe timeout will be picked up on the broker side, and passed to the server under the query options.\nIf the query already timed out before broker sending the request to the servers, it will early terminate with BROKER_TIMEOUT_ERROR.\nIf the query timed out on the server side, broker should already returned with the partial response.\n\nThis PR also supports refreshing routing properties on table config change automatically.\nBecause the table config refresh is implemented using the Helix USER_DEFINE_MSG, both controller and broker need to be deployed in order to support it.\nNo specific deployment sequence is required (warning will be logged in BrokerUserDefinedMessageHandlerFactory when only one component is deployed).", "committedDate": "2020-03-21T02:59:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4Njk1OA==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396686958", "bodyText": "Can we move this line to just below Line 315 since this is the major logic of this code change in BaseBrokerRequestHandler?", "author": "jackjlli", "createdAt": "2020-03-23T19:00:13Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -312,8 +312,58 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n     long routingEndTimeNs = System.nanoTime();\n     _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_ROUTING, routingEndTimeNs - routingStartTimeNs);\n \n+    // Set timeout in the requests\n+    long timeSpentMs = TimeUnit.NANOSECONDS.toMillis(routingEndTimeNs - compilationStartTimeNs);\n+    // Get the per-query timeout from the broker request query options if exists\n+    long queryTimeoutMs = QueryOptions.getTimeoutMs(brokerRequest.getQueryOptions());\n+    // Remaining time in milliseconds for the server query execution\n+    // Use the max of offline table remaining time and realtime table remaining time for hybrid use case\n+    long remainingTimeMs = 0;\n+    // NOTE: Use query-level timeout if exists, or use table-level timeout if exists, or use instance-level timeout", "originalCommit": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczMTY5Mw==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396731693", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-03-23T20:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4Njk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4NzU3OQ==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396687579", "bodyText": "You can wrap this logic into a method so that offline and realtime table can reuse the same code.", "author": "jackjlli", "createdAt": "2020-03-23T19:01:14Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -312,8 +312,58 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n     long routingEndTimeNs = System.nanoTime();\n     _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_ROUTING, routingEndTimeNs - routingStartTimeNs);\n \n+    // Set timeout in the requests\n+    long timeSpentMs = TimeUnit.NANOSECONDS.toMillis(routingEndTimeNs - compilationStartTimeNs);\n+    // Get the per-query timeout from the broker request query options if exists\n+    long queryTimeoutMs = QueryOptions.getTimeoutMs(brokerRequest.getQueryOptions());\n+    // Remaining time in milliseconds for the server query execution\n+    // Use the max of offline table remaining time and realtime table remaining time for hybrid use case\n+    long remainingTimeMs = 0;\n+    // NOTE: Use query-level timeout if exists, or use table-level timeout if exists, or use instance-level timeout\n+    if (offlineBrokerRequest != null) {", "originalCommit": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0MDEyNQ==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396740125", "bodyText": "+1, I have the same comment", "author": "mcvsubbu", "createdAt": "2020-03-23T20:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4NzU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MDc2Ng==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396780766", "bodyText": "DOne", "author": "Jackie-Jiang", "createdAt": "2020-03-23T21:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4NzU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4ODY3OQ==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396688679", "bodyText": "I saw there are two places which use different types of long. Can we unify them together? E.g. always use -1 to denote getTimeoutMs is null.", "author": "jackjlli", "createdAt": "2020-03-23T19:03:09Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/RoutingManager.java", "diffHunk": "@@ -354,9 +359,12 @@ public synchronized void buildRouting(String tableNameWithType) {\n       }\n     }\n \n+    QueryConfig queryConfig = tableConfig.getQueryConfig();\n+    Long timeoutMs = queryConfig != null ? queryConfig.getTimeoutMs() : null;", "originalCommit": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyODIyNg==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396728226", "bodyText": "For json ser-de reason, it is risky to put -1 for null value (serialize & deserialize will break). I'll just use null in both places then", "author": "Jackie-Jiang", "createdAt": "2020-03-23T20:12:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4ODY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4OTMzNw==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396689337", "bodyText": "Can we specify the timeout here? Is it the max overall timeout for each query?", "author": "jackjlli", "createdAt": "2020-03-23T19:04:19Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/RoutingManager.java", "diffHunk": "@@ -450,11 +458,22 @@ public TimeBoundaryInfo getTimeBoundaryInfo(String offlineTableName) {\n     return timeBoundaryManager != null ? timeBoundaryManager.getTimeBoundaryInfo() : null;\n   }\n \n+  /**\n+   * Returns the timeout in milliseconds for the given table, or {@code null} if the timeout is not configured in the\n+   * table config.\n+   */\n+  @Nullable\n+  public Long getTimeoutMs(String tableNameWithType) {", "originalCommit": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczMDEwOA==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396730108", "bodyText": "I don't quite understand this comment. This is the timeout for the table specified in the table config", "author": "Jackie-Jiang", "createdAt": "2020-03-23T20:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4OTMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY5MDk3Nw==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396690977", "bodyText": "Also, I notice in the test you specified TimeoutMs to be 0. Does 0 has special meaning? If yes, could you add it to the description of this variable?", "author": "jackjlli", "createdAt": "2020-03-23T19:07:19Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/RoutingManager.java", "diffHunk": "@@ -354,9 +359,12 @@ public synchronized void buildRouting(String tableNameWithType) {\n       }\n     }\n \n+    QueryConfig queryConfig = tableConfig.getQueryConfig();\n+    Long timeoutMs = queryConfig != null ? queryConfig.getTimeoutMs() : null;", "originalCommit": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyOTUxMQ==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396729511", "bodyText": "It should not be 0 (added a check), but 1ms might be too long for broker compilation to timeout. Let me revise the test, merge the broker & server timeout so that test is not flaky.", "author": "Jackie-Jiang", "createdAt": "2020-03-23T20:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY5MDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyMzEyOA==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396723128", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.error(\"Caught exception while refreshing table config for table: {} (code: {}, type: {})\",\n          \n          \n            \n                  LOGGER.error(\"Caught exception while refreshing table config for table: {} (code: {}, error type: {})\",", "author": "mcvsubbu", "createdAt": "2020-03-23T20:02:25Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java", "diffHunk": "@@ -115,17 +121,15 @@ public HelixTaskResult handleMessage() {\n \n     @Override\n     public void onError(Exception e, ErrorCode errorCode, ErrorType errorType) {\n-      LOGGER.error(\"Caught exception while updating query quota of table: {} (code: {}, type: {})\", _tableNameWithType,\n-          errorCode, errorType, e);\n+      LOGGER.error(\"Caught exception while refreshing table config for table: {} (code: {}, type: {})\",", "originalCommit": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzI4NQ==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396783285", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-03-23T22:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyMzEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyNDI2NQ==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396724265", "bodyText": "not sure why we should merge the 2 managers. Fetching table config, checking for disabled table, etc.  maybe yes.", "author": "mcvsubbu", "createdAt": "2020-03-23T20:04:30Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java", "diffHunk": "@@ -98,15 +101,18 @@ public void onError(Exception e, ErrorCode errorCode, ErrorType errorType) {\n     }\n   }\n \n-  private class QueryQuotaUpdateMessageHandler extends DefaultMessageHandler {\n+  private class RefreshTableConfigMessageHandler extends MessageHandler {\n+    final String _tableNameWithType;\n \n-    public QueryQuotaUpdateMessageHandler(QueryQuotaUpdateMessage queryQuotaUpdateMessage,\n-        NotificationContext context) {\n-      super(queryQuotaUpdateMessage, context);\n+    RefreshTableConfigMessageHandler(TableConfigRefreshMessage tableConfigRefreshMessage, NotificationContext context) {\n+      super(tableConfigRefreshMessage, context);\n+      _tableNameWithType = tableConfigRefreshMessage.getTableNameWithType();\n     }\n \n     @Override\n     public HelixTaskResult handleMessage() {\n+      // TODO: Fetch the table config here and pass it into the managers, or consider merging these 2 managers", "originalCommit": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyNTI3NA==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396725274", "bodyText": "It is better to leave the error message here, in case there is some issue with Helix. Most likely it wont be called anyway.", "author": "mcvsubbu", "createdAt": "2020-03-23T20:06:22Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java", "diffHunk": "@@ -136,8 +140,7 @@ public HelixTaskResult handleMessage() {\n     }\n \n     @Override\n-    public void onError(Exception e, ErrorCode errorCode, ErrorType errorType) {\n-      LOGGER.error(\"Caught exception on table: {} (code: {}, type: {})\", _tableNameWithType, errorCode, errorType, e);\n+    public void onError(Exception e, ErrorCode code, ErrorType type) {", "originalCommit": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzMwNQ==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396783305", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-03-23T22:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyNTI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyOTc4Mw==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396729783", "bodyText": "Can you make a method out of the block between lines 324 and 338?  Logic seems to be repeated. At least, lines 324 to 331?", "author": "mcvsubbu", "createdAt": "2020-03-23T20:15:14Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -312,8 +312,58 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n     long routingEndTimeNs = System.nanoTime();\n     _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_ROUTING, routingEndTimeNs - routingStartTimeNs);\n \n+    // Set timeout in the requests\n+    long timeSpentMs = TimeUnit.NANOSECONDS.toMillis(routingEndTimeNs - compilationStartTimeNs);\n+    // Get the per-query timeout from the broker request query options if exists\n+    long queryTimeoutMs = QueryOptions.getTimeoutMs(brokerRequest.getQueryOptions());\n+    // Remaining time in milliseconds for the server query execution\n+    // Use the max of offline table remaining time and realtime table remaining time for hybrid use case\n+    long remainingTimeMs = 0;\n+    // NOTE: Use query-level timeout if exists, or use table-level timeout if exists, or use instance-level timeout\n+    if (offlineBrokerRequest != null) {\n+      long offlineTimeoutMs;", "originalCommit": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczMTEwMg==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396731102", "bodyText": "Math.min? Should we not take the stricter time to be the timeout value?", "author": "mcvsubbu", "createdAt": "2020-03-23T20:17:58Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -312,8 +312,58 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n     long routingEndTimeNs = System.nanoTime();\n     _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_ROUTING, routingEndTimeNs - routingStartTimeNs);\n \n+    // Set timeout in the requests\n+    long timeSpentMs = TimeUnit.NANOSECONDS.toMillis(routingEndTimeNs - compilationStartTimeNs);\n+    // Get the per-query timeout from the broker request query options if exists\n+    long queryTimeoutMs = QueryOptions.getTimeoutMs(brokerRequest.getQueryOptions());\n+    // Remaining time in milliseconds for the server query execution\n+    // Use the max of offline table remaining time and realtime table remaining time for hybrid use case\n+    long remainingTimeMs = 0;\n+    // NOTE: Use query-level timeout if exists, or use table-level timeout if exists, or use instance-level timeout\n+    if (offlineBrokerRequest != null) {\n+      long offlineTimeoutMs;\n+      if (queryTimeoutMs > 0) {\n+        offlineTimeoutMs = queryTimeoutMs;\n+      } else {\n+        Long tableTimeoutMs = _routingManager.getTimeoutMs(offlineTableName);\n+        offlineTimeoutMs = tableTimeoutMs != null ? tableTimeoutMs : _brokerTimeoutMs;\n+      }\n+      long offlineRemainingTimeMs = offlineTimeoutMs - timeSpentMs;\n+      if (offlineRemainingTimeMs <= 0) {\n+        LOGGER.info(\"Offline table timed out (time spent: {}ms, timeout: {}) before scattering the request {}: {}\",\n+            timeSpentMs, offlineTimeoutMs, requestId, query);\n+        _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.REQUEST_TIMEOUT_BEFORE_SCATTERED_EXCEPTIONS, 1);\n+        return new BrokerResponseNative(QueryException.getException(QueryException.BROKER_TIMEOUT_ERROR, String\n+            .format(\"Offline table timed out (time spent: %dms, timeout: %dms) before scattering the request\",\n+                timeSpentMs, offlineTimeoutMs)));\n+      }\n+      offlineBrokerRequest.getQueryOptions()\n+          .put(Broker.Request.QueryOptionKey.TIMEOUT_MS, Long.toString(offlineRemainingTimeMs));\n+      remainingTimeMs = offlineRemainingTimeMs;\n+    }\n+    if (realtimeBrokerRequest != null) {\n+      long realtimeTimeoutMs;\n+      if (queryTimeoutMs > 0) {\n+        realtimeTimeoutMs = queryTimeoutMs;\n+      } else {\n+        Long tableTimeoutMs = _routingManager.getTimeoutMs(realtimeTableName);\n+        realtimeTimeoutMs = tableTimeoutMs != null ? tableTimeoutMs : _brokerTimeoutMs;\n+      }\n+      long realtimeRemainingTimeMs = realtimeTimeoutMs - timeSpentMs;\n+      if (realtimeRemainingTimeMs <= 0) {\n+        LOGGER.info(\"Realtime table timed out (time spent: {}ms, timeout: {}) before scattering the request {}: {}\",\n+            timeSpentMs, realtimeTimeoutMs, requestId, query);\n+        _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.REQUEST_TIMEOUT_BEFORE_SCATTERED_EXCEPTIONS, 1);\n+        return new BrokerResponseNative(QueryException.getException(QueryException.BROKER_TIMEOUT_ERROR, String\n+            .format(\"Realtime table timed out (time spent: %dms, timeout: %dms) before scattering the request\",\n+                timeSpentMs, realtimeTimeoutMs)));\n+      }\n+      realtimeBrokerRequest.getQueryOptions()\n+          .put(Broker.Request.QueryOptionKey.TIMEOUT_MS, Long.toString(realtimeRemainingTimeMs));\n+      remainingTimeMs = Math.max(remainingTimeMs, realtimeRemainingTimeMs);", "originalCommit": "4b5c809788c7e80e6bc5d2c37a7c7d77ea5d5a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NTE3OQ==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396785179", "bodyText": "Should be max. Updated the comments as following:\n    // NOTE: Use the max of offline table remaining time and realtime table remaining time for hybrid use case if the\n    //       timeout for them are not configured to be the same. Server side will have different remaining time set for\n    //       each table type, and broker should wait for both types to return.", "author": "Jackie-Jiang", "createdAt": "2020-03-23T22:06:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczMTEwMg=="}], "type": "inlineReview"}, {"oid": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f", "url": "https://github.com/apache/pinot/commit/40ddc304f25201caa73fbf0f6d1c4caeff5c210f", "message": "Table level timeout implementation\n\nIntroduced 3 levels of query timeout, where the first available one will be used:\n- Query-level: Passed under the query options with key 'timeoutMs'\n- Table-level: Configured under the QueryConfig inside TableConfig\n- Instance-level: Configured in the instance config, or default\n\nThe timeout will be picked up on the broker side, and passed to the server under the query options.\nIf the query already timed out before broker sending the request to the servers, it will early terminate with BROKER_TIMEOUT_ERROR.\nIf the query timed out on the server side, broker should already returned with the partial response.\n\nThis PR also supports refreshing routing properties on table config change automatically.\nBecause the table config refresh is implemented using the Helix USER_DEFINE_MSG, both controller and broker need to be deployed in order to support it.\nNo specific deployment sequence is required (warning will be logged in BrokerUserDefinedMessageHandlerFactory when only one component is deployed).", "committedDate": "2020-03-23T23:04:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyNTI3NQ==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396825275", "bodyText": "Configuring the two tables to have different timeout values seems to be an admin error, given that pinot treats the table configs independently. Under the given constraints, we can either use Math.max or Math.min, I suppose. It is worth adding a comment that this is an arbitrary choice. Perhaps max is better if we dont want queries suddenly timing out or having partial results due to stricter time limits.", "author": "mcvsubbu", "createdAt": "2020-03-23T23:45:41Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -312,8 +313,29 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n     long routingEndTimeNs = System.nanoTime();\n     _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_ROUTING, routingEndTimeNs - routingStartTimeNs);\n \n+    // Set timeout in the requests\n+    long timeSpentMs = TimeUnit.NANOSECONDS.toMillis(routingEndTimeNs - compilationStartTimeNs);\n+    // Remaining time in milliseconds for the server query execution\n+    // NOTE: Use the max of offline table remaining time and realtime table remaining time for hybrid use case if the\n+    //       timeout for them are not configured to be the same. Server side will have different remaining time set for\n+    //       each table type, and broker should wait for both types to return.\n+    long remainingTimeMs = 0;\n+    try {\n+      if (offlineBrokerRequest != null) {\n+        remainingTimeMs = setQueryTimeout(offlineTableName, offlineBrokerRequest.getQueryOptions(), timeSpentMs);\n+      }\n+      if (realtimeBrokerRequest != null) {\n+        remainingTimeMs = Math.max(remainingTimeMs,", "originalCommit": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyNjg0OQ==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396826849", "bodyText": "IMO, it could be very rare but is legit for some use cases to configure offline part to have lower timeout than the realtime part because in general offline data has better performance. This is not arbitrary choice though. To get the full result, broker has to wait for both parts done before merging the result.", "author": "Jackie-Jiang", "createdAt": "2020-03-23T23:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyNTI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgzMDU2Mw==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396830563", "bodyText": "Updated the comments so that it is more clear", "author": "Jackie-Jiang", "createdAt": "2020-03-24T00:03:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyNTI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyNjQxMA==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396826410", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Returns the timeout in milliseconds for the given table, or {@code null} if the timeout is not configured in the\n          \n          \n            \n               * Returns the query timeout in milliseconds for the given table, or {@code null} if the timeout is not configured in the", "author": "mcvsubbu", "createdAt": "2020-03-23T23:49:17Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/RoutingManager.java", "diffHunk": "@@ -450,11 +458,22 @@ public TimeBoundaryInfo getTimeBoundaryInfo(String offlineTableName) {\n     return timeBoundaryManager != null ? timeBoundaryManager.getTimeBoundaryInfo() : null;\n   }\n \n+  /**\n+   * Returns the timeout in milliseconds for the given table, or {@code null} if the timeout is not configured in the", "originalCommit": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyODg3OA==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396828878", "bodyText": "seems like a candidate for intermittent failure, good to add a comment on the circumstances under which this test can fail. I cant think of another way to add the test", "author": "mcvsubbu", "createdAt": "2020-03-23T23:57:27Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/OfflineClusterIntegrationTest.java", "diffHunk": "@@ -185,6 +191,58 @@ public void testInvalidTableConfig() {\n     }\n   }\n \n+  @Test\n+  public void testRefreshTableConfigAndQueryTimeout()\n+      throws Exception {\n+    TableConfig tableConfig = _helixResourceManager.getOfflineTableConfig(getTableName());\n+    assertNotNull(tableConfig);\n+\n+    // Set timeout as 5ms so that query will timeout\n+    tableConfig.setQueryConfig(new QueryConfig(5L));\n+    _helixResourceManager.updateTableConfig(tableConfig);\n+\n+    // Wait for at most 1 minute for broker to receive and process the table config refresh message\n+    TestUtils.waitForCondition(aVoid -> {", "originalCommit": "40ddc304f25201caa73fbf0f6d1c4caeff5c210f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgzMTMzOA==", "url": "https://github.com/apache/pinot/pull/5169#discussion_r396831338", "bodyText": "I removed the test on uncertain properties (such as timeUsedMs), and it should always pass right not.", "author": "Jackie-Jiang", "createdAt": "2020-03-24T00:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyODg3OA=="}], "type": "inlineReview"}, {"oid": "1ef05cd4621e5018de0e670cebbf7beda54f476d", "url": "https://github.com/apache/pinot/commit/1ef05cd4621e5018de0e670cebbf7beda54f476d", "message": "Table level timeout implementation\n\nIntroduced 3 levels of query timeout, where the first available one will be used:\n- Query-level: Passed under the query options with key 'timeoutMs'\n- Table-level: Configured under the QueryConfig inside TableConfig\n- Instance-level: Configured in the instance config, or default\n\nThe timeout will be picked up on the broker side, and passed to the server under the query options.\nIf the query already timed out before broker sending the request to the servers, it will early terminate with BROKER_TIMEOUT_ERROR.\nIf the query timed out on the server side, broker should already returned with the partial response.\n\nThis PR also supports refreshing routing properties on table config change automatically.\nBecause the table config refresh is implemented using the Helix USER_DEFINE_MSG, both controller and broker need to be deployed in order to support it.\nNo specific deployment sequence is required (warning will be logged in BrokerUserDefinedMessageHandlerFactory when only one component is deployed).", "committedDate": "2020-03-24T00:07:53Z", "type": "commit"}, {"oid": "1ef05cd4621e5018de0e670cebbf7beda54f476d", "url": "https://github.com/apache/pinot/commit/1ef05cd4621e5018de0e670cebbf7beda54f476d", "message": "Table level timeout implementation\n\nIntroduced 3 levels of query timeout, where the first available one will be used:\n- Query-level: Passed under the query options with key 'timeoutMs'\n- Table-level: Configured under the QueryConfig inside TableConfig\n- Instance-level: Configured in the instance config, or default\n\nThe timeout will be picked up on the broker side, and passed to the server under the query options.\nIf the query already timed out before broker sending the request to the servers, it will early terminate with BROKER_TIMEOUT_ERROR.\nIf the query timed out on the server side, broker should already returned with the partial response.\n\nThis PR also supports refreshing routing properties on table config change automatically.\nBecause the table config refresh is implemented using the Helix USER_DEFINE_MSG, both controller and broker need to be deployed in order to support it.\nNo specific deployment sequence is required (warning will be logged in BrokerUserDefinedMessageHandlerFactory when only one component is deployed).", "committedDate": "2020-03-24T00:07:53Z", "type": "forcePushed"}]}