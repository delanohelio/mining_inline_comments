{"pr_number": 5722, "pr_title": "Introduce IndexContainer in MutableSegmentImpl to reduce map lookups", "pr_createdAt": "2020-07-21T05:30:50Z", "pr_url": "https://github.com/apache/pinot/pull/5722", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzMTk4NA==", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458231984", "bodyText": "Is the check for aggregateMetrics redundant here?", "author": "mcvsubbu", "createdAt": "2020-07-21T16:31:44Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -432,202 +409,193 @@ public void addExtraColumns(Schema newSchema) {\n     _logger.info(\"Newly added columns: \" + _newlyAddedColumnsFieldMap.toString());\n   }\n \n+  // NOTE: Okay for single-writer\n+  @SuppressWarnings(\"NonAtomicOperationOnVolatileField\")\n   @Override\n   public boolean index(GenericRow row, @Nullable RowMetadata rowMetadata) {\n-    boolean canTakeMore;\n     // Update dictionary first\n-    Map<String, Object> dictIdMap = updateDictionary(row);\n-\n-    int numDocs = _numDocsIndexed;\n+    updateDictionary(row);\n \n     // If metrics aggregation is enabled and if the dimension values were already seen, this will return existing docId,\n     // else this will return a new docId.\n-    int docId = getOrCreateDocId(dictIdMap);\n-\n-    // docId == numDocs implies new docId.\n-    if (docId == numDocs) {\n-      // Add forward and inverted indices for new document.\n-      addForwardIndex(row, docId, dictIdMap);\n-      addInvertedIndex(row, docId, dictIdMap);\n-      if (_nullHandlingEnabled) {\n-        handleNullValues(row, docId);\n-      }\n+    int docId = getOrCreateDocId();\n \n+    boolean canTakeMore;\n+    if (docId == _numDocsIndexed) {\n+      // New document\n+      addNewDocument(row, docId);\n       // Update number of document indexed at last to make the latest record queryable\n       canTakeMore = _numDocsIndexed++ < _capacity;\n     } else {\n-      Preconditions\n-          .checkState(_aggregateMetrics, \"Invalid document-id during indexing: \" + docId + \" expected: \" + numDocs);\n-      // Update metrics for existing document.\n-      canTakeMore = aggregateMetrics(row, docId);\n+      // Aggregate metrics for existing document\n+      assert _aggregateMetrics;\n+      aggregateMetrics(row, docId);\n+      canTakeMore = true;\n     }\n \n+    // Update last indexed time and latest ingestion time\n     _lastIndexedTimeMs = System.currentTimeMillis();\n-\n-    if (rowMetadata != null && rowMetadata.getIngestionTimeMs() != Long.MIN_VALUE) {\n+    if (rowMetadata != null) {\n       _latestIngestionTimeMs = Math.max(_latestIngestionTimeMs, rowMetadata.getIngestionTimeMs());\n     }\n+\n     return canTakeMore;\n   }\n \n-  private Map<String, Object> updateDictionary(GenericRow row) {\n-    Map<String, Object> dictIdMap = new HashMap<>();\n-    for (FieldSpec fieldSpec : _physicalFieldSpecs) {\n-      String column = fieldSpec.getName();\n+  private void updateDictionary(GenericRow row) {\n+    for (Map.Entry<String, IndexContainer> entry : _indexContainerMap.entrySet()) {\n+      String column = entry.getKey();\n+      IndexContainer indexContainer = entry.getValue();\n       Object value = row.getValue(column);\n-\n-      BaseMutableDictionary dictionary = _dictionaryMap.get(column);\n+      BaseMutableDictionary dictionary = indexContainer._dictionary;\n       if (dictionary != null) {\n-        if (fieldSpec.isSingleValueField()) {\n-          dictIdMap.put(column, dictionary.index(value));\n+        if (indexContainer._fieldSpec.isSingleValueField()) {\n+          indexContainer._dictId = dictionary.index(value);\n         } else {\n-          int[] dictIds = dictionary.index((Object[]) value);\n-          dictIdMap.put(column, dictIds);\n-\n-          // No need to update min/max time value as time column cannot be multi-valued\n-          continue;\n+          indexContainer._dictIds = dictionary.index((Object[]) value);\n         }\n+\n+        // Update min/max value from dictionary\n+        indexContainer._minValue = dictionary.getMinVal();\n+        indexContainer._maxValue = dictionary.getMaxVal();\n       }\n     }\n-    return dictIdMap;\n   }\n \n-  private void addForwardIndex(GenericRow row, int docId, Map<String, Object> dictIdMap) {\n-    // Store dictionary Id(s) for columns with dictionary\n-    for (FieldSpec fieldSpec : _physicalFieldSpecs) {\n-      String column = fieldSpec.getName();\n+  private void addNewDocument(GenericRow row, int docId) {\n+    for (Map.Entry<String, IndexContainer> entry : _indexContainerMap.entrySet()) {\n+      String column = entry.getKey();\n+      IndexContainer indexContainer = entry.getValue();\n       Object value = row.getValue(column);\n-      NumValuesInfo numValuesInfo = _numValuesInfoMap.get(column);\n+      FieldSpec fieldSpec = indexContainer._fieldSpec;\n       if (fieldSpec.isSingleValueField()) {\n-        // SV column\n-        MutableForwardIndex mutableForwardIndex = _forwardIndexMap.get(column);\n-        Integer dictId = (Integer) dictIdMap.get(column);\n-        if (dictId != null) {\n-          // SV Column with dictionary\n-          mutableForwardIndex.setDictId(docId, dictId);\n+        // Single-value column\n+\n+        // Update numValues info\n+        indexContainer._numValuesInfo.updateSVEntry();\n+\n+        // Update indexes\n+        MutableForwardIndex forwardIndex = indexContainer._forwardIndex;\n+        int dictId = indexContainer._dictId;\n+        if (dictId >= 0) {\n+          // Dictionary-encoded single-value column\n+\n+          // Update forward index\n+          forwardIndex.setDictId(docId, dictId);\n+\n+          // Update inverted index\n+          RealtimeInvertedIndexReader invertedIndex = indexContainer._invertedIndex;\n+          if (invertedIndex != null) {\n+            invertedIndex.add(dictId, docId);\n+          }\n         } else {\n-          // No-dictionary SV column\n+          // Single-value column with raw index\n+\n+          // Update forward index\n           DataType dataType = fieldSpec.getDataType();\n           switch (dataType) {\n             case INT:\n-              mutableForwardIndex.setInt(docId, (Integer) value);\n+              forwardIndex.setInt(docId, (Integer) value);\n               break;\n             case LONG:\n-              mutableForwardIndex.setLong(docId, (Long) value);\n+              forwardIndex.setLong(docId, (Long) value);\n               break;\n             case FLOAT:\n-              mutableForwardIndex.setFloat(docId, (Float) value);\n+              forwardIndex.setFloat(docId, (Float) value);\n               break;\n             case DOUBLE:\n-              mutableForwardIndex.setDouble(docId, (Double) value);\n+              forwardIndex.setDouble(docId, (Double) value);\n               break;\n             case STRING:\n-              mutableForwardIndex.setString(docId, (String) value);\n+              forwardIndex.setString(docId, (String) value);\n               break;\n             case BYTES:\n-              mutableForwardIndex.setBytes(docId, (byte[]) value);\n+              forwardIndex.setBytes(docId, (byte[]) value);\n               break;\n             default:\n               throw new UnsupportedOperationException(\n                   \"Unsupported data type: \" + dataType + \" for no-dictionary column: \" + column);\n           }\n+\n+          // Update min/max value from raw value\n+          // NOTE: Skip updating min/max value for aggregated metrics because the value will change over time.\n+          if (!_aggregateMetrics || fieldSpec.getFieldType() != FieldSpec.FieldType.METRIC) {", "originalCommit": "00696e33e82c3c8682b36a3ef380cbf488f946a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI2NzQ5NQ==", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458267495", "bodyText": "No, without aggregateMetrics we can store min/max value for metric columns because the value won't change over time", "author": "Jackie-Jiang", "createdAt": "2020-07-21T17:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzMTk4NA=="}], "type": "inlineReview"}, {"oid": "e0359b839b8f04eb63acda113079ba1b22b98212", "url": "https://github.com/apache/pinot/commit/e0359b839b8f04eb63acda113079ba1b22b98212", "message": "Introduce IndexContianer in MutableSegmentImpl to reduce map lookups", "committedDate": "2020-07-21T17:38:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzE2Mw==", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458337163", "bodyText": "should this be IndexKey instead of String?", "author": "kishoreg", "createdAt": "2020-07-21T19:29:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -108,19 +110,8 @@\n   private final int _partitionId;\n   private final boolean _nullHandlingEnabled;\n \n-  // TODO: Keep one map to store all these info\n-  private final Map<String, NumValuesInfo> _numValuesInfoMap = new HashMap<>();\n-  private final Map<String, BaseMutableDictionary> _dictionaryMap = new HashMap<>();\n-  private final Map<String, MutableForwardIndex> _forwardIndexMap = new HashMap<>();\n-  private final Map<String, InvertedIndexReader> _invertedIndexMap = new HashMap<>();\n-  private final Map<String, InvertedIndexReader> _rangeIndexMap = new HashMap<>();\n-  private final Map<String, InvertedIndexReader> _textIndexMap = new HashMap<>();\n-  private final Map<String, BloomFilterReader> _bloomFilterMap = new HashMap<>();\n-  // Only store min/max for non-dictionary fields\n-  private final Map<String, Comparable> _minValueMap = new HashMap<>();\n-  private final Map<String, Comparable> _maxValueMap = new HashMap<>();\n-\n-  private final Map<String, RealtimeNullValueVectorReaderWriter> _nullValueVectorMap = new HashMap<>();\n+  private final Map<String, IndexContainer> _indexContainerMap = new HashMap<>();", "originalCommit": "e0359b839b8f04eb63acda113079ba1b22b98212", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyMDYyMA==", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458420620", "bodyText": "No, it is the column name. IndexContainer contains all the indexes and extra stats for a column.", "author": "Jackie-Jiang", "createdAt": "2020-07-21T22:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNTMwMA==", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458805300", "bodyText": "Use Optional to avoid null check?", "author": "mayankshriv", "createdAt": "2020-07-22T13:48:30Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -1033,13 +960,89 @@ void updateMVEntry(int numValuesInMVEntry) {\n       _numValues += numValuesInMVEntry;\n       _maxNumValuesPerMVEntry = Math.max(_maxNumValuesPerMVEntry, numValuesInMVEntry);\n     }\n+  }\n+\n+  private class IndexContainer implements Closeable {\n+    final FieldSpec _fieldSpec;\n+    final PartitionFunction _partitionFunction;\n+    final int _partitionId;\n+    final NumValuesInfo _numValuesInfo;\n+    final MutableForwardIndex _forwardIndex;\n+    final BaseMutableDictionary _dictionary;\n+    final RealtimeInvertedIndexReader _invertedIndex;\n+    final InvertedIndexReader _rangeIndex;\n+    final RealtimeLuceneTextIndexReader _textIndex;\n+    final BloomFilterReader _bloomFilter;\n+    final MutableNullValueVector _nullValueVector;\n+\n+    volatile Comparable _minValue;\n+    volatile Comparable _maxValue;\n+\n+    // Hold the dictionary id for the latest record\n+    int _dictId = Integer.MIN_VALUE;\n+    int[] _dictIds;\n+\n+    IndexContainer(FieldSpec fieldSpec, PartitionFunction partitionFunction, int partitionId,\n+        NumValuesInfo numValuesInfo, MutableForwardIndex forwardIndex, BaseMutableDictionary dictionary,\n+        RealtimeInvertedIndexReader invertedIndex, InvertedIndexReader rangeIndex,\n+        RealtimeLuceneTextIndexReader textIndex, BloomFilterReader bloomFilter,\n+        MutableNullValueVector nullValueVector) {\n+      _fieldSpec = fieldSpec;\n+      _partitionFunction = partitionFunction;\n+      _partitionId = partitionId;\n+      _numValuesInfo = numValuesInfo;\n+      _forwardIndex = forwardIndex;\n+      _dictionary = dictionary;\n+      _invertedIndex = invertedIndex;\n+      _rangeIndex = rangeIndex;\n+      _textIndex = textIndex;\n+      _bloomFilter = bloomFilter;\n+      _nullValueVector = nullValueVector;\n+    }\n \n-    int getNumValues() {\n-      return _numValues;\n+    DataSource toDataSource() {\n+      return new MutableDataSource(_fieldSpec, _numDocsIndexed, _numValuesInfo._numValues,\n+          _numValuesInfo._maxNumValuesPerMVEntry, _partitionFunction, _partitionId, _minValue, _maxValue, _forwardIndex,\n+          _dictionary, _invertedIndex, _rangeIndex, _textIndex, _bloomFilter, _nullValueVector);\n     }\n \n-    int getMaxNumValuesPerMVEntry() {\n-      return _maxNumValuesPerMVEntry;\n+    @Override\n+    public void close() {\n+      String column = _fieldSpec.getName();\n+      try {\n+        _forwardIndex.close();\n+      } catch (Exception e) {\n+        _logger.error(\"Caught exception while closing forward index for column: {}, continuing with error\", column, e);\n+      }\n+      if (_dictionary != null) {", "originalCommit": "e0359b839b8f04eb63acda113079ba1b22b98212", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3MDk1Ng==", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458970956", "bodyText": "Do you mean try with resource? Not sure how Optional can help here", "author": "Jackie-Jiang", "createdAt": "2020-07-22T17:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNTMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3ODU1OA==", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458978558", "bodyText": "IMO, the explicit null check is more readable than try (BaseMutableDictionary dictionary = _dictionary) {} or if (optionalDictionary.isPresent()) (no way to avoid this if condition)", "author": "Jackie-Jiang", "createdAt": "2020-07-22T17:56:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNTMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1ODExNg==", "url": "https://github.com/apache/pinot/pull/5722#discussion_r459058116", "bodyText": "I meant using optionalDictionary.ifPresent(<doSomething>):\nhttps://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#ifPresent-java.util.function.Consumer-", "author": "mayankshriv", "createdAt": "2020-07-22T20:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNTMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwOTY2NQ==", "url": "https://github.com/apache/pinot/pull/5722#discussion_r459109665", "bodyText": "With that, the code will be like the following:\n      Optional.ofNullable(_dictionary).ifPresent(baseMutableDictionary -> {\n        try {\n          baseMutableDictionary.close();\n        } catch (IOException e) {\n          _logger.error(\"Caught exception while closing dictionary for column: {}, continuing with error\", column, e);\n        }\n      });\n\nI prefer the explicit null check for the following reasons:\n\nIMO, this is not as readable as the explicit null check\nInternally it is doing the same null check\nThere is overhead of using functional programming APIs (we ran into performance issues before), and it will always create unnecessary objects", "author": "Jackie-Jiang", "createdAt": "2020-07-22T22:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNTMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNjcxNg==", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458806716", "bodyText": "Nit: addNewRow?", "author": "mayankshriv", "createdAt": "2020-07-22T13:50:25Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -432,202 +409,193 @@ public void addExtraColumns(Schema newSchema) {\n     _logger.info(\"Newly added columns: \" + _newlyAddedColumnsFieldMap.toString());\n   }\n \n+  // NOTE: Okay for single-writer\n+  @SuppressWarnings(\"NonAtomicOperationOnVolatileField\")\n   @Override\n   public boolean index(GenericRow row, @Nullable RowMetadata rowMetadata) {\n-    boolean canTakeMore;\n     // Update dictionary first\n-    Map<String, Object> dictIdMap = updateDictionary(row);\n-\n-    int numDocs = _numDocsIndexed;\n+    updateDictionary(row);\n \n     // If metrics aggregation is enabled and if the dimension values were already seen, this will return existing docId,\n     // else this will return a new docId.\n-    int docId = getOrCreateDocId(dictIdMap);\n-\n-    // docId == numDocs implies new docId.\n-    if (docId == numDocs) {\n-      // Add forward and inverted indices for new document.\n-      addForwardIndex(row, docId, dictIdMap);\n-      addInvertedIndex(row, docId, dictIdMap);\n-      if (_nullHandlingEnabled) {\n-        handleNullValues(row, docId);\n-      }\n+    int docId = getOrCreateDocId();\n \n+    boolean canTakeMore;\n+    if (docId == _numDocsIndexed) {\n+      // New document\n+      addNewDocument(row, docId);\n       // Update number of document indexed at last to make the latest record queryable\n       canTakeMore = _numDocsIndexed++ < _capacity;\n     } else {\n-      Preconditions\n-          .checkState(_aggregateMetrics, \"Invalid document-id during indexing: \" + docId + \" expected: \" + numDocs);\n-      // Update metrics for existing document.\n-      canTakeMore = aggregateMetrics(row, docId);\n+      // Aggregate metrics for existing document\n+      assert _aggregateMetrics;\n+      aggregateMetrics(row, docId);\n+      canTakeMore = true;\n     }\n \n+    // Update last indexed time and latest ingestion time\n     _lastIndexedTimeMs = System.currentTimeMillis();\n-\n-    if (rowMetadata != null && rowMetadata.getIngestionTimeMs() != Long.MIN_VALUE) {\n+    if (rowMetadata != null) {\n       _latestIngestionTimeMs = Math.max(_latestIngestionTimeMs, rowMetadata.getIngestionTimeMs());\n     }\n+\n     return canTakeMore;\n   }\n \n-  private Map<String, Object> updateDictionary(GenericRow row) {\n-    Map<String, Object> dictIdMap = new HashMap<>();\n-    for (FieldSpec fieldSpec : _physicalFieldSpecs) {\n-      String column = fieldSpec.getName();\n+  private void updateDictionary(GenericRow row) {\n+    for (Map.Entry<String, IndexContainer> entry : _indexContainerMap.entrySet()) {\n+      String column = entry.getKey();\n+      IndexContainer indexContainer = entry.getValue();\n       Object value = row.getValue(column);\n-\n-      BaseMutableDictionary dictionary = _dictionaryMap.get(column);\n+      BaseMutableDictionary dictionary = indexContainer._dictionary;\n       if (dictionary != null) {\n-        if (fieldSpec.isSingleValueField()) {\n-          dictIdMap.put(column, dictionary.index(value));\n+        if (indexContainer._fieldSpec.isSingleValueField()) {\n+          indexContainer._dictId = dictionary.index(value);\n         } else {\n-          int[] dictIds = dictionary.index((Object[]) value);\n-          dictIdMap.put(column, dictIds);\n-\n-          // No need to update min/max time value as time column cannot be multi-valued\n-          continue;\n+          indexContainer._dictIds = dictionary.index((Object[]) value);\n         }\n+\n+        // Update min/max value from dictionary\n+        indexContainer._minValue = dictionary.getMinVal();\n+        indexContainer._maxValue = dictionary.getMaxVal();\n       }\n     }\n-    return dictIdMap;\n   }\n \n-  private void addForwardIndex(GenericRow row, int docId, Map<String, Object> dictIdMap) {\n-    // Store dictionary Id(s) for columns with dictionary\n-    for (FieldSpec fieldSpec : _physicalFieldSpecs) {\n-      String column = fieldSpec.getName();\n+  private void addNewDocument(GenericRow row, int docId) {", "originalCommit": "e0359b839b8f04eb63acda113079ba1b22b98212", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3MzgwNQ==", "url": "https://github.com/apache/pinot/pull/5722#discussion_r458973805", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-07-22T17:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNjcxNg=="}], "type": "inlineReview"}, {"oid": "413f6e55df9e10b83700ac0b366d1466dc6cc980", "url": "https://github.com/apache/pinot/commit/413f6e55df9e10b83700ac0b366d1466dc6cc980", "message": "Introduce IndexContianer in MutableSegmentImpl to reduce map lookups", "committedDate": "2020-07-22T17:52:29Z", "type": "commit"}, {"oid": "413f6e55df9e10b83700ac0b366d1466dc6cc980", "url": "https://github.com/apache/pinot/commit/413f6e55df9e10b83700ac0b366d1466dc6cc980", "message": "Introduce IndexContianer in MutableSegmentImpl to reduce map lookups", "committedDate": "2020-07-22T17:52:29Z", "type": "forcePushed"}]}