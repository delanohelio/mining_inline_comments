{"pr_number": 6322, "pr_title": "API to get status of consumption of a table", "pr_createdAt": "2020-12-04T23:33:02Z", "pr_url": "https://github.com/apache/pinot/pull/6322", "timeline": [{"oid": "d5b63d428be23e110e76ff68f8158dd03646a326", "url": "https://github.com/apache/pinot/commit/d5b63d428be23e110e76ff68f8158dd03646a326", "message": "API to get status of consuming segments of a table across all servers", "committedDate": "2020-12-04T23:05:56Z", "type": "commit"}, {"oid": "e70617e163bbb1eb2639b9a097abe72006e2666d", "url": "https://github.com/apache/pinot/commit/e70617e163bbb1eb2639b9a097abe72006e2666d", "message": "Treemap for getting order", "committedDate": "2020-12-04T23:32:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ5MjQ1MQ==", "url": "https://github.com/apache/pinot/pull/6322#discussion_r536492451", "bodyText": "consumingSegments must be a set or it will containing duplicates", "author": "kishoreg", "createdAt": "2020-12-05T03:12:44Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1895,6 +1895,24 @@ public void toggleQueryQuotaStateForBroker(String brokerInstanceName, String sta\n     return serverToSegmentsMap;\n   }\n \n+  /**\n+   * Returns a list of CONSUMING segments for the given realtime table.\n+   */\n+  public List<String> getConsumingSegments(String tableNameWithType) {\n+    IdealState idealState = _helixAdmin.getResourceIdealState(_helixClusterName, tableNameWithType);\n+    if (idealState == null) {\n+      throw new IllegalStateException(\"Ideal state does not exist for table: \" + tableNameWithType);\n+    }\n+    List<String> consumingSegments = new ArrayList<>();\n+    for (String segment : idealState.getPartitionSet()) {\n+      Map<String, String> instanceStateMap = idealState.getInstanceStateMap(segment);\n+      if (instanceStateMap.containsValue(SegmentStateModel.CONSUMING)) {\n+        consumingSegments.add(segment);", "originalCommit": "e70617e163bbb1eb2639b9a097abe72006e2666d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ5MjQ5OA==", "url": "https://github.com/apache/pinot/pull/6322#discussion_r536492498", "bodyText": "might also need null check?", "author": "kishoreg", "createdAt": "2020-12-05T03:13:08Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1895,6 +1895,24 @@ public void toggleQueryQuotaStateForBroker(String brokerInstanceName, String sta\n     return serverToSegmentsMap;\n   }\n \n+  /**\n+   * Returns a list of CONSUMING segments for the given realtime table.\n+   */\n+  public List<String> getConsumingSegments(String tableNameWithType) {\n+    IdealState idealState = _helixAdmin.getResourceIdealState(_helixClusterName, tableNameWithType);\n+    if (idealState == null) {\n+      throw new IllegalStateException(\"Ideal state does not exist for table: \" + tableNameWithType);\n+    }\n+    List<String> consumingSegments = new ArrayList<>();\n+    for (String segment : idealState.getPartitionSet()) {\n+      Map<String, String> instanceStateMap = idealState.getInstanceStateMap(segment);\n+      if (instanceStateMap.containsValue(SegmentStateModel.CONSUMING)) {", "originalCommit": "e70617e163bbb1eb2639b9a097abe72006e2666d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5MTgwNg==", "url": "https://github.com/apache/pinot/pull/6322#discussion_r536891806", "bodyText": "shouldn't need null check (or even Set) because we're iterating over the segments fetched from the ideal state. Changed it to Set anyway.", "author": "npawar", "createdAt": "2020-12-05T20:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ5MjQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ5Mjc3MQ==", "url": "https://github.com/apache/pinot/pull/6322#discussion_r536492771", "bodyText": "_partitionToOffsetMap ?", "author": "kishoreg", "createdAt": "2020-12-05T03:15:03Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ConsumingSegmentInfoReader.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.exception.InvalidConfigException;\n+import org.apache.pinot.common.restlet.resources.SegmentConsumerInfo;\n+import org.apache.pinot.controller.helix.core.PinotHelixResourceManager;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch consuming segments info\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ConsumingSegmentInfoReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ConsumingSegmentInfoReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+  private final PinotHelixResourceManager _pinotHelixResourceManager;\n+\n+  public ConsumingSegmentInfoReader(Executor executor, HttpConnectionManager connectionManager,\n+      PinotHelixResourceManager helixResourceManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+    _pinotHelixResourceManager = helixResourceManager;\n+  }\n+\n+  /**\n+   * This method retrieves the consuming segments info for a given realtime table.\n+   * @return a map of segmentName to the information about its consumer\n+   */\n+  public ConsumingSegmentsInfoMap getConsumingSegmentsInfo(String tableNameWithType, int timeoutMs)\n+      throws InvalidConfigException {\n+    final Map<String, List<String>> serverToSegments =\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    BiMap<String, String> serverToEndpoints =\n+        _pinotHelixResourceManager.getDataInstanceAdminEndpoints(serverToSegments.keySet());\n+\n+    // Gets info for segments with LLRealtimeSegmentDataManager found in the table data manager\n+    Map<String, List<SegmentConsumerInfo>> serverToSegmentConsumerInfoMap =\n+        getConsumingSegmentsInfoFromServers(tableNameWithType, serverToEndpoints, timeoutMs);\n+    TreeMap<String, List<ConsumingSegmentInfo>> consumingSegmentInfoMap = new TreeMap<>();\n+    for (Map.Entry<String, List<SegmentConsumerInfo>> entry : serverToSegmentConsumerInfoMap.entrySet()) {\n+      String serverName = entry.getKey();\n+      for (SegmentConsumerInfo info : entry.getValue()) {\n+        consumingSegmentInfoMap.computeIfAbsent(info.getSegmentName(), k -> new ArrayList<>())\n+            .add(new ConsumingSegmentInfo(serverName, info.getConsumerState(), info.getPartitionToOffset()));\n+      }\n+    }\n+    // Segments which are in CONSUMING state but found no consumer on the server\n+    List<String> consumingSegments = _pinotHelixResourceManager.getConsumingSegments(tableNameWithType);\n+    consumingSegments.forEach(c -> consumingSegmentInfoMap.putIfAbsent(c, Collections.emptyList()));\n+    return new ConsumingSegmentsInfoMap(consumingSegmentInfoMap);\n+  }\n+\n+  /**\n+   * This method makes a MultiGet call to all servers to get the consuming segments info.\n+   * @return servers queried and a list of consumer status information for consuming segments on that server\n+   */\n+  private Map<String, List<SegmentConsumerInfo>> getConsumingSegmentsInfoFromServers(String tableNameWithType,\n+      BiMap<String, String> serverToEndpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading consuming segment info from servers: {} for table: {}\", serverToEndpoints.keySet(),\n+        tableNameWithType);\n+\n+    List<String> serverUrls = new ArrayList<>(serverToEndpoints.size());\n+    BiMap<String, String> endpointsToServers = serverToEndpoints.inverse();\n+    for (String endpoint : endpointsToServers.keySet()) {\n+      String consumingSegmentInfoURI = generateServerURL(tableNameWithType, endpoint);\n+      serverUrls.add(consumingSegmentInfoURI);\n+    }\n+\n+    CompletionServiceHelper completionServiceHelper =\n+        new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverUrls, tableNameWithType, timeoutMs);\n+    Map<String, List<SegmentConsumerInfo>> serverToConsumingSegmentInfoList = new HashMap<>();\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        List<SegmentConsumerInfo> segmentConsumerInfos =\n+            JsonUtils.stringToObject(streamResponse.getValue(), new TypeReference<List<SegmentConsumerInfo>>() {\n+            });\n+        serverToConsumingSegmentInfoList.put(streamResponse.getKey(), segmentConsumerInfos);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server {} response due to an error: \", streamResponse.getKey(), e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} / {} segment size info responses from servers.\", failedParses, serverUrls.size());\n+    }\n+    return serverToConsumingSegmentInfoList;\n+  }\n+\n+  private String generateServerURL(String tableNameWithType, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/consumingSegmentsInfo\", endpoint, tableNameWithType);\n+  }\n+\n+  /**\n+   * Map containing all consuming segments and their status information\n+   */\n+  @JsonIgnoreProperties(ignoreUnknown = true)\n+  static public class ConsumingSegmentsInfoMap {\n+    public TreeMap<String, List<ConsumingSegmentInfo>> _segmentToConsumingInfoMap;\n+\n+    public ConsumingSegmentsInfoMap(\n+        @JsonProperty(\"segmentToConsumingInfoMap\") TreeMap<String, List<ConsumingSegmentInfo>> segmentToConsumingInfoMap) {\n+      this._segmentToConsumingInfoMap = segmentToConsumingInfoMap;\n+    }\n+  }\n+\n+  /**\n+   * Contains all the information about a consuming segment\n+   */\n+  @JsonIgnoreProperties(ignoreUnknown = true)\n+  static public class ConsumingSegmentInfo {\n+    public String _serverName;\n+    public String _consumerState;\n+    public Map<String, String> _partitionToOffset;\n+\n+    public ConsumingSegmentInfo(@JsonProperty(\"serverName\") String serverName,\n+        @JsonProperty(\"consumerState\") String consumerState,\n+        @JsonProperty(\"partitionToOffset\") Map<String, String> partitionToOffset) {\n+      _serverName = serverName;\n+      _consumerState = consumerState;\n+      _partitionToOffset = partitionToOffset;", "originalCommit": "e70617e163bbb1eb2639b9a097abe72006e2666d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ5MjkyNA==", "url": "https://github.com/apache/pinot/pull/6322#discussion_r536492924", "bodyText": "can we add a lastConsumedTimestamp?", "author": "kishoreg", "createdAt": "2020-12-05T03:16:04Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ConsumingSegmentInfoReader.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.exception.InvalidConfigException;\n+import org.apache.pinot.common.restlet.resources.SegmentConsumerInfo;\n+import org.apache.pinot.controller.helix.core.PinotHelixResourceManager;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch consuming segments info\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ConsumingSegmentInfoReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ConsumingSegmentInfoReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+  private final PinotHelixResourceManager _pinotHelixResourceManager;\n+\n+  public ConsumingSegmentInfoReader(Executor executor, HttpConnectionManager connectionManager,\n+      PinotHelixResourceManager helixResourceManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+    _pinotHelixResourceManager = helixResourceManager;\n+  }\n+\n+  /**\n+   * This method retrieves the consuming segments info for a given realtime table.\n+   * @return a map of segmentName to the information about its consumer\n+   */\n+  public ConsumingSegmentsInfoMap getConsumingSegmentsInfo(String tableNameWithType, int timeoutMs)\n+      throws InvalidConfigException {\n+    final Map<String, List<String>> serverToSegments =\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    BiMap<String, String> serverToEndpoints =\n+        _pinotHelixResourceManager.getDataInstanceAdminEndpoints(serverToSegments.keySet());\n+\n+    // Gets info for segments with LLRealtimeSegmentDataManager found in the table data manager\n+    Map<String, List<SegmentConsumerInfo>> serverToSegmentConsumerInfoMap =\n+        getConsumingSegmentsInfoFromServers(tableNameWithType, serverToEndpoints, timeoutMs);\n+    TreeMap<String, List<ConsumingSegmentInfo>> consumingSegmentInfoMap = new TreeMap<>();\n+    for (Map.Entry<String, List<SegmentConsumerInfo>> entry : serverToSegmentConsumerInfoMap.entrySet()) {\n+      String serverName = entry.getKey();\n+      for (SegmentConsumerInfo info : entry.getValue()) {\n+        consumingSegmentInfoMap.computeIfAbsent(info.getSegmentName(), k -> new ArrayList<>())\n+            .add(new ConsumingSegmentInfo(serverName, info.getConsumerState(), info.getPartitionToOffset()));\n+      }\n+    }\n+    // Segments which are in CONSUMING state but found no consumer on the server\n+    List<String> consumingSegments = _pinotHelixResourceManager.getConsumingSegments(tableNameWithType);\n+    consumingSegments.forEach(c -> consumingSegmentInfoMap.putIfAbsent(c, Collections.emptyList()));\n+    return new ConsumingSegmentsInfoMap(consumingSegmentInfoMap);\n+  }\n+\n+  /**\n+   * This method makes a MultiGet call to all servers to get the consuming segments info.\n+   * @return servers queried and a list of consumer status information for consuming segments on that server\n+   */\n+  private Map<String, List<SegmentConsumerInfo>> getConsumingSegmentsInfoFromServers(String tableNameWithType,\n+      BiMap<String, String> serverToEndpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading consuming segment info from servers: {} for table: {}\", serverToEndpoints.keySet(),\n+        tableNameWithType);\n+\n+    List<String> serverUrls = new ArrayList<>(serverToEndpoints.size());\n+    BiMap<String, String> endpointsToServers = serverToEndpoints.inverse();\n+    for (String endpoint : endpointsToServers.keySet()) {\n+      String consumingSegmentInfoURI = generateServerURL(tableNameWithType, endpoint);\n+      serverUrls.add(consumingSegmentInfoURI);\n+    }\n+\n+    CompletionServiceHelper completionServiceHelper =\n+        new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverUrls, tableNameWithType, timeoutMs);\n+    Map<String, List<SegmentConsumerInfo>> serverToConsumingSegmentInfoList = new HashMap<>();\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        List<SegmentConsumerInfo> segmentConsumerInfos =\n+            JsonUtils.stringToObject(streamResponse.getValue(), new TypeReference<List<SegmentConsumerInfo>>() {\n+            });\n+        serverToConsumingSegmentInfoList.put(streamResponse.getKey(), segmentConsumerInfos);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server {} response due to an error: \", streamResponse.getKey(), e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} / {} segment size info responses from servers.\", failedParses, serverUrls.size());\n+    }\n+    return serverToConsumingSegmentInfoList;\n+  }\n+\n+  private String generateServerURL(String tableNameWithType, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/consumingSegmentsInfo\", endpoint, tableNameWithType);\n+  }\n+\n+  /**\n+   * Map containing all consuming segments and their status information\n+   */\n+  @JsonIgnoreProperties(ignoreUnknown = true)\n+  static public class ConsumingSegmentsInfoMap {\n+    public TreeMap<String, List<ConsumingSegmentInfo>> _segmentToConsumingInfoMap;\n+\n+    public ConsumingSegmentsInfoMap(\n+        @JsonProperty(\"segmentToConsumingInfoMap\") TreeMap<String, List<ConsumingSegmentInfo>> segmentToConsumingInfoMap) {\n+      this._segmentToConsumingInfoMap = segmentToConsumingInfoMap;\n+    }\n+  }\n+\n+  /**\n+   * Contains all the information about a consuming segment\n+   */\n+  @JsonIgnoreProperties(ignoreUnknown = true)", "originalCommit": "e70617e163bbb1eb2639b9a097abe72006e2666d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5MjQ1NA==", "url": "https://github.com/apache/pinot/pull/6322#discussion_r536892454", "bodyText": "yes should be doable. Let me add that.", "author": "npawar", "createdAt": "2020-12-05T21:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ5MjkyNA=="}], "type": "inlineReview"}, {"oid": "37ed2df2b29d89611ae5eef9e7efc4dd72e73392", "url": "https://github.com/apache/pinot/commit/37ed2df2b29d89611ae5eef9e7efc4dd72e73392", "message": "Test and review comments", "committedDate": "2020-12-05T20:58:08Z", "type": "commit"}, {"oid": "2f6ab7849ff485dff418fc9906184b6eff8301aa", "url": "https://github.com/apache/pinot/commit/2f6ab7849ff485dff418fc9906184b6eff8301aa", "message": "Last consumed timestamp", "committedDate": "2020-12-07T00:20:54Z", "type": "commit"}]}