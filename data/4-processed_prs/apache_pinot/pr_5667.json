{"pr_number": 5667, "pr_title": "Support text index on dictionary encoded columns", "pr_createdAt": "2020-07-08T07:56:38Z", "pr_url": "https://github.com/apache/pinot/pull/5667", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxMTUzNw==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451711537", "bodyText": "Will this cause multiple text document map to the same pinot document? How do you maintain the map? We need to figure out the semantic of text index on MV columns", "author": "Jackie-Jiang", "createdAt": "2020-07-08T17:30:32Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneTextIndexCreator.java", "diffHunk": "@@ -115,14 +115,31 @@ public IndexWriter getIndexWriter() {\n \n   @Override\n   public void addDoc(Object document, int docIdCounter) {\n-    Document docToIndex = new Document();\n-    docToIndex.add(new TextField(_textColumn, document.toString(), Field.Store.NO));\n-    docToIndex.add(new StoredField(LUCENE_INDEX_DOC_ID_COLUMN_NAME, docIdCounter));\n-    try {\n-      _indexWriter.addDocument(docToIndex);\n-    } catch (Exception e) {\n-      LOGGER.error(\"Failure while adding a new document to index for column {}, exception {}\", _textColumn, e.getMessage());\n-      throw new RuntimeException(e);\n+    if (!(document instanceof Object[])) {\n+      // text index on SV column\n+      Document docToIndex = new Document();\n+      docToIndex.add(new TextField(_textColumn, document.toString(), Field.Store.NO));\n+      docToIndex.add(new StoredField(LUCENE_INDEX_DOC_ID_COLUMN_NAME, docIdCounter));\n+      try {\n+        _indexWriter.addDocument(docToIndex);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Failure while adding a new document to index for column {}, exception {}\", _textColumn, e.getMessage());\n+        throw new RuntimeException(e);\n+      }\n+    } else {\n+      // text index on MV column\n+      Object[] values = (Object[])document;\n+      for (Object value : values) {\n+        Document docToIndex = new Document();", "originalCommit": "9df8a5a7d7c6554ab7d845897708e66ec108e9f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4NDM5NA==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451884394", "bodyText": "In order to fix this issue #5666 sooner, I am only relaxing the constraint of text index on raw columns in this PR. The constraint of text index on SV columns is still there and will address in a follow-up. Need to do some digging into Lucene as well to see how arrays can be stored in a single document etc.", "author": "siddharthteotia", "createdAt": "2020-07-08T23:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxMTUzNw=="}], "type": "inlineReview"}, {"oid": "8e1e9af32c5f5c32afea20000048690471737c90", "url": "https://github.com/apache/pinot/commit/8e1e9af32c5f5c32afea20000048690471737c90", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-08T23:40:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNDQxMg==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451904412", "bodyText": "Move this into the branch of single value column", "author": "Jackie-Jiang", "createdAt": "2020-07-09T00:57:48Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -379,6 +370,13 @@ public void indexRow(GenericRow row) {\n           _nullValueVectorCreatorMap.get(columnName).setNull(docIdCounter);\n         }\n       }\n+\n+      // text-search enabled column", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNTY2Mw==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455315663", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-07-15T20:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNDQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNzM0NQ==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451907345", "bodyText": "Also check that column is STRING type?", "author": "Jackie-Jiang", "createdAt": "2020-07-09T01:09:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -199,16 +200,17 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n         _forwardIndexCreatorMap.put(columnName,\n             getRawIndexCreatorForColumn(_indexDir, compressionType, columnName, fieldSpec.getDataType(), totalDocs,\n                 indexCreationInfo.getLengthOfLongestEntry(), deriveNumDocsPerChunk, writerVersion));\n+      }\n \n+      if (_textIndexColumns.contains(columnName)) {\n         // Initialize text index creator\n-        if (_textIndexColumns.contains(columnName)) {\n-          _invertedIndexCreatorMap\n-              .put(columnName, new LuceneTextIndexCreator(columnName, _indexDir, true /* commitOnClose */));\n-        }\n+        Preconditions.checkState(fieldSpec.isSingleValueField(),", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNTY4MA==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455315680", "bodyText": "Yeah, missed that earlier", "author": "siddharthteotia", "createdAt": "2020-07-15T20:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNzM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwOTcyOQ==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451909729", "bodyText": "I think you can just remove this method and always use the default one. We should always create dictionary-encoded index for default column because it is much more efficient.", "author": "Jackie-Jiang", "createdAt": "2020-07-09T01:18:42Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -325,77 +323,92 @@ protected void removeColumnV1Indices(String column)\n   }\n \n   /**\n-   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * Right now the text index is supported on RAW and dictionary encoded\n    * single-value STRING columns. Eventually we will relax the constraints\n    * step by step.\n    * For example, later on user should be able to create text index on\n-   * a dictionary encoded STRING column that also has native Pinot's inverted\n-   * index. We can also support it on BYTE columns later.\n+   * a MV column\n    * @param column column name\n    * @param indexLoadingConfig index loading config\n    * @param fieldSpec field spec\n    */\n   private void checkUnsupportedOperationsForTextIndex(String column, IndexLoadingConfig indexLoadingConfig,\n       FieldSpec fieldSpec) {\n-    if (!indexLoadingConfig.getNoDictionaryColumns().contains(column)) {\n-      throw new UnsupportedOperationException(\n-          \"Text index is currently not supported on dictionary encoded column: \" + column);\n-    }\n-\n-    Set<String> sortedColumns = new HashSet<>(indexLoadingConfig.getSortedColumns());\n-    if (sortedColumns.contains(column)) {\n-      // since Pinot's current implementation doesn't support raw sorted columns,\n-      // we need to check for this too\n-      throw new UnsupportedOperationException(\"Text index is currently not supported on sorted column: \" + column);\n-    }\n-\n     if (!fieldSpec.isSingleValueField()) {\n       throw new UnsupportedOperationException(\"Text index is currently not supported on multi-value column: \" + column);\n     }\n-\n     if (fieldSpec.getDataType() != DataType.STRING) {\n       throw new UnsupportedOperationException(\"Text index is currently only supported on STRING column:\" + column);\n     }\n   }\n \n   void createV1ForwardIndexForTextIndex(String column, IndexLoadingConfig indexLoadingConfig)", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyNjQxNg==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455326416", "bodyText": "It seems to me that existing function createColumnV1Indices() has a bug which I want to investigate further and fix before I reuse that method for text index. Meanwhile, this PR is complete and I can refactor this portion next.\nConsider that case a new column gets added with inverted index. Two things happen:\n(1) First, default column handler creates dictionary and forward index. Note that it doesn't create bit encoded forward index. It creates sorted forward index.\n(2) Later during segment load, InvertedIndexHandler reads the forward index to create inverted index. This code when trying to create inverted index first gets a forward index reader. It gets the forward index buffer and creates the bit encoded forward index reader. This seems wrong to me since for newly added column, the forward index buffer had sorted index format and wasn't bit encoded.\nI will look into this in detail and as part of that cleanup the existing code first before reusing it for text.", "author": "siddharthteotia", "createdAt": "2020-07-15T20:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwOTcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzNTczNQ==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455335735", "bodyText": "Never mind. This particular code handles the problem I was talking about\n// Only create inverted index on dictionary-encoded unsorted columns for (String column : indexLoadingConfig.getInvertedIndexColumns()) { ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(column); if (columnMetadata != null && !columnMetadata.isSorted() && columnMetadata.hasDictionary()) { _invertedIndexColumns.add(columnMetadata); } }", "author": "siddharthteotia", "createdAt": "2020-07-15T20:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwOTcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM2MDk0MA==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455360940", "bodyText": "So why do we still need to keep this method? We should decouple the default column logic from the text index logic. For default column, always use dictionary-encoded + sorted index.", "author": "Jackie-Jiang", "createdAt": "2020-07-15T21:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwOTcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4MzY3NQ==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455983675", "bodyText": "Cleaned up the code to reuse existing", "author": "siddharthteotia", "createdAt": "2020-07-16T18:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwOTcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxMDIzNg==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451910236", "bodyText": "Since text column supports both raw & dictionary-encoded index, remove the branch for text column", "author": "Jackie-Jiang", "createdAt": "2020-07-09T01:20:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java", "diffHunk": "@@ -67,10 +67,19 @@ protected void updateDefaultColumn(String column, DefaultColumnAction action, In\n     Set<String> textIndexColumns = indexLoadingConfig.getTextIndexColumns();", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4MzU2Nw==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455983567", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-07-16T18:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxMDIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMTM4NA==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r453821384", "bodyText": "Are there any more constraints to relax? If not, we can modify this comment?", "author": "mcvsubbu", "createdAt": "2020-07-13T17:44:31Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -325,77 +323,92 @@ protected void removeColumnV1Indices(String column)\n   }\n \n   /**\n-   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * Right now the text index is supported on RAW and dictionary encoded", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNTcwMg==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455315702", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-07-15T20:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMTM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMzAyNw==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r453823027", "bodyText": "same here. capture the constraints correctly in comments", "author": "mcvsubbu", "createdAt": "2020-07-13T17:47:13Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -111,35 +117,22 @@ public void createTextIndexesOnSegmentLoad()\n   }\n \n   /**\n-   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * Right now the text index is supported on RAW and dictionary encoded", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNTcyMg==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455315722", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-07-15T20:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMzAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyNDk1OQ==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r453824959", "bodyText": "Should it be ColumnIndexType.DICTIONARY?", "author": "mcvsubbu", "createdAt": "2020-07-13T17:50:23Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -151,30 +144,68 @@ private void createTextIndexForColumn(ColumnMetadata columnMetadata)\n       return;\n     }\n     int numDocs = columnMetadata.getTotalDocs();\n-    LOGGER.info(\"Creating new text index for column: {} in segment: {}\", column, _segmentName);\n+    boolean hasDictionary = columnMetadata.hasDictionary();\n+    LOGGER.info(\"Creating new text index for column: {} in segment: {}, hasDictionary: {}\", column, _segmentName, hasDictionary);\n     File segmentDirectory = SegmentDirectoryPaths.segmentDirectoryFor(_indexDir, _segmentVersion);\n     // The handlers are always invoked by the preprocessor. Before this ImmutableSegmentLoader would have already\n     // up-converted the segment from v1/v2 -> v3 (if needed). So based on the segmentVersion, whatever segment\n     // segmentDirectory is indicated to us by SegmentDirectoryPaths, we create lucene index there. There is no\n     // further need to move around the lucene index directory since it is created with correct directory structure\n     // based on segmentVersion.\n-    try (LuceneTextIndexCreator textIndexCreator = new LuceneTextIndexCreator(column, segmentDirectory, true);\n-        VarByteChunkSVForwardIndexReader forwardIndexReader = getForwardIndexReader(columnMetadata);\n-        ChunkReaderContext readerContext = forwardIndexReader.createContext()) {\n-      for (int docId = 0; docId < numDocs; docId++) {\n-        textIndexCreator.addDoc(forwardIndexReader.getString(docId, readerContext), docId);\n+    try (ForwardIndexReader forwardIndexReader = getForwardIndexReader(columnMetadata);\n+        ForwardIndexReaderContext readerContext = forwardIndexReader.createContext();\n+        LuceneTextIndexCreator textIndexCreator = new LuceneTextIndexCreator(column, segmentDirectory, true)) {\n+      if (!hasDictionary) {\n+        // text index on raw column, just read the raw forward index\n+        VarByteChunkSVForwardIndexReader rawIndexReader = (VarByteChunkSVForwardIndexReader)forwardIndexReader;\n+        ChunkReaderContext chunkReaderContext = (ChunkReaderContext)readerContext;\n+        for (int docId = 0; docId < numDocs; docId++) {\n+          textIndexCreator.addDoc(rawIndexReader.getString(docId, chunkReaderContext), docId);\n+        }\n+      } else {\n+        // text index on dictionary encoded SV column\n+        // read forward index to get dictId\n+        // read the raw value from dictionary using dictId\n+        try (BaseImmutableDictionary dictionary = getDictionaryReader(columnMetadata)) {\n+          if (columnMetadata.isSingleValue()) {\n+            for (int docId = 0; docId < numDocs; docId++) {\n+              int dictId = forwardIndexReader.getDictId(docId, readerContext);\n+              String value = dictionary.getStringValue(dictId);\n+              textIndexCreator.addDoc(value, docId);\n+            }\n+          }\n+        }\n       }\n       textIndexCreator.seal();\n     }\n+\n     LOGGER.info(\"Created text index for column: {} in segment: {}\", column, _segmentName);\n     PropertiesConfiguration properties = SegmentMetadataImpl.getPropertiesConfiguration(_indexDir);\n     properties.setProperty(getKeyFor(column, TEXT_INDEX_TYPE), TextIndexType.LUCENE.name());\n     properties.save();\n   }\n \n-  private VarByteChunkSVForwardIndexReader getForwardIndexReader(ColumnMetadata columnMetadata)\n+  private ForwardIndexReader<?> getForwardIndexReader(ColumnMetadata columnMetadata)\n+      throws IOException {\n+    if (!columnMetadata.hasDictionary()) {\n+      // raw index\n+      PinotDataBuffer buffer = _segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.FORWARD_INDEX);\n+      return new VarByteChunkSVForwardIndexReader(buffer, DataType.STRING);\n+    } else {\n+      PinotDataBuffer buffer = _segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.FORWARD_INDEX);", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNTc0NA==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455315744", "bodyText": "No", "author": "siddharthteotia", "createdAt": "2020-07-15T20:16:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyNDk1OQ=="}], "type": "inlineReview"}, {"oid": "ea2c70f84f4c0aafe95cae560a73cdfbb1c52922", "url": "https://github.com/apache/pinot/commit/ea2c70f84f4c0aafe95cae560a73cdfbb1c52922", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-15T20:15:02Z", "type": "forcePushed"}, {"oid": "216b6cf99d0119e1514c396389d62a3deb8f348b", "url": "https://github.com/apache/pinot/commit/216b6cf99d0119e1514c396389d62a3deb8f348b", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-15T20:57:36Z", "type": "forcePushed"}, {"oid": "cdd757223f33faac42815feaaa3bed4814ab118b", "url": "https://github.com/apache/pinot/commit/cdd757223f33faac42815feaaa3bed4814ab118b", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-16T17:20:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwMTU0MQ==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r456001541", "bodyText": "Let's remove this check as it will be checked in TextIndexHandler. Try not to couple different modules together.", "author": "Jackie-Jiang", "createdAt": "2020-07-16T18:52:18Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -321,88 +321,33 @@ protected void removeColumnV1Indices(String column)\n   }\n \n   /**\n-   * Right now the text index is supported on RAW (non-dictionary encoded)\n-   * single-value STRING columns. Eventually we will relax the constraints\n-   * step by step.\n-   * For example, later on user should be able to create text index on\n-   * a dictionary encoded STRING column that also has native Pinot's inverted\n-   * index. We can also support it on BYTE columns later.\n+   * Right now the text index is supported on RAW and dictionary encoded\n+   * single-value STRING columns. Later we can add support for text index\n+   * on multi-value columns and BYTE type columns\n    * @param column column name\n-   * @param indexLoadingConfig index loading config\n    * @param fieldSpec field spec\n    */\n-  private void checkUnsupportedOperationsForTextIndex(String column, IndexLoadingConfig indexLoadingConfig,\n-      FieldSpec fieldSpec) {\n-    if (!indexLoadingConfig.getNoDictionaryColumns().contains(column)) {\n-      throw new UnsupportedOperationException(\n-          \"Text index is currently not supported on dictionary encoded column: \" + column);\n-    }\n-\n-    Set<String> sortedColumns = new HashSet<>(indexLoadingConfig.getSortedColumns());\n-    if (sortedColumns.contains(column)) {\n-      // since Pinot's current implementation doesn't support raw sorted columns,\n-      // we need to check for this too\n-      throw new UnsupportedOperationException(\"Text index is currently not supported on sorted column: \" + column);\n-    }\n-\n+  private void checkUnsupportedOperationsForTextIndex(String column, FieldSpec fieldSpec) {", "originalCommit": "cdd757223f33faac42815feaaa3bed4814ab118b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwMjkwMA==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r456002900", "bodyText": "Remove this check (or replace with checkState)", "author": "Jackie-Jiang", "createdAt": "2020-07-16T18:54:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -151,30 +143,76 @@ private void createTextIndexForColumn(ColumnMetadata columnMetadata)\n       return;\n     }\n     int numDocs = columnMetadata.getTotalDocs();\n-    LOGGER.info(\"Creating new text index for column: {} in segment: {}\", column, _segmentName);\n+    boolean hasDictionary = columnMetadata.hasDictionary();\n+    LOGGER.info(\"Creating new text index for column: {} in segment: {}, hasDictionary: {}\", column, _segmentName, hasDictionary);\n     File segmentDirectory = SegmentDirectoryPaths.segmentDirectoryFor(_indexDir, _segmentVersion);\n     // The handlers are always invoked by the preprocessor. Before this ImmutableSegmentLoader would have already\n     // up-converted the segment from v1/v2 -> v3 (if needed). So based on the segmentVersion, whatever segment\n     // segmentDirectory is indicated to us by SegmentDirectoryPaths, we create lucene index there. There is no\n     // further need to move around the lucene index directory since it is created with correct directory structure\n     // based on segmentVersion.\n-    try (LuceneTextIndexCreator textIndexCreator = new LuceneTextIndexCreator(column, segmentDirectory, true);\n-        VarByteChunkSVForwardIndexReader forwardIndexReader = getForwardIndexReader(columnMetadata);\n-        ChunkReaderContext readerContext = forwardIndexReader.createContext()) {\n-      for (int docId = 0; docId < numDocs; docId++) {\n-        textIndexCreator.addDoc(forwardIndexReader.getString(docId, readerContext), docId);\n+    try (ForwardIndexReader forwardIndexReader = getForwardIndexReader(columnMetadata);\n+        ForwardIndexReaderContext readerContext = forwardIndexReader.createContext();\n+        LuceneTextIndexCreator textIndexCreator = new LuceneTextIndexCreator(column, segmentDirectory, true)) {\n+      if (!hasDictionary) {\n+        // text index on raw column, just read the raw forward index\n+        VarByteChunkSVForwardIndexReader rawIndexReader = (VarByteChunkSVForwardIndexReader)forwardIndexReader;\n+        ChunkReaderContext chunkReaderContext = (ChunkReaderContext)readerContext;\n+        for (int docId = 0; docId < numDocs; docId++) {\n+          textIndexCreator.addDoc(rawIndexReader.getString(docId, chunkReaderContext), docId);\n+        }\n+      } else {\n+        // text index on dictionary encoded SV column\n+        // read forward index to get dictId\n+        // read the raw value from dictionary using dictId\n+        try (BaseImmutableDictionary dictionary = getDictionaryReader(columnMetadata)) {\n+          if (columnMetadata.isSingleValue()) {", "originalCommit": "cdd757223f33faac42815feaaa3bed4814ab118b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7afda3f00cfaabcf966098ec3847993ee8063344", "url": "https://github.com/apache/pinot/commit/7afda3f00cfaabcf966098ec3847993ee8063344", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-17T01:33:22Z", "type": "forcePushed"}, {"oid": "7fb7f358d5fb0a4b6510a900fadd95a08def674c", "url": "https://github.com/apache/pinot/commit/7fb7f358d5fb0a4b6510a900fadd95a08def674c", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-17T03:32:29Z", "type": "commit"}, {"oid": "7fb7f358d5fb0a4b6510a900fadd95a08def674c", "url": "https://github.com/apache/pinot/commit/7fb7f358d5fb0a4b6510a900fadd95a08def674c", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-17T03:32:29Z", "type": "forcePushed"}]}