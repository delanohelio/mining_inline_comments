{"pr_number": 5665, "pr_title": "Re-implement TarGzCompressionUtils", "pr_createdAt": "2020-07-08T01:00:25Z", "pr_url": "https://github.com/apache/pinot/pull/5665", "timeline": [{"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "url": "https://github.com/apache/pinot/commit/f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "message": "Re-implement TarGzCompressionUtils\n\nCurrently several tests are flaky because of the tar-gz compression\n\nIn thie PR:\n- Upgrade commons-compress to 1.20 for the bug in this ticket: https://issues.apache.org/jira/browse/COMPRESS-417\n- Re-implement TarGzCompressionUtils following the library user guide: https://commons.apache.org/proper/commons-compress/examples.html\n- With the re-implemented TarGzCompressionUtils, simplify the code for the caller", "committedDate": "2020-07-08T01:57:08Z", "type": "commit"}, {"oid": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "url": "https://github.com/apache/pinot/commit/f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "message": "Re-implement TarGzCompressionUtils\n\nCurrently several tests are flaky because of the tar-gz compression\n\nIn thie PR:\n- Upgrade commons-compress to 1.20 for the bug in this ticket: https://issues.apache.org/jira/browse/COMPRESS-417\n- Re-implement TarGzCompressionUtils following the library user guide: https://commons.apache.org/proper/commons-compress/examples.html\n- With the re-implemented TarGzCompressionUtils, simplify the code for the caller", "committedDate": "2020-07-08T01:57:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODkxNA==", "url": "https://github.com/apache/pinot/pull/5665#discussion_r452578914", "bodyText": "Which part is flakey in the current code?", "author": "siddharthteotia", "createdAt": "2020-07-10T01:46:27Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/TarGzCompressionUtils.java", "diffHunk": "@@ -18,225 +18,151 @@\n  */\n package org.apache.pinot.common.utils;\n \n+import com.google.common.base.Preconditions;\n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.List;\n-import org.apache.commons.compress.archivers.ArchiveException;\n-import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n-import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.IOUtils;\n-import org.apache.pinot.common.Utils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.commons.lang3.StringUtils;\n \n \n /**\n- * Taken from http://www.thoughtspark.org/node/53\n- *\n+ * Utility class to compress/de-compress tar.gz files.\n  */\n public class TarGzCompressionUtils {", "originalCommit": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYzNTIzOA==", "url": "https://github.com/apache/pinot/pull/5665#discussion_r452635238", "bodyText": "The flakiness is from the library version, not the implementation.\nRe-implemented it for the following reasons:\n\nEase of use\nFollowing the official tutorial, instead of copying from some random place\nSupport system with file separator other than \"/\"", "author": "Jackie-Jiang", "createdAt": "2020-07-10T05:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwMzQ0MA==", "url": "https://github.com/apache/pinot/pull/5665#discussion_r453103440", "bodyText": "How does the flakiness manifest itself though? Would be good to document that.", "author": "mayankshriv", "createdAt": "2020-07-10T22:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MjEzNg==", "url": "https://github.com/apache/pinot/pull/5665#discussion_r453142136", "bodyText": "Not sure how to constantly reproduce the issue, but the issue is documented in the linked commons-compress issue ticket", "author": "Jackie-Jiang", "createdAt": "2020-07-11T02:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODk0NA==", "url": "https://github.com/apache/pinot/pull/5665#discussion_r452578944", "bodyText": "When will this not be true? File outputFile = outputDir should ensure it is always true?", "author": "siddharthteotia", "createdAt": "2020-07-10T01:46:38Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/TarGzCompressionUtils.java", "diffHunk": "@@ -18,225 +18,151 @@\n  */\n package org.apache.pinot.common.utils;\n \n+import com.google.common.base.Preconditions;\n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.List;\n-import org.apache.commons.compress.archivers.ArchiveException;\n-import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n-import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.IOUtils;\n-import org.apache.pinot.common.Utils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.commons.lang3.StringUtils;\n \n \n /**\n- * Taken from http://www.thoughtspark.org/node/53\n- *\n+ * Utility class to compress/de-compress tar.gz files.\n  */\n public class TarGzCompressionUtils {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(TarGzCompressionUtils.class);\n+  private TarGzCompressionUtils() {\n+  }\n+\n   public static final String TAR_GZ_FILE_EXTENSION = \".tar.gz\";\n+  private static final char ENTRY_NAME_SEPARATOR = '/';\n \n   /**\n-   * Creates a tar.gz file at the specified path with the contents of the\n-   * specified directory.\n-   *\n-   * @param directoryPath\n-   *          The path to the directory to create an archive of\n-   * @param tarGzPath\n-   *          The path to the archive to create. The file may not exist but\n-   *          it's parent must exist and the parent must be a directory\n-   * @return tarGzPath\n-   * @throws IOException\n-   *           If anything goes wrong\n+   * Creates a tar.gz file from the input file/directory to the output file. The output file must have \".tar.gz\" as the\n+   * file extension.\n    */\n-  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath)\n-      throws IOException {\n-    return createTarGzOfDirectory(directoryPath, tarGzPath, \"\");\n-  }\n-\n-  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath, String entryPrefix)\n+  public static void createTarGzFile(File inputFile, File outputFile)\n       throws IOException {\n-    if (!tarGzPath.endsWith(TAR_GZ_FILE_EXTENSION)) {\n-      tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENSION;\n+    Preconditions.checkArgument(outputFile.getName().endsWith(TAR_GZ_FILE_EXTENSION),\n+        \"Output file: %s does not have '.tar.gz' file extension\", outputFile);\n+    try (OutputStream fileOut = Files.newOutputStream(outputFile.toPath());\n+        BufferedOutputStream bufferedOut = new BufferedOutputStream(fileOut);\n+        OutputStream gzipOut = new GzipCompressorOutputStream(bufferedOut);\n+        TarArchiveOutputStream tarGzOut = new TarArchiveOutputStream(gzipOut)) {\n+      tarGzOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+      addFileToTarGz(tarGzOut, inputFile, \"\");\n     }\n-    try (FileOutputStream fOut = new FileOutputStream(new File(tarGzPath));\n-        BufferedOutputStream bOut = new BufferedOutputStream(fOut);\n-        GzipCompressorOutputStream gzOut = new GzipCompressorOutputStream(bOut);\n-        TarArchiveOutputStream tOut = new TarArchiveOutputStream(gzOut)) {\n-      tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-      addFileToTarGz(tOut, directoryPath, entryPrefix);\n-    } catch (IOException e) {\n-      LOGGER.error(\"Failed to create tar.gz file for {} at path: {}\", directoryPath, tarGzPath, e);\n-      Utils.rethrowException(e);\n-    }\n-    return tarGzPath;\n-  }\n-\n-  public static String createTarGzOfDirectory(String directoryPath)\n-      throws IOException {\n-    String tarGzPath = directoryPath.substring(0);\n-    while (tarGzPath.endsWith(\"/\")) {\n-      tarGzPath = tarGzPath.substring(0, tarGzPath.length() - 1);\n-    }\n-    tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENSION;\n-    return createTarGzOfDirectory(directoryPath, tarGzPath);\n   }\n \n   /**\n-   * Creates a tar entry for the path specified with a name built from the base\n-   * passed in and the file/directory name. If the path is a directory, a\n-   * recursive call is made such that the full directory is added to the tar.\n-   *\n-   * @param tOut\n-   *          The tar file's output stream\n-   * @param path\n-   *          The filesystem path of the file/directory being added\n-   * @param base\n-   *          The base prefix to for the name of the tar file entry\n-   *\n-   * @throws IOException\n-   *           If anything goes wrong\n+   * Helper method to write a file into the tar.gz file output stream. The base entry name is the relative path of the\n+   * file to the root directory.\n    */\n-  private static void addFileToTarGz(TarArchiveOutputStream tOut, String path, String base)\n+  private static void addFileToTarGz(ArchiveOutputStream tarGzOut, File file, String baseEntryName)\n       throws IOException {\n-    File f = new File(path);\n-    String entryName = base + f.getName();\n-    TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n-\n-    tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-    tOut.putArchiveEntry(tarEntry);\n-\n-    if (f.isFile()) {\n-      IOUtils.copy(new FileInputStream(f), tOut);\n-\n-      tOut.closeArchiveEntry();\n+    String entryName = baseEntryName + file.getName();\n+    TarArchiveEntry entry = new TarArchiveEntry(file, entryName);\n+    tarGzOut.putArchiveEntry(entry);\n+    if (file.isFile()) {\n+      try (InputStream in = Files.newInputStream(file.toPath())) {\n+        IOUtils.copy(in, tarGzOut);\n+      }\n+      tarGzOut.closeArchiveEntry();\n     } else {\n-      tOut.closeArchiveEntry();\n+      tarGzOut.closeArchiveEntry();\n \n-      File[] children = f.listFiles();\n-\n-      if (children != null) {\n-        for (File child : children) {\n-          addFileToTarGz(tOut, child.getAbsolutePath(), entryName + \"/\");\n-        }\n+      File[] children = file.listFiles();\n+      assert children != null;\n+      String baseEntryNameForChildren = entryName + ENTRY_NAME_SEPARATOR;\n+      for (File child : children) {\n+        addFileToTarGz(tarGzOut, child, baseEntryNameForChildren);\n       }\n     }\n   }\n \n-  /** Untar an input file into an output file.\n-   * The output file is created in the output folder, having the same name\n-   * as the input file, minus the '.tar' extension.\n-   *\n-   * @param inputFile     the input .tar file\n-   * @param outputDir     the output directory file.\n-   * @throws IOException\n-   * @throws FileNotFoundException\n-   *\n-   * @return The {@link List} of {@link File}s with the untared content.\n-   * @throws ArchiveException\n+  /**\n+   * Un-tars a tar.gz file into a directory, returns all the untarred files/directories.\n+   * <p>For security reason, the untarred files must reside in the output directory.\n    */\n-  public static List<File> unTar(final File inputFile, final File outputDir)\n-      throws IOException, ArchiveException {\n-\n-    String outputDirectoryPath = outputDir.getCanonicalPath();\n-    LOGGER.debug(\"Untaring {} to dir {}.\", inputFile.getAbsolutePath(), outputDirectoryPath);\n-    TarArchiveInputStream debInputStream = null;\n-    InputStream is = null;\n-    final List<File> untaredFiles = new LinkedList<File>();\n-    try {\n-      is = new GzipCompressorInputStream(new BufferedInputStream(new FileInputStream(inputFile)));\n-      debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n-      TarArchiveEntry entry = null;\n-      while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {\n-        final File outputFile = new File(outputDir, entry.getName());\n-        // Check whether the untarred file will be put outside of the target output directory.\n-        if (!outputFile.getCanonicalPath().startsWith(outputDirectoryPath)) {\n-          throw new IOException(\"Tar file must not be untarred outside of the target output directory!\");\n+  public static List<File> untar(File inputFile, File outputDir)\n+      throws IOException {\n+    String outputDirCanonicalPath = outputDir.getCanonicalPath();\n+    List<File> untarredFiles = new ArrayList<>();\n+    try (InputStream fileIn = Files.newInputStream(inputFile.toPath());\n+        InputStream bufferedIn = new BufferedInputStream(fileIn);\n+        InputStream gzipIn = new GzipCompressorInputStream(bufferedIn);\n+        ArchiveInputStream tarGzIn = new TarArchiveInputStream(gzipIn)) {\n+      ArchiveEntry entry;\n+      while ((entry = tarGzIn.getNextEntry()) != null) {\n+        String entryName = entry.getName();\n+        String[] parts = StringUtils.split(entryName, ENTRY_NAME_SEPARATOR);\n+        File outputFile = outputDir;\n+        for (String part : parts) {\n+          outputFile = new File(outputFile, part);\n         }\n         if (entry.isDirectory()) {\n-          // creating directory\n-          LOGGER.debug(String.format(\"Attempting to write output directory %s.\", outputFile.getAbsolutePath()));\n-          if (!outputFile.exists()) {\n-            // does not exist\n-            LOGGER.debug(String.format(\"Attempting to create output directory %s.\", outputFile.getAbsolutePath()));\n-            try {\n-              // create the directory including any non-existent parent directories\n-              Files.createDirectories(outputFile.toPath());\n-            } catch (Exception e) {\n-              LOGGER.error(\"Caught exception while creating directory: {}, error: {}\", outputFile.getAbsolutePath(), e);\n-              throw e;\n-            }\n-          } else {\n-            // directory already exists\n-            LOGGER.error(\"The directory already there. Deleting - \" + outputFile.getAbsolutePath());\n-            FileUtils.deleteDirectory(outputFile);\n+          if (!outputFile.getCanonicalPath().startsWith(outputDirCanonicalPath)) {", "originalCommit": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYzODA3Ng==", "url": "https://github.com/apache/pinot/pull/5665#discussion_r452638076", "bodyText": "There is a test case for this. We want to prevent malicious tar file to inject file outside of the outputDir, and we don't know if there is some way to directly jump out of the outputDir, so this is the safest way. This security check was added in #2835", "author": "Jackie-Jiang", "createdAt": "2020-07-10T06:01:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTAyNQ==", "url": "https://github.com/apache/pinot/pull/5665#discussion_r452579025", "bodyText": "Since entry is a directory and each part leading up to the entry is also a directory, outputFile is also a directory right since outputFile = new File(outputFile, part);", "author": "siddharthteotia", "createdAt": "2020-07-10T01:46:51Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/TarGzCompressionUtils.java", "diffHunk": "@@ -18,225 +18,151 @@\n  */\n package org.apache.pinot.common.utils;\n \n+import com.google.common.base.Preconditions;\n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.List;\n-import org.apache.commons.compress.archivers.ArchiveException;\n-import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n-import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.IOUtils;\n-import org.apache.pinot.common.Utils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.commons.lang3.StringUtils;\n \n \n /**\n- * Taken from http://www.thoughtspark.org/node/53\n- *\n+ * Utility class to compress/de-compress tar.gz files.\n  */\n public class TarGzCompressionUtils {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(TarGzCompressionUtils.class);\n+  private TarGzCompressionUtils() {\n+  }\n+\n   public static final String TAR_GZ_FILE_EXTENSION = \".tar.gz\";\n+  private static final char ENTRY_NAME_SEPARATOR = '/';\n \n   /**\n-   * Creates a tar.gz file at the specified path with the contents of the\n-   * specified directory.\n-   *\n-   * @param directoryPath\n-   *          The path to the directory to create an archive of\n-   * @param tarGzPath\n-   *          The path to the archive to create. The file may not exist but\n-   *          it's parent must exist and the parent must be a directory\n-   * @return tarGzPath\n-   * @throws IOException\n-   *           If anything goes wrong\n+   * Creates a tar.gz file from the input file/directory to the output file. The output file must have \".tar.gz\" as the\n+   * file extension.\n    */\n-  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath)\n-      throws IOException {\n-    return createTarGzOfDirectory(directoryPath, tarGzPath, \"\");\n-  }\n-\n-  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath, String entryPrefix)\n+  public static void createTarGzFile(File inputFile, File outputFile)\n       throws IOException {\n-    if (!tarGzPath.endsWith(TAR_GZ_FILE_EXTENSION)) {\n-      tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENSION;\n+    Preconditions.checkArgument(outputFile.getName().endsWith(TAR_GZ_FILE_EXTENSION),\n+        \"Output file: %s does not have '.tar.gz' file extension\", outputFile);\n+    try (OutputStream fileOut = Files.newOutputStream(outputFile.toPath());\n+        BufferedOutputStream bufferedOut = new BufferedOutputStream(fileOut);\n+        OutputStream gzipOut = new GzipCompressorOutputStream(bufferedOut);\n+        TarArchiveOutputStream tarGzOut = new TarArchiveOutputStream(gzipOut)) {\n+      tarGzOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+      addFileToTarGz(tarGzOut, inputFile, \"\");\n     }\n-    try (FileOutputStream fOut = new FileOutputStream(new File(tarGzPath));\n-        BufferedOutputStream bOut = new BufferedOutputStream(fOut);\n-        GzipCompressorOutputStream gzOut = new GzipCompressorOutputStream(bOut);\n-        TarArchiveOutputStream tOut = new TarArchiveOutputStream(gzOut)) {\n-      tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-      addFileToTarGz(tOut, directoryPath, entryPrefix);\n-    } catch (IOException e) {\n-      LOGGER.error(\"Failed to create tar.gz file for {} at path: {}\", directoryPath, tarGzPath, e);\n-      Utils.rethrowException(e);\n-    }\n-    return tarGzPath;\n-  }\n-\n-  public static String createTarGzOfDirectory(String directoryPath)\n-      throws IOException {\n-    String tarGzPath = directoryPath.substring(0);\n-    while (tarGzPath.endsWith(\"/\")) {\n-      tarGzPath = tarGzPath.substring(0, tarGzPath.length() - 1);\n-    }\n-    tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENSION;\n-    return createTarGzOfDirectory(directoryPath, tarGzPath);\n   }\n \n   /**\n-   * Creates a tar entry for the path specified with a name built from the base\n-   * passed in and the file/directory name. If the path is a directory, a\n-   * recursive call is made such that the full directory is added to the tar.\n-   *\n-   * @param tOut\n-   *          The tar file's output stream\n-   * @param path\n-   *          The filesystem path of the file/directory being added\n-   * @param base\n-   *          The base prefix to for the name of the tar file entry\n-   *\n-   * @throws IOException\n-   *           If anything goes wrong\n+   * Helper method to write a file into the tar.gz file output stream. The base entry name is the relative path of the\n+   * file to the root directory.\n    */\n-  private static void addFileToTarGz(TarArchiveOutputStream tOut, String path, String base)\n+  private static void addFileToTarGz(ArchiveOutputStream tarGzOut, File file, String baseEntryName)\n       throws IOException {\n-    File f = new File(path);\n-    String entryName = base + f.getName();\n-    TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n-\n-    tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-    tOut.putArchiveEntry(tarEntry);\n-\n-    if (f.isFile()) {\n-      IOUtils.copy(new FileInputStream(f), tOut);\n-\n-      tOut.closeArchiveEntry();\n+    String entryName = baseEntryName + file.getName();\n+    TarArchiveEntry entry = new TarArchiveEntry(file, entryName);\n+    tarGzOut.putArchiveEntry(entry);\n+    if (file.isFile()) {\n+      try (InputStream in = Files.newInputStream(file.toPath())) {\n+        IOUtils.copy(in, tarGzOut);\n+      }\n+      tarGzOut.closeArchiveEntry();\n     } else {\n-      tOut.closeArchiveEntry();\n+      tarGzOut.closeArchiveEntry();\n \n-      File[] children = f.listFiles();\n-\n-      if (children != null) {\n-        for (File child : children) {\n-          addFileToTarGz(tOut, child.getAbsolutePath(), entryName + \"/\");\n-        }\n+      File[] children = file.listFiles();\n+      assert children != null;\n+      String baseEntryNameForChildren = entryName + ENTRY_NAME_SEPARATOR;\n+      for (File child : children) {\n+        addFileToTarGz(tarGzOut, child, baseEntryNameForChildren);\n       }\n     }\n   }\n \n-  /** Untar an input file into an output file.\n-   * The output file is created in the output folder, having the same name\n-   * as the input file, minus the '.tar' extension.\n-   *\n-   * @param inputFile     the input .tar file\n-   * @param outputDir     the output directory file.\n-   * @throws IOException\n-   * @throws FileNotFoundException\n-   *\n-   * @return The {@link List} of {@link File}s with the untared content.\n-   * @throws ArchiveException\n+  /**\n+   * Un-tars a tar.gz file into a directory, returns all the untarred files/directories.\n+   * <p>For security reason, the untarred files must reside in the output directory.\n    */\n-  public static List<File> unTar(final File inputFile, final File outputDir)\n-      throws IOException, ArchiveException {\n-\n-    String outputDirectoryPath = outputDir.getCanonicalPath();\n-    LOGGER.debug(\"Untaring {} to dir {}.\", inputFile.getAbsolutePath(), outputDirectoryPath);\n-    TarArchiveInputStream debInputStream = null;\n-    InputStream is = null;\n-    final List<File> untaredFiles = new LinkedList<File>();\n-    try {\n-      is = new GzipCompressorInputStream(new BufferedInputStream(new FileInputStream(inputFile)));\n-      debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n-      TarArchiveEntry entry = null;\n-      while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {\n-        final File outputFile = new File(outputDir, entry.getName());\n-        // Check whether the untarred file will be put outside of the target output directory.\n-        if (!outputFile.getCanonicalPath().startsWith(outputDirectoryPath)) {\n-          throw new IOException(\"Tar file must not be untarred outside of the target output directory!\");\n+  public static List<File> untar(File inputFile, File outputDir)\n+      throws IOException {\n+    String outputDirCanonicalPath = outputDir.getCanonicalPath();\n+    List<File> untarredFiles = new ArrayList<>();\n+    try (InputStream fileIn = Files.newInputStream(inputFile.toPath());\n+        InputStream bufferedIn = new BufferedInputStream(fileIn);\n+        InputStream gzipIn = new GzipCompressorInputStream(bufferedIn);\n+        ArchiveInputStream tarGzIn = new TarArchiveInputStream(gzipIn)) {\n+      ArchiveEntry entry;\n+      while ((entry = tarGzIn.getNextEntry()) != null) {\n+        String entryName = entry.getName();\n+        String[] parts = StringUtils.split(entryName, ENTRY_NAME_SEPARATOR);\n+        File outputFile = outputDir;\n+        for (String part : parts) {\n+          outputFile = new File(outputFile, part);\n         }\n         if (entry.isDirectory()) {\n-          // creating directory\n-          LOGGER.debug(String.format(\"Attempting to write output directory %s.\", outputFile.getAbsolutePath()));\n-          if (!outputFile.exists()) {\n-            // does not exist\n-            LOGGER.debug(String.format(\"Attempting to create output directory %s.\", outputFile.getAbsolutePath()));\n-            try {\n-              // create the directory including any non-existent parent directories\n-              Files.createDirectories(outputFile.toPath());\n-            } catch (Exception e) {\n-              LOGGER.error(\"Caught exception while creating directory: {}, error: {}\", outputFile.getAbsolutePath(), e);\n-              throw e;\n-            }\n-          } else {\n-            // directory already exists\n-            LOGGER.error(\"The directory already there. Deleting - \" + outputFile.getAbsolutePath());\n-            FileUtils.deleteDirectory(outputFile);\n+          if (!outputFile.getCanonicalPath().startsWith(outputDirCanonicalPath)) {\n+            throw new IOException(String\n+                .format(\"Trying to create directory: %s outside of the output directory: %s\", outputFile, outputDir));\n+          }\n+          if (!outputFile.isDirectory() && !outputFile.mkdirs()) {", "originalCommit": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYzNjE0MQ==", "url": "https://github.com/apache/pinot/pull/5665#discussion_r452636141", "bodyText": "outputFile is the file/dir pointed by the entry, so if entry is directory, then outputFile is directory", "author": "Jackie-Jiang", "createdAt": "2020-07-10T05:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTM4MA==", "url": "https://github.com/apache/pinot/pull/5665#discussion_r452579380", "bodyText": "mkdirs() will create non-existent parent directories. If it fails in between after creating some of the parent directories, do we need to recover from that?", "author": "siddharthteotia", "createdAt": "2020-07-10T01:48:21Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/TarGzCompressionUtils.java", "diffHunk": "@@ -18,225 +18,151 @@\n  */\n package org.apache.pinot.common.utils;\n \n+import com.google.common.base.Preconditions;\n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.List;\n-import org.apache.commons.compress.archivers.ArchiveException;\n-import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n-import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.IOUtils;\n-import org.apache.pinot.common.Utils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.commons.lang3.StringUtils;\n \n \n /**\n- * Taken from http://www.thoughtspark.org/node/53\n- *\n+ * Utility class to compress/de-compress tar.gz files.\n  */\n public class TarGzCompressionUtils {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(TarGzCompressionUtils.class);\n+  private TarGzCompressionUtils() {\n+  }\n+\n   public static final String TAR_GZ_FILE_EXTENSION = \".tar.gz\";\n+  private static final char ENTRY_NAME_SEPARATOR = '/';\n \n   /**\n-   * Creates a tar.gz file at the specified path with the contents of the\n-   * specified directory.\n-   *\n-   * @param directoryPath\n-   *          The path to the directory to create an archive of\n-   * @param tarGzPath\n-   *          The path to the archive to create. The file may not exist but\n-   *          it's parent must exist and the parent must be a directory\n-   * @return tarGzPath\n-   * @throws IOException\n-   *           If anything goes wrong\n+   * Creates a tar.gz file from the input file/directory to the output file. The output file must have \".tar.gz\" as the\n+   * file extension.\n    */\n-  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath)\n-      throws IOException {\n-    return createTarGzOfDirectory(directoryPath, tarGzPath, \"\");\n-  }\n-\n-  public static String createTarGzOfDirectory(String directoryPath, String tarGzPath, String entryPrefix)\n+  public static void createTarGzFile(File inputFile, File outputFile)\n       throws IOException {\n-    if (!tarGzPath.endsWith(TAR_GZ_FILE_EXTENSION)) {\n-      tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENSION;\n+    Preconditions.checkArgument(outputFile.getName().endsWith(TAR_GZ_FILE_EXTENSION),\n+        \"Output file: %s does not have '.tar.gz' file extension\", outputFile);\n+    try (OutputStream fileOut = Files.newOutputStream(outputFile.toPath());\n+        BufferedOutputStream bufferedOut = new BufferedOutputStream(fileOut);\n+        OutputStream gzipOut = new GzipCompressorOutputStream(bufferedOut);\n+        TarArchiveOutputStream tarGzOut = new TarArchiveOutputStream(gzipOut)) {\n+      tarGzOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n+      addFileToTarGz(tarGzOut, inputFile, \"\");\n     }\n-    try (FileOutputStream fOut = new FileOutputStream(new File(tarGzPath));\n-        BufferedOutputStream bOut = new BufferedOutputStream(fOut);\n-        GzipCompressorOutputStream gzOut = new GzipCompressorOutputStream(bOut);\n-        TarArchiveOutputStream tOut = new TarArchiveOutputStream(gzOut)) {\n-      tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-      addFileToTarGz(tOut, directoryPath, entryPrefix);\n-    } catch (IOException e) {\n-      LOGGER.error(\"Failed to create tar.gz file for {} at path: {}\", directoryPath, tarGzPath, e);\n-      Utils.rethrowException(e);\n-    }\n-    return tarGzPath;\n-  }\n-\n-  public static String createTarGzOfDirectory(String directoryPath)\n-      throws IOException {\n-    String tarGzPath = directoryPath.substring(0);\n-    while (tarGzPath.endsWith(\"/\")) {\n-      tarGzPath = tarGzPath.substring(0, tarGzPath.length() - 1);\n-    }\n-    tarGzPath = tarGzPath + TAR_GZ_FILE_EXTENSION;\n-    return createTarGzOfDirectory(directoryPath, tarGzPath);\n   }\n \n   /**\n-   * Creates a tar entry for the path specified with a name built from the base\n-   * passed in and the file/directory name. If the path is a directory, a\n-   * recursive call is made such that the full directory is added to the tar.\n-   *\n-   * @param tOut\n-   *          The tar file's output stream\n-   * @param path\n-   *          The filesystem path of the file/directory being added\n-   * @param base\n-   *          The base prefix to for the name of the tar file entry\n-   *\n-   * @throws IOException\n-   *           If anything goes wrong\n+   * Helper method to write a file into the tar.gz file output stream. The base entry name is the relative path of the\n+   * file to the root directory.\n    */\n-  private static void addFileToTarGz(TarArchiveOutputStream tOut, String path, String base)\n+  private static void addFileToTarGz(ArchiveOutputStream tarGzOut, File file, String baseEntryName)\n       throws IOException {\n-    File f = new File(path);\n-    String entryName = base + f.getName();\n-    TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n-\n-    tOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n-    tOut.putArchiveEntry(tarEntry);\n-\n-    if (f.isFile()) {\n-      IOUtils.copy(new FileInputStream(f), tOut);\n-\n-      tOut.closeArchiveEntry();\n+    String entryName = baseEntryName + file.getName();\n+    TarArchiveEntry entry = new TarArchiveEntry(file, entryName);\n+    tarGzOut.putArchiveEntry(entry);\n+    if (file.isFile()) {\n+      try (InputStream in = Files.newInputStream(file.toPath())) {\n+        IOUtils.copy(in, tarGzOut);\n+      }\n+      tarGzOut.closeArchiveEntry();\n     } else {\n-      tOut.closeArchiveEntry();\n+      tarGzOut.closeArchiveEntry();\n \n-      File[] children = f.listFiles();\n-\n-      if (children != null) {\n-        for (File child : children) {\n-          addFileToTarGz(tOut, child.getAbsolutePath(), entryName + \"/\");\n-        }\n+      File[] children = file.listFiles();\n+      assert children != null;\n+      String baseEntryNameForChildren = entryName + ENTRY_NAME_SEPARATOR;\n+      for (File child : children) {\n+        addFileToTarGz(tarGzOut, child, baseEntryNameForChildren);\n       }\n     }\n   }\n \n-  /** Untar an input file into an output file.\n-   * The output file is created in the output folder, having the same name\n-   * as the input file, minus the '.tar' extension.\n-   *\n-   * @param inputFile     the input .tar file\n-   * @param outputDir     the output directory file.\n-   * @throws IOException\n-   * @throws FileNotFoundException\n-   *\n-   * @return The {@link List} of {@link File}s with the untared content.\n-   * @throws ArchiveException\n+  /**\n+   * Un-tars a tar.gz file into a directory, returns all the untarred files/directories.\n+   * <p>For security reason, the untarred files must reside in the output directory.\n    */\n-  public static List<File> unTar(final File inputFile, final File outputDir)\n-      throws IOException, ArchiveException {\n-\n-    String outputDirectoryPath = outputDir.getCanonicalPath();\n-    LOGGER.debug(\"Untaring {} to dir {}.\", inputFile.getAbsolutePath(), outputDirectoryPath);\n-    TarArchiveInputStream debInputStream = null;\n-    InputStream is = null;\n-    final List<File> untaredFiles = new LinkedList<File>();\n-    try {\n-      is = new GzipCompressorInputStream(new BufferedInputStream(new FileInputStream(inputFile)));\n-      debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n-      TarArchiveEntry entry = null;\n-      while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {\n-        final File outputFile = new File(outputDir, entry.getName());\n-        // Check whether the untarred file will be put outside of the target output directory.\n-        if (!outputFile.getCanonicalPath().startsWith(outputDirectoryPath)) {\n-          throw new IOException(\"Tar file must not be untarred outside of the target output directory!\");\n+  public static List<File> untar(File inputFile, File outputDir)\n+      throws IOException {\n+    String outputDirCanonicalPath = outputDir.getCanonicalPath();\n+    List<File> untarredFiles = new ArrayList<>();\n+    try (InputStream fileIn = Files.newInputStream(inputFile.toPath());\n+        InputStream bufferedIn = new BufferedInputStream(fileIn);\n+        InputStream gzipIn = new GzipCompressorInputStream(bufferedIn);\n+        ArchiveInputStream tarGzIn = new TarArchiveInputStream(gzipIn)) {\n+      ArchiveEntry entry;\n+      while ((entry = tarGzIn.getNextEntry()) != null) {\n+        String entryName = entry.getName();\n+        String[] parts = StringUtils.split(entryName, ENTRY_NAME_SEPARATOR);\n+        File outputFile = outputDir;\n+        for (String part : parts) {\n+          outputFile = new File(outputFile, part);\n         }\n         if (entry.isDirectory()) {\n-          // creating directory\n-          LOGGER.debug(String.format(\"Attempting to write output directory %s.\", outputFile.getAbsolutePath()));\n-          if (!outputFile.exists()) {\n-            // does not exist\n-            LOGGER.debug(String.format(\"Attempting to create output directory %s.\", outputFile.getAbsolutePath()));\n-            try {\n-              // create the directory including any non-existent parent directories\n-              Files.createDirectories(outputFile.toPath());\n-            } catch (Exception e) {\n-              LOGGER.error(\"Caught exception while creating directory: {}, error: {}\", outputFile.getAbsolutePath(), e);\n-              throw e;\n-            }\n-          } else {\n-            // directory already exists\n-            LOGGER.error(\"The directory already there. Deleting - \" + outputFile.getAbsolutePath());\n-            FileUtils.deleteDirectory(outputFile);\n+          if (!outputFile.getCanonicalPath().startsWith(outputDirCanonicalPath)) {\n+            throw new IOException(String\n+                .format(\"Trying to create directory: %s outside of the output directory: %s\", outputFile, outputDir));\n+          }\n+          if (!outputFile.isDirectory() && !outputFile.mkdirs()) {", "originalCommit": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYzODc0OQ==", "url": "https://github.com/apache/pinot/pull/5665#discussion_r452638749", "bodyText": "The parent is always inside the outputDir. We usually untar the file into a temporary directory, so no need to recover (I assume recover means delete the already uncompressed files/directories)", "author": "Jackie-Jiang", "createdAt": "2020-07-10T06:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwMzg1MQ==", "url": "https://github.com/apache/pinot/pull/5665#discussion_r453103851", "bodyText": "Is this for file separator? If so, use File.separator instead?", "author": "mayankshriv", "createdAt": "2020-07-10T22:24:10Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/TarGzCompressionUtils.java", "diffHunk": "@@ -18,225 +18,151 @@\n  */\n package org.apache.pinot.common.utils;\n \n+import com.google.common.base.Preconditions;\n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.List;\n-import org.apache.commons.compress.archivers.ArchiveException;\n-import org.apache.commons.compress.archivers.ArchiveStreamFactory;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n-import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.IOUtils;\n-import org.apache.pinot.common.Utils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.commons.lang3.StringUtils;\n \n \n /**\n- * Taken from http://www.thoughtspark.org/node/53\n- *\n+ * Utility class to compress/de-compress tar.gz files.\n  */\n public class TarGzCompressionUtils {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(TarGzCompressionUtils.class);\n+  private TarGzCompressionUtils() {\n+  }\n+\n   public static final String TAR_GZ_FILE_EXTENSION = \".tar.gz\";\n+  private static final char ENTRY_NAME_SEPARATOR = '/';", "originalCommit": "f683688bf09def3d41a43b2dee9626cfb1b6d1ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MTc0NA==", "url": "https://github.com/apache/pinot/pull/5665#discussion_r453141744", "bodyText": "This has to be '/' instead of the system dependent file separator so that the .tar.gz file created from different system can be shared.", "author": "Jackie-Jiang", "createdAt": "2020-07-11T02:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwMzg1MQ=="}], "type": "inlineReview"}]}