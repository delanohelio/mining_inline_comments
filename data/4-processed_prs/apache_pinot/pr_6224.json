{"pr_number": 6224, "pr_title": "Improve comparison coverage for selection SQL queries in ClusterInteg\u2026", "pr_createdAt": "2020-11-03T17:31:58Z", "pr_url": "https://github.com/apache/pinot/pull/6224", "timeline": [{"oid": "26041a9b1af398357943a28394c6ddec5c604133", "url": "https://github.com/apache/pinot/commit/26041a9b1af398357943a28394c6ddec5c604133", "message": "Improve comparison coverage for selection SQL queries in ClusterIntegrationTestUtils(#6193)", "committedDate": "2020-11-03T18:33:36Z", "type": "forcePushed"}, {"oid": "ab7f8cd3a5f3144149d1d633511b183695cc5656", "url": "https://github.com/apache/pinot/commit/ab7f8cd3a5f3144149d1d633511b183695cc5656", "message": "Improve comparison coverage for selection SQL queries in ClusterIntegrationTestUtils(#6193)", "committedDate": "2020-11-04T11:01:19Z", "type": "forcePushed"}, {"oid": "068aac9a1094e0458a00c3d33515e674d6fadd93", "url": "https://github.com/apache/pinot/commit/068aac9a1094e0458a00c3d33515e674d6fadd93", "message": "Improve comparison coverage for selection SQL queries in ClusterIntegrationTestUtils(#6193)", "committedDate": "2020-11-04T16:51:54Z", "type": "forcePushed"}, {"oid": "aab1cfaabd184e011cf23d8f88bee5fdc466f3b6", "url": "https://github.com/apache/pinot/commit/aab1cfaabd184e011cf23d8f88bee5fdc466f3b6", "message": "Improve comparison coverage for selection SQL queries in ClusterIntegrationTestUtils(#6193)", "committedDate": "2020-11-04T18:58:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwNDYzNg==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r517604636", "bodyText": "Can you add a comment why the index starts at 1 instead of 0?", "author": "jackjlli", "createdAt": "2020-11-04T20:13:55Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/ClusterIntegrationTestUtils.java", "diffHunk": "@@ -975,6 +830,199 @@ private static boolean isSelectionQuery(BrokerRequest brokerRequest) {\n     return false;\n   }\n \n+  private static Set<String> convertToUpperCase(Set<String> columns) {\n+    Set<String> upperCaseColumns = new HashSet<>();\n+    for (String column: columns) {\n+      upperCaseColumns.add(column.toUpperCase());\n+    }\n+    return upperCaseColumns;\n+  }\n+\n+  private static int getH2ExpectedValues(Set<String> expectedValues, List<String> expectedOrderByValues,\n+      ResultSet h2ResultSet, ResultSetMetaData h2MetaData, Set<String> orderByColumns) throws SQLException {\n+    Map<String, String> reusableExpectedValueMap = new HashMap<>();\n+    Map<String, List<String>> reusableMultiValuesMap = new HashMap<>();\n+    List<String> reusableColumnOrder = new ArrayList<>();\n+    int h2NumRows;\n+    int numColumns = h2MetaData.getColumnCount();\n+\n+    for (h2NumRows = 0; h2ResultSet.next() && h2NumRows < MAX_NUM_ROWS_TO_COMPARE; h2NumRows++) {\n+      reusableExpectedValueMap.clear();\n+      reusableMultiValuesMap.clear();\n+      reusableColumnOrder.clear();\n+\n+      for (int columnIndex = 1; columnIndex <= numColumns; columnIndex++) {", "originalCommit": "aab1cfaabd184e011cf23d8f88bee5fdc466f3b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwNTk1NQ==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r517605955", "bodyText": "If the result comparisons for PQL and SQL are done in two separate methods, should we still need to pass the queryFormat into testQuery() method?", "author": "jackjlli", "createdAt": "2020-11-04T20:16:17Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/ClusterIntegrationTestUtils.java", "diffHunk": "@@ -666,149 +668,14 @@ public static void testQuery(String pinotQuery, String queryFormat, String broke\n       }\n       Set<String> expectedValues = new HashSet<>();\n       List<String> expectedOrderByValues = new ArrayList<>();\n-      Map<String, String> reusableExpectedValueMap = new HashMap<>();\n-      Map<String, List<String>> reusableMultiValuesMap = new HashMap<>();\n-      List<String> reusableColumnOrder = new ArrayList<>();\n-      int h2NumRows;\n-      for (h2NumRows = 0; h2ResultSet.next() && h2NumRows < MAX_NUM_ROWS_TO_COMPARE; h2NumRows++) {\n-        reusableExpectedValueMap.clear();\n-        reusableMultiValuesMap.clear();\n-        reusableColumnOrder.clear();\n-\n-        int numColumns = h2MetaData.getColumnCount();\n-        for (int columnIndex = 1; columnIndex <= numColumns; columnIndex++) {\n-          String columnName = h2MetaData.getColumnName(columnIndex);\n-\n-          // Handle null result and convert boolean value to lower case\n-          String columnValue = h2ResultSet.getString(columnIndex);\n-          if (columnValue == null) {\n-            columnValue = \"null\";\n-          } else {\n-            columnValue = convertBooleanToLowerCase(columnValue);\n-          }\n \n-          // Handle multi-value columns\n-          int length = columnName.length();\n-          if (length > 5 && columnName.substring(length - 5, length - 1).equals(\"__MV\")) {\n-            // Multi-value column\n-            String multiValueColumnName = columnName.substring(0, length - 5);\n-            List<String> multiValue = reusableMultiValuesMap.get(multiValueColumnName);\n-            if (multiValue == null) {\n-              multiValue = new ArrayList<>();\n-              reusableMultiValuesMap.put(multiValueColumnName, multiValue);\n-              reusableColumnOrder.add(multiValueColumnName);\n-            }\n-            multiValue.add(columnValue);\n-          } else {\n-            // Single-value column\n-            reusableExpectedValueMap.put(columnName, columnValue);\n-            reusableColumnOrder.add(columnName);\n-          }\n-        }\n-\n-        // Add multi-value column results to the expected values\n-        // The reason for this step is that Pinot does not maintain order of elements in multi-value columns\n-        for (Map.Entry<String, List<String>> entry : reusableMultiValuesMap.entrySet()) {\n-          List<String> multiValue = entry.getValue();\n-          Collections.sort(multiValue);\n-          reusableExpectedValueMap.put(entry.getKey(), multiValue.toString());\n-        }\n-\n-        // Build expected value String\n-        StringBuilder expectedValue = new StringBuilder();\n-        StringBuilder expectedOrderByValue = new StringBuilder();\n-        for (String column : reusableColumnOrder) {\n-          expectedValue.append(column).append(':').append(reusableExpectedValueMap.get(column)).append(' ');\n-          if (orderByColumns.contains(column)) {\n-            expectedOrderByValue.append(column).append(':').append(reusableExpectedValueMap.get(column)).append(' ');\n-          }\n-        }\n-        expectedValues.add(expectedValue.toString());\n-        expectedOrderByValues.add(expectedOrderByValue.toString());\n-      }\n+      int h2NumRows = getH2ExpectedValues(expectedValues, expectedOrderByValues, h2ResultSet, h2MetaData, orderByColumns);", "originalCommit": "aab1cfaabd184e011cf23d8f88bee5fdc466f3b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY2Nzk0Nw==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r517667947", "bodyText": "You are right, I think we can remove queryFormat cause it will always be 'pql' for testQuery()", "author": "jtao15", "createdAt": "2020-11-04T22:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwNTk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwNzE5Ng==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r517607196", "bodyText": "Is it possible to reuse the original set here?", "author": "jackjlli", "createdAt": "2020-11-04T20:18:51Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/ClusterIntegrationTestUtils.java", "diffHunk": "@@ -975,6 +830,199 @@ private static boolean isSelectionQuery(BrokerRequest brokerRequest) {\n     return false;\n   }\n \n+  private static Set<String> convertToUpperCase(Set<String> columns) {\n+    Set<String> upperCaseColumns = new HashSet<>();", "originalCommit": "aab1cfaabd184e011cf23d8f88bee5fdc466f3b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYwOTMyMg==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r517609322", "bodyText": "Can you add some comments on why we do it this way in front of this method?", "author": "jackjlli", "createdAt": "2020-11-04T20:23:03Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/ClusterIntegrationTestUtils.java", "diffHunk": "@@ -975,6 +830,199 @@ private static boolean isSelectionQuery(BrokerRequest brokerRequest) {\n     return false;\n   }\n \n+  private static Set<String> convertToUpperCase(Set<String> columns) {\n+    Set<String> upperCaseColumns = new HashSet<>();\n+    for (String column: columns) {\n+      upperCaseColumns.add(column.toUpperCase());\n+    }\n+    return upperCaseColumns;\n+  }\n+\n+  private static int getH2ExpectedValues(Set<String> expectedValues, List<String> expectedOrderByValues,\n+      ResultSet h2ResultSet, ResultSetMetaData h2MetaData, Set<String> orderByColumns) throws SQLException {\n+    Map<String, String> reusableExpectedValueMap = new HashMap<>();\n+    Map<String, List<String>> reusableMultiValuesMap = new HashMap<>();\n+    List<String> reusableColumnOrder = new ArrayList<>();\n+    int h2NumRows;\n+    int numColumns = h2MetaData.getColumnCount();\n+\n+    for (h2NumRows = 0; h2ResultSet.next() && h2NumRows < MAX_NUM_ROWS_TO_COMPARE; h2NumRows++) {\n+      reusableExpectedValueMap.clear();\n+      reusableMultiValuesMap.clear();\n+      reusableColumnOrder.clear();\n+\n+      for (int columnIndex = 1; columnIndex <= numColumns; columnIndex++) {\n+        String columnName = h2MetaData.getColumnName(columnIndex);\n+\n+        // Handle null result and convert boolean value to lower case\n+        String columnValue = h2ResultSet.getString(columnIndex);\n+        if (columnValue == null) {\n+          columnValue = \"null\";\n+        } else {\n+          columnValue = convertBooleanToLowerCase(columnValue);\n+        }\n+\n+        // Handle multi-value columns\n+        int length = columnName.length();\n+        if (length > 5 && columnName.substring(length - 5, length - 1).equals(\"__MV\")) {\n+          // Multi-value column\n+          String multiValueColumnName = columnName.substring(0, length - 5);\n+          List<String> multiValue = reusableMultiValuesMap.get(multiValueColumnName);\n+          if (multiValue == null) {\n+            multiValue = new ArrayList<>();\n+            reusableMultiValuesMap.put(multiValueColumnName, multiValue);\n+            reusableColumnOrder.add(multiValueColumnName);\n+          }\n+          multiValue.add(columnValue);\n+        } else {\n+          // Single-value column\n+          String columnDataType = h2MetaData.getColumnTypeName(columnIndex);\n+          columnValue = removeTrailingZeroForNumber(columnValue, columnDataType);\n+          reusableExpectedValueMap.put(columnName, columnValue);\n+          reusableColumnOrder.add(columnName);\n+        }\n+      }\n+\n+      // Add multi-value column results to the expected values\n+      // The reason for this step is that Pinot does not maintain order of elements in multi-value columns\n+      for (Map.Entry<String, List<String>> entry : reusableMultiValuesMap.entrySet()) {\n+        List<String> multiValue = entry.getValue();\n+        Collections.sort(multiValue);\n+        reusableExpectedValueMap.put(entry.getKey(), multiValue.toString());\n+      }\n+\n+      // Build expected value String\n+      StringBuilder expectedValue = new StringBuilder();\n+      StringBuilder expectedOrderByValue = new StringBuilder();\n+      for (String column : reusableColumnOrder) {\n+        expectedValue.append(reusableExpectedValueMap.get(column)).append(' ');\n+        if (orderByColumns.contains(column)) {\n+          expectedOrderByValue.append(reusableExpectedValueMap.get(column)).append(' ');\n+        }\n+      }\n+      expectedValues.add(expectedValue.toString());\n+      expectedOrderByValues.add(expectedOrderByValue.toString());\n+    }\n+\n+    return h2NumRows;\n+  }\n+\n+  private static void comparePinotResultsWithExpectedValues(Set<String> expectedValues, List<String> expectedOrderByValues,\n+      org.apache.pinot.client.ResultSet connectionResultSet, Set<String> orderByColumns, String pinotQuery, List<String> sqlQueries,\n+      int h2NumRows, long pinotNumRecordsSelected) throws IOException, SQLException {\n+\n+    int pinotNumRows = connectionResultSet.getRowCount();\n+    // No record selected in H2\n+    if (h2NumRows== 0) {\n+      if (pinotNumRows != 0) {\n+        String failureMessage = \"No record selected in H2 but number of records selected in Pinot: \" + pinotNumRows;\n+        failure(pinotQuery, sqlQueries, failureMessage);\n+        return;\n+      }\n+\n+      if (pinotNumRecordsSelected != 0) {\n+        String failureMessage =\n+            \"No selection result returned in Pinot but number of records selected: \" + pinotNumRecordsSelected;\n+        failure(pinotQuery, sqlQueries, failureMessage);\n+        return;\n+      }\n+\n+      // Skip further comparison\n+      return;\n+    }\n+\n+    PinotQuery compiledQuery = CalciteSqlParser.compileToPinotQuery(pinotQuery);\n+    boolean isLimitSet = compiledQuery.isSetLimit();\n+    int limit = compiledQuery.getLimit();\n+\n+    // Only compare exhausted results\n+    if (h2NumRows < MAX_NUM_ROWS_TO_COMPARE) {\n+\n+      for (int rowIndex = 0; rowIndex < pinotNumRows; rowIndex++) {\n+        // Build actual value String.\n+        StringBuilder actualValueBuilder = new StringBuilder();\n+        StringBuilder actualOrderByValueBuilder = new StringBuilder();\n+        for (int columnIndex = 0; columnIndex < connectionResultSet.getColumnCount(); columnIndex++) {\n+          // Convert column name to all uppercase to make it compatible with H2\n+          String columnName = connectionResultSet.getColumnName(columnIndex).toUpperCase();\n+          String columnResult = connectionResultSet.getString(rowIndex, columnIndex);\n+\n+          String columnDataType = connectionResultSet.getColumnDataType(columnIndex);\n+          columnResult = removeTrailingZeroForNumber(columnResult, columnDataType);\n+          // TODO: Find a better way to identify multi-value column\n+          if (columnResult.charAt(0) == '[') {\n+            // Multi-value column\n+            JsonNode columnValues = JsonUtils.stringToJsonNode(columnResult);\n+            List<String> multiValue = new ArrayList<>();\n+            int length = columnValues.size();\n+            for (int elementIndex = 0; elementIndex < length; elementIndex++) {\n+              multiValue.add(columnValues.get(elementIndex).asText());\n+            }\n+            for (int elementIndex = length; elementIndex < MAX_NUM_ELEMENTS_IN_MULTI_VALUE_TO_COMPARE; elementIndex++) {\n+              multiValue.add(\"null\");\n+            }\n+            Collections.sort(multiValue);\n+            actualValueBuilder.append(multiValue.toString()).append(' ');\n+            if (orderByColumns.contains(columnName)) {\n+              actualOrderByValueBuilder.append(columnResult).append(' ');\n+            }\n+          } else {\n+            // Single-value column\n+            actualValueBuilder.append(columnResult).append(' ');\n+            if (orderByColumns.contains(columnName)) {\n+              actualOrderByValueBuilder.append(columnResult).append(' ');\n+            }\n+          }\n+        }\n+\n+        String actualValue = actualValueBuilder.toString();\n+        String actualOrderByValue = actualOrderByValueBuilder.toString();\n+        // Check actual value in expected values set, skip comparison if query response is truncated by limit\n+        if ((!isLimitSet || limit > h2NumRows) && !expectedValues.contains(actualValue)) {\n+          String failureMessage = \"Selection result returned in Pinot but not in H2: \" + actualValue + \", \" + expectedValues;\n+          failure(pinotQuery, sqlQueries, failureMessage);\n+          return;\n+        }\n+        if (!orderByColumns.isEmpty()) {\n+          // Check actual group value is the same as expected group value in the same order.\n+          if (!expectedOrderByValues.get(rowIndex).equals(actualOrderByValue)) {\n+            String failureMessage = String.format(\n+                \"Selection Order by result at row index: %d in Pinot: [ %s ] is different than result in H2: [ %s ].\",\n+                rowIndex, actualOrderByValue, expectedOrderByValues.get(rowIndex));\n+            failure(pinotQuery, sqlQueries, failureMessage);\n+            return;\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private static String removeTrailingZeroForNumber(String value, String type) {\n+    // remove trailing zero after decimal point to compare decimal numbers\n+    if (type == null || type.toUpperCase().equals(\"FLOAT\") || type.toUpperCase().equals(\"DOUBLE\") || type.toUpperCase().equals(\"BIGINT\")) {\n+      // remove trailing zero after decimal point to be consistent with h2 data\n+      if (value.endsWith(\".0\")) {\n+        return value.substring(0, value.length() - 2);\n+      }\n+    }\n+    return value;\n+  }\n+\n+  private static List<String> appendColumnsToSelectionRequests(Set<String> columns, List<String> requests) {", "originalCommit": "aab1cfaabd184e011cf23d8f88bee5fdc466f3b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1fe905b1430d3d18e6197372670291dd69be137f", "url": "https://github.com/apache/pinot/commit/1fe905b1430d3d18e6197372670291dd69be137f", "message": "Improve comparison coverage for selection SQL queries in ClusterIntegrationTestUtils(#6193)", "committedDate": "2020-11-04T23:40:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwMjU2Ng==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r518302566", "bodyText": "Can we rename this to testPqlQuery()?", "author": "snleee", "createdAt": "2020-11-05T19:19:29Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/ClusterIntegrationTestUtils.java", "diffHunk": "@@ -463,21 +466,20 @@ private static Object generateRandomValue(Schema.Type fieldType) {\n    * </ul>\n    *\n    * @param pinotQuery Pinot query\n-   * @param queryFormat Pinot query format\n    * @param brokerUrl Pinot broker URL\n    * @param pinotConnection Pinot connection\n    * @param sqlQueries H2 SQL queries\n    * @param h2Connection H2 connection\n    * @throws Exception\n    */\n-  public static void testQuery(String pinotQuery, String queryFormat, String brokerUrl,\n+  public static void testQuery(String pinotQuery, String brokerUrl,", "originalCommit": "1fe905b1430d3d18e6197372670291dd69be137f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4NzIzNw==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r520187237", "bodyText": "+1 on that", "author": "jackjlli", "createdAt": "2020-11-09T23:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwMjU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4Nzc4NQ==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r520187785", "bodyText": "Use CommonConstants.Broker.Request.PQL here?", "author": "jackjlli", "createdAt": "2020-11-09T23:31:56Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/ClusterIntegrationTestUtils.java", "diffHunk": "@@ -463,21 +466,20 @@ private static Object generateRandomValue(Schema.Type fieldType) {\n    * </ul>\n    *\n    * @param pinotQuery Pinot query\n-   * @param queryFormat Pinot query format\n    * @param brokerUrl Pinot broker URL\n    * @param pinotConnection Pinot connection\n    * @param sqlQueries H2 SQL queries\n    * @param h2Connection H2 connection\n    * @throws Exception\n    */\n-  public static void testQuery(String pinotQuery, String queryFormat, String brokerUrl,\n+  public static void testQuery(String pinotQuery, String brokerUrl,\n       org.apache.pinot.client.Connection pinotConnection, @Nullable List<String> sqlQueries,\n       @Nullable Connection h2Connection)\n       throws Exception {\n     // Use broker response for metadata check, connection response for value check\n-    PinotQueryRequest pinotBrokerQueryRequest = new PinotQueryRequest(queryFormat, pinotQuery);\n+    PinotQueryRequest pinotBrokerQueryRequest = new PinotQueryRequest(\"pql\", pinotQuery);", "originalCommit": "1fe905b1430d3d18e6197372670291dd69be137f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4OTgyNg==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r520189826", "bodyText": "If the values of lastName is exhausted, we can still verify the values, right?", "author": "jackjlli", "createdAt": "2020-11-09T23:37:20Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/ClusterIntegrationTestUtils.java", "diffHunk": "@@ -833,6 +700,33 @@ static void testSqlQuery(String pinotQuery, String brokerUrl, org.apache.pinot.c\n       return;\n     }\n \n+    BrokerRequest brokerRequest =\n+        PinotQueryParserFactory.get(CommonConstants.Broker.Request.SQL).compileToBrokerRequest(pinotQuery);\n+    // Add order by columns which are not in selection clause for comparison purpose\n+    List<String> orderByColumns = new ArrayList<>();\n+    List<String> selectionColumns = new ArrayList<>();\n+    if (isSelectionQuery(brokerRequest) && brokerRequest.getOrderBy() != null && brokerRequest.getOrderBy().size() > 0) {\n+      orderByColumns.addAll(CalciteSqlParser.extractIdentifiers(brokerRequest.getPinotQuery().getOrderByList(), false));\n+      selectionColumns.addAll(CalciteSqlParser.extractIdentifiers(brokerRequest.getPinotQuery().getSelectList(), false));\n+      convertToUpperCase(orderByColumns);\n+      convertToUpperCase(selectionColumns);\n+\n+      if (!selectionColumns.containsAll(orderByColumns)) {\n+        List<String> inputRequests = new ArrayList<>();\n+        inputRequests.add(pinotQuery);\n+        inputRequests.addAll(sqlQueries);\n+\n+        Set<String> orderByColumnsExcluded = new HashSet<>(orderByColumns);\n+        orderByColumnsExcluded.removeAll(selectionColumns);\n+\n+        // Append order-by columns not in selection clause so the order of query responses can be verified\n+        // e.g. we can't verify the order of query `SELECT firstName FROM mytable ORDER BY lastName' if there are duplicate lastNames", "originalCommit": "1fe905b1430d3d18e6197372670291dd69be137f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc3MzcxMw==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r520773713", "bodyText": "Yes, the values are checked. Adding the order-by columns will help to verify the order, the values are still checked by comparing hashed row records.", "author": "jtao15", "createdAt": "2020-11-10T18:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4OTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwOTc5MQ==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r521609791", "bodyText": "Can you post the sample query that you are trying to solve from order-by clause append?\nIMO, the queries from the sample set should have a deterministic result instead of implicitly manipulating the order by clause here.\nWe cannot do the result comparison check if the query result by definition can be changed (e.g. selection with no order by)", "author": "snleee", "createdAt": "2020-11-11T20:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4OTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2MzQ2MQ==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r521663461", "bodyText": "I think the problem here is whether we want to check the returned order of selection queries which order-by columns are not in selection clause. We skipped comparison for this case for previous sql comparison, and current pql logic will not verify the order but only compare values. So without the order-by clause append, the sql comparison will be consistent with current pql logic, and all test cases should pass.", "author": "jtao15", "createdAt": "2020-11-11T21:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4OTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcwMjQyMg==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r521702422", "bodyText": "I'll remove this to be consistent with pql comparison, the values are still being checked.", "author": "jtao15", "createdAt": "2020-11-11T23:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4OTgyNg=="}], "type": "inlineReview"}, {"oid": "40c9a470b644b63ec7da44416c55dd6fa8ddba8f", "url": "https://github.com/apache/pinot/commit/40c9a470b644b63ec7da44416c55dd6fa8ddba8f", "message": "Improve comparison coverage for selection SQL queries in ClusterIntegrationTestUtils(#6193)", "committedDate": "2020-11-10T18:24:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5MDc3OQ==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r521590779", "bodyText": "What does this 5 means?", "author": "snleee", "createdAt": "2020-11-11T19:32:34Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/ClusterIntegrationTestUtils.java", "diffHunk": "@@ -975,6 +831,197 @@ private static boolean isSelectionQuery(BrokerRequest brokerRequest) {\n     return false;\n   }\n \n+  private static void convertToUpperCase(List<String> columns) {\n+    for (int i = 0; i < columns.size(); i++) {\n+      columns.set(i, columns.get(i).toUpperCase());\n+    }\n+  }\n+\n+  private static int getH2ExpectedValues(Set<String> expectedValues, List<String> expectedOrderByValues,\n+      ResultSet h2ResultSet, ResultSetMetaData h2MetaData, Collection<String> orderByColumns) throws SQLException {\n+    Map<String, String> reusableExpectedValueMap = new HashMap<>();\n+    Map<String, List<String>> reusableMultiValuesMap = new HashMap<>();\n+    List<String> reusableColumnOrder = new ArrayList<>();\n+    int h2NumRows;\n+    int numColumns = h2MetaData.getColumnCount();\n+\n+    for (h2NumRows = 0; h2ResultSet.next() && h2NumRows < MAX_NUM_ROWS_TO_COMPARE; h2NumRows++) {\n+      reusableExpectedValueMap.clear();\n+      reusableMultiValuesMap.clear();\n+      reusableColumnOrder.clear();\n+\n+      for (int columnIndex = 1; columnIndex <= numColumns; columnIndex++) { // h2 result set is 1-based\n+        String columnName = h2MetaData.getColumnName(columnIndex);\n+\n+        // Handle null result and convert boolean value to lower case\n+        String columnValue = h2ResultSet.getString(columnIndex);\n+        if (columnValue == null) {\n+          columnValue = \"null\";\n+        } else {\n+          columnValue = convertBooleanToLowerCase(columnValue);\n+        }\n+\n+        // Handle multi-value columns\n+        int length = columnName.length();\n+        if (length > 5 && columnName.substring(length - 5, length - 1).equals(\"__MV\")) {", "originalCommit": "40c9a470b644b63ec7da44416c55dd6fa8ddba8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY2Nzc4Ng==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r521667786", "bodyText": "5 here is the length of h2 muti-value column suffix. A typical h2 multi-value column name will be 'NAME__MV0'. Maybe it's better to change it as a constant instead of number.", "author": "jtao15", "createdAt": "2020-11-11T22:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5MDc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY4Mzg5MQ==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r521683891", "bodyText": "let's use the constant", "author": "snleee", "createdAt": "2020-11-11T22:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5MDc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5ODU0OA==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r521598548", "bodyText": "If you check the connectionResultSet.getString(), we are essentially converting JsonNode to string. We can read the string back to json node and figure out whether it's array or not.", "author": "snleee", "createdAt": "2020-11-11T19:47:40Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/ClusterIntegrationTestUtils.java", "diffHunk": "@@ -975,6 +831,197 @@ private static boolean isSelectionQuery(BrokerRequest brokerRequest) {\n     return false;\n   }\n \n+  private static void convertToUpperCase(List<String> columns) {\n+    for (int i = 0; i < columns.size(); i++) {\n+      columns.set(i, columns.get(i).toUpperCase());\n+    }\n+  }\n+\n+  private static int getH2ExpectedValues(Set<String> expectedValues, List<String> expectedOrderByValues,\n+      ResultSet h2ResultSet, ResultSetMetaData h2MetaData, Collection<String> orderByColumns) throws SQLException {\n+    Map<String, String> reusableExpectedValueMap = new HashMap<>();\n+    Map<String, List<String>> reusableMultiValuesMap = new HashMap<>();\n+    List<String> reusableColumnOrder = new ArrayList<>();\n+    int h2NumRows;\n+    int numColumns = h2MetaData.getColumnCount();\n+\n+    for (h2NumRows = 0; h2ResultSet.next() && h2NumRows < MAX_NUM_ROWS_TO_COMPARE; h2NumRows++) {\n+      reusableExpectedValueMap.clear();\n+      reusableMultiValuesMap.clear();\n+      reusableColumnOrder.clear();\n+\n+      for (int columnIndex = 1; columnIndex <= numColumns; columnIndex++) { // h2 result set is 1-based\n+        String columnName = h2MetaData.getColumnName(columnIndex);\n+\n+        // Handle null result and convert boolean value to lower case\n+        String columnValue = h2ResultSet.getString(columnIndex);\n+        if (columnValue == null) {\n+          columnValue = \"null\";\n+        } else {\n+          columnValue = convertBooleanToLowerCase(columnValue);\n+        }\n+\n+        // Handle multi-value columns\n+        int length = columnName.length();\n+        if (length > 5 && columnName.substring(length - 5, length - 1).equals(\"__MV\")) {\n+          // Multi-value column\n+          String multiValueColumnName = columnName.substring(0, length - 5);\n+          List<String> multiValue = reusableMultiValuesMap.get(multiValueColumnName);\n+          if (multiValue == null) {\n+            multiValue = new ArrayList<>();\n+            reusableMultiValuesMap.put(multiValueColumnName, multiValue);\n+            reusableColumnOrder.add(multiValueColumnName);\n+          }\n+          multiValue.add(columnValue);\n+        } else {\n+          // Single-value column\n+          String columnDataType = h2MetaData.getColumnTypeName(columnIndex);\n+          columnValue = removeTrailingZeroForNumber(columnValue, columnDataType);\n+          reusableExpectedValueMap.put(columnName, columnValue);\n+          reusableColumnOrder.add(columnName);\n+        }\n+      }\n+\n+      // Add multi-value column results to the expected values\n+      // The reason for this step is that Pinot does not maintain order of elements in multi-value columns\n+      for (Map.Entry<String, List<String>> entry : reusableMultiValuesMap.entrySet()) {\n+        List<String> multiValue = entry.getValue();\n+        Collections.sort(multiValue);\n+        reusableExpectedValueMap.put(entry.getKey(), multiValue.toString());\n+      }\n+\n+      // Build expected value String\n+      StringBuilder expectedValue = new StringBuilder();\n+      StringBuilder expectedOrderByValue = new StringBuilder();\n+      for (String column : reusableColumnOrder) {\n+        expectedValue.append(reusableExpectedValueMap.get(column)).append(' ');\n+        if (orderByColumns.contains(column)) {\n+          expectedOrderByValue.append(reusableExpectedValueMap.get(column)).append(' ');\n+        }\n+      }\n+      expectedValues.add(expectedValue.toString());\n+      expectedOrderByValues.add(expectedOrderByValue.toString());\n+    }\n+\n+    return h2NumRows;\n+  }\n+\n+  private static void comparePinotResultsWithExpectedValues(Set<String> expectedValues, List<String> expectedOrderByValues,\n+      org.apache.pinot.client.ResultSet connectionResultSet, Collection<String> orderByColumns, String pinotQuery, List<String> sqlQueries,\n+      int h2NumRows, long pinotNumRecordsSelected) throws IOException, SQLException {\n+\n+    int pinotNumRows = connectionResultSet.getRowCount();\n+    // No record selected in H2\n+    if (h2NumRows== 0) {\n+      if (pinotNumRows != 0) {\n+        String failureMessage = \"No record selected in H2 but number of records selected in Pinot: \" + pinotNumRows;\n+        failure(pinotQuery, sqlQueries, failureMessage);\n+        return;\n+      }\n+\n+      if (pinotNumRecordsSelected != 0) {\n+        String failureMessage =\n+            \"No selection result returned in Pinot but number of records selected: \" + pinotNumRecordsSelected;\n+        failure(pinotQuery, sqlQueries, failureMessage);\n+        return;\n+      }\n+\n+      // Skip further comparison\n+      return;\n+    }\n+\n+    PinotQuery compiledQuery = CalciteSqlParser.compileToPinotQuery(pinotQuery);\n+    boolean isLimitSet = compiledQuery.isSetLimit();\n+    int limit = compiledQuery.getLimit();\n+\n+    // Only compare exhausted results\n+    if (h2NumRows < MAX_NUM_ROWS_TO_COMPARE) {\n+\n+      for (int rowIndex = 0; rowIndex < pinotNumRows; rowIndex++) {\n+        // Build actual value String.\n+        StringBuilder actualValueBuilder = new StringBuilder();\n+        StringBuilder actualOrderByValueBuilder = new StringBuilder();\n+        for (int columnIndex = 0; columnIndex < connectionResultSet.getColumnCount(); columnIndex++) {\n+          // Convert column name to all uppercase to make it compatible with H2\n+          String columnName = connectionResultSet.getColumnName(columnIndex).toUpperCase();\n+          String columnResult = connectionResultSet.getString(rowIndex, columnIndex);\n+\n+          String columnDataType = connectionResultSet.getColumnDataType(columnIndex);\n+          columnResult = removeTrailingZeroForNumber(columnResult, columnDataType);\n+          // TODO: Find a better way to identify multi-value column\n+          if (columnResult.charAt(0) == '[') {", "originalCommit": "40c9a470b644b63ec7da44416c55dd6fa8ddba8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwNjgwNQ==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r521606805", "bodyText": "So, this won't work for some cases.\nYou will need to double check DataTableReducer implementations and check how we format double/float to string.\nFor instance, SelectionDataTableReducer uses SelectionOperatorUtils.renderSelectionResultsWithoutOrdering() and this is probably causing x.0 for your case.\nOn the other hand, if you check AggregationDataTableReducer, we use AggregationFunctionUtils.formatValue(), which will convert the decimals to x.00000\nSo, I think that the better approach is to use the regex like the following:\nFind the position where\n1. start with '.'\n2. any number of {0}\n3. end with '0'", "author": "snleee", "createdAt": "2020-11-11T20:03:26Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/ClusterIntegrationTestUtils.java", "diffHunk": "@@ -975,6 +831,197 @@ private static boolean isSelectionQuery(BrokerRequest brokerRequest) {\n     return false;\n   }\n \n+  private static void convertToUpperCase(List<String> columns) {\n+    for (int i = 0; i < columns.size(); i++) {\n+      columns.set(i, columns.get(i).toUpperCase());\n+    }\n+  }\n+\n+  private static int getH2ExpectedValues(Set<String> expectedValues, List<String> expectedOrderByValues,\n+      ResultSet h2ResultSet, ResultSetMetaData h2MetaData, Collection<String> orderByColumns) throws SQLException {\n+    Map<String, String> reusableExpectedValueMap = new HashMap<>();\n+    Map<String, List<String>> reusableMultiValuesMap = new HashMap<>();\n+    List<String> reusableColumnOrder = new ArrayList<>();\n+    int h2NumRows;\n+    int numColumns = h2MetaData.getColumnCount();\n+\n+    for (h2NumRows = 0; h2ResultSet.next() && h2NumRows < MAX_NUM_ROWS_TO_COMPARE; h2NumRows++) {\n+      reusableExpectedValueMap.clear();\n+      reusableMultiValuesMap.clear();\n+      reusableColumnOrder.clear();\n+\n+      for (int columnIndex = 1; columnIndex <= numColumns; columnIndex++) { // h2 result set is 1-based\n+        String columnName = h2MetaData.getColumnName(columnIndex);\n+\n+        // Handle null result and convert boolean value to lower case\n+        String columnValue = h2ResultSet.getString(columnIndex);\n+        if (columnValue == null) {\n+          columnValue = \"null\";\n+        } else {\n+          columnValue = convertBooleanToLowerCase(columnValue);\n+        }\n+\n+        // Handle multi-value columns\n+        int length = columnName.length();\n+        if (length > 5 && columnName.substring(length - 5, length - 1).equals(\"__MV\")) {\n+          // Multi-value column\n+          String multiValueColumnName = columnName.substring(0, length - 5);\n+          List<String> multiValue = reusableMultiValuesMap.get(multiValueColumnName);\n+          if (multiValue == null) {\n+            multiValue = new ArrayList<>();\n+            reusableMultiValuesMap.put(multiValueColumnName, multiValue);\n+            reusableColumnOrder.add(multiValueColumnName);\n+          }\n+          multiValue.add(columnValue);\n+        } else {\n+          // Single-value column\n+          String columnDataType = h2MetaData.getColumnTypeName(columnIndex);\n+          columnValue = removeTrailingZeroForNumber(columnValue, columnDataType);\n+          reusableExpectedValueMap.put(columnName, columnValue);\n+          reusableColumnOrder.add(columnName);\n+        }\n+      }\n+\n+      // Add multi-value column results to the expected values\n+      // The reason for this step is that Pinot does not maintain order of elements in multi-value columns\n+      for (Map.Entry<String, List<String>> entry : reusableMultiValuesMap.entrySet()) {\n+        List<String> multiValue = entry.getValue();\n+        Collections.sort(multiValue);\n+        reusableExpectedValueMap.put(entry.getKey(), multiValue.toString());\n+      }\n+\n+      // Build expected value String\n+      StringBuilder expectedValue = new StringBuilder();\n+      StringBuilder expectedOrderByValue = new StringBuilder();\n+      for (String column : reusableColumnOrder) {\n+        expectedValue.append(reusableExpectedValueMap.get(column)).append(' ');\n+        if (orderByColumns.contains(column)) {\n+          expectedOrderByValue.append(reusableExpectedValueMap.get(column)).append(' ');\n+        }\n+      }\n+      expectedValues.add(expectedValue.toString());\n+      expectedOrderByValues.add(expectedOrderByValue.toString());\n+    }\n+\n+    return h2NumRows;\n+  }\n+\n+  private static void comparePinotResultsWithExpectedValues(Set<String> expectedValues, List<String> expectedOrderByValues,\n+      org.apache.pinot.client.ResultSet connectionResultSet, Collection<String> orderByColumns, String pinotQuery, List<String> sqlQueries,\n+      int h2NumRows, long pinotNumRecordsSelected) throws IOException, SQLException {\n+\n+    int pinotNumRows = connectionResultSet.getRowCount();\n+    // No record selected in H2\n+    if (h2NumRows== 0) {\n+      if (pinotNumRows != 0) {\n+        String failureMessage = \"No record selected in H2 but number of records selected in Pinot: \" + pinotNumRows;\n+        failure(pinotQuery, sqlQueries, failureMessage);\n+        return;\n+      }\n+\n+      if (pinotNumRecordsSelected != 0) {\n+        String failureMessage =\n+            \"No selection result returned in Pinot but number of records selected: \" + pinotNumRecordsSelected;\n+        failure(pinotQuery, sqlQueries, failureMessage);\n+        return;\n+      }\n+\n+      // Skip further comparison\n+      return;\n+    }\n+\n+    PinotQuery compiledQuery = CalciteSqlParser.compileToPinotQuery(pinotQuery);\n+    boolean isLimitSet = compiledQuery.isSetLimit();\n+    int limit = compiledQuery.getLimit();\n+\n+    // Only compare exhausted results\n+    if (h2NumRows < MAX_NUM_ROWS_TO_COMPARE) {\n+\n+      for (int rowIndex = 0; rowIndex < pinotNumRows; rowIndex++) {\n+        // Build actual value String.\n+        StringBuilder actualValueBuilder = new StringBuilder();\n+        StringBuilder actualOrderByValueBuilder = new StringBuilder();\n+        for (int columnIndex = 0; columnIndex < connectionResultSet.getColumnCount(); columnIndex++) {\n+          // Convert column name to all uppercase to make it compatible with H2\n+          String columnName = connectionResultSet.getColumnName(columnIndex).toUpperCase();\n+          String columnResult = connectionResultSet.getString(rowIndex, columnIndex);\n+\n+          String columnDataType = connectionResultSet.getColumnDataType(columnIndex);\n+          columnResult = removeTrailingZeroForNumber(columnResult, columnDataType);\n+          // TODO: Find a better way to identify multi-value column\n+          if (columnResult.charAt(0) == '[') {\n+            // Multi-value column\n+            JsonNode columnValues = JsonUtils.stringToJsonNode(columnResult);\n+            List<String> multiValue = new ArrayList<>();\n+            int length = columnValues.size();\n+            for (int elementIndex = 0; elementIndex < length; elementIndex++) {\n+              multiValue.add(columnValues.get(elementIndex).asText());\n+            }\n+            for (int elementIndex = length; elementIndex < MAX_NUM_ELEMENTS_IN_MULTI_VALUE_TO_COMPARE; elementIndex++) {\n+              multiValue.add(\"null\");\n+            }\n+            Collections.sort(multiValue);\n+            actualValueBuilder.append(multiValue.toString()).append(' ');\n+            if (orderByColumns.contains(columnName)) {\n+              actualOrderByValueBuilder.append(columnResult).append(' ');\n+            }\n+          } else {\n+            // Single-value column\n+            actualValueBuilder.append(columnResult).append(' ');\n+            if (orderByColumns.contains(columnName)) {\n+              actualOrderByValueBuilder.append(columnResult).append(' ');\n+            }\n+          }\n+        }\n+\n+        String actualValue = actualValueBuilder.toString();\n+        String actualOrderByValue = actualOrderByValueBuilder.toString();\n+        // Check actual value in expected values set, skip comparison if query response is truncated by limit\n+        if ((!isLimitSet || limit > h2NumRows) && !expectedValues.contains(actualValue)) {\n+          String failureMessage = \"Selection result returned in Pinot but not in H2: \" + actualValue + \", \" + expectedValues;\n+          failure(pinotQuery, sqlQueries, failureMessage);\n+          return;\n+        }\n+        if (!orderByColumns.isEmpty()) {\n+          // Check actual group value is the same as expected group value in the same order.\n+          if (!expectedOrderByValues.get(rowIndex).equals(actualOrderByValue)) {\n+            String failureMessage = String.format(\n+                \"Selection Order by result at row index: %d in Pinot: [ %s ] is different than result in H2: [ %s ].\",\n+                rowIndex, actualOrderByValue, expectedOrderByValues.get(rowIndex));\n+            failure(pinotQuery, sqlQueries, failureMessage);\n+            return;\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private static String removeTrailingZeroForNumber(String value, String type) {\n+    // remove trailing zero after decimal point to compare decimal numbers\n+    if (type == null || type.toUpperCase().equals(\"FLOAT\") || type.toUpperCase().equals(\"DOUBLE\") || type.toUpperCase().equals(\"BIGINT\")) {\n+      // remove trailing zero after decimal point to be consistent with h2 data\n+      if (value.endsWith(\".0\")) {", "originalCommit": "40c9a470b644b63ec7da44416c55dd6fa8ddba8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d6dcc8dec1c7f3a7495fe0cc3ea0c7390522f4be", "url": "https://github.com/apache/pinot/commit/d6dcc8dec1c7f3a7495fe0cc3ea0c7390522f4be", "message": "Improve comparison coverage for selection SQL queries in ClusterIntegrationTestUtils(#6193)\nAdd some selection queries without order-by to test_queries_500.sql for testing.", "committedDate": "2020-11-12T00:48:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxOTUxNA==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r522519514", "bodyText": "We can parse JsonNode once when computing isMultiValueColumn and reuse it. Your code parses JSON 2 times.", "author": "snleee", "createdAt": "2020-11-13T00:07:11Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/ClusterIntegrationTestUtils.java", "diffHunk": "@@ -975,6 +814,203 @@ private static boolean isSelectionQuery(BrokerRequest brokerRequest) {\n     return false;\n   }\n \n+  private static void convertToUpperCase(List<String> columns) {\n+    for (int i = 0; i < columns.size(); i++) {\n+      columns.set(i, columns.get(i).toUpperCase());\n+    }\n+  }\n+\n+  private static int getH2ExpectedValues(Set<String> expectedValues, List<String> expectedOrderByValues,\n+      ResultSet h2ResultSet, ResultSetMetaData h2MetaData, Collection<String> orderByColumns) throws SQLException {\n+    Map<String, String> reusableExpectedValueMap = new HashMap<>();\n+    Map<String, List<String>> reusableMultiValuesMap = new HashMap<>();\n+    List<String> reusableColumnOrder = new ArrayList<>();\n+    int h2NumRows;\n+    int numColumns = h2MetaData.getColumnCount();\n+\n+    for (h2NumRows = 0; h2ResultSet.next() && h2NumRows < MAX_NUM_ROWS_TO_COMPARE; h2NumRows++) {\n+      reusableExpectedValueMap.clear();\n+      reusableMultiValuesMap.clear();\n+      reusableColumnOrder.clear();\n+\n+      for (int columnIndex = 1; columnIndex <= numColumns; columnIndex++) { // h2 result set is 1-based\n+        String columnName = h2MetaData.getColumnName(columnIndex);\n+\n+        // Handle null result and convert boolean value to lower case\n+        String columnValue = h2ResultSet.getString(columnIndex);\n+        if (columnValue == null) {\n+          columnValue = \"null\";\n+        } else {\n+          columnValue = convertBooleanToLowerCase(columnValue);\n+        }\n+\n+        // Handle multi-value columns\n+        int length = columnName.length();\n+        if (length > H2_MULTI_VALUE_SUFFIX_LENGTH && columnName.substring(length - H2_MULTI_VALUE_SUFFIX_LENGTH, length - 1).equals(\"__MV\")) {\n+          // Multi-value column\n+          String multiValueColumnName = columnName.substring(0, length - H2_MULTI_VALUE_SUFFIX_LENGTH);\n+          List<String> multiValue = reusableMultiValuesMap.get(multiValueColumnName);\n+          if (multiValue == null) {\n+            multiValue = new ArrayList<>();\n+            reusableMultiValuesMap.put(multiValueColumnName, multiValue);\n+            reusableColumnOrder.add(multiValueColumnName);\n+          }\n+          multiValue.add(columnValue);\n+        } else {\n+          // Single-value column\n+          String columnDataType = h2MetaData.getColumnTypeName(columnIndex);\n+          columnValue = removeTrailingZeroForNumber(columnValue, columnDataType);\n+          reusableExpectedValueMap.put(columnName, columnValue);\n+          reusableColumnOrder.add(columnName);\n+        }\n+      }\n+\n+      // Add multi-value column results to the expected values\n+      // The reason for this step is that Pinot does not maintain order of elements in multi-value columns\n+      for (Map.Entry<String, List<String>> entry : reusableMultiValuesMap.entrySet()) {\n+        List<String> multiValue = entry.getValue();\n+        Collections.sort(multiValue);\n+        reusableExpectedValueMap.put(entry.getKey(), multiValue.toString());\n+      }\n+\n+      // Build expected value String\n+      StringBuilder expectedValue = new StringBuilder();\n+      StringBuilder expectedOrderByValue = new StringBuilder();\n+      for (String column : reusableColumnOrder) {\n+        expectedValue.append(reusableExpectedValueMap.get(column)).append(' ');\n+        if (orderByColumns.contains(column)) {\n+          expectedOrderByValue.append(reusableExpectedValueMap.get(column)).append(' ');\n+        }\n+      }\n+      expectedValues.add(expectedValue.toString());\n+      expectedOrderByValues.add(expectedOrderByValue.toString());\n+    }\n+\n+    return h2NumRows;\n+  }\n+\n+  private static void comparePinotResultsWithExpectedValues(Set<String> expectedValues, List<String> expectedOrderByValues,\n+      org.apache.pinot.client.ResultSet connectionResultSet, Collection<String> orderByColumns, String pinotQuery, List<String> sqlQueries,\n+      int h2NumRows, long pinotNumRecordsSelected) throws IOException, SQLException {\n+\n+    int pinotNumRows = connectionResultSet.getRowCount();\n+    // No record selected in H2\n+    if (h2NumRows== 0) {\n+      if (pinotNumRows != 0) {\n+        String failureMessage = \"No record selected in H2 but number of records selected in Pinot: \" + pinotNumRows;\n+        failure(pinotQuery, sqlQueries, failureMessage);\n+        return;\n+      }\n+\n+      if (pinotNumRecordsSelected != 0) {\n+        String failureMessage =\n+            \"No selection result returned in Pinot but number of records selected: \" + pinotNumRecordsSelected;\n+        failure(pinotQuery, sqlQueries, failureMessage);\n+        return;\n+      }\n+\n+      // Skip further comparison\n+      return;\n+    }\n+\n+    PinotQuery compiledQuery = CalciteSqlParser.compileToPinotQuery(pinotQuery);\n+    boolean isLimitSet = compiledQuery.isSetLimit();\n+    int limit = compiledQuery.getLimit();\n+\n+    // Only compare exhausted results\n+    if (h2NumRows < MAX_NUM_ROWS_TO_COMPARE) {\n+\n+      for (int rowIndex = 0; rowIndex < pinotNumRows; rowIndex++) {\n+        // Build actual value String.\n+        StringBuilder actualValueBuilder = new StringBuilder();\n+        StringBuilder actualOrderByValueBuilder = new StringBuilder();\n+        for (int columnIndex = 0; columnIndex < connectionResultSet.getColumnCount(); columnIndex++) {\n+          // Convert column name to all uppercase to make it compatible with H2\n+          String columnName = connectionResultSet.getColumnName(columnIndex).toUpperCase();\n+          String columnResult = connectionResultSet.getString(rowIndex, columnIndex);\n+\n+          String columnDataType = connectionResultSet.getColumnDataType(columnIndex);\n+          columnResult = removeTrailingZeroForNumber(columnResult, columnDataType);\n+\n+          boolean isMultiValueColumn = false;\n+          try {\n+             isMultiValueColumn = JsonUtils.stringToJsonNode(columnResult).isArray();\n+          } catch (IOException e) {\n+          }\n+\n+          if (isMultiValueColumn) {\n+            // Multi-value column\n+            JsonNode columnValues = JsonUtils.stringToJsonNode(columnResult);", "originalCommit": "d6dcc8dec1c7f3a7495fe0cc3ea0c7390522f4be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxOTU4MA==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r522519580", "bodyText": "add extra line in the end", "author": "snleee", "createdAt": "2020-11-13T00:07:27Z", "path": "pinot-integration-tests/src/test/resources/On_Time_On_Time_Performance_2014_100k_subset.test_queries_500.sql", "diffHunk": "@@ -555,3 +555,9 @@\n {\"sql\":\"SELECT WheelsOff, TotalAddGTime, \\\"Month\\\", OriginState FROM mytable ORDER BY OriginState LIMIT 24\",\"hsqls\":[\"SELECT WheelsOff, TotalAddGTime, Month, OriginState FROM mytable ORDER BY OriginState LIMIT 24\"]}\n {\"sql\":\"SELECT WheelsOn, OriginState FROM mytable WHERE DepartureDelayGroups > -2 ORDER BY OriginState LIMIT 20\"}\n {\"sql\":\"SELECT \\\"Year\\\", DepTime FROM mytable WHERE CRSArrTime BETWEEN 1237 AND 1534 AND Cancelled BETWEEN 0 AND 1 ORDER BY DepTime LIMIT 3\",\"hsqls\":[\"SELECT Year, DepTime FROM mytable WHERE CRSArrTime BETWEEN 1237 AND 1534 AND Cancelled BETWEEN 0 AND 1 ORDER BY DepTime LIMIT 3\"]}\n+{\"sql\":\"SELECT DivDistance, ActualElapsedTime FROM mytable LIMIT 29\"}\n+{\"sql\":\"SELECT DayOfWeek FROM mytable WHERE TotalAddGTime IN (128, 148, 4, 34) LIMIT 8\"}\n+{\"sql\":\"SELECT WheelsOff FROM mytable WHERE DivDistance < 436 LIMIT 12\"}\n+{\"sql\":\"SELECT DivDistance, DepTime FROM mytable WHERE NASDelay IN (45, 55, 31, 9) LIMIT 26\"}\n+{\"sql\":\"SELECT DepDelay FROM mytable WHERE DepDelayMinutes BETWEEN 292.0 AND 237.0 AND DestState IN ('DE', 'AZ') LIMIT 18\"}\n+{\"sql\":\"SELECT DestStateFips FROM mytable LIMIT 27\"}", "originalCommit": "d6dcc8dec1c7f3a7495fe0cc3ea0c7390522f4be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY1MjQxOQ==", "url": "https://github.com/apache/pinot/pull/6224#discussion_r522652419", "bodyText": "You can add # Selection above this line, and update the line 516 to #Selection & Order by to differentiate two groups.", "author": "jackjlli", "createdAt": "2020-11-13T05:11:18Z", "path": "pinot-integration-tests/src/test/resources/On_Time_On_Time_Performance_2014_100k_subset.test_queries_500.sql", "diffHunk": "@@ -555,3 +555,9 @@\n {\"sql\":\"SELECT WheelsOff, TotalAddGTime, \\\"Month\\\", OriginState FROM mytable ORDER BY OriginState LIMIT 24\",\"hsqls\":[\"SELECT WheelsOff, TotalAddGTime, Month, OriginState FROM mytable ORDER BY OriginState LIMIT 24\"]}\n {\"sql\":\"SELECT WheelsOn, OriginState FROM mytable WHERE DepartureDelayGroups > -2 ORDER BY OriginState LIMIT 20\"}\n {\"sql\":\"SELECT \\\"Year\\\", DepTime FROM mytable WHERE CRSArrTime BETWEEN 1237 AND 1534 AND Cancelled BETWEEN 0 AND 1 ORDER BY DepTime LIMIT 3\",\"hsqls\":[\"SELECT Year, DepTime FROM mytable WHERE CRSArrTime BETWEEN 1237 AND 1534 AND Cancelled BETWEEN 0 AND 1 ORDER BY DepTime LIMIT 3\"]}\n+{\"sql\":\"SELECT DivDistance, ActualElapsedTime FROM mytable LIMIT 29\"}", "originalCommit": "d6dcc8dec1c7f3a7495fe0cc3ea0c7390522f4be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "92007d26eb75ce7b25e0380bdd4a9a7ec111105c", "url": "https://github.com/apache/pinot/commit/92007d26eb75ce7b25e0380bdd4a9a7ec111105c", "message": "Improve comparison coverage for selection SQL queries in ClusterIntegrationTestUtils(#6193)\nAdd some selection queries without order-by to test_queries_500.sql for testing.", "committedDate": "2020-11-14T01:25:43Z", "type": "forcePushed"}, {"oid": "e784bd2db3e8d6ce56f8bea5248a80d24a708a3f", "url": "https://github.com/apache/pinot/commit/e784bd2db3e8d6ce56f8bea5248a80d24a708a3f", "message": "Improve comparison coverage for selection SQL queries in ClusterIntegrationTestUtils(#6193)\nAdd some selection queries without order-by to test_queries_500.sql for testing.", "committedDate": "2020-11-15T06:29:40Z", "type": "forcePushed"}, {"oid": "f4559e78d4a0b16b04c2de2a04ceefb5996fc3c6", "url": "https://github.com/apache/pinot/commit/f4559e78d4a0b16b04c2de2a04ceefb5996fc3c6", "message": "Improve comparison coverage for selection SQL queries in ClusterIntegrationTestUtils(#6193)\nAdd some selection queries without order-by to test_queries_500.sql for testing.", "committedDate": "2020-11-17T19:58:40Z", "type": "forcePushed"}, {"oid": "21eacde5fae8c56252af9887cdbdb49bc2dc8c71", "url": "https://github.com/apache/pinot/commit/21eacde5fae8c56252af9887cdbdb49bc2dc8c71", "message": "Improve comparison coverage for selection SQL queries in ClusterIntegrationTestUtils(#6193)\nAdd some selection queries without order-by to test_queries_500.sql for testing.", "committedDate": "2020-11-17T21:41:49Z", "type": "commit"}, {"oid": "21eacde5fae8c56252af9887cdbdb49bc2dc8c71", "url": "https://github.com/apache/pinot/commit/21eacde5fae8c56252af9887cdbdb49bc2dc8c71", "message": "Improve comparison coverage for selection SQL queries in ClusterIntegrationTestUtils(#6193)\nAdd some selection queries without order-by to test_queries_500.sql for testing.", "committedDate": "2020-11-17T21:41:49Z", "type": "forcePushed"}]}