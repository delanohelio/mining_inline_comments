{"pr_number": 5444, "pr_title": "Enhance and simplify the filtering", "pr_createdAt": "2020-05-26T03:01:37Z", "pr_url": "https://github.com/apache/pinot/pull/5444", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMTk4MQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430711981", "bodyText": "this is awesome", "author": "kishoreg", "createdAt": "2020-05-26T21:15:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java", "diffHunk": "@@ -21,6 +21,4 @@\n public interface BlockDocIdSet {\n \n   BlockDocIdIterator iterator();\n-", "originalCommit": "8dbbaa576b37449fc2e85813380ad84ba60f9bd0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMjgwMQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430712801", "bodyText": "why is blockValIterator returning getNextDocId ?", "author": "kishoreg", "createdAt": "2020-05-26T21:16:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockValIterator.java", "diffHunk": "@@ -22,6 +22,8 @@\n \n   boolean hasNext();\n \n+  int getNextDocId();", "originalCommit": "8dbbaa576b37449fc2e85813380ad84ba60f9bd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDQ3Mg==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430790472", "bodyText": "This iterator is not only iterator but supports skipTo(docId) and reset(). It is easier to track the docId here comparing to tracking it on the caller side. I'll add some javadoc to explain this", "author": "Jackie-Jiang", "createdAt": "2020-05-27T01:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMjgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNDI3NQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430714275", "bodyText": "why are we removing these methods, dont we need them for no-dictionary?", "author": "kishoreg", "createdAt": "2020-05-26T21:20:06Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/io/readerwriter/impl/FixedByteSingleColumnMultiValueReaderWriter.java", "diffHunk": "@@ -277,42 +260,6 @@ public void setStringArray(int row, String[] stringArray) {\n     }\n   }\n \n-  @Override", "originalCommit": "8dbbaa576b37449fc2e85813380ad84ba60f9bd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4OTA2Mw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430789063", "bodyText": "No, I only removed the ones that does not apply to Pinot types (we don't support MV BYTES).", "author": "Jackie-Jiang", "createdAt": "2020-05-27T01:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNDI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NzIxNA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430777214", "bodyText": "we don't want to remove these. There are usecases where we will support no-dictionary modes", "author": "kishoreg", "createdAt": "2020-05-27T00:20:54Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/io/writer/SingleColumnMultiValueWriter.java", "diffHunk": "@@ -19,60 +19,14 @@\n package org.apache.pinot.core.io.writer;\n \n public interface SingleColumnMultiValueWriter extends DataFileWriter {\n-  /**", "originalCommit": "8dbbaa576b37449fc2e85813380ad84ba60f9bd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4OTUyMw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430789523", "bodyText": "Same here. I only removed the ones that does not apply to Pinot data types.", "author": "Jackie-Jiang", "createdAt": "2020-05-27T01:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NzIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MzUyMQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430783521", "bodyText": "Java doc over this method and/or the interface? Since we are refactoring this interface, it is a good time to add javadoc for a public interface as well.", "author": "chenboat", "createdAt": "2020-05-27T00:43:25Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java", "diffHunk": "@@ -21,6 +21,4 @@\n public interface BlockDocIdSet {\n \n   BlockDocIdIterator iterator();", "originalCommit": "8dbbaa576b37449fc2e85813380ad84ba60f9bd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDU4Mg==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430790582", "bodyText": "Good point, will add javadoc", "author": "Jackie-Jiang", "createdAt": "2020-05-27T01:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MzUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNDc5OQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r431604799", "bodyText": "can you also explain why it is called block*?", "author": "chenboat", "createdAt": "2020-05-28T06:19:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MzUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0MzAxNA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432043014", "bodyText": "The result from the Operator is called Block, and BlockDocIdSet is the document ids from a Block. It is not structured very well, but it is out of the scope of this PR. We have plan to clean that up later.", "author": "Jackie-Jiang", "createdAt": "2020-05-28T18:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MzUyMQ=="}], "type": "inlineReview"}, {"oid": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "url": "https://github.com/apache/pinot/commit/721e572ec55d488dc0f094e3b413b732ed0ae52b", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-05-27T04:04:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNDQ4NA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r431604484", "bodyText": "javadoc?", "author": "chenboat", "createdAt": "2020-05-28T06:17:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockMultiValIterator.java", "diffHunk": "@@ -18,33 +18,15 @@\n  */\n package org.apache.pinot.core.common;\n \n-/**\n- *\n- *\n- */\n-public abstract class BlockMultiValIterator implements BlockValIterator {\n-\n-  public int nextCharVal(char[] charArray) {\n-    throw new UnsupportedOperationException();\n-  }\n+public interface BlockMultiValIterator extends BlockValIterator {", "originalCommit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNDk3Ng==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r431604976", "bodyText": "javadoc", "author": "chenboat", "createdAt": "2020-05-28T06:19:35Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockSingleValIterator.java", "diffHunk": "@@ -18,37 +18,17 @@\n  */\n package org.apache.pinot.core.common;\n \n-/**\n- *\n- * TODO: Split into two classes, one for iterator over data, another over dictionary id's.\n- */\n-public abstract class BlockSingleValIterator implements BlockValIterator {\n-\n-  char nextCharVal() {\n-    throw new UnsupportedOperationException();\n-  }\n+public interface BlockSingleValIterator extends BlockValIterator {", "originalCommit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNjUwNQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r431606505", "bodyText": "what is the behavior if the input doc id does not exist?", "author": "chenboat", "createdAt": "2020-05-28T06:23:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockValIterator.java", "diffHunk": "@@ -20,9 +20,23 @@\n \n public interface BlockValIterator {\n \n+  /**\n+   * Returns {@code true} if there are more values in the iterator, {@code false} otherwise.\n+   */\n   boolean hasNext();\n \n+  /**\n+   * Returns the next document id to be read.\n+   */\n+  int getNextDocId();\n+\n+  /**\n+   * Sets the next document id to the given document id.", "originalCommit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNjk3MQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r431606971", "bodyText": "it is worthwhile to explain how to use this method? what is the input array?", "author": "chenboat", "createdAt": "2020-05-28T06:25:00Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockMultiValIterator.java", "diffHunk": "@@ -18,33 +18,15 @@\n  */\n package org.apache.pinot.core.common;\n \n-/**\n- *\n- *\n- */\n-public abstract class BlockMultiValIterator implements BlockValIterator {\n-\n-  public int nextCharVal(char[] charArray) {\n-    throw new UnsupportedOperationException();\n-  }\n+public interface BlockMultiValIterator extends BlockValIterator {\n \n-  public int nextIntVal(int[] intArray) {\n-    throw new UnsupportedOperationException();\n-  }\n+  int nextIntVal(int[] intArray);", "originalCommit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTA3Mg==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r431615072", "bodyText": "does it mean the class performs binary merge of 2 child BlockDocIdSets each time?", "author": "chenboat", "createdAt": "2020-05-28T06:45:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/docidsets/AndDocIdSet.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.docidsets;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.pinot.common.utils.Pairs.IntPair;\n+import org.apache.pinot.core.common.BlockDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.AndDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.BitmapBasedDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.RangelessBitmapDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.ScanBasedDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.SortedDocIdIterator;\n+import org.apache.pinot.core.util.SortedRangeIntersection;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+\n+/**\n+ * The FilterBlockDocIdSet to perform AND on all child FilterBlockDocIdSets.\n+ * <p>The AndBlockDocIdSet will construct the BlockDocIdIterator based on the BlockDocIdIterators from the child\n+ * FilterBlockDocIdSets:\n+ * <ul>\n+ *   <li>\n+ *     When there are at least one index-base BlockDocIdIterators (SortedDocIdIterator or BitmapBasedDocIdIterator) and", "originalCommit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MDEwMw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432060103", "bodyText": "It uses a bitmap to perform AND for all index-based BlockDocIdIterators, and use ScanBasedDocIdIterator.applyAnd(docIds) to resolve the scan-based BlockDocIdIterators. After all, there will be one RangelessBitmapDocIdIterator on top of the result bitmap.", "author": "Jackie-Jiang", "createdAt": "2020-05-28T19:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTA3Mg=="}], "type": "inlineReview"}, {"oid": "d048549b900fd79c8559349310ab88c276e9a66b", "url": "https://github.com/apache/pinot/commit/d048549b900fd79c8559349310ab88c276e9a66b", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-05-28T22:42:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMTYzNw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432211637", "bodyText": "It will be useful to add some comments here as to how we make sure that index never overruns. It took me a couple of iterations to get the test cases to test this.\nOn that topic, will be useful to add a unit test for this class.", "author": "mcvsubbu", "createdAt": "2020-05-29T01:39:11Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java", "diffHunk": "@@ -18,112 +18,52 @@\n  */\n package org.apache.pinot.core.operator.dociditerators;\n \n-import java.util.Arrays;\n import org.apache.pinot.core.common.BlockDocIdIterator;\n import org.apache.pinot.core.common.Constants;\n \n \n-// TODO: Optimize this\n public final class AndDocIdIterator implements BlockDocIdIterator {\n-  public final BlockDocIdIterator[] docIdIterators;\n-  public ScanBasedDocIdIterator[] scanBasedDocIdIterators;\n-  public final int[] docIdPointers;\n-  public boolean reachedEnd = false;\n-  public int currentDocId = -1;\n-  int currentMax = -1;\n-  private boolean hasScanBasedIterators;\n+  public final BlockDocIdIterator[] _docIdIterators;\n \n-  public AndDocIdIterator(BlockDocIdIterator[] blockDocIdIterators) {\n-    int numIndexBasedIterators = 0;\n-    int numScanBasedIterators = 0;\n-    for (int i = 0; i < blockDocIdIterators.length; i++) {\n-      if (blockDocIdIterators[i] instanceof IndexBasedDocIdIterator) {\n-        numIndexBasedIterators = numIndexBasedIterators + 1;\n-      } else if (blockDocIdIterators[i] instanceof ScanBasedDocIdIterator) {\n-        numScanBasedIterators = numScanBasedIterators + 1;\n-      }\n-    }\n-    // if we have at least one index based then do intersection based on index based only, and then\n-    // check if matching docs apply on scan based iterator\n-    if (numIndexBasedIterators > 0 && numScanBasedIterators > 0) {\n-      hasScanBasedIterators = true;\n-      int nonScanIteratorsSize = blockDocIdIterators.length - numScanBasedIterators;\n-      this.docIdIterators = new BlockDocIdIterator[nonScanIteratorsSize];\n-      this.scanBasedDocIdIterators = new ScanBasedDocIdIterator[numScanBasedIterators];\n-      int nonScanBasedIndex = 0;\n-      int scanBasedIndex = 0;\n-      for (int i = 0; i < blockDocIdIterators.length; i++) {\n-        if (blockDocIdIterators[i] instanceof ScanBasedDocIdIterator) {\n-          this.scanBasedDocIdIterators[scanBasedIndex++] = (ScanBasedDocIdIterator) blockDocIdIterators[i];\n-        } else {\n-          this.docIdIterators[nonScanBasedIndex++] = blockDocIdIterators[i];\n-        }\n-      }\n-    } else {\n-      hasScanBasedIterators = false;\n-      this.docIdIterators = blockDocIdIterators;\n-    }\n-    this.docIdPointers = new int[docIdIterators.length];\n-    Arrays.fill(docIdPointers, -1);\n-  }\n+  private int _nextDocId = 0;\n \n-  @Override\n-  public int advance(int targetDocId) {\n-    if (currentDocId == Constants.EOF) {\n-      return currentDocId;\n-    }\n-    if (currentDocId >= targetDocId) {\n-      return currentDocId;\n-    }\n-    // next() method will always increment currentMax by 1.\n-    currentMax = targetDocId - 1;\n-    return next();\n+  public AndDocIdIterator(BlockDocIdIterator[] docIdIterators) {\n+    _docIdIterators = docIdIterators;\n   }\n \n   @Override\n   public int next() {\n-    if (currentDocId == Constants.EOF) {\n-      return currentDocId;\n-    }\n-    currentMax = currentMax + 1;\n-    // always increment the pointer to current max, when this is called first time, every one will\n-    // be set to start of posting list.\n-    for (int i = 0; i < docIdIterators.length; i++) {\n-      docIdPointers[i] = docIdIterators[i].advance(currentMax);\n-      if (docIdPointers[i] == Constants.EOF) {\n-        reachedEnd = true;\n-        currentMax = Constants.EOF;\n-        break;\n-      }\n-      if (docIdPointers[i] > currentMax) {\n-        currentMax = docIdPointers[i];\n-        if (i > 0) {\n-          // we need to advance all pointer since we found a new max\n-          i = -1;\n-        }\n-      }\n-      if (hasScanBasedIterators && i == docIdIterators.length - 1) {\n-        // this means we found the docId common to all nonScanBased iterators, now we need to ensure\n-        // that its also found in scanBasedIterator, if not matched, we restart the intersection\n-        for (ScanBasedDocIdIterator iterator : scanBasedDocIdIterators) {\n-          if (!iterator.isMatch(currentMax)) {\n-            i = -1;\n-            currentMax = currentMax + 1;\n-            break;\n+    int maxDocId = _nextDocId;\n+    int maxDocIdIndex = -1;\n+    int numDocIdIterators = _docIdIterators.length;\n+    int index = 0;\n+    while (index < numDocIdIterators) {\n+      if (index == maxDocIdIndex) {\n+        // Skip the index with the max document id\n+        index++;", "originalCommit": "d048549b900fd79c8559349310ab88c276e9a66b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NDc5NA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432244794", "bodyText": "Changed the code a little bit so that it is more clear how index is kept in bound.\nAdded AndDocIdIteratorTest and OrDocIdIteratorTest.\nI have run all the queries before submitting the PR. Will run them again before merging.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T04:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMTYzNw=="}], "type": "inlineReview"}, {"oid": "d22ac5ce9e049c020ee8b9cb7b440591bd7f5176", "url": "https://github.com/apache/pinot/commit/d22ac5ce9e049c020ee8b9cb7b440591bd7f5176", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-05-29T04:04:13Z", "type": "forcePushed"}, {"oid": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "url": "https://github.com/apache/pinot/commit/02f8fc7c0e73853ad6637e3b18539df462cc57cd", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-05-29T04:19:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMTg0Ng==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432321846", "bodyText": "(nit): should just be cardinality of the column (since size of dictionary is equal to cardinality)", "author": "siddharthteotia", "createdAt": "2020-05-29T08:05:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedIndexBasedFilterOperator.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.filter;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.pinot.common.utils.Pairs.IntPair;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.io.reader.impl.v1.SortedIndexReader;\n+import org.apache.pinot.core.operator.blocks.FilterBlock;\n+import org.apache.pinot.core.operator.docidsets.SortedDocIdSet;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n+import org.apache.pinot.core.operator.filter.predicate.RangePredicateEvaluatorFactory.OfflineDictionaryBasedRangePredicateEvaluator;\n+\n+\n+@SuppressWarnings(\"rawtypes\")\n+public class SortedIndexBasedFilterOperator extends BaseFilterOperator {\n+  private static final String OPERATOR_NAME = \"SortedIndexBasedFilterOperator\";\n+\n+  private final PredicateEvaluator _predicateEvaluator;\n+  private final SortedIndexReader _sortedIndexReader;\n+  private final int _numDocs;\n+\n+  SortedIndexBasedFilterOperator(PredicateEvaluator predicateEvaluator, DataSource dataSource, int numDocs) {\n+    _predicateEvaluator = predicateEvaluator;\n+    _sortedIndexReader = (SortedIndexReader) dataSource.getInvertedIndex();\n+    _numDocs = numDocs;\n+  }\n+\n+  @Override\n+  protected FilterBlock getNextBlock() {\n+    // At this point, we need to create a list of matching docId ranges. There are two kinds of operators:\n+    //\n+    // - \"Additive\" operators, such as EQ, IN and RANGE build up a list of ranges and merge overlapping/adjacent ones,\n+    //   clipping the ranges to [startDocId; endDocId]\n+    //\n+    // - \"Subtractive\" operators, such as NEQ and NOT IN build up a list of ranges that do not match and build a list of\n+    //   matching intervals by subtracting a list of non-matching intervals from the given range of\n+    //   [startDocId; endDocId]\n+    //\n+    // For now, we don't look at the cardinality of the column's dictionary, although we should do that if someone", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODk5Nw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432678997", "bodyText": "I didn't change this block of comments, but seems it identifies it as a new class. Let me update it.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T19:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMTg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMjA5NA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432322094", "bodyText": "Is is possible to handle NOT_IN, NEQ exactly once?\nWe checked for _exclusive and accordingly get non matching dictIds or matching dictIds based on whether it is true or false. So the predicate is already evaluated correctly. Now why can't we can just work on the docIds for these dictIds.", "author": "siddharthteotia", "createdAt": "2020-05-29T08:06:05Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/BitmapBasedFilterOperator.java", "diffHunk": "@@ -25,62 +25,73 @@\n import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n import org.apache.pinot.core.segment.index.readers.InvertedIndexReader;\n import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n \n+@SuppressWarnings(\"rawtypes\")\n public class BitmapBasedFilterOperator extends BaseFilterOperator {\n   private static final String OPERATOR_NAME = \"BitmapBasedFilterOperator\";\n \n   private final PredicateEvaluator _predicateEvaluator;\n-  private final DataSource _dataSource;\n-  private final ImmutableRoaringBitmap[] _bitmaps;\n-  private final int _startDocId;\n-  // TODO: change it to exclusive\n-  // Inclusive\n-  private final int _endDocId;\n+  private final InvertedIndexReader _invertedIndexReader;\n+  private final ImmutableRoaringBitmap _docIds;\n   private final boolean _exclusive;\n+  private final int _numDocs;\n \n-  BitmapBasedFilterOperator(PredicateEvaluator predicateEvaluator, DataSource dataSource, int startDocId,\n-      int endDocId) {\n-    // NOTE:\n-    // Predicate that is always evaluated as true or false should not be passed into the BitmapBasedFilterOperator for\n-    // performance concern.\n-    // If predicate is always evaluated as true, use MatchAllFilterOperator; if predicate is always evaluated as false,\n-    // use EmptyFilterOperator.\n-    Preconditions.checkArgument(!predicateEvaluator.isAlwaysTrue() && !predicateEvaluator.isAlwaysFalse());\n-\n+  BitmapBasedFilterOperator(PredicateEvaluator predicateEvaluator, DataSource dataSource, int numDocs) {\n     _predicateEvaluator = predicateEvaluator;\n-    _dataSource = dataSource;\n-    _bitmaps = null;\n-    _startDocId = startDocId;\n-    _endDocId = endDocId;\n+    _invertedIndexReader = dataSource.getInvertedIndex();\n+    _docIds = null;\n     _exclusive = predicateEvaluator.isExclusive();\n+    _numDocs = numDocs;\n   }\n \n-  public BitmapBasedFilterOperator(ImmutableRoaringBitmap[] bitmaps, int startDocId, int endDocId, boolean exclusive) {\n+  public BitmapBasedFilterOperator(ImmutableRoaringBitmap docIds, boolean exclusive, int numDocs) {\n     _predicateEvaluator = null;\n-    _dataSource = null;\n-    _bitmaps = bitmaps;\n-    _startDocId = startDocId;\n-    _endDocId = endDocId;\n+    _invertedIndexReader = null;\n+    _docIds = docIds;\n     _exclusive = exclusive;\n+    _numDocs = numDocs;\n   }\n \n   @Override\n   protected FilterBlock getNextBlock() {\n-    if (_bitmaps != null) {\n-      return new FilterBlock(new BitmapDocIdSet(_bitmaps, _startDocId, _endDocId, _exclusive));\n+    if (_docIds != null) {\n+      if (_exclusive) {\n+        return new FilterBlock(new BitmapDocIdSet(ImmutableRoaringBitmap.flip(_docIds, 0L, _numDocs), _numDocs));\n+      } else {\n+        return new FilterBlock(new BitmapDocIdSet(_docIds, _numDocs));\n+      }\n     }\n \n     int[] dictIds = _exclusive ? _predicateEvaluator.getNonMatchingDictIds() : _predicateEvaluator.getMatchingDictIds();", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MTQ4Mg==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432681482", "bodyText": "For exclusive predicate, we need to flip (inverse) the bitmap so that the result bitmap can reflect the matching docIds.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T19:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMjA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzI2Ng==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432323266", "bodyText": "This is good piece of information. Why delete it? That's how the filtering will work right if we do\nWHERE col1 = 200 AND col2 = 10 -- if there is an inverted index on col1 and no index on col2", "author": "siddharthteotia", "createdAt": "2020-05-29T08:08:12Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/ScanBasedDocIdIterator.java", "diffHunk": "@@ -24,22 +24,18 @@\n \n \n /**\n- * All scan based filter iterators must implement this interface. This allows intersection to be\n- * optimized.\n- * For example, if the we have two iterators one index based and another scan based, instead of", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MjYwOQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432692609", "bodyText": "This part is explained in the AndDocIdSet. Updated the javadoc so that it is more clear here as well.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T19:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzMzNQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432323335", "bodyText": "I think generally hasNext() should be called before next() like it is done here. But I think our next() implementations (at least in some of the cases), have hasNext() called internally from next() as well.\nSo may be we should simply do (nextDocId = docIdIterator.next()) < _numDocs", "author": "siddharthteotia", "createdAt": "2020-05-29T08:08:21Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/SVScanDocIdIterator.java", "diffHunk": "@@ -18,238 +18,138 @@\n  */\n package org.apache.pinot.core.operator.dociditerators;\n \n-import org.apache.pinot.core.common.BlockMetadata;\n import org.apache.pinot.core.common.BlockSingleValIterator;\n-import org.apache.pinot.core.common.BlockValSet;\n import org.apache.pinot.core.common.Constants;\n import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n-import org.apache.pinot.spi.data.FieldSpec;\n import org.roaringbitmap.IntIterator;\n import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n \n-public class SVScanDocIdIterator implements ScanBasedDocIdIterator {\n-  private int _currentDocId = -1;\n+public final class SVScanDocIdIterator implements ScanBasedDocIdIterator {\n+  private final PredicateEvaluator _predicateEvaluator;\n   private final BlockSingleValIterator _valueIterator;\n-  private int _startDocId;\n-  private int _endDocId;\n-  private PredicateEvaluator _evaluator;\n-  private String _operatorName;\n-  private int _numEntriesScanned = 0;\n+  private final int _numDocs;\n   private final ValueMatcher _valueMatcher;\n \n-  public SVScanDocIdIterator(String operatorName, BlockValSet blockValSet, BlockMetadata blockMetadata,\n-      PredicateEvaluator evaluator) {\n-    _operatorName = operatorName;\n-    _evaluator = evaluator;\n-    _valueIterator = (BlockSingleValIterator) blockValSet.iterator();\n-\n-    if (evaluator.isAlwaysFalse()) {\n-      _currentDocId = Constants.EOF;\n-      setStartDocId(Constants.EOF);\n-      setEndDocId(Constants.EOF);\n-    } else {\n-      setStartDocId(blockMetadata.getStartDocId());\n-      setEndDocId(blockMetadata.getEndDocId());\n-    }\n+  private int _nextDocId = 0;\n+  private long _numEntriesScanned = 0L;\n \n-    if (evaluator.isDictionaryBased()) {\n-      _valueMatcher = new IntMatcher(); // Match using dictionary id's that are integers.\n-    } else {\n-      _valueMatcher = getValueMatcherForType(blockMetadata.getDataType());\n-    }\n-    _valueMatcher.setEvaluator(evaluator);\n-  }\n-\n-  /**\n-   * After setting the startDocId, next calls will always return from &gt;=startDocId\n-   *\n-   * @param startDocId Start doc id\n-   */\n-  public void setStartDocId(int startDocId) {\n-    _currentDocId = startDocId - 1;\n-    _valueIterator.skipTo(startDocId);\n-    _startDocId = startDocId;\n-  }\n-\n-  /**\n-   * After setting the endDocId, next call will return Constants.EOF after currentDocId exceeds\n-   * endDocId\n-   *\n-   * @param endDocId End doc id\n-   */\n-  public void setEndDocId(int endDocId) {\n-    _endDocId = endDocId;\n-  }\n-\n-  @Override\n-  public boolean isMatch(int docId) {\n-    if (_currentDocId == Constants.EOF) {\n-      return false;\n-    }\n-    _valueIterator.skipTo(docId);\n-    _numEntriesScanned++;\n-    return _valueMatcher.doesCurrentEntryMatch(_valueIterator);\n-  }\n-\n-  @Override\n-  public int advance(int targetDocId) {\n-    if (_currentDocId == Constants.EOF) {\n-      return _currentDocId;\n-    }\n-    if (targetDocId < _startDocId) {\n-      targetDocId = _startDocId;\n-    } else if (targetDocId > _endDocId) {\n-      _currentDocId = Constants.EOF;\n-    }\n-    if (_currentDocId >= targetDocId) {\n-      return _currentDocId;\n-    } else {\n-      _currentDocId = targetDocId - 1;\n-      _valueIterator.skipTo(targetDocId);\n-      return next();\n-    }\n+  public SVScanDocIdIterator(PredicateEvaluator predicateEvaluator, BlockSingleValIterator valueIterator, int numDocs) {\n+    _predicateEvaluator = predicateEvaluator;\n+    _valueIterator = valueIterator;\n+    _numDocs = numDocs;\n+    _valueMatcher = getValueMatcher();\n   }\n \n   @Override\n   public int next() {\n-    if (_currentDocId == Constants.EOF) {\n-      return Constants.EOF;\n-    }\n-    while (_valueIterator.hasNext() && _currentDocId < _endDocId) {\n-      _currentDocId = _currentDocId + 1;\n+    while (_nextDocId < _numDocs) {\n+      int nextDocId = _nextDocId++;\n       _numEntriesScanned++;\n-      if (_valueMatcher.doesCurrentEntryMatch(_valueIterator)) {\n-        return _currentDocId;\n+      if (_valueMatcher.doesNextValueMatch()) {\n+        return nextDocId;\n       }\n     }\n-    _currentDocId = Constants.EOF;\n     return Constants.EOF;\n   }\n \n   @Override\n-  public int currentDocId() {\n-    return _currentDocId;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return SVScanDocIdIterator.class.getSimpleName() + \"[\" + _operatorName + \"]\";\n+  public int advance(int targetDocId) {\n+    _nextDocId = targetDocId;\n+    _valueIterator.skipTo(targetDocId);\n+    return next();\n   }\n \n   @Override\n   public MutableRoaringBitmap applyAnd(ImmutableRoaringBitmap docIds) {\n     MutableRoaringBitmap result = new MutableRoaringBitmap();\n-    if (_evaluator.isAlwaysFalse()) {\n-      return result;\n-    }\n-    IntIterator intIterator = docIds.getIntIterator();\n-    int docId = -1;\n-    while (intIterator.hasNext() && docId < _endDocId) {\n-      docId = intIterator.next();\n-      if (docId >= _startDocId) {\n-        _valueIterator.skipTo(docId);\n-        _numEntriesScanned++;\n-        if (_valueMatcher.doesCurrentEntryMatch(_valueIterator)) {\n-          result.add(docId);\n-        }\n+    IntIterator docIdIterator = docIds.getIntIterator();\n+    int nextDocId;\n+    while (docIdIterator.hasNext() && (nextDocId = docIdIterator.next()) < _numDocs) {", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NTY1NA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432695654", "bodyText": "This IntIterator is from ImmutableRoaringBitmap.getIntIterator() where docIdIterator.next() does not check hasNext().\nOur BlockDocIdIterator does not have hasNext() and always use Constants.EOF to notify the end of the iteration.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T19:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5OTI4NQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432699285", "bodyText": "its ok to drop hasNext if it simplifies the implementation", "author": "kishoreg", "createdAt": "2020-05-29T19:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzYwNg==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432323606", "bodyText": "+1000 on removing this.", "author": "siddharthteotia", "createdAt": "2020-05-29T08:08:55Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java", "diffHunk": "@@ -18,9 +18,15 @@\n  */\n package org.apache.pinot.core.common;\n \n+/**\n+ * The interface <code>BlockDocIdSet</code> represents all the matching document ids for a predicate.", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzYzMw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432323633", "bodyText": "What happens from an API point of view if the target is same as last returned matching docId?\nWe won't throw error and return the target as is. So, the comment should state greater than or equal to.", "author": "siddharthteotia", "createdAt": "2020-05-29T08:08:59Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdIterator.java", "diffHunk": "@@ -25,25 +25,16 @@\n public interface BlockDocIdIterator {\n \n   /**\n-   * Get the next document id.\n-   *\n-   * @return Next document id or EOF if there is no more documents\n+   * Returns the next matched document id, or {@link Constants#EOF} if there is no more matched document.\n+   * <p>NOTE: There should be no more call to this method after it returns {@link Constants#EOF}.\n    */\n   int next();\n \n   /**\n-   * Advance to the first document whose id is equal or greater than the given target document id.\n-   * <p>If the given target document id is smaller or equal to the current document id, then return the current one.\n-   *\n-   * @param targetDocId The target document id\n-   * @return First document id that is equal or greater than target or EOF if no document matches\n+   * Returns the first matched document whose id is equal to or greater than the given target document id, or\n+   * {@link Constants#EOF} if there is no such document.\n+   * <p>NOTE: The target document id should be greater than the document id previous returned.", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwMDg3Ng==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432700876", "bodyText": "No, the advance(targetDocId) here is equivalent to skipTo(targetDocId) and next() where you already iterate over the targetDocId. From an iterator's perspective, it should not return the same value twice. With this assumption, we can save one if check inside the advance(targetDocId).\nUpdated the javadoc to make it more clear.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T19:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzMTMxMw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432331313", "bodyText": "These 3 (sorted, inv index, and scan) are basically for left or right leaf operators of AND. The remainingDocIdIterators is for non-leaves (child AND/OR) right?\nOn that note, for any sub-tree rooted at AND, there can be at-most one child with sorted iterator. Right?", "author": "siddharthteotia", "createdAt": "2020-05-29T08:23:42Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/docidsets/AndDocIdSet.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.docidsets;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.pinot.common.utils.Pairs.IntPair;\n+import org.apache.pinot.core.common.BlockDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.AndDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.BitmapBasedDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.RangelessBitmapDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.ScanBasedDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.SortedDocIdIterator;\n+import org.apache.pinot.core.util.SortedRangeIntersection;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+\n+/**\n+ * The FilterBlockDocIdSet to perform AND on all child FilterBlockDocIdSets.\n+ * <p>The AndBlockDocIdSet will construct the BlockDocIdIterator based on the BlockDocIdIterators from the child\n+ * FilterBlockDocIdSets:\n+ * <ul>\n+ *   <li>\n+ *     When there are at least one index-base BlockDocIdIterators (SortedDocIdIterator or BitmapBasedDocIdIterator) and\n+ *     at least one ScanBasedDocIdIterator, or more than one index-based BlockDocIdIterators, merge them and construct a\n+ *     RangelessBitmapDocIdIterator from the merged document ids. If there is no remaining BlockDocIdIterators, directly\n+ *     return the merged RangelessBitmapDocIdIterator; otherwise, construct and return an AndDocIdIterator with the\n+ *     merged RangelessBitmapDocIdIterator and the remaining BlockDocIdIterators.\n+ *   </li>\n+ *   <li>\n+ *     Otherwise, construct and return an AndDocIdIterator with all BlockDocIdIterators.\n+ *   </li>\n+ * </ul>\n+ */\n+public final class AndDocIdSet implements FilterBlockDocIdSet {\n+  private final List<FilterBlockDocIdSet> _docIdSets;\n+\n+  public AndDocIdSet(List<FilterBlockDocIdSet> docIdSets) {\n+    _docIdSets = docIdSets;\n+  }\n+\n+  @Override\n+  public BlockDocIdIterator iterator() {\n+    int numDocIdSets = _docIdSets.size();\n+    // NOTE: Keep the order of FilterBlockDocIdSets to preserve the order decided within FilterOperatorUtils.\n+    // TODO: Consider deciding the order based on the stats of BlockDocIdIterators\n+    BlockDocIdIterator[] allDocIdIterators = new BlockDocIdIterator[numDocIdSets];\n+    List<SortedDocIdIterator> sortedDocIdIterators = new ArrayList<>();", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwNDA5MA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432704090", "bodyText": "For the current supported iterators, yes remainingDocIdIterators can only be AND/OR.\nThere could be multiple sorted iterators if there are multiple predicates on the same sorted column or there are multiple sorted columns.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T19:52:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzMTMxMw=="}], "type": "inlineReview"}, {"oid": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "url": "https://github.com/apache/pinot/commit/13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-05-29T19:53:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0MTAzMg==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r433641032", "bodyText": "i think a better name could be candidateDocId because the while loop() is searching for the next doc Id exists in all iterators. maxDocId to many ppl mean the maximum doc id in the iterator.", "author": "chenboat", "createdAt": "2020-06-02T06:10:35Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java", "diffHunk": "@@ -18,112 +18,52 @@\n  */\n package org.apache.pinot.core.operator.dociditerators;\n \n-import java.util.Arrays;\n import org.apache.pinot.core.common.BlockDocIdIterator;\n import org.apache.pinot.core.common.Constants;\n \n \n-// TODO: Optimize this\n public final class AndDocIdIterator implements BlockDocIdIterator {\n-  public final BlockDocIdIterator[] docIdIterators;\n-  public ScanBasedDocIdIterator[] scanBasedDocIdIterators;\n-  public final int[] docIdPointers;\n-  public boolean reachedEnd = false;\n-  public int currentDocId = -1;\n-  int currentMax = -1;\n-  private boolean hasScanBasedIterators;\n+  public final BlockDocIdIterator[] _docIdIterators;\n \n-  public AndDocIdIterator(BlockDocIdIterator[] blockDocIdIterators) {\n-    int numIndexBasedIterators = 0;\n-    int numScanBasedIterators = 0;\n-    for (int i = 0; i < blockDocIdIterators.length; i++) {\n-      if (blockDocIdIterators[i] instanceof IndexBasedDocIdIterator) {\n-        numIndexBasedIterators = numIndexBasedIterators + 1;\n-      } else if (blockDocIdIterators[i] instanceof ScanBasedDocIdIterator) {\n-        numScanBasedIterators = numScanBasedIterators + 1;\n-      }\n-    }\n-    // if we have at least one index based then do intersection based on index based only, and then\n-    // check if matching docs apply on scan based iterator\n-    if (numIndexBasedIterators > 0 && numScanBasedIterators > 0) {\n-      hasScanBasedIterators = true;\n-      int nonScanIteratorsSize = blockDocIdIterators.length - numScanBasedIterators;\n-      this.docIdIterators = new BlockDocIdIterator[nonScanIteratorsSize];\n-      this.scanBasedDocIdIterators = new ScanBasedDocIdIterator[numScanBasedIterators];\n-      int nonScanBasedIndex = 0;\n-      int scanBasedIndex = 0;\n-      for (int i = 0; i < blockDocIdIterators.length; i++) {\n-        if (blockDocIdIterators[i] instanceof ScanBasedDocIdIterator) {\n-          this.scanBasedDocIdIterators[scanBasedIndex++] = (ScanBasedDocIdIterator) blockDocIdIterators[i];\n-        } else {\n-          this.docIdIterators[nonScanBasedIndex++] = blockDocIdIterators[i];\n-        }\n-      }\n-    } else {\n-      hasScanBasedIterators = false;\n-      this.docIdIterators = blockDocIdIterators;\n-    }\n-    this.docIdPointers = new int[docIdIterators.length];\n-    Arrays.fill(docIdPointers, -1);\n-  }\n+  private int _nextDocId = 0;\n \n-  @Override\n-  public int advance(int targetDocId) {\n-    if (currentDocId == Constants.EOF) {\n-      return currentDocId;\n-    }\n-    if (currentDocId >= targetDocId) {\n-      return currentDocId;\n-    }\n-    // next() method will always increment currentMax by 1.\n-    currentMax = targetDocId - 1;\n-    return next();\n+  public AndDocIdIterator(BlockDocIdIterator[] docIdIterators) {\n+    _docIdIterators = docIdIterators;\n   }\n \n   @Override\n   public int next() {\n-    if (currentDocId == Constants.EOF) {\n-      return currentDocId;\n-    }\n-    currentMax = currentMax + 1;\n-    // always increment the pointer to current max, when this is called first time, every one will\n-    // be set to start of posting list.\n-    for (int i = 0; i < docIdIterators.length; i++) {\n-      docIdPointers[i] = docIdIterators[i].advance(currentMax);\n-      if (docIdPointers[i] == Constants.EOF) {\n-        reachedEnd = true;\n-        currentMax = Constants.EOF;\n-        break;\n-      }\n-      if (docIdPointers[i] > currentMax) {\n-        currentMax = docIdPointers[i];\n-        if (i > 0) {\n-          // we need to advance all pointer since we found a new max\n-          i = -1;\n-        }\n+    int maxDocId = _nextDocId;", "originalCommit": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA2NDUxNQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r434064515", "bodyText": "I prefer AndDocIdIterator because it performs an AND (intersection) operation on all the iterators, and also it is the BlockDocIdIterator for AndDocIdSet. Will add some javadoc showing the relation between them.", "author": "Jackie-Jiang", "createdAt": "2020-06-02T17:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0MTAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0Mjc3OA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r433642778", "bodyText": "what happens if _nextIndex >= docIds.length? should we have a array length check?", "author": "chenboat", "createdAt": "2020-06-02T06:15:33Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/ArrayBasedDocIdIterator.java", "diffHunk": "@@ -36,37 +35,15 @@ public ArrayBasedDocIdIterator(int[] docIds, int searchableLength) {\n \n   @Override\n   public int next() {\n-    if (_currentDocId == Constants.EOF) {\n-      return Constants.EOF;\n-    }\n-    if (++_currentIndex == _searchableLength) {\n-      _currentDocId = Constants.EOF;\n+    if (_nextIndex < _searchableLength) {\n+      return _docIds[_nextIndex++];", "originalCommit": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA2MzU2NQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r434063565", "bodyText": "Caller should ensure _searchableLength <= _docIds.length. If caller passes in wrong parameters, it is okay to through IndexOutOfBoundException. Similarly, we don't perform null check everywhere for simplicity and performance reason.", "author": "Jackie-Jiang", "createdAt": "2020-06-02T17:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0Mjc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0NzI3OA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r433647278", "bodyText": "1.javadoc?\n2. comments about thread safety. is it safe/advisable to use this iterator in more than one thread?", "author": "chenboat", "createdAt": "2020-06-02T06:27:57Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java", "diffHunk": "@@ -18,112 +18,52 @@\n  */\n package org.apache.pinot.core.operator.dociditerators;\n \n-import java.util.Arrays;\n import org.apache.pinot.core.common.BlockDocIdIterator;\n import org.apache.pinot.core.common.Constants;\n \n \n-// TODO: Optimize this\n public final class AndDocIdIterator implements BlockDocIdIterator {", "originalCommit": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA2Njg3MA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r434066870", "bodyText": "It is not thread safety (the whole filtering layer does not involve thread safety because it is happening under one segment which is always processed by one thread). Also, I don't think multiple threads using one iterator make sense..", "author": "Jackie-Jiang", "createdAt": "2020-06-02T17:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0NzI3OA=="}], "type": "inlineReview"}, {"oid": "5ec6a24740809eda740e3c1a7e692b71bb57cdc8", "url": "https://github.com/apache/pinot/commit/5ec6a24740809eda740e3c1a7e692b71bb57cdc8", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-06-02T18:30:58Z", "type": "forcePushed"}, {"oid": "ed42e1cbe87bdc580cea52106506547a0d0bc997", "url": "https://github.com/apache/pinot/commit/ed42e1cbe87bdc580cea52106506547a0d0bc997", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-06-05T22:50:19Z", "type": "commit"}, {"oid": "ed42e1cbe87bdc580cea52106506547a0d0bc997", "url": "https://github.com/apache/pinot/commit/ed42e1cbe87bdc580cea52106506547a0d0bc997", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-06-05T22:50:19Z", "type": "forcePushed"}]}