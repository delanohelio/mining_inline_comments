{"pr_number": 5709, "pr_title": "Store column min/max value into segment metadata", "pr_createdAt": "2020-07-16T05:53:58Z", "pr_url": "https://github.com/apache/pinot/pull/5709", "timeline": [{"oid": "ff6744b1112f155b24674bf800f569b4c8f67c70", "url": "https://github.com/apache/pinot/commit/ff6744b1112f155b24674bf800f569b4c8f67c70", "message": "Store column min/max value into segment metadata", "committedDate": "2020-07-16T05:55:31Z", "type": "commit"}, {"oid": "ff6744b1112f155b24674bf800f569b4c8f67c70", "url": "https://github.com/apache/pinot/commit/ff6744b1112f155b24674bf800f569b4c8f67c70", "message": "Store column min/max value into segment metadata", "committedDate": "2020-07-16T05:55:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMjI4OQ==", "url": "https://github.com/apache/pinot/pull/5709#discussion_r455902289", "bodyText": "Since this is only escaping line character, so may be it should be name escapeLineCharacter?", "author": "mayankshriv", "createdAt": "2020-07-16T16:08:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -509,71 +509,61 @@ public static void addColumnMetadataInfo(PropertiesConfiguration properties, Str\n     properties.setProperty(getKeyFor(column, HAS_NULL_VALUE), String.valueOf(columnIndexCreationInfo.hasNulls()));\n     properties.setProperty(getKeyFor(column, HAS_DICTIONARY), String.valueOf(hasDictionary));\n     properties.setProperty(getKeyFor(column, TEXT_INDEX_TYPE), textIndexType.name());\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, HAS_INVERTED_INDEX),\n-        String.valueOf(hasInvertedIndex));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_SINGLE_VALUED),\n-        String.valueOf(fieldSpec.isSingleValueField()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),\n+    properties.setProperty(getKeyFor(column, HAS_INVERTED_INDEX), String.valueOf(hasInvertedIndex));\n+    properties.setProperty(getKeyFor(column, IS_SINGLE_VALUED), String.valueOf(fieldSpec.isSingleValueField()));\n+    properties.setProperty(getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),\n         String.valueOf(columnIndexCreationInfo.getMaxNumberOfMultiValueElements()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),\n+    properties.setProperty(getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),\n         String.valueOf(columnIndexCreationInfo.getTotalNumberOfEntries()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_AUTO_GENERATED),\n-        String.valueOf(columnIndexCreationInfo.isAutoGenerated()));\n+    properties\n+        .setProperty(getKeyFor(column, IS_AUTO_GENERATED), String.valueOf(columnIndexCreationInfo.isAutoGenerated()));\n \n     PartitionFunction partitionFunction = columnIndexCreationInfo.getPartitionFunction();\n     if (partitionFunction != null) {\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_FUNCTION),\n-          partitionFunction.toString());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, NUM_PARTITIONS),\n-          columnIndexCreationInfo.getNumPartitions());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_VALUES),\n-          columnIndexCreationInfo.getPartitions());\n+      properties.setProperty(getKeyFor(column, PARTITION_FUNCTION), partitionFunction.toString());\n+      properties.setProperty(getKeyFor(column, NUM_PARTITIONS), columnIndexCreationInfo.getNumPartitions());\n+      properties.setProperty(getKeyFor(column, PARTITION_VALUES), columnIndexCreationInfo.getPartitions());\n     }\n \n     // datetime field\n     if (fieldSpec.getFieldType().equals(FieldType.DATE_TIME)) {\n       DateTimeFieldSpec dateTimeFieldSpec = (DateTimeFieldSpec) fieldSpec;\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_FORMAT),\n-          dateTimeFieldSpec.getFormat());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_GRANULARITY),\n-          dateTimeFieldSpec.getGranularity());\n+      properties.setProperty(getKeyFor(column, DATETIME_FORMAT), dateTimeFieldSpec.getFormat());\n+      properties.setProperty(getKeyFor(column, DATETIME_GRANULARITY), dateTimeFieldSpec.getGranularity());\n     }\n \n-    Object defaultNullValue = columnIndexCreationInfo.getDefaultNullValue();\n-    if (defaultNullValue instanceof byte[]) {\n-      String defaultNullValueString = BytesUtils.toHexString((byte[]) defaultNullValue);\n-      properties\n-          .setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValueString);\n+    String minValue = columnIndexCreationInfo.getMin().toString();\n+    String maxValue = columnIndexCreationInfo.getMax().toString();\n+    String defaultNullValue = columnIndexCreationInfo.getDefaultNullValue().toString();\n+    if (dataType == DataType.STRING) {\n+      // Escape special character for STRING column\n+      properties.setProperty(getKeyFor(column, MIN_VALUE), escapeSpecialCharacter(minValue));\n+      properties.setProperty(getKeyFor(column, MAX_VALUE), escapeSpecialCharacter(maxValue));\n+      properties.setProperty(getKeyFor(column, DEFAULT_NULL_VALUE), escapeSpecialCharacter(defaultNullValue));\n     } else {\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE),\n-          String.valueOf(defaultNullValue));\n+      properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n+      properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+      properties.setProperty(getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValue);\n     }\n   }\n \n   public static void addColumnMinMaxValueInfo(PropertiesConfiguration properties, String column, String minValue,\n       String maxValue) {\n-    properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n-    properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+    // Escape special character for STRING column\n+    properties.setProperty(getKeyFor(column, MIN_VALUE), escapeSpecialCharacter(minValue));\n+    properties.setProperty(getKeyFor(column, MAX_VALUE), escapeSpecialCharacter(maxValue));\n+  }\n+\n+  /**\n+   * Helper method to escape special character for the property value.\n+   */\n+  private static String escapeSpecialCharacter(String value) {", "originalCommit": "ff6744b1112f155b24674bf800f569b4c8f67c70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1NTIwOA==", "url": "https://github.com/apache/pinot/pull/5709#discussion_r455955208", "bodyText": "Renamed to escapeListSeparator", "author": "Jackie-Jiang", "createdAt": "2020-07-16T17:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMjI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2Mzc0OQ==", "url": "https://github.com/apache/pinot/pull/5709#discussion_r455963749", "bodyText": "Why are we escaping commas?\nAlso, if we escape commas, don't we need to unescape them when reading the metadata back?", "author": "mcvsubbu", "createdAt": "2020-07-16T17:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMjI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNDY3MA==", "url": "https://github.com/apache/pinot/pull/5709#discussion_r456134670", "bodyText": "PropertiesConfiguration is handling the escape while writing and unescape while reading, but it cannot handle leading/trailing whitespace and list separator properly.\nAdded a test and found out that there is no way to handle all scenarios. Change the logic to not storing the value if PropertiesConfiguration is not able to read the original value back.", "author": "Jackie-Jiang", "createdAt": "2020-07-16T23:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMjI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNTMzNQ==", "url": "https://github.com/apache/pinot/pull/5709#discussion_r455905335", "bodyText": "How about no-dictionary columns? We do go over all the values, so we should be able to compute that information even without dictionary?", "author": "mayankshriv", "createdAt": "2020-07-16T16:12:29Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/columnminmaxvalue/ColumnMinMaxValueGenerator.java", "diffHunk": "@@ -91,33 +92,46 @@ private void addColumnMinMaxValueForColumn(String columnName) throws Exception {\n     switch (dataType) {\n       case INT:\n         try (IntDictionary intDictionary = new IntDictionary(dictionaryBuffer, length)) {\n-          SegmentColumnarIndexCreator.addColumnMinMaxValueInfo(_segmentProperties, columnName,\n-              intDictionary.getStringValue(0), intDictionary.getStringValue(length - 1));\n+          SegmentColumnarIndexCreator", "originalCommit": "ff6744b1112f155b24674bf800f569b4c8f67c70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2NTY3NQ==", "url": "https://github.com/apache/pinot/pull/5709#discussion_r455965675", "bodyText": "The ColumnMinMaxValueGenerator is on server side (one of the pre-processors) generating column min/max value on the fly during segment load. We might not want to pay the cost of scanning all the values during segment load, so I kept the existing behavior.\nThe segment creation part is handled in SegmentColumnarIndexCreator where min/max values are added for both dictionary-encoded and raw index.", "author": "Jackie-Jiang", "createdAt": "2020-07-16T17:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNDQ4Mw==", "url": "https://github.com/apache/pinot/pull/5709#discussion_r455934483", "bodyText": "This was essentially setting the min and max value in SegmentMetadata right? It is then used in the code during pruning etc by deserializing into ColumnMetadata. May be I am missing something here?", "author": "siddharthteotia", "createdAt": "2020-07-16T16:59:07Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -509,71 +509,61 @@ public static void addColumnMetadataInfo(PropertiesConfiguration properties, Str\n     properties.setProperty(getKeyFor(column, HAS_NULL_VALUE), String.valueOf(columnIndexCreationInfo.hasNulls()));\n     properties.setProperty(getKeyFor(column, HAS_DICTIONARY), String.valueOf(hasDictionary));\n     properties.setProperty(getKeyFor(column, TEXT_INDEX_TYPE), textIndexType.name());\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, HAS_INVERTED_INDEX),\n-        String.valueOf(hasInvertedIndex));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_SINGLE_VALUED),\n-        String.valueOf(fieldSpec.isSingleValueField()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),\n+    properties.setProperty(getKeyFor(column, HAS_INVERTED_INDEX), String.valueOf(hasInvertedIndex));\n+    properties.setProperty(getKeyFor(column, IS_SINGLE_VALUED), String.valueOf(fieldSpec.isSingleValueField()));\n+    properties.setProperty(getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),\n         String.valueOf(columnIndexCreationInfo.getMaxNumberOfMultiValueElements()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),\n+    properties.setProperty(getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),\n         String.valueOf(columnIndexCreationInfo.getTotalNumberOfEntries()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_AUTO_GENERATED),\n-        String.valueOf(columnIndexCreationInfo.isAutoGenerated()));\n+    properties\n+        .setProperty(getKeyFor(column, IS_AUTO_GENERATED), String.valueOf(columnIndexCreationInfo.isAutoGenerated()));\n \n     PartitionFunction partitionFunction = columnIndexCreationInfo.getPartitionFunction();\n     if (partitionFunction != null) {\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_FUNCTION),\n-          partitionFunction.toString());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, NUM_PARTITIONS),\n-          columnIndexCreationInfo.getNumPartitions());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_VALUES),\n-          columnIndexCreationInfo.getPartitions());\n+      properties.setProperty(getKeyFor(column, PARTITION_FUNCTION), partitionFunction.toString());\n+      properties.setProperty(getKeyFor(column, NUM_PARTITIONS), columnIndexCreationInfo.getNumPartitions());\n+      properties.setProperty(getKeyFor(column, PARTITION_VALUES), columnIndexCreationInfo.getPartitions());\n     }\n \n     // datetime field\n     if (fieldSpec.getFieldType().equals(FieldType.DATE_TIME)) {\n       DateTimeFieldSpec dateTimeFieldSpec = (DateTimeFieldSpec) fieldSpec;\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_FORMAT),\n-          dateTimeFieldSpec.getFormat());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_GRANULARITY),\n-          dateTimeFieldSpec.getGranularity());\n+      properties.setProperty(getKeyFor(column, DATETIME_FORMAT), dateTimeFieldSpec.getFormat());\n+      properties.setProperty(getKeyFor(column, DATETIME_GRANULARITY), dateTimeFieldSpec.getGranularity());\n     }\n \n-    Object defaultNullValue = columnIndexCreationInfo.getDefaultNullValue();\n-    if (defaultNullValue instanceof byte[]) {\n-      String defaultNullValueString = BytesUtils.toHexString((byte[]) defaultNullValue);\n-      properties\n-          .setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValueString);\n+    String minValue = columnIndexCreationInfo.getMin().toString();\n+    String maxValue = columnIndexCreationInfo.getMax().toString();\n+    String defaultNullValue = columnIndexCreationInfo.getDefaultNullValue().toString();\n+    if (dataType == DataType.STRING) {\n+      // Escape special character for STRING column\n+      properties.setProperty(getKeyFor(column, MIN_VALUE), escapeSpecialCharacter(minValue));\n+      properties.setProperty(getKeyFor(column, MAX_VALUE), escapeSpecialCharacter(maxValue));\n+      properties.setProperty(getKeyFor(column, DEFAULT_NULL_VALUE), escapeSpecialCharacter(defaultNullValue));\n     } else {\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE),\n-          String.valueOf(defaultNullValue));\n+      properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n+      properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+      properties.setProperty(getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValue);\n     }\n   }\n \n   public static void addColumnMinMaxValueInfo(PropertiesConfiguration properties, String column, String minValue,", "originalCommit": "ff6744b1112f155b24674bf800f569b4c8f67c70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2ODkwNw==", "url": "https://github.com/apache/pinot/pull/5709#discussion_r455968907", "bodyText": "Yes, the metadata will be stored into SegmentMetadata. ColumnMetadata is part of the SegmentMetadata. The min/max value inside the DataSourceMetadata are coming from there.", "author": "Jackie-Jiang", "createdAt": "2020-07-16T17:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNDQ4Mw=="}], "type": "inlineReview"}, {"oid": "54b50da643c09418a0b06f6cd406d17473cdd49f", "url": "https://github.com/apache/pinot/commit/54b50da643c09418a0b06f6cd406d17473cdd49f", "message": "Address comments", "committedDate": "2020-07-16T23:26:53Z", "type": "forcePushed"}, {"oid": "50a0d49d19a2a78e5938b10d0d35578e0f5bdb25", "url": "https://github.com/apache/pinot/commit/50a0d49d19a2a78e5938b10d0d35578e0f5bdb25", "message": "Address comments", "committedDate": "2020-07-17T00:00:49Z", "type": "forcePushed"}, {"oid": "d7c2f04a99c3d2c587f1ffae289400eaa402defa", "url": "https://github.com/apache/pinot/commit/d7c2f04a99c3d2c587f1ffae289400eaa402defa", "message": "Address comments", "committedDate": "2020-07-17T00:31:12Z", "type": "commit"}, {"oid": "d7c2f04a99c3d2c587f1ffae289400eaa402defa", "url": "https://github.com/apache/pinot/commit/d7c2f04a99c3d2c587f1ffae289400eaa402defa", "message": "Address comments", "committedDate": "2020-07-17T00:31:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE1ODg5MA==", "url": "https://github.com/apache/pinot/pull/5709#discussion_r456158890", "bodyText": "Not sure how we find out that these are the only comprehensive rules", "author": "siddharthteotia", "createdAt": "2020-07-17T00:56:09Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -509,71 +510,83 @@ public static void addColumnMetadataInfo(PropertiesConfiguration properties, Str\n     properties.setProperty(getKeyFor(column, HAS_NULL_VALUE), String.valueOf(columnIndexCreationInfo.hasNulls()));\n     properties.setProperty(getKeyFor(column, HAS_DICTIONARY), String.valueOf(hasDictionary));\n     properties.setProperty(getKeyFor(column, TEXT_INDEX_TYPE), textIndexType.name());\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, HAS_INVERTED_INDEX),\n-        String.valueOf(hasInvertedIndex));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_SINGLE_VALUED),\n-        String.valueOf(fieldSpec.isSingleValueField()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),\n+    properties.setProperty(getKeyFor(column, HAS_INVERTED_INDEX), String.valueOf(hasInvertedIndex));\n+    properties.setProperty(getKeyFor(column, IS_SINGLE_VALUED), String.valueOf(fieldSpec.isSingleValueField()));\n+    properties.setProperty(getKeyFor(column, MAX_MULTI_VALUE_ELEMTS),\n         String.valueOf(columnIndexCreationInfo.getMaxNumberOfMultiValueElements()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),\n+    properties.setProperty(getKeyFor(column, TOTAL_NUMBER_OF_ENTRIES),\n         String.valueOf(columnIndexCreationInfo.getTotalNumberOfEntries()));\n-    properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, IS_AUTO_GENERATED),\n-        String.valueOf(columnIndexCreationInfo.isAutoGenerated()));\n+    properties\n+        .setProperty(getKeyFor(column, IS_AUTO_GENERATED), String.valueOf(columnIndexCreationInfo.isAutoGenerated()));\n \n     PartitionFunction partitionFunction = columnIndexCreationInfo.getPartitionFunction();\n     if (partitionFunction != null) {\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_FUNCTION),\n-          partitionFunction.toString());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, NUM_PARTITIONS),\n-          columnIndexCreationInfo.getNumPartitions());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, PARTITION_VALUES),\n-          columnIndexCreationInfo.getPartitions());\n+      properties.setProperty(getKeyFor(column, PARTITION_FUNCTION), partitionFunction.toString());\n+      properties.setProperty(getKeyFor(column, NUM_PARTITIONS), columnIndexCreationInfo.getNumPartitions());\n+      properties.setProperty(getKeyFor(column, PARTITION_VALUES), columnIndexCreationInfo.getPartitions());\n     }\n \n     // datetime field\n     if (fieldSpec.getFieldType().equals(FieldType.DATE_TIME)) {\n       DateTimeFieldSpec dateTimeFieldSpec = (DateTimeFieldSpec) fieldSpec;\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_FORMAT),\n-          dateTimeFieldSpec.getFormat());\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DATETIME_GRANULARITY),\n-          dateTimeFieldSpec.getGranularity());\n+      properties.setProperty(getKeyFor(column, DATETIME_FORMAT), dateTimeFieldSpec.getFormat());\n+      properties.setProperty(getKeyFor(column, DATETIME_GRANULARITY), dateTimeFieldSpec.getGranularity());\n     }\n \n-    Object defaultNullValue = columnIndexCreationInfo.getDefaultNullValue();\n-    if (defaultNullValue instanceof byte[]) {\n-      String defaultNullValueString = BytesUtils.toHexString((byte[]) defaultNullValue);\n-      properties\n-          .setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValueString);\n+    String minValue = columnIndexCreationInfo.getMin().toString();\n+    String maxValue = columnIndexCreationInfo.getMax().toString();\n+    String defaultNullValue = columnIndexCreationInfo.getDefaultNullValue().toString();\n+    if (dataType == DataType.STRING) {\n+      // Check special characters for STRING column\n+      if (isValidPropertyValue(minValue)) {\n+        properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n+      }\n+      if (isValidPropertyValue(maxValue)) {\n+        properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+      }\n+      if (isValidPropertyValue(defaultNullValue)) {\n+        properties.setProperty(getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValue);\n+      }\n     } else {\n-      properties.setProperty(V1Constants.MetadataKeys.Column.getKeyFor(column, DEFAULT_NULL_VALUE),\n-          String.valueOf(defaultNullValue));\n+      properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n+      properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+      properties.setProperty(getKeyFor(column, DEFAULT_NULL_VALUE), defaultNullValue);\n     }\n   }\n \n   public static void addColumnMinMaxValueInfo(PropertiesConfiguration properties, String column, String minValue,\n       String maxValue) {\n-    properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n-    properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+    // Check special characters for STRING column\n+    if (isValidPropertyValue(minValue)) {\n+      properties.setProperty(getKeyFor(column, MIN_VALUE), minValue);\n+    }\n+    if (isValidPropertyValue(maxValue)) {\n+      properties.setProperty(getKeyFor(column, MAX_VALUE), maxValue);\n+    }\n+  }\n+\n+  /**\n+   * Helper method to check whether the given value is a valid property value.\n+   * <p>Value is invalid iff:\n+   * <ul>", "originalCommit": "d7c2f04a99c3d2c587f1ffae289400eaa402defa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE2OTYxMA==", "url": "https://github.com/apache/pinot/pull/5709#discussion_r456169610", "bodyText": "In SegmentColumnarIndexCreatorTest.testPropertyValueWithSpecialCharacters(), generating random strings to verify that the same string can be retrieved", "author": "Jackie-Jiang", "createdAt": "2020-07-17T01:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE1ODg5MA=="}], "type": "inlineReview"}]}