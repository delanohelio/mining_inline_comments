{"pr_number": 1108, "pr_title": "Evolve BrokerCapacityConfigResolver interface to be aware whether capacity estimation is allowed or not in broker capacity resolution.", "pr_createdAt": "2020-02-18T19:44:16Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1108", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODQ1OA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382308458", "bodyText": "If allowBrokerCapacityEstimation is false, then wouldn't node shuffling be redundant?", "author": "efeg", "createdAt": "2020-02-20T23:04:46Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java", "diffHunk": "@@ -517,7 +523,8 @@ public ClusterModel clusterModel(long from,\n         clusterModel.createRack(rack);\n         BrokerCapacityInfo brokerCapacity;\n         try {\n-          brokerCapacity = _brokerCapacityConfigResolver.capacityForBroker(rack, node.host(), node.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n+          brokerCapacity = _brokerCapacityConfigResolver.capacityForBroker(rack, node.host(), node.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS,", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNTk1Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382325956", "bodyText": "Nit: Long line. I will update the checkstyle to make our check more strict -- e.g. from 160 to a more reasonable value.", "author": "efeg", "createdAt": "2020-02-20T23:54:53Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java", "diffHunk": "@@ -255,14 +255,15 @@ public BrokerStats cachedBrokerLoadStats(boolean allowCapacityEstimation) {\n   /**\n    * Get the cluster model cutting off at the current timestamp.\n    * @param requirements the model completeness requirements.\n+   * @param allowBrokerCapacityEstimation Whether allow broker capacity resolver to estimate broker capacity.\n    * @param operationProgress the progress of the job to report.\n    * @return The cluster workload model.\n    * @throws NotEnoughValidWindowsException If there is not enough sample to generate cluster model.\n    * @throws TimeoutException If broker capacity resolver is unable to resolve broker capacity.\n    */\n-  public ClusterModel clusterModel(ModelCompletenessRequirements requirements, OperationProgress operationProgress)\n+  public ClusterModel clusterModel(ModelCompletenessRequirements requirements, Boolean allowBrokerCapacityEstimation, OperationProgress operationProgress)", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyODUyNw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382328527", "bodyText": "Why do we prefer a Boolean for allowBrokerCapacityEstimation rather than a boolean -- i.e. is null parameter value allowed here?", "author": "efeg", "createdAt": "2020-02-21T00:03:21Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java", "diffHunk": "@@ -255,14 +255,15 @@ public BrokerStats cachedBrokerLoadStats(boolean allowCapacityEstimation) {\n   /**\n    * Get the cluster model cutting off at the current timestamp.\n    * @param requirements the model completeness requirements.\n+   * @param allowBrokerCapacityEstimation Whether allow broker capacity resolver to estimate broker capacity.\n    * @param operationProgress the progress of the job to report.\n    * @return The cluster workload model.\n    * @throws NotEnoughValidWindowsException If there is not enough sample to generate cluster model.\n    * @throws TimeoutException If broker capacity resolver is unable to resolve broker capacity.\n    */\n-  public ClusterModel clusterModel(ModelCompletenessRequirements requirements, OperationProgress operationProgress)\n+  public ClusterModel clusterModel(ModelCompletenessRequirements requirements, Boolean allowBrokerCapacityEstimation, OperationProgress operationProgress)", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyOTU3Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382329573", "bodyText": "Can we ensure that the JavaDoc indicates the expected return value if allowCapacityEstimation is false and the resolver fails to resolve the capacity?\n\nIf in this case the call throws an exception, I am not sure if TimeoutException would be the right one. Should it instead return an exception that extends from KafkaCruiseControlException -- e.g. CapacityResolutionException?\nAlternatively, (and maybe more preferably) the call can return a special BrokerCapacityInfo that indicates unresolvable broker capacity. The calling logic then identify this response, and use it in case it is acceptable to do so -- e.g. for dead broker capacity.", "author": "efeg", "createdAt": "2020-02-21T00:07:00Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java", "diffHunk": "@@ -30,8 +30,11 @@\n    * @param host The host of the broker\n    * @param brokerId The id of the broker\n    * @param timeoutMs The timeout in millisecond.\n+   * @param allowCapacityEstimation Whether allow resolver to estimate broker capacity if resolver is unable to get", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1OTU5Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382759592", "bodyText": "Discuss offline, we will create a new BrokerCapacityResolvingException type to represent capacity resolving failure.", "author": "kidkun", "createdAt": "2020-02-21T19:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyOTU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMDQ1Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382330452", "bodyText": "The JavaDoc seems to describe the internals of BrokerCapacityInfo -- can we move the relevant information to the JavaDoc of BrokerCapacityInfo and refer to it from this JavaDoc via a link?", "author": "efeg", "createdAt": "2020-02-21T00:10:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java", "diffHunk": "@@ -30,8 +30,11 @@\n    * @param host The host of the broker\n    * @param brokerId The id of the broker\n    * @param timeoutMs The timeout in millisecond.\n+   * @param allowCapacityEstimation Whether allow resolver to estimate broker capacity if resolver is unable to get\n+   *                                capacity information of the broker.", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMjEzNA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382332134", "bodyText": "[Applies globally] Can we use consistent (1) name and (2) JavaDoc description for this parameter across the code base -- i.e.\nname: allowBrokerCapacityEstimation -> allowCapacityEstimation?\ndoc: Allow capacity estimation in cluster model if the underlying live broker capacity is unavailable.", "author": "efeg", "createdAt": "2020-02-21T00:16:08Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java", "diffHunk": "@@ -255,14 +255,15 @@ public BrokerStats cachedBrokerLoadStats(boolean allowCapacityEstimation) {\n   /**\n    * Get the cluster model cutting off at the current timestamp.\n    * @param requirements the model completeness requirements.\n+   * @param allowBrokerCapacityEstimation Whether allow broker capacity resolver to estimate broker capacity.", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNTY0Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382335643", "bodyText": "Can we avoid passing a local variable to a method of this class?", "author": "efeg", "createdAt": "2020-02-21T00:29:01Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java", "diffHunk": "@@ -151,28 +152,35 @@\n   private static final String NUM_CORES_CONFIG = \"num.cores\";\n   public static final double DEFAULT_CPU_CAPACITY_WITH_CORES = 100.0;\n   private static Map<Integer, BrokerCapacityInfo> _capacitiesForBrokers;\n+  private String _configFile;\n \n   @Override\n   public void configure(Map<String, ?> configs) {\n-    String configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n+    _configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n     try {\n-      loadCapacities(configFile);\n+      loadCapacities(_configFile);", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNjI0Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382336243", "bodyText": "Either allow capacity estimation -> in this case, shouldn't the users also ensure that the broker has a default capacity as defined via broker id -1?", "author": "efeg", "createdAt": "2020-02-21T00:31:13Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java", "diffHunk": "@@ -151,28 +152,35 @@\n   private static final String NUM_CORES_CONFIG = \"num.cores\";\n   public static final double DEFAULT_CPU_CAPACITY_WITH_CORES = 100.0;\n   private static Map<Integer, BrokerCapacityInfo> _capacitiesForBrokers;\n+  private String _configFile;\n \n   @Override\n   public void configure(Map<String, ?> configs) {\n-    String configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n+    _configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n     try {\n-      loadCapacities(configFile);\n+      loadCapacities(_configFile);\n     } catch (FileNotFoundException e) {\n       throw new IllegalArgumentException(e);\n     }\n   }\n \n   @Override\n-  public BrokerCapacityInfo capacityForBroker(String rack, String host, int brokerId, long timeoutMs) {\n+  public BrokerCapacityInfo capacityForBroker(String rack, String host, int brokerId, long timeoutMs, boolean allowCapacityEstimation)\n+      throws TimeoutException {\n     if (brokerId >= 0) {\n       BrokerCapacityInfo capacity = _capacitiesForBrokers.get(brokerId);\n       if (capacity != null) {\n         return capacity;\n       } else {\n-        String info = String.format(\"Missing broker id(%d) in capacity config file.\", brokerId);\n-        return new BrokerCapacityInfo(_capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).capacity(), info,\n-                                      _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n-                                      _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n+        if (allowCapacityEstimation) {\n+          String info = String.format(\"Missing broker id(%d) in capacity config file.\", brokerId);\n+          return new BrokerCapacityInfo(_capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).capacity(), info,\n+                                        _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n+                                        _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n+        } else {\n+          throw new TimeoutException(String.format(\"Unable to resolve capacity of broker %d. Either allow capacity estimation \"", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1NTIzOA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382355238", "bodyText": "Shouldn't this logic be handled in this layer?  -- i.e. why don't we pass allowBrokerCapacityEstimation rather than aliveBrokers.contains(replica.id()) && allowBrokerCapacityEstimation?\n(please see the previous comment on potentially returning a special broker capacity response for unresolveable broker capacity).", "author": "efeg", "createdAt": "2020-02-21T01:41:17Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -463,7 +465,9 @@ static void populatePartitionLoad(Cluster cluster,\n         String rack = getRackHandleNull(replica);\n         BrokerCapacityInfo brokerCapacity;\n         try {\n-          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n+          // Do not allow capacity estimation for dead brokers.\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS,\n+                                                                          aliveBrokers.contains(replica.id()) && allowBrokerCapacityEstimation);", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1NjE3Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382356177", "bodyText": "Not sure if TimeoutException is correct/sufficient exception here in case the capacity cannot be resolved due to not allowing CPU capacity estimation.", "author": "efeg", "createdAt": "2020-02-21T01:45:19Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java", "diffHunk": "@@ -82,9 +82,9 @@ private void updateCachedNumCoresByBroker(Cluster cluster) {\n         }\n         try {\n           BrokerCapacityInfo capacity =\n-              _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid, BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n-          // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n-          return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+              _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid, BROKER_CAPACITY_FETCH_TIMEOUT_MS,\n+                                                              _allowCpuCapacityEstimation);\n+          return capacity.numCpuCores();", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1NzM4OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382357389", "bodyText": "Can we add the relevant test cases to ensure correct functionality when allow capacity estimation is false and the capacity cannot be resolved for (1) dead brokers and (2) alive brokers?", "author": "efeg", "createdAt": "2020-02-21T01:49:26Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolverTest.java", "diffHunk": "@@ -35,52 +35,52 @@ private static BrokerCapacityConfigResolver getBrokerCapacityConfigResolver(Stri\n   public void testParseConfigFile() throws TimeoutException {\n     BrokerCapacityConfigResolver configResolver = getBrokerCapacityConfigResolver(\"testCapacityConfig.json\", this.getClass());\n \n-    assertEquals(200000.0, configResolver.capacityForBroker(\"\", \"\", 0, BROKER_CAPACITY_FETCH_TIMEOUT_MS)\n+    assertEquals(200000.0, configResolver.capacityForBroker(\"\", \"\", 0, BROKER_CAPACITY_FETCH_TIMEOUT_MS, false)", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1Nzg1Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382357856", "bodyText": "Can we verify (via test cases) that the anomaly detectors behave as expected if capacity estimation is disabled (i.e. the default behavior) and capacity resolver cannot resolve capacity of (1) dead brokers, (2) alive brokers, and (3) a mix of dead/alive brokers.", "author": "efeg", "createdAt": "2020-02-21T01:51:19Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetectorTest.java", "diffHunk": "@@ -293,7 +293,7 @@ private void testFixAnomaly(AnomalyType anomalyType)\n       EasyMock.expect(mockAnomalyNotifier.onGoalViolation(EasyMock.isA(GoalViolations.class))).andReturn(AnomalyNotificationResult.fix());\n     } else if (anomalyType == KafkaAnomalyType.DISK_FAILURE) {\n       ClusterModel singleBrokerWithBadDisk = singleBrokerWithBadDisk();\n-      EasyMock.expect(mockKafkaCruiseControl.clusterModel(EasyMock.anyObject(), EasyMock.anyObject())).andReturn(singleBrokerWithBadDisk);\n+      EasyMock.expect(mockKafkaCruiseControl.clusterModel(EasyMock.anyObject(), EasyMock.anyObject(), EasyMock.anyObject())).andReturn(singleBrokerWithBadDisk);", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgwNTkyOQ==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382805929", "bodyText": "I feel these scenario is specific to LoadMonitor, I prefer to add check in LoadMonitorTest, this test should focus on how detector react to different anomalies.", "author": "kidkun", "createdAt": "2020-02-21T21:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1Nzg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1ODI1MQ==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382358251", "bodyText": "Should we add test cases for allow capacity is false for load monitor?", "author": "efeg", "createdAt": "2020-02-21T01:52:54Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitorTest.java", "diffHunk": "@@ -250,6 +250,7 @@ public void testBasicClusterModel() throws NotEnoughValidWindowsException, Timeo\n \n     ClusterModel clusterModel = loadMonitor.clusterModel(-1, Long.MAX_VALUE,\n                                                          new ModelCompletenessRequirements(2, 1.0, false),\n+                                                         true,", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1OTE0Mg==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r382359142", "bodyText": "Getting a TimeoutException here seems a little non-intuitive -- should we adopt one of the approaches in the previous discussion?", "author": "efeg", "createdAt": "2020-02-21T01:56:31Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessorTest.java", "diffHunk": "@@ -129,8 +130,8 @@ public void testWithCpuCapacityEstimation() throws TimeoutException {\n     // All estimated.\n     BrokerCapacityConfigResolver brokerCapacityConfigResolverAllEstimated = EasyMock.mock(BrokerCapacityConfigResolver.class);\n     EasyMock.expect(brokerCapacityConfigResolverAllEstimated.capacityForBroker(EasyMock.anyString(), EasyMock.anyString(),\n-                                                                               EasyMock.anyInt(), EasyMock.anyLong()))\n-            .andReturn(new BrokerCapacityInfo(EMPTY_BROKER_CAPACITY, \"All estimated\", Collections.emptyMap(), MOCK_NUM_CPU_CORES)).anyTimes();\n+                                                                               EasyMock.anyInt(), EasyMock.anyLong(), EasyMock.eq(false)))\n+            .andThrow(new TimeoutException(\"Unable to resolve capacity.\")).anyTimes();", "originalCommit": "c84af32fcc96d1c4d026e8e4dd5aac54bb8ace6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3b3fe9b180220c58c210f3735e1fe73161c6cfc6", "url": "https://github.com/linkedin/cruise-control/commit/3b3fe9b180220c58c210f3735e1fe73161c6cfc6", "message": "Improve broker capacity estimation.", "committedDate": "2020-02-21T23:36:09Z", "type": "commit"}, {"oid": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "url": "https://github.com/linkedin/cruise-control/commit/edea6da765dc7e1c227086175da9ff1cf1dbd14f", "message": "Address the feedback.", "committedDate": "2020-02-21T23:36:09Z", "type": "commit"}, {"oid": "751e4f26076b5a8edd8f0ca9a538230d1f01feb5", "url": "https://github.com/linkedin/cruise-control/commit/751e4f26076b5a8edd8f0ca9a538230d1f01feb5", "message": "Fix build failure.", "committedDate": "2020-02-21T23:36:09Z", "type": "commit"}, {"oid": "751e4f26076b5a8edd8f0ca9a538230d1f01feb5", "url": "https://github.com/linkedin/cruise-control/commit/751e4f26076b5a8edd8f0ca9a538230d1f01feb5", "message": "Fix build failure.", "committedDate": "2020-02-21T23:36:09Z", "type": "forcePushed"}, {"oid": "34ce3f6af2f599682715c2e89a0b21c6b5ce0e88", "url": "https://github.com/linkedin/cruise-control/commit/34ce3f6af2f599682715c2e89a0b21c6b5ce0e88", "message": "Fix build failue.", "committedDate": "2020-02-21T23:41:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3OTcxMw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383579713", "bodyText": "(Applies globally to the similar usages in JavaDoc) TimeoutException is underdefined.", "author": "efeg", "createdAt": "2020-02-24T23:41:42Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControl.java", "diffHunk": "@@ -256,15 +257,18 @@ public BrokerStats cachedBrokerLoadStats(boolean allowCapacityEstimation) {\n   /**\n    * Get the cluster model cutting off at the current timestamp.\n    * @param requirements the model completeness requirements.\n-   * @param allowBrokerCapacityEstimation Whether allow broker capacity resolver to estimate broker capacity.\n+   * @param allowCapacityEstimation whether allow capacity estimation in cluster model if the underlying live broker capacity is unavailable.\n    * @param operationProgress the progress of the job to report.\n    * @return The cluster workload model.\n    * @throws NotEnoughValidWindowsException If there is not enough sample to generate cluster model.\n    * @throws TimeoutException If broker capacity resolver is unable to resolve broker capacity.\n+   * @throws BrokerCapacityResolvingException If broker capacity resolver fails to resolve broker capacity.", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MTk2NA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383591964", "bodyText": "Nit: %d.Either -> %d. Either", "author": "efeg", "createdAt": "2020-02-25T00:21:00Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java", "diffHunk": "@@ -178,8 +179,9 @@ public BrokerCapacityInfo capacityForBroker(String rack, String host, int broker\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n         } else {\n-          throw new TimeoutException(String.format(\"Unable to resolve capacity of broker %d. Either allow capacity estimation \"\n-                                                   + \"or add broker's capacity information in file %s.\", brokerId, _configFile));\n+          throw new BrokerCapacityResolvingException(String.format(\"Unable to resolve capacity of broker %d.Either (1) adding the \"", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjE4OQ==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383592189", "bodyText": "Missing closing parenthesis.", "author": "efeg", "createdAt": "2020-02-25T00:21:39Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java", "diffHunk": "@@ -178,8 +179,9 @@ public BrokerCapacityInfo capacityForBroker(String rack, String host, int broker\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n         } else {\n-          throw new TimeoutException(String.format(\"Unable to resolve capacity of broker %d. Either allow capacity estimation \"\n-                                                   + \"or add broker's capacity information in file %s.\", brokerId, _configFile));\n+          throw new BrokerCapacityResolvingException(String.format(\"Unable to resolve capacity of broker %d.Either (1) adding the \"\n+              + \"default broker capacity (via adding capacity for broker %d and allowing capacity estimation or (2) add missing \"", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjY5Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383592696", "bodyText": "Inconsistent use of add and adding\nshould we reformat it as -> Either add (1) XXX, or (2) YYY.", "author": "efeg", "createdAt": "2020-02-25T00:23:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java", "diffHunk": "@@ -178,8 +179,9 @@ public BrokerCapacityInfo capacityForBroker(String rack, String host, int broker\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).diskCapacityByLogDir(),\n                                         _capacitiesForBrokers.get(DEFAULT_CAPACITY_BROKER_ID).numCpuCores());\n         } else {\n-          throw new TimeoutException(String.format(\"Unable to resolve capacity of broker %d. Either allow capacity estimation \"\n-                                                   + \"or add broker's capacity information in file %s.\", brokerId, _configFile));\n+          throw new BrokerCapacityResolvingException(String.format(\"Unable to resolve capacity of broker %d.Either (1) adding the \"", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5Mjg1MA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383592850", "bodyText": "Nit: -> An instance", "author": "efeg", "createdAt": "2020-02-25T00:23:52Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java", "diffHunk": "@@ -32,9 +25,10 @@\n    * @param timeoutMs The timeout in millisecond.\n    * @param allowCapacityEstimation Whether allow resolver to estimate broker capacity if resolver is unable to get\n    *                                capacity information of the broker.\n-   * @return The capacity of each resource for the broker\n+   * @return A instance of {@link BrokerCapacityInfo}.", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MzAwMw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383593003", "bodyText": "Nit: encapsulate -> encapsulating", "author": "efeg", "createdAt": "2020-02-25T00:24:24Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java", "diffHunk": "@@ -10,6 +10,17 @@\n import java.util.stream.Collectors;\n \n \n+/**\n+ * A class encapsulate the capacity information of a broker, which includes all the resources defined in {@link Resource}.", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MzM5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383593393", "bodyText": "Nit: BrokerCapacityResolvingException -> CapacityResolutionException or BrokerCapacityResolutionException", "author": "efeg", "createdAt": "2020-02-25T00:25:48Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/exception/BrokerCapacityResolvingException.java", "diffHunk": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.exception;\n+\n+/**\n+ * The exception indicating something went wrong during the broker capacity resolving.\n+ */\n+public class BrokerCapacityResolvingException extends KafkaCruiseControlException {", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5NDAwMA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383594000", "bodyText": "Do we even need to create a new ArrayList in case allowCapacityEstimation is false?", "author": "efeg", "createdAt": "2020-02-25T00:27:42Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java", "diffHunk": "@@ -506,32 +510,34 @@ public ClusterModel clusterModel(long from,\n     final Timer.Context ctx = _clusterModelCreationTimer.time();\n     try {\n       // Create the racks and brokers.\n-      // Shuffle nodes before getting their capacity from the capacity resolver.\n-      // This enables a capacity resolver to estimate the capacity of the nodes, for which the capacity retrieval has\n-      // failed.\n+      // If broker capacity is allowed to estimate broker capacity, shuffle nodes before getting their capacity from the\n+      // capacity resolver. This is good for the capacity resolver to estimate the capacity of the nodes, for which the\n+      // capacity retrieval has failed.\n       // The use case for this estimation is that if the capacity of one of the nodes is not available (e.g. due to some\n       // 3rd party service issue), the capacity resolver may want to use the capacity of a peer node as the capacity for\n       // that node.\n       // To this end, Cruise Control handles the case that the first node is problematic so the capacity resolver does\n       // not have the chance to get the capacity for the other nodes.\n       // Shuffling the node order helps, as the problematic node is unlikely to always be the first node in the list.\n       List<Node> shuffledNodes = new ArrayList<>(cluster.nodes());", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5NjEwNw==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383596107", "bodyText": "Sorry if my previous comment was not clear -- let me rephrase my question:\n\nWhy are we passing a parameter to loadCapacities function? This is a local private function and we already have the value assigned to _configFile. Is it possible to modify loadCapacities to have no parameter and use _configFile in its implementation?", "author": "efeg", "createdAt": "2020-02-25T00:34:54Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolver.java", "diffHunk": "@@ -156,17 +156,18 @@\n \n   @Override\n   public void configure(Map<String, ?> configs) {\n-    _configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n+    String configFile = KafkaCruiseControlUtils.getRequiredConfig(configs, CAPACITY_CONFIG_FILE);\n+    _configFile = configFile;\n     try {\n-      loadCapacities(_configFile);\n+      loadCapacities(configFile);", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5NzIyNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383597225", "bodyText": "Nit: an BrokerCapacityResolvingException -> a BrokerCapacityResolvingException", "author": "efeg", "createdAt": "2020-02-25T00:38:53Z", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigFileResolverTest.java", "diffHunk": "@@ -48,10 +49,13 @@ public void testParseConfigFile() throws TimeoutException {\n \n     assertTrue(configResolver.capacityForBroker(\"\", \"\", 2, BROKER_CAPACITY_FETCH_TIMEOUT_MS, true).isEstimated());\n     assertTrue(configResolver.capacityForBroker(\"\", \"\", 2, BROKER_CAPACITY_FETCH_TIMEOUT_MS, true).estimationInfo().length() > 0);\n+\n+    // If resolver is unable to get broker capacity and not allowed to estimate, an BrokerCapacityResolvingException will be thrown.", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5Nzc2MA==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r383597760", "bodyText": "Nit: I am curious why this change is needed.", "author": "efeg", "createdAt": "2020-02-25T00:40:28Z", "path": "cruise-control/src/test/resources/DefaultCapacityConfig.json", "diffHunk": "@@ -11,14 +11,14 @@\n       \"doc\": \"This is the default capacity. Capacity unit used for disk is in MB, cpu is in percentage, network throughput is in KB.\"\n     },\n     {\n-      \"brokerId\": \"314\",\n+      \"brokerId\": \"1\",\n       \"capacity\": {\n         \"DISK\": \"150000\",\n         \"CPU\": \"100\",\n         \"NW_IN\": \"150000\",\n         \"NW_OUT\": \"150000\"\n       },\n-      \"doc\": \"This overrides the capacity for broker 314.\"", "originalCommit": "edea6da765dc7e1c227086175da9ff1cf1dbd14f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxODYwNQ==", "url": "https://github.com/linkedin/cruise-control/pull/1108#discussion_r384218605", "bodyText": "This is because in many CC tests we use cluster model with broker id 0 and 1 in it.\nSo all brokers are used to be estimated, now there will be one estimated and one accurate, the tests actually cover more scenarios automatically.", "author": "kidkun", "createdAt": "2020-02-26T00:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5Nzc2MA=="}], "type": "inlineReview"}, {"oid": "561185e8db4da8d44b1958202495249c5ed11c96", "url": "https://github.com/linkedin/cruise-control/commit/561185e8db4da8d44b1958202495249c5ed11c96", "message": "Address the feedback.", "committedDate": "2020-02-26T01:04:45Z", "type": "commit"}]}