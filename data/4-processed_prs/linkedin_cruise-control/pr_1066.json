{"pr_number": 1066, "pr_title": "Tolerate broker capacity resolver unable to retrieve capacity information of dead broker.", "pr_createdAt": "2020-01-11T00:52:09Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1066", "timeline": [{"oid": "b5366b4e8a79ed6a609b7f22f843d80790a64288", "url": "https://github.com/linkedin/cruise-control/commit/b5366b4e8a79ed6a609b7f22f843d80790a64288", "message": "Tolerate broker capacity resolver unable to get capacity information of dead broker.", "committedDate": "2020-01-11T00:49:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ5NzU0MA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r365497540", "bodyText": "MonitorUtils#deadBrokersWithReplicas(Cluster) excludes dead brokers with 0 replicas. Shouldn't we include all dead brokers?", "author": "efeg", "createdAt": "2020-01-11T04:00:12Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java", "diffHunk": "@@ -523,10 +523,11 @@ public ClusterModel clusterModel(long from,\n       }\n \n       // Populate snapshots for the cluster model.\n+      Set<Integer> deadBrokers = MonitorUtils.deadBrokersWithReplicas(cluster);", "originalCommit": "b5366b4e8a79ed6a609b7f22f843d80790a64288", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ5ODA1Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r365498053", "bodyText": "Passing an empty map to BrokerCapacityInfo means that the broker has no resources -- I suspect that this will cause issues in the interpreting logic, which expects a value for each resource type (e.g. populating partition load on such brokers -- also see Broker#_brokerCapacity).\n\nCan we add a sanity check in BrokerCapacityInfo constructors to ensure that any capacity sent to this broker has exactly all resource types in the keyset of map?\nCan we add a unit test to verify our expected behavior and a cluster model can be generated properly under the tested scenario?", "author": "efeg", "createdAt": "2020-01-11T04:11:15Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -436,24 +437,33 @@ static void setBadBrokerState(ClusterModel clusterModel, Cluster cluster) {\n    * @param valuesAndExtrapolations The values and extrapolations of the leader replica.\n    * @param replicaPlacementInfo The distribution of replicas over broker logdirs if available, {@code null} otherwise.\n    * @param brokerCapacityConfigResolver The resolver for retrieving broker capacities.\n+   * @param deadBrokers Set of dead brokers in the cluster.\n    */\n   static void populatePartitionLoad(Cluster cluster,\n                                     ClusterModel clusterModel,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver,\n+                                    Set<Integer> deadBrokers) {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n       boolean needToAdjustCpuUsage = true;\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n-        // Note that we assume the capacity resolver can still return the broker capacity even if the broker\n-        // is dead. We need this to get the host resource capacity.\n-        BrokerCapacityInfo brokerCapacity =\n-            brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        BrokerCapacityInfo brokerCapacity;\n+        try {\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        } catch (Exception e) {\n+          //Capacity resolver may not be able to return the capacity information of dead brokers.\n+          if (deadBrokers.contains(replica.id())) {\n+            brokerCapacity = new BrokerCapacityInfo(Collections.emptyMap());", "originalCommit": "b5366b4e8a79ed6a609b7f22f843d80790a64288", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ5ODExMg==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r365498112", "bodyText": "Instead of catching all exceptions, should we catch a TimeoutException and in the logic that implements capacityForBroker, ensure that a timeout exception is thrown in the desired scenario?", "author": "efeg", "createdAt": "2020-01-11T04:13:15Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -436,24 +437,33 @@ static void setBadBrokerState(ClusterModel clusterModel, Cluster cluster) {\n    * @param valuesAndExtrapolations The values and extrapolations of the leader replica.\n    * @param replicaPlacementInfo The distribution of replicas over broker logdirs if available, {@code null} otherwise.\n    * @param brokerCapacityConfigResolver The resolver for retrieving broker capacities.\n+   * @param deadBrokers Set of dead brokers in the cluster.\n    */\n   static void populatePartitionLoad(Cluster cluster,\n                                     ClusterModel clusterModel,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver,\n+                                    Set<Integer> deadBrokers) {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n       boolean needToAdjustCpuUsage = true;\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n-        // Note that we assume the capacity resolver can still return the broker capacity even if the broker\n-        // is dead. We need this to get the host resource capacity.\n-        BrokerCapacityInfo brokerCapacity =\n-            brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        BrokerCapacityInfo brokerCapacity;\n+        try {\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        } catch (Exception e) {", "originalCommit": "b5366b4e8a79ed6a609b7f22f843d80790a64288", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "62bc3142105765f4dc5871b25b44c734167c53f5", "url": "https://github.com/linkedin/cruise-control/commit/62bc3142105765f4dc5871b25b44c734167c53f5", "message": "Address the feedback.", "committedDate": "2020-01-16T01:12:39Z", "type": "commit"}, {"oid": "d1e36497e6ed98941d299f5da634814f604fe2da", "url": "https://github.com/linkedin/cruise-control/commit/d1e36497e6ed98941d299f5da634814f604fe2da", "message": "Fix build failure.", "committedDate": "2020-01-17T19:54:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwMzA2NA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369303064", "bodyText": "When would this exception be thrown? Who configures the timeout here? Can we clarify this in JavaDoc?\nShould we modify this interface to pass a timeout -- e.g. a Duration argument similar to the way consumer poll() timeouts work?", "author": "efeg", "createdAt": "2020-01-21T23:41:53Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityConfigResolver.java", "diffHunk": "@@ -29,6 +30,7 @@\n    * @param host The host of the broker\n    * @param brokerId the id of the broker\n    * @return The capacity of each resource for the broker\n+   * @throws TimeoutException if resolver is unable to resolve broker capacity.", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwNDA3OA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369304078", "bodyText": "Looks like this sanity check can be moved to a static function -- can we also add a unit test for this sanity check? Also can we add a comment to explain why the missing CPU resource is ok? Shouldn't the cpu resource capacity be defined regardless of num cores are defined or not?", "author": "efeg", "createdAt": "2020-01-21T23:45:28Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java", "diffHunk": "@@ -29,6 +31,16 @@ public BrokerCapacityInfo(Map<Resource, Double> capacity,\n                             String estimationInfo,\n                             Map<String, Double> diskCapacityByLogDir,\n                             short numCpuCores) {\n+    Set<Resource> providedResource = capacity.keySet();\n+    Set<Resource> missingResource = new HashSet<>();\n+    for (Resource resource : Resource.cachedValues()) {\n+      if (!providedResource.contains(resource) && resource != Resource.CPU) {\n+        missingResource.add(resource);\n+      }\n+    }\n+    if (!missingResource.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Provided capacity information missing value for resource %s.\", missingResource));\n+    }", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTE1Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369309153", "bodyText": "If we intend to propagate TimeoutException all the way to higher layers, can we update the JavaDoc as we did for NotEnoughValidWindowsException for consistency? Alternatively, would it be cleaner to return null if the cluster model creation has failed due to not being able to resolve the cluster capacity, and handle the null cluster capacity response?", "author": "efeg", "createdAt": "2020-01-22T00:03:05Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java", "diffHunk": "@@ -473,7 +474,7 @@ public ClusterModel clusterModel(long from,\n                                    ModelCompletenessRequirements requirements,\n                                    boolean populateReplicaPlacementInfo,\n                                    OperationProgress operationProgress)\n-      throws NotEnoughValidWindowsException {\n+      throws NotEnoughValidWindowsException, TimeoutException {", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc0MTA2MA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369741060", "bodyText": "I prefer the first approach. Because if the cluster model is unable to generate, there is nothing CC should do other than notify the user about the error.", "author": "kidkun", "createdAt": "2020-01-22T18:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTI3OA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369309278", "bodyText": "Nit: Missing space before Capacity.", "author": "efeg", "createdAt": "2020-01-22T00:03:33Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -442,18 +450,26 @@ static void populatePartitionLoad(Cluster cluster,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n+    Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n       boolean needToAdjustCpuUsage = true;\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n-        // Note that we assume the capacity resolver can still return the broker capacity even if the broker\n-        // is dead. We need this to get the host resource capacity.\n-        BrokerCapacityInfo brokerCapacity =\n-            brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        BrokerCapacityInfo brokerCapacity;\n+        try {\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        } catch (TimeoutException tme) {\n+          //Capacity resolver may not be able to return the capacity information of dead brokers.", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTQ0NQ==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369309445", "bodyText": "Should we (bulk) log this empty broker capacity assignment?", "author": "efeg", "createdAt": "2020-01-22T00:04:12Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -442,18 +450,26 @@ static void populatePartitionLoad(Cluster cluster,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n+    Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n       boolean needToAdjustCpuUsage = true;\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n-        // Note that we assume the capacity resolver can still return the broker capacity even if the broker\n-        // is dead. We need this to get the host resource capacity.\n-        BrokerCapacityInfo brokerCapacity =\n-            brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        BrokerCapacityInfo brokerCapacity;\n+        try {\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        } catch (TimeoutException tme) {\n+          //Capacity resolver may not be able to return the capacity information of dead brokers.\n+          if (!aliveBrokers.contains(replica.id())) {\n+            brokerCapacity = new BrokerCapacityInfo(EMPTY_BROKER_CAPACITY);", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTgxMg==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369309812", "bodyText": "Should we move this inside if (partitionInfo != null)?", "author": "efeg", "createdAt": "2020-01-22T00:05:35Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -442,18 +450,26 @@ static void populatePartitionLoad(Cluster cluster,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n+    Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxMTM5Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369311393", "bodyText": "Nit: core number -> number of CPU cores", "author": "efeg", "createdAt": "2020-01-22T00:11:21Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java", "diffHunk": "@@ -76,9 +77,14 @@ private void updateCachedNumCoresByBroker(Cluster cluster) {\n           LOG.warn(\"Received metrics from unrecognized broker {}.\", bid);\n           return null;\n         }\n-        BrokerCapacityInfo capacity = _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid);\n-        // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n-        return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+        try {\n+          BrokerCapacityInfo capacity = _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid);\n+          // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n+          return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+        } catch (TimeoutException tme) {\n+          LOG.warn(\"Unable to get core number of broker {}.\", node.id());", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxMTcyNw==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r369311727", "bodyText": "Can we update the JavaDoc to indicate cases that a null response is expected? Can we add a unit test to verify the return of expected null response?", "author": "efeg", "createdAt": "2020-01-22T00:12:41Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java", "diffHunk": "@@ -76,9 +77,14 @@ private void updateCachedNumCoresByBroker(Cluster cluster) {\n           LOG.warn(\"Received metrics from unrecognized broker {}.\", bid);\n           return null;\n         }\n-        BrokerCapacityInfo capacity = _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid);\n-        // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n-        return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+        try {\n+          BrokerCapacityInfo capacity = _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid);\n+          // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n+          return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+        } catch (TimeoutException tme) {\n+          LOG.warn(\"Unable to get core number of broker {}.\", node.id());\n+          return null;", "originalCommit": "d1e36497e6ed98941d299f5da634814f604fe2da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "21d6ecd81492c704fd80ecc2246ad36630c9b456", "url": "https://github.com/linkedin/cruise-control/commit/21d6ecd81492c704fd80ecc2246ad36630c9b456", "message": "Address the feedback.", "committedDate": "2020-01-22T20:58:53Z", "type": "commit"}, {"oid": "ff3c4326c194a2bb879d164471c835098cb148ef", "url": "https://github.com/linkedin/cruise-control/commit/ff3c4326c194a2bb879d164471c835098cb148ef", "message": "remove access.log", "committedDate": "2020-01-22T20:59:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI0Mjc0Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r373242747", "bodyText": "Typo: sanityCheckCapcity -> sanityCheckCapacity", "author": "efeg", "createdAt": "2020-01-30T23:08:23Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/BrokerCapacityInfo.java", "diffHunk": "@@ -130,4 +133,17 @@ public String estimationInfo() {\n   public short numCpuCores() {\n     return _numCpuCores;\n   }\n+\n+  /**\n+   * Sanity check to ensure the provided capacity information contains all the resource type.\n+   * @param capacity The provided capacity map.\n+   */\n+  static void sanityCheckCapcity(Map<Resource, Double> capacity) {", "originalCommit": "ff3c4326c194a2bb879d164471c835098cb148ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI0NjA4Ng==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r373246086", "bodyText": "How do we handle the case, where a broker has become unavailable (e.g. dead) after the cluster information is received from _metadataClient.refreshMetadata()?", "author": "efeg", "createdAt": "2020-01-30T23:19:21Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/LoadMonitor.java", "diffHunk": "@@ -510,7 +515,7 @@ public ClusterModel clusterModel(long from,\n         // If the rack is not specified, we use the host info as rack info.\n         String rack = getRackHandleNull(node);\n         clusterModel.createRack(rack);\n-        BrokerCapacityInfo brokerCapacity = _brokerCapacityConfigResolver.capacityForBroker(rack, node.host(), node.id());\n+        BrokerCapacityInfo brokerCapacity = _brokerCapacityConfigResolver.capacityForBroker(rack, node.host(), node.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);", "originalCommit": "ff3c4326c194a2bb879d164471c835098cb148ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI0ODQ5NA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r373248494", "bodyText": "Can we add a log here to indicate why this exception has been thrown and what the user can do to mitigate the issue -- i.e. (1) potentially due to high churn in the cluster (2) retry?", "author": "efeg", "createdAt": "2020-01-30T23:27:44Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -442,18 +451,28 @@ static void populatePartitionLoad(Cluster cluster,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n+      Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n       boolean needToAdjustCpuUsage = true;\n+      Set<Integer> deadBrokers = new HashSet<>();\n       for (int index = 0; index < partitionInfo.replicas().length; index++) {\n         Node replica = partitionInfo.replicas()[index];\n         String rack = getRackHandleNull(replica);\n-        // Note that we assume the capacity resolver can still return the broker capacity even if the broker\n-        // is dead. We need this to get the host resource capacity.\n-        BrokerCapacityInfo brokerCapacity =\n-            brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id());\n+        BrokerCapacityInfo brokerCapacity;\n+        try {\n+          brokerCapacity = brokerCapacityConfigResolver.capacityForBroker(rack, replica.host(), replica.id(), BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n+        } catch (TimeoutException tme) {\n+          // Capacity resolver may not be able to return the capacity information of dead brokers.\n+          if (!aliveBrokers.contains(replica.id())) {\n+            brokerCapacity = new BrokerCapacityInfo(EMPTY_BROKER_CAPACITY);\n+            deadBrokers.add(replica.id());\n+          } else {\n+            throw tme;", "originalCommit": "ff3c4326c194a2bb879d164471c835098cb148ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI2NjAyNg==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r373266026", "bodyText": "Can we rename this to deadBrokersWithUnknownCapacity? -- i.e. it is possible that a broker can be dead, but its capacity can still be resolved depending on whether the capacity resolving service can provide the capacity or not.", "author": "efeg", "createdAt": "2020-01-31T00:33:25Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -442,18 +451,28 @@ static void populatePartitionLoad(Cluster cluster,\n                                     TopicPartition tp,\n                                     ValuesAndExtrapolations valuesAndExtrapolations,\n                                     Map<TopicPartition, Map<Integer, String>> replicaPlacementInfo,\n-                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) {\n+                                    BrokerCapacityConfigResolver brokerCapacityConfigResolver) throws TimeoutException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n     // If partition info does not exist, the topic may have been deleted.\n     if (partitionInfo != null) {\n+      Set<Integer> aliveBrokers = cluster.nodes().stream().mapToInt(Node::id).boxed().collect(Collectors.toSet());\n       boolean needToAdjustCpuUsage = true;\n+      Set<Integer> deadBrokers = new HashSet<>();", "originalCommit": "ff3c4326c194a2bb879d164471c835098cb148ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI2NjM4Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r373266387", "bodyText": "Can we update the message to make it clear that these are not necessarily all the dead brokers, but only the dead brokers, whose capacity cannot be obtained from the capacity resolver?", "author": "efeg", "createdAt": "2020-01-31T00:34:44Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/MonitorUtils.java", "diffHunk": "@@ -479,6 +498,9 @@ static void populatePartitionLoad(Cluster cluster,\n                                     valuesAndExtrapolations.windows());\n         needToAdjustCpuUsage = false;\n       }\n+      if (!deadBrokers.isEmpty()) {\n+        LOG.info(\"Assign empty capacity to dead brokers {} in cluster model.\", deadBrokers);", "originalCommit": "ff3c4326c194a2bb879d164471c835098cb148ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI2NzIzNA==", "url": "https://github.com/linkedin/cruise-control/pull/1066#discussion_r373267234", "bodyText": "Should we add , tme to the log?", "author": "efeg", "createdAt": "2020-01-31T00:38:02Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/monitor/sampling/CruiseControlMetricsProcessor.java", "diffHunk": "@@ -76,9 +80,15 @@ private void updateCachedNumCoresByBroker(Cluster cluster) {\n           LOG.warn(\"Received metrics from unrecognized broker {}.\", bid);\n           return null;\n         }\n-        BrokerCapacityInfo capacity = _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid);\n-        // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n-        return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+        try {\n+          BrokerCapacityInfo capacity =\n+              _brokerCapacityConfigResolver.capacityForBroker(getRackHandleNull(node), node.host(), bid, BROKER_CAPACITY_FETCH_TIMEOUT_MS);\n+          // No mapping shall be recorded if capacity is estimated, but estimation is not allowed.\n+          return (!_allowCpuCapacityEstimation && capacity.isEstimated()) ? null : capacity.numCpuCores();\n+        } catch (TimeoutException tme) {\n+          LOG.warn(\"Unable to get number of CPU cores for broker {}.\", node.id());", "originalCommit": "ff3c4326c194a2bb879d164471c835098cb148ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b10af1c5f044415a4e45cbee2b20131217862467", "url": "https://github.com/linkedin/cruise-control/commit/b10af1c5f044415a4e45cbee2b20131217862467", "message": "Address the feedback.", "committedDate": "2020-01-31T01:51:16Z", "type": "commit"}]}