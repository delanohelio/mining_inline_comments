{"pr_number": 1324, "pr_title": "Add support for goal-based operations via maintenance events.", "pr_createdAt": "2020-09-10T03:02:54Z", "pr_url": "https://github.com/linkedin/cruise-control/pull/1324", "timeline": [{"oid": "115e1c5a4a9daa80b5f97293477d59bed8db8a0b", "url": "https://github.com/linkedin/cruise-control/commit/115e1c5a4a9daa80b5f97293477d59bed8db8a0b", "message": "Add support for goal-based operations via maintenance events.", "committedDate": "2020-09-10T02:58:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNDc0Nw==", "url": "https://github.com/linkedin/cruise-control/pull/1324#discussion_r486614747", "bodyText": "I am a little bit confused about using a config to determine the event type. Is the config per-set when cruise control is deployed or is it set in runtime? From #1248, I thought the point of having the maintenance event is to read the event from some store (i.e. a topic) and trigger actions based on the event type so I guess the next PR for the event reader will introduce the implementation to read form a topic and set this config to trigger the goal-based operation, is it correct?", "author": "hzxa21", "createdAt": "2020-09-10T20:29:13Z", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/MaintenanceEvent.java", "diffHunk": "@@ -24,20 +68,128 @@ public AnomalyType anomalyType() {\n   }\n \n   @Override\n-  public boolean fix() {\n-    // TODO: Start the relevant fix for the maintenance event.\n-    return false;\n+  public boolean fix() throws KafkaCruiseControlException {\n+    // Start the relevant fix for the maintenance event.\n+    _optimizationResult = new OptimizationResult(_goalBasedOperationRunnable.computeResult(), null);\n+    boolean hasProposalsToFix = hasProposalsToFix();\n+    // Ensure that only the relevant response is cached to avoid memory pressure.\n+    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n+    return hasProposalsToFix;\n   }\n \n   @Override\n   public String toString() {\n-    // TODO: Add details on maintenance event.\n-    return super.toString();\n+    // Add details on maintenance event.\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(String.format(\"{Handling %s\", _maintenanceEventType));\n+    if (_topicsWithRFUpdate != null) {\n+      // Add summary for TOPIC_REPLICATION_FACTOR\n+      sb.append(String.format(\" by desired RF: [%s]\", _topicsWithRFUpdate));\n+    } else if (_brokers != null) {\n+      // Add summary for ADD_BROKER / REMOVE_BROKER / DEMOTE_BROKER\n+      sb.append(String.format(\" for brokers: [%s]\", _brokers));\n+    }\n+    sb.append(\"}\");\n+    return sb.toString();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected void initBrokers(Map<String, ?> configs) {\n+    _brokers = (Set<Integer>) configs.get(BROKERS_OBJECT_CONFIG);\n+    if (_brokers == null || _brokers.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing brokers for maintenance event of type %s.\", _maintenanceEventType));\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected void initTopicsWithRFUpdate(Map<String, ?> configs) {\n+    _topicsWithRFUpdate = (Map<Short, Set<String>>) configs.get(TOPICS_WITH_RF_UPDATE_CONFIG);\n+    if (_topicsWithRFUpdate == null || _topicsWithRFUpdate.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s to identify topics for replication factor update.\",\n+                                                       TOPICS_WITH_RF_UPDATE_CONFIG));\n+    }\n+  }\n+\n+  protected Map<Short, Pattern> topicPatternByReplicationFactor(Map<String, ?> configs) {\n+    initTopicsWithRFUpdate(configs);\n+    Map<Short, Pattern> topicPatternByReplicationFactor = new HashMap<>(_topicsWithRFUpdate.size());\n+    _topicsWithRFUpdate.forEach((key, value) -> topicPatternByReplicationFactor.put(key, buildTopicRegex(value)));\n+    return topicPatternByReplicationFactor;\n   }\n \n   @Override\n   public void configure(Map<String, ?> configs) {\n     super.configure(configs);\n-    // TODO: Add configs for maintenance event.\n+    KafkaCruiseControl kafkaCruiseControl = extractKafkaCruiseControlObjectFromConfig(configs, MAINTENANCE_EVENT);\n+    KafkaCruiseControlConfig config = kafkaCruiseControl.config();\n+    boolean allowCapacityEstimation = config.getBoolean(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG);\n+    boolean excludeRecentlyDemotedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n+    boolean excludeRecentlyRemovedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n+    _optimizationResult = null;\n+    _maintenanceEventType = (MaintenanceEventType) configs.get(MAINTENANCE_EVENT_TYPE_CONFIG);", "originalCommit": "115e1c5a4a9daa80b5f97293477d59bed8db8a0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY0Mzg0Mw==", "url": "https://github.com/linkedin/cruise-control/pull/1324#discussion_r486643843", "bodyText": "Is the config per-set when cruise control is deployed or is it set in runtime?\n\nThis is a runtime config similar to the ones used for configuring other anomalies -- e.g. FAILED_BROKERS_OBJECT_CONFIG for BrokerFailures (see setting the config and using it). For examples of setting and using the runtime config MAINTENANCE_EVENT_TYPE_CONFIG , please see (1) setting and (2) usage.\n\nso I guess the next PR for the event reader will introduce the implementation to read form a topic and set this config to trigger the goal-based operation, is it correct?\n\nThat is correct.", "author": "efeg", "createdAt": "2020-09-10T21:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNDc0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY3NzU5NA==", "url": "https://github.com/linkedin/cruise-control/pull/1324#discussion_r486677594", "bodyText": "Thanks for the explanation.", "author": "hzxa21", "createdAt": "2020-09-10T22:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNDc0Nw=="}], "type": "inlineReview"}]}