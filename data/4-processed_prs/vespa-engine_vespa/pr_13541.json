{"pr_number": 13541, "pr_title": "Add draft LocalVisitorSession", "pr_createdAt": "2020-06-10T14:22:38Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/13541", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE4MTQwNQ==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438181405", "bodyText": "Very unclear what this is used for.", "author": "jonmv", "createdAt": "2020-06-10T14:46:58Z", "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.documentapi.AckToken;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorDataHandler;\n+import com.yahoo.documentapi.VisitorDataQueue;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorResponse;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.PutDocumentMessage;\n+import com.yahoo.messagebus.Trace;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Local visitor session that copies and iterates through all items in the local document access.\n+ * Each document must be ack'ed for the session to be done visiting.\n+ * Only document puts are sent by this session, and this is done from a separate thread.\n+ *\n+ * @author jonmv\n+ */\n+public class LocalVisitorSession implements VisitorSession {\n+\n+    private enum State { RUNNING, FAILURE, ABORTED, SUCCESS }\n+\n+    private final VisitorDataHandler data;\n+    private final VisitorControlHandler control;\n+    private final Map<DocumentId, Document> outstanding;\n+    private final AtomicReference<State> state;\n+\n+    public LocalVisitorSession(LocalDocumentAccess access, VisitorParameters parameters) {\n+        if (parameters.getResumeToken() != null)\n+            throw new UnsupportedOperationException(\"Continuation via progress tokens is not supported\");\n+\n+        if (parameters.getRemoteDataHandler() != null)\n+            throw new UnsupportedOperationException(\"Remote data handlers are not supported\");\n+\n+        this.data = parameters.getLocalDataHandler() == null ? new VisitorDataQueue() : parameters.getLocalDataHandler();\n+        this.data.reset();\n+        this.data.setSession(this);\n+\n+        this.control = parameters.getControlHandler() == null ? new VisitorControlHandler() : parameters.getControlHandler();\n+        this.control.reset();\n+        this.control.setSession(this);\n+\n+        this.outstanding = new ConcurrentSkipListMap<>(access.documents);\n+        this.state = new AtomicReference<>(State.RUNNING);\n+\n+        start();\n+    }\n+\n+    void start() {\n+        new Thread(() -> {\n+            try {\n+                // Iterate through all documents and pass on to data handler\n+                outstanding.forEach((id, document) -> {\n+                    data.onMessage(new PutDocumentMessage(new DocumentPut(document)),\n+                                                               new AckToken(id));\n+                });\n+                // Transition to a terminal state when done\n+                state.updateAndGet(current -> {\n+                    switch (current) {\n+                        case RUNNING:\n+                            control.onDone(VisitorControlHandler.CompletionCode.SUCCESS, \"Success\");\n+                            return State.SUCCESS;\n+                        case ABORTED:\n+                            control.onDone(VisitorControlHandler.CompletionCode.ABORTED, \"Aborted by user\");\n+                            return State.ABORTED;\n+                        default:\n+                            control.onDone(VisitorControlHandler.CompletionCode.FAILURE, \"Unexpected state '\" + current + \"'\");;\n+                            return State.FAILURE;\n+                    }\n+                });\n+            }\n+            // Transition to failure terminal state on error\n+            catch (Exception e) {\n+                state.set(State.FAILURE);\n+                outstanding.clear();\n+                control.onDone(VisitorControlHandler.CompletionCode.FAILURE, Exceptions.toMessageString(e));\n+            }\n+            finally {\n+                data.onDone();\n+            }\n+        }).start();\n+    }\n+\n+    @Override\n+    public boolean isDone() {", "originalCommit": "0bb39325a2257d71a8619a19dd19e6aa004d72ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE4MjkyNg==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438182926", "bodyText": "Could wait for worker thread to set state and call control.onDone if true here means anything for the control ... ?", "author": "jonmv", "createdAt": "2020-06-10T14:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE4MTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIxOTM1Nw==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438219357", "bodyText": "Or just return control.isDone(), obviously.", "author": "jonmv", "createdAt": "2020-06-10T15:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE4MTQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE4MTk5NQ==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438181995", "bodyText": "This could be called unconditionally now.", "author": "jonmv", "createdAt": "2020-06-10T14:47:46Z", "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.documentapi.AckToken;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorDataHandler;\n+import com.yahoo.documentapi.VisitorDataQueue;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorResponse;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.PutDocumentMessage;\n+import com.yahoo.messagebus.Trace;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Local visitor session that copies and iterates through all items in the local document access.\n+ * Each document must be ack'ed for the session to be done visiting.\n+ * Only document puts are sent by this session, and this is done from a separate thread.\n+ *\n+ * @author jonmv\n+ */\n+public class LocalVisitorSession implements VisitorSession {\n+\n+    private enum State { RUNNING, FAILURE, ABORTED, SUCCESS }\n+\n+    private final VisitorDataHandler data;\n+    private final VisitorControlHandler control;\n+    private final Map<DocumentId, Document> outstanding;\n+    private final AtomicReference<State> state;\n+\n+    public LocalVisitorSession(LocalDocumentAccess access, VisitorParameters parameters) {\n+        if (parameters.getResumeToken() != null)\n+            throw new UnsupportedOperationException(\"Continuation via progress tokens is not supported\");\n+\n+        if (parameters.getRemoteDataHandler() != null)\n+            throw new UnsupportedOperationException(\"Remote data handlers are not supported\");\n+\n+        this.data = parameters.getLocalDataHandler() == null ? new VisitorDataQueue() : parameters.getLocalDataHandler();\n+        this.data.reset();\n+        this.data.setSession(this);\n+\n+        this.control = parameters.getControlHandler() == null ? new VisitorControlHandler() : parameters.getControlHandler();\n+        this.control.reset();\n+        this.control.setSession(this);\n+\n+        this.outstanding = new ConcurrentSkipListMap<>(access.documents);\n+        this.state = new AtomicReference<>(State.RUNNING);\n+\n+        start();\n+    }\n+\n+    void start() {\n+        new Thread(() -> {\n+            try {\n+                // Iterate through all documents and pass on to data handler\n+                outstanding.forEach((id, document) -> {\n+                    data.onMessage(new PutDocumentMessage(new DocumentPut(document)),\n+                                                               new AckToken(id));\n+                });\n+                // Transition to a terminal state when done\n+                state.updateAndGet(current -> {\n+                    switch (current) {\n+                        case RUNNING:\n+                            control.onDone(VisitorControlHandler.CompletionCode.SUCCESS, \"Success\");\n+                            return State.SUCCESS;\n+                        case ABORTED:\n+                            control.onDone(VisitorControlHandler.CompletionCode.ABORTED, \"Aborted by user\");\n+                            return State.ABORTED;\n+                        default:\n+                            control.onDone(VisitorControlHandler.CompletionCode.FAILURE, \"Unexpected state '\" + current + \"'\");;\n+                            return State.FAILURE;\n+                    }\n+                });\n+            }\n+            // Transition to failure terminal state on error\n+            catch (Exception e) {\n+                state.set(State.FAILURE);\n+                outstanding.clear();\n+                control.onDone(VisitorControlHandler.CompletionCode.FAILURE, Exceptions.toMessageString(e));\n+            }\n+            finally {\n+                data.onDone();\n+            }\n+        }).start();\n+    }\n+\n+    @Override\n+    public boolean isDone() {\n+        return outstanding.isEmpty();\n+    }\n+\n+    @Override\n+    public ProgressToken getProgress() {\n+        throw new UnsupportedOperationException(\"Progress tokens are not supported\");\n+    }\n+\n+    @Override\n+    public Trace getTrace() {\n+        throw new UnsupportedOperationException(\"Traces are not supported\");\n+    }\n+\n+    @Override\n+    public boolean waitUntilDone(long timeoutMs) throws InterruptedException {\n+        return control.waitUntilDone(timeoutMs);\n+    }\n+\n+    @Override\n+    public void ack(AckToken token) {\n+        outstanding.remove((DocumentId) token.ackObject);\n+    }\n+\n+    @Override\n+    public void abort() {\n+        state.updateAndGet(current -> current == State.RUNNING ? State.ABORTED : current);\n+        outstanding.clear();\n+    }\n+\n+    @Override\n+    public VisitorResponse getNext() {\n+        return data.getNext();\n+    }\n+\n+    @Override\n+    public VisitorResponse getNext(int timeoutMilliseconds) throws InterruptedException {\n+        return data.getNext(timeoutMilliseconds);\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        if ( ! isDone())\n+            abort();", "originalCommit": "0bb39325a2257d71a8619a19dd19e6aa004d72ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE4MzA1NQ==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438183055", "bodyText": "Urgh indentation.", "author": "jonmv", "createdAt": "2020-06-10T14:49:06Z", "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.documentapi.AckToken;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorDataHandler;\n+import com.yahoo.documentapi.VisitorDataQueue;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorResponse;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.PutDocumentMessage;\n+import com.yahoo.messagebus.Trace;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Local visitor session that copies and iterates through all items in the local document access.\n+ * Each document must be ack'ed for the session to be done visiting.\n+ * Only document puts are sent by this session, and this is done from a separate thread.\n+ *\n+ * @author jonmv\n+ */\n+public class LocalVisitorSession implements VisitorSession {\n+\n+    private enum State { RUNNING, FAILURE, ABORTED, SUCCESS }\n+\n+    private final VisitorDataHandler data;\n+    private final VisitorControlHandler control;\n+    private final Map<DocumentId, Document> outstanding;\n+    private final AtomicReference<State> state;\n+\n+    public LocalVisitorSession(LocalDocumentAccess access, VisitorParameters parameters) {\n+        if (parameters.getResumeToken() != null)\n+            throw new UnsupportedOperationException(\"Continuation via progress tokens is not supported\");\n+\n+        if (parameters.getRemoteDataHandler() != null)\n+            throw new UnsupportedOperationException(\"Remote data handlers are not supported\");\n+\n+        this.data = parameters.getLocalDataHandler() == null ? new VisitorDataQueue() : parameters.getLocalDataHandler();\n+        this.data.reset();\n+        this.data.setSession(this);\n+\n+        this.control = parameters.getControlHandler() == null ? new VisitorControlHandler() : parameters.getControlHandler();\n+        this.control.reset();\n+        this.control.setSession(this);\n+\n+        this.outstanding = new ConcurrentSkipListMap<>(access.documents);\n+        this.state = new AtomicReference<>(State.RUNNING);\n+\n+        start();\n+    }\n+\n+    void start() {\n+        new Thread(() -> {\n+            try {\n+                // Iterate through all documents and pass on to data handler\n+                outstanding.forEach((id, document) -> {\n+                    data.onMessage(new PutDocumentMessage(new DocumentPut(document)),\n+                                                               new AckToken(id));", "originalCommit": "0bb39325a2257d71a8619a19dd19e6aa004d72ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY5ODcxMA==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438698710", "bodyText": "Shall it be guaranteed that onDocument is always called from a single thread in the local implementation? If not, consider adding synchronization in the data handlers here.", "author": "vekterli", "createdAt": "2020-06-11T10:46:03Z", "path": "documentapi/src/test/java/com/yahoo/documentapi/local/LocalDocumentApiTestCase.java", "diffHunk": "@@ -0,0 +1,241 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.document.DocumentRemove;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.DocumentUpdate;\n+import com.yahoo.document.datatypes.StringFieldValue;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.document.update.FieldUpdate;\n+import com.yahoo.documentapi.AsyncParameters;\n+import com.yahoo.documentapi.AsyncSession;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.DocumentAccessParams;\n+import com.yahoo.documentapi.DocumentResponse;\n+import com.yahoo.documentapi.DumpVisitorDataHandler;\n+import com.yahoo.documentapi.Response;\n+import com.yahoo.documentapi.Result;\n+import com.yahoo.documentapi.SyncParameters;\n+import com.yahoo.documentapi.SyncSession;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.test.AbstractDocumentApiTestCase;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Runs the superclass tests on this implementation\n+ *\n+ * @author bratseth\n+ */\n+public class LocalDocumentApiTestCase extends AbstractDocumentApiTestCase {\n+\n+    protected LocalDocumentAccess access;\n+\n+    @Override\n+    protected DocumentAccess access() {\n+        return access;\n+    }\n+\n+    @Before\n+    public void setUp() {\n+        DocumentAccessParams params = new DocumentAccessParams();\n+        params.setDocumentManagerConfigId(\"file:src/test/cfg/documentmanager.cfg\");\n+        access = new LocalDocumentAccess(params);\n+    }\n+\n+    @After\n+    public void shutdownAccess() {\n+        access.shutdown();\n+    }\n+\n+    @Test\n+    public void testNoExceptionFromAsync() {\n+        AsyncSession session = access.createAsyncSession(new AsyncParameters());\n+\n+        DocumentType type = access.getDocumentTypeManager().getDocumentType(\"music\");\n+        DocumentUpdate docUp = new DocumentUpdate(type, new DocumentId(\"id:ns:music::2\"));\n+\n+        Result result = session.update(docUp);\n+        assertTrue(result.isSuccess());\n+        Response response = session.getNext();\n+        assertEquals(result.getRequestId(), response.getRequestId());\n+        assertFalse(response.isSuccess());\n+        session.destroy();\n+    }\n+\n+    @Test\n+    public void testAsyncFetch() {\n+        AsyncSession session = access.createAsyncSession(new AsyncParameters());\n+        List<DocumentId> ids = new ArrayList<>();\n+        ids.add(new DocumentId(\"id:music:music::1\"));\n+        ids.add(new DocumentId(\"id:music:music::2\"));\n+        ids.add(new DocumentId(\"id:music:music::3\"));\n+        for (DocumentId id : ids)\n+            session.put(new Document(access.getDocumentTypeManager().getDocumentType(\"music\"), id));\n+        int timeout = 100;\n+\n+        long startTime = System.currentTimeMillis();\n+        Set<Long> outstandingRequests = new HashSet<>();\n+        for (DocumentId id : ids) {\n+            Result result = session.get(id);\n+            if ( ! result.isSuccess())\n+                throw new IllegalStateException(\"Failed requesting document \" + id, result.getError().getCause());\n+            outstandingRequests.add(result.getRequestId());\n+        }\n+\n+        List<Document> documents = new ArrayList<>();\n+        try {\n+            while ( ! outstandingRequests.isEmpty()) {\n+                int timeSinceStart = (int)(System.currentTimeMillis() - startTime);\n+                Response response = session.getNext(timeout - timeSinceStart);\n+                if (response == null)\n+                    throw new RuntimeException(\"Timed out waiting for documents\"); // or return what you have\n+                if ( ! outstandingRequests.contains(response.getRequestId())) continue; // Stale: Ignore\n+\n+                if (response.isSuccess())\n+                    documents.add(((DocumentResponse)response).getDocument());\n+                outstandingRequests.remove(response.getRequestId());\n+            }\n+        }\n+        catch (InterruptedException e) {\n+            throw new RuntimeException(\"Interrupted while waiting for documents\", e);\n+        }\n+\n+        assertEquals(3, documents.size());\n+        for (Document document : documents)\n+            assertNotNull(document);\n+    }\n+\n+    @Test\n+    public void testFeedingAndVisiting() throws InterruptedException, ParseException {\n+        DocumentType musicType = access().getDocumentTypeManager().getDocumentType(\"music\");\n+        Document doc1 = new Document(musicType, \"id:ns:music::1\"); doc1.setFieldValue(\"artist\", \"one\");\n+        Document doc2 = new Document(musicType, \"id:ns:music::2\"); doc2.setFieldValue(\"artist\", \"two\");\n+        Document doc3 = new Document(musicType, \"id:ns:music::3\");\n+\n+        // Select all music documents where the \"artist\" field is set\n+        VisitorParameters parameters = new VisitorParameters(\"music.artist\");\n+        parameters.setFieldSet(\"music:artist\");\n+        VisitorControlHandler control = new VisitorControlHandler();\n+        parameters.setControlHandler(control);\n+        List<Document> received = new ArrayList<>();\n+        parameters.setLocalDataHandler(new DumpVisitorDataHandler() {\n+            @Override public void onDocument(Document doc, long timeStamp) {\n+                received.add(doc);", "originalCommit": "801998b41aa21cd2998c93fcb48a6a380e875697", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMzA2MA==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438733060", "bodyText": "Will use a concurrent list.", "author": "jonmv", "createdAt": "2020-06-11T12:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY5ODcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMzQwNg==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438733406", "bodyText": "Well, that would have to be a set, then.", "author": "jonmv", "createdAt": "2020-06-11T12:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY5ODcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcwNjY5NQ==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438706695", "bodyText": "Since outstanding is a ConcurrentSkipListMap I'm presuming it operates on a logical snapshot of the set of initial document IDs where concurrent removes can't mess anything up? It's been a while since I've looked into its semantics \ud83d\ude42", "author": "vekterli", "createdAt": "2020-06-11T11:03:12Z", "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentGet;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.fieldset.FieldCollection;\n+import com.yahoo.document.fieldset.FieldSet;\n+import com.yahoo.document.fieldset.FieldSetRepo;\n+import com.yahoo.document.select.DocumentSelector;\n+import com.yahoo.document.select.Result;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.AckToken;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorDataHandler;\n+import com.yahoo.documentapi.VisitorDataQueue;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorResponse;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.PutDocumentMessage;\n+import com.yahoo.messagebus.Trace;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Local visitor session that copies and iterates through all items in the local document access.\n+ * Each document must be ack'ed for the session to be done visiting.\n+ * Only document puts are sent by this session, and this is done from a separate thread.\n+ *\n+ * @author jonmv\n+ */\n+public class LocalVisitorSession implements VisitorSession {\n+\n+    private enum State { RUNNING, FAILURE, ABORTED, SUCCESS }\n+\n+    private final VisitorDataHandler data;\n+    private final VisitorControlHandler control;\n+    private final Map<DocumentId, Document> outstanding;\n+    private final DocumentSelector selector;\n+    private final FieldSet fieldSet;\n+    private final AtomicReference<State> state;\n+\n+    public LocalVisitorSession(LocalDocumentAccess access, VisitorParameters parameters) throws ParseException {\n+        if (parameters.getResumeToken() != null)\n+            throw new UnsupportedOperationException(\"Continuation via progress tokens is not supported\");\n+\n+        if (parameters.getRemoteDataHandler() != null)\n+            throw new UnsupportedOperationException(\"Remote data handlers are not supported\");\n+\n+        this.selector = new DocumentSelector(parameters.getDocumentSelection());\n+        this.fieldSet = new FieldSetRepo().parse(access.getDocumentTypeManager(), parameters.fieldSet());\n+\n+        this.data = parameters.getLocalDataHandler() == null ? new VisitorDataQueue() : parameters.getLocalDataHandler();\n+        this.data.reset();\n+        this.data.setSession(this);\n+\n+        this.control = parameters.getControlHandler() == null ? new VisitorControlHandler() : parameters.getControlHandler();\n+        this.control.reset();\n+        this.control.setSession(this);\n+\n+        this.outstanding = new ConcurrentSkipListMap<>(Comparator.comparing(DocumentId::toString));\n+        this.outstanding.putAll(access.documents);\n+        this.state = new AtomicReference<>(State.RUNNING);\n+\n+        start();\n+    }\n+\n+    void start() {\n+        new Thread(() -> {\n+            try {\n+                // Iterate through all documents and pass on to data handler\n+                outstanding.forEach((id, document) -> {\n+                    if (selector.accepts(new DocumentPut(document)) != Result.TRUE)\n+                        return;\n+\n+                    Document copy = new Document(document.getDataType(), document.getId());\n+                    for (Field field : document.getDataType().getFields())\n+                        if (fieldSet.contains(field))\n+                            copy.setFieldValue(field, document.getFieldValue(field));\n+\n+                    data.onMessage(new PutDocumentMessage(new DocumentPut(copy)),\n+                                   new AckToken(id));\n+                });\n+                // Transition to a terminal state when done\n+                state.updateAndGet(current -> {\n+                    switch (current) {\n+                        case RUNNING:\n+                            control.onDone(VisitorControlHandler.CompletionCode.SUCCESS, \"Success\");\n+                            return State.SUCCESS;\n+                        case ABORTED:\n+                            control.onDone(VisitorControlHandler.CompletionCode.ABORTED, \"Aborted by user\");\n+                            return State.ABORTED;\n+                        default:\n+                            control.onDone(VisitorControlHandler.CompletionCode.FAILURE, \"Unexpected state '\" + current + \"'\");;\n+                            return State.FAILURE;\n+                    }\n+                });\n+            }\n+            // Transition to failure terminal state on error\n+            catch (Exception e) {\n+                state.set(State.FAILURE);\n+                outstanding.clear();\n+                control.onDone(VisitorControlHandler.CompletionCode.FAILURE, Exceptions.toMessageString(e));\n+            }\n+            finally {\n+                data.onDone();\n+            }\n+        }).start();\n+    }\n+\n+    @Override\n+    public boolean isDone() {\n+        return    outstanding.isEmpty() // All documents ack'ed\n+               && control.isDone();     // Control handler has been notified\n+    }\n+\n+    @Override\n+    public ProgressToken getProgress() {\n+        throw new UnsupportedOperationException(\"Progress tokens are not supported\");\n+    }\n+\n+    @Override\n+    public Trace getTrace() {\n+        throw new UnsupportedOperationException(\"Traces are not supported\");\n+    }\n+\n+    @Override\n+    public boolean waitUntilDone(long timeoutMs) throws InterruptedException {\n+        return control.waitUntilDone(timeoutMs);\n+    }\n+\n+    @Override\n+    public void ack(AckToken token) {\n+        outstanding.remove((DocumentId) token.ackObject);", "originalCommit": "801998b41aa21cd2998c93fcb48a6a380e875697", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMTc5Ng==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438731796", "bodyText": "Its iterators are weakly consistent \u2014 while this is weakly defined, they can reflect changes during iteration.\nThis is the case for the last part of the unit test. I suppose this test would break, were the implementation of ConcurrentSkipListMap ever to change.", "author": "jonmv", "createdAt": "2020-06-11T11:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcwNjY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNTc3OA==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438735778", "bodyText": "Put a guard on state being RUNNING in the iteration.", "author": "jonmv", "createdAt": "2020-06-11T12:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcwNjY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxMDYxNw==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438710617", "bodyText": "I'm one of those filthy {} lovers, so consider adding braces around at least the outer for-loop since it's easy to accidentally put things in the wrong scope when using multiple nested control flow statements", "author": "vekterli", "createdAt": "2020-06-11T11:12:18Z", "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentGet;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.fieldset.FieldCollection;\n+import com.yahoo.document.fieldset.FieldSet;\n+import com.yahoo.document.fieldset.FieldSetRepo;\n+import com.yahoo.document.select.DocumentSelector;\n+import com.yahoo.document.select.Result;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.AckToken;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorDataHandler;\n+import com.yahoo.documentapi.VisitorDataQueue;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorResponse;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.PutDocumentMessage;\n+import com.yahoo.messagebus.Trace;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Local visitor session that copies and iterates through all items in the local document access.\n+ * Each document must be ack'ed for the session to be done visiting.\n+ * Only document puts are sent by this session, and this is done from a separate thread.\n+ *\n+ * @author jonmv\n+ */\n+public class LocalVisitorSession implements VisitorSession {\n+\n+    private enum State { RUNNING, FAILURE, ABORTED, SUCCESS }\n+\n+    private final VisitorDataHandler data;\n+    private final VisitorControlHandler control;\n+    private final Map<DocumentId, Document> outstanding;\n+    private final DocumentSelector selector;\n+    private final FieldSet fieldSet;\n+    private final AtomicReference<State> state;\n+\n+    public LocalVisitorSession(LocalDocumentAccess access, VisitorParameters parameters) throws ParseException {\n+        if (parameters.getResumeToken() != null)\n+            throw new UnsupportedOperationException(\"Continuation via progress tokens is not supported\");\n+\n+        if (parameters.getRemoteDataHandler() != null)\n+            throw new UnsupportedOperationException(\"Remote data handlers are not supported\");\n+\n+        this.selector = new DocumentSelector(parameters.getDocumentSelection());\n+        this.fieldSet = new FieldSetRepo().parse(access.getDocumentTypeManager(), parameters.fieldSet());\n+\n+        this.data = parameters.getLocalDataHandler() == null ? new VisitorDataQueue() : parameters.getLocalDataHandler();\n+        this.data.reset();\n+        this.data.setSession(this);\n+\n+        this.control = parameters.getControlHandler() == null ? new VisitorControlHandler() : parameters.getControlHandler();\n+        this.control.reset();\n+        this.control.setSession(this);\n+\n+        this.outstanding = new ConcurrentSkipListMap<>(Comparator.comparing(DocumentId::toString));\n+        this.outstanding.putAll(access.documents);\n+        this.state = new AtomicReference<>(State.RUNNING);\n+\n+        start();\n+    }\n+\n+    void start() {\n+        new Thread(() -> {\n+            try {\n+                // Iterate through all documents and pass on to data handler\n+                outstanding.forEach((id, document) -> {\n+                    if (selector.accepts(new DocumentPut(document)) != Result.TRUE)\n+                        return;\n+\n+                    Document copy = new Document(document.getDataType(), document.getId());\n+                    for (Field field : document.getDataType().getFields())\n+                        if (fieldSet.contains(field))\n+                            copy.setFieldValue(field, document.getFieldValue(field));", "originalCommit": "801998b41aa21cd2998c93fcb48a6a380e875697", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMDQwMg==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438720402", "bodyText": "Alternatively, I see that this functionality is already provided in FieldSetRepo.copyFields", "author": "vekterli", "createdAt": "2020-06-11T11:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxMDYxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMTk4OA==", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438731988", "bodyText": "Sweet!", "author": "jonmv", "createdAt": "2020-06-11T11:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxMDYxNw=="}], "type": "inlineReview"}, {"oid": "4911919473cf6511fbd193c95cf0db81e5ebae07", "url": "https://github.com/vespa-engine/vespa/commit/4911919473cf6511fbd193c95cf0db81e5ebae07", "message": "Add draft LocalVisitorSession", "committedDate": "2020-06-11T11:45:11Z", "type": "commit"}, {"oid": "16ddfeb30367b2ee20ceaa7d89594585b5365e77", "url": "https://github.com/vespa-engine/vespa/commit/16ddfeb30367b2ee20ceaa7d89594585b5365e77", "message": "Minor fixes", "committedDate": "2020-06-11T11:45:11Z", "type": "commit"}, {"oid": "04612f061138bda3e5bff58313a2323dc4005b87", "url": "https://github.com/vespa-engine/vespa/commit/04612f061138bda3e5bff58313a2323dc4005b87", "message": "Update abi spec", "committedDate": "2020-06-11T11:45:11Z", "type": "commit"}, {"oid": "42852ad470315f3bd3e8da2701f3a2de91d14b95", "url": "https://github.com/vespa-engine/vespa/commit/42852ad470315f3bd3e8da2701f3a2de91d14b95", "message": "Respect selection and field set parameters, and unit test LocalVisitorSession", "committedDate": "2020-06-11T11:45:11Z", "type": "commit"}, {"oid": "3fbc3d229163ab22c80988bf80c7919e5c1a4497", "url": "https://github.com/vespa-engine/vespa/commit/3fbc3d229163ab22c80988bf80c7919e5c1a4497", "message": "Use library to copy fields, and make more robust wrt. future concurrency changes", "committedDate": "2020-06-11T12:08:43Z", "type": "commit"}, {"oid": "3fbc3d229163ab22c80988bf80c7919e5c1a4497", "url": "https://github.com/vespa-engine/vespa/commit/3fbc3d229163ab22c80988bf80c7919e5c1a4497", "message": "Use library to copy fields, and make more robust wrt. future concurrency changes", "committedDate": "2020-06-11T12:08:43Z", "type": "forcePushed"}]}