{"pr_number": 14901, "pr_title": "andreer/delete unused certs 1", "pr_createdAt": "2020-10-15T12:24:10Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/14901", "timeline": [{"oid": "8c7ad4461f87c48990ff75b98c58189ffbebc04e", "url": "https://github.com/vespa-engine/vespa/commit/8c7ad4461f87c48990ff75b98c58189ffbebc04e", "message": "add delete cert method to endpoint certificate providers", "committedDate": "2020-10-12T13:11:41Z", "type": "commit"}, {"oid": "c6070c2eea59ba1f47a35c8c1740cb88a9c19dc1", "url": "https://github.com/vespa-engine/vespa/commit/c6070c2eea59ba1f47a35c8c1740cb88a9c19dc1", "message": "delete unused certificates (guarded by feature flag)", "committedDate": "2020-10-15T12:21:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU4MTY4Nw==", "url": "https://github.com/vespa-engine/vespa/pull/14901#discussion_r505581687", "bodyText": "What's the reason this isn't done through the ApplicationController?", "author": "jonmv", "createdAt": "2020-10-15T14:19:49Z", "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/certificate/EndpointCertificateManager.java", "diffHunk": "@@ -129,76 +129,52 @@ public EndpointCertificateManager(ZoneRegistry zoneRegistry,\n             return Optional.of(reprovisionedCertificateMetadata);\n         }\n \n-        // If feature flag set for application, look for and use refreshed certificate\n-        if (useRefreshedEndpointCertificate.with(FetchVector.Dimension.APPLICATION_ID, instance.id().serializedForm()).value()) {\n-            var latestAvailableVersion = latestVersionInSecretStore(currentCertificateMetadata.get());\n-\n-            if (latestAvailableVersion.isPresent() && latestAvailableVersion.getAsInt() > currentCertificateMetadata.get().version()) {\n-                var refreshedCertificateMetadata = currentCertificateMetadata.get().withVersion(latestAvailableVersion.getAsInt());\n-                validateEndpointCertificate(refreshedCertificateMetadata, instance, zone);\n-                curator.writeEndpointCertificateMetadata(instance.id(), refreshedCertificateMetadata);\n-                return Optional.of(refreshedCertificateMetadata);\n-            }\n+        // Look for and use refreshed certificate\n+        var latestAvailableVersion = latestVersionInSecretStore(currentCertificateMetadata.get());\n+        if (latestAvailableVersion.isPresent() && latestAvailableVersion.getAsInt() > currentCertificateMetadata.get().version()) {\n+            var refreshedCertificateMetadata = currentCertificateMetadata.get().withVersion(latestAvailableVersion.getAsInt());\n+            validateEndpointCertificate(refreshedCertificateMetadata, instance, zone);\n+            curator.writeEndpointCertificateMetadata(instance.id(), refreshedCertificateMetadata);\n+            return Optional.of(refreshedCertificateMetadata);\n         }\n \n         validateEndpointCertificate(currentCertificateMetadata.get(), instance, zone);\n         return currentCertificateMetadata;\n     }\n \n-    enum BackfillMode {\n+    enum CleanupMode {\n         DISABLE,\n         DRYRUN,\n         ENABLE\n     }\n \n-    private void backfillCertificateMetadata() {\n-        BackfillMode mode = BackfillMode.valueOf(endpointCertificateBackfill.value());\n-        if (mode == BackfillMode.DISABLE) return;\n-\n-        List<EndpointCertificateMetadata> allProviderCertificateMetadata = endpointCertificateProvider.listCertificates();\n-        Map<String, EndpointCertificateMetadata> sanToEndpointCertificate = new HashMap<>();\n-\n-        allProviderCertificateMetadata.forEach((providerMetadata -> {\n-            if (providerMetadata.request_id().isEmpty())\n-                throw new RuntimeException(\"Backfill failed - provider metadata missing request_id\");\n-            if (providerMetadata.requestedDnsSans().isEmpty())\n-                throw new RuntimeException(\"Backfill failed - provider metadata missing DNS SANs for \" + providerMetadata.request_id().get());\n-            providerMetadata.requestedDnsSans().get().forEach(san -> sanToEndpointCertificate.put(san, providerMetadata)\n-            );\n-        }));\n-\n-        Map<ApplicationId, EndpointCertificateMetadata> allEndpointCertificateMetadata = curator.readAllEndpointCertificateMetadata();\n-\n-        allEndpointCertificateMetadata.forEach((applicationId, storedMetaData) -> {\n-            if (storedMetaData.requestedDnsSans().isPresent() && storedMetaData.request_id().isPresent() && storedMetaData.issuer().isPresent())\n-                return;\n-\n-            var hashedCn = commonNameHashOf(applicationId, zoneRegistry.system()); // use as join key\n-            EndpointCertificateMetadata providerMetadata = sanToEndpointCertificate.get(hashedCn);\n-\n-            if (providerMetadata == null) {\n-                log.log(Level.INFO, \"No matching certificate provider metadata found for application \" + applicationId.serializedForm());\n-                return;\n-            }\n-\n-            EndpointCertificateMetadata backfilledMetadata =\n-                    new EndpointCertificateMetadata(\n-                            storedMetaData.keyName(),\n-                            storedMetaData.certName(),\n-                            storedMetaData.version(),\n-                            Instant.now().getEpochSecond(),\n-                            providerMetadata.request_id(),\n-                            providerMetadata.requestedDnsSans(),\n-                            providerMetadata.issuer());\n-\n-            if (mode == BackfillMode.DRYRUN) {\n-                log.log(Level.INFO, \"Would update stored metadata \" + storedMetaData + \" with data from provider: \" + backfilledMetadata);\n-            } else if (mode == BackfillMode.ENABLE) {\n-                curator.writeEndpointCertificateMetadata(applicationId, backfilledMetadata);\n+    private void deleteUnusedCertificates() {\n+        CleanupMode mode = CleanupMode.valueOf(deleteUnusedEndpointCertificates.value());\n+        if (mode == CleanupMode.DISABLE) return;\n+\n+        var oneMonthAgo = clock.instant().minus(1, ChronoUnit.MONTHS);\n+        curator.readAllEndpointCertificateMetadata().forEach((applicationId, storedMetaData) -> {\n+            var lastRequested = Instant.ofEpochSecond(storedMetaData.lastRequested());\n+            if (lastRequested.isBefore(oneMonthAgo) && hasNoDeployments(applicationId)) {\n+                log.log(LogLevel.INFO, \"Cert for app \" + applicationId.serializedForm()\n+                        + \" has not been requested in a month and app has no deployments\"\n+                        + (mode == CleanupMode.ENABLE ? \", deleting from provider and ZK\" : \"\"));\n+                if (mode == CleanupMode.ENABLE) {\n+                    endpointCertificateProvider.deleteCertificate(applicationId, storedMetaData);\n+                    curator.deleteEndpointCertificateMetadata(applicationId);\n+                }\n             }\n         });\n     }\n \n+    private boolean hasNoDeployments(ApplicationId applicationId) {\n+        var deployments = curator.readApplication(TenantAndApplicationId.from(applicationId))", "originalCommit": "c6070c2eea59ba1f47a35c8c1740cb88a9c19dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA1MjM4Mg==", "url": "https://github.com/vespa-engine/vespa/pull/14901#discussion_r506052382", "bodyText": "Instantiating the ApplicationController for unit tests seemed like more trouble than it was worth. Maybe I should have mocked it instead?", "author": "andreer", "createdAt": "2020-10-16T04:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU4MTY4Nw=="}], "type": "inlineReview"}]}