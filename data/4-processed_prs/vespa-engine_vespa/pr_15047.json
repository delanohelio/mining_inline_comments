{"pr_number": 15047, "pr_title": "Arnej/add generic create", "pr_createdAt": "2020-10-27T13:21:06Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/15047", "timeline": [{"oid": "7f6401e3df6d7d21824d77a31a86b2b7126fe9e0", "url": "https://github.com/vespa-engine/vespa/commit/7f6401e3df6d7d21824d77a31a86b2b7126fe9e0", "message": "add generic create instruction", "committedDate": "2020-10-27T09:59:11Z", "type": "commit"}, {"oid": "3e931dee99b3a5a61667dd0fba2c721d718a19b7", "url": "https://github.com/vespa-engine/vespa/commit/3e931dee99b3a5a61667dd0fba2c721d718a19b7", "message": "take a more generic spec in GenericCreate::make_instruction", "committedDate": "2020-10-27T13:19:31Z", "type": "commit"}, {"oid": "edc42f4b6b5fcc331e077c921c639643d3fbaa07", "url": "https://github.com/vespa-engine/vespa/commit/edc42f4b6b5fcc331e077c921c639643d3fbaa07", "message": "unit test GenericCreate", "committedDate": "2020-10-27T13:19:34Z", "type": "commit"}, {"oid": "8ee85997bdf22b628bb2c5ceb4f0b7e9f8d3f0b3", "url": "https://github.com/vespa-engine/vespa/commit/8ee85997bdf22b628bb2c5ceb4f0b7e9f8d3f0b3", "message": "switch param order", "committedDate": "2020-10-27T14:35:18Z", "type": "commit"}, {"oid": "ebcb5df47d3cf443656edf9f11fc4a0bf50b0b45", "url": "https://github.com/vespa-engine/vespa/commit/ebcb5df47d3cf443656edf9f11fc4a0bf50b0b45", "message": "do it like new value codec", "committedDate": "2020-10-27T14:35:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5NjU3Nw==", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512696577", "bodyText": "consider testing with float mixed tensor as well", "author": "havardpe", "createdAt": "2020-10-27T13:36:19Z", "path": "eval/src/tests/instruction/generic_create/generic_create_test.cpp", "diffHunk": "@@ -0,0 +1,97 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/eval/simple_value.h>\n+#include <vespa/eval/eval/fast_value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/instruction/generic_create.h>\n+#include <vespa/eval/eval/interpreted_function.h>\n+#include <vespa/eval/eval/test/tensor_model.hpp>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <stdlib.h>\n+#include <algorithm>\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::instruction;\n+using namespace vespalib::eval::test;\n+\n+using vespalib::make_string_short::fmt;\n+\n+std::vector<Layout> create_layouts = {\n+    {x(3)},\n+    {x(3),y(2)},\n+    float_cells({x(3)}),\n+    {x({\"a\",\"b\",\"c\"})},\n+    {x({\"a\",\"b\",\"c\"}),y({\"foo\",\"bar\"})},\n+    float_cells({x({\"a\",\"b\",\"c\"})}),\n+    {x(3),y({\"foo\", \"bar\"})}", "originalCommit": "edc42f4b6b5fcc331e077c921c639643d3fbaa07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3ODA0NQ==", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512778045", "bodyText": "fixes", "author": "arnej27959", "createdAt": "2020-10-27T15:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5NjU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcwMjY0MA==", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512702640", "bodyText": "consider having result type as first parameter", "author": "havardpe", "createdAt": "2020-10-27T13:44:03Z", "path": "eval/src/vespa/eval/instruction/generic_create.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"generic_create.h\"\n+#include <vespa/eval/eval/wrap_param.h>\n+#include <vespa/vespalib/util/stash.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <cassert>\n+\n+using namespace vespalib::eval::tensor_function;\n+\n+namespace vespalib::eval::instruction {\n+\n+using State = InterpretedFunction::State;\n+using Instruction = InterpretedFunction::Instruction;\n+\n+namespace {\n+\n+struct CreateParam {\n+    using Key = std::vector<vespalib::string>;\n+    using Indexes = std::vector<size_t>;\n+\n+    const ValueType res_type;\n+    size_t num_mapped_dims;\n+    size_t dense_subspace_size;\n+    size_t num_children;\n+    std::map<Key,Indexes> my_spec;\n+    const ValueBuilderFactory &factory;\n+\n+    static constexpr size_t npos = -1;\n+\n+    Indexes &indexes(Key key) {\n+        auto iter = my_spec.find(key);\n+        if (iter == my_spec.end()) {\n+            Indexes empty(dense_subspace_size, npos);\n+            iter = my_spec.emplace(key, empty).first;\n+        }\n+        return iter->second;\n+    }\n+\n+    CreateParam(const GenericCreate::SpecMap &spec_in,\n+                const ValueType &res_type_in,\n+                const ValueBuilderFactory &factory_in)\n+        : res_type(res_type_in),\n+          num_mapped_dims(res_type.count_mapped_dimensions()),\n+          dense_subspace_size(res_type.dense_subspace_size()),\n+          num_children(spec_in.size()),\n+          my_spec(),\n+          factory(factory_in)\n+    {\n+        size_t last_child = num_children - 1;\n+        for (const auto & kv : spec_in) {\n+            Key sparse_addr;\n+            size_t dense_idx = 0;\n+            for (const auto &dim : res_type.dimensions()) {\n+                auto iter = kv.first.find(dim.name);\n+                if (dim.is_mapped()) {\n+                    sparse_addr.push_back(iter->second.name);\n+                } else {\n+                    assert(dim.is_indexed());\n+                    dense_idx *= dim.size;\n+                    dense_idx += iter->second.index;\n+                }\n+            }\n+            // note: reverse order of children on stack\n+            size_t stack_idx = last_child - kv.second;\n+            indexes(sparse_addr)[dense_idx] = stack_idx;\n+        }\n+    }\n+};\n+\n+template <typename T>\n+void my_generic_create_op(State &state, uint64_t param_in) {\n+    const auto &param = unwrap_param<CreateParam>(param_in);\n+    auto builder = param.factory.create_value_builder<T>(param.res_type,\n+                                                           param.num_mapped_dims,\n+                                                           param.dense_subspace_size,\n+                                                           param.my_spec.size());\n+    std::vector<vespalib::stringref> sparse_addr;\n+    for (const auto & kv : param.my_spec) {\n+        sparse_addr.clear();\n+        for (const auto & label : kv.first) {\n+            sparse_addr.emplace_back(label);\n+        }\n+        T *dst = builder->add_subspace(sparse_addr).begin();\n+        for (size_t stack_idx : kv.second) {\n+            if (stack_idx == CreateParam::npos) {\n+                *dst++ = T{};\n+            } else {\n+                const Value &child = state.peek(stack_idx);\n+                *dst++ = child.as_double();\n+            }\n+        }\n+    }        \n+    const Value &result = *state.stash.create<Value::UP>(builder->build(std::move(builder)));\n+    state.pop_n_push(param.num_children, result);\n+};\n+\n+struct SelectGenericCreateOp {\n+    template <typename T> static auto invoke() {\n+        return my_generic_create_op<T>;\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+} // namespace <unnamed>\n+\n+Instruction\n+GenericCreate::make_instruction(const SpecMap &spec,", "originalCommit": "edc42f4b6b5fcc331e077c921c639643d3fbaa07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3ODE2OA==", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512778168", "bodyText": "fixed", "author": "arnej27959", "createdAt": "2020-10-27T15:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcwMjY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcwNjk1Ng==", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512706956", "bodyText": "consider using array_array_map", "author": "havardpe", "createdAt": "2020-10-27T13:49:26Z", "path": "eval/src/vespa/eval/instruction/generic_create.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"generic_create.h\"\n+#include <vespa/eval/eval/wrap_param.h>\n+#include <vespa/vespalib/util/stash.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <cassert>\n+\n+using namespace vespalib::eval::tensor_function;\n+\n+namespace vespalib::eval::instruction {\n+\n+using State = InterpretedFunction::State;\n+using Instruction = InterpretedFunction::Instruction;\n+\n+namespace {\n+\n+struct CreateParam {\n+    using Key = std::vector<vespalib::string>;\n+    using Indexes = std::vector<size_t>;\n+\n+    const ValueType res_type;\n+    size_t num_mapped_dims;\n+    size_t dense_subspace_size;\n+    size_t num_children;\n+    std::map<Key,Indexes> my_spec;", "originalCommit": "edc42f4b6b5fcc331e077c921c639643d3fbaa07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3ODI4NA==", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512778284", "bodyText": "done", "author": "arnej27959", "createdAt": "2020-10-27T15:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcwNjk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0MjIxMA==", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512742210", "bodyText": "consider using simple value to fill (since this is the 'reference')", "author": "havardpe", "createdAt": "2020-10-27T14:31:01Z", "path": "eval/src/tests/instruction/generic_create/generic_create_test.cpp", "diffHunk": "@@ -0,0 +1,97 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/eval/simple_value.h>\n+#include <vespa/eval/eval/fast_value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/instruction/generic_create.h>\n+#include <vespa/eval/eval/interpreted_function.h>\n+#include <vespa/eval/eval/test/tensor_model.hpp>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <stdlib.h>\n+#include <algorithm>\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::instruction;\n+using namespace vespalib::eval::test;\n+\n+using vespalib::make_string_short::fmt;\n+\n+std::vector<Layout> create_layouts = {\n+    {x(3)},\n+    {x(3),y(2)},\n+    float_cells({x(3)}),\n+    {x({\"a\",\"b\",\"c\"})},\n+    {x({\"a\",\"b\",\"c\"}),y({\"foo\",\"bar\"})},\n+    float_cells({x({\"a\",\"b\",\"c\"})}),\n+    {x(3),y({\"foo\", \"bar\"})}\n+};\n+\n+TensorSpec remove_each(const TensorSpec &a, size_t n) {\n+    TensorSpec b(a.type());\n+    for (const auto & kv : a.cells()) {\n+        size_t v = kv.second;\n+        if ((v % n) != 0) {\n+            b.add(kv.first, kv.second);\n+        }\n+    }\n+    return b;\n+}\n+\n+struct NumberedCellSpec {\n+    long int num;\n+    TensorSpec::Address addr;\n+    double value;\n+};\n+\n+bool operator< (const NumberedCellSpec &a, const NumberedCellSpec &b) {\n+    return a.num < b.num;\n+}\n+\n+TensorSpec perform_generic_create(const TensorSpec &a, const ValueBuilderFactory &factory)\n+{\n+    ValueType res_type = ValueType::from_spec(a.type());\n+    EXPECT_FALSE(res_type.is_error());\n+    Stash stash;\n+    std::vector<NumberedCellSpec> scramble;\n+    for (const auto & kv : a.cells()) {\n+        NumberedCellSpec cell{random(), kv.first, kv.second};\n+        scramble.push_back(cell);\n+    }\n+    std::sort(scramble.begin(), scramble.end());\n+    std::vector<Value::CREF> my_stack;\n+    std::map<TensorSpec::Address,size_t> create_spec;\n+    for (size_t child_idx = 0; child_idx < scramble.size(); ++child_idx) {\n+        auto cell = scramble[child_idx];\n+        create_spec.emplace(cell.addr, child_idx);\n+        my_stack.push_back(stash.create<DoubleValue>(cell.value));\n+    }\n+    auto my_op = GenericCreate::make_instruction(create_spec, res_type, factory, stash);\n+    InterpretedFunction::EvalSingle single(factory, my_op);\n+    return spec_from_value(single.eval(my_stack));\n+}\n+\n+void test_generic_create_with(const ValueBuilderFactory &factory) {\n+    for (const auto & layout : create_layouts) {\n+        TensorSpec full = spec(layout, N());\n+        auto actual = perform_generic_create(full, factory);\n+        EXPECT_EQ(actual, full);\n+        for (size_t n : {2, 3, 4, 5}) {\n+            TensorSpec partial = remove_each(full, n);\n+            actual = perform_generic_create(partial, factory);\n+            auto filled = spec_from_value(*value_from_spec(partial, factory));", "originalCommit": "edc42f4b6b5fcc331e077c921c639643d3fbaa07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3ODQzMw==", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512778433", "bodyText": "fixed", "author": "arnej27959", "createdAt": "2020-10-27T15:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0MjIxMA=="}], "type": "inlineReview"}, {"oid": "bfdf91325932e0db3a1fe9683868bb3c53d88d36", "url": "https://github.com/vespa-engine/vespa/commit/bfdf91325932e0db3a1fe9683868bb3c53d88d36", "message": "just do all the layouts from map test", "committedDate": "2020-10-27T14:45:27Z", "type": "commit"}, {"oid": "157b7d014c24e60a10ce5a6add343928f03d06bb", "url": "https://github.com/vespa-engine/vespa/commit/157b7d014c24e60a10ce5a6add343928f03d06bb", "message": "use SimpleValueBuilderFactory in reference fill", "committedDate": "2020-10-27T14:47:17Z", "type": "commit"}, {"oid": "dbd8cc9c5d336c42ac8a1443880d536f4b97a604", "url": "https://github.com/vespa-engine/vespa/commit/dbd8cc9c5d336c42ac8a1443880d536f4b97a604", "message": "use ArrayArrayMap", "committedDate": "2020-10-27T15:12:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3NzMyOA==", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r513277328", "bodyText": "I think this was problematic with some compilers since we need to use the implicit cast from string to stringref (there is no stringref constructor taking a string).\nprefer push_back here.", "author": "havardpe", "createdAt": "2020-10-28T09:00:43Z", "path": "eval/src/vespa/eval/instruction/generic_create.cpp", "diffHunk": "@@ -81,21 +81,22 @@ void my_generic_create_op(State &state, uint64_t param_in) {\n                                                          param.dense_subspace_size,\n                                                          param.my_spec.size());\n     std::vector<vespalib::stringref> sparse_addr;\n-    for (const auto & kv : param.my_spec) {\n-        sparse_addr.clear();\n-        for (const auto & label : kv.first) {\n-            sparse_addr.emplace_back(label);\n-        }\n-        T *dst = builder->add_subspace(sparse_addr).begin();\n-        for (size_t stack_idx : kv.second) {\n-            if (stack_idx == CreateParam::npos) {\n-                *dst++ = T{};\n-            } else {\n-                const Value &child = state.peek(stack_idx);\n-                *dst++ = child.as_double();\n+    param.my_spec.each_entry([&](const auto &key, const auto &values)\n+        {\n+            sparse_addr.clear();\n+            for (const auto & label : key) {\n+                sparse_addr.emplace_back(label);", "originalCommit": "dbd8cc9c5d336c42ac8a1443880d536f4b97a604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1e1683b0b11aa9e5131e55241e66c52ae1b497d0", "url": "https://github.com/vespa-engine/vespa/commit/1e1683b0b11aa9e5131e55241e66c52ae1b497d0", "message": "avoid potential ambiguity in constructor selection", "committedDate": "2020-10-28T10:56:25Z", "type": "commit"}]}