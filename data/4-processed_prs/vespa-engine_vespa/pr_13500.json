{"pr_number": 13500, "pr_title": "Revert \"Revert \"When we pull in a cacheline, we should use it too.\"\"", "pr_createdAt": "2020-06-08T06:52:12Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/13500", "timeline": [{"oid": "bebe03c7b970744d09eb26f7383da4f8c1244a36", "url": "https://github.com/vespa-engine/vespa/commit/bebe03c7b970744d09eb26f7383da4f8c1244a36", "message": "Revert \"Revert \"When we pull in a cacheline, we should use it too.\"\"", "committedDate": "2020-06-08T06:51:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MDQ5NQ==", "url": "https://github.com/vespa-engine/vespa/pull/13500#discussion_r437240495", "bodyText": "I think the magic should be done outside the update call and the update call just forward to the appropriate function.", "author": "havardpe", "createdAt": "2020-06-09T08:47:33Z", "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,91 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(Children children) : MultiBitVectorIteratorBase(std::move(children)) { }\n+    explicit MultiBitVectorIterator(Children children)\n+        : MultiBitVectorIteratorBase(std::move(children)),\n+          _update(),\n+          _accel(IAccelrated::getAccelerator()),\n+          _lastWords()\n+    {\n+        static_assert(sizeof(_lastWords) == 64, \"Latswords should have 64 byte size\");\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    const IAccelrated & _accel;\n+    alignas(64) Word    _lastWords[8];\n };\n \n template<typename Update>\n class MultiBitVectorIteratorStrict : public MultiBitVectorIterator<Update>\n {\n public:\n-    MultiBitVectorIteratorStrict(MultiSearch::Children children) : MultiBitVectorIterator<Update>(std::move(children)) { }\n+    explicit MultiBitVectorIteratorStrict(MultiSearch::Children  children)\n+        : MultiBitVectorIterator<Update>(std::move(children))\n+    { }\n private:\n     void doSeek(uint32_t docId) override { this->strictSeek(docId); }\n     Trinary is_strict() const override { return Trinary::True; }\n };\n \n+struct And {\n+    using Word = BitWord::Word;\n+    void operator () (const IAccelrated & accel, size_t offset, const std::vector<std::pair<const void *, bool>> & src, Word *dest) {\n+        accel.and64(offset*sizeof(uint64_t), src, dest);\n+    }\n+    static bool isAnd() { return true; }\n+};\n+\n+struct Or {\n+    using Word = BitWord::Word;\n+    void operator () (const IAccelrated & accel, size_t offset, const std::vector<std::pair<const void *, bool>> & src, Word *dest) {\n+        accel.or64(offset*sizeof(uint64_t), src, dest);\n+    }\n+    static bool isAnd() { return false; }\n+};\n+\n template<typename Update>\n void MultiBitVectorIterator<Update>::updateLastValue(uint32_t docId)\n {\n     if (docId >= _lastMaxDocIdLimit) {\n-        if (__builtin_expect(docId < _numDocs, true)) {\n-            const uint32_t index(wordNum(docId));\n-            _lastValue = _bvs[0][index];\n-            for(uint32_t i(1); i < _bvs.size(); i++) {\n-                _lastValue = _update(_lastValue, _bvs[i][index]);\n-            }\n-            _lastMaxDocIdLimit = (index + 1) * WordLen;\n-        } else {\n+        if (__builtin_expect(docId >= _numDocs, false)) {\n             setAtEnd();\n+            return;\n+        }\n+        const uint32_t index(wordNum(docId));\n+        if (docId >= _lastMaxDocIdLimitRequireFetch) {\n+            uint32_t baseIndex = index & ~(sizeof(_lastWords)/sizeof(Word) - 1);\n+            _update(_accel, baseIndex, _bvs, _lastWords);", "originalCommit": "bebe03c7b970744d09eb26f7383da4f8c1244a36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTU4NA==", "url": "https://github.com/vespa-engine/vespa/pull/13500#discussion_r437275584", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-06-09T09:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MDQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MTMwNQ==", "url": "https://github.com/vespa-engine/vespa/pull/13500#discussion_r437241305", "bodyText": "offset should already be bytes here, and destination void.", "author": "havardpe", "createdAt": "2020-06-09T08:48:45Z", "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,91 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(Children children) : MultiBitVectorIteratorBase(std::move(children)) { }\n+    explicit MultiBitVectorIterator(Children children)\n+        : MultiBitVectorIteratorBase(std::move(children)),\n+          _update(),\n+          _accel(IAccelrated::getAccelerator()),\n+          _lastWords()\n+    {\n+        static_assert(sizeof(_lastWords) == 64, \"Latswords should have 64 byte size\");\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    const IAccelrated & _accel;\n+    alignas(64) Word    _lastWords[8];\n };\n \n template<typename Update>\n class MultiBitVectorIteratorStrict : public MultiBitVectorIterator<Update>\n {\n public:\n-    MultiBitVectorIteratorStrict(MultiSearch::Children children) : MultiBitVectorIterator<Update>(std::move(children)) { }\n+    explicit MultiBitVectorIteratorStrict(MultiSearch::Children  children)\n+        : MultiBitVectorIterator<Update>(std::move(children))\n+    { }\n private:\n     void doSeek(uint32_t docId) override { this->strictSeek(docId); }\n     Trinary is_strict() const override { return Trinary::True; }\n };\n \n+struct And {\n+    using Word = BitWord::Word;\n+    void operator () (const IAccelrated & accel, size_t offset, const std::vector<std::pair<const void *, bool>> & src, Word *dest) {", "originalCommit": "bebe03c7b970744d09eb26f7383da4f8c1244a36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTI3Nw==", "url": "https://github.com/vespa-engine/vespa/pull/13500#discussion_r437275277", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-06-09T09:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MTMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MTkwMA==", "url": "https://github.com/vespa-engine/vespa/pull/13500#discussion_r437241900", "bodyText": "offset is probably in Words and not in uint64_t, but I think this magic should be done together with the other magic anyways.", "author": "havardpe", "createdAt": "2020-06-09T08:49:41Z", "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,91 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(Children children) : MultiBitVectorIteratorBase(std::move(children)) { }\n+    explicit MultiBitVectorIterator(Children children)\n+        : MultiBitVectorIteratorBase(std::move(children)),\n+          _update(),\n+          _accel(IAccelrated::getAccelerator()),\n+          _lastWords()\n+    {\n+        static_assert(sizeof(_lastWords) == 64, \"Latswords should have 64 byte size\");\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    const IAccelrated & _accel;\n+    alignas(64) Word    _lastWords[8];\n };\n \n template<typename Update>\n class MultiBitVectorIteratorStrict : public MultiBitVectorIterator<Update>\n {\n public:\n-    MultiBitVectorIteratorStrict(MultiSearch::Children children) : MultiBitVectorIterator<Update>(std::move(children)) { }\n+    explicit MultiBitVectorIteratorStrict(MultiSearch::Children  children)\n+        : MultiBitVectorIterator<Update>(std::move(children))\n+    { }\n private:\n     void doSeek(uint32_t docId) override { this->strictSeek(docId); }\n     Trinary is_strict() const override { return Trinary::True; }\n };\n \n+struct And {\n+    using Word = BitWord::Word;\n+    void operator () (const IAccelrated & accel, size_t offset, const std::vector<std::pair<const void *, bool>> & src, Word *dest) {\n+        accel.and64(offset*sizeof(uint64_t), src, dest);", "originalCommit": "bebe03c7b970744d09eb26f7383da4f8c1244a36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTEyNQ==", "url": "https://github.com/vespa-engine/vespa/pull/13500#discussion_r437275125", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-06-09T09:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MTkwMA=="}], "type": "inlineReview"}, {"oid": "4e90b78dd51b7d7387b9a8ccd2c2036f78dd65c5", "url": "https://github.com/vespa-engine/vespa/commit/4e90b78dd51b7d7387b9a8ccd2c2036f78dd65c5", "message": "Add static_assert for sanity of template arguments.", "committedDate": "2020-06-09T09:08:56Z", "type": "commit"}, {"oid": "013ffaf1e6627a048a32cee4d8c29d7843c93462", "url": "https://github.com/vespa-engine/vespa/commit/013ffaf1e6627a048a32cee4d8c29d7843c93462", "message": "- Compute batch size in one place.\n- Compute offset in one place.", "committedDate": "2020-06-09T09:31:52Z", "type": "commit"}]}