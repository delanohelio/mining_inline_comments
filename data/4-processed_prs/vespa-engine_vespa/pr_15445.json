{"pr_number": 15445, "pr_title": "Arnej/add simple streamed value", "pr_createdAt": "2020-11-24T13:37:25Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/15445", "timeline": [{"oid": "359903c03748d520357067d03e7ac8eed7c5a19b", "url": "https://github.com/vespa-engine/vespa/commit/359903c03748d520357067d03e7ac8eed7c5a19b", "message": "add StreamedValue", "committedDate": "2020-11-23T11:04:18Z", "type": "commit"}, {"oid": "e122e2fde2c837120427328fc5bee19faf461554", "url": "https://github.com/vespa-engine/vespa/commit/e122e2fde2c837120427328fc5bee19faf461554", "message": "add CellTypeUtils class with various static constexpr methods", "committedDate": "2020-11-23T11:04:18Z", "type": "commit"}, {"oid": "5c2af6bd843c4e3a63da61fc7f16927d151502b4", "url": "https://github.com/vespa-engine/vespa/commit/5c2af6bd843c4e3a63da61fc7f16927d151502b4", "message": "add unit test for StreamedValue", "committedDate": "2020-11-23T11:04:18Z", "type": "commit"}, {"oid": "11e57b2a0ba2e68f654d2369c79024e44d321bd7", "url": "https://github.com/vespa-engine/vespa/commit/11e57b2a0ba2e68f654d2369c79024e44d321bd7", "message": "run conformance test for StreamedValue also", "committedDate": "2020-11-23T11:04:18Z", "type": "commit"}, {"oid": "d73cb9413b0b39943395a717ec20ce6cd89fa47f", "url": "https://github.com/vespa-engine/vespa/commit/d73cb9413b0b39943395a717ec20ce6cd89fa47f", "message": "add documentation comments", "committedDate": "2020-11-24T13:24:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxMzA1OQ==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529613059", "bodyText": "these should be owned by the value codec. (including id_of and type_of functions)", "author": "havardpe", "createdAt": "2020-11-24T15:02:57Z", "path": "eval/src/vespa/eval/eval/cell_type.h", "diffHunk": "@@ -25,14 +25,68 @@ template <typename CT> inline CellType get_cell_type();\n template <> inline CellType get_cell_type<double>() { return CellType::DOUBLE; }\n template <> inline CellType get_cell_type<float>() { return CellType::FLOAT; }\n \n+struct CellTypeUtils {\n+    template <typename CT> static constexpr bool check(CellType type);\n+    template <typename CT> static constexpr CellType get_type();\n+\n+    static constexpr uint32_t DOUBLE_ID = 0;", "originalCommit": "d73cb9413b0b39943395a717ec20ce6cd89fa47f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxNTExNQ==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529615115", "bodyText": "check/get should be left as is", "author": "havardpe", "createdAt": "2020-11-24T15:05:39Z", "path": "eval/src/vespa/eval/eval/cell_type.h", "diffHunk": "@@ -25,14 +25,68 @@ template <typename CT> inline CellType get_cell_type();\n template <> inline CellType get_cell_type<double>() { return CellType::DOUBLE; }\n template <> inline CellType get_cell_type<float>() { return CellType::FLOAT; }\n \n+struct CellTypeUtils {\n+    template <typename CT> static constexpr bool check(CellType type);\n+    template <typename CT> static constexpr CellType get_type();\n+\n+    static constexpr uint32_t DOUBLE_ID = 0;\n+    static constexpr uint32_t FLOAT_ID = 1;\n+\n+    static constexpr uint32_t id_of(CellType cell_type) {\n+        switch (cell_type) {\n+        case CellType::DOUBLE: return DOUBLE_ID;\n+        case CellType::FLOAT: return FLOAT_ID;\n+        }\n+        bad_argument((uint32_t)cell_type);\n+    }\n+\n+    static constexpr CellType type_of(uint32_t id) {\n+        switch (id) {\n+        case DOUBLE_ID: return CellType::DOUBLE;\n+        case FLOAT_ID: return CellType::FLOAT;\n+        }\n+        bad_argument(id);\n+    }\n+\n+    static void bad_argument [[ noreturn ]] (uint32_t id);\n+\n+    static constexpr uint32_t alignment(CellType cell_type) {\n+        switch (cell_type) {\n+        case CellType::DOUBLE: return sizeof(double);\n+        case CellType::FLOAT: return sizeof(float);\n+        }\n+        bad_argument((uint32_t)cell_type);\n+    }\n+\n+    static constexpr size_t mem_size(CellType cell_type, size_t sz) {\n+        switch (cell_type) {\n+        case CellType::DOUBLE: return sz * sizeof(double);\n+        case CellType::FLOAT:  return sz * sizeof(float);\n+        }\n+        bad_argument((uint32_t)cell_type);\n+    }\n+};\n+\n+template <> constexpr bool ", "originalCommit": "d73cb9413b0b39943395a717ec20ce6cd89fa47f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxNjY3Nw==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529616677", "bodyText": "what about the other memory?", "author": "havardpe", "createdAt": "2020-11-24T15:07:36Z", "path": "eval/src/vespa/eval/streamed/streamed_value.cpp", "diffHunk": "@@ -0,0 +1,24 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"streamed_value.h\"\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".vespalib.eval.streamed.streamed_value\");\n+\n+namespace vespalib::eval {\n+\n+template <typename T>\n+StreamedValue<T>::~StreamedValue() = default;\n+\n+template <typename T>\n+MemoryUsage\n+StreamedValue<T>::get_memory_usage() const\n+{\n+    return self_memory_usage<StreamedValue<T>>();", "originalCommit": "d73cb9413b0b39943395a717ec20ce6cd89fa47f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyNTUzNQ==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529625535", "bodyText": "do we need this?", "author": "havardpe", "createdAt": "2020-11-24T15:18:40Z", "path": "eval/src/vespa/eval/streamed/streamed_value_builder.h", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"streamed_value.h\"\n+#include <vespa/vespalib/objects/nbostream.h>\n+\n+namespace vespalib::eval {\n+\n+ /**\n+  *  Builder for StreamedValue objects.\n+  **/\n+template <typename T>\n+class StreamedValueBuilder : public ValueBuilder<T>\n+{\n+private:\n+    ValueType _type;\n+    size_t _dsss;\n+    std::vector<T> _cells;\n+    size_t _num_subspaces;\n+    nbostream _labels;\n+public:\n+    StreamedValueBuilder(const ValueType &type,\n+                         size_t num_mapped_in,\n+                         size_t subspace_size_in,\n+                         size_t expected_subspaces)\n+      : _type(type),\n+        _dsss(subspace_size_in),\n+        _cells(),\n+        _num_subspaces(0),\n+        _labels()\n+    {\n+        _cells.reserve(subspace_size_in * expected_subspaces);\n+        // assume small sized label strings:\n+        _labels.reserve(num_mapped_in * expected_subspaces * 3);\n+    };\n+\n+    ~StreamedValueBuilder();\n+\n+    ArrayRef<T> add_subspace(ConstArrayRef<vespalib::stringref> addr) override {\n+        for (auto label : addr) {\n+            _labels.writeSmallString(label);\n+        }\n+        size_t old_sz = _cells.size();\n+        _cells.resize(old_sz + _dsss);\n+        _num_subspaces++;\n+        return ArrayRef<T>(&_cells[old_sz], _dsss);\n+    }\n+\n+    std::unique_ptr<Value> build(std::unique_ptr<ValueBuilder<T>>) override {\n+        if (_num_subspaces == 0 && _type.count_mapped_dimensions() == 0) {\n+            // add required dense subspace\n+            add_subspace({});", "originalCommit": "d73cb9413b0b39943395a717ec20ce6cd89fa47f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzMDE1OA==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529630158", "bodyText": "why is this not an assert?", "author": "havardpe", "createdAt": "2020-11-24T15:24:24Z", "path": "eval/src/vespa/eval/streamed/streamed_value_view.h", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value_type.h>\n+#include <vespa/eval/eval/value.h>\n+#include \"streamed_value_index.h\"\n+\n+namespace vespalib::eval {\n+\n+ /**\n+  *  Same characteristics as StreamedValue, but does not\n+  *  own its data - refers to type, cells and serialized\n+  *  labels that must be kept outside the Value.\n+  **/\n+class StreamedValueView : public Value\n+{\n+private:\n+    const ValueType &_type;\n+    TypedCells _cells_ref;\n+    StreamedValueIndex _my_index;\n+\n+public:\n+    StreamedValueView(const ValueType &type, TypedCells cells,\n+                      size_t num_ss, ConstArrayRef<char> labels_buf)\n+      : _type(type),\n+        _cells_ref(cells),\n+        _my_index(_type.count_mapped_dimensions(), num_ss, labels_buf)\n+    {\n+        if (num_ss * _type.dense_subspace_size() != _cells_ref.size) abort();", "originalCommit": "d73cb9413b0b39943395a717ec20ce6cd89fa47f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzMjkwNw==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529632907", "bodyText": "this name is a bit misleading, since you do not actually serialize anything", "author": "havardpe", "createdAt": "2020-11-24T15:26:40Z", "path": "eval/src/vespa/eval/streamed/streamed_value_index.h", "diffHunk": "@@ -0,0 +1,36 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value.h>\n+\n+namespace vespalib::eval {\n+\n+ /**\n+  *  Implements Value::Index by reading a stream of serialized\n+  *  labels.\n+  **/\n+class StreamedValueIndex : public Value::Index\n+{\n+public:\n+    struct SerializedForm {\n+        uint32_t num_mapped_dims;\n+        uint32_t num_subspaces;\n+        ConstArrayRef<char> labels_buffer;\n+    };\n+    StreamedValueIndex(uint32_t num_mapped_dims, uint32_t num_subspaces, ConstArrayRef<char> labels_buf)\n+      : _data{num_mapped_dims, num_subspaces, labels_buf}\n+    {}\n+\n+    // index API:\n+    size_t size() const override { return _data.num_subspaces; }\n+    std::unique_ptr<View> create_view(const std::vector<size_t> &dims) const override;\n+\n+    SerializedForm serialize() const { return _data; }", "originalCommit": "d73cb9413b0b39943395a717ec20ce6cd89fa47f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzNzE5OA==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529637198", "bodyText": "this assert is a bit late", "author": "havardpe", "createdAt": "2020-11-24T15:29:37Z", "path": "eval/src/vespa/eval/streamed/streamed_value_index.cpp", "diffHunk": "@@ -0,0 +1,103 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"streamed_value_index.h\"\n+#include \"streamed_value_utils.h\"\n+\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_index\");\n+\n+namespace vespalib::eval {\n+\n+namespace {\n+\n+struct StreamedFilterView : Value::Index::View\n+{\n+    LabelBlockStream label_blocks;\n+    std::vector<size_t> view_dims;\n+    std::vector<vespalib::stringref> to_match;\n+\n+    StreamedFilterView(LabelBlockStream labels, std::vector<size_t> view_dims_in)\n+      : label_blocks(std::move(labels)),\n+        view_dims(std::move(view_dims_in)),\n+        to_match()\n+    {\n+        to_match.reserve(view_dims.size());\n+    }\n+\n+    void lookup(ConstArrayRef<const vespalib::stringref*> addr) override {\n+        label_blocks.reset();\n+        to_match.clear();\n+        for (auto ptr : addr) {\n+            to_match.push_back(*ptr);\n+        }\n+        assert(view_dims.size() == to_match.size());\n+    }\n+\n+    bool next_result(ConstArrayRef<vespalib::stringref*> addr_out, size_t &idx_out) override {\n+        while (const auto block = label_blocks.next_block()) {\n+            idx_out = block.ss_idx;\n+            bool matches = true;\n+            size_t out_idx = 0;\n+            size_t vdm_idx = 0;\n+            for (size_t dim = 0; dim < block.address.size(); ++dim) {\n+                if (vdm_idx < view_dims.size() && (view_dims[vdm_idx] == dim)) {\n+                    if (block.address[dim] != to_match[vdm_idx]) {\n+                        matches = false;\n+                    }\n+                    ++vdm_idx;\n+                } else {\n+                    *addr_out[out_idx++] = block.address[dim];\n+                }\n+            }\n+            assert(out_idx == addr_out.size());\n+            assert(vdm_idx == view_dims.size());\n+            if (matches) return true;\n+        }\n+        return false;\n+    }\n+};\n+\n+struct StreamedIterationView : Value::Index::View\n+{\n+    LabelBlockStream label_blocks;\n+\n+    StreamedIterationView(LabelBlockStream labels)\n+      : label_blocks(std::move(labels))\n+    {}\n+\n+    void lookup(ConstArrayRef<const vespalib::stringref*> addr) override {\n+        label_blocks.reset();\n+        assert(addr.size() == 0);\n+    }\n+\n+    bool next_result(ConstArrayRef<vespalib::stringref*> addr_out, size_t &idx_out) override {\n+        if (auto block = label_blocks.next_block()) {\n+            idx_out = block.ss_idx;\n+            size_t i = 0;\n+            for (auto ptr : addr_out) {\n+                *ptr = block.address[i++];\n+            }\n+            assert(i == block.address.size());", "originalCommit": "d73cb9413b0b39943395a717ec20ce6cd89fa47f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0MjExNQ==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529642115", "bodyText": "consider matches &= ...", "author": "havardpe", "createdAt": "2020-11-24T15:33:14Z", "path": "eval/src/vespa/eval/streamed/streamed_value_index.cpp", "diffHunk": "@@ -0,0 +1,103 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"streamed_value_index.h\"\n+#include \"streamed_value_utils.h\"\n+\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_index\");\n+\n+namespace vespalib::eval {\n+\n+namespace {\n+\n+struct StreamedFilterView : Value::Index::View\n+{\n+    LabelBlockStream label_blocks;\n+    std::vector<size_t> view_dims;\n+    std::vector<vespalib::stringref> to_match;\n+\n+    StreamedFilterView(LabelBlockStream labels, std::vector<size_t> view_dims_in)\n+      : label_blocks(std::move(labels)),\n+        view_dims(std::move(view_dims_in)),\n+        to_match()\n+    {\n+        to_match.reserve(view_dims.size());\n+    }\n+\n+    void lookup(ConstArrayRef<const vespalib::stringref*> addr) override {\n+        label_blocks.reset();\n+        to_match.clear();\n+        for (auto ptr : addr) {\n+            to_match.push_back(*ptr);\n+        }\n+        assert(view_dims.size() == to_match.size());\n+    }\n+\n+    bool next_result(ConstArrayRef<vespalib::stringref*> addr_out, size_t &idx_out) override {\n+        while (const auto block = label_blocks.next_block()) {\n+            idx_out = block.ss_idx;\n+            bool matches = true;\n+            size_t out_idx = 0;\n+            size_t vdm_idx = 0;\n+            for (size_t dim = 0; dim < block.address.size(); ++dim) {\n+                if (vdm_idx < view_dims.size() && (view_dims[vdm_idx] == dim)) {\n+                    if (block.address[dim] != to_match[vdm_idx]) {", "originalCommit": "d73cb9413b0b39943395a717ec20ce6cd89fa47f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0ODI2Mg==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529648262", "bodyText": "consider using explicit parameters", "author": "havardpe", "createdAt": "2020-11-24T15:37:27Z", "path": "eval/src/vespa/eval/streamed/streamed_value_builder_factory.cpp", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"streamed_value_builder_factory.h\"\n+#include \"streamed_value_builder.h\"\n+\n+namespace vespalib::eval {\n+\n+struct SelectStreamedValueBuilder {\n+    template <typename T, typename ...Args>\n+    static std::unique_ptr<ValueBuilderBase> invoke(const ValueType &type, Args &&...args)\n+    {\n+        assert(check_cell_type<T>(type.cell_type()));\n+        return std::make_unique<StreamedValueBuilder<T>>(type, std::forward<Args>(args)...);", "originalCommit": "d73cb9413b0b39943395a717ec20ce6cd89fa47f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1MzAyMg==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529653022", "bodyText": "only use longlived if you really need it and are ready for the consequences...", "author": "havardpe", "createdAt": "2020-11-24T15:40:46Z", "path": "eval/src/vespa/eval/streamed/streamed_value_utils.h", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/vespalib/objects/nbostream.h>\n+\n+namespace vespalib::eval {\n+\n+/**\n+ *  Reads a stream of serialized labels.\n+ *  Reading more labels than available will\n+ *  throw an exception.\n+ **/\n+struct LabelStream {\n+    nbostream_longlivedbuf source;", "originalCommit": "d73cb9413b0b39943395a717ec20ce6cd89fa47f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1ODQyMQ==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529658421", "bodyText": "npos?", "author": "havardpe", "createdAt": "2020-11-24T15:44:30Z", "path": "eval/src/vespa/eval/streamed/streamed_value_utils.h", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/vespalib/objects/nbostream.h>\n+\n+namespace vespalib::eval {\n+\n+/**\n+ *  Reads a stream of serialized labels.\n+ *  Reading more labels than available will\n+ *  throw an exception.\n+ **/\n+struct LabelStream {\n+    nbostream_longlivedbuf source;\n+    LabelStream(ConstArrayRef<char> data) : source(data.begin(), data.size()) {}\n+    vespalib::stringref next_label() {\n+        size_t str_size = source.getInt1_4Bytes();\n+        vespalib::stringref label(source.peek(), str_size);\n+        source.adjustReadPos(str_size);\n+        return label;\n+    }\n+    void reset() { source.rp(0); }\n+};\n+\n+/**\n+ *  Represents an address (set of labels) mapping to a subspace index\n+ **/\n+struct LabelBlock {\n+    static constexpr size_t npos = -1;\n+    size_t ss_idx;\n+    ConstArrayRef<vespalib::stringref> address;\n+    operator bool() const { return ss_idx != npos; }\n+};\n+\n+/**\n+ * Utility for reading a buffer with serialized labels\n+ * as a stream of LabelBlock objects.\n+ **/\n+class LabelBlockStream {\n+private:\n+    size_t _num_subspaces;\n+    LabelStream _labels;\n+    size_t _subspace_index;\n+    std::vector<vespalib::stringref> _current_address;\n+public:\n+    LabelBlock next_block() {\n+        if (_subspace_index < _num_subspaces) {\n+            for (auto & label : _current_address) {\n+                label = _labels.next_label();\n+            }\n+            return LabelBlock{_subspace_index++, _current_address};\n+        } else {\n+            return LabelBlock{LabelBlock::npos, {}};\n+        }\n+    }\n+\n+    void reset() {\n+        _subspace_index = 0;\n+        _labels.reset();\n+    }\n+\n+    LabelBlockStream(uint32_t num_subspaces,\n+                     ConstArrayRef<char> label_buf,\n+                     uint32_t num_mapped_dims)\n+      : _num_subspaces(num_subspaces),\n+        _labels(label_buf),\n+        _subspace_index(-1),", "originalCommit": "d73cb9413b0b39943395a717ec20ce6cd89fa47f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "08cae2f9b4f1ccce8c9534936826a151d63a320d", "url": "https://github.com/vespa-engine/vespa/commit/08cae2f9b4f1ccce8c9534936826a151d63a320d", "message": "remove superfluous additions", "committedDate": "2020-11-24T21:00:48Z", "type": "commit"}, {"oid": "107fd58a5aabe35ce4c3ed1ff9ebcc1ea786d2a1", "url": "https://github.com/vespa-engine/vespa/commit/107fd58a5aabe35ce4c3ed1ff9ebcc1ea786d2a1", "message": "Fixes after review\n\nfor StreamedValue:\n* num_ss -> num_subspaces\n* require num_mapped_dimensions as constructor argument\n\nfor StreamedValueBuilder:\n* do not add the required dense subspace here; it must be\n  added by the caller\n* remember _num_mapped_dimensions\n* _dsss -> _dense_subspace_size", "committedDate": "2020-11-24T21:07:35Z", "type": "commit"}, {"oid": "037e961d3f75ae7d193be425ce064eed5f4be610", "url": "https://github.com/vespa-engine/vespa/commit/037e961d3f75ae7d193be425ce064eed5f4be610", "message": "fix arguments (names and explicit)", "committedDate": "2020-11-24T21:17:29Z", "type": "commit"}, {"oid": "f69c7e87568576e4de11d771160b6d0564946042", "url": "https://github.com/vespa-engine/vespa/commit/f69c7e87568576e4de11d771160b6d0564946042", "message": "more elegant filter; move assert earlier", "committedDate": "2020-11-24T21:18:01Z", "type": "commit"}, {"oid": "3723c0bbba1296507dfe3ce4357e3c179ec3fdd1", "url": "https://github.com/vespa-engine/vespa/commit/3723c0bbba1296507dfe3ce4357e3c179ec3fdd1", "message": "minor fixups:\n\n* no need for nbostream_longlivedbuf\n* explicitly get largest possible size_t", "committedDate": "2020-11-24T21:21:24Z", "type": "commit"}, {"oid": "f1b6c4e09c4c16667b9c609b171a86556f067cc1", "url": "https://github.com/vespa-engine/vespa/commit/f1b6c4e09c4c16667b9c609b171a86556f067cc1", "message": "account for indirect memory usage", "committedDate": "2020-11-24T21:28:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIyNzYzMw==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r530227633", "bodyText": "consider putting the assert here instead of the value constructor", "author": "havardpe", "createdAt": "2020-11-25T09:32:30Z", "path": "eval/src/vespa/eval/streamed/streamed_value_builder.h", "diffHunk": "@@ -42,18 +44,18 @@ class StreamedValueBuilder : public ValueBuilder<T>\n             _labels.writeSmallString(label);\n         }\n         size_t old_sz = _cells.size();\n-        _cells.resize(old_sz + _dsss);\n+        _cells.resize(old_sz + _dense_subspace_size);\n         _num_subspaces++;\n-        return ArrayRef<T>(&_cells[old_sz], _dsss);\n+        return ArrayRef<T>(&_cells[old_sz], _dense_subspace_size);\n     }\n \n     std::unique_ptr<Value> build(std::unique_ptr<ValueBuilder<T>>) override {\n-        if (_num_subspaces == 0 && _type.count_mapped_dimensions() == 0) {\n-            // add required dense subspace\n-            add_subspace({});\n+        if (_num_mapped_dimensions == 0) {\n+            assert(_num_subspaces == 1);\n         }\n-        // note: _num_subspaces * _dsss == _cells.size()\n+        // note: _num_subspaces * _dense_subspace_size == _cells.size()", "originalCommit": "107fd58a5aabe35ce4c3ed1ff9ebcc1ea786d2a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIzMjM2NA==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r530232364", "bodyText": "I thought about using a common npos since one is defined in the LabelBlock, but since you are index based, 'num_spubspaces' would be appropriate here (equivalent with 'end()')", "author": "havardpe", "createdAt": "2020-11-25T09:39:29Z", "path": "eval/src/vespa/eval/streamed/streamed_value_utils.h", "diffHunk": "@@ -66,7 +66,7 @@ class LabelBlockStream {\n                      uint32_t num_mapped_dims)\n       : _num_subspaces(num_subspaces),\n         _labels(label_buf),\n-        _subspace_index(-1),", "originalCommit": "3723c0bbba1296507dfe3ce4357e3c179ec3fdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2OTc2Mw==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r530269763", "bodyText": "good idea, thanks", "author": "arnej27959", "createdAt": "2020-11-25T10:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIzMjM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIzNDc1OQ==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r530234759", "bodyText": "I still think these should get a more descriptive name", "author": "havardpe", "createdAt": "2020-11-25T09:42:59Z", "path": "eval/src/vespa/eval/streamed/streamed_value_view.h", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value_type.h>\n+#include <vespa/eval/eval/value.h>\n+#include \"streamed_value_index.h\"\n+\n+namespace vespalib::eval {\n+\n+ /**\n+  *  Same characteristics as StreamedValue, but does not\n+  *  own its data - refers to type, cells and serialized\n+  *  labels that must be kept outside the Value.\n+  **/\n+class StreamedValueView : public Value\n+{\n+private:\n+    const ValueType &_type;\n+    TypedCells _cells_ref;\n+    StreamedValueIndex _my_index;\n+\n+public:\n+    StreamedValueView(const ValueType &type, TypedCells cells,\n+                      size_t num_ss, ConstArrayRef<char> labels_buf)\n+      : _type(type),\n+        _cells_ref(cells),\n+        _my_index(_type.count_mapped_dimensions(), num_ss, labels_buf)\n+    {\n+        if (num_ss * _type.dense_subspace_size() != _cells_ref.size) abort();\n+    }\n+\n+    ~StreamedValueView();\n+    const ValueType &type() const final override { return _type; }\n+    TypedCells cells() const final override { return _cells_ref; }\n+    const Value::Index &index() const override { return _my_index; }\n+    MemoryUsage get_memory_usage() const final override {\n+        return self_memory_usage<StreamedValueView>();\n+    }\n+    auto serialize_index() const { return _my_index.serialize(); }", "originalCommit": "f1b6c4e09c4c16667b9c609b171a86556f067cc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2OTk2NQ==", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r530269965", "bodyText": "yes, sorry about that, fixed now", "author": "arnej27959", "createdAt": "2020-11-25T10:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIzNDc1OQ=="}], "type": "inlineReview"}, {"oid": "c94e194270381ec1ec4bf93ffa53f59acca2cc3b", "url": "https://github.com/vespa-engine/vespa/commit/c94e194270381ec1ec4bf93ffa53f59acca2cc3b", "message": "fixups after review", "committedDate": "2020-11-25T10:31:45Z", "type": "commit"}, {"oid": "ee4a487bef5372eab6c82dc55c981baa60641b99", "url": "https://github.com/vespa-engine/vespa/commit/ee4a487bef5372eab6c82dc55c981baa60641b99", "message": "Merge branch 'master' into arnej/add-simple-streamed-value", "committedDate": "2020-11-25T10:36:22Z", "type": "commit"}]}