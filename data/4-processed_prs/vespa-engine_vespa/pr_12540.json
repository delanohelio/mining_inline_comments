{"pr_number": 12540, "pr_title": "In order to drain Q faster on sync, and also detect that we are in sy\u2026 ", "pr_createdAt": "2020-03-11T21:55:58Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/12540", "timeline": [{"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e", "url": "https://github.com/vespa-engine/vespa/commit/2c29c9d08fcaa0f23d6eb0015d904723bdc6976e", "message": "In order to drain Q faster on sync, and also detect that we are in sync faster,\nwe wake the consumer unconditionally on sync, and also unconditionally wake the producer when consumer is idle.", "committedDate": "2020-03-11T21:52:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTI1MA==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391499250", "bodyText": "You can skip taking the lock here; consider using std::mutex and std::condition_variable instead.", "author": "havardpe", "createdAt": "2020-03-12T09:38:26Z", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -41,12 +41,38 @@ SingleExecutor::addTask(Task::UP task) {\n     return wp;\n }\n \n+void\n+SingleExecutor::wakeupConsumer() {\n+    MonitorGuard guard(_consumerMonitor);", "originalCommit": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwODc2Ng==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391508766", "bodyText": "OK, will do, have not used them directly before.", "author": "baldersheim", "createdAt": "2020-03-12T09:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU1NDU1NQ==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391554555", "bodyText": "cppreference doc on std::condition_variable is pretty handy on this subject:\n\nThe notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock. However, some implementations (in particular many implementations of pthreads) recognize this situation and avoid this \"hurry up and wait\" scenario by transferring the waiting thread from the condition variable's queue directly to the queue of the mutex within the notify call, without waking it up.", "author": "vekterli", "createdAt": "2020-03-12T11:20:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2MzAyNA==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391563024", "bodyText": "Done", "author": "baldersheim", "createdAt": "2020-03-12T11:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTMyMA==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391499320", "bodyText": "You can skip taking the lock here; consider using std::mutex and std::condition_variable instead.", "author": "havardpe", "createdAt": "2020-03-12T09:38:33Z", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -41,12 +41,38 @@ SingleExecutor::addTask(Task::UP task) {\n     return wp;\n }\n \n+void\n+SingleExecutor::wakeupConsumer() {\n+    MonitorGuard guard(_consumerMonitor);\n+    guard.signal();\n+}\n+\n+void\n+SingleExecutor::sleepConsumer() {\n+    _wakeupConsumerAt.store(_wp.load(std::memory_order_relaxed) + (_taskLimit.load(std::memory_order_relaxed) >> 2), std::memory_order_relaxed);\n+    MonitorGuard guard(_consumerMonitor);\n+    guard.wait(10ms);\n+    _wakeupConsumerAt.store(0, std::memory_order_relaxed);\n+}\n+\n+void\n+SingleExecutor::wakeupProducer() {\n+    MonitorGuard guard(_producerMonitor);", "originalCommit": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2MzEwNw==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391563107", "bodyText": "Done", "author": "baldersheim", "createdAt": "2020-03-12T11:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTk3MA==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391499970", "bodyText": "note that this signal may be lost since no state is being passed with the signal (the other thread might call wait after the signal has been discarded since no-one was waiting).", "author": "havardpe", "createdAt": "2020-03-12T09:39:46Z", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -60,7 +86,9 @@ SingleExecutor &\n SingleExecutor::sync() {\n     uint64_t wp = _wp.load(std::memory_order_relaxed);\n     while (wp > _rp.load(std::memory_order_acquire)) {\n-        std::this_thread::sleep_for(1ms);\n+        wakeupConsumer();", "originalCommit": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwNzIyNQ==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391507225", "bodyText": "Yes, correct. The purpose is to wake up one that is sleeping waiting for low watermark to be reached.", "author": "baldersheim", "createdAt": "2020-03-12T09:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjI0NQ==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391502245", "bodyText": "note that this signal may be lost since no state is being passed with the signal (the other thread might call wait after the signal has been discarded since no-one was waiting).", "author": "havardpe", "createdAt": "2020-03-12T09:43:38Z", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -41,12 +41,38 @@ SingleExecutor::addTask(Task::UP task) {\n     return wp;\n }\n \n+void\n+SingleExecutor::wakeupConsumer() {\n+    MonitorGuard guard(_consumerMonitor);\n+    guard.signal();\n+}\n+\n+void\n+SingleExecutor::sleepConsumer() {\n+    _wakeupConsumerAt.store(_wp.load(std::memory_order_relaxed) + (_taskLimit.load(std::memory_order_relaxed) >> 2), std::memory_order_relaxed);\n+    MonitorGuard guard(_consumerMonitor);\n+    guard.wait(10ms);\n+    _wakeupConsumerAt.store(0, std::memory_order_relaxed);\n+}\n+\n+void\n+SingleExecutor::wakeupProducer() {\n+    MonitorGuard guard(_producerMonitor);\n+    guard.signal();\n+}\n+\n+void\n+SingleExecutor::sleepProducer(MonitorGuard & guard) {\n+    _producerNeedWakeup.store(true, std::memory_order_relaxed);\n+    guard.wait(10ms);\n+    _producerNeedWakeup.store(false, std::memory_order_relaxed);\n+}\n+\n Executor::Task::UP\n SingleExecutor::execute(Task::UP task) {\n     uint64_t wp = addTask(std::move(task));\n     if (wp == _wakeupConsumerAt.load(std::memory_order_relaxed)) {\n-        MonitorGuard guard(_consumerMonitor);\n-        guard.signal();\n+        wakeupConsumer();", "originalCommit": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwNzk0Mg==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391507942", "bodyText": "Yes, correct. The purpose is to wake up one that is sleeping waiting for low watermark to be reached.", "author": "baldersheim", "createdAt": "2020-03-12T09:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjY3Mw==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391502673", "bodyText": "note that this signal may be lost since no state is being passed with the signal (the other thread might call wait after the signal has been discarded since no-one was waiting).", "author": "havardpe", "createdAt": "2020-03-12T09:44:24Z", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -69,10 +97,8 @@ void\n SingleExecutor::run() {\n     while (!_thread.stopped()) {\n         drain_tasks();\n-        _wakeupConsumerAt.store(_wp.load(std::memory_order_relaxed) + (_taskLimit.load(std::memory_order_relaxed) >> 2), std::memory_order_relaxed);\n-        MonitorGuard guard(_consumerMonitor);\n-        guard.wait(10ms);\n-        _wakeupConsumerAt.store(0, std::memory_order_relaxed);\n+        wakeupProducer();", "originalCommit": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwODIwNw==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391508207", "bodyText": "Yes, correct. The purpose is to wake up one that is sleeping waiting for low watermark to be reached.", "author": "baldersheim", "createdAt": "2020-03-12T09:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjgyNw==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391502827", "bodyText": "note that this signal may be lost since no state is being passed with the signal (the other thread might call wait after the signal has been discarded since no-one was waiting).", "author": "havardpe", "createdAt": "2020-03-12T09:44:40Z", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -98,8 +124,7 @@ SingleExecutor::run_tasks_till(uint64_t available) {\n         task->run();\n         _rp.store(++consumed, std::memory_order_release);\n         if (wakeupLimit == consumed) {\n-            MonitorGuard guard(_producerMonitor);\n-            guard.broadcast();\n+            wakeupProducer();", "originalCommit": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwODM2NQ==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391508365", "bodyText": "Yes, correct. The purpose is to wake up one that is sleeping waiting for low watermark to be reached.", "author": "baldersheim", "createdAt": "2020-03-12T09:54:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjgyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUyMDA5OQ==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391520099", "bodyText": "The purpose is irrelevant if the signal is lost. The thread you are trying to wake up will keep sleeping. This might not happen too often, but it could be a bit surprising when it does.", "author": "havardpe", "createdAt": "2020-03-12T10:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjgyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2NDA4Ng==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391564086", "bodyText": "Now it will be attempted woken up again after every 100us. I think that should be good enough.", "author": "baldersheim", "createdAt": "2020-03-12T11:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjgyNw=="}], "type": "inlineReview"}, {"oid": "2a3a5b321deb5e65d4a4856ee53eeafd0551d3b5", "url": "https://github.com/vespa-engine/vespa/commit/2a3a5b321deb5e65d4a4856ee53eeafd0551d3b5", "message": "Use std::mutex/condition_variable.\nUse shorter wait during sync, as that is urgent and synchronous.", "committedDate": "2020-03-12T11:35:01Z", "type": "commit"}, {"oid": "3269532b70f203cd302820ce1adc3facfe35dcf8", "url": "https://github.com/vespa-engine/vespa/commit/3269532b70f203cd302820ce1adc3facfe35dcf8", "message": "- Use a single common lock.\n- Introduce 2 stage startSync/sync.\n- avoid loosing wakeup on sync.", "committedDate": "2020-03-12T15:39:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MjE0OA==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r392162148", "bodyText": "letting go of the lock here will allow multiple threads to call drain at the same time. this might be ok, but could lead to creating more new buffers than you really need.", "author": "havardpe", "createdAt": "2020-03-13T11:03:28Z", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -56,11 +63,27 @@ SingleExecutor::setTaskLimit(uint32_t taskLimit) {\n     _wantedTaskLimit = vespalib::roundUp2inN(taskLimit);\n }\n \n+void\n+SingleExecutor::drain(Lock & lock) {\n+    uint64_t wp = _wp.load(std::memory_order_relaxed);\n+    while (numTasks() > 0) {\n+        _consumerCondition.notify_one();\n+        sleepProducer(lock, 100us, wp);", "originalCommit": "3269532b70f203cd302820ce1adc3facfe35dcf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMxMDQwMQ==", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r392310401", "bodyText": "I think that is not a normal usecase.", "author": "baldersheim", "createdAt": "2020-03-13T15:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MjE0OA=="}], "type": "inlineReview"}]}