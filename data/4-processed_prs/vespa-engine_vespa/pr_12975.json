{"pr_number": 12975, "pr_title": "Since gcc does not provide lock free 16 byte access we must do so our\u2026", "pr_createdAt": "2020-04-19T01:38:51Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/12975", "timeline": [{"oid": "499c47d54b37b067e764821e232f78ab643a5b98", "url": "https://github.com/vespa-engine/vespa/commit/499c47d54b37b067e764821e232f78ab643a5b98", "message": "Since gcc does not provide lock free 16 byte access we must do so ourselves.", "committedDate": "2020-04-19T01:37:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkxNzI3Mg==", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r410917272", "bodyText": "Edited: looking at the use in AFListBase, the side effect of a teared load is just a retry. So this should be OK for the use, but we might want to add comment describing that a teared load is not an issue.", "author": "toregge", "createdAt": "2020-04-19T14:26:02Z", "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,48 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+#define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {", "originalCommit": "499c47d54b37b067e764821e232f78ab643a5b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2NDc5NQ==", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r410964795", "bodyText": "Agree, I will do that.", "author": "baldersheim", "createdAt": "2020-04-19T18:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkxNzI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkxNzcxNA==", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r410917714", "bodyText": "Edited: The store is not atomic, but it is only used in a unit test before starting the test threads. Perhaps add a comment describing that a teared store is not an issue.", "author": "toregge", "createdAt": "2020-04-19T14:28:30Z", "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,48 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+#define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {\n+        return *this;\n+    }\n+    void store(TaggedPtr ptr) {", "originalCommit": "499c47d54b37b067e764821e232f78ab643a5b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2NDgwNg==", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r410964806", "bodyText": "I also noticed that it was used in a uint test so I not look at the details. I will do that and see if it is necessary.", "author": "baldersheim", "createdAt": "2020-04-19T18:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkxNzcxNA=="}], "type": "inlineReview"}, {"oid": "aa70ed3fa69fa0393e21945adeec56314619536b", "url": "https://github.com/vespa-engine/vespa/commit/aa70ed3fa69fa0393e21945adeec56314619536b", "message": "Add comment about shortcut.", "committedDate": "2020-04-19T18:46:59Z", "type": "commit"}, {"oid": "99834fd9c67c9baad2e56f151a4bbe30edfd5322", "url": "https://github.com/vespa-engine/vespa/commit/99834fd9c67c9baad2e56f151a4bbe30edfd5322", "message": "Fix typo", "committedDate": "2020-04-19T19:01:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMxMDE1NQ==", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r411310155", "bodyText": "store/load/compare_exchange_weak could be noexcept", "author": "vekterli", "createdAt": "2020-04-20T11:42:44Z", "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,53 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+    #define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {\n+        // Note that this is NOT an atomic load. The current use as the initial load\n+        // in a compare_exchange loop is safe as a teared load will just give a retry.\n+        return *this;\n+    }\n+    void store(TaggedPtr ptr) {\n+        // Note that this is NOT an atomic store. The current use is in a unit test as an initial\n+        // store before any threads are started. Just done so to keep api compatible with std::atomic as\n+        // that is the preferred implementation..\n+        *this = ptr;\n+    }\n+    bool\n+    compare_exchange_weak(TaggedPtr & oldPtr, TaggedPtr newPtr, std::memory_order, std::memory_order) {", "originalCommit": "99834fd9c67c9baad2e56f151a4bbe30edfd5322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNTQ5OA==", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r411335498", "bodyText": "What does %6 signify in this case?", "author": "vekterli", "createdAt": "2020-04-20T12:26:38Z", "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,53 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+    #define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {\n+        // Note that this is NOT an atomic load. The current use as the initial load\n+        // in a compare_exchange loop is safe as a teared load will just give a retry.\n+        return *this;\n+    }\n+    void store(TaggedPtr ptr) {\n+        // Note that this is NOT an atomic store. The current use is in a unit test as an initial\n+        // store before any threads are started. Just done so to keep api compatible with std::atomic as\n+        // that is the preferred implementation..\n+        *this = ptr;\n+    }\n+    bool\n+    compare_exchange_weak(TaggedPtr & oldPtr, TaggedPtr newPtr, std::memory_order, std::memory_order) {\n+        char result;\n+        __asm__ volatile (\n+        \"lock ;\"\n+        \"cmpxchg16b %6;\"", "originalCommit": "99834fd9c67c9baad2e56f151a4bbe30edfd5322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}