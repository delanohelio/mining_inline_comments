{"pr_number": 11809, "pr_title": "Remove and indirection for document id, for less memory footprint, an\u2026", "pr_createdAt": "2020-01-16T10:49:54Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/11809", "timeline": [{"oid": "f4ca1a66486f7e10f507b0c8054e403c7ff9c125", "url": "https://github.com/vespa-engine/vespa/commit/f4ca1a66486f7e10f507b0c8054e403c7ff9c125", "message": "Remove and indirection for document id, for less memory footprint, and better generated code.", "committedDate": "2020-01-16T10:48:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NDEwNQ==", "url": "https://github.com/vespa-engine/vespa/pull/11809#discussion_r367394105", "bodyText": "Could probably update \"VDS\" to \"Vespa\" \ud83d\ude42\nAlso, technically since this ID string also supports location, it does allow for \"forced\" distribution. I think this comment was outdated already for IdIdString", "author": "vekterli", "createdAt": "2020-01-16T12:36:35Z", "path": "document/src/vespa/document/base/idstring.h", "diffHunk": "@@ -13,108 +12,60 @@ namespace document {\n  * \\class document::IdString\n  * \\ingroup base\n  *\n- * \\brief Superclass for all document identifier schemes.\n+ * \\brief New scheme for documents with no forced distribution.\n+ *\n+ * By using this scheme, documents will be evenly distributed within VDS,", "originalCommit": "f4ca1a66486f7e10f507b0c8054e403c7ff9c125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ2OTE3Mg==", "url": "https://github.com/vespa-engine/vespa/pull/11809#discussion_r367469172", "bodyText": "Cleaned up.", "author": "baldersheim", "createdAt": "2020-01-16T15:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NDEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5ODEwNA==", "url": "https://github.com/vespa-engine/vespa/pull/11809#discussion_r367398104", "bodyText": "Consider adding an explicit cast to signed integer to make it obvious that this doesn't trigger an unsigned underflow. Implicit int promotions due to type ranks are tricky beasts to think about when browsing code \ud83d\ude42", "author": "vekterli", "createdAt": "2020-01-16T12:46:58Z", "path": "document/src/vespa/document/base/idstring.h", "diffHunk": "@@ -13,108 +12,60 @@ namespace document {\n  * \\class document::IdString\n  * \\ingroup base\n  *\n- * \\brief Superclass for all document identifier schemes.\n+ * \\brief New scheme for documents with no forced distribution.\n+ *\n+ * By using this scheme, documents will be evenly distributed within VDS,\n+ * as the location of a doc identifier is a hash of the entire URI.\n+ * This scheme also contains the DocumentType.\n  */\n-class IdString : public vespalib::Cloneable {\n+class IdString {\n public:\n-    typedef std::unique_ptr<IdString> UP;\n-    typedef vespalib::CloneablePtr<IdString> CP;\n     typedef uint64_t LocationType;\n-    enum Type { ID=0, NULLID };\n-    static const vespalib::string & getTypeName(Type t);\n-\n-    /** @throws document::IdParseException If parsing of id scheme failed. */\n-    static IdString::UP createIdString(vespalib::stringref id) { return createIdString(id.data(), id.size()); }\n-    static IdString::UP createIdString(const char *id, size_t sz);\n     static LocationType makeLocation(vespalib::stringref s);\n \n-    ~IdString();\n-    IdString* clone() const override = 0;\n+    explicit IdString(vespalib::stringref ns);\n+    IdString();\n \n-    virtual Type        getType() const = 0;\n     vespalib::stringref getNamespace() const { return getComponent(0); }\n-    virtual vespalib::stringref getNamespaceSpecific() const = 0;\n-    virtual LocationType getLocation() const = 0;\n-    virtual std::pair<int16_t, int64_t> getGidBitsOverride() const { return std::pair<int16_t, int64_t>(0, 0); }\n-    virtual bool hasDocType() const { return false; }\n-    virtual vespalib::stringref getDocType() const { return \"\"; }\n-    virtual bool hasNumber() const { return false; }\n-    virtual uint64_t getNumber() const { return 0; }\n-    virtual bool hasGroup() const { return false; }\n-    virtual vespalib::stringref getGroup() const { return \"\"; }\n+    bool hasDocType() const { return size(1 != 0); }\n+    vespalib::stringref getDocType() const  { return getComponent(1); }\n+    LocationType getLocation() const  { return _location; }\n+    bool hasNumber() const  { return _has_number; }\n+    uint64_t getNumber() const  { return _location; }\n+    bool hasGroup() const  { return _groupOffset != 0; }\n+    vespalib::stringref getGroup() const  {\n+        return vespalib::stringref(getRawId().c_str() + _groupOffset, offset(3) - _groupOffset - 1);\n+    }\n+    vespalib::stringref getNamespaceSpecific() const { return getComponent(3); }\n \n     bool operator==(const IdString& other) const\n         { return toString() == other.toString(); }\n \n-    const vespalib::string & toString() const;\n+    const vespalib::string & toString() const { return _rawId; }\n \n-protected:\n-    IdString(uint32_t maxComponents, uint32_t namespaceOffset, vespalib::stringref rawId);\n+private:\n     size_t offset(size_t index) const { return _offsets[index]; }\n-    size_t size(size_t index) const { return _offsets[index+1] - _offsets[index] - 1; }\n+    size_t size(size_t index) const { return std::max(0, _offsets[index+1] - _offsets[index] - 1); }", "originalCommit": "f4ca1a66486f7e10f507b0c8054e403c7ff9c125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3NTI2NA==", "url": "https://github.com/vespa-engine/vespa/pull/11809#discussion_r367475264", "bodyText": "Done", "author": "baldersheim", "createdAt": "2020-01-16T15:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5ODEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwMDk4NQ==", "url": "https://github.com/vespa-engine/vespa/pull/11809#discussion_r367400985", "bodyText": "Consider replacing this with a memcpy to ensure there are no aliasing violations", "author": "vekterli", "createdAt": "2020-01-16T12:54:12Z", "path": "document/src/vespa/document/bucket/bucketidfactory.cpp", "diffHunk": "@@ -42,29 +42,16 @@ BucketIdFactory::getBucketId(const DocumentId& id) const\n {\n     uint64_t location = id.getScheme().getLocation();\n     assert(GlobalId::LENGTH >= sizeof(uint64_t) + 4u);\n-    uint64_t gid = reinterpret_cast<const uint64_t&>(\n-            *(id.getGlobalId().get() + 4));\n+    uint64_t gid = reinterpret_cast<const uint64_t&>(*(id.getGlobalId().get() + 4));", "originalCommit": "f4ca1a66486f7e10f507b0c8054e403c7ff9c125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3Njg2MA==", "url": "https://github.com/vespa-engine/vespa/pull/11809#discussion_r367476860", "bodyText": "Done.", "author": "baldersheim", "createdAt": "2020-01-16T15:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwMDk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwOTc1NA==", "url": "https://github.com/vespa-engine/vespa/pull/11809#discussion_r367409754", "bodyText": "Was this intended to be return size(1) != 0;? Funnily enough, due to implicit type conversions this ends up being the same expression in practice", "author": "vekterli", "createdAt": "2020-01-16T13:15:01Z", "path": "document/src/vespa/document/base/idstring.h", "diffHunk": "@@ -13,108 +12,60 @@ namespace document {\n  * \\class document::IdString\n  * \\ingroup base\n  *\n- * \\brief Superclass for all document identifier schemes.\n+ * \\brief New scheme for documents with no forced distribution.\n+ *\n+ * By using this scheme, documents will be evenly distributed within VDS,\n+ * as the location of a doc identifier is a hash of the entire URI.\n+ * This scheme also contains the DocumentType.\n  */\n-class IdString : public vespalib::Cloneable {\n+class IdString {\n public:\n-    typedef std::unique_ptr<IdString> UP;\n-    typedef vespalib::CloneablePtr<IdString> CP;\n     typedef uint64_t LocationType;\n-    enum Type { ID=0, NULLID };\n-    static const vespalib::string & getTypeName(Type t);\n-\n-    /** @throws document::IdParseException If parsing of id scheme failed. */\n-    static IdString::UP createIdString(vespalib::stringref id) { return createIdString(id.data(), id.size()); }\n-    static IdString::UP createIdString(const char *id, size_t sz);\n     static LocationType makeLocation(vespalib::stringref s);\n \n-    ~IdString();\n-    IdString* clone() const override = 0;\n+    explicit IdString(vespalib::stringref ns);\n+    IdString();\n \n-    virtual Type        getType() const = 0;\n     vespalib::stringref getNamespace() const { return getComponent(0); }\n-    virtual vespalib::stringref getNamespaceSpecific() const = 0;\n-    virtual LocationType getLocation() const = 0;\n-    virtual std::pair<int16_t, int64_t> getGidBitsOverride() const { return std::pair<int16_t, int64_t>(0, 0); }\n-    virtual bool hasDocType() const { return false; }\n-    virtual vespalib::stringref getDocType() const { return \"\"; }\n-    virtual bool hasNumber() const { return false; }\n-    virtual uint64_t getNumber() const { return 0; }\n-    virtual bool hasGroup() const { return false; }\n-    virtual vespalib::stringref getGroup() const { return \"\"; }\n+    bool hasDocType() const { return size(1 != 0); }", "originalCommit": "f4ca1a66486f7e10f507b0c8054e403c7ff9c125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3MjIyMw==", "url": "https://github.com/vespa-engine/vespa/pull/11809#discussion_r367472223", "bodyText": "Good catch. this was a nasty little bugger. That was what I thought I wrote. At the test started working again :)", "author": "baldersheim", "createdAt": "2020-01-16T15:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwOTc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxOTY2Mg==", "url": "https://github.com/vespa-engine/vespa/pull/11809#discussion_r367419662", "bodyText": "Consider exposing and using MAX_COMPONENTS here to reduce number of magical constants", "author": "vekterli", "createdAt": "2020-01-16T13:36:16Z", "path": "document/src/vespa/document/base/idstring.h", "diffHunk": "@@ -13,108 +12,60 @@ namespace document {\n  * \\class document::IdString\n  * \\ingroup base\n  *\n- * \\brief Superclass for all document identifier schemes.\n+ * \\brief New scheme for documents with no forced distribution.\n+ *\n+ * By using this scheme, documents will be evenly distributed within VDS,\n+ * as the location of a doc identifier is a hash of the entire URI.\n+ * This scheme also contains the DocumentType.\n  */\n-class IdString : public vespalib::Cloneable {\n+class IdString {\n public:\n-    typedef std::unique_ptr<IdString> UP;\n-    typedef vespalib::CloneablePtr<IdString> CP;\n     typedef uint64_t LocationType;\n-    enum Type { ID=0, NULLID };\n-    static const vespalib::string & getTypeName(Type t);\n-\n-    /** @throws document::IdParseException If parsing of id scheme failed. */\n-    static IdString::UP createIdString(vespalib::stringref id) { return createIdString(id.data(), id.size()); }\n-    static IdString::UP createIdString(const char *id, size_t sz);\n     static LocationType makeLocation(vespalib::stringref s);\n \n-    ~IdString();\n-    IdString* clone() const override = 0;\n+    explicit IdString(vespalib::stringref ns);\n+    IdString();\n \n-    virtual Type        getType() const = 0;\n     vespalib::stringref getNamespace() const { return getComponent(0); }\n-    virtual vespalib::stringref getNamespaceSpecific() const = 0;\n-    virtual LocationType getLocation() const = 0;\n-    virtual std::pair<int16_t, int64_t> getGidBitsOverride() const { return std::pair<int16_t, int64_t>(0, 0); }\n-    virtual bool hasDocType() const { return false; }\n-    virtual vespalib::stringref getDocType() const { return \"\"; }\n-    virtual bool hasNumber() const { return false; }\n-    virtual uint64_t getNumber() const { return 0; }\n-    virtual bool hasGroup() const { return false; }\n-    virtual vespalib::stringref getGroup() const { return \"\"; }\n+    bool hasDocType() const { return size(1 != 0); }\n+    vespalib::stringref getDocType() const  { return getComponent(1); }\n+    LocationType getLocation() const  { return _location; }\n+    bool hasNumber() const  { return _has_number; }\n+    uint64_t getNumber() const  { return _location; }\n+    bool hasGroup() const  { return _groupOffset != 0; }\n+    vespalib::stringref getGroup() const  {\n+        return vespalib::stringref(getRawId().c_str() + _groupOffset, offset(3) - _groupOffset - 1);\n+    }\n+    vespalib::stringref getNamespaceSpecific() const { return getComponent(3); }\n \n     bool operator==(const IdString& other) const\n         { return toString() == other.toString(); }\n \n-    const vespalib::string & toString() const;\n+    const vespalib::string & toString() const { return _rawId; }\n \n-protected:\n-    IdString(uint32_t maxComponents, uint32_t namespaceOffset, vespalib::stringref rawId);\n+private:\n     size_t offset(size_t index) const { return _offsets[index]; }\n-    size_t size(size_t index) const { return _offsets[index+1] - _offsets[index] - 1; }\n+    size_t size(size_t index) const { return std::max(0, _offsets[index+1] - _offsets[index] - 1); }\n     vespalib::stringref getComponent(size_t index) const { return vespalib::stringref(_rawId.c_str() + offset(index), size(index)); }\n     const vespalib::string & getRawId() const { return _rawId; }\n-    virtual void validate() const;\n-    size_t getNumComponents() const { return _offsets.numComponents(); }\n \n-private:\n     class Offsets {\n     public:\n-        Offsets(uint32_t maxComponents, uint32_t first, vespalib::stringref id);\n-        uint16_t first() const { return _offsets[0]; }\n+        Offsets() = default;\n+        uint16_t compute(vespalib::stringref id);\n         uint16_t operator [] (size_t i) const { return _offsets[i]; }\n-        size_t numComponents() const { return _numComponents; }\n+        static const Offsets DefaultID;\n     private:\n+        Offsets(vespalib::stringref id);\n         uint16_t _offsets[5];", "originalCommit": "f4ca1a66486f7e10f507b0c8054e403c7ff9c125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3MzcwNw==", "url": "https://github.com/vespa-engine/vespa/pull/11809#discussion_r367473707", "bodyText": "Done.", "author": "baldersheim", "createdAt": "2020-01-16T15:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxOTY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQyNjk5MA==", "url": "https://github.com/vespa-engine/vespa/pull/11809#discussion_r367426990", "bodyText": "Consider removing extra linebreak", "author": "vekterli", "createdAt": "2020-01-16T13:51:11Z", "path": "document/src/vespa/document/base/idstring.cpp", "diffHunk": "@@ -219,21 +170,62 @@ void setLocation(IdString::LocationType &loc, IdString::LocationType val,\n \n }  // namespace\n \n+const IdString::Offsets IdString::Offsets::DefaultID(DEFAULT_ID);\n+\n+IdString::Offsets::Offsets(stringref id)\n+    : _offsets()\n+{\n+    compute(id);\n+}\n+\n+uint16_t\n+IdString::Offsets::compute(stringref id)\n+{\n+    _offsets[0] = NAMESPACE_OFFSET;\n+    size_t index(1);\n+    const char * s(id.data() + NAMESPACE_OFFSET);\n+    const char * e(id.data() + id.size());\n+    for(s=fmemchr(s, e);\n+        (s != nullptr) && (index < MAX_COMPONENTS);\n+        s = fmemchr(s+1, e))\n+    {\n+        _offsets[index++] = s - id.data() + 1;\n+    }\n+    uint16_t numComponents = index;\n+    for (;index < VESPA_NELEMS(_offsets); index++) {\n+        _offsets[index] = id.size() + 1; // 1 is added due to the implicitt accounting for ':'\n+    }\n+    _offsets[MAX_COMPONENTS] = id.size() + 1; // 1 is added due to the implicitt accounting for ':'\n+    return numComponents;\n+}\n+\n IdString::LocationType\n IdString::makeLocation(stringref s) {\n     LocationUnion location;\n     fastc_md5sum(reinterpret_cast<const unsigned char*>(s.data()), s.size(), location._key);\n     return location._location[0];\n }\n \n-IdIdString::IdIdString(stringref id)\n-    : IdString(4, 3, id),\n+IdString::IdString()\n+    : _rawId(DEFAULT_ID),\n       _location(0),\n+      _offsets(Offsets::DefaultID),\n+      _groupOffset(0),\n+      _has_number(false)\n+{\n+}\n+\n+IdString::IdString(stringref id)\n+    : _rawId(id),\n+      _location(0),\n+      _offsets(),\n       _groupOffset(0),\n       _has_number(false)\n {\n     // TODO(magnarn): Require that keys are lexicographically ordered.\n-    validate();\n+    verifyIdString(id.data(), id.size());\n+    validate(_offsets.compute(id));\n+", "originalCommit": "f4ca1a66486f7e10f507b0c8054e403c7ff9c125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3NDI4Ng==", "url": "https://github.com/vespa-engine/vespa/pull/11809#discussion_r367474286", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-01-16T15:14:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQyNjk5MA=="}], "type": "inlineReview"}, {"oid": "3dde87e3ce2539a04b658a8bf6916975925ca30d", "url": "https://github.com/vespa-engine/vespa/commit/3dde87e3ce2539a04b658a8bf6916975925ca30d", "message": "Update comment.", "committedDate": "2020-01-16T15:05:37Z", "type": "commit"}, {"oid": "45f5e0efa10f62f712f41732613ca0246c7318ea", "url": "https://github.com/vespa-engine/vespa/commit/45f5e0efa10f62f712f41732613ca0246c7318ea", "message": "Folloup on the review comments.", "committedDate": "2020-01-16T15:28:50Z", "type": "commit"}]}