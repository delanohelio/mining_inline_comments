{"pr_number": 14383, "pr_title": "Decouple CachingRpcTargetResolver from slobrok and fnet implementatio\u2026", "pr_createdAt": "2020-09-11T11:39:37Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/14383", "timeline": [{"oid": "5518be46c5f333c23547fcf02cfc543cebb40f17", "url": "https://github.com/vespa-engine/vespa/commit/5518be46c5f333c23547fcf02cfc543cebb40f17", "message": "Decouple CachingRpcTargetResolver from slobrok and fnet implementations and write unit tests.", "committedDate": "2020-09-11T11:34:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5NTYxMQ==", "url": "https://github.com/vespa-engine/vespa/pull/14383#discussion_r486995611", "bodyText": "Consider making this a static member function instead", "author": "vekterli", "createdAt": "2020-09-11T11:55:56Z", "path": "storage/src/tests/storageserver/rpc/caching_rpc_target_resolver_test.cpp", "diffHunk": "@@ -0,0 +1,134 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/slobrok/imirrorapi.h>\n+#include <vespa/storage/storageserver/rpc/caching_rpc_target_resolver.h>\n+#include <vespa/storageapi/messageapi/storagemessage.h>\n+#include <vespa/vdslib/state/nodetype.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+\n+using namespace storage::rpc;\n+using slobrok::api::IMirrorAPI;\n+using storage::api::StorageMessageAddress;\n+using storage::lib::NodeType;\n+\n+class MockMirror : public IMirrorAPI {\n+public:\n+    using Mappings = std::map<vespalib::string, IMirrorAPI::SpecList>;\n+    Mappings mappings;\n+    uint32_t gen;\n+    MockMirror() : mappings(), gen(1) {}\n+    SpecList lookup(const std::string& pattern) const override {\n+        auto itr = mappings.find(pattern);\n+        if (itr != mappings.end()) {\n+            return itr->second;\n+        }\n+        return {};\n+    }\n+    uint32_t updates() const override { return gen; }\n+    bool ready() const override { return true; }\n+    void inc_gen() { ++gen; }\n+};\n+\n+class MockWrappedFrtTarget : public WrappedFrtTarget {\n+private:\n+    bool& _valid;\n+public:\n+    MockWrappedFrtTarget(bool& valid) : _valid(valid) {}\n+    FRT_Target* get() override { return nullptr; }\n+    bool is_valid() const override { return _valid; }\n+};\n+\n+class MockTargetFactory : public RpcTargetFactory {\n+public:\n+    mutable bool valid_target;\n+\n+    MockTargetFactory() : valid_target(true) {}\n+    std::unique_ptr<RpcTarget> make_target(const vespalib::string& connection_spec, uint32_t slobrok_gen) const override {\n+        return std::make_unique<RpcTarget>(std::make_unique<MockWrappedFrtTarget>(valid_target),\n+                connection_spec, slobrok_gen);\n+    }\n+};\n+\n+class CachingRpcTargetResolverTest : public ::testing::Test {\n+public:\n+    MockMirror mirror;\n+    MockTargetFactory factory;\n+    CachingRpcTargetResolver resolver;\n+    StorageMessageAddress address_0;\n+    StorageMessageAddress address_1;\n+    vespalib::string spec_0;\n+    vespalib::string spec_1;\n+\n+    CachingRpcTargetResolverTest()\n+        : mirror(),\n+          factory(),\n+          resolver(mirror, factory),\n+          address_0(\"my_cluster\", NodeType::STORAGE, 5),\n+          address_1(\"my_cluster\", NodeType::DISTRIBUTOR, 7),\n+          spec_0(\"tcp/my:41\"),\n+          spec_1(\"tcp/my:42\")\n+    {\n+        add_mapping(address_0, spec_0);\n+    }\n+    void add_mapping(const StorageMessageAddress& address, const vespalib::string& connection_spec) {\n+        mirror.mappings[to_slobrok_id(address)] = {{to_slobrok_id(address), connection_spec}};\n+    }\n+    vespalib::string to_slobrok_id(const storage::api::StorageMessageAddress& address) const {", "originalCommit": "5518be46c5f333c23547fcf02cfc543cebb40f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MjYxNw==", "url": "https://github.com/vespa-engine/vespa/pull/14383#discussion_r487052617", "bodyText": "Fixed", "author": "geirst", "createdAt": "2020-09-11T13:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5NTYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzNjAyOQ==", "url": "https://github.com/vespa-engine/vespa/pull/14383#discussion_r487036029", "bodyText": "Could also use [[maybe_unused]] directly on the parameter itself", "author": "vekterli", "createdAt": "2020-09-11T13:13:55Z", "path": "storage/src/vespa/storage/storageserver/rpc/caching_rpc_target_resolver.cpp", "diffHunk": "@@ -1,82 +1,107 @@\n // Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n #include \"caching_rpc_target_resolver.h\"\n #include \"shared_rpc_resources.h\"\n-#include <vespa/fnet/frt/supervisor.h>\n #include <vespa/fnet/frt/target.h>\n-#include <vespa/slobrok/sbmirror.h>\n+#include <vespa/slobrok/imirrorapi.h>\n #include <vespa/storageapi/messageapi/storagemessage.h>\n #include <vespa/vespalib/stllike/asciistream.h>\n #include <vespa/vespalib/stllike/hash_map.hpp>\n+#include <cassert>\n \n #include <vespa/log/log.h>\n LOG_SETUP(\".storage.caching_rpc_target_resolver\");\n \n namespace storage::rpc {\n \n-CachingRpcTargetResolver::CachingRpcTargetResolver(SharedRpcResources& rpc_resources)\n-    : _rpc_resources(rpc_resources)\n+CachingRpcTargetResolver::CachingRpcTargetResolver(const slobrok::api::IMirrorAPI& slobrok_mirror,\n+                                                   const RpcTargetFactory& target_factory)\n+    : _slobrok_mirror(slobrok_mirror),\n+      _target_factory(target_factory),\n+      _targets_rwmutex()\n {\n }\n \n CachingRpcTargetResolver::~CachingRpcTargetResolver() = default;\n \n-namespace {\n-\n-vespalib::string address_to_slobrok_id(const api::StorageMessageAddress& address) {\n+vespalib::string\n+CachingRpcTargetResolver::address_to_slobrok_id(const api::StorageMessageAddress& address) {\n     vespalib::asciistream as;\n     as << \"storage/cluster.\" << address.getCluster()\n        << '/' << ((address.getNodeType() == lib::NodeType::STORAGE) ? \"storage\" : \"distributor\")\n        << '/' << address.getIndex();\n     return as.str();\n }\n \n+std::shared_ptr<RpcTarget>\n+CachingRpcTargetResolver::lookup_target(const vespalib::string& slobrok_id, uint32_t curr_slobrok_gen) {\n+    std::shared_lock lock(_targets_rwmutex);\n+    auto itr = _targets.find(slobrok_id);\n+    if ((itr != _targets.end())\n+        && itr->second->_target->is_valid()\n+        && (itr->second->_slobrok_gen == curr_slobrok_gen)) {\n+        return itr->second;\n+    }\n+    return {};\n+}\n+\n+std::shared_ptr<RpcTarget>\n+CachingRpcTargetResolver::consider_update_target(const vespalib::string& slobrok_id,\n+                                                 const vespalib::string& connection_spec,\n+                                                 uint32_t curr_slobrok_gen,\n+                                                 const UniqueLock& targets_lock) {\n+    (void) targets_lock;", "originalCommit": "5518be46c5f333c23547fcf02cfc543cebb40f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MzA1Ng==", "url": "https://github.com/vespa-engine/vespa/pull/14383#discussion_r487053056", "bodyText": "Fixed", "author": "geirst", "createdAt": "2020-09-11T13:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzNjAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzODMzNQ==", "url": "https://github.com/vespa-engine/vespa/pull/14383#discussion_r487038335", "bodyText": "Should we consider having the factory return shared_ptr instead of unique_ptr? The latter is more obvious that returned objects are unique, the former avoids an extra control block allocation due to make_shared.", "author": "vekterli", "createdAt": "2020-09-11T13:17:49Z", "path": "storage/src/vespa/storage/storageserver/rpc/caching_rpc_target_resolver.cpp", "diffHunk": "@@ -1,82 +1,107 @@\n // Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n #include \"caching_rpc_target_resolver.h\"\n #include \"shared_rpc_resources.h\"\n-#include <vespa/fnet/frt/supervisor.h>\n #include <vespa/fnet/frt/target.h>\n-#include <vespa/slobrok/sbmirror.h>\n+#include <vespa/slobrok/imirrorapi.h>\n #include <vespa/storageapi/messageapi/storagemessage.h>\n #include <vespa/vespalib/stllike/asciistream.h>\n #include <vespa/vespalib/stllike/hash_map.hpp>\n+#include <cassert>\n \n #include <vespa/log/log.h>\n LOG_SETUP(\".storage.caching_rpc_target_resolver\");\n \n namespace storage::rpc {\n \n-CachingRpcTargetResolver::CachingRpcTargetResolver(SharedRpcResources& rpc_resources)\n-    : _rpc_resources(rpc_resources)\n+CachingRpcTargetResolver::CachingRpcTargetResolver(const slobrok::api::IMirrorAPI& slobrok_mirror,\n+                                                   const RpcTargetFactory& target_factory)\n+    : _slobrok_mirror(slobrok_mirror),\n+      _target_factory(target_factory),\n+      _targets_rwmutex()\n {\n }\n \n CachingRpcTargetResolver::~CachingRpcTargetResolver() = default;\n \n-namespace {\n-\n-vespalib::string address_to_slobrok_id(const api::StorageMessageAddress& address) {\n+vespalib::string\n+CachingRpcTargetResolver::address_to_slobrok_id(const api::StorageMessageAddress& address) {\n     vespalib::asciistream as;\n     as << \"storage/cluster.\" << address.getCluster()\n        << '/' << ((address.getNodeType() == lib::NodeType::STORAGE) ? \"storage\" : \"distributor\")\n        << '/' << address.getIndex();\n     return as.str();\n }\n \n+std::shared_ptr<RpcTarget>\n+CachingRpcTargetResolver::lookup_target(const vespalib::string& slobrok_id, uint32_t curr_slobrok_gen) {\n+    std::shared_lock lock(_targets_rwmutex);\n+    auto itr = _targets.find(slobrok_id);\n+    if ((itr != _targets.end())\n+        && itr->second->_target->is_valid()\n+        && (itr->second->_slobrok_gen == curr_slobrok_gen)) {\n+        return itr->second;\n+    }\n+    return {};\n+}\n+\n+std::shared_ptr<RpcTarget>\n+CachingRpcTargetResolver::consider_update_target(const vespalib::string& slobrok_id,\n+                                                 const vespalib::string& connection_spec,\n+                                                 uint32_t curr_slobrok_gen,\n+                                                 const UniqueLock& targets_lock) {\n+    (void) targets_lock;\n+    // If address has the same spec as the existing target, just reuse it.\n+    auto itr = _targets.find(slobrok_id);\n+    if ((itr != _targets.end())\n+        && (itr->second->_target->is_valid())\n+        && (itr->second->_spec == connection_spec))\n+    {\n+        LOG(info, \"Updating existing mapping '%s' -> '%s' (gen %u) to gen %u\",\n+            slobrok_id.c_str(), connection_spec.c_str(), itr->second->_slobrok_gen, curr_slobrok_gen);\n+        itr->second->_slobrok_gen = curr_slobrok_gen;\n+        return itr->second;\n+    }\n+    return {};\n+}\n+\n+std::shared_ptr<RpcTarget>\n+CachingRpcTargetResolver::insert_new_target_mapping(const vespalib::string& slobrok_id,\n+                                                    const vespalib::string& connection_spec,\n+                                                    uint32_t curr_slobrok_gen,\n+                                                    const UniqueLock& targets_lock) {\n+    (void) targets_lock;\n+    auto target = _target_factory.make_target(connection_spec, curr_slobrok_gen); // TODO expensive inside lock?", "originalCommit": "5518be46c5f333c23547fcf02cfc543cebb40f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0OTEwOQ==", "url": "https://github.com/vespa-engine/vespa/pull/14383#discussion_r487049109", "bodyText": "Discussed offline. We stick with unique_ptr as that better describes intent.", "author": "geirst", "createdAt": "2020-09-11T13:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzODMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzOTU5Nw==", "url": "https://github.com/vespa-engine/vespa/pull/14383#discussion_r487039597", "bodyText": "Consider removing explicit since the constructor has been updated to take in more than one arg", "author": "vekterli", "createdAt": "2020-09-11T13:19:58Z", "path": "storage/src/vespa/storage/storageserver/rpc/caching_rpc_target_resolver.h", "diffHunk": "@@ -2,29 +2,50 @@\n #pragma once\n \n #include \"rpc_target.h\"\n+#include \"rpc_target_factory.h\"\n #include <vespa/vespalib/stllike/hash_map.h>\n #include <memory>\n #include <shared_mutex>\n \n+namespace slobrok::api { class IMirrorAPI; }\n+\n namespace storage {\n \n namespace api { class StorageMessageAddress; }\n \n namespace rpc {\n \n-class SharedRpcResources;\n-\n+/**\n+ * Class that resolves and caches rpc targets based on StorageMessageAddress that is mapped to slobrok id,\n+ * with lookup in a slobrok mirror.\n+ */\n class CachingRpcTargetResolver {\n-    SharedRpcResources& _rpc_resources;\n+private:\n+    const slobrok::api::IMirrorAPI& _slobrok_mirror;\n+    const RpcTargetFactory& _target_factory;\n+    using UniqueLock = std::unique_lock<std::shared_mutex>;\n     mutable std::shared_mutex _targets_rwmutex;\n     // TODO LRU? Size cap?\n     vespalib::hash_map<vespalib::string, std::shared_ptr<RpcTarget>> _targets;\n+\n+    std::shared_ptr<RpcTarget> lookup_target(const vespalib::string& slobrok_id, uint32_t curr_slobrok_gen);\n+    std::shared_ptr<RpcTarget> consider_update_target(const vespalib::string& slobrok_id,\n+                                                      const vespalib::string& connection_spec,\n+                                                      uint32_t curr_slobrok_gen,\n+                                                      const UniqueLock& targets_lock);\n+\n+    std::shared_ptr<RpcTarget> insert_new_target_mapping(const vespalib::string& slobrok_id,\n+                                                         const vespalib::string& connection_spec,\n+                                                         uint32_t curr_slobrok_gen,\n+                                                         const UniqueLock& targets_lock);\n+\n public:\n-    // TODO pass explicit slobrok mirror interface and supervisor to make testing easier\n-    // TODO consider wrapping supervisor to make testing easier\n-    explicit CachingRpcTargetResolver(SharedRpcResources& rpc_resources);\n+    explicit CachingRpcTargetResolver(const slobrok::api::IMirrorAPI& slobrok_mirror,\n+                                      const RpcTargetFactory& target_factory);", "originalCommit": "5518be46c5f333c23547fcf02cfc543cebb40f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MjcxMA==", "url": "https://github.com/vespa-engine/vespa/pull/14383#discussion_r487052710", "bodyText": "Fixed", "author": "geirst", "createdAt": "2020-09-11T13:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzOTU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0MDI3MA==", "url": "https://github.com/vespa-engine/vespa/pull/14383#discussion_r487040270", "bodyText": "Consider making both these noexcept", "author": "vekterli", "createdAt": "2020-09-11T13:21:02Z", "path": "storage/src/vespa/storage/storageserver/rpc/rpc_target.h", "diffHunk": "@@ -8,15 +8,24 @@ class FRT_Target;\n \n namespace storage::rpc {\n \n+/**\n+ * Simple wrapper API to access a FRT_Target.\n+ */\n+class WrappedFrtTarget {\n+public:\n+    virtual ~WrappedFrtTarget() = default;\n+    virtual FRT_Target* get() = 0;\n+    virtual bool is_valid() const = 0;", "originalCommit": "5518be46c5f333c23547fcf02cfc543cebb40f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MjgxOA==", "url": "https://github.com/vespa-engine/vespa/pull/14383#discussion_r487052818", "bodyText": "Fixed", "author": "geirst", "createdAt": "2020-09-11T13:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0MDI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0MTA1Mw==", "url": "https://github.com/vespa-engine/vespa/pull/14383#discussion_r487041053", "bodyText": "Consider = default instead of empty body", "author": "vekterli", "createdAt": "2020-09-11T13:22:13Z", "path": "storage/src/vespa/storage/storageserver/rpc/rpc_target_factory.h", "diffHunk": "@@ -0,0 +1,21 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+#pragma once\n+\n+#include <vespa/vespalib/stllike/string.h>\n+#include <memory>\n+\n+namespace storage::rpc {\n+\n+class RpcTarget;\n+\n+/**\n+ * Factory for creating instances of RpcTarget based on a connection spec.\n+ */\n+class RpcTargetFactory {\n+public:\n+    virtual ~RpcTargetFactory() {}", "originalCommit": "5518be46c5f333c23547fcf02cfc543cebb40f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MjkyMw==", "url": "https://github.com/vespa-engine/vespa/pull/14383#discussion_r487052923", "bodyText": "Fixed", "author": "geirst", "createdAt": "2020-09-11T13:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0MTA1Mw=="}], "type": "inlineReview"}, {"oid": "dc745d31c56b5666a21d0385baf9086ff2f566ae", "url": "https://github.com/vespa-engine/vespa/commit/dc745d31c56b5666a21d0385baf9086ff2f566ae", "message": "Minor adjustments based on review feedback.", "committedDate": "2020-09-11T13:39:57Z", "type": "commit"}]}