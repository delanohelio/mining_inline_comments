{"pr_number": 14839, "pr_title": "- Use std::mutex/std::condition_varaible over vespalib::Monitor.", "pr_createdAt": "2020-10-13T11:06:01Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/14839", "timeline": [{"oid": "d030fc60e38ff893ec01267211ab00890bcd2159", "url": "https://github.com/vespa-engine/vespa/commit/d030fc60e38ff893ec01267211ab00890bcd2159", "message": "- Use std::mutex/std::condition_varaible over vespalib::Monitor.\n- use vespa::duration over storage::framework::XXXTime.", "committedDate": "2020-10-13T11:02:53Z", "type": "commit"}, {"oid": "8e8713cdec730d347e44e2eb55aafc74cbfa374e", "url": "https://github.com/vespa-engine/vespa/commit/8e8713cdec730d347e44e2eb55aafc74cbfa374e", "message": "Use std::mutex", "committedDate": "2020-10-13T12:30:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk1MjkxNw==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r503952917", "bodyText": "Can this function be removed entirely?", "author": "vekterli", "createdAt": "2020-10-13T13:30:32Z", "path": "storage/src/vespa/storage/common/statusmetricconsumer.cpp", "diffHunk": "@@ -337,17 +337,9 @@ StatusMetricConsumer::reportStatus(std::ostream& out,\n }\n \n void\n-StatusMetricConsumer::waitUntilTimeProcessed(framework::SecondTime t) const\n+StatusMetricConsumer::waitUntilTimeProcessed(framework::SecondTime ) const\n {\n-    return; // Return straight away as thread is not running now.\n-        // This is used in unit testing to wait for internal thread to have\n-        // generated snapshots. Wait aggressively and signal other thread to\n-        // make it do it quick (as it uses fake timer)\n-    vespalib::MonitorGuard sync(_waiter);\n-    while (_processedTime < t) {\n-        sync.signal();\n-        sync.wait(1);\n-    }\n+    return;", "originalCommit": "8e8713cdec730d347e44e2eb55aafc74cbfa374e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIyMjcwNw==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r504222707", "bodyText": "Yes, done", "author": "baldersheim", "createdAt": "2020-10-13T20:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk1MjkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MDg2Nw==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r503980867", "bodyText": "Will std::atomic of chrono types be lock-free, or will it be considered some opaque POD type that gets wrapped by spinlocks? Not that it actually matters for this component; if anything we should consider removing it since it doesn't really do much these days. If we suspect a deadlock, a pstack/gcore is likely the only reasonable course of action for forensics, not log messages or internal status pages.", "author": "vekterli", "createdAt": "2020-10-13T14:05:58Z", "path": "storage/src/vespa/storage/frameworkimpl/thread/deadlockdetector.h", "diffHunk": "@@ -81,8 +79,8 @@ struct DeadLockDetector : private framework::Runnable,\n     std::condition_variable _cond;\n     bool _enableWarning;\n     bool _enableShutdown;\n-    std::atomic<uint64_t> _processSlackMs;\n-    std::atomic<uint64_t> _waitSlackMs;\n+    std::atomic<vespalib::duration> _processSlackMs;\n+    std::atomic<vespalib::duration> _waitSlackMs;", "originalCommit": "8e8713cdec730d347e44e2eb55aafc74cbfa374e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIyOTc0OQ==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r504229749", "bodyText": "Test added, they are lock free. However I do agree on the deadlock detector. It is overly complicated. It will also have less value when we go fully async, as different threads will experience the trouble.\nWe might want to consider its right to live later on.", "author": "baldersheim", "createdAt": "2020-10-13T20:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MDg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4NDkzNw==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r503984937", "bodyText": "Consider bringing back lock on _pauseMonitor here since it enforces visibility of the write to _paused to the thread being woken up. Relaxed store/load does not guarantee that.", "author": "vekterli", "createdAt": "2020-10-13T14:11:03Z", "path": "storage/src/vespa/storage/persistence/filestorage/filestorhandlerimpl.cpp", "diffHunk": "@@ -1347,9 +1347,8 @@ FileStorHandlerImpl::pause()\n void\n FileStorHandlerImpl::resume()\n {\n-    vespalib::MonitorGuard g(_pauseMonitor);\n     _paused.store(false, std::memory_order_relaxed);\n-    g.broadcast();\n+    _pauseCond.notify_all();", "originalCommit": "8e8713cdec730d347e44e2eb55aafc74cbfa374e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzMDI2NA==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r504230264", "bodyText": "Done, I assumed that using atomic would ensure that.", "author": "baldersheim", "createdAt": "2020-10-13T20:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4NDkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAwOTk3Nw==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r504009977", "bodyText": "Technically this should never be true when a monotonic time source is used. Should we remove it or keep it around just in case we want to discover if there's any funny kernel business going on? \ud83d\ude42", "author": "vekterli", "createdAt": "2020-10-13T14:42:25Z", "path": "storageframework/src/vespa/storageframework/defaultimplementation/thread/threadimpl.cpp", "diffHunk": "@@ -69,30 +69,29 @@ ThreadImpl::join()\n }\n \n void\n-ThreadImpl::registerTick(CycleType cycleType, MilliSecTime time)\n+ThreadImpl::registerTick(CycleType cycleType, vespalib::steady_time now)\n {\n-    if (!time.isSet()) time = _pool.getClock().getTimeInMillis();\n+    if (now.time_since_epoch() == vespalib::duration::zero()) now = _pool.getClock().getMonotonicTime();\n     ThreadTickData data(getTickData());\n-    uint64_t previousTickMs = data._lastTickMs;\n-    uint64_t nowMs = time.getTime();\n-    data._lastTickMs = nowMs;\n+    vespalib::steady_clock::time_point previousTick = data._lastTick;\n+    data._lastTick = now;\n     data._lastTickType = cycleType;\n     setTickData(data);\n \n-    if (data._lastTickMs == 0) { return; }\n+    if (data._lastTick.time_since_epoch() == vespalib::duration::zero()) { return; }\n \n-    if (previousTickMs > nowMs) {\n+    if (previousTick > now) {", "originalCommit": "8e8713cdec730d347e44e2eb55aafc74cbfa374e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzMDc1OQ==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r504230759", "bodyText": "Keep it for now.", "author": "baldersheim", "createdAt": "2020-10-13T20:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAwOTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAxNjUyMg==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r504016522", "bodyText": "Consider doing a quick sweep of variables/parameters that are now vespalib::duration and remove \"Ms\" etc. explicit unit suffix", "author": "vekterli", "createdAt": "2020-10-13T14:50:16Z", "path": "storageframework/src/vespa/storageframework/defaultimplementation/thread/threadimpl.h", "diffHunk": "@@ -26,10 +26,16 @@ class ThreadImpl : public Thread\n      * on code using it.\n      */\n     struct AtomicThreadTickData {\n+        AtomicThreadTickData() noexcept\n+            : _lastTickType(),\n+              _lastTickMs(vespalib::steady_time(vespalib::duration::zero())),\n+              _maxProcessingTimeSeenMs(),\n+              _maxWaitTimeSeenMs()\n+        {}\n         std::atomic<CycleType> _lastTickType;\n-        std::atomic<uint64_t> _lastTickMs;\n-        std::atomic<uint64_t> _maxProcessingTimeSeenMs;\n-        std::atomic<uint64_t> _maxWaitTimeSeenMs;\n+        std::atomic<vespalib::steady_time> _lastTickMs;\n+        std::atomic<vespalib::duration> _maxProcessingTimeSeenMs;\n+        std::atomic<vespalib::duration> _maxWaitTimeSeenMs;", "originalCommit": "8e8713cdec730d347e44e2eb55aafc74cbfa374e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzNTc5NQ==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r504235795", "bodyText": "Done", "author": "baldersheim", "createdAt": "2020-10-13T20:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAxNjUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE5NDg5OQ==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r504194899", "bodyText": "Shouldn't this class take in a mutex and a condition_variable and instantiate a unique_lock instead? The previous impl acquired a MonitorGuard while this impl does not end up taking any locks.", "author": "vekterli", "createdAt": "2020-10-13T19:12:47Z", "path": "storageframework/src/vespa/storageframework/generic/thread/tickingthread.cpp", "diffHunk": "@@ -120,40 +124,40 @@ class TickingThreadPoolImpl final : public TickingThreadPool {\n         void broadcast() override {}\n     };\n     struct CriticalGuard final : public TickingLockGuard::Impl {\n-        vespalib::MonitorGuard _guard;\n+        std::condition_variable &_cond;\n \n-        explicit CriticalGuard(vespalib::Monitor& m) : _guard(m) {}\n+        explicit CriticalGuard(std::condition_variable & cond) : _cond(cond) {}", "originalCommit": "8e8713cdec730d347e44e2eb55aafc74cbfa374e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzMTA5OQ==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r504231099", "bodyText": "Oops, to fast....", "author": "baldersheim", "createdAt": "2020-10-13T20:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE5NDg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzNjkxOA==", "url": "https://github.com/vespa-engine/vespa/pull/14839#discussion_r504236918", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-10-13T20:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE5NDg5OQ=="}], "type": "inlineReview"}, {"oid": "af77cdd1fb34e8e4cb7259bea395427a91bf8a39", "url": "https://github.com/vespa-engine/vespa/commit/af77cdd1fb34e8e4cb7259bea395427a91bf8a39", "message": "GC unused method.", "committedDate": "2020-10-13T19:44:44Z", "type": "commit"}, {"oid": "231962269b22d5f5f9d58d62ea15430587ab00b0", "url": "https://github.com/vespa-engine/vespa/commit/231962269b22d5f5f9d58d62ea15430587ab00b0", "message": "Time is no longer given in milliseconds.", "committedDate": "2020-10-13T19:58:10Z", "type": "commit"}, {"oid": "cdbaea53fb49e3c41b7788f2519d34cd971dad07", "url": "https://github.com/vespa-engine/vespa/commit/cdbaea53fb49e3c41b7788f2519d34cd971dad07", "message": "Put back guard to ensure thread visibility.", "committedDate": "2020-10-13T20:03:13Z", "type": "commit"}, {"oid": "33291d95a41eeb9919392805da8b2986188c7014", "url": "https://github.com/vespa-engine/vespa/commit/33291d95a41eeb9919392805da8b2986188c7014", "message": "Verify that atomic duration time_point is lock free.", "committedDate": "2020-10-13T20:13:37Z", "type": "commit"}, {"oid": "5f9f6aa7f2f9dc2a91692d6db876b21caa60ee12", "url": "https://github.com/vespa-engine/vespa/commit/5f9f6aa7f2f9dc2a91692d6db876b21caa60ee12", "message": "Properly lock criticalk section.", "committedDate": "2020-10-13T20:23:50Z", "type": "commit"}]}