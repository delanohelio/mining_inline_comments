{"pr_number": 12552, "pr_title": "Arnej/polymorphic distance feature", "pr_createdAt": "2020-03-12T15:00:01Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/12552", "timeline": [{"oid": "fdca30ff3789404465b478c31cb619a76c320ff7", "url": "https://github.com/vespa-engine/vespa/commit/fdca30ff3789404465b478c31cb619a76c320ff7", "message": "extend \"distance\" feature to also extract NNS rawscore", "committedDate": "2020-03-12T14:21:07Z", "type": "commit"}, {"oid": "20c22e5a60d79eae428374abab8fcd0c71dbdb8f", "url": "https://github.com/vespa-engine/vespa/commit/20c22e5a60d79eae428374abab8fcd0c71dbdb8f", "message": "also support labeled items", "committedDate": "2020-03-12T14:21:07Z", "type": "commit"}, {"oid": "076924e0d6048f6474c994f75dc6481ad06b1ea7", "url": "https://github.com/vespa-engine/vespa/commit/076924e0d6048f6474c994f75dc6481ad06b1ea7", "message": "test must now setup field info correctly", "committedDate": "2020-03-12T14:55:18Z", "type": "commit"}, {"oid": "707e76eceb19459afb0750d970a4947974db1211", "url": "https://github.com/vespa-engine/vespa/commit/707e76eceb19459afb0750d970a4947974db1211", "message": "add unit test for extended distance feature", "committedDate": "2020-03-13T11:30:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExODk0MA==", "url": "https://github.com/vespa-engine/vespa/pull/12552#discussion_r392118940", "bodyText": "'\\n' should not be need in log message.", "author": "geirst", "createdAt": "2020-03-13T09:35:47Z", "path": "searchlib/src/vespa/searchlib/features/distancefeature.cpp", "diffHunk": "@@ -101,30 +151,69 @@ DistanceBlueprint::createInstance() const\n }\n \n bool\n-DistanceBlueprint::setup(const IIndexEnvironment & env,\n-                         const ParameterList & params)\n+DistanceBlueprint::setup_geopos(const IIndexEnvironment & env,\n+                                const vespalib::string &attr)\n {\n-    _posAttr = params[0].getValue();\n+    _posAttr = attr;\n+    _use_geo_pos = true;\n     describeOutput(\"out\", \"The euclidean distance from the query position.\");\n     env.hintAttributeAccess(_posAttr);\n-    env.hintAttributeAccess(document::PositionDataType::getZCurveFieldName(_posAttr));\n     return true;\n }\n \n+bool\n+DistanceBlueprint::setup_nns(const IIndexEnvironment & env,\n+                             const vespalib::string &attr)\n+{\n+    _posAttr = attr;\n+    _use_nns_tensor = true;\n+    describeOutput(\"out\", \"The euclidean distance from the query position.\");\n+    env.hintAttributeAccess(_posAttr);\n+    return true;\n+}\n+\n+bool\n+DistanceBlueprint::setup(const IIndexEnvironment & env,\n+                         const ParameterList & params)\n+{\n+    vespalib::string arg = params[0].getValue();\n+    const FieldInfo *fi = env.getFieldByName(arg);\n+    if (fi != nullptr && fi->hasAttribute()) {\n+        auto dt = fi->get_data_type();\n+        auto ct = fi->collection();\n+        if (dt == DataType::TENSOR && ct == CollectionType::SINGLE) {\n+            _attr_id = fi->id();\n+            return setup_nns(env, arg);\n+        }\n+        // could check if dt is DataType::INT64\n+        // could check if ct is CollectionType::SINGLE or CollectionType::ARRAY)\n+        return setup_geopos(env, arg);\n+    }\n+    vespalib::string z = document::PositionDataType::getZCurveFieldName(arg);\n+    fi = env.getFieldByName(z);\n+    if (fi != nullptr && fi->hasAttribute()) {\n+        return setup_geopos(env, z);\n+    }\n+    return false;\n+}\n+\n FeatureExecutor &\n DistanceBlueprint::createExecutor(const IQueryEnvironment &env, vespalib::Stash &stash) const\n {\n+    if (_use_nns_tensor) {\n+        const search::attribute::IAttributeVector * attr = env.getAttributeContext().getAttribute(_posAttr);\n+        if (attr != nullptr) {\n+             return stash.create<ConvertRawscoreExecutor>(env, _attr_id);\n+        } else {\n+             LOG(warning, \"unexpected missing attribute '%s'\\n\", _posAttr.c_str());", "originalCommit": "fdca30ff3789404465b478c31cb619a76c320ff7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MDc1Mg==", "url": "https://github.com/vespa-engine/vespa/pull/12552#discussion_r392860752", "bodyText": "Please update copyright", "author": "geirst", "createdAt": "2020-03-16T08:47:20Z", "path": "searchlib/src/tests/features/nns_distance/CMakeLists.txt", "diffHunk": "@@ -0,0 +1,8 @@\n+# Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "originalCommit": "707e76eceb19459afb0750d970a4947974db1211", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MDg0MQ==", "url": "https://github.com/vespa-engine/vespa/pull/12552#discussion_r392860841", "bodyText": "Please update copyright", "author": "geirst", "createdAt": "2020-03-16T08:47:32Z", "path": "searchlib/src/tests/features/nns_distance/nns_distance_test.cpp", "diffHunk": "@@ -0,0 +1,177 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "originalCommit": "707e76eceb19459afb0750d970a4947974db1211", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjQ5OQ==", "url": "https://github.com/vespa-engine/vespa/pull/12552#discussion_r392866499", "bodyText": "Prefer static_cast over C style cast.", "author": "geirst", "createdAt": "2020-03-16T08:58:29Z", "path": "searchlib/src/tests/features/nns_distance/nns_distance_test.cpp", "diffHunk": "@@ -0,0 +1,177 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/testkit/test_kit.h>\n+#include <vespa/searchlib/features/setup.h>\n+#include <vespa/searchlib/fef/test/indexenvironment.h>\n+#include <vespa/searchlib/fef/test/indexenvironmentbuilder.h>\n+#include <vespa/searchlib/fef/test/queryenvironment.h>\n+#include <vespa/searchlib/features/distancefeature.h>\n+#include <vespa/searchlib/fef/fef.h>\n+#include <vespa/searchlib/fef/test/dummy_dependency_handler.h>\n+#include <vespa/vespalib/stllike/asciistream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+\n+using search::feature_t;\n+using namespace search::fef;\n+using namespace search::fef::test;\n+using namespace search::features;\n+using CollectionType = FieldInfo::CollectionType;\n+using DataType = FieldInfo::DataType;\n+\n+const vespalib::string labelFeatureName(\"distance(label)\");\n+const vespalib::string fieldFeatureName(\"distance(bar)\");\n+\n+struct BlueprintFactoryFixture {\n+    BlueprintFactory factory;\n+    BlueprintFactoryFixture() : factory()\n+    {\n+        setup_search_features(factory);\n+    }\n+};\n+\n+struct IndexFixture {\n+    IndexEnvironment indexEnv;\n+    IndexFixture() : indexEnv()\n+    {\n+        IndexEnvironmentBuilder builder(indexEnv);\n+        builder.addField(FieldType::ATTRIBUTE, CollectionType::SINGLE, DataType::INT64, \"foo\");\n+        builder.addField(FieldType::ATTRIBUTE, CollectionType::SINGLE, DataType::TENSOR, \"bar\");\n+    }\n+};\n+\n+struct FeatureDumpFixture : public IDumpFeatureVisitor {\n+    virtual void visitDumpFeature(const vespalib::string &) override {\n+        TEST_ERROR(\"no features should be dumped\");\n+    }\n+    FeatureDumpFixture() : IDumpFeatureVisitor() {}\n+};\n+\n+struct Labels {\n+    virtual void inject(Properties &p) const = 0;\n+    virtual ~Labels() {}\n+};\n+struct NoLabel : public Labels {\n+    virtual void inject(Properties &) const override {}    \n+};\n+struct SingleLabel : public Labels {\n+    vespalib::string label;\n+    uint32_t uid;\n+    SingleLabel(const vespalib::string &l, uint32_t x) : label(l), uid(x) {}\n+    virtual void inject(Properties &p) const override {\n+        vespalib::asciistream key;\n+        key << \"vespa.label.\" << label << \".id\";\n+        vespalib::asciistream value;\n+        value << uid;\n+        p.add(key.str(), value.str());\n+    }\n+};\n+\n+struct RankFixture : BlueprintFactoryFixture, IndexFixture {\n+    QueryEnvironment         queryEnv;\n+    RankSetup                rankSetup;\n+    MatchDataLayout          mdl;\n+    MatchData::UP            match_data;\n+    RankProgram::UP          rankProgram;\n+    std::vector<TermFieldHandle> fooHandles;\n+    std::vector<TermFieldHandle> barHandles;\n+    RankFixture(size_t fooCnt, size_t barCnt, const Labels &labels, const vespalib::string &featureName)\n+        : queryEnv(&indexEnv), rankSetup(factory, indexEnv),\n+          mdl(), match_data(), rankProgram(), fooHandles(), barHandles()\n+    {\n+        for (size_t i = 0; i < fooCnt; ++i) {\n+            uint32_t fieldId = indexEnv.getFieldByName(\"foo\")->id();\n+            fooHandles.push_back(mdl.allocTermField(fieldId));\n+            SimpleTermData term;\n+            term.setUniqueId(i + 1);\n+            term.addField(fieldId).setHandle(fooHandles.back());\n+            queryEnv.getTerms().push_back(term);\n+        }\n+        for (size_t i = 0; i < barCnt; ++i) { \n+            uint32_t fieldId = indexEnv.getFieldByName(\"bar\")->id();\n+            barHandles.push_back(mdl.allocTermField(fieldId));\n+            SimpleTermData term;\n+            term.setUniqueId(fooCnt + i + 1);\n+            term.addField(fieldId).setHandle(barHandles.back());\n+            queryEnv.getTerms().push_back(term);\n+        }\n+        labels.inject(queryEnv.getProperties());\n+        rankSetup.setFirstPhaseRank(featureName);\n+        rankSetup.setIgnoreDefaultRankFeatures(true);\n+        ASSERT_TRUE(rankSetup.compile());\n+        match_data = mdl.createMatchData();\n+        rankProgram = rankSetup.create_first_phase_program();\n+        rankProgram->setup(*match_data, queryEnv);\n+    }\n+    feature_t getScore(uint32_t docId) {\n+        return Utils::getScoreFeature(*rankProgram, docId);\n+    }\n+    void setScore(TermFieldHandle handle, uint32_t docId, feature_t score) {\n+        match_data->resolveTermField(handle)->setRawScore(docId, score);\n+    }\n+    void setFooScore(uint32_t i, uint32_t docId, feature_t score) {\n+        ASSERT_LESS(i, fooHandles.size());\n+        setScore(fooHandles[i], docId, score);\n+    }\n+    void setBarScore(uint32_t i, uint32_t docId, feature_t score) {\n+        ASSERT_LESS(i, barHandles.size());\n+        setScore(barHandles[i], docId, score);\n+    }\n+};\n+\n+TEST_F(\"require that blueprint can be created from factory\", BlueprintFactoryFixture) {\n+    Blueprint::SP bp = f.factory.createBlueprint(\"distance\");\n+    EXPECT_TRUE(bp.get() != 0);\n+    EXPECT_TRUE(dynamic_cast<DistanceBlueprint*>(bp.get()) != 0);\n+}\n+\n+TEST_FFF(\"require that no features are dumped\", DistanceBlueprint, IndexFixture, FeatureDumpFixture) {\n+    f1.visitDumpFeatures(f2.indexEnv, f3);\n+}\n+\n+TEST_FF(\"require that setup can be done on random label\", DistanceBlueprint, IndexFixture) {\n+    DummyDependencyHandler deps(f1);\n+    f1.setName(vespalib::make_string(\"%s(random_label)\", f1.getBaseName().c_str()));\n+    EXPECT_TRUE(((Blueprint&)f1).setup(f2.indexEnv, std::vector<vespalib::string>(1, \"random_label\")));", "originalCommit": "707e76eceb19459afb0750d970a4947974db1211", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7fd2d7d18d88a1decb3ec4c1b74eb93f5659ec0c", "url": "https://github.com/vespa-engine/vespa/commit/7fd2d7d18d88a1decb3ec4c1b74eb93f5659ec0c", "message": "review follow-up", "committedDate": "2020-03-16T12:46:57Z", "type": "commit"}]}