{"pr_number": 13490, "pr_title": "When we pull in a cacheline, we should use it too.", "pr_createdAt": "2020-06-04T22:38:25Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/13490", "timeline": [{"oid": "8ef08f0c80a409ecfebd179d2a71382ee9b9d814", "url": "https://github.com/vespa-engine/vespa/commit/8ef08f0c80a409ecfebd179d2a71382ee9b9d814", "message": "When we pull in a cacheline, we should use it too.\nThere is possibly wasting 7/8 of it and very likely suffer a cache miss.", "committedDate": "2020-06-04T22:34:44Z", "type": "commit"}, {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6", "url": "https://github.com/vespa-engine/vespa/commit/3fded8534edd1ad2a9ae3e5e6575eabf209c76e6", "message": "Use c++11 for loop.", "committedDate": "2020-06-05T08:21:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODE2Mg==", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435828162", "bodyText": "should also test with inverted vectors", "author": "havardpe", "createdAt": "2020-06-05T10:17:38Z", "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);", "originalCommit": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2NDg0MA==", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r436364840", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-06-07T13:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODIzNA==", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435828234", "bodyText": "should also test with inverted vectors", "author": "havardpe", "createdAt": "2020-06-05T10:17:47Z", "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.or64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");\n+                LOG_ABORT(\"should not be reached\");\n+            }\n+        }\n+    }\n+}\n+\n+void\n+verifyAnd64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleAndWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);", "originalCommit": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2NDgxMA==", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r436364810", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-06-07T13:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODQyOA==", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435828428", "bodyText": "misleading error message", "author": "havardpe", "createdAt": "2020-06-05T10:18:09Z", "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.or64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");\n+                LOG_ABORT(\"should not be reached\");\n+            }\n+        }\n+    }\n+}\n+\n+void\n+verifyAnd64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleAndWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.and64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");", "originalCommit": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1OTczMQ==", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r436359731", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-06-07T12:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODQ3Mw==", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435828473", "bodyText": "even more misleading error message", "author": "havardpe", "createdAt": "2020-06-05T10:18:15Z", "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.or64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");", "originalCommit": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1OTY5OA==", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r436359698", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-06-07T12:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MDI0Mw==", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435840243", "bodyText": "should add a static assert somewhere that this value is 64 bytes", "author": "havardpe", "createdAt": "2020-06-05T10:43:19Z", "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,90 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(const Children & children) : MultiBitVectorIteratorBase(children) { }\n+    explicit MultiBitVectorIterator(const Children & children)\n+        : MultiBitVectorIteratorBase(children),\n+          _update(),\n+          _lastWords(),\n+          _accel(IAccelrated::getAccelrator())\n+    {\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    Word                _lastWords[8] __attribute__((aligned(32)));", "originalCommit": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1OTQyMA==", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r436359420", "bodyText": "Fixed", "author": "baldersheim", "createdAt": "2020-06-07T12:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MDI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NDM4OA==", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435844388", "bodyText": "these functions are a bit confusing. The length of the operation is specified in bytes while the offset is specified in multiples of uint64_t. It also binds the Word abstraction to be uint64_t, making that abstraction less useful. Also; at glace, the 64 in the function name seems to reflect the fact that we are using 64-bit values, leaving the size of the operation a mystery...\nconsider using byte offset and passing the memory as void*", "author": "havardpe", "createdAt": "2020-06-05T10:53:04Z", "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.h", "diffHunk": "@@ -29,6 +30,9 @@ class IAccelrated\n     virtual size_t populationCount(const uint64_t *a, size_t sz) const = 0;\n     virtual double squaredEuclideanDistance(const float * a, const float * b, size_t sz) const = 0;\n     virtual double squaredEuclideanDistance(const double * a, const double * b, size_t sz) const = 0;\n+    // And 64 bytes from multiple sources\n+    virtual void and64(size_t offset, const std::vector<std::pair<const uint64_t *, bool>> &src, uint64_t *dest) const = 0;", "originalCommit": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2NDkwNg==", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r436364906", "bodyText": "Agree, fixed", "author": "baldersheim", "createdAt": "2020-06-07T13:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NDM4OA=="}], "type": "inlineReview"}, {"oid": "8c2c60de38041e579cfaae4a8987248fbfc3d16c", "url": "https://github.com/vespa-engine/vespa/commit/8c2c60de38041e579cfaae4a8987248fbfc3d16c", "message": "- Test both normal and inverted bit vectors.\n- Use 64 byte alignment of buffer.\n- Improve error messages.", "committedDate": "2020-06-07T13:19:18Z", "type": "commit"}, {"oid": "633d97a8c892bbff4cb1c8bb58c5797435dd2ee0", "url": "https://github.com/vespa-engine/vespa/commit/633d97a8c892bbff4cb1c8bb58c5797435dd2ee0", "message": "- Stick to void * and byte offsets.\n- Correct spelling error.", "committedDate": "2020-06-07T13:50:17Z", "type": "commit"}, {"oid": "8b85b62224800ef740ea80c223e5e7c2baadadae", "url": "https://github.com/vespa-engine/vespa/commit/8b85b62224800ef740ea80c223e5e7c2baadadae", "message": "Merge branch 'master' into balder/fetch-and-merge-a-cacheline", "committedDate": "2020-06-07T21:16:54Z", "type": "commit"}]}