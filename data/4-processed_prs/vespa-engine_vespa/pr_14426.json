{"pr_number": 14426, "pr_title": "Add benchmark for feeding at SPI layer.", "pr_createdAt": "2020-09-16T12:57:07Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/14426", "timeline": [{"oid": "2a57cdfd2e7e24432cf9b0993b9e10dc77f86100", "url": "https://github.com/vespa-engine/vespa/commit/2a57cdfd2e7e24432cf9b0993b9e10dc77f86100", "message": "Add benchmark for feeding at SPI layer.", "committedDate": "2020-09-16T12:55:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MjE5Ng==", "url": "https://github.com/vespa-engine/vespa/pull/14426#discussion_r490282196", "bodyText": "Could also use document::BucketIdFactory to do this", "author": "vekterli", "createdAt": "2020-09-17T14:15:47Z", "path": "searchcore/src/apps/vespa-spi-feed-bm/vespa_spi_feed_bm.cpp", "diffHunk": "@@ -0,0 +1,464 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/testkit/testapp.h>\n+\n+#include <tests/proton/common/dummydbowner.h>\n+#include <vespa/config-imported-fields.h>\n+#include <vespa/config-rank-profiles.h>\n+#include <vespa/config-summarymap.h>\n+#include <vespa/fastos/file.h>\n+#include <vespa/document/datatype/documenttype.h>\n+#include <vespa/document/fieldvalue/intfieldvalue.h>\n+#include <vespa/document/repo/configbuilder.h>\n+#include <vespa/document/repo/documenttyperepo.h>\n+#include <vespa/document/test/make_bucket_space.h>\n+#include <vespa/searchcommon/common/schemaconfigurer.h>\n+#include <vespa/searchcore/proton/common/hw_info.h>\n+#include <vespa/searchcore/proton/matching/querylimiter.h>\n+#include <vespa/searchcore/proton/metrics/metricswireservice.h>\n+#include <vespa/searchcore/proton/persistenceengine/ipersistenceengineowner.h>\n+#include <vespa/searchcore/proton/persistenceengine/persistenceengine.h>\n+#include <vespa/searchcore/proton/server/bootstrapconfig.h>\n+#include <vespa/searchcore/proton/server/document_db_maintenance_config.h>\n+#include <vespa/searchcore/proton/server/documentdb.h>\n+#include <vespa/searchcore/proton/server/documentdbconfigmanager.h>\n+#include <vespa/searchcore/proton/server/fileconfigmanager.h>\n+#include <vespa/searchcore/proton/server/memoryconfigstore.h>\n+#include <vespa/searchcore/proton/server/persistencehandlerproxy.h>\n+#include <vespa/searchlib/index/dummyfileheadercontext.h>\n+#include <vespa/searchlib/transactionlog/translogserver.h>\n+#include <vespa/searchsummary/config/config-juniperrc.h>\n+#include <vespa/vespalib/util/lambdatask.h>\n+#include <vespa/config-bucketspaces.h>\n+#include <vespa/config-attributes.h>\n+#include <vespa/config-indexschema.h>\n+#include <vespa/config-summary.h>\n+#include <vespa/vespalib/io/fileutil.h>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\"vespa-spi-feed-bm\");\n+\n+using namespace config;\n+using namespace proton;\n+using namespace cloud::config::filedistribution;\n+using namespace vespa::config::search::core;\n+using namespace vespa::config::search::summary;\n+using namespace vespa::config::search;\n+using namespace std::chrono_literals;\n+using vespa::config::content::core::BucketspacesConfig;\n+\n+using document::BucketId;\n+using document::BucketSpace;\n+using document::Document;\n+using document::DocumentId;\n+using document::DocumentType;\n+using document::DocumentTypeRepo;\n+using document::DocumenttypesConfig;\n+using document::Field;\n+using document::IntFieldValue;\n+using document::test::makeBucketSpace;\n+using search::TuneFileDocumentDB;\n+using search::index::DummyFileHeaderContext;\n+using search::index::Schema;\n+using search::index::SchemaBuilder;\n+using search::transactionlog::TransLogServer;\n+using storage::spi::Bucket;\n+using storage::spi::PartitionId;\n+using storage::spi::PersistenceProvider;\n+using storage::spi::Priority;\n+using storage::spi::Timestamp;\n+using storage::spi::Trace;\n+using vespalib::makeLambdaTask;\n+\n+using DocumentDBMap = std::map<DocTypeName, std::shared_ptr<DocumentDB>>;\n+\n+namespace {\n+\n+storage::spi::LoadType default_load_type(0, \"default\");\n+\n+vespalib::string base_dir = \"testdb\";\n+\n+std::shared_ptr<DocumenttypesConfig> make_document_type() {\n+    using Struct = document::config_builder::Struct;\n+    using DataType = document::DataType;\n+    document::config_builder::DocumenttypesConfigBuilderHelper builder;\n+    builder.document(42, \"test\", Struct(\"test.header\").addField(\"int\", DataType::T_INT), Struct(\"test.body\"));\n+    return std::make_shared<DocumenttypesConfig>(builder.config());\n+}\n+\n+std::shared_ptr<AttributesConfig> make_attributes_config() {\n+    AttributesConfigBuilder builder;\n+    AttributesConfig::Attribute attribute;\n+    attribute.datatype = AttributesConfig::Attribute::Datatype::INT32;\n+    builder.attribute.emplace_back(attribute);\n+    return std::make_shared<AttributesConfig>(builder);\n+}\n+\n+std::shared_ptr<DocumentDBConfig> make_document_db_config(std::shared_ptr<DocumenttypesConfig> document_types, std::shared_ptr<const DocumentTypeRepo> repo, const DocTypeName& doc_type_name)\n+{\n+    auto indexschema = std::make_shared<IndexschemaConfig>();\n+    auto attributes = make_attributes_config();\n+    auto summary = std::make_shared<SummaryConfig>();\n+    std::shared_ptr<Schema> schema(new Schema());\n+    SchemaBuilder::build(*indexschema, *schema);\n+    SchemaBuilder::build(*attributes, *schema);\n+    SchemaBuilder::build(*summary, *schema);\n+    return std::make_shared<DocumentDBConfig>(\n+            1,\n+            std::make_shared<RankProfilesConfig>(),\n+            std::make_shared<matching::RankingConstants>(),\n+            std::make_shared<matching::OnnxModels>(),\n+            indexschema,\n+            attributes,\n+            summary,\n+            std::make_shared<SummarymapConfig>(),\n+            std::make_shared<JuniperrcConfig>(),\n+            document_types,\n+            repo,\n+            std::make_shared<ImportedFieldsConfig>(),\n+            std::make_shared<TuneFileDocumentDB>(),\n+            schema,\n+            std::make_shared<DocumentDBMaintenanceConfig>(),\n+            search::LogDocumentStore::Config(),\n+            \"client\",\n+            doc_type_name.getName());\n+}\n+\n+class MyPersistenceEngineOwner : public IPersistenceEngineOwner\n+{\n+    void setClusterState(BucketSpace, const storage::spi::ClusterState &) override { }\n+};\n+\n+struct MyResourceWriteFilter : public IResourceWriteFilter\n+{\n+    bool acceptWriteOperation() const override { return true; }\n+    State getAcceptState() const override { return IResourceWriteFilter::State(); }\n+};\n+\n+class MyPendingTracker {\n+    uint32_t                _pending;\n+    uint32_t                _limit;\n+    std::mutex              _mutex;\n+    std::condition_variable _cond;\n+\n+public:\n+    MyPendingTracker(uint32_t limit)\n+        : _pending(0u),\n+          _limit(limit),\n+          _mutex(),\n+          _cond()\n+    {\n+    }\n+\n+    ~MyPendingTracker()\n+    {\n+        drain();\n+    }\n+\n+    void release() {\n+        std::unique_lock<std::mutex> guard(_mutex);\n+        --_pending;\n+        if (_pending < _limit) {\n+            _cond.notify_all();\n+        }\n+        //LOG(info, \"release, pending is now %u\", _pending);\n+    }\n+    void retain() {\n+        std::unique_lock<std::mutex> guard(_mutex);\n+        while (_pending >= _limit) {\n+            _cond.wait(guard);\n+        }\n+        ++_pending;\n+        //LOG(info, \"retain, pending is now %u\", _pending);\n+    }\n+\n+    void drain() {\n+        std::unique_lock<std::mutex> guard(_mutex);\n+        while (_pending > 0) {\n+            _cond.wait(guard);\n+        }\n+    }\n+};\n+\n+class MyOperationComplete : public storage::spi::OperationComplete\n+{\n+    MyPendingTracker& _tracker;\n+public:\n+    MyOperationComplete(MyPendingTracker &tracker);\n+    ~MyOperationComplete();\n+    void onComplete(std::unique_ptr<storage::spi::Result> result) override;\n+    void addResultHandler(const storage::spi::ResultHandler* resultHandler) override;\n+};\n+\n+MyOperationComplete::MyOperationComplete(MyPendingTracker& tracker)\n+    : _tracker(tracker)\n+{\n+    _tracker.retain();\n+}\n+\n+MyOperationComplete::~MyOperationComplete()\n+{\n+    _tracker.release();\n+}\n+\n+void\n+MyOperationComplete::onComplete(std::unique_ptr<storage::spi::Result> result)\n+{\n+    (void) result;\n+}\n+\n+void\n+MyOperationComplete::addResultHandler(const storage::spi::ResultHandler * resultHandler)\n+{\n+    (void) resultHandler;\n+}\n+\n+}\n+\n+\n+struct PersistenceProviderFixture {\n+    std::shared_ptr<DocumenttypesConfig>       _document_types;\n+    std::shared_ptr<const DocumentTypeRepo>    _repo;\n+    DocTypeName                                _doc_type_name;\n+    const DocumentType*                        _document_type;\n+    const Field&                               _field;\n+    std::shared_ptr<DocumentDBConfig>          _document_db_config;\n+    vespalib::string                           _base_dir;\n+    DummyFileHeaderContext                     _file_header_context;\n+    int                                        _tls_listen_port;\n+    TransLogServer                             _tls;\n+    vespalib::string                           _tls_spec;\n+    matching::QueryLimiter                     _query_limiter;\n+    vespalib::Clock                            _clock;\n+    DummyWireService                           _metrics_wire_service;\n+    MemoryConfigStores                         _config_stores;\n+    vespalib::ThreadStackExecutor              _summary_executor;\n+    DummyDBOwner                               _document_db_owner;\n+    BucketSpace                                _bucket_space;\n+    std::shared_ptr<DocumentDB>                _document_db;\n+    MyPersistenceEngineOwner                   _persistence_owner;\n+    MyResourceWriteFilter                      _write_filter;\n+    std::shared_ptr<PersistenceEngine>         _persistence_engine;\n+    storage::spi::Context                      _context;\n+    uint32_t                                   _bucket_bits;\n+    \n+    PersistenceProviderFixture();\n+    ~PersistenceProviderFixture();\n+    void create_document_db();\n+    uint32_t num_buckets() const { return (1u << _bucket_bits); }\n+    Bucket make_bucket(uint32_t i) const { return Bucket(document::Bucket(_bucket_space, BucketId(_bucket_bits, i & (num_buckets() - 1))), PartitionId(0)); }\n+    BucketId get_bucket_id(const Document &document) const {\n+        auto &id = document.getId();\n+        auto &gid = id.getGlobalId();\n+        return BucketId(_bucket_bits, gid.convertToBucketId().getRawId()).stripUnused();", "originalCommit": "2a57cdfd2e7e24432cf9b0993b9e10dc77f86100", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}