{"pr_number": 15325, "pr_title": "added spin lock with test", "pr_createdAt": "2020-11-12T16:33:20Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/15325", "timeline": [{"oid": "b6268ea791bc989679227facbf528cc98f096ff4", "url": "https://github.com/vespa-engine/vespa/commit/b6268ea791bc989679227facbf528cc98f096ff4", "message": "added spin lock with test\n\nThe micro-benchmark shows promise (run test manually with 'verbose' as\nparameter). It indicates that taking and releasing the spin lock from\na single thread is cheaper than doing the same with a normal mutex (as\nexpected based on previous tests). However, it also indicates that it\nis competitive with a normal mutex for short critical sections with\nmultiple threads involved. (on my laptop, only the cases using more\nthreads than cores run faster with a normal mutex, which is a better\nresult than expected).", "committedDate": "2020-11-12T16:17:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2ODI3NA==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522268274", "bodyText": "SpinLock -> std::mutex", "author": "arnej27959", "createdAt": "2020-11-12T17:05:51Z", "path": "vespalib/src/tests/spin_lock/spin_lock_test.cpp", "diffHunk": "@@ -0,0 +1,174 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/util/spin_lock.h>\n+#include <vespa/vespalib/util/benchmark_timer.h>\n+#include <vespa/vespalib/util/time.h>\n+#include <vespa/vespalib/testkit/test_kit.h>\n+\n+using namespace vespalib;\n+\n+bool verbose = false;\n+double budget = 0.25;\n+size_t thread_safety_work = 1000000;\n+\n+struct DummyLock {\n+    void lock() {}\n+    void unlock() {}\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+struct MyState {\n+    static constexpr size_t SZ = 5;\n+    std::array<size_t,SZ> state = {0,0,0,0,0};\n+    void update() {\n+        std::array<size_t,SZ> tmp;\n+        for (size_t i = 0; i < SZ; ++i) {\n+            tmp[i] = state[i];\n+        }\n+        for (size_t i = 0; i < SZ; ++i) {\n+            state[i] = tmp[i] + 1;\n+        }\n+    }\n+    bool check(size_t expect) const {\n+        for (size_t value: state) {\n+            if (value != expect) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    void report(size_t expect, const char *name) const {\n+        if (check(expect)) {\n+            fprintf(stderr, \"%s is thread safe\\n\", name);\n+        } else {\n+            fprintf(stderr, \"%s is not thread safe\\n\", name);\n+            fprintf(stderr, \"    expected %zu, got [%zu,%zu,%zu,%zu,%zu]\\n\",\n+                    expect, state[0], state[1], state[2], state[3], state[4]);\n+        }\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename T> void  basic_usage() {\n+    T lock;\n+    {\n+        std::lock_guard guard(lock);\n+    }\n+    {\n+        std::unique_lock guard(lock);\n+    }\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename T> size_t thread_safety_loop(T &lock, MyState &state, size_t thread_id, size_t thread_limit) {\n+    size_t loop_cnt = (thread_safety_work / thread_limit);\n+    TEST_BARRIER();\n+    auto t0 = steady_clock::now();\n+    TEST_BARRIER();\n+    if (thread_id < thread_limit) {\n+        for (size_t i = 0; i < loop_cnt; ++i) {\n+            std::lock_guard guard(lock);\n+            state.update();\n+        }\n+    }\n+    auto t1 = steady_clock::now();\n+    TEST_BARRIER();\n+    if (thread_id == 0) {\n+        auto t2 = steady_clock::now();\n+        size_t total_ms = count_ms(t2 - t0);\n+        fprintf(stderr, \"---> thread_safety_loop with %zu threads used %zu ms\\n\", thread_limit, total_ms);\n+    }\n+    TEST_BARRIER();\n+    if (verbose && (thread_id < thread_limit)) {\n+        size_t local_ms = count_ms(t1 - t0);\n+        fprintf(stderr, \"    -- thread %zu used %zu ms\\n\", thread_id, local_ms);\n+    }\n+    TEST_BARRIER();\n+    return (loop_cnt * thread_limit);\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename T> void estimate_cost(const char *name) __attribute__((noinline));\n+template <typename T> void estimate_cost(const char *name) {\n+    T lock;\n+    auto lock_loop = [&]()\n+                     {\n+                         // 250 * 4 = 1000 times lock/unlock\n+                         for (size_t i = 0; i < 250; ++i) {\n+                             // 4 times lock/unlock\n+                             lock.lock();\n+                             lock.unlock();\n+                             lock.lock();\n+                             lock.unlock();\n+                             lock.lock();\n+                             lock.unlock();\n+                             lock.lock();\n+                             lock.unlock();\n+                         }\n+                     };\n+    BenchmarkTimer timer(budget);\n+    while (timer.has_budget()) {\n+        timer.before();\n+        lock_loop();\n+        timer.after();\n+    }\n+    auto cost_ns = timer.min_time() * 1000.0 * 1000.0;\n+    fprintf(stderr, \"%s: estimated lock/unlock time: %g ns\\n\", name, cost_ns);\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+TEST(\"require that locks can be used with lock_guard and unique_lock\") {\n+    TEST_DO(basic_usage<DummyLock>());\n+    TEST_DO(basic_usage<SpinLock>());\n+}\n+\n+TEST_MT_FF(\"report whether DummyLock is thread safe\", 24, DummyLock(), MyState()) {\n+    size_t expect = thread_safety_loop(f1, f2, thread_id, 24);\n+    if (thread_id == 0) {\n+        f2.report(expect, \"DummyLock\");\n+    }\n+}\n+\n+TEST_MT_FF(\"require that SpinLock is thread safe\", 24, SpinLock(), MyState()) {\n+    size_t expect = thread_safety_loop(f1, f2, thread_id, 24);\n+    expect += thread_safety_loop(f1, f2, thread_id, 12);\n+    expect += thread_safety_loop(f1, f2, thread_id, 6);\n+    expect += thread_safety_loop(f1, f2, thread_id, 3);\n+    if (thread_id == 0) {\n+        f2.report(expect, \"SpinLock\");\n+        EXPECT_TRUE(f2.check(expect));\n+    }\n+}\n+\n+TEST_MT_FF(\"require that SpinLock is thread safe\", 24, std::mutex(), MyState()) {", "originalCommit": "b6268ea791bc989679227facbf528cc98f096ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyODUxMw==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522828513", "bodyText": "fixed", "author": "havardpe", "createdAt": "2020-11-13T09:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2ODI3NA=="}], "type": "inlineReview"}, {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d", "url": "https://github.com/vespa-engine/vespa/commit/5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d", "message": "fix typo", "committedDate": "2020-11-13T08:52:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgxNDg1Mg==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522814852", "bodyText": "Note that the spin lock does not provide priority inheritance, a low priority thread preempted while holding the spin lock can cause excessive spinning in a high priority thread if the system has few (e.g. a single) cpu cores.", "author": "toregge", "createdAt": "2020-11-13T09:02:54Z", "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.", "originalCommit": "b6268ea791bc989679227facbf528cc98f096ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyODQzMQ==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522828431", "bodyText": "added more warnings to the comment", "author": "havardpe", "createdAt": "2020-11-13T09:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgxNDg1Mg=="}], "type": "inlineReview"}, {"oid": "7201a4f8b2e54686f6898998fc5b9c9962f3f20e", "url": "https://github.com/vespa-engine/vespa/commit/7201a4f8b2e54686f6898998fc5b9c9962f3f20e", "message": "add more warnings", "committedDate": "2020-11-13T09:25:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMTUwNw==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522821507", "bodyText": "Could consider using std::atomic_flag here. It has a simpler interface than std::atomic but is the only atomic type guaranteed to be lock free (that means the static_assert below could be removed). The inner relaxed load loop seems to require a C++20 addition for it, so hopefully we have it..!", "author": "vekterli", "createdAt": "2020-11-13T09:15:23Z", "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;", "originalCommit": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzNDEyNw==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522834127", "bodyText": "I switched from atomic_flag to atomic_bool because I want to be able to read the variable without writing it to avoid totally messing up the cache. I do not think gcc is C++20 ready just yet, at least I do not think we have enabled it. It is highly unlikely that we want to run Vespa on a system that does not support atomic bool anyway.", "author": "havardpe", "createdAt": "2020-11-13T09:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMTUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzNjg0OQ==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522836849", "bodyText": "Yeah, strangely being able to do test(std::memory_order_relaxed) is very recent. Reading variables is cutting edge technology", "author": "vekterli", "createdAt": "2020-11-13T09:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMTUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMzUzNA==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522823534", "bodyText": "_mm_pause may be more portable, but I believe it requires xmmintrin.h so if used maybe it should be wrapped away in its own translation unit to avoid header pollution.", "author": "vekterli", "createdAt": "2020-11-13T09:19:16Z", "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {\n+            while (_lock.load(std::memory_order_relaxed)) {\n+                __builtin_ia32_pause();                ", "originalCommit": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzNzkwMw==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522837903", "bodyText": "I could not figure out the subtle differences between _mm_pause and __builtin_ia32_pause across compilers, but concluded that if __builtin_ia32_pause is supported, it generates the appropriate code. I will let @toregge sink into this when he tries to compile Vespa on other platforms.", "author": "havardpe", "createdAt": "2020-11-13T09:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMzUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyNDQ0OQ==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522824449", "bodyText": "Are we on a new and cool\u2122 enough version of GCC to be able to use the C++20 [[likely]] attribute?", "author": "vekterli", "createdAt": "2020-11-13T09:20:51Z", "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {", "originalCommit": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzODc0MA==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522838740", "bodyText": "I am not sure, I thought C++20 was off the table for now, but I might be wrong... @baldersheim ?", "author": "havardpe", "createdAt": "2020-11-13T09:46:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyNDQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0Mjg1OQ==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522842859", "bodyText": "We are on 9 still, but could try to enable c++20 if it has support for it.", "author": "baldersheim", "createdAt": "2020-11-13T09:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyNDQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1MjA2Mw==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522852063", "bodyText": "I could not find it on the list: (maybe it has some cool name)\nhttps://gcc.gnu.org/projects/cxx-status.html\nBut it does seem some C++20 features are available in gcc 9 (although experimental). We might want to wait until it is called 20 and not 2a...", "author": "havardpe", "createdAt": "2020-11-13T10:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyNDQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzMzQ1OQ==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522833459", "bodyText": "Have you compared this to using yield ?", "author": "baldersheim", "createdAt": "2020-11-13T09:37:13Z", "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,42 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * Note that multiple threads trying to obtain the lock at the same\n+ * time will reduce performance due to atomic writes against the same\n+ * cache line.\n+ *\n+ * Note that being preempted while holding the lock will reduce\n+ * performance, even more if the thread holding the lock is lower\n+ * priority than the threads trying to obtain the lock. With a\n+ * deterministic scheduler this could even lead to deadlock.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {\n+            while (_lock.load(std::memory_order_relaxed)) {\n+                __builtin_ia32_pause();                ", "originalCommit": "7201a4f8b2e54686f6898998fc5b9c9962f3f20e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0MTc3NA==", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522841774", "bodyText": "turns out yield is much better than pause in all tested cases, I will switch. This also fixes portability; double win", "author": "havardpe", "createdAt": "2020-11-13T09:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzMzQ1OQ=="}], "type": "inlineReview"}, {"oid": "76f13a1c63f2a35fbf90190679c79f1c169f6f10", "url": "https://github.com/vespa-engine/vespa/commit/76f13a1c63f2a35fbf90190679c79f1c169f6f10", "message": "use yield instead of pause", "committedDate": "2020-11-13T09:53:28Z", "type": "commit"}]}