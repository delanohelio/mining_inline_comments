{"pr_number": 15559, "pr_title": "ensure all cases can test with factory", "pr_createdAt": "2020-12-01T11:41:23Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/15559", "timeline": [{"oid": "c85fa192079701624b2f763a61bb17821fa7594a", "url": "https://github.com/vespa-engine/vespa/commit/c85fa192079701624b2f763a61bb17821fa7594a", "message": "ensure all cases can test with factory", "committedDate": "2020-12-01T11:35:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjAzOA==", "url": "https://github.com/vespa-engine/vespa/pull/15559#discussion_r533382038", "bodyText": "use TensorSpec::from_expr here", "author": "havardpe", "createdAt": "2020-12-01T12:47:33Z", "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "diffHunk": "@@ -77,14 +78,14 @@ void verify_impl(const vespalib::string &expr, const vespalib::string &expect) {\n     verify_impl<T>(expr, expect, [](const T*){});\n }\n \n-void verify_generic(const vespalib::string &expr, const vespalib::string &expect,\n-                    EvalMode expect_eval_mode)\n-{\n-    verify_impl<DenseLambdaFunction>(expr, expect,\n-                                     [&](const DenseLambdaFunction *info)\n-                                     {\n-                                         EXPECT_EQUAL(info->eval_mode(), expect_eval_mode);\n-                                     });\n+void verify_not_optimized(const vespalib::string &expr, const vespalib::string &expect) {\n+    EvalFixture fixture(prod_factory, expr, param_repo, true);\n+    EvalFixture simple_factory_fixture(simple_factory, expr, param_repo, false);\n+    EXPECT_EQUAL(fixture.result(), simple_factory_fixture.result());\n+    EXPECT_EQUAL(fixture.result(), EvalFixture::ref(expr, param_repo));\n+    EXPECT_EQUAL(fixture.result(), EvalFixture::ref(expect, param_repo));", "originalCommit": "c85fa192079701624b2f763a61bb17821fa7594a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxOTUwOQ==", "url": "https://github.com/vespa-engine/vespa/pull/15559#discussion_r533419509", "bodyText": "some of the \"expect\" expressions reference the param_repo, so that didn't work.", "author": "arnej27959", "createdAt": "2020-12-01T13:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4Mjg1NQ==", "url": "https://github.com/vespa-engine/vespa/pull/15559#discussion_r533382855", "bodyText": "I like the verify_generic name better here", "author": "havardpe", "createdAt": "2020-12-01T12:49:04Z", "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "diffHunk": "@@ -77,14 +78,14 @@ void verify_impl(const vespalib::string &expr, const vespalib::string &expect) {\n     verify_impl<T>(expr, expect, [](const T*){});\n }\n \n-void verify_generic(const vespalib::string &expr, const vespalib::string &expect,\n-                    EvalMode expect_eval_mode)\n-{\n-    verify_impl<DenseLambdaFunction>(expr, expect,\n-                                     [&](const DenseLambdaFunction *info)\n-                                     {\n-                                         EXPECT_EQUAL(info->eval_mode(), expect_eval_mode);\n-                                     });\n+void verify_not_optimized(const vespalib::string &expr, const vespalib::string &expect) {", "originalCommit": "c85fa192079701624b2f763a61bb17821fa7594a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxOTY0OA==", "url": "https://github.com/vespa-engine/vespa/pull/15559#discussion_r533419648", "bodyText": "done.", "author": "arnej27959", "createdAt": "2020-12-01T13:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4Mjg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzAwNA==", "url": "https://github.com/vespa-engine/vespa/pull/15559#discussion_r533383004", "bodyText": "feel free to just remove this now", "author": "havardpe", "createdAt": "2020-12-01T12:49:19Z", "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "diffHunk": "@@ -184,13 +157,92 @@ TEST(\"require that non-continuous cell extraction is optimized\") {\n     TEST_DO(verify_idx_fun(\"tensor<float>(x[3])(x3y5f{x:(x),y:2})\", \"x3y5f{y:2}\", \"f(x)((floor(x)*5)+2)\"));\n }\n \n+TEST(\"require that simple dynamic tensor lambda works\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x+a)\", \"tensor(x[3]):[1,2,3]\"));\n+}\n+\n+TEST(\"require that compiled multi-dimensional multi-param dynamic tensor lambda works\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3],y[2])((b-a)+x+y)\", \"tensor(x[3],y[2]):[[1,2],[2,3],[3,4]]\"));\n+    TEST_DO(verify_not_optimized(\"tensor<float>(x[3],y[2])((b-a)+x+y)\", \"tensor<float>(x[3],y[2]):[[1,2],[2,3],[3,4]]\"));\n+}\n+\n+TEST(\"require that interpreted multi-dimensional multi-param dynamic tensor lambda works\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3],y[2])((x3{x:(a)}-a)+x+y)\", \"tensor(x[3],y[2]):[[1,2],[2,3],[3,4]]\"));\n+    TEST_DO(verify_not_optimized(\"tensor<float>(x[3],y[2])((x3{x:(a)}-a)+x+y)\", \"tensor<float>(x[3],y[2]):[[1,2],[2,3],[3,4]]\"));\n+}\n+\n+TEST(\"require that tensor lambda can be used for tensor slicing\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[2])(x3{x:(x+a)})\", \"tensor(x[2]):[2,3]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[2])(a+x3{x:(x)})\", \"tensor(x[2]):[2,3]\"));\n+}\n+\n+TEST(\"require that tensor lambda can be used to convert from sparse to dense tensors\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3m{x:(x)})\", \"tensor(x[3]):[1,2,3]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[2])(x3m{x:(x)})\", \"tensor(x[2]):[1,2]\"));\n+}\n+\n+TEST(\"require that dynamic nested tensor lambda using tensor peek works\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[2])(tensor(y[2])((x+y)+a){y:(x)})\", \"tensor(x[2]):[1,3]\"));\n+}\n+\n+TEST(\"require that out-of-bounds cell extraction is not optimized\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3y5{x:1,y:(x+3)})\", \"tensor(x[3]):[9,10,0]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3y5{x:1,y:(x-1)})\", \"tensor(x[3]):[0,6,7]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3y5{x:(x+1),y:(x)})\", \"tensor(x[3]):[6,12,0]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3y5{x:(x-1),y:(x)})\", \"tensor(x[3]):[0,2,8]\"));\n+}\n+\n+//---------------------------------------------------------------------------\n+// to be removed when DefaultTensorEngine is removed:", "originalCommit": "c85fa192079701624b2f763a61bb17821fa7594a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxOTc2NQ==", "url": "https://github.com/vespa-engine/vespa/pull/15559#discussion_r533419765", "bodyText": "done.", "author": "arnej27959", "createdAt": "2020-12-01T13:49:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzAwNA=="}], "type": "inlineReview"}, {"oid": "3e9bb253be74a9a4498743ff8780ecc349373dcf", "url": "https://github.com/vespa-engine/vespa/commit/3e9bb253be74a9a4498743ff8780ecc349373dcf", "message": "remove engine testing", "committedDate": "2020-12-01T13:44:41Z", "type": "commit"}, {"oid": "4441a93d58cee52335a67e9f82b77cf7dcd9bd81", "url": "https://github.com/vespa-engine/vespa/commit/4441a93d58cee52335a67e9f82b77cf7dcd9bd81", "message": "avoid using namespace vespalib::tensor", "committedDate": "2020-12-01T13:46:26Z", "type": "commit"}, {"oid": "3a06af2324933b1c40d85077e0dd28847e469d96", "url": "https://github.com/vespa-engine/vespa/commit/3a06af2324933b1c40d85077e0dd28847e469d96", "message": "verify_not_optimized -> verify_generic", "committedDate": "2020-12-01T13:47:43Z", "type": "commit"}]}