{"pr_number": 13653, "pr_title": "Tgm/application package", "pr_createdAt": "2020-06-22T07:33:16Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/13653", "timeline": [{"oid": "91f7960dc0185db7e6a59d113187a9f7c20ddbcb", "url": "https://github.com/vespa-engine/vespa/commit/91f7960dc0185db7e6a59d113187a9f7c20ddbcb", "message": "include application package page", "committedDate": "2020-06-22T07:12:43Z", "type": "commit"}, {"oid": "3e7a2f2ebfc0d7a84706145f32d5b375d9f7e15b", "url": "https://github.com/vespa-engine/vespa/commit/3e7a2f2ebfc0d7a84706145f32d5b375d9f7e15b", "message": "include docker library dependency", "committedDate": "2020-06-22T07:12:59Z", "type": "commit"}, {"oid": "2f738a456d43288b033ab69463dbf6d66b1426d5", "url": "https://github.com/vespa-engine/vespa/commit/2f738a456d43288b033ab69463dbf6d66b1426d5", "message": "include ApplicationPackage code", "committedDate": "2020-06-22T07:13:52Z", "type": "commit"}, {"oid": "fd6b49e6c3a396b201fb0505181e840f323970ea", "url": "https://github.com/vespa-engine/vespa/commit/fd6b49e6c3a396b201fb0505181e840f323970ea", "message": "add class for serialization", "committedDate": "2020-06-25T13:15:13Z", "type": "commit"}, {"oid": "0702e5fba074ebd9bf0033acba60c35aa07b33c3", "url": "https://github.com/vespa-engine/vespa/commit/0702e5fba074ebd9bf0033acba60c35aa07b33c3", "message": "add code to deploy locally and start to implement the api to create application package", "committedDate": "2020-06-25T13:16:15Z", "type": "commit"}, {"oid": "492a2a614d59c3eed7eeaf4118e805421e2cfaa6", "url": "https://github.com/vespa-engine/vespa/commit/492a2a614d59c3eed7eeaf4118e805421e2cfaa6", "message": "start to unit test the code to create application package", "committedDate": "2020-06-25T13:16:39Z", "type": "commit"}, {"oid": "9a210d61d3be04397c814795f292d755d28d4017", "url": "https://github.com/vespa-engine/vespa/commit/9a210d61d3be04397c814795f292d755d28d4017", "message": "implement document and field set", "committedDate": "2020-06-27T20:49:33Z", "type": "commit"}, {"oid": "c51c4daace20e42d9bdc5fda2c62bc117c4bf392", "url": "https://github.com/vespa-engine/vespa/commit/c51c4daace20e42d9bdc5fda2c62bc117c4bf392", "message": "implement rank profile and schema", "committedDate": "2020-06-29T12:22:31Z", "type": "commit"}, {"oid": "2800e149a2cdcb3ec90ed6725ccbddc9ee5bdd4a", "url": "https://github.com/vespa-engine/vespa/commit/2800e149a2cdcb3ec90ed6725ccbddc9ee5bdd4a", "message": "add jinja 2 dependency", "committedDate": "2020-07-02T10:42:47Z", "type": "commit"}, {"oid": "08db10b5950570373dd13851bebedae0f76f95dc", "url": "https://github.com/vespa-engine/vespa/commit/08db10b5950570373dd13851bebedae0f76f95dc", "message": "add application package serialization code", "committedDate": "2020-07-02T10:43:29Z", "type": "commit"}, {"oid": "49edbc6ebb6baac6eb1c402b6bcbec5136d95092", "url": "https://github.com/vespa-engine/vespa/commit/49edbc6ebb6baac6eb1c402b6bcbec5136d95092", "message": "schema template", "committedDate": "2020-07-02T10:43:40Z", "type": "commit"}, {"oid": "ddd7cd7c804261993f04d8a4cabe5720f5cec605", "url": "https://github.com/vespa-engine/vespa/commit/ddd7cd7c804261993f04d8a4cabe5720f5cec605", "message": "add hosts and services template", "committedDate": "2020-07-02T12:39:24Z", "type": "commit"}, {"oid": "1409de59e3b549424c7226c622e2b31a271e276a", "url": "https://github.com/vespa-engine/vespa/commit/1409de59e3b549424c7226c622e2b31a271e276a", "message": "hosts and services template files", "committedDate": "2020-07-02T12:39:46Z", "type": "commit"}, {"oid": "018520297d97b9573aeaf482b133abf98c86a0eb", "url": "https://github.com/vespa-engine/vespa/commit/018520297d97b9573aeaf482b133abf98c86a0eb", "message": "write application files before local deployment", "committedDate": "2020-07-02T20:18:28Z", "type": "commit"}, {"oid": "ff656a5b6a9eaf0314731cafbd16e9069302820b", "url": "https://github.com/vespa-engine/vespa/commit/ff656a5b6a9eaf0314731cafbd16e9069302820b", "message": "application package notebook", "committedDate": "2020-07-03T07:13:32Z", "type": "commit"}, {"oid": "51f219bc4ddb0d9999bff9fcc7738db275298b0c", "url": "https://github.com/vespa-engine/vespa/commit/51f219bc4ddb0d9999bff9fcc7738db275298b0c", "message": "update disk path", "committedDate": "2020-07-03T07:18:59Z", "type": "commit"}, {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "url": "https://github.com/vespa-engine/vespa/commit/8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "message": "set deploy code to text", "committedDate": "2020-07-03T07:36:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4OTg3MA==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450089870", "bodyText": "I think list() here is redundant.", "author": "oyving", "createdAt": "2020-07-06T09:13:51Z", "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))", "originalCommit": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MjM0Ng==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450092346", "bodyText": "I would avoid \\n in __repr__. It's better to have it on one line. __repr__ should attempt to look like a Python expressions while __str__ is for informal string representation. See https://docs.python.org/3/reference/datamodel.html#object.__repr__.", "author": "oyving", "createdAt": "2020-07-06T09:18:07Z", "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "originalCommit": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MjY3OQ==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450092679", "bodyText": "See __repr__ comment below.", "author": "oyving", "createdAt": "2020-07-06T09:18:43Z", "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "originalCommit": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MjgwMg==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450092802", "bodyText": "See __repr__ comment above.", "author": "oyving", "createdAt": "2020-07-06T09:18:57Z", "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "originalCommit": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5NTcwMQ==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450095701", "bodyText": "Just a different style, it might not be more clear: self.fields = [] if not fields else fields.", "author": "oyving", "createdAt": "2020-07-06T09:24:13Z", "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields", "originalCommit": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5NjYyMw==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450096623", "bodyText": "See __repr__ above.", "author": "oyving", "createdAt": "2020-07-06T09:25:47Z", "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "originalCommit": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5NzgzNA==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450097834", "bodyText": "Why .update() instead of just self.rank_profiles[rank_profile.name] = rank_profile?", "author": "oyving", "createdAt": "2020-07-06T09:27:54Z", "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Schema(ToJson, FromJson[\"Schema\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        document: Document,\n+        fieldsets: Optional[List[FieldSet]] = None,\n+        rank_profiles: Optional[List[RankProfile]] = None,\n+    ) -> None:\n+        \"\"\"\n+        Create a Vespa Schema.\n+\n+        :param name: Schema name.\n+        :param document: Vespa document associated with the Schema.\n+        :param fieldsets: A list of `FieldSet` associated with the Schema.\n+        :param rank_profiles: A list of `RankProfile` associated with the Schema.\n+        \"\"\"\n+        self.name = name\n+        self.document = document\n+\n+        self.fieldsets = {}\n+        if fieldsets is not None:\n+            self.fieldsets = {fieldset.name: fieldset for fieldset in fieldsets}\n+\n+        self.rank_profiles = {}\n+        if rank_profiles is not None:\n+            self.rank_profiles = {\n+                rank_profile.name: rank_profile for rank_profile in rank_profiles\n+            }\n+\n+    def add_rank_profile(self, rank_profile: RankProfile) -> None:\n+        \"\"\"\n+        Add a `RankProfile` to the `Schema`.\n+        :param rank_profile: `RankProfile` to be added.\n+        :return: None.\n+        \"\"\"\n+        self.rank_profiles.update({rank_profile.name: rank_profile})", "originalCommit": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5ODAyMw==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450098023", "bodyText": "See __repr__ above.", "author": "oyving", "createdAt": "2020-07-06T09:28:14Z", "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Schema(ToJson, FromJson[\"Schema\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        document: Document,\n+        fieldsets: Optional[List[FieldSet]] = None,\n+        rank_profiles: Optional[List[RankProfile]] = None,\n+    ) -> None:\n+        \"\"\"\n+        Create a Vespa Schema.\n+\n+        :param name: Schema name.\n+        :param document: Vespa document associated with the Schema.\n+        :param fieldsets: A list of `FieldSet` associated with the Schema.\n+        :param rank_profiles: A list of `RankProfile` associated with the Schema.\n+        \"\"\"\n+        self.name = name\n+        self.document = document\n+\n+        self.fieldsets = {}\n+        if fieldsets is not None:\n+            self.fieldsets = {fieldset.name: fieldset for fieldset in fieldsets}\n+\n+        self.rank_profiles = {}\n+        if rank_profiles is not None:\n+            self.rank_profiles = {\n+                rank_profile.name: rank_profile for rank_profile in rank_profiles\n+            }\n+\n+    def add_rank_profile(self, rank_profile: RankProfile) -> None:\n+        \"\"\"\n+        Add a `RankProfile` to the `Schema`.\n+        :param rank_profile: `RankProfile` to be added.\n+        :return: None.\n+        \"\"\"\n+        self.rank_profiles.update({rank_profile.name: rank_profile})\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Schema\":\n+        return Schema(\n+            name=mapping[\"name\"],\n+            document=FromJson.map(mapping[\"document\"]),\n+            fieldsets=[FromJson.map(fieldset) for fieldset in mapping[\"fieldsets\"]],\n+            rank_profiles=[\n+                FromJson.map(rank_profile) for rank_profile in mapping[\"rank_profiles\"]\n+            ],\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\n+            \"name\": self.name,\n+            \"document\": self.document.to_envelope,\n+            \"fieldsets\": [\n+                self.fieldsets[name].to_envelope for name in self.fieldsets.keys()\n+            ],\n+            \"rank_profiles\": [\n+                self.rank_profiles[name].to_envelope\n+                for name in self.rank_profiles.keys()\n+            ],\n+        }\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.document == other.document\n+            and self.fieldsets == other.fieldsets\n+            and self.rank_profiles == other.rank_profiles\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "originalCommit": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5OTczNA==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450099734", "bodyText": "There are a few methods in this class that related to running the application. I would pull those out into a separate class or just have them as regular functions outside a class. Then it would be easier to have VespaCloud.run(app) and VespaDocker.run(app) and ApplicationPackage just becomes a data container.", "author": "oyving", "createdAt": "2020-07-06T09:31:13Z", "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Schema(ToJson, FromJson[\"Schema\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        document: Document,\n+        fieldsets: Optional[List[FieldSet]] = None,\n+        rank_profiles: Optional[List[RankProfile]] = None,\n+    ) -> None:\n+        \"\"\"\n+        Create a Vespa Schema.\n+\n+        :param name: Schema name.\n+        :param document: Vespa document associated with the Schema.\n+        :param fieldsets: A list of `FieldSet` associated with the Schema.\n+        :param rank_profiles: A list of `RankProfile` associated with the Schema.\n+        \"\"\"\n+        self.name = name\n+        self.document = document\n+\n+        self.fieldsets = {}\n+        if fieldsets is not None:\n+            self.fieldsets = {fieldset.name: fieldset for fieldset in fieldsets}\n+\n+        self.rank_profiles = {}\n+        if rank_profiles is not None:\n+            self.rank_profiles = {\n+                rank_profile.name: rank_profile for rank_profile in rank_profiles\n+            }\n+\n+    def add_rank_profile(self, rank_profile: RankProfile) -> None:\n+        \"\"\"\n+        Add a `RankProfile` to the `Schema`.\n+        :param rank_profile: `RankProfile` to be added.\n+        :return: None.\n+        \"\"\"\n+        self.rank_profiles.update({rank_profile.name: rank_profile})\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Schema\":\n+        return Schema(\n+            name=mapping[\"name\"],\n+            document=FromJson.map(mapping[\"document\"]),\n+            fieldsets=[FromJson.map(fieldset) for fieldset in mapping[\"fieldsets\"]],\n+            rank_profiles=[\n+                FromJson.map(rank_profile) for rank_profile in mapping[\"rank_profiles\"]\n+            ],\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\n+            \"name\": self.name,\n+            \"document\": self.document.to_envelope,\n+            \"fieldsets\": [\n+                self.fieldsets[name].to_envelope for name in self.fieldsets.keys()\n+            ],\n+            \"rank_profiles\": [\n+                self.rank_profiles[name].to_envelope\n+                for name in self.rank_profiles.keys()\n+            ],\n+        }\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.document == other.document\n+            and self.fieldsets == other.fieldsets\n+            and self.rank_profiles == other.rank_profiles\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class ApplicationPackage(ToJson, FromJson[\"ApplicationPackage\"]):", "originalCommit": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcyMzMwMg==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450723302", "bodyText": "Good point.", "author": "thigm85", "createdAt": "2020-07-07T09:15:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5OTczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEwMzg4Mw==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450103883", "bodyText": "I don't think this is necessary. The indexing docproc cluster is implicitly there.", "author": "oyving", "createdAt": "2020-07-06T09:39:00Z", "path": "python/vespa/vespa/templates/services.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<services version=\"1.0\">\n+    <container id=\"{{ application_name }}_container\" version=\"1.0\">\n+        <search></search>\n+        <document-processing></document-processing>\n+        <document-api></document-api>\n+    </container>\n+    <content id=\"{{ application_name }}_content\" version=\"1.0\">\n+        <redundancy reply-after=\"1\">1</redundancy>\n+        <documents>\n+            <document type=\"{{ document_name }}\" mode=\"index\"></document>\n+            <document-processing cluster=\"{{ application_name }}_container\"></document-processing>", "originalCommit": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEwNDAzNw==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450104037", "bodyText": "Unless you are adding document processors, you don't need this either.", "author": "oyving", "createdAt": "2020-07-06T09:39:16Z", "path": "python/vespa/vespa/templates/services.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<services version=\"1.0\">\n+    <container id=\"{{ application_name }}_container\" version=\"1.0\">\n+        <search></search>\n+        <document-processing></document-processing>", "originalCommit": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e9eecc937cdc2dc4925904c1f0e986efcb016269", "url": "https://github.com/vespa-engine/vespa/commit/e9eecc937cdc2dc4925904c1f0e986efcb016269", "message": "remove redundant list", "committedDate": "2020-07-07T08:20:05Z", "type": "commit"}, {"oid": "ab41b91f89a450e657bd1a14592bb9c17333fbfb", "url": "https://github.com/vespa-engine/vespa/commit/ab41b91f89a450e657bd1a14592bb9c17333fbfb", "message": "more compact expression", "committedDate": "2020-07-07T08:27:09Z", "type": "commit"}, {"oid": "b7c5ab66c1ef1fb38d321848627e66954ac5c64a", "url": "https://github.com/vespa-engine/vespa/commit/b7c5ab66c1ef1fb38d321848627e66954ac5c64a", "message": "remove unnecessary update", "committedDate": "2020-07-07T08:28:49Z", "type": "commit"}, {"oid": "b4825ad2f4f874f4675b35c86c19ca4bf96ff241", "url": "https://github.com/vespa-engine/vespa/commit/b4825ad2f4f874f4675b35c86c19ca4bf96ff241", "message": "refactor __repr__ as a python expression", "committedDate": "2020-07-07T08:52:53Z", "type": "commit"}, {"oid": "07ccf914050178ad743dbe3d3f3ebb304a28deb8", "url": "https://github.com/vespa-engine/vespa/commit/07ccf914050178ad743dbe3d3f3ebb304a28deb8", "message": "Create VespaDocker class to encapsulate docker deployment code.", "committedDate": "2020-07-07T09:13:49Z", "type": "commit"}, {"oid": "cd671e9aabad05ba83277182f2721af689ef1a45", "url": "https://github.com/vespa-engine/vespa/commit/cd671e9aabad05ba83277182f2721af689ef1a45", "message": "update application package notebook", "committedDate": "2020-07-07T09:14:47Z", "type": "commit"}, {"oid": "f5bc1f9dfffecc55fd89053117ac4c4d067c89f9", "url": "https://github.com/vespa-engine/vespa/commit/f5bc1f9dfffecc55fd89053117ac4c4d067c89f9", "message": "remove unnecessary document-processing tags", "committedDate": "2020-07-07T09:16:49Z", "type": "commit"}, {"oid": "84fa57da76f6392fc6c1873e68f9076cd8b155f9", "url": "https://github.com/vespa-engine/vespa/commit/84fa57da76f6392fc6c1873e68f9076cd8b155f9", "message": "fix unit test", "committedDate": "2020-07-07T09:19:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3ODE0OA==", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450778148", "bodyText": "You should probably call repr() on these.", "author": "oyving", "createdAt": "2020-07-07T10:54:11Z", "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -65,7 +65,13 @@ def __eq__(self, other):\n         )\n \n     def __repr__(self):\n-        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+        return \"{0}({1}, {2}, {3}, {4})\".format(\n+            self.__class__.__name__,\n+            str(self.name),", "originalCommit": "b4825ad2f4f874f4675b35c86c19ca4bf96ff241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b77cd04441b47a479386b5337f1699c2ec98870b", "url": "https://github.com/vespa-engine/vespa/commit/b77cd04441b47a479386b5337f1699c2ec98870b", "message": "used repr on the class members", "committedDate": "2020-07-07T11:13:31Z", "type": "commit"}]}