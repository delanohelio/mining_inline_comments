{"pr_number": 15187, "pr_title": "Jonmv/reindexig controller", "pr_createdAt": "2020-11-05T11:35:49Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/15187", "timeline": [{"oid": "97ebd0f758659d00ceef13d0eb71ce0899dfbd9e", "url": "https://github.com/vespa-engine/vespa/commit/97ebd0f758659d00ceef13d0eb71ce0899dfbd9e", "message": "Properly handle interruption while destroying MessageBusVisitorSession", "committedDate": "2020-11-05T08:27:56Z", "type": "commit"}, {"oid": "2679d5fbbe935580607791669844d65c11b568f6", "url": "https://github.com/vespa-engine/vespa/commit/2679d5fbbe935580607791669844d65c11b568f6", "message": "Add ReindexingMaintainer and Reindexer", "committedDate": "2020-11-05T11:35:12Z", "type": "commit"}, {"oid": "793896757cb554eb20ea32b3c24aced6515b5c14", "url": "https://github.com/vespa-engine/vespa/commit/793896757cb554eb20ea32b3c24aced6515b5c14", "message": "Clear interrupt status when done with reindexing, before storing result", "committedDate": "2020-11-05T11:47:52Z", "type": "commit"}, {"oid": "b71490c769a7a2660622f1bc162daeecbae29d51", "url": "https://github.com/vespa-engine/vespa/commit/b71490c769a7a2660622f1bc162daeecbae29d51", "message": "Clean up and add some javadoc", "committedDate": "2020-11-05T12:24:40Z", "type": "commit"}, {"oid": "afdeeb2ab52af526a1225547a9ce469c8e7cbabc", "url": "https://github.com/vespa-engine/vespa/commit/afdeeb2ab52af526a1225547a9ce469c8e7cbabc", "message": "Test setup in ReindexingMaintainer", "committedDate": "2020-11-05T16:29:53Z", "type": "commit"}, {"oid": "d41ae481069efb9b8628f928adbf779c445050d0", "url": "https://github.com/vespa-engine/vespa/commit/d41ae481069efb9b8628f928adbf779c445050d0", "message": "Use explicit field set list", "committedDate": "2020-11-05T16:31:10Z", "type": "commit"}, {"oid": "3195e7b15bf99d8400ac22e010ab8ef1a4cebbeb", "url": "https://github.com/vespa-engine/vespa/commit/3195e7b15bf99d8400ac22e010ab8ef1a4cebbeb", "message": "Start with null progress, not a new one, since that is all done for some reason", "committedDate": "2020-11-05T16:31:37Z", "type": "commit"}, {"oid": "7dbefcfae54ae88292f4fb9c9c775b0c92f11680", "url": "https://github.com/vespa-engine/vespa/commit/7dbefcfae54ae88292f4fb9c9c775b0c92f11680", "message": "Dummy support for progress tokens and remote destination in LocalVisitorSession", "committedDate": "2020-11-05T16:32:36Z", "type": "commit"}, {"oid": "af9ff428c8a110612902c4cb2c9c7303e2b668c8", "url": "https://github.com/vespa-engine/vespa/commit/af9ff428c8a110612902c4cb2c9c7303e2b668c8", "message": "Test Reindexer", "committedDate": "2020-11-05T16:32:51Z", "type": "commit"}, {"oid": "392f878cdd4e636b8b20d3188dd20ba16bc3393e", "url": "https://github.com/vespa-engine/vespa/commit/392f878cdd4e636b8b20d3188dd20ba16bc3393e", "message": "Fix assertions", "committedDate": "2020-11-05T16:34:16Z", "type": "commit"}, {"oid": "6ad9ce9460a3d8a3743234960164a14dfa952151", "url": "https://github.com/vespa-engine/vespa/commit/6ad9ce9460a3d8a3743234960164a14dfa952151", "message": "Use fieldSet :[document]", "committedDate": "2020-11-05T19:33:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0Nzc2OA==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518647768", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.\n          \n          \n            \n             * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.", "author": "jonmv", "createdAt": "2020-11-06T10:06:25Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.", "originalCommit": "6ad9ce9460a3d8a3743234960164a14dfa952151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0ODIyNA==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518648224", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.ready = new TreeMap<>(ready);\n          \n          \n            \n                    this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.", "author": "jonmv", "createdAt": "2020-11-06T10:07:16Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready);", "originalCommit": "6ad9ce9460a3d8a3743234960164a14dfa952151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0OTgwNQ==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518649805", "bodyText": "This will intentionally happen for all the things the first time this all rolls out to existing deployments, so no reprocessing will start immediately.", "author": "jonmv", "createdAt": "2020-11-06T10:10:12Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready);\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.", "originalCommit": "6ad9ce9460a3d8a3743234960164a14dfa952151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY1MTU1OA==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518651558", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        case SUCCESSFUL: // Intentional fallthrough \u2014 both are done states.\n          \n          \n            \n                        case SUCCESSFUL: // Intentional fallthrough \u2014 all three are done states.", "author": "jonmv", "createdAt": "2020-11-06T10:13:28Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready);\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n+            case FAILED:\n+                log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n+            case SUCCESSFUL: // Intentional fallthrough \u2014 both are done states.", "originalCommit": "6ad9ce9460a3d8a3743234960164a14dfa952151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY1MzA3OA==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518653078", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            log.log(FINE, () -> \"Aborting reindexing of \" + type + \" due to shutdown \u2014\u00a0will continue later\");\n          \n          \n            \n                            log.log(FINE, () -> \"Halting reindexing of \" + type + \" due to shutdown \u2014\u00a0will continue later\");", "author": "jonmv", "createdAt": "2020-11-06T10:16:19Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready);\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n+            case FAILED:\n+                log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n+            case SUCCESSFUL: // Intentional fallthrough \u2014 both are done states.\n+                return status;\n+            case RUNNING:\n+                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);\n+            case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.\n+        }\n+\n+        // Visit buckets until they're all done, or until we are interrupted.\n+        status = status.running();\n+        VisitorControlHandler control = new VisitorControlHandler();\n+        visit(type, status.progress().orElse(null), control);\n+\n+        // Progress is null if no buckets were successfully visited due to interrupt.\n+        if (control.getProgress() != null)\n+            status = status.progressed(control.getProgress());\n+\n+        // If we were interrupted, the result may not yet be set in the control handler.\n+        CompletionCode code = control.getResult() != null ? control.getResult().getCode() : ABORTED;\n+        switch (code) {\n+            default:\n+                log.log(WARNING, \"Unexpected visitor result '\" + control.getResult().getCode() + \"'\");\n+            case FAILURE: // Intentional fallthrough \u2014\u00a0this is an error.\n+                log.log(WARNING, \"Visiting failed: \" + control.getResult().getMessage());\n+                return status.failed(clock.instant(), control.getResult().getMessage());\n+            case ABORTED:\n+                log.log(FINE, () -> \"Aborting reindexing of \" + type + \" due to shutdown \u2014\u00a0will continue later\");", "originalCommit": "6ad9ce9460a3d8a3743234960164a14dfa952151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY1NDU4OA==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518654588", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.\n          \n          \n            \n                        case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.\n          \n          \n            \n                        log.log(FINE, () -> \"Running reindexing of \" + type + \", which started at \" + status.startedAt());", "author": "jonmv", "createdAt": "2020-11-06T10:19:11Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready);\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n+            case FAILED:\n+                log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n+            case SUCCESSFUL: // Intentional fallthrough \u2014 both are done states.\n+                return status;\n+            case RUNNING:\n+                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);\n+            case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.", "originalCommit": "6ad9ce9460a3d8a3743234960164a14dfa952151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab", "url": "https://github.com/vespa-engine/vespa/commit/cab5c5ae03d0b6bb76f0fbda57e99f6302349bab", "message": "Add some comments, and fine-log when resuming reindexing", "committedDate": "2020-11-06T10:20:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY3NzQ1NQ==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518677455", "bodyText": "I'd prefer if this were called bucketSpaceOf, as \"bucket space\" to \"bucket\" is a bit like \"table\" is to \"tablet\" in e.g. BigTable, i.e. on different levels of abstraction. Consider also renaming other variables to match.", "author": "vekterli", "createdAt": "2020-11-06T10:59:52Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n+            case FAILED:\n+                log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n+            case SUCCESSFUL: // Intentional fallthrough \u2014 all three are done states.\n+                return status;\n+            case RUNNING:\n+                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);\n+            case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.\n+            log.log(FINE, () -> \"Running reindexing of \" + type + \", which started at \" + status.startedAt());\n+        }\n+\n+        // Visit buckets until they're all done, or until we are interrupted.\n+        status = status.running();\n+        VisitorControlHandler control = new VisitorControlHandler();\n+        visit(type, status.progress().orElse(null), control);\n+\n+        // Progress is null if no buckets were successfully visited due to interrupt.\n+        if (control.getProgress() != null)\n+            status = status.progressed(control.getProgress());\n+\n+        // If we were interrupted, the result may not yet be set in the control handler.\n+        CompletionCode code = control.getResult() != null ? control.getResult().getCode() : ABORTED;\n+        switch (code) {\n+            default:\n+                log.log(WARNING, \"Unexpected visitor result '\" + control.getResult().getCode() + \"'\");\n+            case FAILURE: // Intentional fallthrough \u2014\u00a0this is an error.\n+                log.log(WARNING, \"Visiting failed: \" + control.getResult().getMessage());\n+                return status.failed(clock.instant(), control.getResult().getMessage());\n+            case ABORTED:\n+                log.log(FINE, () -> \"Halting reindexing of \" + type + \" due to shutdown \u2014\u00a0will continue later\");\n+                return status.halted();\n+            case SUCCESS:\n+                log.log(INFO, \"Completed reindexing of \" + type + \" after \" + Duration.between(status.startedAt(), clock.instant()));\n+                return status.successful(clock.instant());\n+        }\n+    }\n+\n+    private void visit(DocumentType type, ProgressToken progress, VisitorControlHandler control) {\n+        VisitorParameters parameters = createParameters(type, progress);\n+        parameters.setControlHandler(control);\n+        VisitorSession session;\n+        try {\n+            session = access.createVisitorSession(parameters);\n+        }\n+        catch (ParseException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        // Wait until done, or interrupted, in which case we abort the visit but don't wait for it to complete.\n+        try {\n+            control.waitUntilDone();\n+        }\n+        catch (InterruptedException e) {\n+            control.abort();\n+            Thread.currentThread().interrupt();\n+        }\n+        session.destroy(); // If thread is interrupted, this will not wait, but will retain the interrupted flag.\n+    }\n+\n+    VisitorParameters createParameters(DocumentType type, ProgressToken progress) {\n+        VisitorParameters parameters = new VisitorParameters(type.getName());\n+        parameters.setRemoteDataHandler(cluster.name());\n+        parameters.setResumeToken(progress);\n+        parameters.setFieldSet(type.getName() + \":[document]\");\n+        parameters.setPriority(DocumentProtocol.Priority.LOW_1);\n+        parameters.setRoute(cluster.route());\n+        parameters.setBucketSpace(cluster.bucketOf(type));\n+        // parameters.setVisitorLibrary(\"ReindexVisitor\");\n+        return parameters;\n+    }\n+\n+\n+    static class Cluster {\n+\n+        private final String name;\n+        private final String configId;\n+        private final Map<DocumentType, String> documentBuckets;\n+\n+        Cluster(String name, String configId, Map<DocumentType, String> documentBuckets) {\n+            this.name = requireNonNull(name);\n+            this.configId = requireNonNull(configId);\n+            this.documentBuckets = Map.copyOf(documentBuckets);\n+        }\n+\n+        String name() {\n+            return name;\n+        }\n+\n+        String route() {\n+            return \"[Storage:cluster=\" + name + \";clusterconfigid=\" + configId + \"]\";\n+        }\n+\n+        String bucketOf(DocumentType documentType) {", "originalCommit": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY4MDE2Mw==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518680163", "bodyText": "Yes yes yes. Obviously ;)", "author": "jonmv", "createdAt": "2020-11-06T11:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY3NzQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcwOTg0Ng==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518709846", "bodyText": "This should not be logged as warning", "author": "bjorncs", "createdAt": "2020-11-06T12:06:02Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +", "originalCommit": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg0MzY2NQ==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518843665", "bodyText": "I don't know ... ti shouldn't happen. We only send out config for \"now\", and those \"now\"s should be a little in the past.", "author": "jonmv", "createdAt": "2020-11-06T15:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcwOTg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MjM0Nw==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518872347", "bodyText": "Can go with INFO.", "author": "jonmv", "createdAt": "2020-11-06T16:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcwOTg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcxNzM1Mw==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518717353", "bodyText": "Spelling", "author": "bjorncs", "createdAt": "2020-11-06T12:22:06Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n+            case FAILED:\n+                log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n+            case SUCCESSFUL: // Intentional fallthrough \u2014 all three are done states.\n+                return status;\n+            case RUNNING:\n+                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);", "originalCommit": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MjI5MQ==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518872291", "bodyText": "Thanks.", "author": "jonmv", "createdAt": "2020-11-06T16:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcxNzM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcxNzc0MA==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518717740", "bodyText": "Consider throwing an exception (assuming this is an unexpected behaviour).", "author": "bjorncs", "createdAt": "2020-11-06T12:22:54Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");", "originalCommit": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MTYzMw==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518871633", "bodyText": "It's unexpected, but would like to continue with other document types anyway. Any types before this one would also be processed.", "author": "jonmv", "createdAt": "2020-11-06T16:42:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcxNzc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMDUxOA==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518720518", "bodyText": "Are we leaking Guava types from our curator framework? \ud83e\udd26", "author": "bjorncs", "createdAt": "2020-11-06T12:28:41Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingCurator.java", "diffHunk": "@@ -2,6 +2,7 @@\n package ai.vespa.reindexing;\n \n import ai.vespa.reindexing.Reindexing.Status;\n+import com.google.common.util.concurrent.UncheckedTimeoutException;", "originalCommit": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNzE5OA==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518737198", "bodyText": "Catching these might not even work if bundles disagree on the class instance", "author": "bjorncs", "createdAt": "2020-11-06T13:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMDUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MDYzNQ==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518870635", "bodyText": "How nice. Will make a note to fix it.", "author": "jonmv", "createdAt": "2020-11-06T16:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMDUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMTc2Mw==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518721763", "bodyText": "s/reindexngg/reindexing", "author": "bjorncs", "createdAt": "2020-11-06T12:31:20Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingMaintainer.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexer.Cluster;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.google.inject.Inject;\n+import com.yahoo.cloud.config.ClusterListConfig;\n+import com.yahoo.cloud.config.ZookeepersConfig;\n+import com.yahoo.component.AbstractComponent;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.DocumentTypeManager;\n+import com.yahoo.document.config.DocumentmanagerConfig;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.net.HostName;\n+import com.yahoo.vespa.config.content.AllClustersBucketSpacesConfig;\n+import com.yahoo.vespa.config.content.reindexing.ReindexingConfig;\n+import com.yahoo.vespa.curator.Curator;\n+import com.yahoo.vespa.zookeeper.VespaZooKeeperServer;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiConsumer;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+\n+/**\n+ * Runs in all cluster controller containers, and progresses reindexngg efforts.", "originalCommit": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MDMyNQ==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518870325", "bodyText": "Thanks", "author": "jonmv", "createdAt": "2020-11-06T16:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMTc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMjUyNQ==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518722525", "bodyText": "Consider adding debug-logging when this happens", "author": "bjorncs", "createdAt": "2020-11-06T12:33:03Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingMaintainer.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexer.Cluster;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.google.inject.Inject;\n+import com.yahoo.cloud.config.ClusterListConfig;\n+import com.yahoo.cloud.config.ZookeepersConfig;\n+import com.yahoo.component.AbstractComponent;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.DocumentTypeManager;\n+import com.yahoo.document.config.DocumentmanagerConfig;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.net.HostName;\n+import com.yahoo.vespa.config.content.AllClustersBucketSpacesConfig;\n+import com.yahoo.vespa.config.content.reindexing.ReindexingConfig;\n+import com.yahoo.vespa.curator.Curator;\n+import com.yahoo.vespa.zookeeper.VespaZooKeeperServer;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiConsumer;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+\n+/**\n+ * Runs in all cluster controller containers, and progresses reindexngg efforts.\n+ * Work is only done by one container at a time, by requiring a shared ZooKeeper lock to be held while visiting.\n+ * Whichever maintainer gets the lock holds it until all reindexing is done, or until shutdown.\n+ *\n+ * @author jonmv\n+ */\n+public class ReindexingMaintainer extends AbstractComponent {\n+\n+    private static final Logger log = Logger.getLogger(Reindexing.class.getName());\n+\n+    private final Reindexer reindexer;\n+    private final ScheduledExecutorService executor;\n+\n+    // VespaZooKeeperServer dependency to ensure the ZK cluster is running.\n+    @Inject\n+    public ReindexingMaintainer(VespaZooKeeperServer zooKeeperServer, DocumentAccess access, ZookeepersConfig zookeepersConfig,\n+                                ClusterListConfig clusterListConfig, AllClustersBucketSpacesConfig allClustersBucketSpacesConfig,\n+                                ReindexingConfig reindexingConfig, DocumentmanagerConfig documentmanagerConfig) {\n+        this(Clock.systemUTC(), access, zookeepersConfig, clusterListConfig, allClustersBucketSpacesConfig, reindexingConfig, documentmanagerConfig);\n+    }\n+\n+    ReindexingMaintainer(Clock clock, DocumentAccess access, ZookeepersConfig zookeepersConfig,\n+                         ClusterListConfig clusterListConfig, AllClustersBucketSpacesConfig allClustersBucketSpacesConfig,\n+                         ReindexingConfig reindexingConfig, DocumentmanagerConfig documentmanagerConfig) {\n+        DocumentTypeManager manager = new DocumentTypeManager(documentmanagerConfig);\n+        this.reindexer = new Reindexer(parseCluster(reindexingConfig.clusterName(), clusterListConfig, allClustersBucketSpacesConfig, manager),\n+                                       parseReady(reindexingConfig, manager),\n+                                       new ReindexingCurator(Curator.create(zookeepersConfig.zookeeperserverlist()), manager),\n+                                       access,\n+                                       clock);\n+        this.executor = new ScheduledThreadPoolExecutor(1, new DaemonThreadFactory(\"reindexer-\"));\n+        if (reindexingConfig.enabled())\n+            scheduleStaggered((delayMillis, intervalMillis) -> executor.scheduleAtFixedRate(this::maintain, delayMillis, intervalMillis, TimeUnit.MILLISECONDS),\n+                              Duration.ofMinutes(1), clock.instant(), HostName.getLocalhost(), zookeepersConfig.zookeeperserverlist());\n+    }\n+\n+    private void maintain() {\n+        try {\n+            reindexer.reindex();\n+        }\n+        catch (ReindexingLockException e) {", "originalCommit": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MDE2Mg==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518870162", "bodyText": "Yeah, done.", "author": "jonmv", "createdAt": "2020-11-06T16:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMjUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwMTM3OQ==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518801379", "bodyText": "s/destinatino/destination", "author": "bjorncs", "createdAt": "2020-11-06T14:52:48Z", "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -28,7 +28,7 @@\n \n /**\n  * Local visitor session that copies and iterates through all items in the local document access.\n- * Each document must be ack'ed for the session to be done visiting.\n+ * Each document must be ack'ed for the session to be done visiting, unless the destinatino is remote.", "originalCommit": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2OTY1NQ==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518869655", "bodyText": "Thanks", "author": "jonmv", "createdAt": "2020-11-06T16:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwMTM3OQ=="}], "type": "inlineReview"}, {"oid": "604ddaefbb59f1353a16e25e45ad0c241cc79793", "url": "https://github.com/vespa-engine/vespa/commit/604ddaefbb59f1353a16e25e45ad0c241cc79793", "message": "Avoid interrupts for control flow", "committedDate": "2020-11-06T15:55:46Z", "type": "commit"}, {"oid": "7572c20d93c23756353aefbf4d12c3c214337220", "url": "https://github.com/vespa-engine/vespa/commit/7572c20d93c23756353aefbf4d12c3c214337220", "message": "Address review comments, and fix unit test", "committedDate": "2020-11-06T17:11:37Z", "type": "commit"}, {"oid": "61f35d882805926489f59c0ce3402fbd57b0ea11", "url": "https://github.com/vespa-engine/vespa/commit/61f35d882805926489f59c0ce3402fbd57b0ea11", "message": "Update timestamp for last progress", "committedDate": "2020-11-06T17:18:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1ODYxNA==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r519658614", "bodyText": "I presume this is a synchronous write to ZooKeeper? If it's observed to be a performance issue, it could be useful to consider making progress updates async since this is called in the context of a visitor client worker thread callback.", "author": "vekterli", "createdAt": "2020-11-09T09:20:01Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -60,72 +63,94 @@ public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCu\n         this.clock = clock;\n     }\n \n+    /** Tells this to stop reindexing at its leisure. */\n+    public void shutdown() {\n+        phaser.forceTermination();\n+    }\n+\n     /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n     public void reindex() throws ReindexingLockException {\n+        if (phaser.isTerminated())\n+            throw new IllegalStateException(\"Already shut down\");\n+\n         try (Lock lock = database.lockReindexing()) {\n-            Reindexing reindexing = database.readReindexing();\n             for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n-                if (ready.get(type).isAfter(clock.instant())) {\n-                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n-                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n-                }\n-                else {\n-                    // If this is a new document type (or a new cluster), no reindexing is required.\n-                    Status status = reindexing.status().getOrDefault(type,\n-                                                                     Status.ready(clock.instant())\n-                                                                           .running()\n-                                                                           .successful(clock.instant()));\n-                    reindexing = reindexing.with(type, progress(type, status));\n-                }\n-                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                if (ready.get(type).isAfter(clock.instant()))\n+                    log.log(INFO, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                  \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                else\n+                    progress(type);\n+\n+                if (phaser.isTerminated())\n                     break;\n             }\n-            database.writeReindexing(reindexing);\n         }\n     }\n \n     @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n-    private Status progress(DocumentType type, Status status) {\n+    private void progress(DocumentType type) {\n+        // If this is a new document type (or a new cluster), no reindexing is required.\n+        reindexing = database.readReindexing();\n+        status = reindexing.status().getOrDefault(type,\n+                                                  Status.ready(clock.instant())\n+                                                        .running()\n+                                                        .successful(clock.instant()));\n         if (ready.get(type).isAfter(status.startedAt()))\n             status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n \n+        database.writeReindexing(reindexing = reindexing.with(type, status));\n+\n         switch (status.state()) {\n             default:\n                 log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n             case FAILED:\n                 log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n             case SUCCESSFUL: // Intentional fallthrough \u2014 all three are done states.\n-                return status;\n+                return;\n             case RUNNING:\n-                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);\n+                log.log(WARNING, \"Unexpected state 'RUNNING' of reindexing of \" + type);\n             case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.\n-            log.log(FINE, () -> \"Running reindexing of \" + type + \", which started at \" + status.startedAt());\n+            log.log(FINE, () -> \"Running reindexing of \" + type);\n         }\n \n         // Visit buckets until they're all done, or until we are interrupted.\n         status = status.running();\n-        VisitorControlHandler control = new VisitorControlHandler();\n+        AtomicReference<Instant> progressLastStored = new AtomicReference<>(clock.instant());\n+        VisitorControlHandler control = new VisitorControlHandler() {\n+            @Override\n+            public void onProgress(ProgressToken token) {\n+                super.onProgress(token);\n+                status = status.progressed(token);\n+                if (progressLastStored.get().isBefore(clock.instant().minusSeconds(10))) {\n+                    progressLastStored.set(clock.instant());\n+                    database.writeReindexing(reindexing = reindexing.with(type, status));", "originalCommit": "61f35d882805926489f59c0ce3402fbd57b0ea11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcxMTEzOA==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r519711138", "bodyText": "Noted.", "author": "jonmv", "createdAt": "2020-11-09T10:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1ODYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3Mzg2Mg==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r519673862", "bodyText": "Could we ever get a case where multiple (disparate) reindexing controller clusters run against the same ZooKeeper cluster? I don't really see this happening with our current setup, mind you. We could probably use some ZK chroot-style magic if we need to support it.", "author": "vekterli", "createdAt": "2020-11-09T09:43:33Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingCurator.java", "diffHunk": "@@ -33,14 +37,22 @@\n     private static final String STATE = \"state\";\n     private static final String MESSAGE = \"message\";\n \n-    private static final Path statusPath = Path.fromString(\"/reindexing/v1/status\");\n+    private static final Path rootPath = Path.fromString(\"/reindexing/v1\");", "originalCommit": "61f35d882805926489f59c0ce3402fbd57b0ea11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcxMTY0OQ==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r519711649", "bodyText": "Can add cluster name as part of the root.", "author": "jonmv", "createdAt": "2020-11-09T10:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3Mzg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY4OTAzNQ==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r519689035", "bodyText": "For those of us not too familiar with these newfangled and fancy Phaser doohickies, a comment on how this ends up transitively aborting the active visitor session would be nice \ud83e\udd96", "author": "vekterli", "createdAt": "2020-11-09T10:06:20Z", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,235 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until shutdown is called, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+    private final Phaser phaser = new Phaser(2); // Reindexer and visitor.\n+\n+    private Reindexing reindexing;\n+    private Status status;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketSpaceOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Tells this to stop reindexing at its leisure. */\n+    public void shutdown() {\n+        phaser.forceTermination();", "originalCommit": "61f35d882805926489f59c0ce3402fbd57b0ea11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcxMTg5OQ==", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r519711899", "bodyText": "Of course!", "author": "jonmv", "createdAt": "2020-11-09T10:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY4OTAzNQ=="}], "type": "inlineReview"}, {"oid": "c662ac1850acc7f6d1dc61ef30592908f1d510c0", "url": "https://github.com/vespa-engine/vespa/commit/c662ac1850acc7f6d1dc61ef30592908f1d510c0", "message": "Add cluster name to reindexing status root", "committedDate": "2020-11-09T10:55:22Z", "type": "commit"}, {"oid": "215d8a7a446a37d74be3900061d4488a662b54cb", "url": "https://github.com/vespa-engine/vespa/commit/215d8a7a446a37d74be3900061d4488a662b54cb", "message": "Add some commeents about synchronisation in Reindexer", "committedDate": "2020-11-09T10:55:35Z", "type": "commit"}]}