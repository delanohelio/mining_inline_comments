{"pr_number": 15484, "pr_title": "Arnej/add serialized fast value attribute", "pr_createdAt": "2020-11-26T13:36:22Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/15484", "timeline": [{"oid": "01fbc29b61328fdad6c8607b5099ffd3b5cf45a1", "url": "https://github.com/vespa-engine/vespa/commit/01fbc29b61328fdad6c8607b5099ffd3b5cf45a1", "message": "more explicit name", "committedDate": "2020-11-26T13:35:08Z", "type": "commit"}, {"oid": "1644ca6e82ca22275e8d350724d995682ed87b1f", "url": "https://github.com/vespa-engine/vespa/commit/1644ca6e82ca22275e8d350724d995682ed87b1f", "message": "add SerializedFastValueAttribute", "committedDate": "2020-11-26T13:35:08Z", "type": "commit"}, {"oid": "d68669ae2a1e35b88db93308f6c4922f698c4ab2", "url": "https://github.com/vespa-engine/vespa/commit/d68669ae2a1e35b88db93308f6c4922f698c4ab2", "message": "use SerializedFastValueAttribute if possible", "committedDate": "2020-11-26T13:35:08Z", "type": "commit"}, {"oid": "d5c16579174f3e20b4cc67886476aa9e05408102", "url": "https://github.com/vespa-engine/vespa/commit/d5c16579174f3e20b4cc67886476aa9e05408102", "message": "more consistent version checking", "committedDate": "2020-11-26T13:35:08Z", "type": "commit"}, {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000", "url": "https://github.com/vespa-engine/vespa/commit/600249318782e85982cce4b1e1f8bcf9a1c7a000", "message": "test SerializedFastValueAttribute instead", "committedDate": "2020-11-27T12:48:28Z", "type": "commit"}, {"oid": "42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c", "url": "https://github.com/vespa-engine/vespa/commit/42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c", "message": "Merge branch 'master' into arnej/add-serialized_fast_value_attribute\n\nfix trivial conflict.\n\nConflicts:\n\tsearchlib/src/tests/features/tensor/tensor_test.cpp", "committedDate": "2020-11-27T13:47:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU5NjU0OQ==", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531596549", "bodyText": "Please add copyright.", "author": "geirst", "createdAt": "2020-11-27T13:17:29Z", "path": "searchlib/src/vespa/searchlib/tensor/serialized_fast_value_attribute.h", "diffHunk": "@@ -0,0 +1,26 @@\n+", "originalCommit": "600249318782e85982cce4b1e1f8bcf9a1c7a000", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU5NjY0MA==", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531596640", "bodyText": "Please add copyright.", "author": "geirst", "createdAt": "2020-11-27T13:17:42Z", "path": "searchlib/src/vespa/searchlib/tensor/serialized_fast_value_attribute.cpp", "diffHunk": "@@ -0,0 +1,207 @@\n+#include \"serialized_fast_value_attribute.h\"", "originalCommit": "600249318782e85982cce4b1e1f8bcf9a1c7a000", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU5Njk5Ng==", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531596996", "bodyText": "Please add copyright.", "author": "geirst", "createdAt": "2020-11-27T13:18:29Z", "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "diffHunk": "@@ -0,0 +1,241 @@\n+", "originalCommit": "600249318782e85982cce4b1e1f8bcf9a1c7a000", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwMTczMw==", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531601733", "bodyText": "Please rename to a more descriptive name.", "author": "geirst", "createdAt": "2020-11-27T13:27:36Z", "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "diffHunk": "@@ -0,0 +1,241 @@\n+\n+#include \"streamed_value_store.h\"\n+#include \"tensor_deserialize.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/streamed/streamed_value_builder_factory.h>\n+#include <vespa/eval/streamed/streamed_value_view.h>\n+#include <vespa/vespalib/datastore/datastore.hpp>\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_store\");\n+\n+using vespalib::datastore::Handle;\n+using namespace vespalib::eval;\n+\n+namespace search::tensor {\n+\n+namespace {\n+\n+constexpr size_t MIN_BUFFER_ARRAYS = 1024;\n+\n+struct CellsMemBlock {\n+    uint32_t num;\n+    uint32_t total_sz;\n+    const char *ptr;\n+    CellsMemBlock(TypedCells cells)\n+      : num(cells.size),\n+        total_sz(CellTypeUtils::mem_size(cells.type, num)),\n+        ptr((const char *)cells.data)\n+    {}\n+};\n+\n+template<typename T>\n+T *fix_alignment(T *ptr, size_t align)\n+{\n+    static_assert(sizeof(T) == 1);\n+    assert((align & (align-1)) == 0); // must be 2^N\n+    size_t ptr_val = (size_t)ptr;\n+    size_t unalign = ptr_val & (align - 1);\n+    if (unalign == 0) {\n+        return ptr;\n+    } else {\n+        return ptr + (align - unalign);\n+    }\n+}\n+\n+} // namespace <unnamed>\n+\n+StreamedValueStore::StreamedValueStore(const ValueType &tensor_type)\n+  : TensorStore(_concreteStore),\n+    _concreteStore(),\n+    _bufferType(RefType::align(1),\n+                MIN_BUFFER_ARRAYS,\n+                RefType::offsetSize() / RefType::align(1)),\n+    _tensor_type(tensor_type),\n+    _data_from_type(_tensor_type)\n+{\n+    _store.addType(&_bufferType);\n+    _store.initActiveBuffers();\n+}\n+\n+StreamedValueStore::~StreamedValueStore()\n+{\n+    _store.dropBuffers();\n+}\n+\n+std::pair<const char *, uint32_t>\n+StreamedValueStore::getRawBuffer(RefType ref) const\n+{\n+    if (!ref.valid()) {\n+        return std::make_pair(nullptr, 0u);\n+    }\n+    const char *buf = _store.getEntry<char>(ref);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    return std::make_pair(buf + sizeof(uint32_t), len);\n+}\n+\n+Handle<char>\n+StreamedValueStore::allocRawBuffer(uint32_t size)\n+{\n+    if (size == 0) {\n+        return Handle<char>();\n+    }\n+    size_t extSize = size + sizeof(uint32_t);\n+    size_t bufSize = RefType::align(extSize);\n+    auto result = _concreteStore.rawAllocator<char>(_typeId).alloc(bufSize);\n+    *reinterpret_cast<uint32_t *>(result.data) = size;\n+    char *padWritePtr = result.data + extSize;\n+    for (size_t i = extSize; i < bufSize; ++i) {\n+        *padWritePtr++ = 0;\n+    }\n+    // Hide length of buffer (first 4 bytes) from users of the buffer.\n+    return Handle<char>(result.ref, result.data + sizeof(uint32_t));\n+}\n+\n+void\n+StreamedValueStore::holdTensor(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return;\n+    }\n+    RefType iRef(ref);\n+    const char *buf = _store.getEntry<char>(iRef);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    _concreteStore.holdElem(ref, len + sizeof(uint32_t));\n+}\n+\n+TensorStore::EntryRef\n+StreamedValueStore::move(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return RefType();\n+    }\n+    auto oldraw = getRawBuffer(ref);\n+    auto newraw = allocRawBuffer(oldraw.second);\n+    memcpy(newraw.data, oldraw.first, oldraw.second);\n+    _concreteStore.holdElem(ref, oldraw.second + sizeof(uint32_t));\n+    return newraw.ref;\n+}\n+\n+StreamedValueStore::StreamedValueData\n+StreamedValueStore::get_tensor_data(EntryRef ref) const\n+{\n+    StreamedValueData retval;\n+    retval.valid = false;\n+    auto raw = getRawBuffer(ref);\n+    if (raw.second == 0u) {\n+        return retval;\n+    }\n+    vespalib::nbostream_longlivedbuf source(raw.first, raw.second);\n+    uint32_t num_cells = source.readValue<uint32_t>();\n+    {\n+        uint32_t alignment = CellTypeUtils::alignment(_data_from_type.cell_type);\n+        const char *aligned_ptr = fix_alignment(source.peek(), alignment);\n+        size_t adjustment = aligned_ptr - source.peek();\n+        source.adjustReadPos(adjustment);\n+    }\n+    retval.cells_ref = TypedCells(source.peek(), _data_from_type.cell_type, num_cells);\n+    source.adjustReadPos(CellTypeUtils::mem_size(_data_from_type.cell_type, num_cells));\n+    retval.num_subspaces = source.readValue<uint32_t>();\n+    retval.labels_buffer = vespalib::ConstArrayRef<char>(source.peek(), source.size());\n+ \n+    if (retval.num_subspaces * _data_from_type.dense_subspace_size == num_cells) {\n+        retval.valid = true;\n+        return retval;\n+    }\n+    LOG(warning, \"inconsistent stored tensor data: \"\n+        \"num_subspaces[%zu] * dense_subspace_size[%u] = %zu != num_cells[%u]\",\n+        retval.num_subspaces, _data_from_type.dense_subspace_size,\n+        retval.num_subspaces * _data_from_type.dense_subspace_size,\n+        num_cells);\n+    return retval;\n+}\n+\n+bool\n+StreamedValueStore::encode_tensor(EntryRef ref, vespalib::nbostream &target) const\n+{\n+    if (auto data = get_tensor_data(ref)) {\n+        StreamedValueView value(\n+            _tensor_type, _data_from_type.num_mapped_dimensions,\n+            data.cells_ref, data.num_subspaces, data.labels_buffer);\n+        vespalib::eval::encode_value(value, target);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+void\n+StreamedValueStore::my_encode(const Value::Index &index,", "originalCommit": "600249318782e85982cce4b1e1f8bcf9a1c7a000", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwMzYwNA==", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531603604", "bodyText": "Please update copyright.", "author": "geirst", "createdAt": "2020-11-27T13:31:10Z", "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.h", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "originalCommit": "600249318782e85982cce4b1e1f8bcf9a1c7a000", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwNDA0NQ==", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531604045", "bodyText": "Please update description to reflect implementation. Would also be nice with a short description of the serialisation format used.", "author": "geirst", "createdAt": "2020-11-27T13:32:03Z", "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.h", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"tensor_store.h\"\n+#include <vespa/eval/eval/value_type.h>\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/typify.h>\n+\n+namespace search::tensor {\n+\n+/**\n+ * Class for storing serialized tensors in memory", "originalCommit": "600249318782e85982cce4b1e1f8bcf9a1c7a000", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNTU1Mw==", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531625553", "bodyText": "Consider adding labels to error message.", "author": "geirst", "createdAt": "2020-11-27T14:14:35Z", "path": "searchlib/src/vespa/searchlib/tensor/serialized_fast_value_attribute.cpp", "diffHunk": "@@ -0,0 +1,207 @@\n+#include \"serialized_fast_value_attribute.h\"\n+#include \"streamed_value_saver.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/fast_value.hpp>\n+#include <vespa/eval/streamed/streamed_value_utils.h>\n+#include <vespa/fastlib/io/bufferedfile.h>\n+#include <vespa/searchlib/attribute/readerbase.h>\n+#include <vespa/searchlib/util/fileutil.h>\n+#include <vespa/vespalib/util/rcuvector.hpp>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.serialized_fast_value_attribute\");\n+\n+#include \"blob_sequence_reader.h\"\n+#include \"tensor_attribute.hpp\"\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+\n+namespace search::tensor {\n+\n+namespace {\n+\n+struct ValueBlock : LabelBlock {\n+    TypedCells cells;\n+};\n+\n+class ValueBlockStream {\n+private:\n+    const StreamedValueStore::DataFromType &_from_type;\n+    LabelBlockStream _label_block_stream;\n+    const char *_cells_ptr;\n+\n+    size_t dsss() const { return _from_type.dense_subspace_size; }\n+    auto cell_type() const { return _from_type.cell_type; }\n+public:\n+    ValueBlock next_block() {\n+        auto labels = _label_block_stream.next_block();\n+        if (labels) {\n+            TypedCells subspace_cells(_cells_ptr, cell_type(), dsss());\n+            _cells_ptr += CellTypeUtils::mem_size(cell_type(), dsss());\n+            return ValueBlock{labels, subspace_cells};\n+        } else {\n+            TypedCells none(nullptr, cell_type(), 0);\n+            return ValueBlock{labels, none};\n+        }\n+    }\n+    \n+    ValueBlockStream(const StreamedValueStore::DataFromType &from_type,\n+                     const StreamedValueStore::StreamedValueData &from_store)\n+      : _from_type(from_type),\n+        _label_block_stream(from_store.num_subspaces,\n+                            from_store.labels_buffer,\n+                            from_type.num_mapped_dimensions),\n+        _cells_ptr((const char *)from_store.cells_ref.data)\n+    {\n+        _label_block_stream.reset();\n+    }\n+    \n+    ~ValueBlockStream();\n+};\n+\n+ValueBlockStream::~ValueBlockStream() = default;\n+\n+class OnlyFastValueIndex : public Value {\n+private:\n+    const ValueType &_type;\n+    TypedCells _cells;\n+    FastValueIndex my_index;\n+public:\n+    OnlyFastValueIndex(const ValueType &type,\n+                       const StreamedValueStore::DataFromType &from_type,\n+                       const StreamedValueStore::StreamedValueData &from_store)\n+      : _type(type),\n+        _cells(from_store.cells_ref),\n+        my_index(from_type.num_mapped_dimensions,\n+                 from_store.num_subspaces)\n+    {\n+        assert(_type.cell_type() == _cells.type);\n+        std::vector<vespalib::stringref> address(from_type.num_mapped_dimensions);\n+        auto block_stream = ValueBlockStream(from_type, from_store);\n+        size_t ss = 0;\n+        while (auto block = block_stream.next_block()) {\n+            size_t idx = my_index.map.add_mapping(block.address);\n+            if (idx != ss) {\n+                LOG(error, \"add_mapping returned idx=%zu for subspace %zu\", idx, ss);", "originalCommit": "42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNjAzOQ==", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531626039", "bodyText": "Change to an assert.", "author": "geirst", "createdAt": "2020-11-27T14:15:28Z", "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "diffHunk": "@@ -0,0 +1,241 @@\n+\n+#include \"streamed_value_store.h\"\n+#include \"tensor_deserialize.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/streamed/streamed_value_builder_factory.h>\n+#include <vespa/eval/streamed/streamed_value_view.h>\n+#include <vespa/vespalib/datastore/datastore.hpp>\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_store\");\n+\n+using vespalib::datastore::Handle;\n+using namespace vespalib::eval;\n+\n+namespace search::tensor {\n+\n+namespace {\n+\n+constexpr size_t MIN_BUFFER_ARRAYS = 1024;\n+\n+struct CellsMemBlock {\n+    uint32_t num;\n+    uint32_t total_sz;\n+    const char *ptr;\n+    CellsMemBlock(TypedCells cells)\n+      : num(cells.size),\n+        total_sz(CellTypeUtils::mem_size(cells.type, num)),\n+        ptr((const char *)cells.data)\n+    {}\n+};\n+\n+template<typename T>\n+T *fix_alignment(T *ptr, size_t align)\n+{\n+    static_assert(sizeof(T) == 1);\n+    assert((align & (align-1)) == 0); // must be 2^N\n+    size_t ptr_val = (size_t)ptr;\n+    size_t unalign = ptr_val & (align - 1);\n+    if (unalign == 0) {\n+        return ptr;\n+    } else {\n+        return ptr + (align - unalign);\n+    }\n+}\n+\n+} // namespace <unnamed>\n+\n+StreamedValueStore::StreamedValueStore(const ValueType &tensor_type)\n+  : TensorStore(_concreteStore),\n+    _concreteStore(),\n+    _bufferType(RefType::align(1),\n+                MIN_BUFFER_ARRAYS,\n+                RefType::offsetSize() / RefType::align(1)),\n+    _tensor_type(tensor_type),\n+    _data_from_type(_tensor_type)\n+{\n+    _store.addType(&_bufferType);\n+    _store.initActiveBuffers();\n+}\n+\n+StreamedValueStore::~StreamedValueStore()\n+{\n+    _store.dropBuffers();\n+}\n+\n+std::pair<const char *, uint32_t>\n+StreamedValueStore::getRawBuffer(RefType ref) const\n+{\n+    if (!ref.valid()) {\n+        return std::make_pair(nullptr, 0u);\n+    }\n+    const char *buf = _store.getEntry<char>(ref);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    return std::make_pair(buf + sizeof(uint32_t), len);\n+}\n+\n+Handle<char>\n+StreamedValueStore::allocRawBuffer(uint32_t size)\n+{\n+    if (size == 0) {\n+        return Handle<char>();\n+    }\n+    size_t extSize = size + sizeof(uint32_t);\n+    size_t bufSize = RefType::align(extSize);\n+    auto result = _concreteStore.rawAllocator<char>(_typeId).alloc(bufSize);\n+    *reinterpret_cast<uint32_t *>(result.data) = size;\n+    char *padWritePtr = result.data + extSize;\n+    for (size_t i = extSize; i < bufSize; ++i) {\n+        *padWritePtr++ = 0;\n+    }\n+    // Hide length of buffer (first 4 bytes) from users of the buffer.\n+    return Handle<char>(result.ref, result.data + sizeof(uint32_t));\n+}\n+\n+void\n+StreamedValueStore::holdTensor(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return;\n+    }\n+    RefType iRef(ref);\n+    const char *buf = _store.getEntry<char>(iRef);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    _concreteStore.holdElem(ref, len + sizeof(uint32_t));\n+}\n+\n+TensorStore::EntryRef\n+StreamedValueStore::move(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return RefType();\n+    }\n+    auto oldraw = getRawBuffer(ref);\n+    auto newraw = allocRawBuffer(oldraw.second);\n+    memcpy(newraw.data, oldraw.first, oldraw.second);\n+    _concreteStore.holdElem(ref, oldraw.second + sizeof(uint32_t));\n+    return newraw.ref;\n+}\n+\n+StreamedValueStore::StreamedValueData\n+StreamedValueStore::get_tensor_data(EntryRef ref) const\n+{\n+    StreamedValueData retval;\n+    retval.valid = false;\n+    auto raw = getRawBuffer(ref);\n+    if (raw.second == 0u) {\n+        return retval;\n+    }\n+    vespalib::nbostream_longlivedbuf source(raw.first, raw.second);\n+    uint32_t num_cells = source.readValue<uint32_t>();\n+    {\n+        uint32_t alignment = CellTypeUtils::alignment(_data_from_type.cell_type);\n+        const char *aligned_ptr = fix_alignment(source.peek(), alignment);\n+        size_t adjustment = aligned_ptr - source.peek();\n+        source.adjustReadPos(adjustment);\n+    }\n+    retval.cells_ref = TypedCells(source.peek(), _data_from_type.cell_type, num_cells);\n+    source.adjustReadPos(CellTypeUtils::mem_size(_data_from_type.cell_type, num_cells));\n+    retval.num_subspaces = source.readValue<uint32_t>();\n+    retval.labels_buffer = vespalib::ConstArrayRef<char>(source.peek(), source.size());\n+ \n+    if (retval.num_subspaces * _data_from_type.dense_subspace_size == num_cells) {", "originalCommit": "42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNjQ3Mw==", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531626473", "bodyText": "We can remove the log message with the assert above.", "author": "geirst", "createdAt": "2020-11-27T14:16:16Z", "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "diffHunk": "@@ -0,0 +1,241 @@\n+\n+#include \"streamed_value_store.h\"\n+#include \"tensor_deserialize.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/streamed/streamed_value_builder_factory.h>\n+#include <vespa/eval/streamed/streamed_value_view.h>\n+#include <vespa/vespalib/datastore/datastore.hpp>\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_store\");\n+\n+using vespalib::datastore::Handle;\n+using namespace vespalib::eval;\n+\n+namespace search::tensor {\n+\n+namespace {\n+\n+constexpr size_t MIN_BUFFER_ARRAYS = 1024;\n+\n+struct CellsMemBlock {\n+    uint32_t num;\n+    uint32_t total_sz;\n+    const char *ptr;\n+    CellsMemBlock(TypedCells cells)\n+      : num(cells.size),\n+        total_sz(CellTypeUtils::mem_size(cells.type, num)),\n+        ptr((const char *)cells.data)\n+    {}\n+};\n+\n+template<typename T>\n+T *fix_alignment(T *ptr, size_t align)\n+{\n+    static_assert(sizeof(T) == 1);\n+    assert((align & (align-1)) == 0); // must be 2^N\n+    size_t ptr_val = (size_t)ptr;\n+    size_t unalign = ptr_val & (align - 1);\n+    if (unalign == 0) {\n+        return ptr;\n+    } else {\n+        return ptr + (align - unalign);\n+    }\n+}\n+\n+} // namespace <unnamed>\n+\n+StreamedValueStore::StreamedValueStore(const ValueType &tensor_type)\n+  : TensorStore(_concreteStore),\n+    _concreteStore(),\n+    _bufferType(RefType::align(1),\n+                MIN_BUFFER_ARRAYS,\n+                RefType::offsetSize() / RefType::align(1)),\n+    _tensor_type(tensor_type),\n+    _data_from_type(_tensor_type)\n+{\n+    _store.addType(&_bufferType);\n+    _store.initActiveBuffers();\n+}\n+\n+StreamedValueStore::~StreamedValueStore()\n+{\n+    _store.dropBuffers();\n+}\n+\n+std::pair<const char *, uint32_t>\n+StreamedValueStore::getRawBuffer(RefType ref) const\n+{\n+    if (!ref.valid()) {\n+        return std::make_pair(nullptr, 0u);\n+    }\n+    const char *buf = _store.getEntry<char>(ref);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    return std::make_pair(buf + sizeof(uint32_t), len);\n+}\n+\n+Handle<char>\n+StreamedValueStore::allocRawBuffer(uint32_t size)\n+{\n+    if (size == 0) {\n+        return Handle<char>();\n+    }\n+    size_t extSize = size + sizeof(uint32_t);\n+    size_t bufSize = RefType::align(extSize);\n+    auto result = _concreteStore.rawAllocator<char>(_typeId).alloc(bufSize);\n+    *reinterpret_cast<uint32_t *>(result.data) = size;\n+    char *padWritePtr = result.data + extSize;\n+    for (size_t i = extSize; i < bufSize; ++i) {\n+        *padWritePtr++ = 0;\n+    }\n+    // Hide length of buffer (first 4 bytes) from users of the buffer.\n+    return Handle<char>(result.ref, result.data + sizeof(uint32_t));\n+}\n+\n+void\n+StreamedValueStore::holdTensor(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return;\n+    }\n+    RefType iRef(ref);\n+    const char *buf = _store.getEntry<char>(iRef);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    _concreteStore.holdElem(ref, len + sizeof(uint32_t));\n+}\n+\n+TensorStore::EntryRef\n+StreamedValueStore::move(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return RefType();\n+    }\n+    auto oldraw = getRawBuffer(ref);\n+    auto newraw = allocRawBuffer(oldraw.second);\n+    memcpy(newraw.data, oldraw.first, oldraw.second);\n+    _concreteStore.holdElem(ref, oldraw.second + sizeof(uint32_t));\n+    return newraw.ref;\n+}\n+\n+StreamedValueStore::StreamedValueData\n+StreamedValueStore::get_tensor_data(EntryRef ref) const\n+{\n+    StreamedValueData retval;\n+    retval.valid = false;\n+    auto raw = getRawBuffer(ref);\n+    if (raw.second == 0u) {\n+        return retval;\n+    }\n+    vespalib::nbostream_longlivedbuf source(raw.first, raw.second);\n+    uint32_t num_cells = source.readValue<uint32_t>();\n+    {\n+        uint32_t alignment = CellTypeUtils::alignment(_data_from_type.cell_type);\n+        const char *aligned_ptr = fix_alignment(source.peek(), alignment);\n+        size_t adjustment = aligned_ptr - source.peek();\n+        source.adjustReadPos(adjustment);\n+    }\n+    retval.cells_ref = TypedCells(source.peek(), _data_from_type.cell_type, num_cells);\n+    source.adjustReadPos(CellTypeUtils::mem_size(_data_from_type.cell_type, num_cells));\n+    retval.num_subspaces = source.readValue<uint32_t>();\n+    retval.labels_buffer = vespalib::ConstArrayRef<char>(source.peek(), source.size());\n+ \n+    if (retval.num_subspaces * _data_from_type.dense_subspace_size == num_cells) {\n+        retval.valid = true;\n+        return retval;\n+    }\n+    LOG(warning, \"inconsistent stored tensor data: \"", "originalCommit": "42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "da1bc43297be17d4f7ea18026c9984f07098af73", "url": "https://github.com/vespa-engine/vespa/commit/da1bc43297be17d4f7ea18026c9984f07098af73", "message": "review follow-up fixes\n\n* add documentation comment for OnlyFastValueIndex\n* flesh out documentation comment for StreamedValueStore\n* no need for nbostream_longlivedbuf here\n* rename my_encode -> serialize_labels\n* less random logging of problems\n* report labels for addresses causing subspace collision", "committedDate": "2020-11-27T15:39:02Z", "type": "commit"}, {"oid": "4ac10dad24980734a161533c36b232cfc5d3a2f9", "url": "https://github.com/vespa-engine/vespa/commit/4ac10dad24980734a161533c36b232cfc5d3a2f9", "message": "check tensor type in attribute, just assert in store", "committedDate": "2020-11-27T15:52:51Z", "type": "commit"}]}