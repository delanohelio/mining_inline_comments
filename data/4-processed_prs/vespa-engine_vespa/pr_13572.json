{"pr_number": 13572, "pr_title": "Arnej/keep and follow refs", "pr_createdAt": "2020-06-12T14:00:04Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/13572", "timeline": [{"oid": "2ccbb15bc59d6ebd743eed0a918ad0374e75f821", "url": "https://github.com/vespa-engine/vespa/commit/2ccbb15bc59d6ebd743eed0a918ad0374e75f821", "message": "add getters checking if held references are still valid", "committedDate": "2020-06-12T08:36:28Z", "type": "commit"}, {"oid": "d42fba42c3a8e58e87d3b03ad0124169c7b96e51", "url": "https://github.com/vespa-engine/vespa/commit/d42fba42c3a8e58e87d3b03ad0124169c7b96e51", "message": "keep and follow node_refs when traversing HNSW graph\n\n* cannot assert in HnswGraph read operations,\n  because nodes may be removed or replaced by another\n  thread\n* read operations on the HNSW graph need to load the\n  node_ref (and check that it's valid) when following\n  links; keep and use that node_ref to ensure succeeding\n  operations actually access information that belongs\n  to the same version of the node.\n* to ensure the entry point is internally consistent,\n  check that the atomic value is the same after reading\n  the corresponding node_ref, and retry if it was\n  updated concurrently.", "committedDate": "2020-06-12T08:36:29Z", "type": "commit"}, {"oid": "7a01030e688079f7d1838c8d1f8b7384d1b98cdb", "url": "https://github.com/vespa-engine/vespa/commit/7a01030e688079f7d1838c8d1f8b7384d1b98cdb", "message": "no explicit clear of each level when removing document\n\n* keep the levels as they were, so any concurrent search\n  operation getting a reference to this docid can follow\n  old links and avoid getting trapped if possible\n* ensure later GC can pick up any referenced data in\n  HnswGraph::remove_node_for_document instead, it is\n  more robust to have it in the graph layer anyway.", "committedDate": "2020-06-12T08:36:29Z", "type": "commit"}, {"oid": "96a0022950968d86584f5c75307a9a30a6eeb7d0", "url": "https://github.com/vespa-engine/vespa/commit/96a0022950968d86584f5c75307a9a30a6eeb7d0", "message": "add possible improvement points", "committedDate": "2020-06-12T08:36:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE5NDg2Nw==", "url": "https://github.com/vespa-engine/vespa/pull/13572#discussion_r440194867", "bodyText": "Indentation seems off.", "author": "geirst", "createdAt": "2020-06-15T13:57:26Z", "path": "searchlib/src/vespa/searchlib/tensor/hnsw_graph.h", "diffHunk": "@@ -102,15 +112,43 @@ struct HnswGraph {\n         uint64_t value = node.level;\n         value <<= 32;\n         value |= node.docid;\n+        if (node.node_ref.valid()) {\n+            assert(node.level >= 0);\n+            assert(node.docid > 0);\n+        } else {\n+            assert(node.level == -1);\n+            assert(node.docid == 0);\n+        }\n         entry_docid_and_level.store(value, std::memory_order_release);\n     }\n \n+    uint64_t get_entry_atomic() const {\n+        return entry_docid_and_level.load(std::memory_order_acquire);\n+    }\n+\n     EntryNode get_entry_node() const {\n         EntryNode entry;\n-        uint64_t value = entry_docid_and_level.load(std::memory_order_acquire);\n-        entry.docid = (uint32_t)value;\n-        entry.level = (int32_t)(value >> 32);\n-        return entry;\n+        while (true) {\n+\t    uint64_t value = get_entry_atomic();", "originalCommit": "d42fba42c3a8e58e87d3b03ad0124169c7b96e51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e01810c179b2593d7eae286fca7664eb6065d0fe", "url": "https://github.com/vespa-engine/vespa/commit/e01810c179b2593d7eae286fca7664eb6065d0fe", "message": "add stress test", "committedDate": "2020-06-16T17:27:49Z", "type": "commit"}, {"oid": "fb2b67a51102aa4ae3bfa9e1432d00073fd68e89", "url": "https://github.com/vespa-engine/vespa/commit/fb2b67a51102aa4ae3bfa9e1432d00073fd68e89", "message": "fix bugs found by stress test", "committedDate": "2020-06-16T17:35:21Z", "type": "commit"}, {"oid": "8d7162f6e803e3be272ea906778b9d185ac62854", "url": "https://github.com/vespa-engine/vespa/commit/8d7162f6e803e3be272ea906778b9d185ac62854", "message": "get rid of test-internal race condition in MyDocVectorStore", "committedDate": "2020-06-16T18:05:52Z", "type": "commit"}, {"oid": "86fa3c7610c7f35b8b0730a661f6e852a660e412", "url": "https://github.com/vespa-engine/vespa/commit/86fa3c7610c7f35b8b0730a661f6e852a660e412", "message": "untabify", "committedDate": "2020-06-17T11:00:49Z", "type": "commit"}, {"oid": "1da494f6f83b0c506170518e5ed6caa090f752c7", "url": "https://github.com/vespa-engine/vespa/commit/1da494f6f83b0c506170518e5ed6caa090f752c7", "message": "save node_ref in prepare_add_doc and check its validity in complete", "committedDate": "2020-06-17T11:01:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5OTgzMg==", "url": "https://github.com/vespa-engine/vespa/pull/13572#discussion_r441499832", "bodyText": "Please update copyright.", "author": "geirst", "createdAt": "2020-06-17T12:16:49Z", "path": "searchlib/src/tests/tensor/hnsw_index/stress_hnsw_mt.cpp", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright 2020 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "originalCommit": "e01810c179b2593d7eae286fca7664eb6065d0fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyNDk1MQ==", "url": "https://github.com/vespa-engine/vespa/pull/13572#discussion_r441524951", "bodyText": "The order of the tasks posted to write_thread is not critical in this test, but we could consider doing it similar to the upcoming functionality in AttributeWriter where we post to both multi_prepare_workers and write_thread with a future binding the two together: 8c0fa90#diff-fe6cb86f93de54a95217644d498483cbR611", "author": "geirst", "createdAt": "2020-06-17T12:59:29Z", "path": "searchlib/src/tests/tensor/hnsw_index/stress_hnsw_mt.cpp", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright 2020 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/tensor/dense/typed_cells.h>\n+#include <vespa/searchlib/common/bitvector.h>\n+#include <vespa/searchlib/tensor/distance_functions.h>\n+#include <vespa/searchlib/tensor/doc_vector_access.h>\n+#include <vespa/searchlib/tensor/hnsw_index.h>\n+#include <vespa/searchlib/tensor/random_level_generator.h>\n+#include <vespa/searchlib/tensor/inv_log_level_generator.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <vespa/vespalib/util/generationhandler.h>\n+#include <vespa/vespalib/data/slime/slime.h>\n+#include <vespa/vespalib/util/threadstackexecutor.h>\n+#include <vespa/vespalib/util/blockingthreadstackexecutor.h>\n+#include <vespa/vespalib/util/gate.h>\n+#include <vespa/vespalib/util/lambdatask.h>\n+\n+#include <vector>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <chrono>\n+#include <cstdlib>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\"stress_hnsw_mt\");\n+\n+using vespalib::GenerationHandler;\n+using vespalib::MemoryUsage;\n+using namespace search::tensor;\n+using namespace vespalib::slime;\n+using vespalib::Slime;\n+using search::BitVector;\n+\n+#define NUM_DIMS 128\n+#define NUM_POSSIBLE_V 100000\n+#define NUM_POSSIBLE_DOCS 10000\n+#define NUM_OPS 50000\n+\n+class RndGen {\n+private:\n+    std::mt19937_64 urng;\n+    std::uniform_real_distribution<double> uf;\n+public:\n+    RndGen() : urng(0x1234deadbeef5678uLL), uf(0.0, 1.0) {}\n+\n+    double nextUniform() {\n+        return uf(urng);\n+    }\n+};\n+\n+using ConstVectorRef = vespalib::ConstArrayRef<float>;\n+\n+struct MallocPointVector {\n+    float v[NUM_DIMS];\n+    operator ConstVectorRef() const { return ConstVectorRef(v, NUM_DIMS); }\n+};\n+static MallocPointVector *aligned_alloc_pv(size_t num) {\n+    size_t num_bytes = num * sizeof(MallocPointVector);\n+    double mega_bytes = num_bytes / (1024.0*1024.0);\n+    fprintf(stderr, \"allocate %.2f MB of vectors\\n\", mega_bytes);\n+    char *mem = (char *)malloc(num_bytes + 512);\n+    mem += 512;\n+    size_t val = (size_t)mem;\n+    size_t unalign = val % 512;\n+    mem -= unalign;\n+    return reinterpret_cast<MallocPointVector *>(mem);\n+}\n+\n+void read_vector_file(MallocPointVector *p) {\n+    std::string data_set = \"sift\";\n+    std::string data_dir = \".\";\n+    char *home = getenv(\"HOME\");\n+    if (home) {\n+        data_dir = home;\n+        data_dir += \"/\" + data_set;\n+    }\n+    std::string fn = data_dir + \"/\" + data_set + \"_base.fvecs\";\n+    int fd = open(fn.c_str(), O_RDONLY);\n+    if (fd < 0) {\n+        perror(fn.c_str());\n+        exit(1);\n+    }\n+    int d;\n+    size_t rv;\n+    fprintf(stderr, \"reading %u vectors from %s\\n\", NUM_POSSIBLE_V, fn.c_str());\n+    for (uint32_t i = 0; i < NUM_POSSIBLE_V; ++i) {\n+        rv = read(fd, &d, 4);\n+        ASSERT_EQ(rv, 4u);\n+        ASSERT_EQ(d, NUM_DIMS);\n+        rv = read(fd, &p[i].v, NUM_DIMS*sizeof(float));\n+        ASSERT_EQ(rv, sizeof(MallocPointVector));\n+    }\n+    close(fd);\n+    fprintf(stderr, \"reading %u vectors OK\\n\", NUM_POSSIBLE_V);\n+}\n+\n+class MyDocVectorStore : public DocVectorAccess {\n+private:\n+    using Vector = std::vector<float>;\n+    std::vector<Vector> _vectors;\n+\n+public:\n+    MyDocVectorStore() : _vectors() {}\n+    MyDocVectorStore& set(uint32_t docid, ConstVectorRef vec) {\n+        if (docid >= _vectors.size()) {\n+            _vectors.resize(docid + 1);\n+        }\n+        _vectors[docid] = Vector(vec.begin(), vec.end());\n+        return *this;\n+    }\n+    vespalib::tensor::TypedCells get_vector(uint32_t docid) const override {\n+        ConstVectorRef ref(_vectors[docid]);\n+        return vespalib::tensor::TypedCells(ref);\n+    }\n+};\n+\n+using FloatSqEuclideanDistance = SquaredEuclideanDistance<float>;\n+using HnswIndexUP = std::unique_ptr<HnswIndex>;\n+\n+class Stressor : public ::testing::Test {\n+private:\n+    struct LoadedVectors {\n+        MallocPointVector *pv_storage;\n+        void load() {\n+            pv_storage = aligned_alloc_pv(size());\n+            read_vector_file(pv_storage);\n+        }\n+        size_t size() const { return NUM_POSSIBLE_V; }\n+        vespalib::ConstArrayRef<float> operator[] (size_t i) {\n+            return pv_storage[i];\n+        }\n+    } loaded_vectors;\n+public:\n+    BitVector::UP in_progress;\n+    BitVector::UP existing_ids;\n+    RndGen rng;\n+    MyDocVectorStore vectors;\n+    GenerationHandler gen_handler;\n+    HnswIndexUP index;\n+    vespalib::BlockingThreadStackExecutor multi_prepare_workers;\n+    vespalib::BlockingThreadStackExecutor write_thread;\n+\n+    using PrepUP = std::unique_ptr<PrepareResult>;\n+    using ReadGuard = GenerationHandler::Guard;\n+\n+    struct CompleteAddTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        PrepUP prepare_result;\n+\n+        CompleteAddTask(Stressor &p, uint32_t d, ConstVectorRef v, PrepUP r)\n+            : parent(p), docid(d), vec(v), prepare_result(std::move(r))\n+        {}\n+\n+        void run() override {\n+            parent.vectors.set(docid, vec);\n+            parent.index->complete_add_document(docid, std::move(prepare_result));\n+            parent.existing_ids->setBit(docid);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseAddTask  : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseAddTask(Stressor &p, uint32_t d, ConstVectorRef v, ReadGuard r)\n+            : parent(p), docid(d), vec(v), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto v = vespalib::tensor::TypedCells(vec);\n+            auto up = parent.index->prepare_add_document(docid, v, read_guard);\n+            auto task = std::make_unique<CompleteAddTask>(parent, docid, vec, std::move(up));\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete add task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    struct CompleteRemoveTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+\n+        CompleteRemoveTask(Stressor &p, uint32_t d)\n+            : parent(p), docid(d)\n+        {}\n+\n+        void run() override {\n+            parent.index->remove_document(docid);\n+            parent.existing_ids->clearBit(docid);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseRemoveTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseRemoveTask(Stressor &p, uint32_t d, ReadGuard r)\n+            : parent(p), docid(d), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto task = std::make_unique<CompleteRemoveTask>(parent, docid);\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete remove task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    struct CompleteUpdateTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        std::unique_ptr<PrepareResult> prepare_result;\n+\n+        CompleteUpdateTask(Stressor &p, uint32_t d, ConstVectorRef v, PrepUP r)\n+            : parent(p), docid(d), vec(v), prepare_result(std::move(r))\n+        {}\n+\n+        void run() override {\n+            parent.index->remove_document(docid);\n+            parent.vectors.set(docid, vec);\n+            parent.index->complete_add_document(docid, std::move(prepare_result));\n+            EXPECT_EQ(parent.existing_ids->testBit(docid), true);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseUpdateTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseUpdateTask(Stressor &p, uint32_t d, ConstVectorRef v, ReadGuard r)\n+            : parent(p), docid(d), vec(v), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto v = vespalib::tensor::TypedCells(vec);\n+            auto up = parent.index->prepare_add_document(docid, v, read_guard);\n+            EXPECT_EQ(bool(up), true);\n+            auto task = std::make_unique<CompleteUpdateTask>(parent, docid, vec, std::move(up));\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete remove task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    Stressor()\n+        : loaded_vectors(),\n+          in_progress(BitVector::create(NUM_POSSIBLE_DOCS)),\n+          existing_ids(BitVector::create(NUM_POSSIBLE_DOCS)),\n+          rng(),\n+          vectors(),\n+          gen_handler(),\n+          index(),\n+          multi_prepare_workers(10, 128*1024, 50),\n+          write_thread(1, 128*1024, 15)\n+    {\n+        loaded_vectors.load();\n+    }\n+\n+    ~Stressor() {}\n+\n+    void init() {\n+        uint32_t m = 16;\n+        index = std::make_unique<HnswIndex>(vectors, std::make_unique<FloatSqEuclideanDistance>(),\n+                                            std::make_unique<InvLogLevelGenerator>(m),\n+                                            HnswIndex::Config(2*m, m, 200, true));\n+        vectors.set(NUM_POSSIBLE_DOCS, loaded_vectors[0]);\n+    }\n+    size_t get_rnd(size_t size) {\n+        return rng.nextUniform() * size;\n+    }\n+    void add_document(uint32_t docid) {\n+        size_t vec_num = get_rnd(loaded_vectors.size());\n+        ConstVectorRef vec = loaded_vectors[vec_num];\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseAddTask>(*this, docid, vec, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));", "originalCommit": "e01810c179b2593d7eae286fca7664eb6065d0fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyNTU0Mg==", "url": "https://github.com/vespa-engine/vespa/pull/13572#discussion_r441525542", "bodyText": "Same comment as with add_document().", "author": "geirst", "createdAt": "2020-06-17T13:00:25Z", "path": "searchlib/src/tests/tensor/hnsw_index/stress_hnsw_mt.cpp", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright 2020 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/tensor/dense/typed_cells.h>\n+#include <vespa/searchlib/common/bitvector.h>\n+#include <vespa/searchlib/tensor/distance_functions.h>\n+#include <vespa/searchlib/tensor/doc_vector_access.h>\n+#include <vespa/searchlib/tensor/hnsw_index.h>\n+#include <vespa/searchlib/tensor/random_level_generator.h>\n+#include <vespa/searchlib/tensor/inv_log_level_generator.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <vespa/vespalib/util/generationhandler.h>\n+#include <vespa/vespalib/data/slime/slime.h>\n+#include <vespa/vespalib/util/threadstackexecutor.h>\n+#include <vespa/vespalib/util/blockingthreadstackexecutor.h>\n+#include <vespa/vespalib/util/gate.h>\n+#include <vespa/vespalib/util/lambdatask.h>\n+\n+#include <vector>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <chrono>\n+#include <cstdlib>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\"stress_hnsw_mt\");\n+\n+using vespalib::GenerationHandler;\n+using vespalib::MemoryUsage;\n+using namespace search::tensor;\n+using namespace vespalib::slime;\n+using vespalib::Slime;\n+using search::BitVector;\n+\n+#define NUM_DIMS 128\n+#define NUM_POSSIBLE_V 100000\n+#define NUM_POSSIBLE_DOCS 10000\n+#define NUM_OPS 50000\n+\n+class RndGen {\n+private:\n+    std::mt19937_64 urng;\n+    std::uniform_real_distribution<double> uf;\n+public:\n+    RndGen() : urng(0x1234deadbeef5678uLL), uf(0.0, 1.0) {}\n+\n+    double nextUniform() {\n+        return uf(urng);\n+    }\n+};\n+\n+using ConstVectorRef = vespalib::ConstArrayRef<float>;\n+\n+struct MallocPointVector {\n+    float v[NUM_DIMS];\n+    operator ConstVectorRef() const { return ConstVectorRef(v, NUM_DIMS); }\n+};\n+static MallocPointVector *aligned_alloc_pv(size_t num) {\n+    size_t num_bytes = num * sizeof(MallocPointVector);\n+    double mega_bytes = num_bytes / (1024.0*1024.0);\n+    fprintf(stderr, \"allocate %.2f MB of vectors\\n\", mega_bytes);\n+    char *mem = (char *)malloc(num_bytes + 512);\n+    mem += 512;\n+    size_t val = (size_t)mem;\n+    size_t unalign = val % 512;\n+    mem -= unalign;\n+    return reinterpret_cast<MallocPointVector *>(mem);\n+}\n+\n+void read_vector_file(MallocPointVector *p) {\n+    std::string data_set = \"sift\";\n+    std::string data_dir = \".\";\n+    char *home = getenv(\"HOME\");\n+    if (home) {\n+        data_dir = home;\n+        data_dir += \"/\" + data_set;\n+    }\n+    std::string fn = data_dir + \"/\" + data_set + \"_base.fvecs\";\n+    int fd = open(fn.c_str(), O_RDONLY);\n+    if (fd < 0) {\n+        perror(fn.c_str());\n+        exit(1);\n+    }\n+    int d;\n+    size_t rv;\n+    fprintf(stderr, \"reading %u vectors from %s\\n\", NUM_POSSIBLE_V, fn.c_str());\n+    for (uint32_t i = 0; i < NUM_POSSIBLE_V; ++i) {\n+        rv = read(fd, &d, 4);\n+        ASSERT_EQ(rv, 4u);\n+        ASSERT_EQ(d, NUM_DIMS);\n+        rv = read(fd, &p[i].v, NUM_DIMS*sizeof(float));\n+        ASSERT_EQ(rv, sizeof(MallocPointVector));\n+    }\n+    close(fd);\n+    fprintf(stderr, \"reading %u vectors OK\\n\", NUM_POSSIBLE_V);\n+}\n+\n+class MyDocVectorStore : public DocVectorAccess {\n+private:\n+    using Vector = std::vector<float>;\n+    std::vector<Vector> _vectors;\n+\n+public:\n+    MyDocVectorStore() : _vectors() {}\n+    MyDocVectorStore& set(uint32_t docid, ConstVectorRef vec) {\n+        if (docid >= _vectors.size()) {\n+            _vectors.resize(docid + 1);\n+        }\n+        _vectors[docid] = Vector(vec.begin(), vec.end());\n+        return *this;\n+    }\n+    vespalib::tensor::TypedCells get_vector(uint32_t docid) const override {\n+        ConstVectorRef ref(_vectors[docid]);\n+        return vespalib::tensor::TypedCells(ref);\n+    }\n+};\n+\n+using FloatSqEuclideanDistance = SquaredEuclideanDistance<float>;\n+using HnswIndexUP = std::unique_ptr<HnswIndex>;\n+\n+class Stressor : public ::testing::Test {\n+private:\n+    struct LoadedVectors {\n+        MallocPointVector *pv_storage;\n+        void load() {\n+            pv_storage = aligned_alloc_pv(size());\n+            read_vector_file(pv_storage);\n+        }\n+        size_t size() const { return NUM_POSSIBLE_V; }\n+        vespalib::ConstArrayRef<float> operator[] (size_t i) {\n+            return pv_storage[i];\n+        }\n+    } loaded_vectors;\n+public:\n+    BitVector::UP in_progress;\n+    BitVector::UP existing_ids;\n+    RndGen rng;\n+    MyDocVectorStore vectors;\n+    GenerationHandler gen_handler;\n+    HnswIndexUP index;\n+    vespalib::BlockingThreadStackExecutor multi_prepare_workers;\n+    vespalib::BlockingThreadStackExecutor write_thread;\n+\n+    using PrepUP = std::unique_ptr<PrepareResult>;\n+    using ReadGuard = GenerationHandler::Guard;\n+\n+    struct CompleteAddTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        PrepUP prepare_result;\n+\n+        CompleteAddTask(Stressor &p, uint32_t d, ConstVectorRef v, PrepUP r)\n+            : parent(p), docid(d), vec(v), prepare_result(std::move(r))\n+        {}\n+\n+        void run() override {\n+            parent.vectors.set(docid, vec);\n+            parent.index->complete_add_document(docid, std::move(prepare_result));\n+            parent.existing_ids->setBit(docid);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseAddTask  : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseAddTask(Stressor &p, uint32_t d, ConstVectorRef v, ReadGuard r)\n+            : parent(p), docid(d), vec(v), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto v = vespalib::tensor::TypedCells(vec);\n+            auto up = parent.index->prepare_add_document(docid, v, read_guard);\n+            auto task = std::make_unique<CompleteAddTask>(parent, docid, vec, std::move(up));\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete add task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    struct CompleteRemoveTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+\n+        CompleteRemoveTask(Stressor &p, uint32_t d)\n+            : parent(p), docid(d)\n+        {}\n+\n+        void run() override {\n+            parent.index->remove_document(docid);\n+            parent.existing_ids->clearBit(docid);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseRemoveTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseRemoveTask(Stressor &p, uint32_t d, ReadGuard r)\n+            : parent(p), docid(d), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto task = std::make_unique<CompleteRemoveTask>(parent, docid);\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete remove task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    struct CompleteUpdateTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        std::unique_ptr<PrepareResult> prepare_result;\n+\n+        CompleteUpdateTask(Stressor &p, uint32_t d, ConstVectorRef v, PrepUP r)\n+            : parent(p), docid(d), vec(v), prepare_result(std::move(r))\n+        {}\n+\n+        void run() override {\n+            parent.index->remove_document(docid);\n+            parent.vectors.set(docid, vec);\n+            parent.index->complete_add_document(docid, std::move(prepare_result));\n+            EXPECT_EQ(parent.existing_ids->testBit(docid), true);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseUpdateTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseUpdateTask(Stressor &p, uint32_t d, ConstVectorRef v, ReadGuard r)\n+            : parent(p), docid(d), vec(v), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto v = vespalib::tensor::TypedCells(vec);\n+            auto up = parent.index->prepare_add_document(docid, v, read_guard);\n+            EXPECT_EQ(bool(up), true);\n+            auto task = std::make_unique<CompleteUpdateTask>(parent, docid, vec, std::move(up));\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete remove task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    Stressor()\n+        : loaded_vectors(),\n+          in_progress(BitVector::create(NUM_POSSIBLE_DOCS)),\n+          existing_ids(BitVector::create(NUM_POSSIBLE_DOCS)),\n+          rng(),\n+          vectors(),\n+          gen_handler(),\n+          index(),\n+          multi_prepare_workers(10, 128*1024, 50),\n+          write_thread(1, 128*1024, 15)\n+    {\n+        loaded_vectors.load();\n+    }\n+\n+    ~Stressor() {}\n+\n+    void init() {\n+        uint32_t m = 16;\n+        index = std::make_unique<HnswIndex>(vectors, std::make_unique<FloatSqEuclideanDistance>(),\n+                                            std::make_unique<InvLogLevelGenerator>(m),\n+                                            HnswIndex::Config(2*m, m, 200, true));\n+        vectors.set(NUM_POSSIBLE_DOCS, loaded_vectors[0]);\n+    }\n+    size_t get_rnd(size_t size) {\n+        return rng.nextUniform() * size;\n+    }\n+    void add_document(uint32_t docid) {\n+        size_t vec_num = get_rnd(loaded_vectors.size());\n+        ConstVectorRef vec = loaded_vectors[vec_num];\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseAddTask>(*this, docid, vec, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));\n+        ASSERT_EQ(bool(r), false);\n+    }\n+    void remove_document(uint32_t docid) {\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseRemoveTask>(*this, docid, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));\n+        ASSERT_EQ(bool(r), false);\n+    }\n+    void update_document(uint32_t docid) {\n+        size_t vec_num = get_rnd(loaded_vectors.size());\n+        ConstVectorRef vec = loaded_vectors[vec_num];\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseUpdateTask>(*this, docid, vec, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));", "originalCommit": "e01810c179b2593d7eae286fca7664eb6065d0fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyNzQzNQ==", "url": "https://github.com/vespa-engine/vespa/pull/13572#discussion_r441527435", "bodyText": "Is this racing with what happens in gen_operation(). Should we protect it with a mutex?", "author": "geirst", "createdAt": "2020-06-17T13:03:21Z", "path": "searchlib/src/tests/tensor/hnsw_index/stress_hnsw_mt.cpp", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright 2020 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/tensor/dense/typed_cells.h>\n+#include <vespa/searchlib/common/bitvector.h>\n+#include <vespa/searchlib/tensor/distance_functions.h>\n+#include <vespa/searchlib/tensor/doc_vector_access.h>\n+#include <vespa/searchlib/tensor/hnsw_index.h>\n+#include <vespa/searchlib/tensor/random_level_generator.h>\n+#include <vespa/searchlib/tensor/inv_log_level_generator.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <vespa/vespalib/util/generationhandler.h>\n+#include <vespa/vespalib/data/slime/slime.h>\n+#include <vespa/vespalib/util/threadstackexecutor.h>\n+#include <vespa/vespalib/util/blockingthreadstackexecutor.h>\n+#include <vespa/vespalib/util/gate.h>\n+#include <vespa/vespalib/util/lambdatask.h>\n+\n+#include <vector>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <chrono>\n+#include <cstdlib>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\"stress_hnsw_mt\");\n+\n+using vespalib::GenerationHandler;\n+using vespalib::MemoryUsage;\n+using namespace search::tensor;\n+using namespace vespalib::slime;\n+using vespalib::Slime;\n+using search::BitVector;\n+\n+#define NUM_DIMS 128\n+#define NUM_POSSIBLE_V 100000\n+#define NUM_POSSIBLE_DOCS 10000\n+#define NUM_OPS 50000\n+\n+class RndGen {\n+private:\n+    std::mt19937_64 urng;\n+    std::uniform_real_distribution<double> uf;\n+public:\n+    RndGen() : urng(0x1234deadbeef5678uLL), uf(0.0, 1.0) {}\n+\n+    double nextUniform() {\n+        return uf(urng);\n+    }\n+};\n+\n+using ConstVectorRef = vespalib::ConstArrayRef<float>;\n+\n+struct MallocPointVector {\n+    float v[NUM_DIMS];\n+    operator ConstVectorRef() const { return ConstVectorRef(v, NUM_DIMS); }\n+};\n+static MallocPointVector *aligned_alloc_pv(size_t num) {\n+    size_t num_bytes = num * sizeof(MallocPointVector);\n+    double mega_bytes = num_bytes / (1024.0*1024.0);\n+    fprintf(stderr, \"allocate %.2f MB of vectors\\n\", mega_bytes);\n+    char *mem = (char *)malloc(num_bytes + 512);\n+    mem += 512;\n+    size_t val = (size_t)mem;\n+    size_t unalign = val % 512;\n+    mem -= unalign;\n+    return reinterpret_cast<MallocPointVector *>(mem);\n+}\n+\n+void read_vector_file(MallocPointVector *p) {\n+    std::string data_set = \"sift\";\n+    std::string data_dir = \".\";\n+    char *home = getenv(\"HOME\");\n+    if (home) {\n+        data_dir = home;\n+        data_dir += \"/\" + data_set;\n+    }\n+    std::string fn = data_dir + \"/\" + data_set + \"_base.fvecs\";\n+    int fd = open(fn.c_str(), O_RDONLY);\n+    if (fd < 0) {\n+        perror(fn.c_str());\n+        exit(1);\n+    }\n+    int d;\n+    size_t rv;\n+    fprintf(stderr, \"reading %u vectors from %s\\n\", NUM_POSSIBLE_V, fn.c_str());\n+    for (uint32_t i = 0; i < NUM_POSSIBLE_V; ++i) {\n+        rv = read(fd, &d, 4);\n+        ASSERT_EQ(rv, 4u);\n+        ASSERT_EQ(d, NUM_DIMS);\n+        rv = read(fd, &p[i].v, NUM_DIMS*sizeof(float));\n+        ASSERT_EQ(rv, sizeof(MallocPointVector));\n+    }\n+    close(fd);\n+    fprintf(stderr, \"reading %u vectors OK\\n\", NUM_POSSIBLE_V);\n+}\n+\n+class MyDocVectorStore : public DocVectorAccess {\n+private:\n+    using Vector = std::vector<float>;\n+    std::vector<Vector> _vectors;\n+\n+public:\n+    MyDocVectorStore() : _vectors() {}\n+    MyDocVectorStore& set(uint32_t docid, ConstVectorRef vec) {\n+        if (docid >= _vectors.size()) {\n+            _vectors.resize(docid + 1);\n+        }\n+        _vectors[docid] = Vector(vec.begin(), vec.end());\n+        return *this;\n+    }\n+    vespalib::tensor::TypedCells get_vector(uint32_t docid) const override {\n+        ConstVectorRef ref(_vectors[docid]);\n+        return vespalib::tensor::TypedCells(ref);\n+    }\n+};\n+\n+using FloatSqEuclideanDistance = SquaredEuclideanDistance<float>;\n+using HnswIndexUP = std::unique_ptr<HnswIndex>;\n+\n+class Stressor : public ::testing::Test {\n+private:\n+    struct LoadedVectors {\n+        MallocPointVector *pv_storage;\n+        void load() {\n+            pv_storage = aligned_alloc_pv(size());\n+            read_vector_file(pv_storage);\n+        }\n+        size_t size() const { return NUM_POSSIBLE_V; }\n+        vespalib::ConstArrayRef<float> operator[] (size_t i) {\n+            return pv_storage[i];\n+        }\n+    } loaded_vectors;\n+public:\n+    BitVector::UP in_progress;\n+    BitVector::UP existing_ids;\n+    RndGen rng;\n+    MyDocVectorStore vectors;\n+    GenerationHandler gen_handler;\n+    HnswIndexUP index;\n+    vespalib::BlockingThreadStackExecutor multi_prepare_workers;\n+    vespalib::BlockingThreadStackExecutor write_thread;\n+\n+    using PrepUP = std::unique_ptr<PrepareResult>;\n+    using ReadGuard = GenerationHandler::Guard;\n+\n+    struct CompleteAddTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        PrepUP prepare_result;\n+\n+        CompleteAddTask(Stressor &p, uint32_t d, ConstVectorRef v, PrepUP r)\n+            : parent(p), docid(d), vec(v), prepare_result(std::move(r))\n+        {}\n+\n+        void run() override {\n+            parent.vectors.set(docid, vec);\n+            parent.index->complete_add_document(docid, std::move(prepare_result));\n+            parent.existing_ids->setBit(docid);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseAddTask  : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseAddTask(Stressor &p, uint32_t d, ConstVectorRef v, ReadGuard r)\n+            : parent(p), docid(d), vec(v), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto v = vespalib::tensor::TypedCells(vec);\n+            auto up = parent.index->prepare_add_document(docid, v, read_guard);\n+            auto task = std::make_unique<CompleteAddTask>(parent, docid, vec, std::move(up));\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete add task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    struct CompleteRemoveTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+\n+        CompleteRemoveTask(Stressor &p, uint32_t d)\n+            : parent(p), docid(d)\n+        {}\n+\n+        void run() override {\n+            parent.index->remove_document(docid);\n+            parent.existing_ids->clearBit(docid);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseRemoveTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseRemoveTask(Stressor &p, uint32_t d, ReadGuard r)\n+            : parent(p), docid(d), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto task = std::make_unique<CompleteRemoveTask>(parent, docid);\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete remove task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    struct CompleteUpdateTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        std::unique_ptr<PrepareResult> prepare_result;\n+\n+        CompleteUpdateTask(Stressor &p, uint32_t d, ConstVectorRef v, PrepUP r)\n+            : parent(p), docid(d), vec(v), prepare_result(std::move(r))\n+        {}\n+\n+        void run() override {\n+            parent.index->remove_document(docid);\n+            parent.vectors.set(docid, vec);\n+            parent.index->complete_add_document(docid, std::move(prepare_result));\n+            EXPECT_EQ(parent.existing_ids->testBit(docid), true);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseUpdateTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseUpdateTask(Stressor &p, uint32_t d, ConstVectorRef v, ReadGuard r)\n+            : parent(p), docid(d), vec(v), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto v = vespalib::tensor::TypedCells(vec);\n+            auto up = parent.index->prepare_add_document(docid, v, read_guard);\n+            EXPECT_EQ(bool(up), true);\n+            auto task = std::make_unique<CompleteUpdateTask>(parent, docid, vec, std::move(up));\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete remove task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    Stressor()\n+        : loaded_vectors(),\n+          in_progress(BitVector::create(NUM_POSSIBLE_DOCS)),\n+          existing_ids(BitVector::create(NUM_POSSIBLE_DOCS)),\n+          rng(),\n+          vectors(),\n+          gen_handler(),\n+          index(),\n+          multi_prepare_workers(10, 128*1024, 50),\n+          write_thread(1, 128*1024, 15)\n+    {\n+        loaded_vectors.load();\n+    }\n+\n+    ~Stressor() {}\n+\n+    void init() {\n+        uint32_t m = 16;\n+        index = std::make_unique<HnswIndex>(vectors, std::make_unique<FloatSqEuclideanDistance>(),\n+                                            std::make_unique<InvLogLevelGenerator>(m),\n+                                            HnswIndex::Config(2*m, m, 200, true));\n+        vectors.set(NUM_POSSIBLE_DOCS, loaded_vectors[0]);\n+    }\n+    size_t get_rnd(size_t size) {\n+        return rng.nextUniform() * size;\n+    }\n+    void add_document(uint32_t docid) {\n+        size_t vec_num = get_rnd(loaded_vectors.size());\n+        ConstVectorRef vec = loaded_vectors[vec_num];\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseAddTask>(*this, docid, vec, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));\n+        ASSERT_EQ(bool(r), false);\n+    }\n+    void remove_document(uint32_t docid) {\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseRemoveTask>(*this, docid, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));\n+        ASSERT_EQ(bool(r), false);\n+    }\n+    void update_document(uint32_t docid) {\n+        size_t vec_num = get_rnd(loaded_vectors.size());\n+        ConstVectorRef vec = loaded_vectors[vec_num];\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseUpdateTask>(*this, docid, vec, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));\n+        ASSERT_EQ(bool(r), false);\n+    }\n+    void commit(uint32_t docid) {\n+        index->transfer_hold_lists(gen_handler.getCurrentGeneration());\n+        gen_handler.incGeneration();\n+        gen_handler.updateFirstUsedGeneration();\n+        index->trim_hold_lists(gen_handler.getFirstUsedGeneration());\n+        in_progress->clearBit(docid);", "originalCommit": "e01810c179b2593d7eae286fca7664eb6065d0fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyNzg5MQ==", "url": "https://github.com/vespa-engine/vespa/pull/13572#discussion_r441527891", "bodyText": "Consider rename 'me' -> 'me_docid' / 'self_docid'", "author": "geirst", "createdAt": "2020-06-17T13:04:08Z", "path": "searchlib/src/vespa/searchlib/tensor/hnsw_index.cpp", "diffHunk": "@@ -322,14 +322,21 @@ HnswIndex::internal_prepare_add(uint32_t docid, TypedCells input_vector) const\n }\n \n HnswIndex::LinkArray \n-HnswIndex::filter_valid_docids(const LinkArrayRef &docids)\n+HnswIndex::filter_valid_docids(uint32_t level, const LinkArrayRef &docids, uint32_t me)", "originalCommit": "fb2b67a51102aa4ae3bfa9e1432d00073fd68e89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24f3af2b0d89353dd13c73f29261d40b59fa7e0d", "url": "https://github.com/vespa-engine/vespa/commit/24f3af2b0d89353dd13c73f29261d40b59fa7e0d", "message": "also check graph symmetry", "committedDate": "2020-06-17T13:15:40Z", "type": "commit"}, {"oid": "f9be44201661bb12c5999cd2329ccea28817e246", "url": "https://github.com/vespa-engine/vespa/commit/f9be44201661bb12c5999cd2329ccea28817e246", "message": "refactor task data into common base class", "committedDate": "2020-06-17T13:15:50Z", "type": "commit"}, {"oid": "44ebaa3f2345a17f2d90f1fd5cbb3463e4fd9b1f", "url": "https://github.com/vespa-engine/vespa/commit/44ebaa3f2345a17f2d90f1fd5cbb3463e4fd9b1f", "message": "minor stress-test tweaks:\n\n* update copyright line\n* cleanup unused includes etc\n* increase the numbers to test a lot more", "committedDate": "2020-06-17T14:34:05Z", "type": "commit"}, {"oid": "43d9d52c85ca09bdacc5b35bf69b3c0f0adb277f", "url": "https://github.com/vespa-engine/vespa/commit/43d9d52c85ca09bdacc5b35bf69b3c0f0adb277f", "message": "rename me -> self_docid\n\n* other tests should now ensure that we don't get self-references.", "committedDate": "2020-06-17T14:34:25Z", "type": "commit"}, {"oid": "ba91880f54edc7e8179e00c1ac50b819c7a1a0cc", "url": "https://github.com/vespa-engine/vespa/commit/ba91880f54edc7e8179e00c1ac50b819c7a1a0cc", "message": "add mutex protecting in_progress bitvector", "committedDate": "2020-06-17T15:18:18Z", "type": "commit"}, {"oid": "05233b5d5eb97778c541bbc12e74ae07e6c74de7", "url": "https://github.com/vespa-engine/vespa/commit/05233b5d5eb97778c541bbc12e74ae07e6c74de7", "message": "rewrite with futures", "committedDate": "2020-06-17T16:27:41Z", "type": "commit"}, {"oid": "741bb36004486c11598419613bfd6a29224f5327", "url": "https://github.com/vespa-engine/vespa/commit/741bb36004486c11598419613bfd6a29224f5327", "message": "print more statistics", "committedDate": "2020-06-18T07:13:36Z", "type": "commit"}, {"oid": "48f6c00d94bf01352bb2d46ef03ddee86c1cf0c7", "url": "https://github.com/vespa-engine/vespa/commit/48f6c00d94bf01352bb2d46ef03ddee86c1cf0c7", "message": "update test now that TODO is done", "committedDate": "2020-06-18T08:52:03Z", "type": "commit"}]}