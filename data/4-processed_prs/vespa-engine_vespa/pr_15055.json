{"pr_number": 15055, "pr_title": "Jonmv/wait for running steps when aborting and finishing ru", "pr_createdAt": "2020-10-27T18:08:04Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/15055", "timeline": [{"oid": "555f5f9c1c1d59308f0cc2299b81da6298b90337", "url": "https://github.com/vespa-engine/vespa/commit/555f5f9c1c1d59308f0cc2299b81da6298b90337", "message": "Wait for all steps to finish before finishing a run", "committedDate": "2020-10-27T18:06:13Z", "type": "commit"}, {"oid": "25aebb11668d399345aa38d67b4adb97423827f9", "url": "https://github.com/vespa-engine/vespa/commit/25aebb11668d399345aa38d67b4adb97423827f9", "message": "More threads for JobRunner, and name them", "committedDate": "2020-10-27T18:06:33Z", "type": "commit"}, {"oid": "e9bd7b1f84bfce80592c222198b7bb7a912a710e", "url": "https://github.com/vespa-engine/vespa/commit/e9bd7b1f84bfce80592c222198b7bb7a912a710e", "message": "... and now, for something complete different (simplify)", "committedDate": "2020-10-27T18:07:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM0MjQ1OQ==", "url": "https://github.com/vespa-engine/vespa/pull/15055#discussion_r513342459", "bodyText": "Btw, I don't get how locking works in the JobRunner maintainer.  Shouldn't the maintainer\n\nacquire a global zk lock\nread all Runs and decide on some actions, then either do those actions or store to zk that those actions are in progress (using ephemeral nodes)\nunlock the global zk lock\n\nInstead it looks like e.g. two JobRunner may decide to finish concurrently?  Or one thread decide to abort a job whose step may already be processed in another thread.", "author": "hakonhall", "createdAt": "2020-10-28T10:41:41Z", "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/deployment/JobController.java", "diffHunk": "@@ -353,7 +354,10 @@ public void setStartTimestamp(RunId id, Instant timestamp, LockedStep step) {\n     }\n \n     /** Changes the status of the given run to inactive, and stores it as a historic run. */\n-    public void finish(RunId id) {\n+    public void finish(RunId id) throws TimeoutException {\n+        // Ensure no step is still running before we finish the run \u2014 report depends transitively on all the other steps.\n+        locked(id.application(), id.type(), report, __ -> { });", "originalCommit": "e9bd7b1f84bfce80592c222198b7bb7a912a710e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM0MzU1Mw==", "url": "https://github.com/vespa-engine/vespa/pull/15055#discussion_r513343553", "bodyText": "or perhaps the read of Runs is fine, but for each Run, a lock must be held before deciding to abort() or advancement", "author": "hakonhall", "createdAt": "2020-10-28T10:43:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM0MjQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM1MzA0NA==", "url": "https://github.com/vespa-engine/vespa/pull/15055#discussion_r513353044", "bodyText": "Instead it looks like e.g. two JobRunner may decide to finish concurrently? Or one thread decide to abort a job whose step may already be processed in another thread.\n\nYes:\nFinishing a run (the actual state change) is guarded by a job-specific lock, so is already OK.\nThe second case is exactly what this fixes: current code doesn't wait for a running step to complete before finishing the run, which means any further logging by that step is lost.\nSteps have separate locks so they can run concurrently. This could be implemented as reading and writing the step status under lock as well, but I felt the lock-per-step was clearer.\nFinishing the run only when each step status is non-running requires the abort signal to cause this status to be set for each step, which can only happen after any currently running steps release their locks, and just requires more logic.", "author": "jonmv", "createdAt": "2020-10-28T10:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM0MjQ1OQ=="}], "type": "inlineReview"}]}