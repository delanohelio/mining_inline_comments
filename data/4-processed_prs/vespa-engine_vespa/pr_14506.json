{"pr_number": 14506, "pr_title": "Arnej/add new encode decode", "pr_createdAt": "2020-09-23T12:05:23Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/14506", "timeline": [{"oid": "3f9c2f64823b4b65b5164ec28e36e13912817f18", "url": "https://github.com/vespa-engine/vespa/commit/3f9c2f64823b4b65b5164ec28e36e13912817f18", "message": "add new_encode and new_decode\n\n* move common encode/decode logic from\n  simple_tensor.cpp into codec.h / codec.cpp\n* encoding and decoding using new Value API\n  is in value_codec.h, both for binary format\n  and to/from TensorSpec\n* will move implementation of TensorSpec\n  conversions later\n* extend unit test for tensor serialization\n  to also test new_encode and new_decode\n* add hack in CreateValueFromTensorSpec to\n  handle a spec without any cells but\n  no mapped dimensions, this was used by\n  unit test", "committedDate": "2020-09-23T12:04:08Z", "type": "commit"}, {"oid": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8", "url": "https://github.com/vespa-engine/vespa/commit/dff267e0d6323c3ad1ae10d3193e4c18c823a1b8", "message": "peek into nbostream instead of copying strings", "committedDate": "2020-09-23T12:04:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUyNzk4Mg==", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493527982", "bodyText": "I suggest we call this encode_value. Also, we could mention that this requires new api compliance in the comment.", "author": "havardpe", "createdAt": "2020-09-23T12:26:37Z", "path": "eval/src/vespa/eval/eval/value_codec.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"simple_value.h\"\n+#include <vespa/vespalib/stllike/string.h>\n+\n+namespace vespalib { class nbostream; }\n+\n+namespace vespalib::eval {\n+\n+/**\n+ * encode a value to binary format\n+ **/\n+void new_encode(const Value &value, nbostream &output);", "originalCommit": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUyODI1OA==", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493528258", "bodyText": "I suggest we call this decode_value", "author": "havardpe", "createdAt": "2020-09-23T12:26:59Z", "path": "eval/src/vespa/eval/eval/value_codec.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"simple_value.h\"\n+#include <vespa/vespalib/stllike/string.h>\n+\n+namespace vespalib { class nbostream; }\n+\n+namespace vespalib::eval {\n+\n+/**\n+ * encode a value to binary format\n+ **/\n+void new_encode(const Value &value, nbostream &output);\n+\n+/**\n+ * decode a value from binary format\n+ **/\n+std::unique_ptr<Value> new_decode(nbostream &input, const ValueBuilderFactory &factory);", "originalCommit": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzNTg5Mg==", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493535892", "bodyText": "this is a vital part of the SimpleTensor implementation that was re-used for encoding purposes, I do not think this should be moved out of like this. I think we should keep this one in SimpleTensor as-is and add a similar DecodePlan to value_codec.cpp", "author": "havardpe", "createdAt": "2020-09-23T12:35:02Z", "path": "eval/src/vespa/eval/eval/codec.h", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"simple_tensor.h\"\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <cassert>\n+\n+namespace vespalib::eval::codec {\n+\n+using CellType = ValueType::CellType;\n+using IndexList = std::vector<size_t>;\n+\n+constexpr uint32_t DOUBLE_CELL_TYPE = 0;\n+constexpr uint32_t FLOAT_CELL_TYPE = 1;\n+\n+inline uint32_t cell_type_to_id(CellType cell_type) {\n+    switch (cell_type) {\n+    case CellType::DOUBLE: return DOUBLE_CELL_TYPE;\n+    case CellType::FLOAT: return FLOAT_CELL_TYPE;\n+    }\n+    abort();\n+}\n+\n+inline CellType id_to_cell_type(uint32_t id) {\n+    switch (id) {\n+    case DOUBLE_CELL_TYPE: return CellType::DOUBLE;\n+    case FLOAT_CELL_TYPE: return CellType::FLOAT;\n+    }\n+    abort();\n+}\n+\n+/**\n+ * Meta information about how a type can be decomposed into mapped and\n+ * indexed dimensions and also how large each block is. A block is a\n+ * dense-subspace consisting of all indexed dimensions that is\n+ * uniquely specified by the labels of all mapped dimensions.\n+ **/\n+struct TypeMeta {", "originalCommit": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MTAwMA==", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493541000", "bodyText": "not really a hack since converting from a spec should use 0.0 as default value for all existing non-defined cells. good catch though.", "author": "havardpe", "createdAt": "2020-09-23T12:40:32Z", "path": "eval/src/vespa/eval/eval/simple_value.cpp", "diffHunk": "@@ -45,6 +46,10 @@ struct CreateValueFromTensorSpec {\n             }\n             map[sparse_key][dense_key] = entry.second;\n         }\n+        // hack for passing some (invalid?) unit tests", "originalCommit": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MzIxMQ==", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493543211", "bodyText": "prefer using {} or similar instead of SparseKey()", "author": "havardpe", "createdAt": "2020-09-23T12:42:36Z", "path": "eval/src/vespa/eval/eval/simple_value.cpp", "diffHunk": "@@ -45,6 +46,10 @@ struct CreateValueFromTensorSpec {\n             }\n             map[sparse_key][dense_key] = entry.second;\n         }\n+        // hack for passing some (invalid?) unit tests\n+        if (spec.cells().empty() && type.count_mapped_dimensions() == 0) {\n+            map[SparseKey()][0] = 0;", "originalCommit": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0Mzg3MQ==", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493543871", "bodyText": "prefer checking 'map' over spec", "author": "havardpe", "createdAt": "2020-09-23T12:43:14Z", "path": "eval/src/vespa/eval/eval/simple_value.cpp", "diffHunk": "@@ -45,6 +46,10 @@ struct CreateValueFromTensorSpec {\n             }\n             map[sparse_key][dense_key] = entry.second;\n         }\n+        // hack for passing some (invalid?) unit tests\n+        if (spec.cells().empty() && type.count_mapped_dimensions() == 0) {", "originalCommit": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b81b7f5e10eaefb611616fa516b4a0851cd1e645", "url": "https://github.com/vespa-engine/vespa/commit/b81b7f5e10eaefb611616fa516b4a0851cd1e645", "message": "revert moving code into codec.h", "committedDate": "2020-09-23T13:23:32Z", "type": "commit"}, {"oid": "e6bb3101ca84e92e2335d1710e42c04ac562b1d2", "url": "https://github.com/vespa-engine/vespa/commit/e6bb3101ca84e92e2335d1710e42c04ac562b1d2", "message": "move Spec conversion to value_codec.cpp", "committedDate": "2020-09-23T13:30:05Z", "type": "commit"}, {"oid": "10169943144990208e11529109d30febccb49756", "url": "https://github.com/vespa-engine/vespa/commit/10169943144990208e11529109d30febccb49756", "message": "cleanup hack", "committedDate": "2020-09-23T13:32:05Z", "type": "commit"}, {"oid": "05442b391e2feedae7cbea9dd53a01caf26da5f1", "url": "https://github.com/vespa-engine/vespa/commit/05442b391e2feedae7cbea9dd53a01caf26da5f1", "message": "add unit test for value_codec.h functions", "committedDate": "2020-09-23T13:57:19Z", "type": "commit"}, {"oid": "b1181249596fdbff748aeaad958c3d329cb56c62", "url": "https://github.com/vespa-engine/vespa/commit/b1181249596fdbff748aeaad958c3d329cb56c62", "message": "simplify value_codec some", "committedDate": "2020-09-23T14:08:53Z", "type": "commit"}, {"oid": "b632540821ed7c3657b93f926aa8719f1d7fc9e1", "url": "https://github.com/vespa-engine/vespa/commit/b632540821ed7c3657b93f926aa8719f1d7fc9e1", "message": "refactor without TypeMeta", "committedDate": "2020-09-23T15:22:24Z", "type": "commit"}, {"oid": "959ae0f84ec4b62c6ac170451924a0a3bd4eaaed", "url": "https://github.com/vespa-engine/vespa/commit/959ae0f84ec4b62c6ac170451924a0a3bd4eaaed", "message": "use typify_invoke for new_encode also", "committedDate": "2020-09-23T16:19:14Z", "type": "commit"}, {"oid": "447ef46eff9c2247e6db8d559f2dc62d3d0d499e", "url": "https://github.com/vespa-engine/vespa/commit/447ef46eff9c2247e6db8d559f2dc62d3d0d499e", "message": "cosmetic test fixes", "committedDate": "2020-09-23T16:22:30Z", "type": "commit"}, {"oid": "9a11a8d39ee7138e81fdc3d3b0adfd58cbeea84a", "url": "https://github.com/vespa-engine/vespa/commit/9a11a8d39ee7138e81fdc3d3b0adfd58cbeea84a", "message": "rename new API\n\nnew_encode -> encode_value\nnew_decode -> decode_value", "committedDate": "2020-09-23T16:36:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc0NDA1OA==", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493744058", "bodyText": "should add unit test for this", "author": "havardpe", "createdAt": "2020-09-23T16:52:51Z", "path": "eval/src/vespa/eval/eval/value_type.h", "diffHunk": "@@ -60,10 +60,12 @@ class ValueType\n     bool is_tensor() const { return (_type == Type::TENSOR); }\n     bool is_sparse() const;\n     bool is_dense() const;\n+    size_t count_indexed_dimensions() const;", "originalCommit": "9a11a8d39ee7138e81fdc3d3b0adfd58cbeea84a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc0NDIxMg==", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493744212", "bodyText": "should add unit test for this", "author": "havardpe", "createdAt": "2020-09-23T16:53:05Z", "path": "eval/src/vespa/eval/eval/value_type.h", "diffHunk": "@@ -60,10 +60,12 @@ class ValueType\n     bool is_tensor() const { return (_type == Type::TENSOR); }\n     bool is_sparse() const;\n     bool is_dense() const;\n+    size_t count_indexed_dimensions() const;\n     size_t count_mapped_dimensions() const;\n     size_t dense_subspace_size() const;\n     const std::vector<Dimension> &dimensions() const { return _dimensions; }\n     std::vector<Dimension> nontrivial_indexed_dimensions() const;\n+    std::vector<Dimension> indexed_dimensions() const;", "originalCommit": "9a11a8d39ee7138e81fdc3d3b0adfd58cbeea84a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc0NDUwNg==", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493744506", "bodyText": "should also contain classes below", "author": "havardpe", "createdAt": "2020-09-23T16:53:35Z", "path": "eval/src/vespa/eval/eval/value_codec.cpp", "diffHunk": "@@ -0,0 +1,304 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"value_codec.h\"\n+#include \"tensor_spec.h\"\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/typify.h>\n+\n+namespace vespalib::eval {\n+\n+namespace {\n+\n+using CellType = ValueType::CellType;\n+using IndexList = std::vector<size_t>;\n+\n+constexpr uint32_t DOUBLE_CELL_TYPE = 0;\n+constexpr uint32_t FLOAT_CELL_TYPE = 1;\n+\n+inline uint32_t cell_type_to_id(CellType cell_type) {\n+    switch (cell_type) {\n+    case CellType::DOUBLE: return DOUBLE_CELL_TYPE;\n+    case CellType::FLOAT: return FLOAT_CELL_TYPE;\n+    }\n+    abort();\n+}\n+\n+inline CellType id_to_cell_type(uint32_t id) {\n+    switch (id) {\n+    case DOUBLE_CELL_TYPE: return CellType::DOUBLE;\n+    case FLOAT_CELL_TYPE: return CellType::FLOAT;\n+    }\n+    abort();\n+}\n+\n+struct Format {\n+    bool     has_sparse;\n+    bool     has_dense;\n+    bool     with_cell_type;\n+    uint32_t tag;\n+    explicit Format(const ValueType &type)\n+        : has_sparse(type.count_mapped_dimensions() > 0),\n+          has_dense((type.count_indexed_dimensions() > 0) || !has_sparse),\n+          with_cell_type(type.cell_type() != CellType::DOUBLE),\n+          tag((has_sparse ? 0x1 : 0) | (has_dense ? 0x2 : 0) | (with_cell_type ? 0x4 : 0)) {}\n+    explicit Format(uint32_t tag_in)\n+        : has_sparse((tag_in & 0x1) != 0),\n+          has_dense((tag_in & 0x2) != 0),\n+          with_cell_type((tag_in & 0x4) != 0),\n+          tag(tag_in) {}\n+    ~Format() {}\n+};\n+\n+void maybe_encode_cell_type(nbostream &output, const Format &format, CellType cell_type) {\n+    if (format.with_cell_type) {\n+        output.putInt1_4Bytes(cell_type_to_id(cell_type));\n+    }\n+}\n+\n+void encode_type(nbostream &output, const Format &format, const ValueType &type) {\n+    maybe_encode_cell_type(output, format, type.cell_type());\n+    if (format.has_sparse) {\n+        const auto & dims = type.mapped_dimensions();\n+        output.putInt1_4Bytes(dims.size());\n+        for (const auto & dim : dims) {\n+            output.writeSmallString(dim.name);\n+        }\n+    }\n+    if (format.has_dense) {\n+        const auto & dims = type.indexed_dimensions();\n+        output.putInt1_4Bytes(dims.size());\n+        for (const auto & dim : dims) {\n+            output.writeSmallString(dim.name);\n+            output.putInt1_4Bytes(dim.size);\n+        }\n+    }\n+}\n+\n+void maybe_encode_num_blocks(nbostream &output, bool has_mapped_dims, size_t num_blocks) {\n+    if (has_mapped_dims) {\n+        output.putInt1_4Bytes(num_blocks);\n+    }\n+}\n+\n+CellType maybe_decode_cell_type(nbostream &input, const Format &format) {\n+    if (format.with_cell_type) {\n+        return id_to_cell_type(input.getInt1_4Bytes());\n+    }\n+    return CellType::DOUBLE;\n+}\n+\n+ValueType decode_type(nbostream &input, const Format &format) {\n+    CellType cell_type = maybe_decode_cell_type(input, format);\n+    std::vector<ValueType::Dimension> dim_list;\n+    if (format.has_sparse) {\n+        size_t cnt = input.getInt1_4Bytes();\n+        for (size_t i = 0; i < cnt; ++i) {\n+            vespalib::string name;\n+            input.readSmallString(name);\n+            dim_list.emplace_back(name);\n+        }\n+    }\n+    if (format.has_dense) {\n+        size_t cnt = input.getInt1_4Bytes();\n+        for (size_t i = 0; i < cnt; ++i) {\n+            vespalib::string name;\n+            input.readSmallString(name);\n+            dim_list.emplace_back(name, input.getInt1_4Bytes());\n+        }\n+    }\n+    return ValueType::tensor_type(std::move(dim_list), cell_type);\n+}\n+\n+size_t maybe_decode_num_blocks(nbostream &input, bool has_mapped_dims, const Format &format) {\n+    if (has_mapped_dims || !format.has_dense) {\n+        return input.getInt1_4Bytes();\n+    }\n+    return 1;\n+}\n+\n+void encode_mapped_labels(nbostream &output, size_t num_mapped_dims, const std::vector<vespalib::stringref> &addr) {\n+    for (size_t i = 0; i < num_mapped_dims; ++i) {\n+        output.writeSmallString(addr[i]);\n+    }\n+}\n+\n+void decode_mapped_labels(nbostream &input, size_t num_mapped_dims, std::vector<vespalib::stringref> &addr) {\n+    for (size_t i = 0; i < num_mapped_dims; ++i) {\n+        size_t strSize = input.getInt1_4Bytes();\n+        addr[i] = vespalib::stringref(input.peek(), strSize);\n+        input.adjustReadPos(strSize);\n+    }\n+}\n+\n+\n+template<typename T>\n+void decode_cells(nbostream &input, size_t num_cells, ArrayRef<T> dst)\n+{\n+    T value;\n+    for (size_t i = 0; i < num_cells; ++i) {\n+        input >> value;\n+        dst[i] = value;\n+    }\n+}\n+\n+struct DecodeState {\n+    const ValueType &type;\n+    const size_t subspace_size;\n+    const size_t num_blocks;\n+    const size_t num_mapped_dims;\n+};\n+\n+struct ContentDecoder {\n+    template<typename T>\n+    static std::unique_ptr<Value> invoke(nbostream &input, const DecodeState &state, const ValueBuilderFactory &factory) {\n+        std::vector<vespalib::stringref> address(state.num_mapped_dims);\n+        auto builder = factory.create_value_builder<T>(state.type, state.num_mapped_dims, state.subspace_size, state.num_blocks);\n+        for (size_t i = 0; i < state.num_blocks; ++i) {\n+            decode_mapped_labels(input, state.num_mapped_dims, address);\n+            auto block_cells = builder->add_subspace(address);\n+            decode_cells(input, state.subspace_size, block_cells);\n+        }\n+        return builder->build(std::move(builder));\n+    }\n+};\n+\n+struct CreateValueFromTensorSpec {\n+    template <typename T> static std::unique_ptr<Value> invoke(const ValueType &type, const TensorSpec &spec, const ValueBuilderFactory &factory) {\n+        using SparseKey = std::vector<vespalib::stringref>;\n+        using DenseMap = std::map<size_t,T>;\n+        std::map<SparseKey,DenseMap> map;\n+        for (const auto &entry: spec.cells()) {\n+            SparseKey sparse_key;\n+            size_t dense_key = 0;\n+            for (const auto &dim: type.dimensions()) {\n+                auto pos = entry.first.find(dim.name);\n+                assert(pos != entry.first.end());\n+                assert(pos->second.is_mapped() == dim.is_mapped());\n+                if (dim.is_mapped()) {\n+                    sparse_key.emplace_back(pos->second.name);\n+                } else {\n+                    dense_key = (dense_key * dim.size) + pos->second.index;\n+                }\n+            }\n+            map[sparse_key][dense_key] = entry.second;\n+        }\n+        // if spec is missing the required dense space, add it here:\n+        if (map.empty() && type.count_mapped_dimensions() == 0) {\n+            map[{}][0] = 0;\n+        }\n+        auto builder = factory.create_value_builder<T>(type, type.count_mapped_dimensions(), type.dense_subspace_size(), map.size());\n+        for (const auto &entry: map) {\n+            auto subspace = builder->add_subspace(entry.first);\n+            for (const auto &cell: entry.second) {\n+                subspace[cell.first] = cell.second;\n+            }\n+        }\n+        return builder->build(std::move(builder));\n+    }\n+};\n+\n+struct CreateTensorSpecFromValue {\n+    template <typename T> static TensorSpec invoke(const Value &value) {\n+        auto cells = value.cells().typify<T>();\n+        TensorSpec spec(value.type().to_spec());\n+        size_t subspace_id = 0;\n+        size_t subspace_size = value.type().dense_subspace_size();\n+        std::vector<vespalib::stringref> labels(value.type().count_mapped_dimensions());\n+        std::vector<vespalib::stringref*> label_refs;\n+        for (auto &label: labels) {\n+            label_refs.push_back(&label);\n+        }\n+        auto view = value.index().create_view({});\n+        view->lookup({});\n+        while (view->next_result(label_refs, subspace_id)) {\n+            size_t label_idx = 0;\n+            TensorSpec::Address addr;\n+            for (const auto &dim: value.type().dimensions()) {\n+                if (dim.is_mapped()) {\n+                    addr.emplace(dim.name, labels[label_idx++]);\n+                }\n+            }\n+            for (size_t i = 0; i < subspace_size; ++i) {\n+                size_t dense_key = i;\n+                for (auto dim = value.type().dimensions().rbegin();\n+                     dim != value.type().dimensions().rend(); ++dim)\n+                {\n+                    if (dim->is_indexed()) {\n+                        size_t label = dense_key % dim->size;\n+                        addr.emplace(dim->name, label).first->second = TensorSpec::Label(label);\n+                        dense_key /= dim->size;\n+                    }\n+                }\n+                spec.add(addr, cells[(subspace_size * subspace_id) + i]);\n+            }\n+        }\n+        return spec;\n+    }\n+};\n+\n+} // namespace <unnamed>", "originalCommit": "9a11a8d39ee7138e81fdc3d3b0adfd58cbeea84a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0944da353ad8912ed0cc04cf74808a753bde15c8", "url": "https://github.com/vespa-engine/vespa/commit/0944da353ad8912ed0cc04cf74808a753bde15c8", "message": "fixes after review\n\n* move namespace end to correct place\n* remove ValueType::indexed_dimensions(),\n  just loop over all dimensions when getting\n  names to avoid making an extra vector\n* unit test ValueType::count_indexed_dimensions()", "committedDate": "2020-09-23T17:11:41Z", "type": "commit"}]}