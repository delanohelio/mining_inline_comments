{"pr_number": 14728, "pr_title": "Arnej/add generic concat squish", "pr_createdAt": "2020-10-05T13:57:41Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/14728", "timeline": [{"oid": "8cc6d2d46c0196975e5340db5aaacccc89d44ab2", "url": "https://github.com/vespa-engine/vespa/commit/8cc6d2d46c0196975e5340db5aaacccc89d44ab2", "message": "add reference implementation of concat, with test", "committedDate": "2020-10-05T13:57:20Z", "type": "commit"}, {"oid": "c56465e5237fe3a5534a5b680990a01e7a798193", "url": "https://github.com/vespa-engine/vespa/commit/c56465e5237fe3a5534a5b680990a01e7a798193", "message": "add generic_concat, with test", "committedDate": "2020-10-05T13:57:20Z", "type": "commit"}, {"oid": "079779d64dcad2341c6db9f281570f5172408849", "url": "https://github.com/vespa-engine/vespa/commit/079779d64dcad2341c6db9f281570f5172408849", "message": "also merge similar cases", "committedDate": "2020-10-05T13:57:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY0Nzk5MQ==", "url": "https://github.com/vespa-engine/vespa/pull/14728#discussion_r499647991", "bodyText": "this should not be part of the final plan", "author": "havardpe", "createdAt": "2020-10-05T14:37:58Z", "path": "eval/src/vespa/eval/instruction/generic_concat.h", "diffHunk": "@@ -0,0 +1,45 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/nested_loop.h>\n+#include <vespa/eval/eval/value_type.h>\n+#include <vespa/eval/eval/interpreted_function.h>\n+#include <vespa/vespalib/stllike/string.h>\n+#include <vector>\n+\n+namespace vespalib::eval { struct ValueBuilderFactory; }\n+\n+namespace vespalib::eval::instruction {\n+\n+struct GenericConcat {\n+    static InterpretedFunction::Instruction\n+    make_instruction(const ValueType &lhs_type, const ValueType &rhs_type,\n+                     const vespalib::string &dimension,\n+                     const ValueBuilderFactory &factory, Stash &stash);\n+};\n+\n+struct DenseConcatPlan {\n+    size_t right_offset;\n+    struct InOutLoop {\n+        size_t input_size;\n+        size_t output_size;\n+        std::vector<size_t> in_loop_cnt;\n+        std::vector<size_t> out_loop_cnt;", "originalCommit": "079779d64dcad2341c6db9f281570f5172408849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY0OTUyNw==", "url": "https://github.com/vespa-engine/vespa/pull/14728#discussion_r499649527", "bodyText": "ideally, we should not be depending on simple tensor to give us the expected result here", "author": "havardpe", "createdAt": "2020-10-05T14:39:58Z", "path": "eval/src/tests/instruction/generic_concat/generic_concat_test.cpp", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/eval/simple_value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/eval/simple_tensor.h>\n+#include <vespa/eval/eval/simple_tensor_engine.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/instruction/generic_concat.h>\n+#include <vespa/eval/eval/interpreted_function.h>\n+#include <vespa/eval/eval/test/tensor_model.hpp>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::instruction;\n+using namespace vespalib::eval::test;\n+\n+using vespalib::make_string_short::fmt;\n+\n+std::vector<Layout> concat_layouts = {\n+    {},                                                 {},\n+    {},                                                 {x(5)},\n+    {x(5)},                                             {},\n+    {x(2)},                                             {x(3)},\n+    {x(2)},                                             {y(3)},\n+    {y(2)},                                             {z(3)},\n+    {x(5)},                                             {x(2),y(5)},\n+    {y(3)},                                             {x(2),z(3)},\n+    {x(2)},                                             {x(3),y(5),z(2)},\n+    {x(2),y(5),z(2)},                                   {x(3),y(5),z(2)},\n+    {x(3),y(5)},                                        {y(5),z(7)},\n+    float_cells({x(3),y(5)}),                           {y(5),z(7)},\n+    {x(3),y(5)},                                        float_cells({y(5),z(7)}),\n+    float_cells({x(3),y(5)}),                           float_cells({y(5),z(7)}),\n+    {y({\"a\",\"b\",\"c\"})},                                 {y({\"a\",\"b\",\"c\"})},\n+    {y({\"a\",\"b\",\"c\"})},                                 {y({\"a\",\"b\"})},\n+    {y({\"a\",\"b\",\"c\"})},                                 {y({\"b\",\"c\",\"d\"})},\n+    float_cells({y({\"a\",\"b\",\"c\"})}),                    {y({\"b\",\"c\",\"d\"})},\n+    {y({\"a\",\"b\",\"c\"})},                                 float_cells({y({\"b\",\"c\",\"d\"})}),\n+    float_cells({y({\"a\",\"b\",\"c\"})}),                    float_cells({z({\"foo\",\"bar\",\"baz\"})}),\n+    {y({\"a\",\"b\",\"c\"})},                                 {y({\"a\",\"b\",\"c\"}),z({\"foo\",\"bar\",\"baz\"})},\n+    {y({\"a\",\"b\"}),z({\"foo\",\"bar\",\"baz\"})},              {y({\"a\",\"b\",\"c\"}),z({\"foo\",\"bar\"})},\n+    {x(2),y({\"a\",\"b\",\"c\"})},                            {x(3),y({\"b\",\"c\",\"d\"})},\n+    {x(2),y({\"a\",\"b\"})},                                {x(3),z({\"c\",\"d\"})}\n+};\n+\n+TensorSpec perform_simpletensor_concat(const TensorSpec &a, const TensorSpec &b, const std::string &dimension) {\n+    auto lhs = SimpleTensor::create(a);\n+    auto rhs = SimpleTensor::create(b);\n+    auto out = SimpleTensor::concat(*lhs, *rhs, dimension);\n+    return SimpleTensorEngine::ref().to_spec(*out);\n+}\n+\n+bool concat_address(const TensorSpec::Address &me, const TensorSpec::Address &other,\n+                    const std::string &concat_dim, size_t my_offset,\n+                    TensorSpec::Address &my_out, TensorSpec::Address &other_out)\n+{\n+    my_out.insert_or_assign(concat_dim, my_offset);\n+    for (const auto &my_dim: me) {\n+        const auto & name = my_dim.first;\n+        const auto & label = my_dim.second;\n+        if (name == concat_dim) {\n+            my_out.insert_or_assign(name, label.index + my_offset);\n+        } else {\n+            auto pos = other.find(name);\n+            if ((pos == other.end()) || (pos->second == label)) {\n+                my_out.insert_or_assign(name, label);\n+                other_out.insert_or_assign(name, label);\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+    return true;\n+}\n+\n+bool concat_addresses(const TensorSpec::Address &a, const TensorSpec::Address &b,\n+                      const std::string &concat_dim, size_t b_offset,\n+                      TensorSpec::Address &a_out, TensorSpec::Address &b_out)\n+{\n+    return concat_address(a, b, concat_dim,        0, a_out, b_out) &&\n+           concat_address(b, a, concat_dim, b_offset, b_out, a_out);\n+}\n+\n+TensorSpec reference_concat(const TensorSpec &a, const TensorSpec &b, const std::string &concat_dim) {\n+    ValueType a_type = ValueType::from_spec(a.type());\n+    ValueType b_type = ValueType::from_spec(b.type());\n+    size_t cc_dim_a_size = 1;\n+    for (const auto & dim : a_type.dimensions()) {\n+        if (dim.name == concat_dim) {\n+            EXPECT_TRUE(dim.is_indexed());\n+            cc_dim_a_size = dim.size;\n+        }\n+    }\n+    ValueType res_type = ValueType::concat(a_type, b_type, concat_dim);\n+    EXPECT_FALSE(res_type.is_error());\n+    TensorSpec result(res_type.to_spec());\n+    for (const auto &cell_a: a.cells()) {\n+        for (const auto &cell_b: b.cells()) {\n+            TensorSpec::Address addr_a;\n+            TensorSpec::Address addr_b;\n+            if (concat_addresses(cell_a.first, cell_b.first, concat_dim, cc_dim_a_size, addr_a, addr_b)) {\n+                result.set(addr_a, cell_a.second);\n+                result.set(addr_b, cell_b.second);\n+            }\n+        }\n+    }\n+    return result;\n+}\n+\n+TensorSpec perform_generic_concat(const TensorSpec &a, const TensorSpec &b, const std::string &concat_dim) {\n+    Stash stash;\n+    const auto &factory = SimpleValueBuilderFactory::get();\n+    auto lhs = value_from_spec(a, factory);\n+    auto rhs = value_from_spec(b, factory);\n+    auto my_op = GenericConcat::make_instruction(lhs->type(), rhs->type(), concat_dim, factory, stash);\n+    InterpretedFunction::EvalSingle single(my_op);\n+    return spec_from_value(single.eval(std::vector<Value::CREF>({*lhs,*rhs})));\n+}\n+\n+TEST(GenericConcatTest, generic_reference_concat_works) {\n+    ASSERT_TRUE((concat_layouts.size() % 2) == 0);\n+    for (size_t i = 0; i < concat_layouts.size(); i += 2) {\n+        const TensorSpec lhs = spec(concat_layouts[i], N());\n+        const TensorSpec rhs = spec(concat_layouts[i + 1], Div16(N()));\n+        SCOPED_TRACE(fmt(\"\\n===\\nin LHS: %s\\nin RHS: %s\\n===\\n\", lhs.to_string().c_str(), rhs.to_string().c_str()));\n+        auto actual = reference_concat(lhs, rhs, \"x\");\n+        auto expect = perform_simpletensor_concat(lhs, rhs, \"x\");", "originalCommit": "079779d64dcad2341c6db9f281570f5172408849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "907e6b805dd31518cef75c9e91d8facf095b1c3d", "url": "https://github.com/vespa-engine/vespa/commit/907e6b805dd31518cef75c9e91d8facf095b1c3d", "message": "make SparseJoinState visible in header file", "committedDate": "2020-10-06T06:48:02Z", "type": "commit"}, {"oid": "89069de6916e19bf2757dc5621ec4b57ce0f5e7f", "url": "https://github.com/vespa-engine/vespa/commit/89069de6916e19bf2757dc5621ec4b57ce0f5e7f", "message": "out_loop_cnt is not needed in the final plan", "committedDate": "2020-10-06T06:50:11Z", "type": "commit"}, {"oid": "392be2d2538cafb73ca1269003973db91306e3e2", "url": "https://github.com/vespa-engine/vespa/commit/392be2d2538cafb73ca1269003973db91306e3e2", "message": "use dimension_index instead of explicit loop", "committedDate": "2020-10-06T07:10:09Z", "type": "commit"}]}