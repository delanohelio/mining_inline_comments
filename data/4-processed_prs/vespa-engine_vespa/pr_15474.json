{"pr_number": 15474, "pr_title": "shared string repo -- WIP", "pr_createdAt": "2020-11-25T17:01:43Z", "pr_url": "https://github.com/vespa-engine/vespa/pull/15474", "timeline": [{"oid": "a57880315976dc49be7f32f1736571845659ed0a", "url": "https://github.com/vespa-engine/vespa/commit/a57880315976dc49be7f32f1736571845659ed0a", "message": "shared string repo -- WIP", "committedDate": "2020-11-25T16:55:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMjI5Mg==", "url": "https://github.com/vespa-engine/vespa/pull/15474#discussion_r530602292", "bodyText": "don't you need to check for id == 0 here?", "author": "arnej27959", "createdAt": "2020-11-25T19:35:00Z", "path": "vespalib/src/vespa/vespalib/util/shared_string_repo.h", "diffHunk": "@@ -0,0 +1,193 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"spin_lock.h\"\n+#include <vespa/vespalib/stllike/string.h>\n+#include <vespa/vespalib/stllike/hash_set.hpp>\n+#include <xxhash.h>\n+#include <mutex>\n+#include <vector>\n+\n+namespace vespalib {\n+\n+/**\n+ * This class implements application-wide in-memory string\n+ * interning. Each string stored in the repo will be assigned a unique\n+ * 32-bit id that can be used by the application to check for\n+ * equality. The repo can never be shrunk in size, but ids can be\n+ * re-used when the corresponding strings are evicted from the\n+ * repo. Strong handles are used to track which strings are in\n+ * use. Weak handles are used as a cheap alternative to strong handles\n+ * when you also have a strong handle that ensures the string will not\n+ * be evicted. For example, an efficient sparse tensor attribute could\n+ * have a pool of strong handles to all strings used\n+ * internally. Individual tensor indexes could then contain only weak\n+ * handles, making string comparison as cheap as possible.\n+ **/\n+class SharedStringRepo {\n+private:\n+    static constexpr int NUM_PARTS = 64;\n+    static constexpr int PART_BITS = 6;\n+    static constexpr int PART_MASK = 0x3f;\n+\n+    struct AltKey {\n+        vespalib::stringref str;\n+        uint32_t hash;\n+    };\n+\n+    class Partition {\n+    public:\n+        struct Entry {\n+            uint32_t hash;\n+            uint32_t ref_cnt;\n+            vespalib::string str;\n+            Entry(const AltKey &key) noexcept : hash(key.hash), ref_cnt(1), str(key.str) {}\n+            void reset() {\n+                str.reset();\n+            }\n+            void reuse(const AltKey &key) {\n+                hash = key.hash;\n+                ref_cnt = 1;\n+                str = key.str;\n+            }\n+        };\n+        struct Key {\n+            uint32_t idx;\n+            uint32_t hash;\n+        };\n+        struct Hash {\n+            uint32_t operator()(const Key &key) const { return key.hash; }\n+            uint32_t operator()(const AltKey &key) const { return key.hash; }\n+        };\n+        struct Equal {\n+            const std::vector<Entry> &entries;\n+            Equal(const std::vector<Entry> &entries_in) : entries(entries_in) {}\n+            Equal(const Equal &rhs) = default;\n+            bool operator()(const Key &a, const Key &b) const { return (a.idx == b.idx); }\n+            bool operator()(const Key &a, const AltKey &b) const { return ((a.hash == b.hash) && (entries[a.idx].str == b.str)); }\n+        };\n+        using HashType = vespalib::hash_set<Key,Hash,Equal>;\n+\n+    private:\n+        SpinLock              _lock;\n+        std::vector<Entry>    _entries;\n+        std::vector<uint32_t> _free;\n+        HashType              _hash;\n+\n+        uint32_t make_entry(const AltKey &alt_key) {\n+            if (_free.empty()) {\n+                uint32_t idx = _entries.size();\n+                _entries.emplace_back(alt_key);\n+                return idx;\n+            } else {\n+                uint32_t idx = _free.back();\n+                _free.pop_back();\n+                _entries[idx].reuse(alt_key);\n+                return idx;\n+            }\n+        }\n+\n+    public:\n+        Partition()\n+            : _lock(), _entries(), _free(), _hash(0, Hash(), Equal(_entries)) {}\n+        ~Partition();\n+\n+        uint32_t resolve(const AltKey &alt_key) {\n+            std::lock_guard guard(_lock);\n+            auto pos = _hash.find(alt_key);\n+            if (pos != _hash.end()) {\n+                ++_entries[pos->idx].ref_cnt;\n+                return pos->idx;\n+            } else {\n+                uint32_t idx = make_entry(alt_key);\n+                _hash.insert(Key{idx, alt_key.hash});\n+                return idx;\n+            }\n+        }\n+\n+        vespalib::string get(uint32_t idx) {\n+            std::lock_guard guard(_lock);\n+            return _entries[idx].str;\n+        }\n+\n+        void copy(uint32_t idx) {\n+            std::lock_guard guard(_lock);\n+            ++_entries[idx].ref_cnt;\n+        }\n+\n+        void reclaim(uint32_t idx) {\n+            std::lock_guard guard(_lock);\n+            Entry &entry = _entries[idx];\n+            if (--entry.ref_cnt == 0) {\n+                _hash.erase(Key{idx, entry.hash});\n+                entry.reset();\n+                _free.push_back(idx);\n+            }\n+        }\n+    };\n+\n+    static std::array<Partition,NUM_PARTS> _partitions;\n+\n+    static uint32_t resolve(vespalib::stringref str) {\n+        if (!str.empty()) {\n+            uint64_t full_hash = XXH3_64bits(str.data(), str.size());\n+            uint32_t part = full_hash & PART_MASK;\n+            uint32_t local_hash = full_hash >> PART_BITS;\n+            uint32_t local_idx = _partitions[part].resolve(AltKey{str, local_hash});\n+            return (((local_idx << PART_BITS) | part) + 1);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    static vespalib::string get(uint32_t id) {\n+        uint32_t part = (id - 1) & PART_MASK;", "originalCommit": "a57880315976dc49be7f32f1736571845659ed0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkxMDMxNA==", "url": "https://github.com/vespa-engine/vespa/pull/15474#discussion_r530910314", "bodyText": "yes, I do", "author": "havardpe", "createdAt": "2020-11-26T10:02:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMjI5Mg=="}], "type": "inlineReview"}, {"oid": "a553f4feb65d4f026d334a8a9ab792a6671d6bd0", "url": "https://github.com/vespa-engine/vespa/commit/a553f4feb65d4f026d334a8a9ab792a6671d6bd0", "message": "check for 0 id more places\n\nalso cut some documentation, since we only have one handle type for\nnow.", "committedDate": "2020-11-26T10:29:04Z", "type": "commit"}, {"oid": "84e9a5330a98a02aab4c498ed643603589970d8c", "url": "https://github.com/vespa-engine/vespa/commit/84e9a5330a98a02aab4c498ed643603589970d8c", "message": "improve and clean up unit test", "committedDate": "2020-11-26T10:52:30Z", "type": "commit"}, {"oid": "3da9b933cca405ae71a3fac8a00b803d123c5121", "url": "https://github.com/vespa-engine/vespa/commit/3da9b933cca405ae71a3fac8a00b803d123c5121", "message": "use singleton object instead of static members\n\nthis is to avoid having to create a repo when it is not used", "committedDate": "2020-11-26T11:23:59Z", "type": "commit"}]}