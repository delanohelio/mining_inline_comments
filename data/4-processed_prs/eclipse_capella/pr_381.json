{"pr_number": 381, "pr_title": "[563193] Capella Diagram Performance issues", "pr_createdAt": "2020-10-01T13:36:59Z", "pr_url": "https://github.com/eclipse/capella/pull/381", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2MTQ4OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498461488", "bodyText": "Collection directEvents = getElementToContainerCache(element);\nif (directEvents != null) {\n// if not present, compute it and put it in cache\ndirectEvents = getDirectEvents(element, instanceRole)\n}\nreturn directEvents.stream().filter(Execution)...", "author": "mPorhel", "createdAt": "2020-10-01T19:14:51Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  /**\n+   * Return abstract end covered TimeLapse/InstanceRole.\n+   * \n+   * @param end\n+   *          AbstractEnd\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return TimeLapse\n+   */\n+  public static Optional<CapellaElement> getEvent(AbstractEnd end, InstanceRole instanceRole) {\n+    Optional<CapellaElement> timeLapse = getEndToEventCache(end);\n+    if (!timeLapse.isPresent()) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      // get TimeLapse from cache\n+      // if not present, compute it from EventContext structure\n+      Optional<EventContext> endEventContext = eventContexts.stream()\n+          .filter(eventContext -> end.equals(eventContext.getElement())).findFirst();\n+      if (endEventContext.isPresent() && endEventContext.get().getParent() instanceof CapellaElement) {\n+        putEndToEventCache(end, (CapellaElement) endEventContext.get().getParent());\n+      }\n+      timeLapse = getEndToEventCache(end);\n+    }\n+    return timeLapse;\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  private static List<EventContext> getEventContext(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      putInstanceRoleToEventContextCache(instanceRole, eventContexts);\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(eventContext -> eventContext.getElement()).filter(event -> event != element).distinct()\n+          .collect(Collectors.toList());\n+      putElementToContainerCache(element, directEvents);\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA1OTM5NA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501059394", "bodyText": "Done", "author": "mPorhel", "createdAt": "2020-10-07T14:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2MTQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2MTYxOA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498461618", "bodyText": "Collection directEvents = getElementToContainerCache(element);\nif (directEvents != null) {\n// if not present, compute it and put it in cache\ndirectEvents = getDirectEvents(element, instanceRole)\n}\nreturn directEvents.stream().filter(State...)...", "author": "mPorhel", "createdAt": "2020-10-01T19:15:05Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  /**\n+   * Return abstract end covered TimeLapse/InstanceRole.\n+   * \n+   * @param end\n+   *          AbstractEnd\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return TimeLapse\n+   */\n+  public static Optional<CapellaElement> getEvent(AbstractEnd end, InstanceRole instanceRole) {\n+    Optional<CapellaElement> timeLapse = getEndToEventCache(end);\n+    if (!timeLapse.isPresent()) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      // get TimeLapse from cache\n+      // if not present, compute it from EventContext structure\n+      Optional<EventContext> endEventContext = eventContexts.stream()\n+          .filter(eventContext -> end.equals(eventContext.getElement())).findFirst();\n+      if (endEventContext.isPresent() && endEventContext.get().getParent() instanceof CapellaElement) {\n+        putEndToEventCache(end, (CapellaElement) endEventContext.get().getParent());\n+      }\n+      timeLapse = getEndToEventCache(end);\n+    }\n+    return timeLapse;\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  private static List<EventContext> getEventContext(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      putInstanceRoleToEventContextCache(instanceRole, eventContexts);\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(eventContext -> eventContext.getElement()).filter(event -> event != element).distinct()\n+          .collect(Collectors.toList());\n+      putElementToContainerCache(element, directEvents);\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA1OTU3NQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501059575", "bodyText": "Done", "author": "mPorhel", "createdAt": "2020-10-07T14:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2MTYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NjI2OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498466268", "bodyText": "You use the endToEventCache to retreive information that you did not put in the cache like ExecutionEnd -> Execution (finish of an eexcution when there is no return message : see timers and exchanges without return branch.", "author": "mPorhel", "createdAt": "2020-10-01T19:24:44Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  /**\n+   * Return abstract end covered TimeLapse/InstanceRole.\n+   * \n+   * @param end\n+   *          AbstractEnd\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return TimeLapse\n+   */\n+  public static Optional<CapellaElement> getEvent(AbstractEnd end, InstanceRole instanceRole) {\n+    Optional<CapellaElement> timeLapse = getEndToEventCache(end);\n+    if (!timeLapse.isPresent()) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      // get TimeLapse from cache\n+      // if not present, compute it from EventContext structure\n+      Optional<EventContext> endEventContext = eventContexts.stream()\n+          .filter(eventContext -> end.equals(eventContext.getElement())).findFirst();\n+      if (endEventContext.isPresent() && endEventContext.get().getParent() instanceof CapellaElement) {\n+        putEndToEventCache(end, (CapellaElement) endEventContext.get().getParent());\n+      }\n+      timeLapse = getEndToEventCache(end);\n+    }\n+    return timeLapse;\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  private static List<EventContext> getEventContext(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      putInstanceRoleToEventContextCache(instanceRole, eventContexts);\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(eventContext -> eventContext.getElement()).filter(event -> event != element).distinct()\n+          .collect(Collectors.toList());\n+      putElementToContainerCache(element, directEvents);\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Stack<EObject> ancestors = new Stack<EObject>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<EventContext>();\n+\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // cache StateFragment.start -> Execution and StateFragment.finish -> Execution\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Stack<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Stack<EObject> ancestors, List<EventContext> result, MessageEnd end) {\n+    Optional<CapellaElement> container = getEndToEventCache(end);\n+    if (container.isPresent() && container.get() instanceof Execution\n+        && ((Execution) container.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), true, ancestors.size() + 1));\n+      ancestors.push(container.get());\n+    }\n+\n+    if (container.isPresent() && container.get() instanceof Execution\n+        && ((Execution) container.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), container.get(), false, ancestors.size() + 1));\n+    }\n+    if (!container.isPresent()) {\n+      putEndToEventCache(end, (CapellaElement) ancestors.peek());\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Stack<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Stack<EObject> ancestors, List<EventContext> result, InteractionState end) {\n+    Optional<CapellaElement> container = getEndToEventCache(end);\n+    if (container.isPresent() && container.get() instanceof StateFragment\n+        && ((StateFragment) container.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (container.isPresent() && container.get() instanceof StateFragment\n+        && ((StateFragment) container.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), false, ancestors.size() + 1));\n+    }\n+    if (!container.isPresent()) {\n+      putEndToEventCache(end, (CapellaElement) ancestors.peek());\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for ExecutionEnd.\n+   * \n+   * @param ancestors\n+   *          Stack<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          ExecutionEnd\n+   */\n+  private static void visit(Stack<EObject> ancestors, List<EventContext> result, ExecutionEnd end) {\n+    Execution execution = end.getExecution();\n+    if (execution != null && end.getExecution().getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), execution, true, ancestors.size() + 1));\n+      ancestors.push(execution);\n+    }\n+    if (execution != null && end.getExecution().getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), execution, false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Return covered instance role.\n+   * \n+   * @param end\n+   *          InteractionFragment\n+   * @return covered instance role.\n+   */\n+  private static InstanceRole getCoveredInstanceRole(InteractionFragment end) {\n+    InstanceRole covered = null;\n+    if (end instanceof AbstractEnd) {\n+      covered = getInteractionCache(AbstractEnd::getCovered, (AbstractEnd) end);\n+    } else if (end instanceof InteractionState) {\n+      covered = getInteractionCache(InteractionState::getCovered, (InteractionState) end);\n+    }\n+    return covered;\n+  }\n+\n+  /**\n+   * Compute cache for TimeLapse start and finish ends.\n+   * \n+   * @param scenario\n+   *          Scenario\n+   */\n+  private static void computeTimeLapseStartAndEndCache(Scenario scenario) {\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    Stream<TimeLapse> timeLapses = scenario.getOwnedTimeLapses().stream()\n+        .filter(tl -> !(tl instanceof AbstractFragment));\n+    // scan timelapse only one time\n+    if (getEndToEventCache().isEmpty()) {\n+      timeLapses.forEach(e -> {\n+        if (e.getStart() instanceof MessageEnd) {\n+          putEndToEventCache(e.getStart(), e);", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2Mzc3OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501063778", "bodyText": "Done in further commit.\nendToEventCache renamed into interactionFragmentToTimeLapseCache and type changed from Map<InteractionFragment, CapellaElement> to Map<InteractionFragment, TimeLapse>.\nThis cache is now used only to store and retrieve the link from an InteractionFragment to a TimeLapse, this information exists with ExecutionEnd::execution but is missing between MEssageEnd and Execution and between InteractionState and StateFragment. The other way is defined in the M2 with TimeLapse::start and TimeLapse::finish references.", "author": "mPorhel", "createdAt": "2020-10-07T14:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NjI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2Njg5Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498466897", "bodyText": "not sur that to understand how this  allows to retrieve the Excution/InstanceRole on which the Edge willbe connected", "author": "mPorhel", "createdAt": "2020-10-01T19:26:03Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  /**\n+   * Return abstract end covered TimeLapse/InstanceRole.\n+   * \n+   * @param end\n+   *          AbstractEnd\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return TimeLapse\n+   */\n+  public static Optional<CapellaElement> getEvent(AbstractEnd end, InstanceRole instanceRole) {", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NDMxNw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501064317", "bodyText": "Replaced by computation of ReceivingEnd/SendingEnd based on the EventContext structure", "author": "mPorhel", "createdAt": "2020-10-07T14:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2Njg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NzQxNA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498467414", "bodyText": "sending/receiving End ?\nif container isEmpty, this means that the messageEnd is not the start of the finish of an execution but the sendingEnd of the edge or the receiving end of the return branch.\nHere I see two solutions:\neither you use the endToEvent cache for this one to reference the \"getExecutionOfMessageEnd\", ie the Execution which will be the source of the edge (target of the return branch), but then your the mesage is not part of the structure.\nor you put  something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  putEndToEventCache(end, (CapellaElement) ancestors.peek());\n          \n          \n            \n                Message msg = end.getMessage();\n          \n          \n            \n                result.add(new EventContext(ancestors.peek(), msg, end.equals(msg.getStart()), ancestors.size() + 1));", "author": "mPorhel", "createdAt": "2020-10-01T19:27:13Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  /**\n+   * Return abstract end covered TimeLapse/InstanceRole.\n+   * \n+   * @param end\n+   *          AbstractEnd\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return TimeLapse\n+   */\n+  public static Optional<CapellaElement> getEvent(AbstractEnd end, InstanceRole instanceRole) {\n+    Optional<CapellaElement> timeLapse = getEndToEventCache(end);\n+    if (!timeLapse.isPresent()) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      // get TimeLapse from cache\n+      // if not present, compute it from EventContext structure\n+      Optional<EventContext> endEventContext = eventContexts.stream()\n+          .filter(eventContext -> end.equals(eventContext.getElement())).findFirst();\n+      if (endEventContext.isPresent() && endEventContext.get().getParent() instanceof CapellaElement) {\n+        putEndToEventCache(end, (CapellaElement) endEventContext.get().getParent());\n+      }\n+      timeLapse = getEndToEventCache(end);\n+    }\n+    return timeLapse;\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  private static List<EventContext> getEventContext(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      putInstanceRoleToEventContextCache(instanceRole, eventContexts);\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(eventContext -> eventContext.getElement()).filter(event -> event != element).distinct()\n+          .collect(Collectors.toList());\n+      putElementToContainerCache(element, directEvents);\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Stack<EObject> ancestors = new Stack<EObject>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<EventContext>();\n+\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // cache StateFragment.start -> Execution and StateFragment.finish -> Execution\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Stack<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Stack<EObject> ancestors, List<EventContext> result, MessageEnd end) {\n+    Optional<CapellaElement> container = getEndToEventCache(end);\n+    if (container.isPresent() && container.get() instanceof Execution\n+        && ((Execution) container.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), true, ancestors.size() + 1));\n+      ancestors.push(container.get());\n+    }\n+\n+    if (container.isPresent() && container.get() instanceof Execution\n+        && ((Execution) container.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), container.get(), false, ancestors.size() + 1));\n+    }\n+    if (!container.isPresent()) {\n+      putEndToEventCache(end, (CapellaElement) ancestors.peek());", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NTAxOQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501065019", "bodyText": "Replaced with the creation of EventContext for every MessageEnd, see comments in code.", "author": "mPorhel", "createdAt": "2020-10-07T14:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NzQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2ODcwNA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498468704", "bodyText": "here I do not see how ancestor.peek()  would be the StateFragment of the InteractionState.\nStateFragment have no \"children\"\ncomputeTimeLapseStartAndEndCache is called before the calls to the visit method, so the cache is alreayd completed for InstractionState -> StateFragment\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  putEndToEventCache(end, (CapellaElement) ancestors.peek());", "author": "mPorhel", "createdAt": "2020-10-01T19:29:51Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  /**\n+   * Return abstract end covered TimeLapse/InstanceRole.\n+   * \n+   * @param end\n+   *          AbstractEnd\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return TimeLapse\n+   */\n+  public static Optional<CapellaElement> getEvent(AbstractEnd end, InstanceRole instanceRole) {\n+    Optional<CapellaElement> timeLapse = getEndToEventCache(end);\n+    if (!timeLapse.isPresent()) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      // get TimeLapse from cache\n+      // if not present, compute it from EventContext structure\n+      Optional<EventContext> endEventContext = eventContexts.stream()\n+          .filter(eventContext -> end.equals(eventContext.getElement())).findFirst();\n+      if (endEventContext.isPresent() && endEventContext.get().getParent() instanceof CapellaElement) {\n+        putEndToEventCache(end, (CapellaElement) endEventContext.get().getParent());\n+      }\n+      timeLapse = getEndToEventCache(end);\n+    }\n+    return timeLapse;\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  private static List<EventContext> getEventContext(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      putInstanceRoleToEventContextCache(instanceRole, eventContexts);\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(eventContext -> eventContext.getElement()).filter(event -> event != element).distinct()\n+          .collect(Collectors.toList());\n+      putElementToContainerCache(element, directEvents);\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Stack<EObject> ancestors = new Stack<EObject>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<EventContext>();\n+\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // cache StateFragment.start -> Execution and StateFragment.finish -> Execution\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Stack<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Stack<EObject> ancestors, List<EventContext> result, MessageEnd end) {\n+    Optional<CapellaElement> container = getEndToEventCache(end);\n+    if (container.isPresent() && container.get() instanceof Execution\n+        && ((Execution) container.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), true, ancestors.size() + 1));\n+      ancestors.push(container.get());\n+    }\n+\n+    if (container.isPresent() && container.get() instanceof Execution\n+        && ((Execution) container.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), container.get(), false, ancestors.size() + 1));\n+    }\n+    if (!container.isPresent()) {\n+      putEndToEventCache(end, (CapellaElement) ancestors.peek());\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Stack<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Stack<EObject> ancestors, List<EventContext> result, InteractionState end) {\n+    Optional<CapellaElement> container = getEndToEventCache(end);\n+    if (container.isPresent() && container.get() instanceof StateFragment\n+        && ((StateFragment) container.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (container.isPresent() && container.get() instanceof StateFragment\n+        && ((StateFragment) container.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), false, ancestors.size() + 1));\n+    }\n+    if (!container.isPresent()) {\n+      putEndToEventCache(end, (CapellaElement) ancestors.peek());", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NTQyMA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501065420", "bodyText": "LoC removed.", "author": "mPorhel", "createdAt": "2020-10-07T14:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2ODcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3ODI1Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498478257", "bodyText": "I would have put:\nExecution exec = getEndToEvent(end);\n(by construction the start/finish is useless)\nif (exec != null)\nreturn  exec; (the execution/timer delimited by a message and its return branch)\nelse: need to find the exec which send/receive the edge : see eventContext message case.\nif no execution : instancerole must be returned.", "author": "mPorhel", "createdAt": "2020-10-01T19:50:25Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java", "diffHunk": "@@ -141,69 +113,21 @@ public static EObject getSendingEnd(SequenceMessage message) {\n     if (end == null) {\n       return message; // found message case\n     }\n-\n-    Scenario sc = (Scenario) message.eContainer();\n-    for (TimeLapse exec : sc.getOwnedTimeLapses()) {\n-      if (exec.getFinish() == end) {\n-        return exec;\n-      }\n-    }\n-    Execution execution = getExecutionOfMessageEnd(end);\n-\n-    return execution == null ? end.getCovered() : execution;\n+    return getExecutionOrCoveredOfMessageEnd(end);", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NTgzNA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501065834", "bodyText": "Computation is now based on EventContext structure.", "author": "mPorhel", "createdAt": "2020-10-07T14:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3ODI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3ODQzNQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498478435", "bodyText": "see previous comment, I am not sure that the getEvent is the food solution here.", "author": "mPorhel", "createdAt": "2020-10-01T19:50:51Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java", "diffHunk": "@@ -141,69 +113,21 @@ public static EObject getSendingEnd(SequenceMessage message) {\n     if (end == null) {\n       return message; // found message case\n     }\n-\n-    Scenario sc = (Scenario) message.eContainer();\n-    for (TimeLapse exec : sc.getOwnedTimeLapses()) {\n-      if (exec.getFinish() == end) {\n-        return exec;\n-      }\n-    }\n-    Execution execution = getExecutionOfMessageEnd(end);\n-\n-    return execution == null ? end.getCovered() : execution;\n+    return getExecutionOrCoveredOfMessageEnd(end);\n   }\n \n   public static EObject getReceivingEnd(SequenceMessage message) {\n     MessageEnd end = message.getReceivingEnd();\n     if (end == null) {\n       return message; // lost message case\n     }\n-    Scenario sc = (Scenario) message.eContainer();\n-    for (TimeLapse exec : sc.getOwnedTimeLapses()) {\n-      if (exec.getStart() == end) {\n-        return exec;\n-      }\n-    }\n-    Execution execution = getExecutionOfMessageEnd(end);\n-    return execution == null ? end.getCovered() : execution;\n+    return getExecutionOrCoveredOfMessageEnd(end);\n   }\n \n-  /**\n-   * return the execution which start the messageEnd taken in parameter.\n-   * \n-   * @param end\n-   * @return\n-   */\n-  private static Execution getExecutionOfMessageEnd(MessageEnd end) {\n-    Scenario scenario = getScenario(end);\n-    InstanceRole currentIR = end.getCovered();\n-    List<Execution> executionStack = new ArrayList<Execution>();\n-    for (InteractionFragment ifgt : scenario.getOwnedInteractionFragments()) {\n-      if (ifgt instanceof AbstractEnd) {\n-        AbstractEnd ae = (AbstractEnd) ifgt;\n-        if (ae.getCovered() == currentIR) {\n-          // if ae starts an exception, the execution is stacked\n-          // if ae ends an exception, the execution is unstacked\n-          for (TimeLapse laptime : scenario.getOwnedTimeLapses()) {\n-            if (laptime instanceof Execution) {\n-              Execution execution = (Execution) laptime;\n-              if (execution.getCovered() == currentIR) {\n-                if (execution.getStart() == ae) {\n-                  executionStack.add(execution);\n-                }\n-                if (execution.getFinish() == ae) {\n-                  executionStack.remove(execution);\n-                }\n-              }\n-            }\n-          }\n-          if (ae == end) {\n-            return top(executionStack);\n-          }\n-        }\n-      }\n-    }\n-    return null;\n+  private static EObject getExecutionOrCoveredOfMessageEnd(MessageEnd end) {\n+    Optional<CapellaElement> execution = EventContextServices.getEvent(end, currentInstanceRole(end));\n+    // null never happen\n+    return execution.isPresent() ? execution.get() : null;", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NjA4Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501066086", "bodyText": "Computation is now based on EventContext structure.", "author": "mPorhel", "createdAt": "2020-10-07T14:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3ODQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3OTg2Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498479867", "bodyText": "I would put this change in a releng commit to format the class before this commit", "author": "mPorhel", "createdAt": "2020-10-01T19:54:03Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java", "diffHunk": "@@ -276,16 +200,16 @@ private static void reorderInteractionFragment(Scenario scenario, InteractionFra\n     int currentFragmentIndex = -1;\n     if (currentFragment != null) {\n       currentFragmentIndex = scenario.getOwnedInteractionFragments().indexOf(currentFragment);\n-    int currentIndexNewPredecessor = -1;\n-    if (newPredecessor != null) {\n-      currentIndexNewPredecessor = scenario.getOwnedInteractionFragments().indexOf(newPredecessor);\n-    }\n+      int currentIndexNewPredecessor = -1;\n+      if (newPredecessor != null) {\n+        currentIndexNewPredecessor = scenario.getOwnedInteractionFragments().indexOf(newPredecessor);\n+      }", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MDY1OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498480658", "bodyText": "It is a cache from InstanceRole/Execution to list fo children  (Execution/StateFragment)\neventToSubEventsCache ?", "author": "mPorhel", "createdAt": "2020-10-01T19:55:44Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n+\n+public class InteractionRefreshExtension extends AbstractCacheAwareRefreshExtension {\n+\n+  /**\n+   * Generic cache (basically for getCovered).\n+   */\n+  private static Cache interactionCache = new Cache();\n+\n+  /**\n+   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n+   * way to get this information.)\n+   */\n+  private static Map<InteractionFragment, CapellaElement> endToEventCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n+   */\n+  private static Map<EObject, Collection<EObject>> elementToContainerCache = new ConcurrentHashMap<>();\n+", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NzA0Mw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501067043", "bodyText": "elementToContainerCache renamed into directEventsCache.\nIt could have been named directChildrenTimeLapseCache.", "author": "mPorhel", "createdAt": "2020-10-07T14:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MDY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MTIwNw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498481207", "bodyText": "Should not we activate the cache from here", "author": "mPorhel", "createdAt": "2020-10-01T19:56:57Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n+\n+public class InteractionRefreshExtension extends AbstractCacheAwareRefreshExtension {\n+\n+  /**\n+   * Generic cache (basically for getCovered).\n+   */\n+  private static Cache interactionCache = new Cache();\n+\n+  /**\n+   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n+   * way to get this information.)\n+   */\n+  private static Map<InteractionFragment, CapellaElement> endToEventCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n+   */\n+  private static Map<EObject, Collection<EObject>> elementToContainerCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for InstanceRole -> EventContext structure.\n+   */\n+  private static Map<InstanceRole, List<EventContext>> instanceRoleToEventContextCache = new ConcurrentHashMap<InstanceRole, List<EventContext>>();\n+\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#beforeRefresh(org.eclipse.sirius.DDiagram)\n+   */\n+  @Override\n+  public void beforeRefresh(DDiagram diagram) {\n+    super.beforeRefresh(diagram);", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MzUzNw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498483537", "bodyText": "cacheGetter could return null is cache is not enabled and put method would do nothing (but current implementations which do put and then get would need to be reworked)", "author": "mPorhel", "createdAt": "2020-10-01T20:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MTIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NzM5Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501067397", "bodyText": "Done", "author": "mPorhel", "createdAt": "2020-10-07T14:39:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MTIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MTY4Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498481682", "bodyText": "clear + disable cache ?\nThe scope the cache would only be the refresh/\nWe would need to checkthe VSM to checkthat the tools do not use the services.\nThe cache is emptied for the lists but interactionCache remains active, it should be disabled to let tools properly work.", "author": "mPorhel", "createdAt": "2020-10-01T19:57:53Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n+\n+public class InteractionRefreshExtension extends AbstractCacheAwareRefreshExtension {\n+\n+  /**\n+   * Generic cache (basically for getCovered).\n+   */\n+  private static Cache interactionCache = new Cache();\n+\n+  /**\n+   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n+   * way to get this information.)\n+   */\n+  private static Map<InteractionFragment, CapellaElement> endToEventCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n+   */\n+  private static Map<EObject, Collection<EObject>> elementToContainerCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for InstanceRole -> EventContext structure.\n+   */\n+  private static Map<InstanceRole, List<EventContext>> instanceRoleToEventContextCache = new ConcurrentHashMap<InstanceRole, List<EventContext>>();\n+\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#beforeRefresh(org.eclipse.sirius.DDiagram)\n+   */\n+  @Override\n+  public void beforeRefresh(DDiagram diagram) {\n+    super.beforeRefresh(diagram);\n+  }\n+\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#postRefresh(org.eclipse.sirius.DDiagram)\n+   */\n+  @Override\n+  public void postRefresh(DDiagram diagram) {\n+    interactionCache.clearCache();", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NzU5MA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501067590", "bodyText": "done", "author": "mPorhel", "createdAt": "2020-10-07T14:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MTY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1Mjg3Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498952876", "bodyText": "diagram ?", "author": "mPorhel", "createdAt": "2020-10-02T17:25:24Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtensionProvider.java", "diffHunk": "@@ -19,24 +19,24 @@\n \n public class InteractionRefreshExtensionProvider implements IRefreshExtensionProvider {\n \n-    private static final InteractionRefreshExtension REFRESH_EXTENSION = new InteractionRefreshExtension();\n+  private static final InteractionRefreshExtension REFRESH_EXTENSION = new InteractionRefreshExtension();\n \n-    public InteractionRefreshExtensionProvider() {\n-        // empty constructor\n-    }\n+  public InteractionRefreshExtensionProvider() {\n+    // empty constructor\n+  }\n \n-    /**\n-     * @see org.eclipse.sirius.business.api.refresh.IRefreshExtensionProvider#getRefreshExtension(org.eclipse.sirius.DDiagram)\n-     */\n-    public IRefreshExtension getRefreshExtension(DDiagram viewPoint_p) {\n-        return REFRESH_EXTENSION;\n-    }\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtensionProvider#getRefreshExtension(org.eclipse.sirius.DDiagram)\n+   */\n+  public IRefreshExtension getRefreshExtension(DDiagram viewPoint) {\n+    return REFRESH_EXTENSION;\n+  }\n \n-    /**\n-     * @see org.eclipse.sirius.business.api.refresh.IRefreshExtensionProvider#provides(org.eclipse.sirius.DDiagram)\n-     */\n-    public boolean provides(DDiagram viewPoint_p) {\n-        return viewPoint_p instanceof SequenceDDiagram;\n-    }\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtensionProvider#provides(org.eclipse.sirius.DDiagram)\n+   */\n+  public boolean provides(DDiagram viewPoint) {", "originalCommit": "a6cdaea6053b6df2111535c8961d12fb2b561c78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2ODc5Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501068796", "bodyText": "done", "author": "mPorhel", "createdAt": "2020-10-07T14:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1Mjg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NDIxNQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498954215", "bodyText": "We could condition the putxxxCache method to have an effect only in this instead of check theisCacheEnabled value everywhere.\nTeh need to have the isCacheEnabledMethod would be less usefull.", "author": "mPorhel", "createdAt": "2020-10-02T17:28:06Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -65,7 +69,7 @@ public void beforeRefresh(DDiagram diagram) {\n   @Override\n   public void postRefresh(DDiagram diagram) {\n     clearCaches();\n-    super.postRefresh(diagram);\n+    isCacheEnabled = false;", "originalCommit": "a6cdaea6053b6df2111535c8961d12fb2b561c78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MTU2Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498961562", "bodyText": "If we remove the super.beforeRefresh / afterRefresh method could you confirm that there is another extension which enable the ModelCache during the SequenceDDiagram refresh ?\nIf there is another extension doing this, we can remove the superbeforeR/afterR methods but in this case we should also remove the inheritance to the AbstractCacheAwareRefreshExtension.\nIt seems that the TitleBlockRefreshExtensionProvider is enabled for every diagram.", "author": "mPorhel", "createdAt": "2020-10-02T17:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NDIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA3MzAzNQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501073035", "bodyText": "done", "author": "mPorhel", "createdAt": "2020-10-07T14:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NDIxNQ=="}], "type": "inlineReview"}, {"oid": "d06008bf95006a89f25657e20ddc00404c421075", "url": "https://github.com/eclipse/capella/commit/d06008bf95006a89f25657e20ddc00404c421075", "message": "[563193] Capella Diagram Performance issues\n\n\nSigned-off-by: Nathalie Lepine <nathalie.lepine@obeo.fr>", "committedDate": "2020-10-08T10:40:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwODg0MA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r505608840", "bodyText": "Maybe AbstractFragment could be taken into account in a future enhancement since it's absolutely suitable to use the same logic of EventContext to process elements such as CombinedFragment and InteractionUse.", "author": "minhtutonthat", "createdAt": "2020-10-15T14:53:55Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: \n+        //   EventContext(IR2, e1, true, 2)\n+        //   EventContext(e1, m1, false, 2)\n+        //   EventContext(e1, m2, true, 2)\n+        //   EventContext(e1, e3, true, 3)\n+        //   EventContext(e3, m3, false, 3)\n+        //   EventContext(e3, return_m3, true, 3)\n+        //   EventContext(e1, e3, false, 3)\n+        //   EventContext(e1, return_m1 true, 2)\n+        //   EventContext(IR2, e1, false, 2)\n+        //\n+        //  For IR3: \n+        //   EventContext(IR3, e3, true, 2)\n+        //   EventContext(e3, m2, false, 2)\n+        //   EventContext(IR3, e3, false, 2)\n+        // @formatter:on\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, InteractionState end,\n+      Optional<TimeLapse> timeLapse) {\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for ExecutionEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          ExecutionEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, ExecutionEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+    // Should not happen in current implementation of Capella Sequence diagrams\n+    if (timeLapse.isPresent() && timeLapse.get().getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Execution without return branch end / ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get().getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Return covered instance role.\n+   * \n+   * @param end\n+   *          InteractionFragment\n+   * @return covered instance role.\n+   */\n+  private static InstanceRole getCoveredInstanceRole(InteractionFragment end) {\n+    InstanceRole covered = null;\n+    if (end instanceof AbstractEnd) {\n+      covered = getInteractionCache(AbstractEnd::getCovered, (AbstractEnd) end);\n+    } else if (end instanceof InteractionState) {\n+      covered = getInteractionCache(InteractionState::getCovered, (InteractionState) end);\n+    }\n+    return covered;\n+  }\n+\n+  /**\n+   * Compute cache for TimeLapse start and finish ends.\n+   * \n+   * @param scenario\n+   *          Scenario\n+   */\n+  private static void computeTimeLapseStartAndEndCache(Scenario scenario) {\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // scan timelapse only one time\n+    if (getInteractionFragmentToTimeLapseCache().isEmpty()) {\n+      Stream<TimeLapse> timeLapses = scenario.getOwnedTimeLapses().stream()\n+          .filter(tl -> !(tl instanceof AbstractFragment));", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxNDM3Mw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507714373", "bodyText": "Yes and no : all interactionUse and combinedFragments are direct DNodeContainder children of the SequenceDDiagram, there is no complexitiy to find and compute them. Then it is the SequenceLayout and the editParts which takes them and plays with the zOrder and layout constraints to place them.\nFor execution and states, we need all this logic in order to compute the DNode structure as each level of execution/state nodes are bordered nodes of the parent level. (The lifeline itself is a border node of the InstanceRole figure).", "author": "mPorhel", "createdAt": "2020-10-19T12:42:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwODg0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIzNDA5Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r509234092", "bodyText": "Ok i see", "author": "minhtutonthat", "createdAt": "2020-10-21T12:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwODg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwOTA4Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r505609086", "bodyText": "For IR2?", "author": "minhtutonthat", "createdAt": "2020-10-15T14:54:15Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: ", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxMTIxMA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507711210", "bodyText": "IR2", "author": "mPorhel", "createdAt": "2020-10-19T12:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwOTA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMDUxOQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r505610519", "bodyText": "Could you remove the unnecessary else clause?", "author": "minhtutonthat", "createdAt": "2020-10-15T14:55:51Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java", "diffHunk": "@@ -140,70 +111,28 @@ public static EObject getSendingEnd(SequenceMessage message) {\n     MessageEnd end = message.getSendingEnd();\n     if (end == null) {\n       return message; // found message case\n-    }\n+    } else {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxNTU4Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507715587", "bodyText": "It is not unnecessary, it corresponds to all the logic ..\nSorry, ok, style issue, as you want.", "author": "mPorhel", "createdAt": "2020-10-19T12:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMDUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc0NDE1Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507744156", "bodyText": "In our Dev environment, without the \"else\", we have a Checsktyle warning.", "author": "mPorhel", "createdAt": "2020-10-19T13:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMDUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIzNTAxNg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r509235016", "bodyText": "In our dev environment Sonar checks this kind of rule :)", "author": "minhtutonthat", "createdAt": "2020-10-21T12:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMTA1MQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r505611051", "bodyText": "Similary, could you remove the else clause plz?", "author": "minhtutonthat", "createdAt": "2020-10-15T14:56:25Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java", "diffHunk": "@@ -140,70 +111,28 @@ public static EObject getSendingEnd(SequenceMessage message) {\n     MessageEnd end = message.getSendingEnd();\n     if (end == null) {\n       return message; // found message case\n-    }\n+    } else {\n+      InstanceRole currentInstanceRole = currentInstanceRole(end);\n+      List<EventContext> eventContexts = EventContextServices.getEventContexts(currentInstanceRole);\n \n-    Scenario sc = (Scenario) message.eContainer();\n-    for (TimeLapse exec : sc.getOwnedTimeLapses()) {\n-      if (exec.getFinish() == end) {\n-        return exec;\n-      }\n+      Optional<EventContext> sendingEvent = eventContexts.stream()\n+          .filter(ec -> ec.isStart() && ec.getElement().equals(message)).findFirst();\n+      return sendingEvent.isPresent() ? sendingEvent.get().getParent() : currentInstanceRole;\n     }\n-    Execution execution = getExecutionOfMessageEnd(end);\n-\n-    return execution == null ? end.getCovered() : execution;\n   }\n \n   public static EObject getReceivingEnd(SequenceMessage message) {\n     MessageEnd end = message.getReceivingEnd();\n     if (end == null) {\n       return message; // lost message case\n-    }\n-    Scenario sc = (Scenario) message.eContainer();\n-    for (TimeLapse exec : sc.getOwnedTimeLapses()) {\n-      if (exec.getStart() == end) {\n-        return exec;\n-      }\n-    }\n-    Execution execution = getExecutionOfMessageEnd(end);\n-    return execution == null ? end.getCovered() : execution;\n-  }\n+    } else {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxNTY0OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507715648", "bodyText": "ok", "author": "mPorhel", "createdAt": "2020-10-19T12:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMTA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ0NTMxNg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506445316", "bodyText": "This class has a misleading name and location. This is not really a service (in the capella service sense), it is more a cache than a service.\n\nRename this class to ScenarioCache, make it a singleton and and move it to capella.core.sirius.analysis.cache.\nMove all of the caches (interactionCache, interactionFragmentToTimeLapseCache and all the others) and all the methods from the InteractionRefreshExtension to this ScenarioCache.\nThe InteractionRefreshExtension will only have an reference to the new ScenarioCache and activate/deactivate it.\nThe real services like ScenarioService will use the methods from the ScenarioCache.", "author": "sandupostaru", "createdAt": "2020-10-16T13:51:08Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ1OTAwNg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506459006", "bodyText": "Preambule:\nThank you for the contribution. The new caching system seems cool and I can see the benefits from this change \ud83d\udc4d\nMy comments ones are mostly related to style, class location, variable naming conventions and are not all that functional except for a few. Don't hesitate to come back to me if you need more details.", "author": "sandupostaru", "createdAt": "2020-10-16T14:03:02Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sequencediag/ScenarioService.java", "diffHunk": "@@ -88,6 +86,7 @@\n import org.polarsys.capella.core.model.helpers.queries.QueryIdentifierConstants;\n import org.polarsys.capella.core.model.helpers.queries.filters.OnlySharedDataOrEventOrUnsetFilter;\n import org.polarsys.capella.core.sirius.analysis.CapellaServices;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices;", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2NDYyNw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506464627", "bodyText": "The name of this class is confusing. There is already an Event class in Capella that has different meaning.\nA more suitable name  would be Sibling because this class contains siblings of InstanceRoles (closely related elements).\nAn sibling contains a parent which can be used to filter the children.", "author": "sandupostaru", "createdAt": "2020-10-16T14:07:30Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: \n+        //   EventContext(IR2, e1, true, 2)\n+        //   EventContext(e1, m1, false, 2)\n+        //   EventContext(e1, m2, true, 2)\n+        //   EventContext(e1, e3, true, 3)\n+        //   EventContext(e3, m3, false, 3)\n+        //   EventContext(e3, return_m3, true, 3)\n+        //   EventContext(e1, e3, false, 3)\n+        //   EventContext(e1, return_m1 true, 2)\n+        //   EventContext(IR2, e1, false, 2)\n+        //\n+        //  For IR3: \n+        //   EventContext(IR3, e3, true, 2)\n+        //   EventContext(e3, m2, false, 2)\n+        //   EventContext(IR3, e3, false, 2)\n+        // @formatter:on\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, InteractionState end,\n+      Optional<TimeLapse> timeLapse) {\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for ExecutionEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          ExecutionEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, ExecutionEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+    // Should not happen in current implementation of Capella Sequence diagrams\n+    if (timeLapse.isPresent() && timeLapse.get().getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Execution without return branch end / ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get().getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Return covered instance role.\n+   * \n+   * @param end\n+   *          InteractionFragment\n+   * @return covered instance role.\n+   */\n+  private static InstanceRole getCoveredInstanceRole(InteractionFragment end) {\n+    InstanceRole covered = null;\n+    if (end instanceof AbstractEnd) {\n+      covered = getInteractionCache(AbstractEnd::getCovered, (AbstractEnd) end);\n+    } else if (end instanceof InteractionState) {\n+      covered = getInteractionCache(InteractionState::getCovered, (InteractionState) end);\n+    }\n+    return covered;\n+  }\n+\n+  /**\n+   * Compute cache for TimeLapse start and finish ends.\n+   * \n+   * @param scenario\n+   *          Scenario\n+   */\n+  private static void computeTimeLapseStartAndEndCache(Scenario scenario) {\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // scan timelapse only one time\n+    if (getInteractionFragmentToTimeLapseCache().isEmpty()) {\n+      Stream<TimeLapse> timeLapses = scenario.getOwnedTimeLapses().stream()\n+          .filter(tl -> !(tl instanceof AbstractFragment));\n+      timeLapses.forEach(e -> {\n+        // Keep Interaction to TimeLapse info in cache\n+        // M2 allows to retrieve an Execution from an ExecutionEnd (execution.getFinish() when there is no\n+        // return branch : ASyncCall)\n+        // but not an Execution from a MessagEnd (SyncCall and ASyncCall) or a StateFragment from an\n+        // InteractionState.\n+        putTimeLapseInCache(e.getStart(), e);\n+        putTimeLapseInCache(e.getFinish(), e);\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Helper class to keep track of who \"contains\" who depending on the interleaving of the start/finish ends.\n+   * \n+   * @author pcdavid\n+   */\n+  public static final class EventContext {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcwMDg3OQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507700879", "bodyText": "Hi Sandu,\nWe kept Event,  EventContext and EventEnd as this is has a meaning in the Sirius Sequence diagram (used in layout, internal api ISequenceEvent), it was really helpfull in debug to have the same wording than in Sirius (refresh, layout) and not new vocabulary.\nIt was also a way to be sure to avoid to reuse TimeLapse, Fragments, ...", "author": "mPorhel", "createdAt": "2020-10-19T12:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2NDYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2ODMwOA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r508368308", "bodyText": "Hi Sandu.\nAfter discussion with Philippe, it is ok to rename the EventContext into something else, to avoid confusion with the \"event\" from the Capella M2 to help the maintainers of this code, but \"sibling\" does not look appropriate:\n\ndefinition of sibling: each of two or more children or offspring having one or both parents in common; a brother or sister.\n\nIMO, we should try to find another name, as the EventContext elements are not just siblings under the same parent, but their organization represents the hierarchical tree of Executions/States on the diagram and the structure is used from the VSM to build/find the semantic candidates for level/depth in evaluation of the mappings's expression during the SequenceDDiagram refresh.", "author": "mPorhel", "createdAt": "2020-10-20T09:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2NDYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2NjU3OQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506466579", "bodyText": "change to child", "author": "sandupostaru", "createdAt": "2020-10-16T14:08:54Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: \n+        //   EventContext(IR2, e1, true, 2)\n+        //   EventContext(e1, m1, false, 2)\n+        //   EventContext(e1, m2, true, 2)\n+        //   EventContext(e1, e3, true, 3)\n+        //   EventContext(e3, m3, false, 3)\n+        //   EventContext(e3, return_m3, true, 3)\n+        //   EventContext(e1, e3, false, 3)\n+        //   EventContext(e1, return_m1 true, 2)\n+        //   EventContext(IR2, e1, false, 2)\n+        //\n+        //  For IR3: \n+        //   EventContext(IR3, e3, true, 2)\n+        //   EventContext(e3, m2, false, 2)\n+        //   EventContext(IR3, e3, false, 2)\n+        // @formatter:on\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, InteractionState end,\n+      Optional<TimeLapse> timeLapse) {\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for ExecutionEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          ExecutionEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, ExecutionEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+    // Should not happen in current implementation of Capella Sequence diagrams\n+    if (timeLapse.isPresent() && timeLapse.get().getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Execution without return branch end / ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get().getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Return covered instance role.\n+   * \n+   * @param end\n+   *          InteractionFragment\n+   * @return covered instance role.\n+   */\n+  private static InstanceRole getCoveredInstanceRole(InteractionFragment end) {\n+    InstanceRole covered = null;\n+    if (end instanceof AbstractEnd) {\n+      covered = getInteractionCache(AbstractEnd::getCovered, (AbstractEnd) end);\n+    } else if (end instanceof InteractionState) {\n+      covered = getInteractionCache(InteractionState::getCovered, (InteractionState) end);\n+    }\n+    return covered;\n+  }\n+\n+  /**\n+   * Compute cache for TimeLapse start and finish ends.\n+   * \n+   * @param scenario\n+   *          Scenario\n+   */\n+  private static void computeTimeLapseStartAndEndCache(Scenario scenario) {\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // scan timelapse only one time\n+    if (getInteractionFragmentToTimeLapseCache().isEmpty()) {\n+      Stream<TimeLapse> timeLapses = scenario.getOwnedTimeLapses().stream()\n+          .filter(tl -> !(tl instanceof AbstractFragment));\n+      timeLapses.forEach(e -> {\n+        // Keep Interaction to TimeLapse info in cache\n+        // M2 allows to retrieve an Execution from an ExecutionEnd (execution.getFinish() when there is no\n+        // return branch : ASyncCall)\n+        // but not an Execution from a MessagEnd (SyncCall and ASyncCall) or a StateFragment from an\n+        // InteractionState.\n+        putTimeLapseInCache(e.getStart(), e);\n+        putTimeLapseInCache(e.getFinish(), e);\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Helper class to keep track of who \"contains\" who depending on the interleaving of the start/finish ends.\n+   * \n+   * @author pcdavid\n+   */\n+  public static final class EventContext {\n+    private final EObject parent;\n+\n+    private final boolean start;\n+\n+    private final EObject element;", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcwMTMyNA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507701324", "bodyText": "I am not sure, this is really the current element for which we want the parent.\nChild would be used if we wanted to compute the children of element.", "author": "mPorhel", "createdAt": "2020-10-19T12:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2NjU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2Njg2OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506466868", "bodyText": "getChild", "author": "sandupostaru", "createdAt": "2020-10-16T14:09:07Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: \n+        //   EventContext(IR2, e1, true, 2)\n+        //   EventContext(e1, m1, false, 2)\n+        //   EventContext(e1, m2, true, 2)\n+        //   EventContext(e1, e3, true, 3)\n+        //   EventContext(e3, m3, false, 3)\n+        //   EventContext(e3, return_m3, true, 3)\n+        //   EventContext(e1, e3, false, 3)\n+        //   EventContext(e1, return_m1 true, 2)\n+        //   EventContext(IR2, e1, false, 2)\n+        //\n+        //  For IR3: \n+        //   EventContext(IR3, e3, true, 2)\n+        //   EventContext(e3, m2, false, 2)\n+        //   EventContext(IR3, e3, false, 2)\n+        // @formatter:on\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, InteractionState end,\n+      Optional<TimeLapse> timeLapse) {\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for ExecutionEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          ExecutionEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, ExecutionEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+    // Should not happen in current implementation of Capella Sequence diagrams\n+    if (timeLapse.isPresent() && timeLapse.get().getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Execution without return branch end / ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get().getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Return covered instance role.\n+   * \n+   * @param end\n+   *          InteractionFragment\n+   * @return covered instance role.\n+   */\n+  private static InstanceRole getCoveredInstanceRole(InteractionFragment end) {\n+    InstanceRole covered = null;\n+    if (end instanceof AbstractEnd) {\n+      covered = getInteractionCache(AbstractEnd::getCovered, (AbstractEnd) end);\n+    } else if (end instanceof InteractionState) {\n+      covered = getInteractionCache(InteractionState::getCovered, (InteractionState) end);\n+    }\n+    return covered;\n+  }\n+\n+  /**\n+   * Compute cache for TimeLapse start and finish ends.\n+   * \n+   * @param scenario\n+   *          Scenario\n+   */\n+  private static void computeTimeLapseStartAndEndCache(Scenario scenario) {\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // scan timelapse only one time\n+    if (getInteractionFragmentToTimeLapseCache().isEmpty()) {\n+      Stream<TimeLapse> timeLapses = scenario.getOwnedTimeLapses().stream()\n+          .filter(tl -> !(tl instanceof AbstractFragment));\n+      timeLapses.forEach(e -> {\n+        // Keep Interaction to TimeLapse info in cache\n+        // M2 allows to retrieve an Execution from an ExecutionEnd (execution.getFinish() when there is no\n+        // return branch : ASyncCall)\n+        // but not an Execution from a MessagEnd (SyncCall and ASyncCall) or a StateFragment from an\n+        // InteractionState.\n+        putTimeLapseInCache(e.getStart(), e);\n+        putTimeLapseInCache(e.getFinish(), e);\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Helper class to keep track of who \"contains\" who depending on the interleaving of the start/finish ends.\n+   * \n+   * @author pcdavid\n+   */\n+  public static final class EventContext {\n+    private final EObject parent;\n+\n+    private final boolean start;\n+\n+    private final EObject element;\n+\n+    private final int level;\n+\n+    public EventContext(EObject parent, EObject element, boolean start, int level) {\n+      this.parent = parent;\n+      this.element = element;\n+      this.level = level;\n+      this.start = start;\n+    }\n+\n+    public boolean isStart() {\n+      return start;\n+    }\n+\n+    public EObject getParent() {\n+      return parent;\n+    }\n+\n+    public EObject getElement() {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2OTU2OQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506469569", "bodyText": "rename to getSiblings (see my comment on the renaming of the EventContext class)", "author": "sandupostaru", "createdAt": "2020-10-16T14:11:22Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3MDQ2Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506470467", "bodyText": "make this method private and rename to getSiblingChildren", "author": "sandupostaru", "createdAt": "2020-10-16T14:12:11Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3MTEzMg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506471132", "bodyText": "Rename element to parent and change the order of the parameters, instanceRole comes first, parent second", "author": "sandupostaru", "createdAt": "2020-10-16T14:12:47Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3OTI2Mw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506479263", "bodyText": "This code block  does not serve any purpose, since the getDirectEvents() at line 122 already does verify if the information is available in the cache. This block should thus be removed.", "author": "sandupostaru", "createdAt": "2020-10-16T14:22:42Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcwOTYxNQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507709615", "bodyText": "this code filters the directEvents and return only the executions.", "author": "mPorhel", "createdAt": "2020-10-19T12:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3OTI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3OTQ3Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506479472", "bodyText": "This code block  does not serve any purpose, since the getDirectEvents() at line 143 already does verify if the information is available in the cache. This block should thus be removed.", "author": "sandupostaru", "createdAt": "2020-10-16T14:22:57Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxMDIwMw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507710203", "bodyText": "the code block filters direct events found in cache to return the state elements.", "author": "mPorhel", "createdAt": "2020-10-19T12:35:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3OTQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxMDUzNQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507710535", "bodyText": "the line 143, compute the directs event, put them in cache and then we filter the result from here.", "author": "mPorhel", "createdAt": "2020-10-19T12:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3OTQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4MDUyMw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506480523", "bodyText": "rename to getSiblingExecutions, change parameter order and rename element to parent", "author": "sandupostaru", "createdAt": "2020-10-16T14:24:12Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4MDc2NA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506480764", "bodyText": "rename to getSiblingStateFragments, change parameter order and rename element to parent", "author": "sandupostaru", "createdAt": "2020-10-16T14:24:33Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4MjA3MA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506482070", "bodyText": "rename to computeSiblings", "author": "sandupostaru", "createdAt": "2020-10-16T14:26:03Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4MjU0OQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506482549", "bodyText": "rename to siblings", "author": "sandupostaru", "createdAt": "2020-10-16T14:26:29Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4Mjk4MA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506482980", "bodyText": "rename to interactionFragments", "author": "sandupostaru", "createdAt": "2020-10-16T14:26:53Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4MzM5Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506483392", "bodyText": "rename to interactionFragment", "author": "sandupostaru", "createdAt": "2020-10-16T14:27:19Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4MzgyMw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506483823", "bodyText": "coveredInstanceRole", "author": "sandupostaru", "createdAt": "2020-10-16T14:27:42Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4NDk0Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506484942", "bodyText": "check right away if timelapse is null / present here and thus avoid checking it in each of the visitMethods", "author": "sandupostaru", "createdAt": "2020-10-16T14:28:40Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxMTg3NA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507711874", "bodyText": "the visit (Message) case will do something even if there is no attached timelapse.", "author": "mPorhel", "createdAt": "2020-10-19T12:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4NDk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4NTc5MQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506485791", "bodyText": "See the comments for each of the visit methods", "author": "sandupostaru", "createdAt": "2020-10-16T14:29:27Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4NzI3OQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506487279", "bodyText": "rename to ComputeSiblings\nChange the order of the arguments and their name like so:\ncomputeSiblings(ancestors, timelapse->child , end -> executionEnd/state/messageEnd [depending on the method], result -> siblings)", "author": "sandupostaru", "createdAt": "2020-10-16T14:30:52Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4ODE1Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506488152", "bodyText": "same remark as above", "author": "sandupostaru", "createdAt": "2020-10-16T14:31:43Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: \n+        //   EventContext(IR2, e1, true, 2)\n+        //   EventContext(e1, m1, false, 2)\n+        //   EventContext(e1, m2, true, 2)\n+        //   EventContext(e1, e3, true, 3)\n+        //   EventContext(e3, m3, false, 3)\n+        //   EventContext(e3, return_m3, true, 3)\n+        //   EventContext(e1, e3, false, 3)\n+        //   EventContext(e1, return_m1 true, 2)\n+        //   EventContext(IR2, e1, false, 2)\n+        //\n+        //  For IR3: \n+        //   EventContext(IR3, e3, true, 2)\n+        //   EventContext(e3, m2, false, 2)\n+        //   EventContext(IR3, e3, false, 2)\n+        // @formatter:on\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, InteractionState end,", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4ODMzOQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506488339", "bodyText": "same remark as above", "author": "sandupostaru", "createdAt": "2020-10-16T14:31:51Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: \n+        //   EventContext(IR2, e1, true, 2)\n+        //   EventContext(e1, m1, false, 2)\n+        //   EventContext(e1, m2, true, 2)\n+        //   EventContext(e1, e3, true, 3)\n+        //   EventContext(e3, m3, false, 3)\n+        //   EventContext(e3, return_m3, true, 3)\n+        //   EventContext(e1, e3, false, 3)\n+        //   EventContext(e1, return_m1 true, 2)\n+        //   EventContext(IR2, e1, false, 2)\n+        //\n+        //  For IR3: \n+        //   EventContext(IR3, e3, true, 2)\n+        //   EventContext(e3, m2, false, 2)\n+        //   EventContext(IR3, e3, false, 2)\n+        // @formatter:on\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, InteractionState end,\n+      Optional<TimeLapse> timeLapse) {\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for ExecutionEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          ExecutionEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, ExecutionEnd end,", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5MzQxOQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506493419", "bodyText": "not needed since null check is moved in calling method", "author": "sandupostaru", "createdAt": "2020-10-16T14:36:53Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5NDA1Mw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506494053", "bodyText": "Thanks for the explication, this is nice \ud83d\udc4d", "author": "sandupostaru", "createdAt": "2020-10-16T14:37:29Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcwMTg2NA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507701864", "bodyText": "It was hard ten years after the main developments on Sequence to bring all memories together, it will be easier with this.", "author": "mPorhel", "createdAt": "2020-10-19T12:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5NDA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5NTc3Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506495776", "bodyText": "Why does this method return an optional? All of the other methods return null if the value is absent.\nLet's return a TimeLapse here ;)", "author": "sandupostaru", "createdAt": "2020-10-16T14:39:14Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n+\n+public class InteractionRefreshExtension implements IRefreshExtension {\n+\n+  /**\n+   * Generic cache (basically for getCovered).\n+   */\n+  private static Cache interactionCache = new Cache();\n+\n+  /**\n+   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n+   * way to get this information.)\n+   */\n+  private static Map<InteractionFragment, TimeLapse> interactionFragmentToTimeLapseCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n+   */\n+  private static Map<EObject, Collection<EObject>> directEventsCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for InstanceRole -> EventContext structure.\n+   */\n+  private static Map<InstanceRole, List<EventContext>> instanceRoleToEventContextsCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Is InteractionRefreshExtension caches enabled ?\n+   */\n+  private static boolean isCacheEnabled;\n+\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#beforeRefresh(org.eclipse.sirius.DDiagram)\n+   */\n+  @Override\n+  public void beforeRefresh(DDiagram diagram) {\n+      enableRefreshCache();\n+  }\n+\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#postRefresh(org.eclipse.sirius.DDiagram)\n+   */\n+  @Override\n+  public void postRefresh(DDiagram diagram) {\n+    clearCaches();\n+    disableRefreshCache();\n+  }\n+\n+  private void clearCaches() {\n+    interactionCache.clearCache();\n+    directEventsCache.clear();\n+    instanceRoleToEventContextsCache.clear();\n+    interactionFragmentToTimeLapseCache.clear();\n+  }\n+\n+  /**\n+   * \n+   * @param function\n+   * @param parameter\n+   * @return If enabled, return the cached result if any or apply the function to the given parameter and cache the\n+   *         result before returning it. //\n+   */\n+  public static <P, R> R getInteractionCache(Function<P, R> function, P parameter) {\n+    return interactionCache.get(function, parameter);\n+  }\n+\n+  /**\n+   * Get EventContext structure for instanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getInstanceRoleToEventContextCache(InstanceRole instanceRole) {\n+    return instanceRoleToEventContextsCache.get(instanceRole);\n+  }\n+\n+  /**\n+   * Put EventContext structure for instanceRole in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @param structure\n+   *          List<EventContext>\n+   */\n+  public static void putInstanceRoleToEventContextsCache(InstanceRole instanceRole, List<EventContext> structure) {\n+    instanceRoleToEventContextsCache.put(instanceRole, structure);\n+  }\n+\n+  /**\n+   * Get element container.\n+   * \n+   * @param capellaElement\n+   *          EObject\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEventsFromCache(EObject capellaElement) {\n+    return directEventsCache.get(capellaElement);\n+  }\n+\n+  /**\n+   * Put element -> container in cache.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param container\n+   *          Collection<EObject>\n+   */\n+  public static void putDirectEventsInCache(EObject element, Collection<EObject> container) {\n+    directEventsCache.put(element, container);\n+  }\n+\n+  /**\n+   * @param key\n+   *          InteractionFragment\n+   * @return Event corresponding to key.\n+   */\n+  public static Optional<TimeLapse> getTimeLapseFromCache(InteractionFragment key) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcwNzY2NA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507707664", "bodyText": "Because it is a special case :\nit is used  to simulate the \"MixEnd\" case : some MessageEnd are used as start/finish of an Execution additionnaly to being the start/finish of a message. But there is no end -> Execution/TimeLapse info in the M2.\nWe also use this cache to retrieve the InteractionState > StateFragment information.\nAnd to be consistent, we also store ExecutionEnd -> Execution.\nIf the cache returns null, IMO, this means that we put no entry in it. If the cache returns en empty Optional, this means that the TimeLapse in the model has no start or finish.\nBut looking at the implementation, it seems that putTimeLapseInCache should do nothing if the provided key is null and you are right getTimeLapseFromCache could return a TimeLapse, without Optional.", "author": "mPorhel", "createdAt": "2020-10-19T12:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5NTc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5Njc0Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506496747", "bodyText": "Lets call this Class ScenarioRefreshExtensionProvider in order to be coherent.", "author": "sandupostaru", "createdAt": "2020-10-16T14:40:13Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtensionProvider.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtensionProvider;\n+import org.eclipse.sirius.diagram.sequence.SequenceDDiagram;\n+\n+public class InteractionRefreshExtensionProvider implements IRefreshExtensionProvider {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5Njk4OQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506496989", "bodyText": "Lets call this Class ScenarioRefreshExtension in order to be coherent.", "author": "sandupostaru", "createdAt": "2020-10-16T14:40:29Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n+\n+public class InteractionRefreshExtension implements IRefreshExtension {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5ODQ5OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506498498", "bodyText": "We should also call clearCache() here, in case the root postRefresh Sirius method fails for whatever reason, and our postRefresh is not called.", "author": "sandupostaru", "createdAt": "2020-10-16T14:41:57Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n+\n+public class InteractionRefreshExtension implements IRefreshExtension {\n+\n+  /**\n+   * Generic cache (basically for getCovered).\n+   */\n+  private static Cache interactionCache = new Cache();\n+\n+  /**\n+   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n+   * way to get this information.)\n+   */\n+  private static Map<InteractionFragment, TimeLapse> interactionFragmentToTimeLapseCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n+   */\n+  private static Map<EObject, Collection<EObject>> directEventsCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for InstanceRole -> EventContext structure.\n+   */\n+  private static Map<InstanceRole, List<EventContext>> instanceRoleToEventContextsCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Is InteractionRefreshExtension caches enabled ?\n+   */\n+  private static boolean isCacheEnabled;\n+\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#beforeRefresh(org.eclipse.sirius.DDiagram)\n+   */\n+  @Override\n+  public void beforeRefresh(DDiagram diagram) {\n+      enableRefreshCache();", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "url": "https://github.com/eclipse/capella/commit/b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "message": "[563193] Capella Diagram Performance issues\n\nSigned-off-by: Nathalie Lepine <nathalie.lepine@obeo.fr>", "committedDate": "2020-10-20T08:38:19Z", "type": "forcePushed"}, {"oid": "4ff155ae64a57c94a9a3369c0b3368e96b89e654", "url": "https://github.com/eclipse/capella/commit/4ff155ae64a57c94a9a3369c0b3368e96b89e654", "message": "[563193] Capella Diagram Performance issues\n\nSigned-off-by: Nathalie Lepine <nathalie.lepine@obeo.fr>", "committedDate": "2020-10-20T19:27:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIxNjQwNg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r509216406", "bodyText": "The formatting of this section seems to be off. I think it was messed-up during the save + auto format.\nCan you restore it please?", "author": "sandupostaru", "createdAt": "2020-10-21T11:56:29Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java", "diffHunk": "@@ -0,0 +1,554 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.cache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+import org.polarsys.capella.core.sirius.analysis.SequenceDiagramServices;\n+\n+/**\n+ * Compute Scenario cache structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class ScenarioCache {\n+\n+  /**\n+   * Singleton.\n+   */\n+  private static ScenarioCache instance;\n+\n+  /**\n+   * Generic cache (basically for getCovered).\n+   */\n+  private Cache interactionCache = new Cache();\n+\n+  /**\n+   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n+   * way to get this information.)\n+   */\n+  private Map<InteractionFragment, TimeLapse> interactionFragmentToTimeLapseCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n+   */\n+  private Map<EObject, Collection<EObject>> semanticCandidatesCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for InstanceRole -> semantic candidate structure.\n+   */\n+  private Map<InstanceRole, List<SemanticCandidateContext>> instanceRoleToSemanticCandidateContextsCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Is InteractionRefreshExtension caches enabled ?\n+   */\n+  private boolean isCacheEnabled;\n+\n+  /**\n+   * Constructor.\n+   */\n+  private ScenarioCache() {\n+  }\n+\n+  /**\n+   * @return ScenarioCache\n+   */\n+  public static ScenarioCache getInstance() {\n+    if (instance == null) {\n+      instance = new ScenarioCache();\n+    }\n+    return instance;\n+  }\n+\n+  /**\n+   * Clear all caches.\n+   */\n+  public void clearCaches() {\n+    interactionCache.clearCache();\n+    semanticCandidatesCache.clear();\n+    instanceRoleToSemanticCandidateContextsCache.clear();\n+    interactionFragmentToTimeLapseCache.clear();\n+  }\n+\n+  /**\n+   * \n+   * @param function\n+   * @param parameter\n+   * @return If enabled, return the cached result if any or apply the function to the given parameter and cache the\n+   *         result before returning it. //\n+   */\n+  public <P, R> R getInteractionCache(Function<P, R> function, P parameter) {\n+    return interactionCache.get(function, parameter);\n+  }\n+\n+  /**\n+   * Get SemanticCandidateContext structure for instanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<SemanticCandidateContext>\n+   */\n+  public List<SemanticCandidateContext> getInstanceRoleToSemanticCandidateContextCache(InstanceRole instanceRole) {\n+    return instanceRoleToSemanticCandidateContextsCache.get(instanceRole);\n+  }\n+\n+  /**\n+   * Put SemanticCandidateContext structure for instanceRole in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @param structure\n+   *          List<SemanticCandidateContext>\n+   */\n+  public void putInstanceRoleToSemanticCandidateContextsCache(InstanceRole instanceRole,\n+      List<SemanticCandidateContext> structure) {\n+    instanceRoleToSemanticCandidateContextsCache.put(instanceRole, structure);\n+  }\n+\n+  /**\n+   * Get element container.\n+   * \n+   * @param capellaElement\n+   *          EObject\n+   * @return Collection<EObject>\n+   */\n+  public Collection<EObject> getSemanticCandidatesFromCache(EObject capellaElement) {\n+    return semanticCandidatesCache.get(capellaElement);\n+  }\n+\n+  /**\n+   * Put element -> container in cache.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param container\n+   *          Collection<EObject>\n+   */\n+  public void putSemanticCandidatesInCache(EObject element, Collection<EObject> container) {\n+    semanticCandidatesCache.put(element, container);\n+  }\n+\n+  /**\n+   * @param key\n+   *          InteractionFragment\n+   * @return TimeLapse corresponding to key.\n+   */\n+  public TimeLapse getTimeLapseFromCache(InteractionFragment key) {\n+    return interactionFragmentToTimeLapseCache.get(key);\n+  }\n+\n+  /**\n+   * Put end -> TimeLapse in cache.\n+   * \n+   * @param key\n+   *          InteractionFragment\n+   * @param value\n+   *          TimeLapse\n+   */\n+  public void putTimeLapseInCache(InteractionFragment key, TimeLapse value) {\n+    interactionFragmentToTimeLapseCache.put(key, value);\n+  }\n+\n+  /**\n+   * @return endToTimeLapseCache\n+   */\n+  public Map<InteractionFragment, TimeLapse> getInteractionFragmentToTimeLapseCache() {\n+    return interactionFragmentToTimeLapseCache;\n+  }\n+\n+  /**\n+   * @return if refresh cache is enabled\n+   */\n+  public boolean isRefreshCacheEnabled() {\n+    return isCacheEnabled;\n+  }\n+\n+  /**\n+   * Enable refresh cache.\n+   */\n+  public void enableRefreshCache() {\n+    isCacheEnabled = true;\n+  }\n+\n+  /**\n+   * Disable refresh cache.\n+   */\n+  public void disableRefreshCache() {\n+    isCacheEnabled = false;\n+  }\n+\n+  /**\n+   * Compute Scenario structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<SemanticCandidateContext>\n+   */\n+  public List<SemanticCandidateContext> getSemanticCandidateContexts(InstanceRole instanceRole) {\n+    List<SemanticCandidateContext> semanticCandidateContexts = getInstanceRoleToSemanticCandidateContextCache(\n+        instanceRole);\n+    if (semanticCandidateContexts == null) {\n+      semanticCandidateContexts = computeInstanceRoleSemanticCandidateContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToSemanticCandidateContextsCache(instanceRole, semanticCandidateContexts);\n+      }\n+    }\n+    return semanticCandidateContexts;\n+  }\n+\n+  /**\n+   * Get semantic candidate on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution\n+   * children + StateFragment)\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @param element\n+   *          EObject\n+   * @return Collection<EObject>\n+   */\n+  private Collection<EObject> getSemanticCandidates(InstanceRole instanceRole, EObject element) {\n+    Collection<EObject> semanticCandidates = getSemanticCandidatesFromCache(element);\n+    if (semanticCandidates == null) {\n+      // compute result from SemanticCandidateContext structure\n+      List<SemanticCandidateContext> semanticCandidateContexts = getSemanticCandidateContexts(instanceRole);\n+\n+      semanticCandidates = semanticCandidateContexts.stream().filter(scc -> element.equals(scc.getParent()))\n+          .map(SemanticCandidateContext::getElement).filter(candidate -> candidate != element).distinct()\n+          .collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putSemanticCandidatesInCache(element, semanticCandidates);\n+      }\n+    }\n+    return semanticCandidates;\n+  }\n+\n+  /**\n+   * Get Execution semantic candidates on element.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @param element\n+   *          EObject\n+   * @return Collection<EObject>\n+   */\n+  public Collection<Execution> getExecutionSemanticCandidates(InstanceRole instanceRole, EObject element) {\n+    return getSemanticCandidates(instanceRole, element).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment semantic candidates on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public List<StateFragment> getStateFragmentSemanticCandidates(InstanceRole instanceRole, EObject element) {\n+    return getSemanticCandidates(instanceRole, element).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute SemanticCandidateContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<SemanticCandidateContext>\n+   */\n+  private List<SemanticCandidateContext> computeInstanceRoleSemanticCandidateContextStructure(\n+      InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<SemanticCandidateContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> interactionFragments = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    interactionFragments.forEachOrdered(end -> {\n+      InstanceRole coveredInstanceRole = getCoveredInstanceRole(end);\n+      if (coveredInstanceRole != null && coveredInstanceRole.equals(instanceRole)) {\n+        TimeLapse timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, timeLapse, (ExecutionEnd) end, result);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, timeLapse, (InteractionState) end, result);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, timeLapse, (MessageEnd) end, result);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute Semantic candidate Structure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<SemanticCandidateContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private void visit(Deque<CapellaElement> ancestors, TimeLapse timeLapse, MessageEnd end,\n+      List<SemanticCandidateContext> result) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse instanceof Execution && ((Execution) timeLapse).getStart() == end) {\n+      result.add(new SemanticCandidateContext(ancestors.peek(), timeLapse, true, ancestors.size() + 1));\n+      ancestors.push(timeLapse);\n+    }\n+\n+    // Message - SemanticCandidateContext to directly know which execution/instanceRole DNode must be source/target of\n+    // the message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in interactionFragmentToTimeLapseCache)\n+    // - receiving end of the main branch (start of execution found in interactionFragmentToTimeLapseCache cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in interactionFragmentToTimeLapseCache cache, not yet\n+    // removed from the ancestor cache)\n+    // - receiving end of the return branch (no execution found in interactionFragmentToTimeLapseCache cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new SemanticCandidateContext(ancestors.peek(), message, end.equals(message.getSendingEnd()),\n+          ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse instanceof Execution && ((Execution) timeLapse).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new SemanticCandidateContext(ancestors.peek(), timeLapse, false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+    // The Following diagram would result in\n+    //\n+    // | IR1 | | IR2 ] | IR3 ]\n+    // | | |\n+    // | | |\n+    // |-------> - | e1 m1\n+    // | | |------> - e2 m2\n+    // | | | | |\n+    // | | - <-----| | e3 m3\n+    // | || | | |\n+    // | || | | |\n+    // | | - ----->| | return_m3\n+    // | | | | |\n+    // |<------- - | | return_m1\n+    // | | -\n+    // | | |\n+", "originalCommit": "4ff155ae64a57c94a9a3369c0b3368e96b89e654", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDEzMDA0MA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r510130040", "bodyText": "Hi Sandu,\nNathalie is on holidays until Monday.\nShe will fix this on Monday.\nWe need to disable the Eclipse formatter  for this section as it is the only solution to have a understandable view of the computation here.", "author": "mPorhel", "createdAt": "2020-10-22T12:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIxNjQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NjI1Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r511856256", "bodyText": "Done!", "author": "nlepine", "createdAt": "2020-10-26T10:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIxNjQwNg=="}], "type": "inlineReview"}, {"oid": "c0fe85dd3a57933440851cb057fce58bcf929455", "url": "https://github.com/eclipse/capella/commit/c0fe85dd3a57933440851cb057fce58bcf929455", "message": "[563193] Capella Diagram Performance issues\n\n\nSigned-off-by: Nathalie Lepine <nathalie.lepine@obeo.fr>", "committedDate": "2020-10-26T09:28:50Z", "type": "commit"}, {"oid": "c0fe85dd3a57933440851cb057fce58bcf929455", "url": "https://github.com/eclipse/capella/commit/c0fe85dd3a57933440851cb057fce58bcf929455", "message": "[563193] Capella Diagram Performance issues\n\n\nSigned-off-by: Nathalie Lepine <nathalie.lepine@obeo.fr>", "committedDate": "2020-10-26T09:28:50Z", "type": "forcePushed"}]}