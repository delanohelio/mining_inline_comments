{"pr_number": 1980, "pr_title": "Long range bot pathfinding", "pr_createdAt": "2020-05-29T05:52:52Z", "pr_url": "https://github.com/MegaMek/megamek/pull/1980", "timeline": [{"oid": "ef37048e9787a4e376b952949fa5249ff0420d67", "url": "https://github.com/MegaMek/megamek/commit/ef37048e9787a4e376b952949fa5249ff0420d67", "message": "work in progress", "committedDate": "2020-05-14T01:45:24Z", "type": "commit"}, {"oid": "66ef0843ef8d9da8ae1337ce7443c57079584c61", "url": "https://github.com/MegaMek/megamek/commit/66ef0843ef8d9da8ae1337ce7443c57079584c61", "message": "Merge branch 'master' of https://github.com/MegaMek/megamek into long_range_pathfinding", "committedDate": "2020-05-15T00:39:51Z", "type": "commit"}, {"oid": "048bcd6ebc34cb1c0fde53cc56b23bf3747a3f96", "url": "https://github.com/MegaMek/megamek/commit/048bcd6ebc34cb1c0fde53cc56b23bf3747a3f96", "message": "pathfinder work", "committedDate": "2020-05-15T18:14:19Z", "type": "commit"}, {"oid": "3ac2e0506ac7182c81aa627513d681e100276044", "url": "https://github.com/MegaMek/megamek/commit/3ac2e0506ac7182c81aa627513d681e100276044", "message": "Merge branch 'master' of https://github.com/MegaMek/megamek into long_range_pathfinding", "committedDate": "2020-05-16T00:46:20Z", "type": "commit"}, {"oid": "430e543b394dcd74e8fabe85ce03b4c50369519a", "url": "https://github.com/MegaMek/megamek/commit/430e543b394dcd74e8fabe85ce03b4c50369519a", "message": "pathfinder working", "committedDate": "2020-05-17T04:03:28Z", "type": "commit"}, {"oid": "a83acc7f535602a47cf124536cdcf09f78bbfa6f", "url": "https://github.com/MegaMek/megamek/commit/a83acc7f535602a47cf124536cdcf09f78bbfa6f", "message": "further pathfinder work", "committedDate": "2020-05-18T19:10:29Z", "type": "commit"}, {"oid": "2d3d742e07063deeeb20ef973468c1d880ef6d67", "url": "https://github.com/MegaMek/megamek/commit/2d3d742e07063deeeb20ef973468c1d880ef6d67", "message": "Merge branch 'master' of https://github.com/MegaMek/megamek into long_range_pathfinding", "committedDate": "2020-05-21T01:52:43Z", "type": "commit"}, {"oid": "0f2b8f2abf40bf3bb34d9642ac5977a08eb227f8", "url": "https://github.com/MegaMek/megamek/commit/0f2b8f2abf40bf3bb34d9642ac5977a08eb227f8", "message": "almost there", "committedDate": "2020-05-21T05:26:59Z", "type": "commit"}, {"oid": "67931af5b52b77653268923327b488d024d52808", "url": "https://github.com/MegaMek/megamek/commit/67931af5b52b77653268923327b488d024d52808", "message": "destination and fleeing", "committedDate": "2020-05-22T03:12:40Z", "type": "commit"}, {"oid": "6e8e4a4925735485aa5f37cceca5d84565978de5", "url": "https://github.com/MegaMek/megamek/commit/6e8e4a4925735485aa5f37cceca5d84565978de5", "message": "amphi capability, storage of unit behavior calc", "committedDate": "2020-05-22T05:13:17Z", "type": "commit"}, {"oid": "7cb3e6c704e8d5cf4af58305452ea7254b57784d", "url": "https://github.com/MegaMek/megamek/commit/7cb3e6c704e8d5cf4af58305452ea7254b57784d", "message": "clustering", "committedDate": "2020-05-24T04:51:59Z", "type": "commit"}, {"oid": "7cd3e4252e431185bd8681c6efe2fb2315ffb479", "url": "https://github.com/MegaMek/megamek/commit/7cd3e4252e431185bd8681c6efe2fb2315ffb479", "message": "mostly working", "committedDate": "2020-05-29T05:45:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2OTcyMA==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432269720", "bodyText": "Indicates that no such thing exists, I should probably make a note of that in a comment.", "author": "NickAragua", "createdAt": "2020-05-29T05:53:59Z", "path": "megamek/src/megamek/client/bot/princess/BasicPathRanker.java", "diffHunk": "@@ -772,9 +779,9 @@ public double distanceToClosestEnemy(Entity me, Coords position, IGame game) {\n         getOwner().methodBegin(BasicPathRanker.class, METHOD_NAME);\n \n         try {\n-            Entity closest = findClosestEnemy(me, position, game);\n+            Targetable closest = findClosestEnemy(me, position, game);\n             if (closest == null) {\n-                return 0;\n+                return -1;", "originalCommit": "7cd3e4252e431185bd8681c6efe2fb2315ffb479", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQwNDYyNg==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r433404626", "bodyText": "I concur that this should added, probably to the javadoc comment above", "author": "Windchild292", "createdAt": "2020-06-01T18:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2OTcyMA=="}], "type": "inlineReview"}, {"oid": "3aad8640b726f94ecb35051206e42180a55c2fd1", "url": "https://github.com/MegaMek/megamek/commit/3aad8640b726f94ecb35051206e42180a55c2fd1", "message": "Delete DeploymentState.java\n\nUnnecessary", "committedDate": "2020-05-29T05:54:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDAyMQ==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432270021", "bodyText": "This computation needs to be cached, as it is expensive and carried out repeatedly.", "author": "NickAragua", "createdAt": "2020-05-29T05:55:09Z", "path": "megamek/src/megamek/client/bot/princess/FireControl.java", "diffHunk": "@@ -2455,8 +2455,8 @@ FiringPlan getBestFiringPlan(final Entity shooter,\n      * @param useExtremeRange Is the extreme range optional rule in effect?\n      * @return The most damage done at that range.\n      */\n-    // todo cluster and other variable damage.\n-    double getMaxDamageAtRange(final Entity shooter,\n+    // todo: cluster and other variable damage.\n+    public static double getMaxDamageAtRange(final Entity shooter,", "originalCommit": "3aad8640b726f94ecb35051206e42180a55c2fd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDc3MQ==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432270771", "bodyText": "This situation is now handled by generating long-range paths, which are \"guaranteed\" to move the unit in the direction of the destination, unless it can't get there anyway.", "author": "NickAragua", "createdAt": "2020-05-29T05:57:42Z", "path": "megamek/src/megamek/client/bot/princess/PathRanker.java", "diffHunk": "@@ -172,13 +194,6 @@ abstract RankedPath rankPath(MovePath path, IGame game, int maxRange, double fal\n             \t\n                 Coords finalCoords = path.getFinalCoords();\n \n-                // If fleeing, skip any paths that don't get me closer to home.\n-                if (fleeing && (distanceToHomeEdge(finalCoords, homeEdge, game) >= startingHomeDistance)) {", "originalCommit": "3aad8640b726f94ecb35051206e42180a55c2fd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3Njk3NA==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432276974", "bodyText": "I wound up not using this, will likely remove it.", "author": "NickAragua", "createdAt": "2020-05-29T06:18:53Z", "path": "megamek/src/megamek/common/Coords.java", "diffHunk": "@@ -217,6 +220,50 @@ public final boolean isXOdd() {\n     public int direction(Coords d) {\n         return (int) Math.round(radian(d) / HEXSIDE) % 6;\n     }\n+    \n+    /**\n+     * Returns an approximate direction in which another coordinate lies; \n+     * 0 if the coordinates are equal\n+     */\n+    public int approximateDirection(Coords second, int initialDirection, int previousDirection) {", "originalCommit": "3aad8640b726f94ecb35051206e42180a55c2fd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyMjcyMg==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r433422722", "bodyText": "This is used in the commented out code on line 1394 BoardView1 (renderApproxHexDirection)", "author": "Windchild292", "createdAt": "2020-06-01T18:49:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3Njk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxNDkzMg==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432414932", "bodyText": "Are we guaranteed to have a move path here?", "author": "sixlettervariables", "createdAt": "2020-05-29T11:10:32Z", "path": "megamek/src/megamek/client/bot/princess/PathRanker.java", "diffHunk": "@@ -105,18 +107,40 @@ abstract RankedPath rankPath(MovePath path, IGame game, int maxRange, double fal\n             final BigDecimal numberPaths = new BigDecimal(validPaths.size());\n             BigDecimal count = BigDecimal.ZERO;\n             BigDecimal interval = new BigDecimal(5);\n+            \n+            boolean pathsHaveExpectedDamage = false;\n+            \n             for (MovePath path : validPaths) {\n                 count = count.add(BigDecimal.ONE);\n                 \n-                returnPaths.add(rankPath(path, game, maxRange, fallTolerance, startingHomeDistance, enemies,\n-                                         allyCenter));\n+                RankedPath rankedPath = rankPath(path, game, maxRange, fallTolerance, startingHomeDistance, enemies,\n+                        allyCenter);\n+                returnPaths.add(rankedPath);\n+                \n+                // we want to keep track of if any of the paths we've considered have some kind of damage potential\n+                pathsHaveExpectedDamage |= (rankedPath.getExpectedDamage() > 0);\n+                \n                 BigDecimal percent = count.divide(numberPaths, 2, RoundingMode.DOWN).multiply(new BigDecimal(100))\n                                           .round(new MathContext(0, RoundingMode.DOWN));\n                 if (percent.compareTo(interval) >= 0) {\n                     getOwner().sendChat(\"... \" + percent.intValue() + \"% complete.\", LogLevel.INFO);\n                     interval = percent.add(new BigDecimal(5));\n                 }\n             }\n+            \n+            Entity mover = movePaths.get(0).getEntity();", "originalCommit": "3aad8640b726f94ecb35051206e42180a55c2fd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMDQ5Nw==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432530497", "bodyText": "Yes. At the beginning of the method, there's an isEmpty check on movepaths that returns.", "author": "NickAragua", "createdAt": "2020-05-29T14:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxNDkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxNTc5NA==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432415794", "bodyText": "Should their behavior change back?", "author": "sixlettervariables", "createdAt": "2020-05-29T11:12:36Z", "path": "megamek/src/megamek/client/bot/princess/PathRanker.java", "diffHunk": "@@ -105,18 +107,40 @@ abstract RankedPath rankPath(MovePath path, IGame game, int maxRange, double fal\n             final BigDecimal numberPaths = new BigDecimal(validPaths.size());\n             BigDecimal count = BigDecimal.ZERO;\n             BigDecimal interval = new BigDecimal(5);\n+            \n+            boolean pathsHaveExpectedDamage = false;\n+            \n             for (MovePath path : validPaths) {\n                 count = count.add(BigDecimal.ONE);\n                 \n-                returnPaths.add(rankPath(path, game, maxRange, fallTolerance, startingHomeDistance, enemies,\n-                                         allyCenter));\n+                RankedPath rankedPath = rankPath(path, game, maxRange, fallTolerance, startingHomeDistance, enemies,\n+                        allyCenter);\n+                returnPaths.add(rankedPath);\n+                \n+                // we want to keep track of if any of the paths we've considered have some kind of damage potential\n+                pathsHaveExpectedDamage |= (rankedPath.getExpectedDamage() > 0);\n+                \n                 BigDecimal percent = count.divide(numberPaths, 2, RoundingMode.DOWN).multiply(new BigDecimal(100))\n                                           .round(new MathContext(0, RoundingMode.DOWN));\n                 if (percent.compareTo(interval) >= 0) {\n                     getOwner().sendChat(\"... \" + percent.intValue() + \"% complete.\", LogLevel.INFO);\n                     interval = percent.add(new BigDecimal(5));\n                 }\n             }\n+            \n+            Entity mover = movePaths.get(0).getEntity();\n+            UnitBehavior behaviorTracker = getOwner().getUnitBehaviorTracker();\n+            boolean noDamageButCanDoDamage = !pathsHaveExpectedDamage && (FireControl.getMaxDamageAtRange(mover, 1, false, false) > 0);\n+            \n+            // if we're trying to fight, but aren't going to be doing any damage no matter how we move\n+            // then let's try to get closer\n+            if(noDamageButCanDoDamage && behaviorTracker.getBehaviorType(mover, getOwner()) == BehaviorType.Engaged) {\n+                \n+                behaviorTracker.overrideBehaviorType(mover, BehaviorType.MoveToContact);\n+                return rankPaths(getOwner().getMovePathsAndSetNecessaryTargets(mover, true), game, maxRange, fallTolerance, ", "originalCommit": "3aad8640b726f94ecb35051206e42180a55c2fd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMTQzNg==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432531436", "bodyText": "No, that would result in an endless loop. The idea here is that if none of the considered paths have any damage potential whatsoever, we should move towards the nearest enemy unit instead.", "author": "NickAragua", "createdAt": "2020-05-29T14:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxNTc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxNjg3MA==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432416870", "bodyText": "Collections.emptyList unless it should be mutable.", "author": "sixlettervariables", "createdAt": "2020-05-29T11:15:08Z", "path": "megamek/src/megamek/client/bot/princess/Princess.java", "diffHunk": "@@ -1464,6 +1485,102 @@ protected void initFiring() {\n             methodEnd(getClass(), METHOD_NAME);\n         }\n     }\n+    \n+    /**\n+     * Function with side effects. Retrieves the move path collection we want\n+     * the entity to consider. Sometimes it's the standard \"circle\", sometimes it's pruned long-range movement paths\n+     */\n+    public List<MovePath> getMovePathsAndSetNecessaryTargets(Entity mover, boolean forceMoveToContact) {\n+        // if the mover can't move, then there's nothing for us to do here, let's cut out.\n+        if(mover.isImmobile()) {\n+            return new ArrayList<MovePath>();", "originalCommit": "3aad8640b726f94ecb35051206e42180a55c2fd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxODU3Mw==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432418573", "bodyText": "Will we always have paths here?", "author": "sixlettervariables", "createdAt": "2020-05-29T11:18:58Z", "path": "megamek/src/megamek/client/bot/princess/Princess.java", "diffHunk": "@@ -1464,6 +1485,102 @@ protected void initFiring() {\n             methodEnd(getClass(), METHOD_NAME);\n         }\n     }\n+    \n+    /**\n+     * Function with side effects. Retrieves the move path collection we want\n+     * the entity to consider. Sometimes it's the standard \"circle\", sometimes it's pruned long-range movement paths\n+     */\n+    public List<MovePath> getMovePathsAndSetNecessaryTargets(Entity mover, boolean forceMoveToContact) {\n+        // if the mover can't move, then there's nothing for us to do here, let's cut out.\n+        if(mover.isImmobile()) {\n+            return new ArrayList<MovePath>();\n+        }\n+        \n+        BehaviorType behavior = forceMoveToContact ? BehaviorType.MoveToContact : unitBehaviorTracker.getBehaviorType(mover, this);\n+        boardClusterTracker.clearMovableAreas();\n+        boardClusterTracker.updateMovableAreas(mover);\n+        \n+        // basic idea: \n+        // if we're \"in battle\", just use the standard set of move paths\n+        // if we're trying to get somewhere\n+        //  - sort all long range paths by \"mp cost\" (actual MP + how long it'll take to do terrain leveling)\n+        //  - set the first terrain/building as 'strategic target' if the shortest path requires terrain leveling\n+        //  - if the first strategic target is in LOS at the pruned end of the shortest path,  \n+        //      then we actually return the paths for \"engaged\" behavior\n+        // TODO: special case is 'move to contact' mode, which should evaluate the long range paths if none of the\n+        // basic paths produce potential damage \n+        \n+        switch(behavior) {\n+        case Engaged:\n+            return getPrecognition().getPathEnumerator()\n+                    .getUnitPaths()\n+                    .get(mover.getId());\n+        case MoveToDestination:\n+        case MoveToContact:\n+        case ForcedWithdrawal:\n+        default:\n+            List<BulldozerMovePath> bulldozerPaths = getPrecognition().getPathEnumerator().\n+                getLongRangePaths().get(mover.getId());\n+            \n+            // for whatever reason (most likely it's wheeled), there are no long-range paths for this unit, \n+            // so just have it mill around in place as usual. Also set the behavior to \"engaged\"\n+            // so it doesn't hump the walls due to \"self preservation mods\"\n+            if ((bulldozerPaths == null) || (bulldozerPaths.size() == 0)) {\n+                getUnitBehaviorTracker().overrideBehaviorType(mover, BehaviorType.NoPathToDestination);\n+                return getPrecognition().getPathEnumerator()\n+                        .getUnitPaths()\n+                        .get(mover.getId());\n+            }\n+            \n+            Collections.sort(bulldozerPaths, new BulldozerMovePath.MPCostComparator());\n+            \n+            // if the quickest route needs some terrain adjustments, let's get working on that\n+            Targetable levelingTarget = null;\n+            \n+            if (bulldozerPaths.get(0).needsLeveling()) {", "originalCommit": "3aad8640b726f94ecb35051206e42180a55c2fd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMjExMg==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432532112", "bodyText": "Yes, on line 1528 there's a \"null or size 0\" check.", "author": "NickAragua", "createdAt": "2020-05-29T14:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxODU3Mw=="}], "type": "inlineReview"}, {"oid": "86e107831bade31c620393118ec1d5f5de861417", "url": "https://github.com/MegaMek/megamek/commit/86e107831bade31c620393118ec1d5f5de861417", "message": "minor bug fixes", "committedDate": "2020-05-29T15:36:58Z", "type": "commit"}, {"oid": "ab854ed9897e89e1bc02fee0ebc982f2083bf1e2", "url": "https://github.com/MegaMek/megamek/commit/ab854ed9897e89e1bc02fee0ebc982f2083bf1e2", "message": "Merge branch 'long_range_pathfinding' of https://github.com/NickAragua/megamek into long_range_pathfinding", "committedDate": "2020-05-29T15:37:54Z", "type": "commit"}, {"oid": "87d8da3ec65a968c8929bcdecc53086616a74199", "url": "https://github.com/MegaMek/megamek/commit/87d8da3ec65a968c8929bcdecc53086616a74199", "message": "fix unit test", "committedDate": "2020-05-29T16:09:01Z", "type": "commit"}, {"oid": "e3d3e5a001c4fe16a5f591004075c029a0f1934f", "url": "https://github.com/MegaMek/megamek/commit/e3d3e5a001c4fe16a5f591004075c029a0f1934f", "message": "Enable VTOLs to adjust altitude", "committedDate": "2020-05-30T01:19:57Z", "type": "commit"}, {"oid": "b8154746c265f11bbfffacb305ece8e9396f2806", "url": "https://github.com/MegaMek/megamek/commit/b8154746c265f11bbfffacb305ece8e9396f2806", "message": "fix water depth calculation error", "committedDate": "2020-05-30T02:00:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NzU1Mw==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432867553", "bodyText": "This may be null, especially if elevation changes prevent any neighbor to be added (perhaps they jumped into a hole).", "author": "sixlettervariables", "createdAt": "2020-05-30T16:21:31Z", "path": "megamek/src/megamek/common/pathfinder/BoardClusterTracker.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+* MegaMek -\n+* Copyright (C) 2020 The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package megamek.common.pathfinder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.client.bot.princess.CardinalEdge;\n+import megamek.common.BulldozerMovePath;\n+import megamek.common.Coords;\n+import megamek.common.Entity;\n+import megamek.common.EntityMovementMode;\n+import megamek.common.IBoard;\n+import megamek.common.IGame;\n+import megamek.common.MiscType;\n+import megamek.common.util.BoardUtilities;\n+\n+/**\n+ * This class handles the tracking of \"clusters\" of movable areas for various movement types, \n+ * either with or without destruction awareness.\n+ */\n+public class BoardClusterTracker {\n+    /**\n+     * Movement types that are relevant for \"destruction-aware pathfinding\"\n+     * Have a close relationship but are not exactly one to one with entity movement modes.\n+     */\n+    public static enum MovementType {\n+        Walker,\n+        Wheeled,\n+        WheeledAmphi,\n+        Tracked,\n+        TrackedAmphi,\n+        Hover,\n+        Jump,\n+        Flyer,\n+        Water,\n+        None;\n+        \n+        /**\n+         * Figures out the relevant entity movement mode (for path caching) based on properties \n+         * of the entity. Mostly just movement mode, but some complications exist for tracked/wheeled vehicles.\n+         */\n+        public static MovementType getMovementType(Entity entity) {\n+            switch(entity.getMovementMode()) {\n+                case BIPED:\n+                case TRIPOD:\n+                case QUAD:\n+                case INF_LEG:\n+                    return Walker;\n+                case TRACKED:\n+                    return entity.hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS) ? TrackedAmphi : Tracked;\n+                    //technically  MiscType.F_AMPHIBIOUS and MiscType.F_LIMITED_AMPHIBIOUS apply here too, but are not implemented in general\n+                case WHEELED:\n+                    return entity.hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS) ? WheeledAmphi : Wheeled;\n+                case HOVER:\n+                    return Hover;\n+                case BIPED_SWIM:\n+                case QUAD_SWIM:\n+                case INF_UMU:\n+                case SUBMARINE:\n+                case NAVAL:\n+                case HYDROFOIL:\n+                    return Water;\n+                case VTOL:\n+                    return Flyer;\n+                default:\n+                    return None;\n+            }\n+        }\n+    }\n+    \n+    private Map<MovementType, Map<Coords, BoardCluster>> movableAreas = new HashMap<>();\n+    private Map<MovementType, Map<Coords, BoardCluster>> movableAreasWithTerrainReduction = new HashMap<>();\n+\n+    /**\n+     * Returns a set of coordinates on a given board edge that intersects with the cluster\n+     * in which the given entity resides. May return an empty set.\n+     */\n+    public Set<Coords> getDestinationCoords(Entity entity, CardinalEdge edge, boolean terrainReduction) {\n+        CardinalEdge actualEdge = edge;\n+        if(edge == CardinalEdge.NEAREST_OR_NONE) {\n+            actualEdge = BoardUtilities.getClosestEdge(entity);\n+        }\n+        \n+        updateMovableAreas(entity);\n+        \n+        MovementType movementType = MovementType.getMovementType(entity);\n+        BoardCluster entityCluster = null;\n+        \n+        if(terrainReduction) {\n+            entityCluster = movableAreasWithTerrainReduction.get(movementType).get(entity.getPosition());\n+        } else {\n+            entityCluster = movableAreas.get(movementType).get(entity.getPosition());\n+        }\n+        \n+        if(entityCluster != null) {\n+            return entityCluster.getIntersectingHexes(actualEdge, entity.getGame().getBoard());\n+        }\n+        \n+        return null;\n+    }\n+    \n+    /**\n+     * Resets board clusters\n+     */\n+    public void clearMovableAreas() {\n+        movableAreas.clear();\n+        movableAreasWithTerrainReduction.clear();\n+    }\n+    \n+    /**\n+     * Updates and stores accessible clusters for the given entity,\n+     * both for destruction and non-destruction-aware path finding.\n+     */\n+    public void updateMovableAreas(Entity entity) {\n+        MovementType movementType = MovementType.getMovementType(entity);\n+        \n+        movableAreas.putIfAbsent(movementType, generateClusters(entity, false));\n+        movableAreasWithTerrainReduction.putIfAbsent(movementType, generateClusters(entity, true));\n+    }\n+\n+    /**\n+     * Returns accessible clusters for the given entity.\n+     */\n+    public Map<Coords, BoardCluster> generateClusters(Entity entity, boolean destructionAware) { \n+        Map<Coords, BoardCluster> clusters = new HashMap<>();\n+        \n+        // start with (0, 0)\n+        // for each hex:\n+        // if hex is not accessible to this entity, move on\n+        // if hex is accessible, check if its neighbors are in a cluster\n+        // for each neighbor in a cluster, check if we can move from this hex to the neighbor and back \n+        //      if yes, flag for joining neighbor's cluster\n+        //      note that if any other neighbor is in a different cluster, and we can move back and forth, we merge the two clusters\n+        // if no neighbors or cannot move back and forth between hex and neighbors, start new cluster\n+        \n+        if (entity == null || entity.getGame() == null) {\n+            return clusters;\n+        }\n+        \n+        IBoard board = entity.getGame().getBoard();\n+        int clusterID = 0;\n+        \n+        boolean isHovercraft = entity.getMovementMode() == EntityMovementMode.HOVER;\n+        boolean isAmphibious = entity.hasWorkingMisc(MiscType.F_AMPHIBIOUS) ||\n+                                entity.hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS) ||\n+                                entity.hasWorkingMisc(MiscType.F_LIMITED_AMPHIBIOUS);\n+        \n+        for(int x = 0; x < board.getWidth(); x++) {\n+            for(int y = 0; y < board.getHeight(); y++) {\n+                Coords c = new Coords(x, y);\n+                \n+                // hex is either inaccessible\n+                // or it is inaccessible AND we can't level it, then we move on\n+                if (entity.isLocationProhibited(c) && \n+                        (!destructionAware || (destructionAware && !canLevel(entity, c)))) {\n+                    continue;\n+                }\n+                \n+                List<Coords> neighborsToJoin = new ArrayList<>();\n+                BoardCluster biggestNeighbor = null; \n+                \n+                // hex is accessible one way or another\n+                for(int direction = 0; direction < 6; direction++) {\n+                    Coords neighbor = c.translated(direction);\n+                    \n+                    if(clusters.containsKey(neighbor)) {\n+                        int neighborElevation = BoardEdgePathFinder.calculateUnitElevationInHex(board.getHex(neighbor), entity, isHovercraft, isAmphibious);\n+                        int myElevation = BoardEdgePathFinder.calculateUnitElevationInHex(board.getHex(c), entity, isHovercraft, isAmphibious);\n+                        \n+                        // if we can't reach from here to the neighbor due to elevation differences, move on\n+                        int elevationDiff = Math.abs(neighborElevation - myElevation);\n+                        if(elevationDiff > entity.getMaxElevationChange()) {\n+                            continue;\n+                        }\n+                        \n+                        // we can \"freely\" go back and forth between ourselves and the neighbor, so let's join that cluster \n+                        neighborsToJoin.add(neighbor);\n+                        \n+                        if((biggestNeighbor == null) || \n+                                (clusters.get(neighbor).contents.size() > biggestNeighbor.contents.size())) {\n+                            biggestNeighbor = clusters.get(neighbor);\n+                        }\n+                    }\n+                }\n+                \n+                // start up a new cluster if we have no mutually accessible neighbors\n+                if(neighborsToJoin.isEmpty()) {\n+                    BoardCluster newCluster = new BoardCluster(clusterID++);\n+                    newCluster.contents.add(c);\n+                    clusters.put(c, newCluster);\n+                // otherwise, join an existing cluster, bringing any other mutually accessible neighbors and their clusters with me\n+                // join the biggest neighbor to reduce shuffling.\n+                } else {\n+                    biggestNeighbor.contents.add(c);", "originalCommit": "b8154746c265f11bbfffacb305ece8e9396f2806", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5OTU1MA==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432899550", "bodyText": "I think it's actually not possible, because if it's null then neighborsToJoin is empty, and then it goes into the \"new cluster\" logic, but I'll add it to that clause out of an abundance of caution.", "author": "NickAragua", "createdAt": "2020-05-31T00:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NzU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NzY3Ng==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432867676", "bodyText": "This is dead code.", "author": "sixlettervariables", "createdAt": "2020-05-30T16:23:30Z", "path": "megamek/src/megamek/common/pathfinder/DestructionAwareDestinationPathfinder.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+* MegaMek -\n+* Copyright (C) 2020 The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package megamek.common.pathfinder;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import megamek.client.bot.princess.AeroPathUtil;\n+import megamek.common.BulldozerMovePath;\n+import megamek.common.Coords;\n+import megamek.common.Entity;\n+import megamek.common.IBoard;\n+import megamek.common.MovePath;\n+import megamek.common.MovePath.MoveStepType;\n+import megamek.common.PlanetaryConditions;\n+\n+/**\n+ * Handles the generation of ground-based move paths that contain information relating to the destruction \n+ * of terrain necessary to accomplish that path.\n+ */\n+public class DestructionAwareDestinationPathfinder extends BoardEdgePathFinder {\n+\n+    Comparator<BulldozerMovePath> movePathComparator;\n+    int maximumCost = Integer.MAX_VALUE;\n+    \n+    /**\n+     * Uses an A* search to find the \"optimal\" path to the destination coordinates.\n+     * Ignores move cost and makes note of hexes that need to be cleared for the path to\n+     * be viable.\n+     */\n+    public BulldozerMovePath findPathToCoords(Entity entity, Set<Coords> destinationCoords) {\n+        return findPathToCoords(entity, destinationCoords, false);\n+    }\n+    \n+    /**\n+     * Uses an A* search to find the \"optimal\" path to the destination coordinates.\n+     * Ignores move cost and makes note of hexes that need to be cleared for the path to\n+     * be viable.\n+     */\n+    public BulldozerMovePath findPathToCoords(Entity entity, Set<Coords> destinationCoords, boolean jump) {\n+        BulldozerMovePath startPath = new BulldozerMovePath(entity.getGame(), entity);\n+        \n+        if(entity.getDisplayName().contains(\"Zibler\")) {\n+            int alpha = 1;", "originalCommit": "b8154746c265f11bbfffacb305ece8e9396f2806", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2Nzc1Nw==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432867757", "bodyText": "Dead code.", "author": "sixlettervariables", "createdAt": "2020-05-30T16:25:06Z", "path": "megamek/src/megamek/common/pathfinder/DestructionAwareDestinationPathfinder.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+* MegaMek -\n+* Copyright (C) 2020 The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package megamek.common.pathfinder;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import megamek.client.bot.princess.AeroPathUtil;\n+import megamek.common.BulldozerMovePath;\n+import megamek.common.Coords;\n+import megamek.common.Entity;\n+import megamek.common.IBoard;\n+import megamek.common.MovePath;\n+import megamek.common.MovePath.MoveStepType;\n+import megamek.common.PlanetaryConditions;\n+\n+/**\n+ * Handles the generation of ground-based move paths that contain information relating to the destruction \n+ * of terrain necessary to accomplish that path.\n+ */\n+public class DestructionAwareDestinationPathfinder extends BoardEdgePathFinder {\n+\n+    Comparator<BulldozerMovePath> movePathComparator;\n+    int maximumCost = Integer.MAX_VALUE;\n+    \n+    /**\n+     * Uses an A* search to find the \"optimal\" path to the destination coordinates.\n+     * Ignores move cost and makes note of hexes that need to be cleared for the path to\n+     * be viable.\n+     */\n+    public BulldozerMovePath findPathToCoords(Entity entity, Set<Coords> destinationCoords) {\n+        return findPathToCoords(entity, destinationCoords, false);\n+    }\n+    \n+    /**\n+     * Uses an A* search to find the \"optimal\" path to the destination coordinates.\n+     * Ignores move cost and makes note of hexes that need to be cleared for the path to\n+     * be viable.\n+     */\n+    public BulldozerMovePath findPathToCoords(Entity entity, Set<Coords> destinationCoords, boolean jump) {\n+        BulldozerMovePath startPath = new BulldozerMovePath(entity.getGame(), entity);\n+        \n+        if(entity.getDisplayName().contains(\"Zibler\")) {\n+            int alpha = 1;\n+        }\n+        \n+        // if we're calculating a jump path and the entity has jump mp and can jump, start off with a jump\n+        // if we're trying to calc a jump path and the entity does not have jump mp, we're done\n+        if(jump && (startPath.getCachedEntityState().getJumpMPWithTerrain() > 0) &&\n+                !entity.isProne() && !entity.isHullDown() && \n+                (entity.getGame().getPlanetaryConditions().getWindStrength() != PlanetaryConditions.WI_TORNADO_F4)) {\n+            startPath.addStep(MoveStepType.START_JUMP);\n+        // if we specified a jump path, but can't actually jump\n+        } else if (jump) {\n+            return null;\n+        // can't \"climb into\" anything while jumping\n+        } else { \n+            if(entity.hasETypeFlag(Entity.ETYPE_INFANTRY)) {\n+                startPath.addStep(MoveStepType.CLIMB_MODE_OFF);\n+            } else {\n+                startPath.addStep(MoveStepType.CLIMB_MODE_ON);\n+            }\n+        }\n+        \n+        // if we're on the ground, let's try to get up first before moving \n+        if(entity.isProne() || entity.isHullDown()) {\n+            startPath.addStep(MoveStepType.GET_UP);\n+        }\n+\n+        Coords closest = getClosestCoords(destinationCoords, entity);\n+        // if we can't at all get to the coordinates with this entity, don't bother with the rest \n+        if (closest == null) {\n+            return null;\n+        }\n+        \n+        movePathComparator = new AStarComparator(closest);\n+        maximumCost = Integer.MAX_VALUE;\n+        \n+        TreeSet<BulldozerMovePath> candidates = new TreeSet<>(movePathComparator);\n+        candidates.add(startPath);\n+\n+        // a collection of coordinates we've already visited, so we don't loop back.\n+        Map<Coords, BulldozerMovePath> shortestPathsToCoords = new HashMap<>();\n+        shortestPathsToCoords.put(startPath.getFinalCoords(), startPath);\n+        BulldozerMovePath bestPath = null;\n+\n+        while(!candidates.isEmpty()) {\n+            BulldozerMovePath currentPath = candidates.pollFirst();\n+            \n+            if(currentPath.getFinalCoords().getX() == 9 &&\n+                    currentPath.getFinalCoords().getY() == 59) {\n+                int alpha = 1;", "originalCommit": "b8154746c265f11bbfffacb305ece8e9396f2806", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2ODM4MA==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432868380", "bodyText": "dead code", "author": "sixlettervariables", "createdAt": "2020-05-30T16:34:43Z", "path": "megamek/src/megamek/common/pathfinder/DestructionAwareDestinationPathfinder.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+* MegaMek -\n+* Copyright (C) 2020 The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package megamek.common.pathfinder;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import megamek.client.bot.princess.AeroPathUtil;\n+import megamek.common.BulldozerMovePath;\n+import megamek.common.Coords;\n+import megamek.common.Entity;\n+import megamek.common.IBoard;\n+import megamek.common.MovePath;\n+import megamek.common.MovePath.MoveStepType;\n+import megamek.common.PlanetaryConditions;\n+\n+/**\n+ * Handles the generation of ground-based move paths that contain information relating to the destruction \n+ * of terrain necessary to accomplish that path.\n+ */\n+public class DestructionAwareDestinationPathfinder extends BoardEdgePathFinder {\n+\n+    Comparator<BulldozerMovePath> movePathComparator;\n+    int maximumCost = Integer.MAX_VALUE;\n+    \n+    /**\n+     * Uses an A* search to find the \"optimal\" path to the destination coordinates.\n+     * Ignores move cost and makes note of hexes that need to be cleared for the path to\n+     * be viable.\n+     */\n+    public BulldozerMovePath findPathToCoords(Entity entity, Set<Coords> destinationCoords) {\n+        return findPathToCoords(entity, destinationCoords, false);\n+    }\n+    \n+    /**\n+     * Uses an A* search to find the \"optimal\" path to the destination coordinates.\n+     * Ignores move cost and makes note of hexes that need to be cleared for the path to\n+     * be viable.\n+     */\n+    public BulldozerMovePath findPathToCoords(Entity entity, Set<Coords> destinationCoords, boolean jump) {\n+        BulldozerMovePath startPath = new BulldozerMovePath(entity.getGame(), entity);\n+        \n+        if(entity.getDisplayName().contains(\"Zibler\")) {\n+            int alpha = 1;\n+        }\n+        \n+        // if we're calculating a jump path and the entity has jump mp and can jump, start off with a jump\n+        // if we're trying to calc a jump path and the entity does not have jump mp, we're done\n+        if(jump && (startPath.getCachedEntityState().getJumpMPWithTerrain() > 0) &&\n+                !entity.isProne() && !entity.isHullDown() && \n+                (entity.getGame().getPlanetaryConditions().getWindStrength() != PlanetaryConditions.WI_TORNADO_F4)) {\n+            startPath.addStep(MoveStepType.START_JUMP);\n+        // if we specified a jump path, but can't actually jump\n+        } else if (jump) {\n+            return null;\n+        // can't \"climb into\" anything while jumping\n+        } else { \n+            if(entity.hasETypeFlag(Entity.ETYPE_INFANTRY)) {\n+                startPath.addStep(MoveStepType.CLIMB_MODE_OFF);\n+            } else {\n+                startPath.addStep(MoveStepType.CLIMB_MODE_ON);\n+            }\n+        }\n+        \n+        // if we're on the ground, let's try to get up first before moving \n+        if(entity.isProne() || entity.isHullDown()) {\n+            startPath.addStep(MoveStepType.GET_UP);\n+        }\n+\n+        Coords closest = getClosestCoords(destinationCoords, entity);\n+        // if we can't at all get to the coordinates with this entity, don't bother with the rest \n+        if (closest == null) {\n+            return null;\n+        }\n+        \n+        movePathComparator = new AStarComparator(closest);\n+        maximumCost = Integer.MAX_VALUE;\n+        \n+        TreeSet<BulldozerMovePath> candidates = new TreeSet<>(movePathComparator);\n+        candidates.add(startPath);\n+\n+        // a collection of coordinates we've already visited, so we don't loop back.\n+        Map<Coords, BulldozerMovePath> shortestPathsToCoords = new HashMap<>();\n+        shortestPathsToCoords.put(startPath.getFinalCoords(), startPath);\n+        BulldozerMovePath bestPath = null;\n+\n+        while(!candidates.isEmpty()) {\n+            BulldozerMovePath currentPath = candidates.pollFirst();\n+            \n+            if(currentPath.getFinalCoords().getX() == 9 &&\n+                    currentPath.getFinalCoords().getY() == 59) {\n+                int alpha = 1;\n+            }\n+            \n+            candidates.addAll(generateChildNodes(currentPath, shortestPathsToCoords));\n+            \n+            if(destinationCoords.contains(currentPath.getFinalCoords()) &&\n+                    (bestPath == null || movePathComparator.compare(bestPath, currentPath) < 0)) {\n+                bestPath = currentPath;\n+                maximumCost = bestPath.getMpUsed() + bestPath.getLevelingCost();\n+            }\n+        }\n+  \n+        return bestPath;\n+    }\n+    \n+    /**\n+     * Calculates the closest coordinates to the given entity\n+     * Coordinates which you have to blow up to get into are considered to be further\n+     */\n+    public static Coords getClosestCoords(Set<Coords> destinationRegion, Entity entity) {\n+        Coords bestCoords = null;\n+        int bestDistance = Integer.MAX_VALUE;\n+        \n+        for(Coords coords : destinationRegion) {\n+            if(!entity.getGame().getBoard().contains(coords)) {\n+                continue;\n+            }\n+            \n+            int levelingCost = BulldozerMovePath.calculateLevelingCost(coords, entity);\n+            boolean canLevel = levelingCost > BulldozerMovePath.CANNOT_LEVEL;\n+            \n+            if(!entity.isLocationProhibited(coords) || canLevel) {\n+                int distance = coords.distance(entity.getPosition()) + (canLevel ? levelingCost : 0);\n+                if(distance < bestDistance) {\n+                    bestDistance = distance;\n+                    bestCoords = coords;\n+                }\n+            }\n+        }\n+        \n+        return bestCoords;\n+    }\n+    \n+    /**\n+     * Function that generates all possible \"legal\" moves resulting from the given path\n+     * and updates the set of visited coordinates so we don't visit them again.\n+     * @param parentPath The path for which to generate child nodes\n+     * @param visitedCoords Set of visited coordinates so we don't loop around\n+     * @return List of valid children. Between 0 and 3 inclusive.\n+     */\n+    protected List<BulldozerMovePath> generateChildNodes(BulldozerMovePath parentPath, Map<Coords, BulldozerMovePath> shortestPathsToCoords) {\n+        List<BulldozerMovePath> children = new ArrayList<>();\n+\n+        // there are six possible children of a move path, defined in AeroPathUtil.TURNS\n+        for(List<MoveStepType> turns : AeroPathUtil.TURNS) {\n+            BulldozerMovePath childPath = (BulldozerMovePath) parentPath.clone();\n+            \n+            // apply the list of turn steps\n+            for(MoveStepType stepType : turns) {\n+                childPath.addStep(stepType);\n+            }\n+            \n+            // potentially apply UP so we can hop over unwanted terrain\n+            PathDecorator.AdjustElevationForForwardMovement(childPath);\n+            \n+            // move forward and process the generated child path\n+            childPath.addStep(MoveStepType.FORWARDS);\n+            processChild(childPath, children, shortestPathsToCoords);\n+        }\n+\n+        return children;\n+    }\n+    \n+    /**\n+     * Helper function that handles logic related to potentially adding a generated child path\n+     * to the list of child paths.\n+     */\n+    protected void processChild(BulldozerMovePath child, List<BulldozerMovePath> children, \n+            Map<Coords, BulldozerMovePath> shortestPathsToCoords) {\n+        int alpha = 1;", "originalCommit": "b8154746c265f11bbfffacb305ece8e9396f2806", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2ODY4OQ==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432868689", "bodyText": "Why not:\nif (dd != 0) {\n   return dd;\n}\n\ndd = ShortestPathFinder.getFacingDiff(first, destination, backwards) - ShortestPathFinder.getFacingDiff(second, destination, backwards);\nif (dd != 0) {\n    return dd;\n }\n\nreturn first.getHexesMoved() - second.getHexesMoved();\nThis follows the contract of a multi-step comparator rather than the addition/subtraction of facing diffs. Or is this some sort of optimization to avoid calculating facing diffs?", "author": "sixlettervariables", "createdAt": "2020-05-30T16:38:52Z", "path": "megamek/src/megamek/common/pathfinder/DestructionAwareDestinationPathfinder.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+* MegaMek -\n+* Copyright (C) 2020 The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package megamek.common.pathfinder;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import megamek.client.bot.princess.AeroPathUtil;\n+import megamek.common.BulldozerMovePath;\n+import megamek.common.Coords;\n+import megamek.common.Entity;\n+import megamek.common.IBoard;\n+import megamek.common.MovePath;\n+import megamek.common.MovePath.MoveStepType;\n+import megamek.common.PlanetaryConditions;\n+\n+/**\n+ * Handles the generation of ground-based move paths that contain information relating to the destruction \n+ * of terrain necessary to accomplish that path.\n+ */\n+public class DestructionAwareDestinationPathfinder extends BoardEdgePathFinder {\n+\n+    Comparator<BulldozerMovePath> movePathComparator;\n+    int maximumCost = Integer.MAX_VALUE;\n+    \n+    /**\n+     * Uses an A* search to find the \"optimal\" path to the destination coordinates.\n+     * Ignores move cost and makes note of hexes that need to be cleared for the path to\n+     * be viable.\n+     */\n+    public BulldozerMovePath findPathToCoords(Entity entity, Set<Coords> destinationCoords) {\n+        return findPathToCoords(entity, destinationCoords, false);\n+    }\n+    \n+    /**\n+     * Uses an A* search to find the \"optimal\" path to the destination coordinates.\n+     * Ignores move cost and makes note of hexes that need to be cleared for the path to\n+     * be viable.\n+     */\n+    public BulldozerMovePath findPathToCoords(Entity entity, Set<Coords> destinationCoords, boolean jump) {\n+        BulldozerMovePath startPath = new BulldozerMovePath(entity.getGame(), entity);\n+        \n+        if(entity.getDisplayName().contains(\"Zibler\")) {\n+            int alpha = 1;\n+        }\n+        \n+        // if we're calculating a jump path and the entity has jump mp and can jump, start off with a jump\n+        // if we're trying to calc a jump path and the entity does not have jump mp, we're done\n+        if(jump && (startPath.getCachedEntityState().getJumpMPWithTerrain() > 0) &&\n+                !entity.isProne() && !entity.isHullDown() && \n+                (entity.getGame().getPlanetaryConditions().getWindStrength() != PlanetaryConditions.WI_TORNADO_F4)) {\n+            startPath.addStep(MoveStepType.START_JUMP);\n+        // if we specified a jump path, but can't actually jump\n+        } else if (jump) {\n+            return null;\n+        // can't \"climb into\" anything while jumping\n+        } else { \n+            if(entity.hasETypeFlag(Entity.ETYPE_INFANTRY)) {\n+                startPath.addStep(MoveStepType.CLIMB_MODE_OFF);\n+            } else {\n+                startPath.addStep(MoveStepType.CLIMB_MODE_ON);\n+            }\n+        }\n+        \n+        // if we're on the ground, let's try to get up first before moving \n+        if(entity.isProne() || entity.isHullDown()) {\n+            startPath.addStep(MoveStepType.GET_UP);\n+        }\n+\n+        Coords closest = getClosestCoords(destinationCoords, entity);\n+        // if we can't at all get to the coordinates with this entity, don't bother with the rest \n+        if (closest == null) {\n+            return null;\n+        }\n+        \n+        movePathComparator = new AStarComparator(closest);\n+        maximumCost = Integer.MAX_VALUE;\n+        \n+        TreeSet<BulldozerMovePath> candidates = new TreeSet<>(movePathComparator);\n+        candidates.add(startPath);\n+\n+        // a collection of coordinates we've already visited, so we don't loop back.\n+        Map<Coords, BulldozerMovePath> shortestPathsToCoords = new HashMap<>();\n+        shortestPathsToCoords.put(startPath.getFinalCoords(), startPath);\n+        BulldozerMovePath bestPath = null;\n+\n+        while(!candidates.isEmpty()) {\n+            BulldozerMovePath currentPath = candidates.pollFirst();\n+            \n+            if(currentPath.getFinalCoords().getX() == 9 &&\n+                    currentPath.getFinalCoords().getY() == 59) {\n+                int alpha = 1;\n+            }\n+            \n+            candidates.addAll(generateChildNodes(currentPath, shortestPathsToCoords));\n+            \n+            if(destinationCoords.contains(currentPath.getFinalCoords()) &&\n+                    (bestPath == null || movePathComparator.compare(bestPath, currentPath) < 0)) {\n+                bestPath = currentPath;\n+                maximumCost = bestPath.getMpUsed() + bestPath.getLevelingCost();\n+            }\n+        }\n+  \n+        return bestPath;\n+    }\n+    \n+    /**\n+     * Calculates the closest coordinates to the given entity\n+     * Coordinates which you have to blow up to get into are considered to be further\n+     */\n+    public static Coords getClosestCoords(Set<Coords> destinationRegion, Entity entity) {\n+        Coords bestCoords = null;\n+        int bestDistance = Integer.MAX_VALUE;\n+        \n+        for(Coords coords : destinationRegion) {\n+            if(!entity.getGame().getBoard().contains(coords)) {\n+                continue;\n+            }\n+            \n+            int levelingCost = BulldozerMovePath.calculateLevelingCost(coords, entity);\n+            boolean canLevel = levelingCost > BulldozerMovePath.CANNOT_LEVEL;\n+            \n+            if(!entity.isLocationProhibited(coords) || canLevel) {\n+                int distance = coords.distance(entity.getPosition()) + (canLevel ? levelingCost : 0);\n+                if(distance < bestDistance) {\n+                    bestDistance = distance;\n+                    bestCoords = coords;\n+                }\n+            }\n+        }\n+        \n+        return bestCoords;\n+    }\n+    \n+    /**\n+     * Function that generates all possible \"legal\" moves resulting from the given path\n+     * and updates the set of visited coordinates so we don't visit them again.\n+     * @param parentPath The path for which to generate child nodes\n+     * @param visitedCoords Set of visited coordinates so we don't loop around\n+     * @return List of valid children. Between 0 and 3 inclusive.\n+     */\n+    protected List<BulldozerMovePath> generateChildNodes(BulldozerMovePath parentPath, Map<Coords, BulldozerMovePath> shortestPathsToCoords) {\n+        List<BulldozerMovePath> children = new ArrayList<>();\n+\n+        // there are six possible children of a move path, defined in AeroPathUtil.TURNS\n+        for(List<MoveStepType> turns : AeroPathUtil.TURNS) {\n+            BulldozerMovePath childPath = (BulldozerMovePath) parentPath.clone();\n+            \n+            // apply the list of turn steps\n+            for(MoveStepType stepType : turns) {\n+                childPath.addStep(stepType);\n+            }\n+            \n+            // potentially apply UP so we can hop over unwanted terrain\n+            PathDecorator.AdjustElevationForForwardMovement(childPath);\n+            \n+            // move forward and process the generated child path\n+            childPath.addStep(MoveStepType.FORWARDS);\n+            processChild(childPath, children, shortestPathsToCoords);\n+        }\n+\n+        return children;\n+    }\n+    \n+    /**\n+     * Helper function that handles logic related to potentially adding a generated child path\n+     * to the list of child paths.\n+     */\n+    protected void processChild(BulldozerMovePath child, List<BulldozerMovePath> children, \n+            Map<Coords, BulldozerMovePath> shortestPathsToCoords) {\n+        int alpha = 1;\n+        // (if we haven't visited these coordinates before\n+        // or we have, and this is a shorter path)\n+        // and (it is a legal move\n+        // or it needs some \"terrain adjustment\" to become a legal move)\n+        // and we haven't already found a path to the destination that's cheaper than what we're considering\n+        // and we're not going off board \n+        MoveLegalityIndicator mli = isLegalMove((MovePath) child);\n+        \n+        // if this path goes through terrain that can be leveled\n+        // but has other problems with it (e.g. elevation change, or the \"reduced\" terrain still won't let you through)\n+        // it still can't be leveled\n+        boolean canLevel = child.needsLeveling() &&\n+                !mli.outOfBounds &&\n+                !mli.destinationImpassable &&\n+                !mli.goingDownTooLow &&\n+                !mli.goingUpTooHigh &&\n+                !mli.wheeledTankRestriction &&\n+                !mli.destinationHasWeakBridge &&\n+                !mli.groundTankIntoWater;\n+        \n+        if((!shortestPathsToCoords.containsKey(child.getFinalCoords()) ||\n+                // shorter path to these coordinates\n+                (movePathComparator.compare(shortestPathsToCoords.get(child.getFinalCoords()), child) > 0)) &&\n+                // legal or needs leveling and not off-board\n+                (mli.isLegal() || canLevel) &&\n+                // better than existing path to ultimate destination\n+                (child.getMpUsed() + child.getLevelingCost() < maximumCost)) {\n+            shortestPathsToCoords.put(child.getFinalCoords(), child);\n+            children.add(child);\n+        }\n+    }\n+    \n+    /**\n+     * Comparator implementation useful in comparing how much closer a given path is to the internal\n+     * \"destination edge\" than the other.\n+     * @author NickAragua\n+     *\n+     */\n+    private class AStarComparator implements Comparator<BulldozerMovePath> {\n+        private Coords destination;\n+\n+        /**\n+         * Constructor - initializes the destination edge.\n+         * @param targetRegion Destination edge\n+         */\n+        public AStarComparator(Coords destination) {\n+            this.destination = destination;\n+        }\n+        \n+        /**\n+         * compare the first move path to the second\n+         * Favors paths that move closer to the destination edge first.\n+         * in case of tie, favors paths that cost less MP\n+         */\n+        public int compare(BulldozerMovePath first, BulldozerMovePath second) {            \n+            IBoard board = first.getGame().getBoard();\n+            boolean backwards = false;\n+            int h1 = first.getFinalCoords().distance(destination)\n+                    + ShortestPathFinder.getLevelDiff(first, destination, board)\n+                    + ShortestPathFinder.getElevationDiff(first, destination, board, first.getEntity());\n+            int h2 = second.getFinalCoords().distance(destination)\n+                    + ShortestPathFinder.getLevelDiff(second, destination, board)\n+                    + ShortestPathFinder.getElevationDiff(second, destination, board, second.getEntity());\n+    \n+            int dd = (first.getMpUsed() + first.getLevelingCost() + first.getAdditionalCost() + h1) \n+                    - (second.getMpUsed() + second.getLevelingCost() + second.getAdditionalCost() + h2);\n+            \n+            // getFacingDiff returns a number between 0 and 3 inclusive. \n+            // if the value diff is larger than 3, then it won't make a difference and we skip calculating it\n+            if(Math.abs(dd) < 4) ", "originalCommit": "b8154746c265f11bbfffacb305ece8e9396f2806", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5ODcyNw==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r432898727", "bodyText": "That's basically it, yeah. Calculating facing diffs is expensive because of the arctangents, so I avoid calculating them in situations where it doesn't matter.", "author": "NickAragua", "createdAt": "2020-05-31T00:40:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2ODY4OQ=="}], "type": "inlineReview"}, {"oid": "5cb3b12f86b76bba1410d716c251e8daa4f3be1f", "url": "https://github.com/MegaMek/megamek/commit/5cb3b12f86b76bba1410d716c251e8daa4f3be1f", "message": "code review cleanup", "committedDate": "2020-05-31T01:00:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3NTkwOA==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r433375908", "bodyText": "Why include this commented out code?", "author": "Windchild292", "createdAt": "2020-06-01T17:21:12Z", "path": "megamek/src/megamek/common/pathfinder/ShortestPathFinder.java", "diffHunk": "@@ -359,6 +335,7 @@ public static int getFacingDiff(final MovePath mp, Coords dest,\n         }\n \n         // Direction dest hex is from current location, in hex facings\n+        //int destDir = mp.getFinalCoords().approximateDirection(dest, 0, 0);", "originalCommit": "5cb3b12f86b76bba1410d716c251e8daa4f3be1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7f5a1bf0477b2d995dfbae51e1d479a68d837f1c", "url": "https://github.com/MegaMek/megamek/commit/7f5a1bf0477b2d995dfbae51e1d479a68d837f1c", "message": "delete unnecessarya commented out code", "committedDate": "2020-06-01T18:16:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MzY1Mg==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r433383652", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if(Math.abs(dd) < 4) \n          \n          \n            \n                        {\n          \n          \n            \n                        if (Math.abs(dd) < 4) {", "author": "Windchild292", "createdAt": "2020-06-01T17:35:36Z", "path": "megamek/src/megamek/common/pathfinder/DestructionAwareDestinationPathfinder.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+* MegaMek -\n+* Copyright (C) 2020 The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package megamek.common.pathfinder;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import megamek.client.bot.princess.AeroPathUtil;\n+import megamek.common.BulldozerMovePath;\n+import megamek.common.Coords;\n+import megamek.common.Entity;\n+import megamek.common.IBoard;\n+import megamek.common.MovePath;\n+import megamek.common.MovePath.MoveStepType;\n+import megamek.common.PlanetaryConditions;\n+\n+/**\n+ * Handles the generation of ground-based move paths that contain information relating to the destruction \n+ * of terrain necessary to accomplish that path.\n+ */\n+public class DestructionAwareDestinationPathfinder extends BoardEdgePathFinder {\n+\n+    Comparator<BulldozerMovePath> movePathComparator;\n+    int maximumCost = Integer.MAX_VALUE;\n+    \n+    /**\n+     * Uses an A* search to find the \"optimal\" path to the destination coordinates.\n+     * Ignores move cost and makes note of hexes that need to be cleared for the path to\n+     * be viable.\n+     */\n+    public BulldozerMovePath findPathToCoords(Entity entity, Set<Coords> destinationCoords) {\n+        return findPathToCoords(entity, destinationCoords, false);\n+    }\n+    \n+    /**\n+     * Uses an A* search to find the \"optimal\" path to the destination coordinates.\n+     * Ignores move cost and makes note of hexes that need to be cleared for the path to\n+     * be viable.\n+     */\n+    public BulldozerMovePath findPathToCoords(Entity entity, Set<Coords> destinationCoords, boolean jump) {\n+        BulldozerMovePath startPath = new BulldozerMovePath(entity.getGame(), entity);\n+        \n+        // if we're calculating a jump path and the entity has jump mp and can jump, start off with a jump\n+        // if we're trying to calc a jump path and the entity does not have jump mp, we're done\n+        if(jump && (startPath.getCachedEntityState().getJumpMPWithTerrain() > 0) &&\n+                !entity.isProne() && !entity.isHullDown() && \n+                (entity.getGame().getPlanetaryConditions().getWindStrength() != PlanetaryConditions.WI_TORNADO_F4)) {\n+            startPath.addStep(MoveStepType.START_JUMP);\n+        // if we specified a jump path, but can't actually jump\n+        } else if (jump) {\n+            return null;\n+        // can't \"climb into\" anything while jumping\n+        } else { \n+            if(entity.hasETypeFlag(Entity.ETYPE_INFANTRY)) {\n+                startPath.addStep(MoveStepType.CLIMB_MODE_OFF);\n+            } else {\n+                startPath.addStep(MoveStepType.CLIMB_MODE_ON);\n+            }\n+        }\n+        \n+        // if we're on the ground, let's try to get up first before moving \n+        if(entity.isProne() || entity.isHullDown()) {\n+            startPath.addStep(MoveStepType.GET_UP);\n+        }\n+\n+        Coords closest = getClosestCoords(destinationCoords, entity);\n+        // if we can't at all get to the coordinates with this entity, don't bother with the rest \n+        if (closest == null) {\n+            return null;\n+        }\n+        \n+        movePathComparator = new AStarComparator(closest);\n+        maximumCost = Integer.MAX_VALUE;\n+        \n+        TreeSet<BulldozerMovePath> candidates = new TreeSet<>(movePathComparator);\n+        candidates.add(startPath);\n+\n+        // a collection of coordinates we've already visited, so we don't loop back.\n+        Map<Coords, BulldozerMovePath> shortestPathsToCoords = new HashMap<>();\n+        shortestPathsToCoords.put(startPath.getFinalCoords(), startPath);\n+        BulldozerMovePath bestPath = null;\n+\n+        while(!candidates.isEmpty()) {\n+            BulldozerMovePath currentPath = candidates.pollFirst();\n+            \n+            candidates.addAll(generateChildNodes(currentPath, shortestPathsToCoords));\n+            \n+            if(destinationCoords.contains(currentPath.getFinalCoords()) &&\n+                    (bestPath == null || movePathComparator.compare(bestPath, currentPath) < 0)) {\n+                bestPath = currentPath;\n+                maximumCost = bestPath.getMpUsed() + bestPath.getLevelingCost();\n+            }\n+        }\n+  \n+        return bestPath;\n+    }\n+    \n+    /**\n+     * Calculates the closest coordinates to the given entity\n+     * Coordinates which you have to blow up to get into are considered to be further\n+     */\n+    public static Coords getClosestCoords(Set<Coords> destinationRegion, Entity entity) {\n+        Coords bestCoords = null;\n+        int bestDistance = Integer.MAX_VALUE;\n+        \n+        for(Coords coords : destinationRegion) {\n+            if(!entity.getGame().getBoard().contains(coords)) {\n+                continue;\n+            }\n+            \n+            int levelingCost = BulldozerMovePath.calculateLevelingCost(coords, entity);\n+            boolean canLevel = levelingCost > BulldozerMovePath.CANNOT_LEVEL;\n+            \n+            if(!entity.isLocationProhibited(coords) || canLevel) {\n+                int distance = coords.distance(entity.getPosition()) + (canLevel ? levelingCost : 0);\n+                if(distance < bestDistance) {\n+                    bestDistance = distance;\n+                    bestCoords = coords;\n+                }\n+            }\n+        }\n+        \n+        return bestCoords;\n+    }\n+    \n+    /**\n+     * Function that generates all possible \"legal\" moves resulting from the given path\n+     * and updates the set of visited coordinates so we don't visit them again.\n+     * @param parentPath The path for which to generate child nodes\n+     * @param visitedCoords Set of visited coordinates so we don't loop around\n+     * @return List of valid children. Between 0 and 3 inclusive.\n+     */\n+    protected List<BulldozerMovePath> generateChildNodes(BulldozerMovePath parentPath, Map<Coords, BulldozerMovePath> shortestPathsToCoords) {\n+        List<BulldozerMovePath> children = new ArrayList<>();\n+\n+        // there are six possible children of a move path, defined in AeroPathUtil.TURNS\n+        for(List<MoveStepType> turns : AeroPathUtil.TURNS) {\n+            BulldozerMovePath childPath = (BulldozerMovePath) parentPath.clone();\n+            \n+            // apply the list of turn steps\n+            for(MoveStepType stepType : turns) {\n+                childPath.addStep(stepType);\n+            }\n+            \n+            // potentially apply UP so we can hop over unwanted terrain\n+            PathDecorator.AdjustElevationForForwardMovement(childPath);\n+            \n+            // move forward and process the generated child path\n+            childPath.addStep(MoveStepType.FORWARDS);\n+            processChild(childPath, children, shortestPathsToCoords);\n+        }\n+\n+        return children;\n+    }\n+    \n+    /**\n+     * Helper function that handles logic related to potentially adding a generated child path\n+     * to the list of child paths.\n+     */\n+    protected void processChild(BulldozerMovePath child, List<BulldozerMovePath> children, \n+            Map<Coords, BulldozerMovePath> shortestPathsToCoords) {\n+        // (if we haven't visited these coordinates before\n+        // or we have, and this is a shorter path)\n+        // and (it is a legal move\n+        // or it needs some \"terrain adjustment\" to become a legal move)\n+        // and we haven't already found a path to the destination that's cheaper than what we're considering\n+        // and we're not going off board \n+        MoveLegalityIndicator mli = isLegalMove((MovePath) child);\n+        \n+        // if this path goes through terrain that can be leveled\n+        // but has other problems with it (e.g. elevation change, or the \"reduced\" terrain still won't let you through)\n+        // it still can't be leveled\n+        boolean canLevel = child.needsLeveling() &&\n+                !mli.outOfBounds &&\n+                !mli.destinationImpassable &&\n+                !mli.goingDownTooLow &&\n+                !mli.goingUpTooHigh &&\n+                !mli.wheeledTankRestriction &&\n+                !mli.destinationHasWeakBridge &&\n+                !mli.groundTankIntoWater;\n+        \n+        if((!shortestPathsToCoords.containsKey(child.getFinalCoords()) ||\n+                // shorter path to these coordinates\n+                (movePathComparator.compare(shortestPathsToCoords.get(child.getFinalCoords()), child) > 0)) &&\n+                // legal or needs leveling and not off-board\n+                (mli.isLegal() || canLevel) &&\n+                // better than existing path to ultimate destination\n+                (child.getMpUsed() + child.getLevelingCost() < maximumCost)) {\n+            shortestPathsToCoords.put(child.getFinalCoords(), child);\n+            children.add(child);\n+        }\n+    }\n+    \n+    /**\n+     * Comparator implementation useful in comparing how much closer a given path is to the internal\n+     * \"destination edge\" than the other.\n+     * @author NickAragua\n+     *\n+     */\n+    private class AStarComparator implements Comparator<BulldozerMovePath> {\n+        private Coords destination;\n+\n+        /**\n+         * Constructor - initializes the destination edge.\n+         * @param targetRegion Destination edge\n+         */\n+        public AStarComparator(Coords destination) {\n+            this.destination = destination;\n+        }\n+        \n+        /**\n+         * compare the first move path to the second\n+         * Favors paths that move closer to the destination edge first.\n+         * in case of tie, favors paths that cost less MP\n+         */\n+        public int compare(BulldozerMovePath first, BulldozerMovePath second) {            \n+            IBoard board = first.getGame().getBoard();\n+            boolean backwards = false;\n+            int h1 = first.getFinalCoords().distance(destination)\n+                    + ShortestPathFinder.getLevelDiff(first, destination, board)\n+                    + ShortestPathFinder.getElevationDiff(first, destination, board, first.getEntity());\n+            int h2 = second.getFinalCoords().distance(destination)\n+                    + ShortestPathFinder.getLevelDiff(second, destination, board)\n+                    + ShortestPathFinder.getElevationDiff(second, destination, board, second.getEntity());\n+    \n+            int dd = (first.getMpUsed() + first.getLevelingCost() + first.getAdditionalCost() + h1) \n+                    - (second.getMpUsed() + second.getLevelingCost() + second.getAdditionalCost() + h2);\n+            \n+            // getFacingDiff returns a number between 0 and 3 inclusive. \n+            // if the value diff is larger than 3, then it won't make a difference and we skip calculating it\n+            if(Math.abs(dd) < 4) \n+            {", "originalCommit": "5cb3b12f86b76bba1410d716c251e8daa4f3be1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4NDAxNg==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r433384016", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "author": "Windchild292", "createdAt": "2020-06-01T17:36:17Z", "path": "megamek/src/megamek/common/pathfinder/DestructionAwareDestinationPathfinder.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+* MegaMek -\n+* Copyright (C) 2020 The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package megamek.common.pathfinder;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import megamek.client.bot.princess.AeroPathUtil;\n+import megamek.common.BulldozerMovePath;\n+import megamek.common.Coords;\n+import megamek.common.Entity;\n+import megamek.common.IBoard;\n+import megamek.common.MovePath;\n+import megamek.common.MovePath.MoveStepType;\n+import megamek.common.PlanetaryConditions;\n+\n+/**\n+ * Handles the generation of ground-based move paths that contain information relating to the destruction \n+ * of terrain necessary to accomplish that path.\n+ */\n+public class DestructionAwareDestinationPathfinder extends BoardEdgePathFinder {\n+\n+    Comparator<BulldozerMovePath> movePathComparator;\n+    int maximumCost = Integer.MAX_VALUE;\n+    \n+    /**\n+     * Uses an A* search to find the \"optimal\" path to the destination coordinates.\n+     * Ignores move cost and makes note of hexes that need to be cleared for the path to\n+     * be viable.\n+     */\n+    public BulldozerMovePath findPathToCoords(Entity entity, Set<Coords> destinationCoords) {\n+        return findPathToCoords(entity, destinationCoords, false);\n+    }\n+    \n+    /**\n+     * Uses an A* search to find the \"optimal\" path to the destination coordinates.\n+     * Ignores move cost and makes note of hexes that need to be cleared for the path to\n+     * be viable.\n+     */\n+    public BulldozerMovePath findPathToCoords(Entity entity, Set<Coords> destinationCoords, boolean jump) {\n+        BulldozerMovePath startPath = new BulldozerMovePath(entity.getGame(), entity);\n+        \n+        // if we're calculating a jump path and the entity has jump mp and can jump, start off with a jump\n+        // if we're trying to calc a jump path and the entity does not have jump mp, we're done\n+        if(jump && (startPath.getCachedEntityState().getJumpMPWithTerrain() > 0) &&\n+                !entity.isProne() && !entity.isHullDown() && \n+                (entity.getGame().getPlanetaryConditions().getWindStrength() != PlanetaryConditions.WI_TORNADO_F4)) {\n+            startPath.addStep(MoveStepType.START_JUMP);\n+        // if we specified a jump path, but can't actually jump\n+        } else if (jump) {\n+            return null;\n+        // can't \"climb into\" anything while jumping\n+        } else { \n+            if(entity.hasETypeFlag(Entity.ETYPE_INFANTRY)) {\n+                startPath.addStep(MoveStepType.CLIMB_MODE_OFF);\n+            } else {\n+                startPath.addStep(MoveStepType.CLIMB_MODE_ON);\n+            }\n+        }\n+        \n+        // if we're on the ground, let's try to get up first before moving \n+        if(entity.isProne() || entity.isHullDown()) {\n+            startPath.addStep(MoveStepType.GET_UP);\n+        }\n+\n+        Coords closest = getClosestCoords(destinationCoords, entity);\n+        // if we can't at all get to the coordinates with this entity, don't bother with the rest \n+        if (closest == null) {\n+            return null;\n+        }\n+        \n+        movePathComparator = new AStarComparator(closest);\n+        maximumCost = Integer.MAX_VALUE;\n+        \n+        TreeSet<BulldozerMovePath> candidates = new TreeSet<>(movePathComparator);\n+        candidates.add(startPath);\n+\n+        // a collection of coordinates we've already visited, so we don't loop back.\n+        Map<Coords, BulldozerMovePath> shortestPathsToCoords = new HashMap<>();\n+        shortestPathsToCoords.put(startPath.getFinalCoords(), startPath);\n+        BulldozerMovePath bestPath = null;\n+\n+        while(!candidates.isEmpty()) {\n+            BulldozerMovePath currentPath = candidates.pollFirst();\n+            \n+            candidates.addAll(generateChildNodes(currentPath, shortestPathsToCoords));\n+            \n+            if(destinationCoords.contains(currentPath.getFinalCoords()) &&\n+                    (bestPath == null || movePathComparator.compare(bestPath, currentPath) < 0)) {\n+                bestPath = currentPath;\n+                maximumCost = bestPath.getMpUsed() + bestPath.getLevelingCost();\n+            }\n+        }\n+  \n+        return bestPath;\n+    }\n+    \n+    /**\n+     * Calculates the closest coordinates to the given entity\n+     * Coordinates which you have to blow up to get into are considered to be further\n+     */\n+    public static Coords getClosestCoords(Set<Coords> destinationRegion, Entity entity) {\n+        Coords bestCoords = null;\n+        int bestDistance = Integer.MAX_VALUE;\n+        \n+        for(Coords coords : destinationRegion) {\n+            if(!entity.getGame().getBoard().contains(coords)) {\n+                continue;\n+            }\n+            \n+            int levelingCost = BulldozerMovePath.calculateLevelingCost(coords, entity);\n+            boolean canLevel = levelingCost > BulldozerMovePath.CANNOT_LEVEL;\n+            \n+            if(!entity.isLocationProhibited(coords) || canLevel) {\n+                int distance = coords.distance(entity.getPosition()) + (canLevel ? levelingCost : 0);\n+                if(distance < bestDistance) {\n+                    bestDistance = distance;\n+                    bestCoords = coords;\n+                }\n+            }\n+        }\n+        \n+        return bestCoords;\n+    }\n+    \n+    /**\n+     * Function that generates all possible \"legal\" moves resulting from the given path\n+     * and updates the set of visited coordinates so we don't visit them again.\n+     * @param parentPath The path for which to generate child nodes\n+     * @param visitedCoords Set of visited coordinates so we don't loop around\n+     * @return List of valid children. Between 0 and 3 inclusive.\n+     */\n+    protected List<BulldozerMovePath> generateChildNodes(BulldozerMovePath parentPath, Map<Coords, BulldozerMovePath> shortestPathsToCoords) {\n+        List<BulldozerMovePath> children = new ArrayList<>();\n+\n+        // there are six possible children of a move path, defined in AeroPathUtil.TURNS\n+        for(List<MoveStepType> turns : AeroPathUtil.TURNS) {\n+            BulldozerMovePath childPath = (BulldozerMovePath) parentPath.clone();\n+            \n+            // apply the list of turn steps\n+            for(MoveStepType stepType : turns) {\n+                childPath.addStep(stepType);\n+            }\n+            \n+            // potentially apply UP so we can hop over unwanted terrain\n+            PathDecorator.AdjustElevationForForwardMovement(childPath);\n+            \n+            // move forward and process the generated child path\n+            childPath.addStep(MoveStepType.FORWARDS);\n+            processChild(childPath, children, shortestPathsToCoords);\n+        }\n+\n+        return children;\n+    }\n+    \n+    /**\n+     * Helper function that handles logic related to potentially adding a generated child path\n+     * to the list of child paths.\n+     */\n+    protected void processChild(BulldozerMovePath child, List<BulldozerMovePath> children, \n+            Map<Coords, BulldozerMovePath> shortestPathsToCoords) {\n+        // (if we haven't visited these coordinates before\n+        // or we have, and this is a shorter path)\n+        // and (it is a legal move\n+        // or it needs some \"terrain adjustment\" to become a legal move)\n+        // and we haven't already found a path to the destination that's cheaper than what we're considering\n+        // and we're not going off board \n+        MoveLegalityIndicator mli = isLegalMove((MovePath) child);\n+        \n+        // if this path goes through terrain that can be leveled\n+        // but has other problems with it (e.g. elevation change, or the \"reduced\" terrain still won't let you through)\n+        // it still can't be leveled\n+        boolean canLevel = child.needsLeveling() &&\n+                !mli.outOfBounds &&\n+                !mli.destinationImpassable &&\n+                !mli.goingDownTooLow &&\n+                !mli.goingUpTooHigh &&\n+                !mli.wheeledTankRestriction &&\n+                !mli.destinationHasWeakBridge &&\n+                !mli.groundTankIntoWater;\n+        \n+        if((!shortestPathsToCoords.containsKey(child.getFinalCoords()) ||\n+                // shorter path to these coordinates\n+                (movePathComparator.compare(shortestPathsToCoords.get(child.getFinalCoords()), child) > 0)) &&\n+                // legal or needs leveling and not off-board\n+                (mli.isLegal() || canLevel) &&\n+                // better than existing path to ultimate destination\n+                (child.getMpUsed() + child.getLevelingCost() < maximumCost)) {\n+            shortestPathsToCoords.put(child.getFinalCoords(), child);\n+            children.add(child);\n+        }\n+    }\n+    \n+    /**\n+     * Comparator implementation useful in comparing how much closer a given path is to the internal\n+     * \"destination edge\" than the other.\n+     * @author NickAragua\n+     *", "originalCommit": "5cb3b12f86b76bba1410d716c251e8daa4f3be1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQwMzA2Mg==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r433403062", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int srcHexElevation = calculateUnitElevationInHex(srcHex, entity, isHovercraft, isAmphibious);        \n          \n          \n            \n                    int srcHexElevation = calculateUnitElevationInHex(srcHex, entity, isHovercraft, isAmphibious);", "author": "Windchild292", "createdAt": "2020-06-01T18:12:02Z", "path": "megamek/src/megamek/common/pathfinder/BoardEdgePathFinder.java", "diffHunk": "@@ -493,104 +494,115 @@ private void cacheGoodPath(MovePath path, int destinationRegion) {\n      * Helper function that handles logic related to potentially adding a generated child path\n      * to the list of child paths.\n      */\n-    private void processChild(MovePath child, List<MovePath> children, Set<Coords> visitedCoords) {\n-        if(!visitedCoords.contains(child.getFinalCoords()) && isLegalMove(child)) {\n+    protected void processChild(MovePath child, List<MovePath> children, Set<Coords> visitedCoords) {\n+        if(!visitedCoords.contains(child.getFinalCoords()) && isLegalMove(child).isLegal()) {\n             visitedCoords.add(child.getFinalCoords());\n             children.add(child);\n         }\n     }\n-\n+    \n     /**\n      * A \"light-weight\" version of the logic found in \"isMovementPossible\" in MoveStep.java\n      *\n      * @param movePath The move path to process\n      * @return Whether or not the given move path is \"legal\" in the context of this pathfinder.\n      */\n-    private boolean isLegalMove(MovePath movePath) {\n+    protected MoveLegalityIndicator isLegalMove(MovePath movePath) {\n         Coords dest = movePath.getFinalCoords();\n         IBoard board = movePath.getGame().getBoard();\n         IHex destHex = board.getHex(dest);\n+        Building destinationBuilding = board.getBuildingAt(dest);\n+        \n+        return isLegalMove(movePath, destHex, destinationBuilding);\n+    }\n+\n+    /**\n+     * A \"light-weight\" version of the logic found in \"isMovementPossible\" in MoveStep.java\n+     * \n+     *\n+     * @param movePath The move path to process\n+     * @param destHex the hex at the end of the path\n+     * @param destinationBuilding the building at the end of the path, can be null\n+     * @return Whether or not the given move path is \"legal\" in the context of this pathfinder.\n+     */\n+    private MoveLegalityIndicator isLegalMove(MovePath movePath, IHex destHex, Building destinationBuilding) {        \n+        Coords dest = movePath.getFinalCoords();\n+        IBoard board = movePath.getGame().getBoard();\n         Coords src = movePath.getSecondLastStep().getPosition();\n         IHex srcHex = board.getHex(src);\n         Entity entity = movePath.getEntity();\n \n+        MoveLegalityIndicator mli = new MoveLegalityIndicator();\n+        \n         boolean destinationInBounds = board.contains(dest);\n         if(!destinationInBounds) {\n-            return false;\n+            mli.outOfBounds = true;\n+            return mli;\n         }\n \n         // we only need to be able to legally move into the hex from the previous hex.\n         // we don't care about stacking limits, remaining unit mp or other transient data\n-\n-        Building destinationBuilding = board.getBuildingAt(dest);\n-\n         // quadvees are not considered \"tracked\" for the purposes of this exercise because they can transform\n         boolean isTracked = entity.getMovementMode() == EntityMovementMode.TRACKED && !entity.hasETypeFlag(Entity.ETYPE_QUADVEE);\n         boolean isHovercraft = entity.getMovementMode() == EntityMovementMode.HOVER;\n         boolean isWheeled = entity.getMovementMode() == EntityMovementMode.WHEELED;\n+        boolean isAmphibious = movePath.getCachedEntityState().hasWorkingMisc(MiscType.F_AMPHIBIOUS) ||\n+                            movePath.getCachedEntityState().hasWorkingMisc(MiscType.F_FULLY_AMPHIBIOUS) ||\n+                            movePath.getCachedEntityState().hasWorkingMisc(MiscType.F_LIMITED_AMPHIBIOUS);\n         boolean destHexHasRoad = destHex.containsTerrain(Terrains.ROAD);\n         // jumpers can clear higher objects than walkers and crawlers\n         int maxUpwardElevationChange = Math.max(entity.getJumpMP(), entity.getMaxElevationChange());\n         // jumpers can just hop down wherever they want\n-        int maxDownwardElevationChange = entity.getJumpMP() > 0 ? 999 : entity.getMaxElevationDown();\n-        int destHexElevation = calculateUnitElevationInHex(destHex, entity);\n-        int srcHexElevation = calculateUnitElevationInHex(srcHex, entity);\n-\n-        boolean destinationImpassable = destHex.containsTerrain(Terrains.IMPASSABLE);\n+        int maxDownwardElevationChange = movePath.getCachedEntityState().getJumpMP() > 0 ? 999 : entity.getMaxElevationDown();\n+        int destHexElevation = calculateUnitElevationInHex(destHex, entity, isHovercraft, isAmphibious);\n+        int srcHexElevation = calculateUnitElevationInHex(srcHex, entity, isHovercraft, isAmphibious);        ", "originalCommit": "5cb3b12f86b76bba1410d716c251e8daa4f3be1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQwOTA1NA==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r433409054", "bodyText": "Couldn't these two lines now be merged?", "author": "Windchild292", "createdAt": "2020-06-01T18:23:43Z", "path": "megamek/src/megamek/client/bot/princess/Princess.java", "diffHunk": "@@ -268,7 +276,7 @@ boolean getForcedWithdrawal() {\n     }\n \n     private void setFleeBoard(final boolean fleeBoard,\n-                              @SuppressWarnings(\"SameParameterValue\") final String reason) {\n+                              final String reason) {", "originalCommit": "5cb3b12f86b76bba1410d716c251e8daa4f3be1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyMDQzOQ==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r433420439", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *", "author": "Windchild292", "createdAt": "2020-06-01T18:45:06Z", "path": "megamek/src/megamek/common/BulldozerMovePath.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+* MegaMek -\n+* Copyright (C) 2020 The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package megamek.common;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.client.bot.princess.FireControl;\n+import megamek.common.pathfinder.ShortestPathFinder;\n+import megamek.common.pathfinder.BoardClusterTracker.MovementType;\n+\n+/**\n+ * An extension of the MovePath class that stores information about terrain that needs\n+ * to be destroyed in order to move along the specified route.\n+ * @author NickAragua\n+ *", "originalCommit": "5cb3b12f86b76bba1410d716c251e8daa4f3be1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyMDUyMA==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r433420520", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /**\n          \n          \n            \n                 * \n          \n          \n            \n                 */", "author": "Windchild292", "createdAt": "2020-06-01T18:45:16Z", "path": "megamek/src/megamek/common/BulldozerMovePath.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+* MegaMek -\n+* Copyright (C) 2020 The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package megamek.common;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.client.bot.princess.FireControl;\n+import megamek.common.pathfinder.ShortestPathFinder;\n+import megamek.common.pathfinder.BoardClusterTracker.MovementType;\n+\n+/**\n+ * An extension of the MovePath class that stores information about terrain that needs\n+ * to be destroyed in order to move along the specified route.\n+ * @author NickAragua\n+ *\n+ */\n+public class BulldozerMovePath extends MovePath {\n+    /**\n+     * \n+     */", "originalCommit": "5cb3b12f86b76bba1410d716c251e8daa4f3be1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyMDY1MA==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r433420650", "bodyText": "Why was this added in the first place?", "author": "Windchild292", "createdAt": "2020-06-01T18:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyMDUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NDY1Mg==", "url": "https://github.com/MegaMek/megamek/pull/1980#discussion_r433564652", "bodyText": "No idea. Some IDE thing, probably.", "author": "NickAragua", "createdAt": "2020-06-02T00:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyMDUyMA=="}], "type": "inlineReview"}, {"oid": "f84205c86d94996de8b0e5313a39843538927871", "url": "https://github.com/MegaMek/megamek/commit/f84205c86d94996de8b0e5313a39843538927871", "message": "Update megamek/src/megamek/common/pathfinder/DestructionAwareDestinationPathfinder.java\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2020-06-02T00:26:15Z", "type": "commit"}, {"oid": "9fa70f178e320db7b7ea988ff9b1b629d6fb182b", "url": "https://github.com/MegaMek/megamek/commit/9fa70f178e320db7b7ea988ff9b1b629d6fb182b", "message": "Update megamek/src/megamek/common/pathfinder/DestructionAwareDestinationPathfinder.java\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2020-06-02T00:26:23Z", "type": "commit"}, {"oid": "988e7b047f5dbc3a8413d3af2d26f9e9ef8924c6", "url": "https://github.com/MegaMek/megamek/commit/988e7b047f5dbc3a8413d3af2d26f9e9ef8924c6", "message": "Update megamek/src/megamek/common/BulldozerMovePath.java\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2020-06-02T00:27:04Z", "type": "commit"}, {"oid": "0fe86664e9ecefe90b61e35dabc871bb0578188d", "url": "https://github.com/MegaMek/megamek/commit/0fe86664e9ecefe90b61e35dabc871bb0578188d", "message": "Update megamek/src/megamek/common/BulldozerMovePath.java\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2020-06-02T00:27:51Z", "type": "commit"}, {"oid": "e49b6ce1505c761216616d7f2133863f7af82cdf", "url": "https://github.com/MegaMek/megamek/commit/e49b6ce1505c761216616d7f2133863f7af82cdf", "message": "code review updates", "committedDate": "2020-06-02T01:00:41Z", "type": "commit"}]}