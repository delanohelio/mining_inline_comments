{"pr_number": 2148, "pr_title": "make bot turn calculations more tolerant of threading-related errors fixable by kicking and replacing the bot", "pr_createdAt": "2020-08-14T04:37:06Z", "pr_url": "https://github.com/MegaMek/megamek/pull/2148", "timeline": [{"oid": "b97fc285ad53ef51858a889e22c2e5f5eff29ea2", "url": "https://github.com/MegaMek/megamek/commit/b97fc285ad53ef51858a889e22c2e5f5eff29ea2", "message": "make mode list thread safe", "committedDate": "2020-08-14T04:23:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNzgzMg==", "url": "https://github.com/MegaMek/megamek/pull/2148#discussion_r470407832", "bodyText": "Collections.synchronizedList protects the given methods on List from concurrent access, however, they do not protect iteration. So you'd need to use synchronized. Oh and you have to use threadSafeModes everywhere you want to use modes.\nExcept, threadSafeModes isn't being used for all of your mutable uses of modes (add, remove). As it stands, you'd likely be better served by simply wrapping every usage of modes in a synchronized block on modes itself.", "author": "sixlettervariables", "createdAt": "2020-08-14T04:46:56Z", "path": "megamek/src/megamek/common/EquipmentType.java", "diffHunk": "@@ -553,10 +555,16 @@ public boolean hasModeType(String modeType) {\n     \t\treturn false;\n     \t}\n     \t\n-    \tfor(EquipmentMode mode : modes) {\n-    \t\tif(mode.getName().equals(modeType)) {\n-    \t\t\treturn true;\n-    \t\t}\n+    \t// sometimes, the list of modes may be modified while we're looping through it\n+    \t// so let's do this in a thread-safe way\n+    \tList<EquipmentMode> threadSafeModes = Collections.synchronizedList(modes);", "originalCommit": "b97fc285ad53ef51858a889e22c2e5f5eff29ea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQxMDcyMA==", "url": "https://github.com/MegaMek/megamek/pull/2148#discussion_r470410720", "bodyText": "Also it looks like modes is a Vector, which already has the same behavior as a synchronizedList. So basically, either addMode or removeMode was called while this was going on. My guess is a network delay or GC pause gave it enough timing to fail.", "author": "sixlettervariables", "createdAt": "2020-08-14T04:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNzgzMg=="}], "type": "inlineReview"}, {"oid": "a1c78c3ec4d8a2d4314975d1b05b469a600bb26c", "url": "https://github.com/MegaMek/megamek/commit/a1c78c3ec4d8a2d4314975d1b05b469a600bb26c", "message": "more general solution to the problem; spheroid dropship movement fix", "committedDate": "2020-08-15T02:32:01Z", "type": "commit"}, {"oid": "cc93a650850c40c7b179dfbf6c583fd09fcdafc7", "url": "https://github.com/MegaMek/megamek/commit/cc93a650850c40c7b179dfbf6c583fd09fcdafc7", "message": "cleanup", "committedDate": "2020-08-15T02:39:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyODk4OA==", "url": "https://github.com/MegaMek/megamek/pull/2148#discussion_r470928988", "bodyText": "Can we refactor the inner try contents into its own method? That would separate the concerns here nicely.", "author": "sixlettervariables", "createdAt": "2020-08-15T02:55:50Z", "path": "megamek/src/megamek/client/bot/BotClient.java", "diffHunk": "@@ -507,57 +510,71 @@ private synchronized void calculateMyTurn() {\n         currentTurnEnemyEntities = null;\n         currentTurnFriendlyEntities = null;\n         \n-        try {\n-            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {\n-                MovePath mp;\n-                if (game.getTurn() instanceof GameTurn.SpecificEntityTurn) {\n-                    GameTurn.SpecificEntityTurn turn = (GameTurn.SpecificEntityTurn) game\n-                            .getTurn();\n-                    Entity mustMove = game.getEntity(turn.getEntityNum());\n-                    mp = continueMovementFor(mustMove);\n-                } else {\n-                    if (config.isForcedIndividual()) {\n-                        Entity mustMove = getRandomUnmovedEntity();\n-                        mp = continueMovementFor(mustMove);\n-                    } else {\n-                        mp = calculateMoveTurn();\n-                    }\n-                }\n-                moveEntity(mp.getEntity().getId(), mp);\n-            } else if (game.getPhase() == IGame.Phase.PHASE_FIRING) {\n-                // TODO: consider that if you're hidden you should hold fire\n-                calculateFiringTurn();\n-            } else if (game.getPhase() == IGame.Phase.PHASE_PHYSICAL) {\n-                PhysicalOption po = calculatePhysicalTurn();\n-                // Bug #1072137: don't crash if the bot can't find a physical.\n-                if (null != po) {\n-                    sendAttackData(po.attacker.getId(), po.getVector());\n-                } else {\n-                    // Send a \"no attack\" to clear the game turn, if any.\n-                    sendAttackData(game.getFirstEntityNum(getMyTurn()),\n-                                   new Vector<>(0));\n-                }\n-            } else if (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT) {\n-                calculateDeployment();\n-            } else if (game.getPhase() == IGame.Phase.PHASE_DEPLOY_MINEFIELDS) {\n-                Vector<Minefield> mines = calculateMinefieldDeployment();\n-                for (Minefield mine : mines) {\n-                    game.addMinefield(mine);\n-                }\n-                sendDeployMinefields(mines);\n-                sendPlayerInfo();\n-            } else if (game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) {\n-                // For now, declare no autohit hexes.\n-                Vector<Coords> autoHitHexes = calculateArtyAutoHitHexes();\n-                sendArtyAutoHitHexes(autoHitHexes);\n-            } else if ((game.getPhase() == IGame.Phase.PHASE_TARGETING)\n-                       || (game.getPhase() == IGame.Phase.PHASE_OFFBOARD)) {\n-                // Send a \"no attack\" to clear the game turn, if any.\n-                // TODO: Fix for real arty stuff\n-                calculateTargetingOffBoardTurn();\n-            }\n-        } catch (Throwable t) {\n-            t.printStackTrace();\n+        int retryCount = 0;\n+        boolean success = false;\n+        \n+        while((retryCount < BOT_TURN_RETRY_COUNT) && !success) {\n+\t        try {\n+\t            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {", "originalCommit": "cc93a650850c40c7b179dfbf6c583fd09fcdafc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyOTM0Mw==", "url": "https://github.com/MegaMek/megamek/pull/2148#discussion_r470929343", "bodyText": "Same as above.", "author": "sixlettervariables", "createdAt": "2020-08-15T03:00:16Z", "path": "megamek/src/megamek/client/bot/princess/PathEnumerator.java", "diffHunk": "@@ -168,166 +170,173 @@ void updateUnitLocations(Entity entity, List<MovePath> paths) {\n     public void recalculateMovesFor(final Entity mover) {\n         final String METHOD_NAME = \"recalculateMovesFor(IGame, Entity)\";\n         getOwner().methodBegin(getClass(), METHOD_NAME);\n-        try {\n-\n-            // Record it's current position.\n-            getLastKnownLocations().put(\n-                    mover.getId(),\n-                    CoordFacingCombo.createCoordFacingCombo(\n-                            mover.getPosition(), mover.getFacing()));\n-\n-            // Clear out any already calculated paths.\n-            getUnitPaths().remove(mover.getId());\n-            getLongRangePaths().remove(mover.getId());\n-            \n-            // if the entity does not exist in the game for any reason, let's cut out safely\n-            // otherwise, we'll run into problems calculating paths\n-            if (getGame().getEntity(mover.getId()) == null) {\n-                // clean up orphaned entries in local storage\n-                getUnitMovableAreas().remove(mover.getId());\n-                getUnitPotentialLocations().remove(mover.getId());\n-                getLastKnownLocations().remove(mover.getId());\n-                return;\n-            }\n-\n-            // Start constructing the new list of paths.\n-            List<MovePath> paths = new ArrayList<>();\n-            \n-            // Aero movement on atmospheric ground maps\n-            // currently only applies to a) conventional aircraft, b) aerotech units, c) lams in air mode\n-            if(mover.isAirborneAeroOnGroundMap() && !((IAero) mover).isSpheroid()) {\n-                AeroGroundPathFinder apf = AeroGroundPathFinder.getInstance(getGame());\n-                MovePath startPath = new MovePath(getGame(), mover);\n-                apf.run(startPath);\n-                paths.addAll(apf.getAllComputedPathsUncategorized());\n-                \n-                // Remove illegal paths.\n-                Filter<MovePath> filter = new Filter<MovePath>() {\n-                    @Override\n-                    public boolean shouldStay(MovePath movePath) {\n-                        return isLegalAeroMove(movePath);\n-                    }\n-                };\n-                \n-                this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Unfiltered paths: \" + paths.size());\n-                paths = new ArrayList<>(filter.doFilter(paths));\n-                this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Filtered out illegal paths: \" + paths.size());\n-                AeroGroundOffBoardFilter offBoardFilter = new AeroGroundOffBoardFilter();\n-                paths = new ArrayList<>(offBoardFilter.doFilter(paths));\n-                \n-                MovePath offBoardPath = offBoardFilter.getShortestPath();\n-                if(offBoardPath != null) {\n-                    paths.add(offBoardFilter.getShortestPath());\n-                }\n-                \n-                this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Filtered out offboard paths: \" + paths.size());\n-                \n-                // This is code useful for debugging, but puts out a lot of log entries, which slows things down. \n-                HashMap<Integer, Integer> pathLengths = new HashMap<Integer, Integer>();\n-                for(MovePath path : paths) {\n-                    if(!pathLengths.containsKey(path.length())) {\n-                        pathLengths.put(path.length(), 0);\n-                    }\n-                    Integer lengthCount = pathLengths.get(path.length());\n-                    pathLengths.put(path.length(), lengthCount + 1);\n-                    \n-                    this.owner.log(this.getClass(), \"Path \", LogLevel.DEBUG, path.toString());\n-                }\n-                \n-                for(Integer length : pathLengths.keySet()) {\n-                    this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Paths of length \" + length + \": \" + pathLengths.get(length));\n-                }\n-            // this handles the case of the mover being an aerospace unit and \"advances space flight\" rules being on\n-            } else if(mover.isAero() && game.useVectorMove()) {\n-                NewtonianAerospacePathFinder npf = NewtonianAerospacePathFinder.getInstance(getGame());\n-                npf.run(new MovePath(game, mover));\n-                paths.addAll(npf.getAllComputedPathsUncategorized());\n-            // this handles the case of the mover being an aerospace unit on a space map\n-            } else if(mover.isAero() && game.getBoard().inSpace()) {\n-                AeroSpacePathFinder apf = AeroSpacePathFinder.getInstance(getGame());\n-                apf.run(new MovePath(game, mover));\n-                paths.addAll(apf.getAllComputedPathsUncategorized());\n-            // this handles the case of the mover being a winged aerospace unit on a low-atmo map\n-            } else if(mover.isAero() && game.getBoard().inAtmosphere() && !Compute.useSpheroidAtmosphere(game, mover)) {\n-                AeroLowAltitudePathFinder apf = AeroLowAltitudePathFinder.getInstance(getGame());\n-                apf.run(new MovePath(game, mover));\n-                paths.addAll(apf.getAllComputedPathsUncategorized());\n-            // this handles the case of the mover acting like a spheroid aerospace unit in an atmosphere\n-            } else if(Compute.useSpheroidAtmosphere(game, mover)) {\n-                SpheroidPathFinder spf = SpheroidPathFinder.getInstance(game);\n-                spf.run(new MovePath(game, mover));\n-                paths.addAll(spf.getAllComputedPathsUncategorized());\n-            // this handles the case of the mover being an infantry unit of some kind, that's not airborne.\n-            } else if (mover.hasETypeFlag(Entity.ETYPE_INFANTRY) && !mover.isAirborne()) {\n-                InfantryPathFinder ipf = InfantryPathFinder.getInstance(getGame());\n-                ipf.run(new MovePath(game, mover));\n-                paths.addAll(ipf.getAllComputedPathsUncategorized());\n-                \n-                // generate long-range paths appropriate to the bot's current state\n-                updateLongRangePaths(mover);\n-            // this handles situations where a unit is high up in the air, but is not an aircraft\n-            // such as an ejected pilot or a unit hot dropping from a dropship, as these cannot move\n-            } else if (!mover.isAero() && mover.isAirborne()) {\n-                paths.add(new MovePath(game, mover));\n-            } else { // Non-Aero movement\n-                // TODO: Will this cause Princess to never use MASC?\n-                LongestPathFinder lpf = LongestPathFinder\n-                        .newInstanceOfLongestPath(mover.getRunMPwithoutMASC(),\n-                                MoveStepType.FORWARDS, getGame());\n-                lpf.run(new MovePath(game, mover));\n-                paths.addAll(lpf.getLongestComputedPaths());\n-\n-                //add walking moves\n-                lpf = LongestPathFinder.newInstanceOfLongestPath(\n-                        mover.getWalkMP(), MoveStepType.BACKWARDS, getGame());\n-                lpf.run(new MovePath(getGame(), mover));\n-                paths.addAll(lpf.getLongestComputedPaths());\n-\n-                //add jumping moves\n-                if (mover.getJumpMP() > 0) {\n-                    ShortestPathFinder spf = ShortestPathFinder\n-                            .newInstanceOfOneToAll(mover.getJumpMP(),\n-                                    MoveStepType.FORWARDS, getGame());\n-                    spf.run((new MovePath(game, mover))\n-                            .addStep(MoveStepType.START_JUMP));\n-                    paths.addAll(spf.getAllComputedPathsUncategorized());\n-                }\n-\n-                for(MovePath path : paths) {\n-                    this.owner.log(this.getClass(), \"Path \", LogLevel.DEBUG, path.toString());\n-                }\n-                \n-                // Try climbing over obstacles and onto bridges\n-                adjustPathsForBridges(paths);\n-\n-                //filter those paths that end in illegal state\n-                Filter<MovePath> filter = new Filter<MovePath>() {\n-                    @Override\n-                    public boolean shouldStay(MovePath movePath) {\n-                        boolean isLegal = movePath.isMoveLegal();\n-                        return isLegal\n-                                && (Compute.stackingViolation(getGame(),\n-                                        mover.getId(),\n-                                        movePath.getFinalCoords()) == null);\n-                    }\n-                };\n-                paths = new ArrayList<>(filter.doFilter(paths));\n-                \n-                // generate long-range paths appropriate to the bot's current state\n-                updateLongRangePaths(mover);\n-            }\n-\n-            // Update our locations and add the computed paths.\n-            updateUnitLocations(mover, paths);\n-            getUnitPaths().put(mover.getId(), paths);\n-\n-            // calculate bounding area for move\n-            ConvexBoardArea myArea = new ConvexBoardArea(owner);\n-            myArea.addCoordFacingCombos(getUnitPotentialLocations().get(\n-                    mover.getId()).iterator());\n-            getUnitMovableAreas().put(mover.getId(), myArea);\n-        } finally {\n-            getOwner().methodEnd(getClass(), METHOD_NAME);\n+        \n+        int retryCount = 0;\n+        boolean success = false;\n+        \n+        while ((retryCount < BotClient.BOT_TURN_RETRY_COUNT) && !success) {\n+\t        try {\n+\t\n+\t            // Record it's current position.\n+\t            getLastKnownLocations().put(", "originalCommit": "cc93a650850c40c7b179dfbf6c583fd09fcdafc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "381a80ebe02dcf2165f12f1bf18bfb314ab1c80b", "url": "https://github.com/MegaMek/megamek/commit/381a80ebe02dcf2165f12f1bf18bfb314ab1c80b", "message": "separate retry and worker functionality", "committedDate": "2020-08-15T04:22:24Z", "type": "commit"}]}