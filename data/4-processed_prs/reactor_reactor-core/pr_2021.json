{"pr_number": 2021, "pr_title": "fix #2014 Cancel discards concatMapIterable/fromIterable's remainder \u2026", "pr_createdAt": "2020-01-23T14:53:45Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2021", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE4NTI2MA==", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r370185260", "bodyText": "magical constant used in a few places, let's extract :)", "author": "bsideup", "createdAt": "2020-01-23T15:26:35Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -89,11 +91,11 @@ public void subscribe(CoreSubscriber<? super R> actual) {\n \t\t\t}\n \n \t\t\tIterator<? extends R> it;\n-\n+\t\t\tboolean knownToBeFinite;\n \t\t\ttry {\n \t\t\t\tIterable<? extends R> iter = mapper.apply(v);\n-\n \t\t\t\tit = iter.iterator();\n+\t\t\t\tknownToBeFinite = iter.spliterator().getExactSizeIfKnown() != -1;", "originalCommit": "ceac4252f343d2607a34fc66fef6e2e5d5a8baa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE4NTg4Nw==", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r370185887", "bodyText": "this block seems to be repeated 9 times, wdyt about extracting it into a method?", "author": "bsideup", "createdAt": "2020-01-23T15:27:30Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -367,15 +378,21 @@ void drainAsync() {\n \t\t\t\t\twhile (e != r) {\n \t\t\t\t\t\tif (cancelled) {\n \t\t\t\t\t\t\tcurrent = null;\n-\t\t\t\t\t\t\tOperators.onDiscardQueueWithClear(q, ctx, null);\n+\t\t\t\t\t\t\tcurrentKnownToBeFinite = false; //reset explicitly", "originalCommit": "ceac4252f343d2607a34fc66fef6e2e5d5a8baa8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUzNjMwNg==", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r370536306", "bodyText": "Maybe not the whole block, but the current = null; currentKnownToBeFinite = false; part: it is very important these two are reset together, and the code is short enough that it can be inlined. I'll extract that instead (19 duplicates).", "author": "simonbasle", "createdAt": "2020-01-24T09:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE4NTg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE3MTQ2OA==", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r371171468", "bodyText": "FYI I was looking at the sources of java.util.Spliterator and trying to find the -1 constant there.\ngetExactSizeIfKnown() is defined as:\n    default long getExactSizeIfKnown() {\n        return (characteristics() & SIZED) == 0 ? -1L : estimateSize();\n    }\nwhich means that we could also do (iter.spliterator().characteristics() & Spliterator.SIZED) == 0 instead of calling getExactSizeIfKnown() which also matches what we're actually checking. WDYT?", "author": "bsideup", "createdAt": "2020-01-27T10:49:19Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -89,11 +90,11 @@ public void subscribe(CoreSubscriber<? super R> actual) {\n \t\t\t}\n \n \t\t\tIterator<? extends R> it;\n-\n+\t\t\tboolean knownToBeFinite;\n \t\t\ttry {\n \t\t\t\tIterable<? extends R> iter = mapper.apply(v);\n-\n \t\t\t\tit = iter.iterator();\n+\t\t\t\tknownToBeFinite = iter.spliterator().getExactSizeIfKnown() != FluxIterable.SPLITERATOR_UNSIZED;", "originalCommit": "88992af734ddbee9b874dc1ed442216edb7e1cda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4MDc1NQ==", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r371180755", "bodyText": "yeah that is still expressive enough and less computational-intensive", "author": "simonbasle", "createdAt": "2020-01-27T11:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE3MTQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwNjE4Mw==", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r372906183", "bodyText": "Couldn't we check first if Iterable is a  Collection as an optimization to avoid the Spliterator instance creation? It could be encapsulated in an utility method since this is done quite a few times.", "author": "rstoyanchev", "createdAt": "2020-01-30T11:52:44Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -89,11 +91,11 @@ public void subscribe(CoreSubscriber<? super R> actual) {\n \t\t\t}\n \n \t\t\tIterator<? extends R> it;\n-\n+\t\t\tboolean knownToBeFinite;\n \t\t\ttry {\n \t\t\t\tIterable<? extends R> iter = mapper.apply(v);\n-\n \t\t\t\tit = iter.iterator();\n+\t\t\t\tknownToBeFinite = iter.spliterator().hasCharacteristics(Spliterator.SIZED);", "originalCommit": "1505277b88197bc1f4dfe23fb6dbc13273099086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkxMjgxNA==", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r372912814", "bodyText": "Maybe resetCurrent() reads better. Clear sounds a lot like clearing content, as in aCollection, which is also implemented here.", "author": "rstoyanchev", "createdAt": "2020-01-30T12:08:23Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -275,18 +279,27 @@ public void cancel() {\n \t\t\t\ts.cancel();\n \n \t\t\t\tif (WIP.getAndIncrement(this) == 0) {\n-\t\t\t\t\tOperators.onDiscardQueueWithClear(queue, actual.currentContext(), null);\n+\t\t\t\t\tContext context = actual.currentContext();\n+\t\t\t\t\tOperators.onDiscardQueueWithClear(queue, context, null);\n+\t\t\t\t\tOperators.onDiscardMultiple(current, currentKnownToBeFinite, context);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\t//should be kept small and final to favor inlining\n+\t\tfinal void clearIterator() {\n+\t\t\tcurrent = null;\n+\t\t\tcurrentKnownToBeFinite = false;\n+\t\t}", "originalCommit": "1505277b88197bc1f4dfe23fb6dbc13273099086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzNzE2Mw==", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r372937163", "bodyText": "I noticed onCloseWithDropError in both subscriptions don't call onDiscardMultiple. Perhaps there is a reason, but it looks like the iterator may have more items (e.g. in poll() if an item is null).", "author": "rstoyanchev", "createdAt": "2020-01-30T13:09:24Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxIterable.java", "diffHunk": "@@ -19,16 +19,20 @@\n import java.util.Collection;", "originalCommit": "1505277b88197bc1f4dfe23fb6dbc13273099086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDExNTMxMw==", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r374115313", "bodyText": "a QueueSubscription must only return null to poll() if the subscription is empty/done. some cases of calling onCloseWithDropErrors are not suitable for attempting a drain of the iterator, for instance if hasNext() throws... Should we attempt to drain in the case the iterator returns a null value though? I'd argue this is an illegal state so the user should find the root cause of the null first and foremost, after which the discarding will be correctly done.", "author": "simonbasle", "createdAt": "2020-02-03T13:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzNzE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzOTg2Nw==", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r372939867", "bodyText": "Isn't this initialization redundant? It will be updated before its used.", "author": "rstoyanchev", "createdAt": "2020-01-30T13:15:31Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -658,6 +697,7 @@ public boolean isEmpty() {\n \t\t@Nullable\n \t\tpublic R poll() {\n \t\t\tIterator<? extends R> it = current;\n+\t\t\tboolean itFinite = currentKnownToBeFinite;", "originalCommit": "1505277b88197bc1f4dfe23fb6dbc13273099086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEyMTkxOQ==", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r374121919", "bodyText": "indeed, fixed", "author": "simonbasle", "createdAt": "2020-02-03T14:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzOTg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk0MDIyNA==", "url": "https://github.com/reactor/reactor-core/pull/2021#discussion_r372940224", "bodyText": "Likewise setting this here seems redundant since itFinite will be set again before its used.", "author": "rstoyanchev", "createdAt": "2020-01-30T13:16:14Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxFlattenIterable.java", "diffHunk": "@@ -679,16 +721,18 @@ public R poll() {\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t\tcurrent = it;\n+\t\t\t\t\tcurrentKnownToBeFinite = itFinite;\n \t\t\t\t}\n \t\t\t\telse if (!it.hasNext()) {\n \t\t\t\t\tit = null;\n+\t\t\t\t\titFinite = false;", "originalCommit": "1505277b88197bc1f4dfe23fb6dbc13273099086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "db7d3cb26e209e39965e43600ad95a3e2088f499", "url": "https://github.com/reactor/reactor-core/commit/db7d3cb26e209e39965e43600ad95a3e2088f499", "message": "fix #2014 Discard concatMapIterable/fromIterable's remainder on Cancel\n\nIn this change, the goal is to discard elements of the Iterable that\nhaven't been processed yet. The challenge is to avoid attempting doing\nso for _infinite_ Iterables (which would lead to infinite discarding\nloops).\n\nIf the Iterable is a Collection, it should be finite.\n\nIf both an Iterator and a Spliterator can be generated for each of the\nprocessed Iterables, then the Spliterator is used to ensure the Iterable\nis SIZED. This allows us to safely assume we can iterate over the\nremainder of the iterator when cancelling, in order to discard its\nelements that weren't emitted.\n\nFor Streams, since both the iterator() and spliterator() methods are\nterminating the Stream we only generate the Spliterator. We use it to\ncheck SIZED and then wrap it in an Iterator adapter for iteration (which\nis what BaseStream does by default).\n\nImplementation Notes\n----\nWe didn't fully switch to using a Spliterator to drive the internal\niteration. It doesn't work that well, since the Iterable#spliterator\ndefault implementation isn't SIZED and its estimatedSize() method does\nnot behave like hasNext().\nIterator#hasNext is far better suited for looking ahead of the emitted\nelement to trigger onComplete immediately after the last onNext.", "committedDate": "2020-02-07T09:24:05Z", "type": "commit"}, {"oid": "f0dfc644388c353cd0ddf641210c2e7414ea042b", "url": "https://github.com/reactor/reactor-core/commit/f0dfc644388c353cd0ddf641210c2e7414ea042b", "message": "[polish] Improve onDiscardMultiple/QueueWithClear resiliency (#2021)\n\nThis commit improves discard resiliency when dealing with queues,\nstreams, collections and iterators. By introducing finer grained\ntry/catch blocks, we ensure that failures around a single discarded\nelement doesn't prevent discarding of further elements of the container.", "committedDate": "2020-02-07T09:29:45Z", "type": "commit"}, {"oid": "f0dfc644388c353cd0ddf641210c2e7414ea042b", "url": "https://github.com/reactor/reactor-core/commit/f0dfc644388c353cd0ddf641210c2e7414ea042b", "message": "[polish] Improve onDiscardMultiple/QueueWithClear resiliency (#2021)\n\nThis commit improves discard resiliency when dealing with queues,\nstreams, collections and iterators. By introducing finer grained\ntry/catch blocks, we ensure that failures around a single discarded\nelement doesn't prevent discarding of further elements of the container.", "committedDate": "2020-02-07T09:29:45Z", "type": "forcePushed"}]}