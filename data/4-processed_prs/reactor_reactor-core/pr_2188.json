{"pr_number": 2188, "pr_title": "Introduce Sinks and deprecate concrete processors", "pr_createdAt": "2020-06-11T15:04:28Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2188", "timeline": [{"oid": "e26ada7999dd24f5a65a8a7781c5e835839b3e53", "url": "https://github.com/reactor/reactor-core/commit/e26ada7999dd24f5a65a8a7781c5e835839b3e53", "message": "wip first round of deprecation fixes for tests", "committedDate": "2020-06-11T15:06:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjQ2Mg==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r438872462", "bodyText": "Can these wait until a major to be removed?", "author": "spencergibb", "createdAt": "2020-06-11T15:30:02Z", "path": "reactor-core/src/main/java/reactor/core/publisher/DirectProcessor.java", "diffHunk": "@@ -77,7 +78,9 @@\n  * </p>\n  *\n  * @param <T> the input and output value type\n+ * @deprecated Prefer clear cut usage of either {@link Processors} or {@link Sinks}, to be removed in 3.5", "originalCommit": "e26ada7999dd24f5a65a8a7781c5e835839b3e53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg4OTYwNg==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r438889606", "bodyText": "can you expand on your concern ? if we follow the history of Reactor (2.x > 3.0 > 3.1 > 3.2 and now 3.3), a \"major\" would be a significant event that would probably mean a complete re-architecture, to the point that the whole ecosystem around Reactor would probably need heavy re-architecturing too, or break (see Reactor 2 vs Reactor 3). The only other drives for a Reactor 4 that I could think about are a change in the Java baseline or the advent of a Reactive Streams v2. In any case, very unlikely at this point.", "author": "simonbasle", "createdAt": "2020-06-11T15:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg5OTA4NQ==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r438899085", "bodyText": "deprecating one release and removing the next just breaks backward compatibility quickly. With boot moving to a 6-month cadence for minors, they are deprecating, then waiting an extra release to remove. So deprecate in x.1, do nothing in x.2 and remove in x.3.", "author": "spencergibb", "createdAt": "2020-06-11T16:00:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyOTQyNA==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r438929424", "bodyText": "I see. But unlike Boot, we haven't switched to a 6 month cadence. So deprecating these now would mean that the concrete classes would disappear from the public API in a year or so. Initially, there was an issue to directly remove them without the deprecation, but I agree this would be overkill. Note that TopicProcessor and WorkQueueProcessor are slated to be removed though (since deprecated in 3.3.0)", "author": "simonbasle", "createdAt": "2020-06-11T16:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0MjcwNg==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r438942706", "bodyText": "\ud83d\udc4d got it. thanks for taking the time to explain.", "author": "spencergibb", "createdAt": "2020-06-11T17:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjQ2Mg=="}], "type": "inlineReview"}, {"oid": "52fa84bf2422d36200d0e14a79e104d16702766a", "url": "https://github.com/reactor/reactor-core/commit/52fa84bf2422d36200d0e14a79e104d16702766a", "message": "Introduce FluxSink superinterface, Sinks vs Processors...\n\nAlso deprecate FluxProcessor concrete implementations.", "committedDate": "2020-06-18T17:43:10Z", "type": "commit"}, {"oid": "ae1e25df970d6bbda1a3d9d6c35f3459bf474390", "url": "https://github.com/reactor/reactor-core/commit/ae1e25df970d6bbda1a3d9d6c35f3459bf474390", "message": "Fix compilation of prod+test; fix warnings in prod", "committedDate": "2020-06-18T17:43:10Z", "type": "commit"}, {"oid": "8ac71c31731e111c05992ac8e95ecb4b42363d1f", "url": "https://github.com/reactor/reactor-core/commit/8ac71c31731e111c05992ac8e95ecb4b42363d1f", "message": "Update guide to use Sinks.hotFlux instead of DirectProcessor", "committedDate": "2020-06-18T17:43:10Z", "type": "commit"}, {"oid": "85f274caafbd3a5967aecdef363722948581f4ca", "url": "https://github.com/reactor/reactor-core/commit/85f274caafbd3a5967aecdef363722948581f4ca", "message": "wip first round of deprecation fixes for tests", "committedDate": "2020-06-18T17:43:10Z", "type": "commit"}, {"oid": "d70f60271ea604e385f11769d0d301610d9b5375", "url": "https://github.com/reactor/reactor-core/commit/d70f60271ea604e385f11769d0d301610d9b5375", "message": "Fixup UnicastProcessor initial request", "committedDate": "2020-06-18T17:43:11Z", "type": "commit"}, {"oid": "4b3b42874e89d1aea553abbcb3ff26cbb4fd719f", "url": "https://github.com/reactor/reactor-core/commit/4b3b42874e89d1aea553abbcb3ff26cbb4fd719f", "message": "Have UnicastProcessor expose ACTUAL attribute", "committedDate": "2020-06-18T17:43:11Z", "type": "commit"}, {"oid": "83c9a9041d019d56b3570d4ffd72b169eedd4a2d", "url": "https://github.com/reactor/reactor-core/commit/83c9a9041d019d56b3570d4ffd72b169eedd4a2d", "message": "Replace processor with standalone sink in FluxBufferTimeoutTest", "committedDate": "2020-06-18T17:43:11Z", "type": "commit"}, {"oid": "a624c76af0d8b2dc907133357d756754529006a6", "url": "https://github.com/reactor/reactor-core/commit/a624c76af0d8b2dc907133357d756754529006a6", "message": "Remove deprecated uses of concrete processors in flux tests", "committedDate": "2020-06-18T17:43:11Z", "type": "commit"}, {"oid": "55805025a2f6cf5bee36ad901ef5397fee258876", "url": "https://github.com/reactor/reactor-core/commit/55805025a2f6cf5bee36ad901ef5397fee258876", "message": "Remove deprecated uses of concrete processors in reactor-test tests", "committedDate": "2020-06-18T17:43:11Z", "type": "commit"}, {"oid": "91e7bcbbae15a17031cefedc70e86e3f3bf758d1", "url": "https://github.com/reactor/reactor-core/commit/91e7bcbbae15a17031cefedc70e86e3f3bf758d1", "message": "Remove deprecated uses of concrete processors in BaseOperatorTest", "committedDate": "2020-06-18T17:43:11Z", "type": "commit"}, {"oid": "2570dc929e534ae8a2ce139dea375d8d2ec3e018", "url": "https://github.com/reactor/reactor-core/commit/2570dc929e534ae8a2ce139dea375d8d2ec3e018", "message": "SinkFlux to SequenceSink, add ScalarSink, add more flavors\n\nTODO test latest() and trigger() mono-like sinks.", "committedDate": "2020-06-18T17:43:11Z", "type": "commit"}, {"oid": "e5589ad86ba398592d83f2f1c33ab440755d3de5", "url": "https://github.com/reactor/reactor-core/commit/e5589ad86ba398592d83f2f1c33ab440755d3de5", "message": "Align Processors size replay method naming with Sinks", "committedDate": "2020-06-18T17:43:11Z", "type": "commit"}, {"oid": "161b5106420ed8f920092edc4968464e944cd651", "url": "https://github.com/reactor/reactor-core/commit/161b5106420ed8f920092edc4968464e944cd651", "message": "Remove SequenceToMonoSink, polish", "committedDate": "2020-06-18T17:43:11Z", "type": "commit"}, {"oid": "45a7458528d1caee41db04c0f4ce3309cca55808", "url": "https://github.com/reactor/reactor-core/commit/45a7458528d1caee41db04c0f4ce3309cca55808", "message": "polish unicast() sink and test", "committedDate": "2020-06-18T17:43:11Z", "type": "commit"}, {"oid": "c52e32b4aea4885830ae7d89b397d6068b036107", "url": "https://github.com/reactor/reactor-core/commit/c52e32b4aea4885830ae7d89b397d6068b036107", "message": "Add documentation around standalone sinks", "committedDate": "2020-06-18T17:43:11Z", "type": "commit"}, {"oid": "c52e32b4aea4885830ae7d89b397d6068b036107", "url": "https://github.com/reactor/reactor-core/commit/c52e32b4aea4885830ae7d89b397d6068b036107", "message": "Add documentation around standalone sinks", "committedDate": "2020-06-18T17:43:11Z", "type": "forcePushed"}, {"oid": "ab76df0c1cd9fcaea8e53579a05789e6b5bbdd3f", "url": "https://github.com/reactor/reactor-core/commit/ab76df0c1cd9fcaea8e53579a05789e6b5bbdd3f", "message": "polish asciidoc and fix issues", "committedDate": "2020-06-18T18:18:14Z", "type": "commit"}, {"oid": "d222ce1ac5a54f75a2212488c4ba340bdb6a3614", "url": "https://github.com/reactor/reactor-core/commit/d222ce1ac5a54f75a2212488c4ba340bdb6a3614", "message": "Swap multicast() and multicastPreWarming, buffer by defaut", "committedDate": "2020-06-18T18:25:11Z", "type": "commit"}, {"oid": "299a170088e47afaa060b550a7d9a4772169af30", "url": "https://github.com/reactor/reactor-core/commit/299a170088e47afaa060b550a7d9a4772169af30", "message": "Align multicastReplay Sinks naming with replay Processors", "committedDate": "2020-06-18T18:25:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzg2MQ==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442507861", "bodyText": "Since asFlux() exposes Flux<T> but not concrete Processor onEachOperator hook could be applied here.\nSince FluxProcessors are ASYNC Publishers it could help with Thread context propagations", "author": "robotmrv", "createdAt": "2020-06-18T21:17:40Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {\n+\t\treturn new MonoProcessorSink<>(MonoProcessor.create());\n+\t}\n+\n+\t// == interfaces ==\n+\n+\t/**\n+\t * A flavor of {@link SequenceSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asFlux() as a Flux}. Most likely, such a {@link SequenceSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneFluxSink<T> extends SequenceSink<T> {\n+\n+\t\t@Override\n+\t\tStandaloneFluxSink<T> next(T t);\n+\n+\t\t/**\n+\t\t * Return the companion {@link Flux} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Flux} view associated to this {@link StandaloneFluxSink}\n+\t\t */\n+\t\tFlux<T> asFlux();\n+\n+\t}\n+\n+\t/**\n+\t * A flavor of {@link ScalarSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asMono() as a Mono}. Most likely, such a {@link ScalarSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneMonoSink<T> extends ScalarSink<T> {\n+\n+\t\t/**\n+\t\t * Return the companion {@link Mono} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Mono} view associated to this {@link StandaloneMonoSink}\n+\t\t */\n+\t\tMono<T> asMono();\n+\t}\n+\n+\t// == concrete classes ==\n+\n+\tstatic final class FluxProcessorSink<T>\n+\t\t\timplements StandaloneFluxSink<T> {\n+\n+\t\tfinal FluxSink<T>         delegateSink;\n+\t\tfinal FluxProcessor<T, T> processor;\n+\n+\t\t@SuppressWarnings(\"deprecation\")\n+\t\tFluxProcessorSink(FluxProcessor<T, T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t\tthis.delegateSink = processor.sink();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Flux<T> asFlux() {\n+\t\t\treturn processor;", "originalCommit": "299a170088e47afaa060b550a7d9a4772169af30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5ODk5Mw==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442698993", "bodyText": "the processor in question is only fed via manual interactions, so I'm not sure how that would help eg. if the user decides to do a new Thread(() -> sink.next(1)).start()...", "author": "simonbasle", "createdAt": "2020-06-19T08:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzg2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNTMwMA==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442715300", "bodyText": "it would help downstream consumers as processor could be decorated and values would be emitted within context for them.\nhere the example of the problem\n//add hook that propagates value from Reactor `Context` to the `ThreadLocal`\n....\nString testValue = \"testValue\";\nsetTL(testValue);\nMonoProcessor<Integer> processor = MonoProcessor.create();\nMono.delay(Duration.ofMillis(500))\n        .doOnNext(it -> processor.onNext(1))\n        .subscribe();\n\nString value = processor\n//        .doOnNext(it -> {}) // works only with dummy operator as it decorates downstream\n        .map(it -> getValueFromTL())// value was not propagated because hook was not applied to the source\n        .block();\nAssertions.assertThat(value).isEqualTo(testValue);", "author": "robotmrv", "createdAt": "2020-06-19T08:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzg2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MDIxOA==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442870218", "bodyText": "I need to look deeper into the consequences of that, not sure applying the hooks to the processor will work naturally. plus currently there is no such thing with processors. can you chime back in once M1 is released (eg creating an issue for M2) ?", "author": "simonbasle", "createdAt": "2020-06-19T14:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxMzIzMw==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442713233", "bodyText": "shouldn't it inherit the javadocs?", "author": "bsideup", "createdAt": "2020-06-19T08:41:34Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxSink.java", "diffHunk": "@@ -31,12 +31,10 @@\n  * <p>\n  * @param <T> the value type\n  */\n-public interface FluxSink<T> {\n+public interface FluxSink<T> extends SequenceSink<T> {\n \n-\t/**\n-     * @see Subscriber#onComplete()\n-     */\n-    void complete();\n+\t@Override", "originalCommit": "299a170088e47afaa060b550a7d9a4772169af30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgzMzA2OA==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442833068", "bodyText": "the javadoc is automatically copied, inheritDoc is only if you want to supplement it with additional content while including the super content", "author": "simonbasle", "createdAt": "2020-06-19T13:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxMzIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNDUwMg==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442714502", "bodyText": "FYI one of the reasons why I was choosing concrete type over FluxProcessor is because having to specify the type argument twice was a bit cumbersome.\nAs this is a new API, perhaps we can do something about it? especially given that now it is always <T, T>", "author": "bsideup", "createdAt": "2020-06-19T08:46:00Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Processors.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.function.Consumer;\n+\n+import reactor.core.Disposable;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.util.annotation.Nullable;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Processors {\n+\n+\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static final <T> FluxProcessor<T, T> unicast() {", "originalCommit": "299a170088e47afaa060b550a7d9a4772169af30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMzAxNA==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442723014", "bodyText": "the number of new interfaces / classes was a concern in the original proposal back then, but there's probably little way around the current split into 4 sink interfaces (plus 2 additional utility classes).\nwe could improve that <T,T> situation but it means adding FluxIdentityProcessor<T> at least... Maybe Processors can be turned into both interface and factory.\nIt raises another issue, which is the misalignment between FluxProcessor<A,B> and MonoProcessor<A> (mono processor has a single concrete implementation, and thus doesn't help with representing processing stages). That'll be a concern for either M2 or 3.5 now :/", "author": "simonbasle", "createdAt": "2020-06-19T09:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNDUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwMzIxNQ==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442903215", "bodyText": "actually it cannot be melded with Processors, the FluxProcessor being an abstract class (due to the need to extend Flux)... furthermore replay factory method on Processors would clash with Flux#replay(), and the factory methods would be lost in the noise of Flux API.\nInstead I went ahead and added an abstract intermediate FluxIdentityProcessor<T> extends FluxProcessor<T, T>", "author": "simonbasle", "createdAt": "2020-06-19T15:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNDUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNTQyNA==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442715424", "bodyText": "\"warmup\" sounds like a new term added. And, TBH, I struggle to understand it (even after reading the javadoc) \ud83d\ude05\nCould you please help me understanding the concept?", "author": "bsideup", "createdAt": "2020-06-19T08:50:12Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {", "originalCommit": "299a170088e47afaa060b550a7d9a4772169af30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxOTAwNQ==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442719005", "bodyText": "yeah I'm having trouble finding a better term. It's the way some processors will \"remember\" upstream onNext (or in our case sink.next) that come in BEFORE the first Subscriber subscribes. But then the second Subscriber would only see live pushes.\n\\ denotes a subscription\n<-warmup------><---------hot ---------->\n\n--(1)---(2)----\\---------\\----(3)------>   sink\n              -\\(1)(2)--------(3)------>   sub1\n                        -\\----(3)------>   sub2", "author": "simonbasle", "createdAt": "2020-06-19T08:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNTQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0NzAzNg==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442747036", "bodyText": "Thanks, the diagram really helps! Maybe let's add it to the javadoc?", "author": "bsideup", "createdAt": "2020-06-19T09:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNTQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2NTIzNw==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442865237", "bodyText": "I'll add a quick SVG version for both multicast() and multicastNoWarmup()", "author": "simonbasle", "createdAt": "2020-06-19T14:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNTQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxOTQ1NQ==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442719455", "bodyText": "WDYT about promise or future? trigger is too verb-ish", "author": "bsideup", "createdAt": "2020-06-19T09:00:39Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {", "originalCommit": "299a170088e47afaa060b550a7d9a4772169af30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTAyMg==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442725022", "bodyText": "I don't really like trigger either, future and promise sound too overloaded. Maybe completable to echo both CompletableFuture and Completable in RxJava? By I fear this becomes overloaded too...", "author": "simonbasle", "createdAt": "2020-06-19T09:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxOTQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0NzcyOA==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442747728", "bodyText": "IIRC Completable in RxJava is Publisher<Void>. It does sound too overloaded but we're talking about method's name, not type, so I think we're fine as it helps understanding the return value much better.", "author": "bsideup", "createdAt": "2020-06-19T09:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxOTQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3MTg2Mw==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442871863", "bodyText": "ok, I'll go with promise actually...", "author": "simonbasle", "createdAt": "2020-06-19T14:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxOTQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMTg3Nw==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442721877", "bodyText": "Just curious, why not using CAS?", "author": "bsideup", "createdAt": "2020-06-19T09:06:11Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import reactor.util.annotation.Nullable;\n+import reactor.util.concurrent.Queues;\n+import reactor.util.context.Context;\n+\n+/**\n+ * A collection of standalone sinks ({@link StandaloneFluxSink} and\n+ * {@link StandaloneMonoSink}).\n+ *\n+ * @author Simon Basl\u00e9\n+ */\n+public final class Sinks {\n+\n+\tprivate Sinks() { }\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand by conforming to the lowest demand in case\n+\t *     of multiple subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed. To the exception of the first\n+\t *     subscriber (see below).</li>\n+\t *     <li>Without {@link Subscriber}: warm up. Remembers up to {@link Queues#SMALL_BUFFER_SIZE}\n+\t *     elements pushed before the first {@link Subscriber} is registered.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicast() {\n+\t\treturn new FluxProcessorSink<>(EmitterProcessor.create(Queues.SMALL_BUFFER_SIZE));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: No replay. Only forwards to a {@link Subscriber} the elements that have been\n+\t *     pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t *     <li>Without {@link Subscriber}: Discarding. Pushing elements while there are no {@link Subscriber}\n+\t *     registered will simply discard these elements instead of \"warming up\" the sink.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> multicastNoWarmup() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(0));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: by {@code historySize}. Keeps the last {@code historySize} elements and\n+\t *     replays them instantly to new subscribers before continuing with \"live\" elements.</li>\n+\t *     <li>Without {@link Subscriber}: buffers enough elements pushed without a subscriber to\n+\t *     honor the {@code historySize}.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replay(int historySize) {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create(historySize));\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li>Multicast</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of individual subscribers.</li>\n+\t *     <li>Replaying: all elements pushed to this sink are replayed to new subscribers.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered,\n+\t *     even when there is no subscriber.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> replayAll() {\n+\t\treturn new FluxProcessorSink<>(ReplayProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneFluxSink} with the following characteristics:\n+\t * <ul>\n+\t *     <li><strong>Unicast</strong>: contrary to most other {@link StandaloneFluxSink}, the\n+\t *     {@link Flux} view rejects {@link Subscriber subscribers} past the first one.</li>\n+\t *     <li>Backpressure : this sink honors downstream demand of its single {@link Subscriber}.</li>\n+\t *     <li>Replaying: non-applicable, since only one {@link Subscriber} can register.</li>\n+\t *     <li>Without {@link Subscriber}: all elements pushed to this sink are remembered and will\n+\t *     be replayed once the {@link Subscriber} subscribes.</li>\n+\t * </ul>\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\tpublic static <T> StandaloneFluxSink<T> unicast() {\n+\t\treturn new FluxProcessorSink<>(UnicastProcessor.create());\n+\t}\n+\n+\t/**\n+\t * A {@link StandaloneMonoSink} that can be triggered at any time by either of\n+\t * the three completions: {@link ScalarSink#success(Object) valued completion},\n+\t * {@link ScalarSink#success() empty completions} or {@link ScalarSink#error(Throwable) error}.\n+\t * This completion is replayed to late subscribers.\n+\t */\n+\tpublic static <T> StandaloneMonoSink<T> trigger() {\n+\t\treturn new MonoProcessorSink<>(MonoProcessor.create());\n+\t}\n+\n+\t// == interfaces ==\n+\n+\t/**\n+\t * A flavor of {@link SequenceSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asFlux() as a Flux}. Most likely, such a {@link SequenceSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneFluxSink<T> extends SequenceSink<T> {\n+\n+\t\t@Override\n+\t\tStandaloneFluxSink<T> next(T t);\n+\n+\t\t/**\n+\t\t * Return the companion {@link Flux} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Flux} view associated to this {@link StandaloneFluxSink}\n+\t\t */\n+\t\tFlux<T> asFlux();\n+\n+\t}\n+\n+\t/**\n+\t * A flavor of {@link ScalarSink} that is not attached to a single {@link Subscriber}\n+\t * but rather viewable {@link #asMono() as a Mono}. Most likely, such a {@link ScalarSink}\n+\t * is capable of multicasting to several subscribers. However implementations can chose\n+\t * to be unicast instead, and only accept one {@link Subscriber} at a time (as allowed\n+\t * by the {@link org.reactivestreams.Publisher} specification).\n+\t *\n+\t * @param <T> the type of elements that can be emitted through this sink\n+\t */\n+\tpublic interface StandaloneMonoSink<T> extends ScalarSink<T> {\n+\n+\t\t/**\n+\t\t * Return the companion {@link Mono} instance that is backed by this sink.\n+\t\t * All calls to this method return the same instance.\n+\t\t *\n+\t\t * @return the {@link Mono} view associated to this {@link StandaloneMonoSink}\n+\t\t */\n+\t\tMono<T> asMono();\n+\t}\n+\n+\t// == concrete classes ==\n+\n+\tstatic final class FluxProcessorSink<T>\n+\t\t\timplements StandaloneFluxSink<T> {\n+\n+\t\tfinal FluxSink<T>         delegateSink;\n+\t\tfinal FluxProcessor<T, T> processor;\n+\n+\t\t@SuppressWarnings(\"deprecation\")\n+\t\tFluxProcessorSink(FluxProcessor<T, T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t\tthis.delegateSink = processor.sink();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Flux<T> asFlux() {\n+\t\t\treturn processor;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void complete() {\n+\t\t\tdelegateSink.complete();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void error(Throwable e) {\n+\t\t\tdelegateSink.error(e);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic StandaloneFluxSink<T> next(T t) {\n+\t\t\tdelegateSink.next(t);\n+\t\t\treturn this;\n+\t\t}\n+\t}\n+\n+\tstatic final class MonoProcessorSink<T> implements StandaloneMonoSink<T> {\n+\n+\t\tfinal MonoProcessor<T> processor;\n+\t\tboolean done;\n+\n+\t\tMonoProcessorSink(MonoProcessor<T> processor) {\n+\t\t\tthis.processor = processor;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Mono<T> asMono() {\n+\t\t\treturn this.processor;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void success() {\n+\t\t\tsynchronized (processor) {\n+\t\t\t\tif (done) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tdone = true;", "originalCommit": "299a170088e47afaa060b550a7d9a4772169af30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNDAzNQ==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442724035", "bodyText": "too much on my plate to have the perfect implementation in time for M1 :(", "author": "simonbasle", "createdAt": "2020-06-19T09:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMTg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNDUzNw==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442724537", "bodyText": "Should be destroyed after the test to avoid dangling Threads", "author": "bsideup", "createdAt": "2020-06-19T09:11:37Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);", "originalCommit": "299a170088e47afaa060b550a7d9a4772169af30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwNDU0Ng==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442904546", "bodyText": "done in the dynamic test version", "author": "simonbasle", "createdAt": "2020-06-19T15:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNDUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTI5Mw==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442725293", "bodyText": "cleanup is missing", "author": "bsideup", "createdAt": "2020-06-19T09:13:10Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);", "originalCommit": "299a170088e47afaa060b550a7d9a4772169af30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwNDQwNA==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442904404", "bodyText": "done in the dynamic test version", "author": "simonbasle", "createdAt": "2020-06-19T15:26:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTcxOA==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442725718", "bodyText": "could use an abstract parent class that checks common behaviours like this one", "author": "bsideup", "createdAt": "2020-06-19T09:14:08Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {", "originalCommit": "299a170088e47afaa060b550a7d9a4772169af30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwNDMzMA==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442904330", "bodyText": "done: made a dynamic test generation to express more directly the semantics found in the javadocs", "author": "simonbasle", "createdAt": "2020-06-19T15:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNjMyOQ==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442726329", "bodyText": "Probably not. Especially if onErrorResume is used on the returning Flux", "author": "bsideup", "createdAt": "2020-06-19T09:15:22Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1, 2, 3).assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void replayAndCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1).assertComplete();\n+\t\t}\n+\n+\t\t@Test //TODO is that acceptable that EmitterProcessor doesn't replay in case of errors?", "originalCommit": "299a170088e47afaa060b550a7d9a4772169af30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwMzU4Nw==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442903587", "bodyText": "isolated that in the test a bit more, will have to decide what to do by GA", "author": "simonbasle", "createdAt": "2020-06-19T15:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNjMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNzUwOA==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442727508", "bodyText": "ditto (the cleanup)", "author": "bsideup", "createdAt": "2020-06-19T09:17:56Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinksTest.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.concurrent.Queues;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+class SinksTest {\n+\n+\t@Nested\n+\tclass MulticastNoWarmup {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicastNoWarmup();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesNotBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass Multicast {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.multicast();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);\n+\t\t\tCountDownLatch requestLatch = new CountDownLatch(2);\n+\t\t\tfinal Future<?> f1 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test1 = AssertSubscriber.create(2);\n+\t\t\t\tflux.subscribe(test1);\n+\t\t\t\ttest1.assertNoValues();\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest1.awaitAndAssertNextValues(1, 2);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test1.assertValueCount(2));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest1.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tfinal Future<?> f2 = es.submit(() -> {\n+\t\t\t\tAssertSubscriber<Integer> test2 = AssertSubscriber.create(1);\n+\t\t\t\tflux.subscribe(test2);\n+\t\t\t\trequestLatch.countDown();\n+\n+\t\t\t\ttest2.awaitAndAssertNextValues(1);\n+\t\t\t\ttry {\n+\t\t\t\t\tAwaitility.await().atMost(2, TimeUnit.SECONDS)\n+\t\t\t\t\t          .with().pollDelay(1, TimeUnit.SECONDS)\n+\t\t\t\t\t          .untilAsserted(() -> test2.assertValueCount(1));\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\ttest2.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\trequestLatch.await(1, TimeUnit.SECONDS);\n+\t\t\tsink.next(1)\n+\t\t\t    .next(2)\n+\t\t\t    .next(3)\n+\t\t\t    .next(4)\n+\t\t\t    .complete();\n+\n+\t\t\tf1.get();\n+\t\t\tf2.get();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid doesNotReplayToLateSubscribers() {\n+\t\t\tAssertSubscriber<Integer> s1 = AssertSubscriber.create();\n+\t\t\tAssertSubscriber<Integer> s2 = AssertSubscriber.create();\n+\n+\t\t\tflux.subscribe(s1);\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\ts1.assertValues(1, 2, 3);\n+\n+\t\t\tflux.subscribe(s2);\n+\t\t\ts2.assertNoValues().assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\ts1.assertValueCount(3).assertComplete();\n+\t\t\ts2.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void doesBufferBeforeFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3);\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1, 2, 3).assertNotComplete();\n+\n+\t\t\tsink.complete();\n+\t\t\tfirst.assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void replayAndCompleteFirstSubscriber() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertValues(1).assertComplete();\n+\t\t}\n+\n+\t\t@Test //TODO is that acceptable that EmitterProcessor doesn't replay in case of errors?\n+\t\tpublic void noReplayBeforeFirstSubscriberIfEarlyError() {\n+\t\t\tAssertSubscriber<Integer> first = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).next(2).next(3).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(first);\n+\n+\t\t\tfirst.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyCompleteLateSubscriber() {\n+\t\t\tflux.subscribe(); //first subscriber\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).complete();\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertComplete();\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void immediatelyErrorLateSubscriber() {\n+\t\t\tflux.onErrorReturn(-1).subscribe(); //first subscriber, ignore errors\n+\t\t\tAssertSubscriber<Integer> late = AssertSubscriber.create();\n+\n+\t\t\tsink.next(1).error(new IllegalStateException(\"boom\"));\n+\t\t\tflux.subscribe(late);\n+\n+\t\t\tlate.assertNoValues().assertErrorMessage(\"boom\");\n+\t\t}\n+\t}\n+\n+\t@Nested\n+\tclass MulticastReplayAll {\n+\n+\t\tprivate Sinks.StandaloneFluxSink<Integer> sink;\n+\t\tprivate Flux<Integer> flux;\n+\n+\t\t@BeforeEach\n+\t\tvoid createInstance() {\n+\t\t\tsink = Sinks.replayAll();\n+\t\t\tflux = sink.asFlux();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid fluxViewReturnsSameInstance() {\n+\t\t\tassertThat(flux).isSameAs(sink.asFlux());\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid isAcceptingMoreThatOneSubscriber() {\n+\t\t\tassertThatCode(() -> {\n+\t\t\t\tflux.subscribe();\n+\t\t\t\tflux.subscribe();\n+\t\t\t}).doesNotThrowAnyException();\n+\t\t}\n+\n+\t\t@Test\n+\t\tvoid honorsMultipleSubscribersBackpressure()\n+\t\t\t\tthrows InterruptedException, ExecutionException {\n+\t\t\tExecutorService es = Executors.newFixedThreadPool(2);", "originalCommit": "299a170088e47afaa060b550a7d9a4772169af30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwMzg4Ng==", "url": "https://github.com/reactor/reactor-core/pull/2188#discussion_r442903886", "bodyText": "done in the dynamic test", "author": "simonbasle", "createdAt": "2020-06-19T15:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNzUwOA=="}], "type": "inlineReview"}, {"oid": "f16014ad3bd48313adf0c90c33274a025719c321", "url": "https://github.com/reactor/reactor-core/commit/f16014ad3bd48313adf0c90c33274a025719c321", "message": "Rework SinksTests to mutualize code as dynamic tests", "committedDate": "2020-06-19T13:03:03Z", "type": "commit"}, {"oid": "2fc8a2eed65ade94b587797134f5d5740c567503", "url": "https://github.com/reactor/reactor-core/commit/2fc8a2eed65ade94b587797134f5d5740c567503", "message": "per review, improve javadocs and add svg for warmup concept", "committedDate": "2020-06-19T14:27:36Z", "type": "commit"}, {"oid": "a5fa482da96da34acdd980d9b28ab2fb696f3d4e", "url": "https://github.com/reactor/reactor-core/commit/a5fa482da96da34acdd980d9b28ab2fb696f3d4e", "message": "per review, rename trigger to promise. add tests and fix error drop", "committedDate": "2020-06-19T15:03:04Z", "type": "commit"}, {"oid": "60285c2e462b27804cea70009f168f23ae0014b4", "url": "https://github.com/reactor/reactor-core/commit/60285c2e462b27804cea70009f168f23ae0014b4", "message": "Add FluxIdentityProcessor<T> specialization of FluxProcessor<T,T>", "committedDate": "2020-06-19T15:22:05Z", "type": "commit"}, {"oid": "6377bf3ad706354f9ad0dcc86db6398d9ba58ac6", "url": "https://github.com/reactor/reactor-core/commit/6377bf3ad706354f9ad0dcc86db6398d9ba58ac6", "message": "fixup compilation and some additional deprecation warnings", "committedDate": "2020-06-19T16:36:05Z", "type": "commit"}, {"oid": "77571d3d5460e357466716e1befe0edb0e2bc31a", "url": "https://github.com/reactor/reactor-core/commit/77571d3d5460e357466716e1befe0edb0e2bc31a", "message": "fixup hanging test", "committedDate": "2020-06-19T17:34:30Z", "type": "commit"}, {"oid": "a83b4deb91f552eb88973365a79edc95fa15e549", "url": "https://github.com/reactor/reactor-core/commit/a83b4deb91f552eb88973365a79edc95fa15e549", "message": "Switch from FluxProcessor<T,T> to FluxIdentityProcessor<T> in operators", "committedDate": "2020-06-19T17:50:32Z", "type": "commit"}]}