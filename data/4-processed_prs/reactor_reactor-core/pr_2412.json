{"pr_number": 2412, "pr_title": "Fix concurrent terminal signal detection in `SerializedManySink`", "pr_createdAt": "2020-10-02T15:23:07Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2412", "timeline": [{"oid": "bced94e098012b0a0180e17f6e4cff28742756ff", "url": "https://github.com/reactor/reactor-core/commit/bced94e098012b0a0180e17f6e4cff28742756ff", "message": "Fix onNext/termination race in `SerializedManySink`", "committedDate": "2020-10-02T15:22:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5MTE2Nw==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r498891167", "bodyText": "note to reviewers:\nlazy write should(?) be fine here because only the current thread really cares about the value", "author": "bsideup", "createdAt": "2020-10-02T15:25:10Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -78,16 +77,25 @@ public void emitComplete() {\n \n \t@Override\n \tpublic final Emission tryEmitComplete() {\n-\t\tif (done) {\n-\t\t\treturn Sinks.Emission.FAIL_TERMINATED;\n+\t\tThread currentTread = Thread.currentThread();\n+\t\tif (WIP.get(this) == 0 && WIP.compareAndSet(this, 0, 1)) {\n+\t\t\tLOCKED_AT.lazySet(this, currentTread);", "originalCommit": "bced94e098012b0a0180e17f6e4cff28742756ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2OTk0NQ==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r499469945", "bodyText": "as discussed offband, would actually benefit from a detailed comment because lazySet has subtle implications.\nthe winning thread A update could be invisible to thread B performing LOCKED_AT.get below, but that is ok as long as the conditional is != currentThread. What can happen at the get:\n\nthe A update is visible \u2705\nthe A update is not visible, null is seen so a FAIL is still triggered \u2705\nthe A update is not visible, C is seen (any other old winning thread) so a FAIL is still triggered \u2705\n\nBut having an outdated B value is not possible because to reach that point, since we're in thread B, it must have executed the compareAndSet which would have loaded the update from A.", "author": "simonbasle", "createdAt": "2020-10-05T09:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5MTE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5MjcwNw==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r498892707", "bodyText": "description should be onNext after onComplete", "author": "simonbasle", "createdAt": "2020-10-02T15:27:45Z", "path": "reactor-core/src/jcstress/java/reactor/core/publisher/SerializedManySinkStressTest.java", "diffHunk": "@@ -63,12 +63,38 @@ public void arbiter(LLI_Result r) {\n \t\t}\n \t}\n \n+\t@JCStressTest\n+\t@Outcome(id = {\"OK, FAIL_NON_SERIALIZED, 0\"}, expect = ACCEPTABLE, desc = \"onNext wins\")\n+\t@Outcome(id = {\"FAIL_NON_SERIALIZED, OK, 1\"}, expect = ACCEPTABLE, desc = \"onComplete wins\")\n+\t@Outcome(id = {\"FAIL_TERMINATED, OK, 1\"}, expect = ACCEPTABLE, desc = \"onNext after onComplete\")\n+\t@Outcome(id = {\"OK, OK, 1\"}, expect = ACCEPTABLE, desc = \"onComplete after onComplete\")", "originalCommit": "bced94e098012b0a0180e17f6e4cff28742756ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NDI4MA==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r498894280", "bodyText": "the sink is always Scannable so Scannable.from(sink) could be turned into sink as a polish", "author": "simonbasle", "createdAt": "2020-10-02T15:30:25Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -164,35 +179,31 @@ public void emitNext(T value) {\n \t@Override\n \tpublic final Emission tryEmitNext(T t) {\n \t\tObjects.requireNonNull(t, \"t is null in sink.next(t)\");\n-\t\tif (done) {\n-\t\t\treturn Sinks.Emission.FAIL_TERMINATED;\n+\n+\t\tThread currentTread = Thread.currentThread();\n+\t\tif (WIP.get(this) == 0 && WIP.compareAndSet(this, 0, 1)) {\n+\t\t\tLOCKED_AT.lazySet(this, currentTread);\n \t\t}\n-\t\tThread currentThread = Thread.currentThread();\n-\t\tThread lockedAt = LOCKED_AT.get(this);\n-\t\tif (lockedAt != null) {\n-\t\t\tif (lockedAt != currentThread) {\n+\t\telse {\n+\t\t\tif (LOCKED_AT.get(this) != currentTread) {\n \t\t\t\treturn Emission.FAIL_NON_SERIALIZED;\n \t\t\t}\n-\t\t}\n-\t\telse if (!LOCKED_AT.compareAndSet(this, null, currentThread)) {\n-\t\t\treturn Emission.FAIL_NON_SERIALIZED;\n+\t\t\tWIP.incrementAndGet(this);\n \t\t}\n \n-\t\tEmission emission = sink.tryEmitNext(t);\n-\t\tLOCKED_AT.compareAndSet(this, currentThread, null);\n-\t\treturn emission;\n+\t\ttry {\n+\t\t\treturn sink.tryEmitNext(t);\n+\t\t}\n+\t\tfinally {\n+\t\t\tif (WIP.decrementAndGet(this) == 0) {\n+\t\t\t\tLOCKED_AT.compareAndSet(this, currentTread, null);\n+\t\t\t}\n+\t\t}\n \t}\n \n \t@Override\n \t@Nullable\n \tpublic Object scanUnsafe(Attr key) {\n-\t\tif (key == Attr.ERROR) {\n-\t\t\treturn error;\n-\t\t}\n-\t\tif (key == Attr.TERMINATED) {\n-\t\t\treturn done;\n-\t\t}\n-\n \t\treturn Scannable.from(sink).scanUnsafe(key);", "originalCommit": "bced94e098012b0a0180e17f6e4cff28742756ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NjAzMA==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r498896030", "bodyText": "I know I said that one wasn't probably useful offband, but while reviewing I thought about one benefit: it allows a more meaningful error code to be returned before checking for unsynchronized access: we can relax on the serialized access condition if we know that the sink is terminated anyway (since fail fast to FAIL_TERMINATED wouldn't result in any spec violation downstream).", "author": "simonbasle", "createdAt": "2020-10-02T15:33:29Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -34,18 +35,16 @@\n \tfinal Many<T>       sink;\n \tfinal ContextHolder contextHolder;\n \n-\tvolatile     Throwable                                                  error;\n+\tvolatile int wip;\n \t@SuppressWarnings(\"rawtypes\")\n-\tstatic final AtomicReferenceFieldUpdater<SerializedManySink, Throwable> ERROR =\n-\t\t\tAtomicReferenceFieldUpdater.newUpdater(SerializedManySink.class, Throwable.class, \"error\");\n+\tstatic final AtomicIntegerFieldUpdater<SerializedManySink> WIP =\n+\t\t\tAtomicIntegerFieldUpdater.newUpdater(SerializedManySink.class, \"wip\");\n \n \tvolatile Thread lockedAt;\n \t@SuppressWarnings(\"rawtypes\")\n \tstatic final AtomicReferenceFieldUpdater<SerializedManySink, Thread> LOCKED_AT =\n \t\t\tAtomicReferenceFieldUpdater.newUpdater(SerializedManySink.class, Thread.class, \"lockedAt\");\n \n-\tvolatile boolean done;", "originalCommit": "bced94e098012b0a0180e17f6e4cff28742756ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1MDY5NQ==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r499450695", "bodyText": "We could, but I had a feeling that it overcomplicates the implementation and preferred to stick to as trivial implementation as possible. Also, failing fast would hide the fact of a non-serialized access that is very racy and should ideally be detected ASAP with an increased chance of being triggered from tests. WDYT?", "author": "bsideup", "createdAt": "2020-10-05T09:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NjAzMA=="}], "type": "inlineReview"}, {"oid": "c7194f71071273690d3bbbd31316946178ee3193", "url": "https://github.com/reactor/reactor-core/commit/c7194f71071273690d3bbbd31316946178ee3193", "message": "Review fixes", "committedDate": "2020-10-05T09:09:53Z", "type": "commit"}, {"oid": "a470fbdd1f4cb27dcaae34aa40d3aaa35e877649", "url": "https://github.com/reactor/reactor-core/commit/a470fbdd1f4cb27dcaae34aa40d3aaa35e877649", "message": "extract `tryAcquire`, add a comment on `lazySet`", "committedDate": "2020-10-05T09:41:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ3ODIyOA==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r499478228", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t// lazySet here, because:\n          \n          \n            \n            \t\t\t// 1. initial state is `null`\n          \n          \n            \n            \t\t\t// 2. `LOCKED_AT.get(this) != currentThread` from the next branch will either see null or an outdated old thread\n          \n          \n            \n            \t\t\t// 3. The only possibility to make the condition pass is to read it from the current thread that already has the value cached\n          \n          \n            \n            \t\t\t// lazySet in thread A here is ok because:\n          \n          \n            \n            \t\t\t// 1. initial state is `null`\n          \n          \n            \n            \t\t\t// 2. `LOCKED_AT.get(this) != currentThread` from a different thread B could see outdated null or an outdated old thread\n          \n          \n            \n            \t\t\t// 3. but that old thread cannot be B: since we're in thread B, it must have executed the compareAndSet which would have loaded the update from A\n          \n          \n            \n            \t\t\t// 4. Seeing `null` or `C` is equivalent from seeing `A` from the perspective of the condition (`!= currentThread` is still true in all three cases)", "author": "simonbasle", "createdAt": "2020-10-05T09:53:38Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -180,27 +168,38 @@ public void emitNext(T value) {\n \tpublic final Emission tryEmitNext(T t) {\n \t\tObjects.requireNonNull(t, \"t is null in sink.next(t)\");\n \n-\t\tThread currentTread = Thread.currentThread();\n-\t\tif (WIP.get(this) == 0 && WIP.compareAndSet(this, 0, 1)) {\n-\t\t\tLOCKED_AT.lazySet(this, currentTread);\n-\t\t}\n-\t\telse {\n-\t\t\tif (LOCKED_AT.get(this) != currentTread) {\n-\t\t\t\treturn Emission.FAIL_NON_SERIALIZED;\n-\t\t\t}\n-\t\t\tWIP.incrementAndGet(this);\n+\t\tThread currentThread = Thread.currentThread();\n+\t\tif (!tryAcquire(currentThread)) {\n+\t\t\treturn Emission.FAIL_NON_SERIALIZED;\n \t\t}\n \n \t\ttry {\n \t\t\treturn sink.tryEmitNext(t);\n \t\t}\n \t\tfinally {\n \t\t\tif (WIP.decrementAndGet(this) == 0) {\n-\t\t\t\tLOCKED_AT.compareAndSet(this, currentTread, null);\n+\t\t\t\tLOCKED_AT.compareAndSet(this, currentThread, null);\n \t\t\t}\n \t\t}\n \t}\n \n+\tprivate boolean tryAcquire(Thread currentThread) {\n+\t\tif (WIP.get(this) == 0 && WIP.compareAndSet(this, 0, 1)) {\n+\t\t\t// lazySet here, because:\n+\t\t\t// 1. initial state is `null`\n+\t\t\t// 2. `LOCKED_AT.get(this) != currentThread` from the next branch will either see null or an outdated old thread\n+\t\t\t// 3. The only possibility to make the condition pass is to read it from the current thread that already has the value cached", "originalCommit": "a470fbdd1f4cb27dcaae34aa40d3aaa35e877649", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6cb6e571c36cf91f315254b1fb4a403fa3312298", "url": "https://github.com/reactor/reactor-core/commit/6cb6e571c36cf91f315254b1fb4a403fa3312298", "message": "update the comment", "committedDate": "2020-10-05T10:09:44Z", "type": "commit"}]}