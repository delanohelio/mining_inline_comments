{"pr_number": 2202, "pr_title": "Allow \"0\" prefetch value in `concatMap`", "pr_createdAt": "2020-06-18T15:40:27Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2202", "timeline": [{"oid": "a38ffcc8dc8fadd0937a8256496f5fdbb87fd792", "url": "https://github.com/reactor/reactor-core/commit/a38ffcc8dc8fadd0937a8256496f5fdbb87fd792", "message": "Allow \"0\" prefetch value in `concatMap`", "committedDate": "2020-06-18T15:36:14Z", "type": "commit"}, {"oid": "3cc49e762e75f3cea608ea0d2702232c1af29369", "url": "https://github.com/reactor/reactor-core/commit/3cc49e762e75f3cea608ea0d2702232c1af29369", "message": "Try to fix the build file", "committedDate": "2020-06-18T16:55:50Z", "type": "commit"}, {"oid": "e565a244f56eef68e50b38c2e4f2f324563064e1", "url": "https://github.com/reactor/reactor-core/commit/e565a244f56eef68e50b38c2e4f2f324563064e1", "message": "Add discard/drop", "committedDate": "2020-06-25T09:58:19Z", "type": "commit"}, {"oid": "0dda46d64bc03677a6a9fddaded4da6d3d10a4a2", "url": "https://github.com/reactor/reactor-core/commit/0dda46d64bc03677a6a9fddaded4da6d3d10a4a2", "message": "fix japicmp Gradle task", "committedDate": "2020-06-25T10:06:12Z", "type": "commit"}, {"oid": "33dd747b7d7ae919b99eecb7594444c7febb818b", "url": "https://github.com/reactor/reactor-core/commit/33dd747b7d7ae919b99eecb7594444c7febb818b", "message": "remove `finalizedBy`", "committedDate": "2020-06-25T10:51:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ2NjA0OQ==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445466049", "bodyText": "can be removed, this is not an historical operator from RSC", "author": "simonbasle", "createdAt": "2020-06-25T10:38:22Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see <a href=\"https://github.com/reactor/reactive-streams-commons\">Reactive-Streams-Commons</a>", "originalCommit": "0dda46d64bc03677a6a9fddaded4da6d3d10a4a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ2Njc2NQ==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445466765", "bodyText": "intentional blank line?", "author": "simonbasle", "createdAt": "2020-06-25T10:39:58Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see <a href=\"https://github.com/reactor/reactive-streams-commons\">Reactive-Streams-Commons</a>\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new FluxConcatMapNoPrefetchSubscriber<>(actual, mapper);\n+\t}\n+\n+\tstatic final class FluxConcatMapNoPrefetchSubscriber<T, R> implements FluxConcatMapSupport<T, R> {\n+\n+\t\tenum State {\n+\t\t\tINITIAL,\n+", "originalCommit": "0dda46d64bc03677a6a9fddaded4da6d3d10a4a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ3MzcxMg==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445473712", "bodyText": "Even if it is redundant, I would consider using State.ACTIVE in the compareAndSet instead of previousState. I find it slightly easier to grok when just scanning the CAS", "author": "simonbasle", "createdAt": "2020-06-25T10:54:15Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see <a href=\"https://github.com/reactor/reactive-streams-commons\">Reactive-Streams-Commons</a>\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new FluxConcatMapNoPrefetchSubscriber<>(actual, mapper);\n+\t}\n+\n+\tstatic final class FluxConcatMapNoPrefetchSubscriber<T, R> implements FluxConcatMapSupport<T, R> {\n+\n+\t\tenum State {\n+\t\t\tINITIAL,\n+\n+\t\t\tREQUESTED,\n+\t\t\tACTIVE,\n+\t\t\tLAST_ACTIVE,\n+\t\t\tTERMINATED,\n+\t\t\tCANCELED,\n+\t\t}\n+\n+\t\tvolatile State state;\n+\n+\t\t@SuppressWarnings(\"rawtypes\")\n+\t\tstatic final AtomicReferenceFieldUpdater<FluxConcatMapNoPrefetchSubscriber, State> STATE = AtomicReferenceFieldUpdater.newUpdater(\n+\t\t\t\tFluxConcatMapNoPrefetchSubscriber.class,\n+\t\t\t\tState.class,\n+\t\t\t\t\"state\"\n+\t\t);\n+\n+\t\tfinal CoreSubscriber<? super R> actual;\n+\n+\t\tfinal ConcatMapInner<R> inner;\n+\n+\t\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\t\tSubscription upstream;\n+\n+\t\tFluxConcatMapNoPrefetchSubscriber(\n+\t\t\t\tCoreSubscriber<? super R> actual,\n+\t\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t\t) {\n+\t\t\tthis.actual = actual;\n+\t\t\tthis.mapper = mapper;\n+\t\t\tthis.inner = new ConcatMapInner<>(this);\n+\t\t\tSTATE.lazySet(this, State.INITIAL);\n+\t\t}\n+\n+\t\t@Override\n+\t\t@Nullable\n+\t\tpublic Object scanUnsafe(Attr key) {\n+\t\t\tif (key == Attr.PARENT) return upstream;\n+\t\t\tif (key == Attr.TERMINATED) return state == State.TERMINATED;\n+\t\t\tif (key == Attr.CANCELLED) return state == State.CANCELED;\n+\n+\t\t\treturn FluxConcatMapSupport.super.scanUnsafe(key);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic CoreSubscriber<? super R> actual() {\n+\t\t\treturn actual;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onSubscribe(Subscription s) {\n+\t\t\tif (Operators.validate(this.upstream, s)) {\n+\t\t\t\tthis.upstream = s;\n+\n+\t\t\t\tactual.onSubscribe(this);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onNext(T t) {\n+\t\t\tif (!STATE.compareAndSet(this, State.REQUESTED, State.ACTIVE)) {\n+\t\t\t\tswitch (state) {\n+\t\t\t\t\tcase CANCELED:\n+\t\t\t\t\t\tOperators.onDiscard(t, currentContext());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase TERMINATED:\n+\t\t\t\t\t\tOperators.onNextDropped(t, currentContext());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tPublisher<? extends R> p = mapper.apply(t);\n+\t\t\t\tObjects.requireNonNull(p, \"The mapper returned a null Publisher\");\n+\n+\t\t\t\tif (p instanceof Callable) {\n+\t\t\t\t\tCallable<R> callable = (Callable<R>) p;\n+\n+\t\t\t\t\tR result = callable.call();\n+\t\t\t\t\tif (result == null) {\n+\t\t\t\t\t\tinnerComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (inner.isUnbounded()) {\n+\t\t\t\t\t\tactual.onNext(result);\n+\t\t\t\t\t\tinnerComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tinner.set(new WeakScalarSubscription<>(result, inner));\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tp.subscribe(inner);\n+\t\t\t}\n+\t\t\tcatch (Throwable e) {\n+\t\t\t\tContext ctx = actual.currentContext();\n+\t\t\t\tOperators.onDiscard(t, ctx);\n+\n+\t\t\t\tThrowable e_ = Operators.onNextError(t, e, ctx, upstream);\n+\t\t\t\tif (e_ == null) {\n+\t\t\t\t\tinnerComplete();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tSTATE.lazySet(this, State.TERMINATED);\n+\t\t\t\tactual.onError(Operators.onOperatorError(upstream, e, t, ctx));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onError(Throwable t) {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase CANCELED:\n+\t\t\t\t\tcase TERMINATED:\n+\t\t\t\t\t\tOperators.onErrorDropped(t, currentContext());\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tinner.cancel();\n+\t\t\t\t\t\tsynchronized (this) {\n+\t\t\t\t\t\t\tactual.onError(t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onComplete() {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase INITIAL:\n+\t\t\t\t\tcase REQUESTED:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tactual.onComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tcase ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.LAST_ACTIVE)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic synchronized void innerNext(R value) {\n+\t\t\tswitch (state) {\n+\t\t\t\tcase ACTIVE:\n+\t\t\t\tcase LAST_ACTIVE:\n+\t\t\t\t\tactual.onNext(value);\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void innerComplete() {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {", "originalCommit": "0dda46d64bc03677a6a9fddaded4da6d3d10a4a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MjM4OA==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445482388", "bodyText": "(this generally applies to CAS in that class)", "author": "simonbasle", "createdAt": "2020-06-25T11:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ3MzcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5MjU1Mg==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445492552", "bodyText": "I thought about doing it, but then realized that it is not copy/paste friendly and we may slip some bugs due to it.\nWhen reviewing, having to check previousState IMO is actually better, because it forces you to double check that we're in the correct case branch. Otherwise imagine accidentally approving something like:\nswitch (previousState) {\n\tcase ACTIVE:\n\t\tif (!STATE.compareAndSet(this, ACTIVE, State.REQUESTED)) {\n\t\t\tcontinue;\n\t\t}\n\t\tupstream.request(1);\n\t\treturn;\n\tcase LAST_ACTIVE:\n\t\tif (!STATE.compareAndSet(this, ACTIVE, State.TERMINATED)) {\n\t\t\tcontinue;\n\t\t}\n\t\tactual.onComplete();\n\t\treturn;\n\tdefault:\n\t\treturn;\n}\nif not covered with tests (hehe :D), we will ship a potentially infinite loop to production, and the cost of such mistake would be high", "author": "bsideup", "createdAt": "2020-06-25T11:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ3MzcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0NDE4Mg==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445544182", "bodyText": "ok, that makes sense as well. let's keep it that way then.", "author": "simonbasle", "createdAt": "2020-06-25T13:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ3MzcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MDM3Mw==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445480373", "bodyText": "here I think it is worth it detailing the behavior in a comment:\n\nthe fact that obviously the only time a downstream request directly results in an upstream request is the first time\ndetail of what happens when request(10) is done but the inner only serves eg. 3 elements (3 inner next will be tracked as produced by the ConcatMapInner, then inner onComplete will update the requested tracker, then innerComplete will transition to REQUESTED state and request one more source, swap the subscription and request the 7 remaining demand)", "author": "simonbasle", "createdAt": "2020-06-25T11:08:29Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see <a href=\"https://github.com/reactor/reactive-streams-commons\">Reactive-Streams-Commons</a>\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new FluxConcatMapNoPrefetchSubscriber<>(actual, mapper);\n+\t}\n+\n+\tstatic final class FluxConcatMapNoPrefetchSubscriber<T, R> implements FluxConcatMapSupport<T, R> {\n+\n+\t\tenum State {\n+\t\t\tINITIAL,\n+\n+\t\t\tREQUESTED,\n+\t\t\tACTIVE,\n+\t\t\tLAST_ACTIVE,\n+\t\t\tTERMINATED,\n+\t\t\tCANCELED,\n+\t\t}\n+\n+\t\tvolatile State state;\n+\n+\t\t@SuppressWarnings(\"rawtypes\")\n+\t\tstatic final AtomicReferenceFieldUpdater<FluxConcatMapNoPrefetchSubscriber, State> STATE = AtomicReferenceFieldUpdater.newUpdater(\n+\t\t\t\tFluxConcatMapNoPrefetchSubscriber.class,\n+\t\t\t\tState.class,\n+\t\t\t\t\"state\"\n+\t\t);\n+\n+\t\tfinal CoreSubscriber<? super R> actual;\n+\n+\t\tfinal ConcatMapInner<R> inner;\n+\n+\t\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\t\tSubscription upstream;\n+\n+\t\tFluxConcatMapNoPrefetchSubscriber(\n+\t\t\t\tCoreSubscriber<? super R> actual,\n+\t\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t\t) {\n+\t\t\tthis.actual = actual;\n+\t\t\tthis.mapper = mapper;\n+\t\t\tthis.inner = new ConcatMapInner<>(this);\n+\t\t\tSTATE.lazySet(this, State.INITIAL);\n+\t\t}\n+\n+\t\t@Override\n+\t\t@Nullable\n+\t\tpublic Object scanUnsafe(Attr key) {\n+\t\t\tif (key == Attr.PARENT) return upstream;\n+\t\t\tif (key == Attr.TERMINATED) return state == State.TERMINATED;\n+\t\t\tif (key == Attr.CANCELLED) return state == State.CANCELED;\n+\n+\t\t\treturn FluxConcatMapSupport.super.scanUnsafe(key);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic CoreSubscriber<? super R> actual() {\n+\t\t\treturn actual;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onSubscribe(Subscription s) {\n+\t\t\tif (Operators.validate(this.upstream, s)) {\n+\t\t\t\tthis.upstream = s;\n+\n+\t\t\t\tactual.onSubscribe(this);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onNext(T t) {\n+\t\t\tif (!STATE.compareAndSet(this, State.REQUESTED, State.ACTIVE)) {\n+\t\t\t\tswitch (state) {\n+\t\t\t\t\tcase CANCELED:\n+\t\t\t\t\t\tOperators.onDiscard(t, currentContext());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase TERMINATED:\n+\t\t\t\t\t\tOperators.onNextDropped(t, currentContext());\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tPublisher<? extends R> p = mapper.apply(t);\n+\t\t\t\tObjects.requireNonNull(p, \"The mapper returned a null Publisher\");\n+\n+\t\t\t\tif (p instanceof Callable) {\n+\t\t\t\t\tCallable<R> callable = (Callable<R>) p;\n+\n+\t\t\t\t\tR result = callable.call();\n+\t\t\t\t\tif (result == null) {\n+\t\t\t\t\t\tinnerComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (inner.isUnbounded()) {\n+\t\t\t\t\t\tactual.onNext(result);\n+\t\t\t\t\t\tinnerComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tinner.set(new WeakScalarSubscription<>(result, inner));\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tp.subscribe(inner);\n+\t\t\t}\n+\t\t\tcatch (Throwable e) {\n+\t\t\t\tContext ctx = actual.currentContext();\n+\t\t\t\tOperators.onDiscard(t, ctx);\n+\n+\t\t\t\tThrowable e_ = Operators.onNextError(t, e, ctx, upstream);\n+\t\t\t\tif (e_ == null) {\n+\t\t\t\t\tinnerComplete();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tSTATE.lazySet(this, State.TERMINATED);\n+\t\t\t\tactual.onError(Operators.onOperatorError(upstream, e, t, ctx));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onError(Throwable t) {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase CANCELED:\n+\t\t\t\t\tcase TERMINATED:\n+\t\t\t\t\t\tOperators.onErrorDropped(t, currentContext());\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tinner.cancel();\n+\t\t\t\t\t\tsynchronized (this) {\n+\t\t\t\t\t\t\tactual.onError(t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onComplete() {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase INITIAL:\n+\t\t\t\t\tcase REQUESTED:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tactual.onComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tcase ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.LAST_ACTIVE)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic synchronized void innerNext(R value) {\n+\t\t\tswitch (state) {\n+\t\t\t\tcase ACTIVE:\n+\t\t\t\tcase LAST_ACTIVE:\n+\t\t\t\t\tactual.onNext(value);\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void innerComplete() {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.REQUESTED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tupstream.request(1);\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tcase LAST_ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tactual.onComplete();\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void innerError(Throwable e) {\n+\t\t\tfor (State previousState = this.state; ; previousState = this.state) {\n+\t\t\t\tswitch (previousState) {\n+\t\t\t\t\tcase ACTIVE:\n+\t\t\t\t\tcase LAST_ACTIVE:\n+\t\t\t\t\t\tif (!STATE.compareAndSet(this, previousState, State.TERMINATED)) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tupstream.cancel();\n+\t\t\t\t\t\tinner.cancel();\n+\t\t\t\t\t\tactual.onError(e);\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tOperators.onErrorDropped(e, currentContext());\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void request(long n) {\n+\t\t\tif (STATE.compareAndSet(this, State.INITIAL, State.REQUESTED)) {", "originalCommit": "33dd747b7d7ae919b99eecb7594444c7febb818b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MDYxNw==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445480617", "bodyText": "(this is absolutely not necessary, but after reviewing that was the one spot I had to double back over)", "author": "simonbasle", "createdAt": "2020-06-25T11:09:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MDM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MTYwNQ==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445481605", "bodyText": "would it make sense to have additional tests for the concrete class in a separate test case, on top of that one (which tests the API goes down the FluxConcatMapNoPrefetch path I guess) and the stress test ? There might not be much left to test other than the Scannable, that said, but still... this test can actually be done in the separate test class as well.", "author": "simonbasle", "createdAt": "2020-06-25T11:11:11Z", "path": "reactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java", "diffHunk": "@@ -1226,4 +1227,46 @@ public void discardDelayedOnDrainMapperError() {\n \t\t            .verifyThenAssertThat()\n \t\t            .hasDiscardedExactly(1);\n \t}\n+\n+\t@Test\n+\tpublic void noRequestBeforeOnCompleteWithZeroPrefetch() {", "originalCommit": "33dd747b7d7ae919b99eecb7594444c7febb818b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5NDI0Mw==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445494243", "bodyText": "I actually ran (locally) FluxConcatMapTest with *NoPrefetch (by adding prefetch == 0 || true to Flux.java) and it passed all but the prefetch ones.\nGlad that you asked, because I wanted to discuss the testing approach here. We could reuse the same set of tests by replacing every .concatMap with .as(this.concatMap(...)). This will be a massive change in this PR but IMO worth it. WDYT?", "author": "bsideup", "createdAt": "2020-06-25T11:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MTYwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0NTMzMg==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445545332", "bodyText": "are you talking about mutualizing the test code, or duplicating the relevant tests? I would definitely agree on duplicating, but if reusing I'm expecting only a subset of the tests make sense for FluxConcatMapNoPrefetch?", "author": "simonbasle", "createdAt": "2020-06-25T13:09:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MTYwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0NjE1OA==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445546158", "bodyText": "or, actually, an easier way would be to make the prefetch in the test explicit... yes, I think that's the way to go :) Will do.", "author": "bsideup", "createdAt": "2020-06-25T13:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MTYwNQ=="}], "type": "inlineReview"}, {"oid": "160a95cdb5011a1d6eddd1b087147395d48ebca7", "url": "https://github.com/reactor/reactor-core/commit/160a95cdb5011a1d6eddd1b087147395d48ebca7", "message": "remove the RSC reference, drop the unnecessary empty line", "committedDate": "2020-06-25T11:40:07Z", "type": "commit"}, {"oid": "2f99b8e76eb50084d4ff532284a258fec6be320b", "url": "https://github.com/reactor/reactor-core/commit/2f99b8e76eb50084d4ff532284a258fec6be320b", "message": "Merge branch 'master' into zero_prefetch_concatMap\n\n# Conflicts:\n#\treactor-core/build.gradle\n#\treactor-test/build.gradle", "committedDate": "2020-06-25T12:56:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0MzU5OA==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445543598", "bodyText": "wait there's actually an inconsistency. your implementation seem to always delay errors, so it should be an overload of concatMapDelayErrors", "author": "simonbasle", "createdAt": "2020-06-25T13:07:11Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "diffHunk": "@@ -3663,13 +3663,16 @@ public final T blockLast(Duration timeout) {\n \t * @reactor.discard This operator discards elements it internally queued for backpressure upon cancellation.\n \t *\n \t * @param mapper the function to transform this sequence of T into concatenated sequences of V\n-\t * @param prefetch the inner source produced demand\n+\t * @param prefetch the inner source produced demand (set it to 0 if you don't want it to prefetch)\n \t * @param <V> the produced concatenated type\n \t *\n \t * @return a concatenated {@link Flux}\n \t */\n \tpublic final <V> Flux<V> concatMap(Function<? super T, ? extends Publisher<? extends V>>\n \t\t\tmapper, int prefetch) {\n+\t\tif (prefetch == 0) {", "originalCommit": "2f99b8e76eb50084d4ff532284a258fec6be320b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0NjQyNQ==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445546425", "bodyText": "Oh... nice catch! Thanks!", "author": "bsideup", "createdAt": "2020-06-25T13:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0MzU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk5MDU3MQ==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r446990571", "bodyText": "FYI should be fixed now", "author": "bsideup", "createdAt": "2020-06-29T13:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0MzU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0MzkxMA==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r445543910", "bodyText": "see comment on Flux relative to that second boolean (expectDelayErrors) being true.", "author": "simonbasle", "createdAt": "2020-06-25T13:07:39Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see FluxConcatMap\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {", "originalCommit": "2f99b8e76eb50084d4ff532284a258fec6be320b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMjUyNA==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r447032524", "bodyText": "the second boolean should be this.errorMode != ErrorMode.IMMEDIATE I think", "author": "simonbasle", "createdAt": "2020-06-29T14:52:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0MzkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1NDg1NA==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r447054854", "bodyText": "Seems to be hardcoded true here as well:\n\n  \n    \n      reactor-core/reactor-core/src/main/java/reactor/core/publisher/FluxConcatMap.java\n    \n    \n         Line 116\n      in\n      cb74c0c\n    \n    \n    \n    \n\n        \n          \n           if (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) { \n        \n    \n  \n\n\nSince the source is scalar, I guess it doesn't make a difference?", "author": "bsideup", "createdAt": "2020-06-29T15:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0MzkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2NzkxMw==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r447067913", "bodyText": "good point about the scalar nature \ud83d\udc4d", "author": "simonbasle", "createdAt": "2020-06-29T15:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0MzkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4MjU1Mg==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r446082552", "bodyText": "Could you document the transition diagram, or at least explain the states in more detail (in particular LAST_ACTIVE)?", "author": "ericbottard", "createdAt": "2020-06-26T09:45:49Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see FluxConcatMap\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new FluxConcatMapNoPrefetchSubscriber<>(actual, mapper);\n+\t}\n+\n+\tstatic final class FluxConcatMapNoPrefetchSubscriber<T, R> implements FluxConcatMapSupport<T, R> {\n+\n+\t\tenum State {", "originalCommit": "2f99b8e76eb50084d4ff532284a258fec6be320b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4OTcwMg==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r446089702", "bodyText": "Unless you have a good idea how to code it, I don't think doing a diagram is a good idea, since it may easily get outdated :(", "author": "bsideup", "createdAt": "2020-06-26T10:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4MjU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5NzQ3OQ==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r446097479", "bodyText": "I meant at least documenting what transitions make sense, and what each (non trivial) state represents. That said, I would argue that if we were to produce a diagram for comprehension's sake and it got outdated, there is indeed a problem :)", "author": "ericbottard", "createdAt": "2020-06-26T10:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4MjU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE3NTAxMA==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r446175010", "bodyText": "I believe that code is the best documentation especially when state transition is not that complicated and can be easily derived from the enums.", "author": "OlegDokuka", "createdAt": "2020-06-26T13:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4MjU1Mg=="}], "type": "inlineReview"}, {"oid": "042ff01ff09ef2952853d4227fc786454cc3a4fb", "url": "https://github.com/reactor/reactor-core/commit/042ff01ff09ef2952853d4227fc786454cc3a4fb", "message": "support `ErrorMode`", "committedDate": "2020-06-26T10:11:26Z", "type": "commit"}, {"oid": "aba5aa0950733c58cc1ac56bcefc22d52f5eb74c", "url": "https://github.com/reactor/reactor-core/commit/aba5aa0950733c58cc1ac56bcefc22d52f5eb74c", "message": "Extract `AbstractFluxConcatMapTest`", "committedDate": "2020-06-26T10:12:33Z", "type": "commit"}, {"oid": "76f9fefc15c95921e9a6b83895e09407c7e80721", "url": "https://github.com/reactor/reactor-core/commit/76f9fefc15c95921e9a6b83895e09407c7e80721", "message": "simplify error handling, document states", "committedDate": "2020-06-26T15:48:00Z", "type": "commit"}, {"oid": "669fcc954a1bc0d75351b3cf369abf0e6027c8cc", "url": "https://github.com/reactor/reactor-core/commit/669fcc954a1bc0d75351b3cf369abf0e6027c8cc", "message": "Merge branch 'master' into zero_prefetch_concatMap\n\n# Conflicts:\n#\treactor-core/src/test/java/reactor/core/publisher/FluxConcatMapTest.java", "committedDate": "2020-06-29T13:57:31Z", "type": "commit"}, {"oid": "2fcd373c4184ae6749ee5b5a7effa6e258487484", "url": "https://github.com/reactor/reactor-core/commit/2fcd373c4184ae6749ee5b5a7effa6e258487484", "message": "Remove `Schedulers.elastic()` usage", "committedDate": "2020-06-29T14:00:22Z", "type": "commit"}, {"oid": "8f57fa020f8fb635f4c2e5372970912561dc25d9", "url": "https://github.com/reactor/reactor-core/commit/8f57fa020f8fb635f4c2e5372970912561dc25d9", "message": "Fix the indentation in `build.gradle`", "committedDate": "2020-06-29T14:18:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMDc5Mw==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r447030793", "bodyText": "\ud83d\udc4d, please just mention this change in the body of the commit message", "author": "simonbasle", "createdAt": "2020-06-29T14:50:26Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Flux.java", "diffHunk": "@@ -472,10 +472,7 @@\n \t * @return a new {@link Flux} concatenating all inner sources sequences\n \t */\n \tpublic static <T> Flux<T> concat(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {\n-\t\treturn onAssembly(new FluxConcatMap<>(from(sources),\n-\t\t\t\tidentityFunction(),\n-\t\t\t\tQueues.get(prefetch), prefetch,\n-\t\t\t\tFluxConcatMap.ErrorMode.IMMEDIATE));\n+\t\treturn wrap(sources).concatMap(identityFunction(), prefetch);", "originalCommit": "8f57fa020f8fb635f4c2e5372970912561dc25d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMzgzNA==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r447033834", "bodyText": "Isn't it just another way of writing the same and completely \"internal\"? Or did I change the behaviour? \ud83d\ude31", "author": "bsideup", "createdAt": "2020-06-29T14:54:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMDc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3MDMzOA==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r447070338", "bodyText": "well, the wrap won't apply assembly hooks, but the concatMap will, so I think this is ok. it's just that the direct application of assembly hooks would have pointed tracebacks maybe a tiny bit more directly to concat (rather than having concatMap in the traceback), but I think that is ok.", "author": "simonbasle", "createdAt": "2020-06-29T15:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMDc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NDIzNA==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r447074234", "bodyText": "Oh, you're right! Actually, let's use from as it was before to avoid any side effects from this change. I will submit a separate PR that will use wrap where applicable and evaluate the impact without the rest of the concatMap changes, ok?", "author": "bsideup", "createdAt": "2020-06-29T15:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMDc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMTI0NA==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r447111244", "bodyText": "sounds good to me", "author": "simonbasle", "createdAt": "2020-06-29T16:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMDc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzNTMyOA==", "url": "https://github.com/reactor/reactor-core/pull/2202#discussion_r447035328", "bodyText": "a minor nitpick, and a departure from our usual choice of American English spelling over British English spelling, but we use CANCELLED in most places (all but one actually...), including the public Scannable.Attr.CANCELLED", "author": "simonbasle", "createdAt": "2020-06-29T14:56:22Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxConcatMapNoPrefetch.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.FluxConcatMap.ConcatMapInner;\n+import reactor.core.publisher.FluxConcatMap.ErrorMode;\n+import reactor.core.publisher.FluxConcatMap.FluxConcatMapSupport;\n+import reactor.core.publisher.FluxConcatMap.WeakScalarSubscription;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * Maps each upstream value into a Publisher and concatenates them into one\n+ * sequence of items.\n+ *\n+ * @param <T> the source value type\n+ * @param <R> the output value type\n+ *\n+ * @see FluxConcatMap\n+ */\n+final class FluxConcatMapNoPrefetch<T, R> extends InternalFluxOperator<T, R> {\n+\n+\tfinal Function<? super T, ? extends Publisher<? extends R>> mapper;\n+\n+\tfinal ErrorMode errorMode;\n+\n+\tFluxConcatMapNoPrefetch(\n+\t\t\tFlux<? extends T> source,\n+\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper,\n+\t\t\tErrorMode errorMode\n+\t) {\n+\t\tsuper(source);\n+\t\tthis.mapper = Objects.requireNonNull(mapper, \"mapper\");\n+\t\tthis.errorMode = errorMode;\n+\t}\n+\n+\t@Override\n+\tpublic CoreSubscriber<? super T> subscribeOrReturn(CoreSubscriber<? super R> actual) {\n+\t\tif (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, false, true)) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new FluxConcatMapNoPrefetchSubscriber<>(actual, mapper, errorMode);\n+\t}\n+\n+\tstatic final class FluxConcatMapNoPrefetchSubscriber<T, R> implements FluxConcatMapSupport<T, R> {\n+\n+\t\tenum State {\n+\t\t\tINITIAL,\n+\t\t\t/**\n+\t\t\t * Requested from {@link #upstream}, waiting for {@link #onNext(Object)}\n+\t\t\t */\n+\t\t\tREQUESTED,\n+\t\t\t/**\n+\t\t\t * {@link #onNext(Object)} received, listening on {@link #inner}\n+\t\t\t */\n+\t\t\tACTIVE,\n+\t\t\t/**\n+\t\t\t * Received outer {@link #onComplete()}, waiting for {@link #inner} to complete\n+\t\t\t */\n+\t\t\tLAST_ACTIVE,\n+\t\t\t/**\n+\t\t\t * Terminated either successfully or after an error\n+\t\t\t */\n+\t\t\tTERMINATED,\n+\t\t\tCANCELED,", "originalCommit": "8f57fa020f8fb635f4c2e5372970912561dc25d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3ec9518e593154af18962d86d6cf5930e0d5f544", "url": "https://github.com/reactor/reactor-core/commit/3ec9518e593154af18962d86d6cf5930e0d5f544", "message": "`CANCELED` -> `CANCELLED`", "committedDate": "2020-06-30T08:50:11Z", "type": "commit"}, {"oid": "cb587aa1d28ab1545308306203761f60f8f3c940", "url": "https://github.com/reactor/reactor-core/commit/cb587aa1d28ab1545308306203761f60f8f3c940", "message": "`wrap` -> `from`", "committedDate": "2020-06-30T08:51:19Z", "type": "commit"}]}