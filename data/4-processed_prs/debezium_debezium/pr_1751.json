{"pr_number": 1751, "pr_title": "DBZ-2338 Base WAL position detection on commit LSNs", "pr_createdAt": "2020-08-12T04:58:32Z", "pr_url": "https://github.com/debezium/debezium/pull/1751", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNjU1Mw==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469106553", "bodyText": "Wasn't DBZ-2200, also focused on the PG connector, intended to have a more abstract implementation in debezium-core that fits different connector needs? Something like SourceOffset<T extends Comparable> or something?", "author": "rk3rn3r", "createdAt": "2020-08-12T08:50:51Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/Lsn.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.postgresql.connection;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.postgresql.replication.LogSequenceNumber;\n+\n+/**\n+ * Abstraction of PostgreSQL log sequence number, adapted from\n+ * {@link org.postgresql.replication.LogSequenceNumber}.\n+ *\n+ * @author Jiri Pechanec\n+ *\n+ */\n+public class Lsn implements Comparable<Lsn> {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNDg5NA==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469134894", "bodyText": "No, at least that's not what I had in mind when logging this. This really was focused on having such Lsn type for PG instead of representing it with Long.", "author": "gunnarmorling", "createdAt": "2020-08-12T09:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNjU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MjM5NQ==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469142395", "bodyText": "I meant when we were talking about the task. At least that what I understood. Does it makes sense to have it in debezium-core?", "author": "rk3rn3r", "createdAt": "2020-08-12T09:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNjU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1MTU0Mw==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469151543", "bodyText": "It doesn't make sense to have Lsn in core, as it's PG-specific. I'm not sure whether one could finda more generic abstraction which still would be useful tbh. In any case I don't think it's something we need to concern ourselves with right now. When it comes to (simple-ish) refactorings, I'd suggest rather to look at https://issues.redhat.com/browse/DBZ-2420 (unification of JDBC connection props) or the filter handling unification.", "author": "gunnarmorling", "createdAt": "2020-08-12T10:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNjU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNjk5MQ==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469136991", "bodyText": "How about enabling Lsn#valueOf() itself to handle and return null?", "author": "gunnarmorling", "createdAt": "2020-08-12T09:41:54Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresOffsetContext.java", "diffHunk": "@@ -171,8 +171,10 @@ private Long readOptionalLong(Map<String, ?> offset, String key) {\n         @SuppressWarnings(\"unchecked\")\n         @Override\n         public OffsetContext load(Map<String, ?> offset) {\n-            final Long lsn = readOptionalLong(offset, SourceInfo.LSN_KEY);\n-            final Long lastCompletelyProcessedLsn = readOptionalLong(offset, LAST_COMPLETELY_PROCESSED_LSN_KEY);\n+            final Long lsnAsLong = readOptionalLong(offset, SourceInfo.LSN_KEY);\n+            final Lsn lsn = (lsnAsLong == null) ? null : Lsn.valueOf(lsnAsLong);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNzUzMA==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469137530", "bodyText": "Ok, I really hope we don't miss this somewhere.", "author": "gunnarmorling", "createdAt": "2020-08-12T09:42:47Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresSourceInfoStructMaker.java", "diffHunk": "@@ -45,7 +45,7 @@ public Struct struct(SourceInfo sourceInfo) {\n             result.put(SourceInfo.TXID_KEY, sourceInfo.txId());\n         }\n         if (sourceInfo.lsn() != null) {\n-            result.put(SourceInfo.LSN_KEY, sourceInfo.lsn());\n+            result.put(SourceInfo.LSN_KEY, sourceInfo.lsn().asLong());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzOTAxOQ==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469139019", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        assertNotEquals(\"lsn should not be flushed until heartbeat is produced\", serverLsn, flushLsn);\n          \n          \n            \n                        assertNotEquals(\"LSN should not be flushed until heartbeat is produced\", serverLsn, flushLsn);", "author": "gunnarmorling", "createdAt": "2020-08-12T09:45:16Z", "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -1235,9 +1236,9 @@ public void shouldReceiveHeartbeatAlsoWhenChangingNonWhitelistedTable() throws E\n \n             // check if client's lsn is not flushed yet\n             SlotState slotState = postgresConnection.getReplicationSlotState(Builder.DEFAULT_SLOT_NAME, TestHelper.decoderPlugin().getPostgresPluginName());\n-            long flushLsn = slotState.slotLastFlushedLsn();\n+            final Lsn flushLsn = slotState.slotLastFlushedLsn();\n             // serverLsn is the latest server lsn and is equal to insert statement lsn\n-            long serverLsn = postgresConnection.currentXLogLocation();\n+            final Lsn serverLsn = Lsn.valueOf(postgresConnection.currentXLogLocation());\n             assertNotEquals(\"lsn should not be flushed until heartbeat is produced\", serverLsn, flushLsn);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzOTA4Mw==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469139083", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        assertTrue(\"lsn should be flushed when heartbeat is produced\", flushedLsn.compareTo(serverLsn) >= 0);\n          \n          \n            \n                        assertTrue(\"LSN should be flushed when heartbeat is produced\", flushedLsn.compareTo(serverLsn) >= 0);", "author": "gunnarmorling", "createdAt": "2020-08-12T09:45:25Z", "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -1254,8 +1255,8 @@ public void shouldReceiveHeartbeatAlsoWhenChangingNonWhitelistedTable() throws E\n \n             // check if flushed lsn is equal to or greater than server lsn\n             SlotState slotStateAfterHeartbeat = postgresConnection.getReplicationSlotState(Builder.DEFAULT_SLOT_NAME, TestHelper.decoderPlugin().getPostgresPluginName());\n-            long flushedLsn = slotStateAfterHeartbeat.slotLastFlushedLsn();\n-            assertTrue(\"lsn should be flushed when heartbeat is produced\", flushedLsn >= serverLsn);\n+            final Lsn flushedLsn = slotStateAfterHeartbeat.slotLastFlushedLsn();\n+            assertTrue(\"lsn should be flushed when heartbeat is produced\", flushedLsn.compareTo(serverLsn) >= 0);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzOTI1Mg==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469139252", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    AtomicReference<Lsn> lastReceivedLSN = new AtomicReference<>();\n          \n          \n            \n                    AtomicReference<Lsn> lastReceivedLsn = new AtomicReference<>();", "author": "gunnarmorling", "createdAt": "2020-08-12T09:45:42Z", "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/connection/ReplicationConnectionIT.java", "diffHunk": "@@ -180,9 +180,9 @@ public void shouldReceiveMissedChangesWhileDown() throws Exception {\n     @Test\n     public void shouldResumeFromLastReceivedLSN() throws Exception {\n         String slotName = \"test\";\n-        AtomicLong lastReceivedLSN = new AtomicLong(0);\n-        startInsertStop(slotName, stream -> lastReceivedLSN.compareAndSet(0, stream.lastReceivedLsn()));\n-        assertTrue(lastReceivedLSN.get() > 0);\n+        AtomicReference<Lsn> lastReceivedLSN = new AtomicReference<>();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "99560bc6312576426607690bebb17ca81b5dae0f", "url": "https://github.com/debezium/debezium/commit/99560bc6312576426607690bebb17ca81b5dae0f", "message": "DBZ-2200 Introduce LLSN domain type", "committedDate": "2020-08-21T12:30:55Z", "type": "commit"}, {"oid": "d5d96d20e6b584ed90e0bf010563723a517470c4", "url": "https://github.com/debezium/debezium/commit/d5d96d20e6b584ed90e0bf010563723a517470c4", "message": "DBZ-2338 Base WAL position detection on commit LSNs", "committedDate": "2020-08-21T12:32:53Z", "type": "commit"}, {"oid": "3eb98ca18ace191f46ddc4796b413833c86a0ef9", "url": "https://github.com/debezium/debezium/commit/3eb98ca18ace191f46ddc4796b413833c86a0ef9", "message": "DBZ-2338 Support for pgoutput", "committedDate": "2020-08-21T12:32:53Z", "type": "commit"}, {"oid": "3e478a5da54f3fdbd4b42297201e4519878280f3", "url": "https://github.com/debezium/debezium/commit/3e478a5da54f3fdbd4b42297201e4519878280f3", "message": "DBZ-2338 Minor corrections\n\nCo-authored-by: Gunnar Morling <gunnar.morling@googlemail.com>", "committedDate": "2020-08-21T12:32:53Z", "type": "commit"}, {"oid": "9c7c9c2aad3061efeb4859844b1ef49f59cf3f98", "url": "https://github.com/debezium/debezium/commit/9c7c9c2aad3061efeb4859844b1ef49f59cf3f98", "message": "DBZ-2397 Test for restart in tx", "committedDate": "2020-08-21T12:32:53Z", "type": "commit"}, {"oid": "c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "url": "https://github.com/debezium/debezium/commit/c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "message": "DBZ-2338 Skip initial statements on reconnect", "committedDate": "2020-08-21T13:13:16Z", "type": "commit"}, {"oid": "c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "url": "https://github.com/debezium/debezium/commit/c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "message": "DBZ-2338 Skip initial statements on reconnect", "committedDate": "2020-08-21T13:13:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjA4Nw==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475256087", "bodyText": "Why does keepalive need to be disabled to commit the current transaction?  Asking because PostgresTaskContext#refreshSchema called on https://github.com/debezium/debezium/pull/1751/files#diff-dff0ff397d3f72ba1319e51a37ace1adL118 here performs a commit but does not disable keepalive.", "author": "grantcooksey", "createdAt": "2020-08-23T19:31:20Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -96,103 +97,45 @@ public void execute(ChangeEventSourceContext context) throws InterruptedExceptio\n         }\n \n         try {\n+            final WalPositionLocator walPosition;\n             if (hasStartLsnStoredInContext) {\n                 // start streaming from the last recorded position in the offset\n-                final Long lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n-                if (LOGGER.isDebugEnabled()) {\n-                    LOGGER.debug(\"retrieved latest position from stored offset '{}'\", ReplicationConnection.format(lsn));\n-                }\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn));\n+                final Lsn lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n+                LOGGER.info(\"Retrieved latest position from stored offset '{}'\", lsn);\n+                walPosition = new WalPositionLocator(offsetContext.lastCommitLsn(), lsn);\n+                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn, walPosition));\n             }\n             else {\n-                LOGGER.info(\"no previous LSN found in Kafka, streaming from the latest xlogpos or flushed LSN...\");\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming());\n+                LOGGER.info(\"No previous LSN found in Kafka, streaming from the latest xlogpos or flushed LSN...\");\n+                walPosition = new WalPositionLocator();\n+                replicationStream.compareAndSet(null, replicationConnection.startStreaming(walPosition));\n             }\n             // for large dbs, the refresh of schema can take too much time\n             // such that the connection times out. We must enable keep\n             // alive to ensure that it doesn't time out\n-            final ReplicationStream stream = this.replicationStream.get();\n+            ReplicationStream stream = this.replicationStream.get();\n             stream.startKeepAlive(Executors.newSingleThreadExecutor());\n \n             // refresh the schema so we have a latest view of the DB tables\n             taskContext.refreshSchema(connection, true);\n \n             this.lastCompletelyProcessedLsn = replicationStream.get().startLsn();\n \n-            int noMessageIterations = 0;\n-            while (context.isRunning()) {\n-\n-                boolean receivedMessage = stream.readPending(message -> {\n-                    final Long lsn = stream.lastReceivedLsn();\n-\n-                    if (message.isLastEventForLsn()) {\n-                        lastCompletelyProcessedLsn = lsn;\n-                    }\n-\n-                    // Tx BEGIN/END event\n-                    if (message.isTransactionalMessage()) {\n-                        if (!connectorConfig.shouldProvideTransactionMetadata()) {\n-                            LOGGER.trace(\"Received transactional message {}\", message);\n-                            // Don't skip on BEGIN message as it would flush LSN for the whole transaction\n-                            // too early\n-                            if (message.getOperation() == Operation.COMMIT) {\n-                                skipMessage(lsn);\n-                            }\n-                            return;\n-                        }\n-\n-                        offsetContext.updateWalPosition(lsn, lastCompletelyProcessedLsn, message.getCommitTime(), message.getTransactionId(), null,\n-                                taskContext.getSlotXmin(connection));\n-                        if (message.getOperation() == Operation.BEGIN) {\n-                            dispatcher.dispatchTransactionStartedEvent(Long.toString(message.getTransactionId()), offsetContext);\n-                        }\n-                        else if (message.getOperation() == Operation.COMMIT) {\n-                            dispatcher.dispatchTransactionCommittedEvent(offsetContext);\n-                        }\n-                        maybeWarnAboutGrowingWalBacklog(true);\n-                        return;\n-                    }\n-                    // DML event\n-                    else {\n-                        TableId tableId = null;\n-                        if (message.getOperation() != Operation.NOOP) {\n-                            tableId = PostgresSchema.parse(message.getTable());\n-                            Objects.requireNonNull(tableId);\n-                        }\n-\n-                        offsetContext.updateWalPosition(lsn, lastCompletelyProcessedLsn, message.getCommitTime(), message.getTransactionId(), tableId,\n-                                taskContext.getSlotXmin(connection));\n-\n-                        boolean dispatched = (message.getOperation() == Operation.NOOP) ? false\n-                                : dispatcher.dispatchDataChangeEvent(\n-                                        tableId,\n-                                        new PostgresChangeRecordEmitter(\n-                                                offsetContext,\n-                                                clock,\n-                                                connectorConfig,\n-                                                schema,\n-                                                connection,\n-                                                message));\n-\n-                        maybeWarnAboutGrowingWalBacklog(dispatched);\n-                    }\n-                });\n-\n-                if (receivedMessage) {\n-                    noMessageIterations = 0;\n+            if (walPosition.searchingEnabled()) {\n+                searchWalPosition(context, stream, walPosition);\n+                stream.stopKeepAlive();", "originalCommit": "c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMzNDkwMQ==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475334901", "bodyText": "Hi, in this case it is not due to the commit but due to the reconnect that is few lines later down", "author": "jpechane", "createdAt": "2020-08-24T04:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjA4Nw=="}], "type": "inlineReview"}, {"oid": "1af7eb1d8f850218bfcdfe949cd84824636d01f8", "url": "https://github.com/debezium/debezium/commit/1af7eb1d8f850218bfcdfe949cd84824636d01f8", "message": "DBZ-2338 Log exception; restart keepalive", "committedDate": "2020-08-24T04:34:29Z", "type": "commit"}, {"oid": "4f91d032459c2bb24126d361c84432a8f349948c", "url": "https://github.com/debezium/debezium/commit/4f91d032459c2bb24126d361c84432a8f349948c", "message": "DBZ-2338 Flush LSNs on tx boundaries", "committedDate": "2020-08-24T05:17:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5NDUyNA==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475594524", "bodyText": "Was changing the log level of this from debug to info intentional?", "author": "Naros", "createdAt": "2020-08-24T13:21:09Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -96,103 +97,46 @@ public void execute(ChangeEventSourceContext context) throws InterruptedExceptio\n         }\n \n         try {\n+            final WalPositionLocator walPosition;\n             if (hasStartLsnStoredInContext) {\n                 // start streaming from the last recorded position in the offset\n-                final Long lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n-                if (LOGGER.isDebugEnabled()) {\n-                    LOGGER.debug(\"retrieved latest position from stored offset '{}'\", ReplicationConnection.format(lsn));\n-                }\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn));\n+                final Lsn lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n+                LOGGER.info(\"Retrieved latest position from stored offset '{}'\", lsn);", "originalCommit": "4f91d032459c2bb24126d361c84432a8f349948c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5OTI4NQ==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475599285", "bodyText": "Would it be possible to use queryAndMap here in order to avoid the AtomicReference usage?", "author": "Naros", "createdAt": "2020-08-24T13:28:48Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -219,7 +218,7 @@ protected void initReplicationSlot() throws SQLException, InterruptedException {\n                 this.createReplicationSlot();\n             }\n \n-            AtomicLong xlogStart = new AtomicLong();\n+            final AtomicReference<Lsn> xlogStart = new AtomicReference<>();", "originalCommit": "4f91d032459c2bb24126d361c84432a8f349948c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxNTk4NA==", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475815984", "bodyText": "Done, thanks!", "author": "jpechane", "createdAt": "2020-08-24T18:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5OTI4NQ=="}], "type": "inlineReview"}, {"oid": "99b8375a200f422d680c5aca540f0c030432cb94", "url": "https://github.com/debezium/debezium/commit/99b8375a200f422d680c5aca540f0c030432cb94", "message": "DBZ-2338 Atomic is not necessary", "committedDate": "2020-08-24T18:33:57Z", "type": "commit"}]}