{"pr_number": 1921, "pr_title": "DBZ-2704 Fix test failure - PostgresConnectorIT#shouldRegularlyFlushLsnWithTxMonitoring", "pr_createdAt": "2020-10-29T17:18:55Z", "pr_url": "https://github.com/debezium/debezium/pull/1921", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4MDI3Mg==", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r514980272", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                if (!actualRecords.keySet().contains(record.topic())) {\n          \n          \n            \n                                                if (!actualRecords.containsKey(record.topic())) {", "author": "gunnarmorling", "createdAt": "2020-10-30T09:49:53Z", "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/PostgresConnectorIT.java", "diffHunk": "@@ -1094,9 +1097,33 @@ public void shouldRegularlyFlushLsnWithTxMonitoring() throws InterruptedExceptio\n             for (int i = 2; i <= recordCount + 2; i++) {\n                 TestHelper.execute(INSERT_STMT);\n \n-                final SourceRecords actualRecords = consumeRecordsByTopic(3);\n-                assertThat(actualRecords.topics().size()).isEqualTo(2);\n-                assertThat(actualRecords.recordsForTopic(topicName(\"s1.a\")).size()).isEqualTo(1);\n+                final Map<String, List<SourceRecord>> actualRecords = new HashMap<>();\n+                try {\n+                    Awaitility.await()\n+                            .atMost(5 * TestHelper.waitTimeForRecords(), TimeUnit.SECONDS)\n+                            .until(() -> {\n+                                // consume all available records\n+                                List<SourceRecord> records = new LinkedList<>();\n+                                consumeAvailableRecords(records::add);\n+\n+                                // capture all topics\n+                                for (SourceRecord record : records) {\n+                                    if (!actualRecords.keySet().contains(record.topic())) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480", "url": "https://github.com/debezium/debezium/commit/c8f0bd9dd67acc3bde0f1c39f812c0d675e16480", "message": "DBZ-2704 Fix test failure - PostgresConnectorIT#shouldRegularlyFlushLsnWithTxMonitoring", "committedDate": "2020-11-02T16:54:18Z", "type": "commit"}, {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480", "url": "https://github.com/debezium/debezium/commit/c8f0bd9dd67acc3bde0f1c39f812c0d675e16480", "message": "DBZ-2704 Fix test failure - PostgresConnectorIT#shouldRegularlyFlushLsnWithTxMonitoring", "committedDate": "2020-11-02T16:54:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzMTA5MA==", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r516431090", "bodyText": "SHould not the assert call isTransactionRecord method instead of chekcing the topic name?", "author": "jpechane", "createdAt": "2020-11-03T05:11:06Z", "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "diffHunk": "@@ -640,6 +781,13 @@ protected void assertNoRecordsToConsume() {\n         assertThat(consumedLines.isEmpty()).isTrue();\n     }\n \n+    /**\n+     * Assert that there are only transaction topic records to be consumed.\n+     */\n+    protected void assertOnlyTransactionRecordsToConsume() {\n+        consumedLines.iterator().forEachRemaining(r -> assertThat(r.topic()).endsWith(\".transaction\"));", "originalCommit": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNTEyOQ==", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r516435129", "bodyText": "Even if it is not strictly necessary I'd prefer to process even the incoming tx BEGIN to ensure symmetry between BEGIN/END messages.", "author": "jpechane", "createdAt": "2020-11-03T05:30:51Z", "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "diffHunk": "@@ -500,6 +503,144 @@ protected SourceRecords consumeRecordsByTopic(int numRecords, boolean assertReco\n         return records;\n     }\n \n+    /**\n+     * Try to consume and capture exactly the specified number of Dml records from the connector.\n+     *\n+     * While transaction metadata topic records are captured by this method, the {@code numDmlRecords} should not\n+     * include the expected number of records emitted to the transaction topic.\n+     *\n+     * @param numDmlRecords the number of Dml records that should be consumed\n+     * @return the collector to which the records were captured; never null\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected SourceRecords consumeDmlRecordsByTopic(int numDmlRecords) throws InterruptedException {\n+        SourceRecords records = new SourceRecords();\n+        consumeDmlRecordsByTopic(numDmlRecords, records::add);\n+        return records;\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     * For slower connectors it is possible to receive no records form the connector at most 3 times in a row\n+     * till the waiting is terminated.\n+     *\n+     * @param numberDmlRecords the number of Dml records that should be consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberDmlRecords, Consumer<SourceRecord> recordConsumer) throws InterruptedException {\n+        return consumeDmlRecordsByTopic(numberDmlRecords, 3, recordConsumer, true);\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     *\n+     * For slower connectors it is possible to receive no records from the connector at most 3 times in a row\n+     * until the waiting is terminated.  Additionally, while this method will consume and append transaction metadata\n+     * topic records to the consumer, the returned value only considers Dml records.\n+     *\n+     * @param numberOfRecords the number of Dml records that should be consumed\n+     * @param breakAfterNulls the number of allowed run when no records are consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @param assertRecords true if records serialization should be verified\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberOfRecords, int breakAfterNulls, Consumer<SourceRecord> recordConsumer, boolean assertRecords)\n+            throws InterruptedException {\n+        int recordsConsumed = 0;\n+        int nullReturn = 0;\n+        Set<String> endTransactions = new LinkedHashSet<>();\n+        while (recordsConsumed < numberOfRecords) {\n+            SourceRecord record = consumedLines.poll(pollTimeoutInMs, TimeUnit.MILLISECONDS);\n+            if (record != null) {\n+                nullReturn = 0;\n+                if (isTransactionRecord(record)) {\n+                    final Struct value = (Struct) record.value();\n+                    final String status = value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_STATUS_KEY);\n+                    if (status.equals(TransactionStatus.BEGIN.name())) {\n+                        endTransactions.add(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                    else {\n+                        endTransactions.remove(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                }\n+                else {\n+                    ++recordsConsumed;\n+                }\n+                if (recordConsumer != null) {\n+                    recordConsumer.accept(record);\n+                }\n+                if (Testing.Debug.isEnabled()) {\n+                    Testing.debug(\"Consumed record \" + recordsConsumed + \" / \" + numberOfRecords + \" (\"\n+                            + (numberOfRecords - recordsConsumed) + \" more)\");\n+                    debug(record);\n+                }\n+                else if (Testing.Print.isEnabled()) {\n+                    Testing.print(\"Consumed record \" + recordsConsumed + \" / \" + numberOfRecords + \" (\"\n+                            + (numberOfRecords - recordsConsumed) + \" more)\");\n+                    print(record);\n+                }\n+                if (assertRecords) {\n+                    VerifyRecord.isValid(record);\n+                }\n+            }\n+            else {\n+                if (++nullReturn >= breakAfterNulls) {\n+                    return recordsConsumed;\n+                }\n+            }\n+        }\n+\n+        while (!endTransactions.isEmpty()) {\n+            SourceRecord record = consumedLines.poll(pollTimeoutInMs, TimeUnit.MILLISECONDS);\n+            if (record != null) {\n+                nullReturn = 0;\n+                if (isTransactionRecord(record)) {\n+                    final Struct value = (Struct) record.value();\n+                    final String status = value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_STATUS_KEY);\n+                    if (status.equals(TransactionStatus.END.name())) {", "originalCommit": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNTI4NQ==", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r516435285", "bodyText": "Could the log messages here and down contain also information about endTransactions?", "author": "jpechane", "createdAt": "2020-11-03T05:31:41Z", "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "diffHunk": "@@ -500,6 +503,144 @@ protected SourceRecords consumeRecordsByTopic(int numRecords, boolean assertReco\n         return records;\n     }\n \n+    /**\n+     * Try to consume and capture exactly the specified number of Dml records from the connector.\n+     *\n+     * While transaction metadata topic records are captured by this method, the {@code numDmlRecords} should not\n+     * include the expected number of records emitted to the transaction topic.\n+     *\n+     * @param numDmlRecords the number of Dml records that should be consumed\n+     * @return the collector to which the records were captured; never null\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected SourceRecords consumeDmlRecordsByTopic(int numDmlRecords) throws InterruptedException {\n+        SourceRecords records = new SourceRecords();\n+        consumeDmlRecordsByTopic(numDmlRecords, records::add);\n+        return records;\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     * For slower connectors it is possible to receive no records form the connector at most 3 times in a row\n+     * till the waiting is terminated.\n+     *\n+     * @param numberDmlRecords the number of Dml records that should be consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberDmlRecords, Consumer<SourceRecord> recordConsumer) throws InterruptedException {\n+        return consumeDmlRecordsByTopic(numberDmlRecords, 3, recordConsumer, true);\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     *\n+     * For slower connectors it is possible to receive no records from the connector at most 3 times in a row\n+     * until the waiting is terminated.  Additionally, while this method will consume and append transaction metadata\n+     * topic records to the consumer, the returned value only considers Dml records.\n+     *\n+     * @param numberOfRecords the number of Dml records that should be consumed\n+     * @param breakAfterNulls the number of allowed run when no records are consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @param assertRecords true if records serialization should be verified\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberOfRecords, int breakAfterNulls, Consumer<SourceRecord> recordConsumer, boolean assertRecords)\n+            throws InterruptedException {\n+        int recordsConsumed = 0;\n+        int nullReturn = 0;\n+        Set<String> endTransactions = new LinkedHashSet<>();\n+        while (recordsConsumed < numberOfRecords) {\n+            SourceRecord record = consumedLines.poll(pollTimeoutInMs, TimeUnit.MILLISECONDS);\n+            if (record != null) {\n+                nullReturn = 0;\n+                if (isTransactionRecord(record)) {\n+                    final Struct value = (Struct) record.value();\n+                    final String status = value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_STATUS_KEY);\n+                    if (status.equals(TransactionStatus.BEGIN.name())) {\n+                        endTransactions.add(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                    else {\n+                        endTransactions.remove(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                }\n+                else {\n+                    ++recordsConsumed;\n+                }\n+                if (recordConsumer != null) {\n+                    recordConsumer.accept(record);\n+                }\n+                if (Testing.Debug.isEnabled()) {\n+                    Testing.debug(\"Consumed record \" + recordsConsumed + \" / \" + numberOfRecords + \" (\"", "originalCommit": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNTUwOA==", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r516435508", "bodyText": "Here it would be great to assert that the DML message txId is present in endTransactions", "author": "jpechane", "createdAt": "2020-11-03T05:32:47Z", "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "diffHunk": "@@ -500,6 +503,144 @@ protected SourceRecords consumeRecordsByTopic(int numRecords, boolean assertReco\n         return records;\n     }\n \n+    /**\n+     * Try to consume and capture exactly the specified number of Dml records from the connector.\n+     *\n+     * While transaction metadata topic records are captured by this method, the {@code numDmlRecords} should not\n+     * include the expected number of records emitted to the transaction topic.\n+     *\n+     * @param numDmlRecords the number of Dml records that should be consumed\n+     * @return the collector to which the records were captured; never null\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected SourceRecords consumeDmlRecordsByTopic(int numDmlRecords) throws InterruptedException {\n+        SourceRecords records = new SourceRecords();\n+        consumeDmlRecordsByTopic(numDmlRecords, records::add);\n+        return records;\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     * For slower connectors it is possible to receive no records form the connector at most 3 times in a row\n+     * till the waiting is terminated.\n+     *\n+     * @param numberDmlRecords the number of Dml records that should be consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberDmlRecords, Consumer<SourceRecord> recordConsumer) throws InterruptedException {\n+        return consumeDmlRecordsByTopic(numberDmlRecords, 3, recordConsumer, true);\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     *\n+     * For slower connectors it is possible to receive no records from the connector at most 3 times in a row\n+     * until the waiting is terminated.  Additionally, while this method will consume and append transaction metadata\n+     * topic records to the consumer, the returned value only considers Dml records.\n+     *\n+     * @param numberOfRecords the number of Dml records that should be consumed\n+     * @param breakAfterNulls the number of allowed run when no records are consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @param assertRecords true if records serialization should be verified\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberOfRecords, int breakAfterNulls, Consumer<SourceRecord> recordConsumer, boolean assertRecords)\n+            throws InterruptedException {\n+        int recordsConsumed = 0;\n+        int nullReturn = 0;\n+        Set<String> endTransactions = new LinkedHashSet<>();\n+        while (recordsConsumed < numberOfRecords) {\n+            SourceRecord record = consumedLines.poll(pollTimeoutInMs, TimeUnit.MILLISECONDS);\n+            if (record != null) {\n+                nullReturn = 0;\n+                if (isTransactionRecord(record)) {\n+                    final Struct value = (Struct) record.value();\n+                    final String status = value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_STATUS_KEY);\n+                    if (status.equals(TransactionStatus.BEGIN.name())) {\n+                        endTransactions.add(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                    else {\n+                        endTransactions.remove(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                }\n+                else {\n+                    ++recordsConsumed;", "originalCommit": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2b06f02525ecb451e6a9a96845c349b2e883a256", "url": "https://github.com/debezium/debezium/commit/2b06f02525ecb451e6a9a96845c349b2e883a256", "message": "DBZ-2704 Suggested fixes", "committedDate": "2020-11-03T17:12:46Z", "type": "commit"}]}