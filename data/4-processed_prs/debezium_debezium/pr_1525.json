{"pr_number": 1525, "pr_title": "DBZ-1813 Restrict the set of tables with a publication when using pgoutput", "pr_createdAt": "2020-05-21T14:40:16Z", "pr_url": "https://github.com/debezium/debezium/pull/1525", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMjM3NA==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r429302374", "bodyText": "Actually it's whitelist + blacklist together. Perhaps \"filter\" or \"filtered\"?", "author": "gunnarmorling", "createdAt": "2020-05-22T15:06:30Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresConnectorConfig.java", "diffHunk": "@@ -592,6 +592,84 @@ public static SchemaRefreshMode parse(String value) {\n             .withDescription(\"The name of the Postgres 10+ publication used for streaming changes from a plugin.\" +\n                     \"Defaults to '\" + ReplicationConnection.Builder.DEFAULT_PUBLICATION_NAME + \"'\");\n \n+    public enum AutoCreateMode implements EnumeratedValue {\n+        /**\n+         * No Publication will be created, it's expected the user\n+         * has already created the publication.\n+         */\n+        DISABLED(\"disabled\"),\n+        /**\n+         * Enable publication for all tables.\n+         */\n+        ALL_TABLES(\"all_tables\"),\n+        /**\n+         * Enable publication on a specific set of tables.\n+         */\n+        WHITELIST(\"whitelist\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ0MjUxOA==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r429442518", "bodyText": "yeah filtered makes the most sense I think given the desired behaviour", "author": "brbrown25", "createdAt": "2020-05-22T20:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMjM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNTEzNA==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r429305134", "bodyText": "This needs to consider also the table blacklist as well as database blacklist/whitelist. I suppose this was always an implicit assumption on my end during the conversations, sorry for not being more clear on that. You can take a look at RelationalSnapshotChangeEventSource.determineCapturedTables(RelationalSnapshotContext) to see how that's handled during snapshotting using the TableFilter contract.", "author": "gunnarmorling", "createdAt": "2020-05-22T15:11:48Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresTaskContext.java", "diffHunk": "@@ -111,6 +111,8 @@ protected ReplicationConnection createReplicationConnection(boolean exportSnapsh\n         return ReplicationConnection.builder(config.jdbcConfig())\n                 .withSlot(config.slotName())\n                 .withPublication(config.publicationName())\n+                .withTableWhitelist(config.tableWhitelist())", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNTU1NQ==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r429305555", "bodyText": "As per above, this probably should receive TableFilter instead.", "author": "gunnarmorling", "createdAt": "2020-05-22T15:12:36Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/ReplicationConnection.java", "diffHunk": "@@ -133,6 +133,24 @@ static String format(long lsn) {\n          */\n         Builder withPublication(final String publicationName);\n \n+        /**\n+         * Sets the publication tables to watch for the PG logical publication\n+         *\n+         * @param tableWhitelist the tables the publication is subscribed to, may not be null.\n+         * @return this instance\n+         * @see #config.tableWhitelist()\n+         */\n+        Builder withTableWhitelist(final String tableWhitelist);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5MTkwNg==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433791906", "bodyText": "What's the purpose of this sorting step?", "author": "gunnarmorling", "createdAt": "2020-06-02T10:59:59Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -117,38 +136,97 @@ private PostgresReplicationConnection(Configuration config,\n \n     protected void initPublication() {\n         if (PostgresConnectorConfig.LogicalDecoder.PGOUTPUT.equals(plugin)) {\n-            LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n-            try {\n-                String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n-                try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n-                    if (rs.next()) {\n-                        Long count = rs.getLong(1);\n-                        if (count == 0L) {\n-                            LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n-                            // Publication doesn't exist, create it.\n-                            // todo: DBZ-766 - Change this to be restricted based on configured whitelist tables?\n-                            // For situations where no publication exists, we likely cannot create it for all tables.\n-                            // This is because postgres requires certain super user permissions to use \"ALL TABLES\".\n-                            // We should restrict this to the configured tables here.\n-                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n-                        }\n-                        else {\n-                            LOGGER.trace(\n-                                    \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n-                                            \"and will be used by the plugin\",\n-                                    publicationName, plugin, database());\n+            if (PostgresConnectorConfig.AutoCreateMode.DISABLED.equals(publicationAutocreateMode)) {\n+                throw new ConnectException(\"Publication autocreation is disabled, please create one and restart the connector.\");\n+            }\n+            else {\n+                LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n+                try {\n+                    String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n+                    try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n+                        if (rs.next()) {\n+                            Long count = rs.getLong(1);\n+                            if (count == 0L) {\n+                                LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n+                                switch (publicationAutocreateMode) {\n+                                    case ALL_TABLES:\n+                                        // Publication doesn't exist, create it.\n+                                        stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n+                                        break;\n+                                    case FILTERED:\n+                                        try {\n+                                            Set<TableId> tablesToCapture = determineCapturedTables(new RelationalSnapshotChangeEventSource.RelationalSnapshotContext(\"\"));\n+                                            String tableFilterString = tablesToCapture.stream().map(TableId::toDoubleQuotedString).collect(Collectors.joining(\", \"));\n+                                            // Publication doesn't exist, create it but restrict to the tableFilter.\n+                                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR TABLE %s;\", publicationName, tableFilterString));\n+                                        }\n+                                        catch (Exception e) {\n+                                            LOGGER.error(\"Unable to create publication for \");\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            else {\n+                                LOGGER.trace(\n+                                        \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n+                                                \"and will be used by the plugin\",\n+                                        publicationName, plugin, database());\n+                            }\n                         }\n                     }\n                 }\n+                catch (SQLException e) {\n+                    throw new JdbcConnectionException(e);\n+                }\n+\n+                // This is what ties the publication definition to the replication stream\n+                streamParams.put(\"proto_version\", 1);\n+                streamParams.put(\"publication_names\", publicationName);\n             }\n-            catch (SQLException e) {\n-                throw new JdbcConnectionException(e);\n-            }\n+        }\n+    }\n+\n+    private Stream<TableId> toTableIds(Set<TableId> tableIds, Pattern pattern) {\n+        return tableIds\n+                .stream()\n+                .filter(tid -> pattern.asPredicate().test(tid.toString()))\n+                .sorted();\n+    }\n+\n+    private Set<TableId> sort(Set<TableId> capturedTables) throws Exception {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3MzgyNQ==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433873825", "bodyText": "So this was taken from the the RelationalSnapshotChangeEventSource.determineCapturedTables(RelationalSnapshotContext) so I copied that over for consistency", "author": "brbrown25", "createdAt": "2020-06-02T13:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5MTkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2NzIzOA==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433867238", "bodyText": "Shouldn't this be handled further below, in the swich block? It seems we'd trigger this exception in case the publication already exists?", "author": "gunnarmorling", "createdAt": "2020-06-02T13:18:32Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -117,38 +136,97 @@ private PostgresReplicationConnection(Configuration config,\n \n     protected void initPublication() {\n         if (PostgresConnectorConfig.LogicalDecoder.PGOUTPUT.equals(plugin)) {\n-            LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n-            try {\n-                String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n-                try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n-                    if (rs.next()) {\n-                        Long count = rs.getLong(1);\n-                        if (count == 0L) {\n-                            LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n-                            // Publication doesn't exist, create it.\n-                            // todo: DBZ-766 - Change this to be restricted based on configured whitelist tables?\n-                            // For situations where no publication exists, we likely cannot create it for all tables.\n-                            // This is because postgres requires certain super user permissions to use \"ALL TABLES\".\n-                            // We should restrict this to the configured tables here.\n-                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n-                        }\n-                        else {\n-                            LOGGER.trace(\n-                                    \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n-                                            \"and will be used by the plugin\",\n-                                    publicationName, plugin, database());\n+            if (PostgresConnectorConfig.AutoCreateMode.DISABLED.equals(publicationAutocreateMode)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3NTYwMA==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433875600", "bodyText": "I went for a failing early approach, but I can see the argument for moving it into the switch, now that I look at it, that seems like a better place for it!", "author": "brbrown25", "createdAt": "2020-06-02T13:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2NzIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2ODA4MQ==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433868081", "bodyText": "The name is a bit misleading, perhaps simply filter()?", "author": "gunnarmorling", "createdAt": "2020-06-02T13:19:48Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -117,38 +136,97 @@ private PostgresReplicationConnection(Configuration config,\n \n     protected void initPublication() {\n         if (PostgresConnectorConfig.LogicalDecoder.PGOUTPUT.equals(plugin)) {\n-            LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n-            try {\n-                String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n-                try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n-                    if (rs.next()) {\n-                        Long count = rs.getLong(1);\n-                        if (count == 0L) {\n-                            LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n-                            // Publication doesn't exist, create it.\n-                            // todo: DBZ-766 - Change this to be restricted based on configured whitelist tables?\n-                            // For situations where no publication exists, we likely cannot create it for all tables.\n-                            // This is because postgres requires certain super user permissions to use \"ALL TABLES\".\n-                            // We should restrict this to the configured tables here.\n-                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n-                        }\n-                        else {\n-                            LOGGER.trace(\n-                                    \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n-                                            \"and will be used by the plugin\",\n-                                    publicationName, plugin, database());\n+            if (PostgresConnectorConfig.AutoCreateMode.DISABLED.equals(publicationAutocreateMode)) {\n+                throw new ConnectException(\"Publication autocreation is disabled, please create one and restart the connector.\");\n+            }\n+            else {\n+                LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n+                try {\n+                    String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n+                    try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n+                        if (rs.next()) {\n+                            Long count = rs.getLong(1);\n+                            if (count == 0L) {\n+                                LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n+                                switch (publicationAutocreateMode) {\n+                                    case ALL_TABLES:\n+                                        // Publication doesn't exist, create it.\n+                                        stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n+                                        break;\n+                                    case FILTERED:\n+                                        try {\n+                                            Set<TableId> tablesToCapture = determineCapturedTables(new RelationalSnapshotChangeEventSource.RelationalSnapshotContext(\"\"));\n+                                            String tableFilterString = tablesToCapture.stream().map(TableId::toDoubleQuotedString).collect(Collectors.joining(\", \"));\n+                                            // Publication doesn't exist, create it but restrict to the tableFilter.\n+                                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR TABLE %s;\", publicationName, tableFilterString));\n+                                        }\n+                                        catch (Exception e) {\n+                                            LOGGER.error(\"Unable to create publication for \");\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            else {\n+                                LOGGER.trace(\n+                                        \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n+                                                \"and will be used by the plugin\",\n+                                        publicationName, plugin, database());\n+                            }\n                         }\n                     }\n                 }\n+                catch (SQLException e) {\n+                    throw new JdbcConnectionException(e);\n+                }\n+\n+                // This is what ties the publication definition to the replication stream\n+                streamParams.put(\"proto_version\", 1);\n+                streamParams.put(\"publication_names\", publicationName);\n             }\n-            catch (SQLException e) {\n-                throw new JdbcConnectionException(e);\n-            }\n+        }\n+    }\n+\n+    private Stream<TableId> toTableIds(Set<TableId> tableIds, Pattern pattern) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3NDc4NQ==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433874785", "bodyText": "yeah this was copied from the RelationalSnapshotChangeEventSource.determineCapturedTables(RelationalSnapshotContext)", "author": "brbrown25", "createdAt": "2020-06-02T13:29:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2ODA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2ODIwMw==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433868203", "bodyText": "Why is the context parameter needed here?", "author": "gunnarmorling", "createdAt": "2020-06-02T13:19:59Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -117,38 +136,97 @@ private PostgresReplicationConnection(Configuration config,\n \n     protected void initPublication() {\n         if (PostgresConnectorConfig.LogicalDecoder.PGOUTPUT.equals(plugin)) {\n-            LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n-            try {\n-                String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n-                try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n-                    if (rs.next()) {\n-                        Long count = rs.getLong(1);\n-                        if (count == 0L) {\n-                            LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n-                            // Publication doesn't exist, create it.\n-                            // todo: DBZ-766 - Change this to be restricted based on configured whitelist tables?\n-                            // For situations where no publication exists, we likely cannot create it for all tables.\n-                            // This is because postgres requires certain super user permissions to use \"ALL TABLES\".\n-                            // We should restrict this to the configured tables here.\n-                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n-                        }\n-                        else {\n-                            LOGGER.trace(\n-                                    \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n-                                            \"and will be used by the plugin\",\n-                                    publicationName, plugin, database());\n+            if (PostgresConnectorConfig.AutoCreateMode.DISABLED.equals(publicationAutocreateMode)) {\n+                throw new ConnectException(\"Publication autocreation is disabled, please create one and restart the connector.\");\n+            }\n+            else {\n+                LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n+                try {\n+                    String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n+                    try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n+                        if (rs.next()) {\n+                            Long count = rs.getLong(1);\n+                            if (count == 0L) {\n+                                LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n+                                switch (publicationAutocreateMode) {\n+                                    case ALL_TABLES:\n+                                        // Publication doesn't exist, create it.\n+                                        stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n+                                        break;\n+                                    case FILTERED:\n+                                        try {\n+                                            Set<TableId> tablesToCapture = determineCapturedTables(new RelationalSnapshotChangeEventSource.RelationalSnapshotContext(\"\"));\n+                                            String tableFilterString = tablesToCapture.stream().map(TableId::toDoubleQuotedString).collect(Collectors.joining(\", \"));\n+                                            // Publication doesn't exist, create it but restrict to the tableFilter.\n+                                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR TABLE %s;\", publicationName, tableFilterString));\n+                                        }\n+                                        catch (Exception e) {\n+                                            LOGGER.error(\"Unable to create publication for \");\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            else {\n+                                LOGGER.trace(\n+                                        \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n+                                                \"and will be used by the plugin\",\n+                                        publicationName, plugin, database());\n+                            }\n                         }\n                     }\n                 }\n+                catch (SQLException e) {\n+                    throw new JdbcConnectionException(e);\n+                }\n+\n+                // This is what ties the publication definition to the replication stream\n+                streamParams.put(\"proto_version\", 1);\n+                streamParams.put(\"publication_names\", publicationName);\n             }\n-            catch (SQLException e) {\n-                throw new JdbcConnectionException(e);\n-            }\n+        }\n+    }\n+\n+    private Stream<TableId> toTableIds(Set<TableId> tableIds, Pattern pattern) {\n+        return tableIds\n+                .stream()\n+                .filter(tid -> pattern.asPredicate().test(tid.toString()))\n+                .sorted();\n+    }\n+\n+    private Set<TableId> sort(Set<TableId> capturedTables) throws Exception {\n+        String value = config().getString(RelationalDatabaseConnectorConfig.TABLE_WHITELIST);\n+        if (value != null) {\n+            return Strings.listOfRegex(value, Pattern.CASE_INSENSITIVE)\n+                    .stream()\n+                    .flatMap(pattern -> toTableIds(capturedTables, pattern))\n+                    .collect(Collectors.toCollection(LinkedHashSet::new));\n+        }\n+        return capturedTables\n+                .stream()\n+                .sorted()\n+                .collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n+    private Set<TableId> determineCapturedTables(RelationalSnapshotChangeEventSource.RelationalSnapshotContext ctx) throws Exception {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3NjY4Nw==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433876687", "bodyText": "that's the part where I wasn;t really sure the best way of using the table filter contract. since based on RelationalSnapshotChangeEventSource.determineCapturedTables(RelationalSnapshotContext) it appears that is needs to know all the tables and then iterate through and build up a list of TableIds that match", "author": "brbrown25", "createdAt": "2020-06-02T13:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2ODIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk5OTMzNw==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433999337", "bodyText": "actually I may have just figure out how that works...should have  some updates later today! thanks so much for helping me through on this!", "author": "brbrown25", "createdAt": "2020-06-02T16:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2ODIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3MDc0OA==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433870748", "bodyText": "Would be better to avoid those formatting changes. The formatter will flag/revert them anyways, and if it doesn't, it adds some unneccessary noise to the PR.", "author": "gunnarmorling", "createdAt": "2020-06-02T13:23:37Z", "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/PostgresConnectorIT.java", "diffHunk": "@@ -218,8 +219,7 @@ public void shouldSupportSSLParameters() throws Exception {\n         });\n         if (TestHelper.shouldSSLConnectionFail()) {\n             assertConnectorNotRunning();\n-        }\n-        else {\n+        } else {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3NDA5OQ==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433874099", "bodyText": "Hey @brbrown25, a few comments inline. Overall I think it's going into the right direction. Having a test which asserts some events from a filtered publication would be nice to have, too. Plus, the new option should be added to the connector docs. As a heads-up, we'll do the next 1.2 release mid next week. Looks like we could have this wrapped up by then?\nThanks a lot!\n\nYeah I think we can have it wrapped up by then!", "author": "brbrown25", "createdAt": "2020-06-02T13:28:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3MDc0OA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MjIyMA==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434682220", "bodyText": "There seems to be missing something after \"for\". More importantly, though, did you consciously decide to not propagate that exception? I think it'd be better to just let it bubble up (wrapped in a ConnectException with some contextual information), thus stopping connector start-up.", "author": "gunnarmorling", "createdAt": "2020-06-03T16:03:55Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -125,12 +144,29 @@ protected void initPublication() {\n                         Long count = rs.getLong(1);\n                         if (count == 0L) {\n                             LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n-                            // Publication doesn't exist, create it.\n-                            // todo: DBZ-766 - Change this to be restricted based on configured whitelist tables?\n-                            // For situations where no publication exists, we likely cannot create it for all tables.\n-                            // This is because postgres requires certain super user permissions to use \"ALL TABLES\".\n-                            // We should restrict this to the configured tables here.\n-                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n+                            switch (publicationAutocreateMode) {\n+                                case DISABLED:\n+                                    throw new ConnectException(\"Publication autocreation is disabled, please create one and restart the connector.\");\n+                                case ALL_TABLES:\n+                                    createPublicationStmt = String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName);\n+                                    LOGGER.info(\"Creating Publication with statement '{}'\", createPublicationStmt);\n+                                    // Publication doesn't exist, create it.\n+                                    stmt.execute(createPublicationStmt);\n+                                    break;\n+                                case FILTERED:\n+                                    try {\n+                                        Set<TableId> tablesToCapture = determineCapturedTables();\n+                                        String tableFilterString = tablesToCapture.stream().map(TableId::toDoubleQuotedString).collect(Collectors.joining(\", \"));\n+                                        createPublicationStmt = String.format(\"CREATE PUBLICATION %s FOR TABLE %s;\", publicationName, tableFilterString);\n+                                        LOGGER.info(\"Creating Publication with statement '{}'\", createPublicationStmt);\n+                                        // Publication doesn't exist, create it but restrict to the tableFilter.\n+                                        stmt.execute(createPublicationStmt);\n+                                    }\n+                                    catch (Exception e) {\n+                                        LOGGER.error(\"Unable to create publication for \");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcyNTgzMw==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434725833", "bodyText": "Actually it looks like I messed something up, I do want to through a connect exception and provide a better error message!", "author": "brbrown25", "createdAt": "2020-06-03T17:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MjIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMDIxMg==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434710212", "bodyText": "Hum, I think I've asked about it before, but why is this explicit check against TABLE_WHITELIST done here? It shouldn't be needed, given you already apply the data collection filter above. Is it some sort of left-over perhaps?", "author": "gunnarmorling", "createdAt": "2020-06-03T16:45:26Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -151,6 +187,42 @@ protected void initPublication() {\n         }\n     }\n \n+    private Stream<TableId> toTableIds(Set<TableId> tableIds, Pattern pattern) {\n+        return tableIds\n+                .stream()\n+                .filter(tid -> pattern.asPredicate().test(tid.toString()))\n+                .sorted();\n+    }\n+\n+    private Set<TableId> determineCapturedTables() throws Exception {\n+        Set<TableId> allTableIds = this.connect().readTableNames(pgConnection().getCatalog(), null, null, new String[]{ \"TABLE\" });\n+\n+        Set<TableId> capturedTables = new HashSet<>();\n+\n+        String value = config().getString(RelationalDatabaseConnectorConfig.TABLE_WHITELIST);\n+\n+        for (TableId tableId : allTableIds) {\n+            if (tableFilter.dataCollectionFilter().isIncluded(tableId)) {\n+                LOGGER.trace(\"Adding table {} to the list of captured tables\", tableId);\n+                capturedTables.add(tableId);\n+            }\n+            else {\n+                LOGGER.trace(\"Ignoring table {} as it's not included in the filter configuration\", tableId);\n+            }\n+        }\n+\n+        if (value != null) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMDcxOQ==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434730719", "bodyText": "yeah this does seem like a left over!", "author": "brbrown25", "createdAt": "2020-06-03T17:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMDIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMTAzMw==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434711033", "bodyText": "Could you change the test so that multiple tables are matched? Seems like a critical thing to get right, set up the publication for more than one table.", "author": "gunnarmorling", "createdAt": "2020-06-03T16:46:46Z", "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/PostgresConnectorIT.java", "diffHunk": "@@ -1628,6 +1630,126 @@ public void shouldOutputRecordsInCloudEventsFormat() throws Exception {\n         stopConnector();\n     }\n \n+    @Test\n+    @FixFor(\"DBZ-1813\")\n+    @SkipWhenDecoderPluginNameIsNot(value = SkipWhenDecoderPluginNameIsNot.DecoderPluginName.PGOUTPUT, reason = \"Publication configuration only valid for PGOUTPUT decoder\")\n+    public void shouldConfigureSubscriptionsForAllTablesByDefault() throws Exception {\n+        // This captures all logged messages, allowing us to verify log message was written.\n+        final LogInterceptor logInterceptor = new LogInterceptor();\n+\n+        TestHelper.dropAllSchemas();\n+        TestHelper.dropPublication(\"cdc\");\n+        TestHelper.executeDDL(\"postgres_create_tables.ddl\");\n+\n+        Configuration.Builder configBuilder = TestHelper.defaultConfig()\n+                .with(PostgresConnectorConfig.PUBLICATION_NAME, \"cdc\");\n+\n+        start(PostgresConnector.class, configBuilder.build());\n+        assertConnectorIsRunning();\n+        waitForAvailableRecords(100, TimeUnit.MILLISECONDS);\n+\n+        stopConnector(value -> assertTrue(\n+                logInterceptor.containsMessage(\"Creating Publication with statement 'CREATE PUBLICATION cdc FOR ALL TABLES;'\") &&\n+                        logInterceptor.containsMessage(\"Creating new publication 'cdc' for plugin 'PGOUTPUT'\")));\n+        assertTrue(TestHelper.publicationExists(\"cdc\"));\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-1813\")\n+    @SkipWhenDecoderPluginNameIsNot(value = SkipWhenDecoderPluginNameIsNot.DecoderPluginName.PGOUTPUT, reason = \"Publication configuration only valid for PGOUTPUT decoder\")\n+    public void shouldConfigureSubscriptionsFromTableFilters() throws Exception {\n+        // This captures all logged messages, allowing us to verify log message was written.\n+        final LogInterceptor logInterceptor = new LogInterceptor();\n+\n+        TestHelper.dropAllSchemas();\n+        TestHelper.dropPublication(\"cdc\");\n+        TestHelper.executeDDL(\"postgres_create_tables.ddl\");\n+\n+        Configuration.Builder configBuilder = TestHelper.defaultConfig()\n+                .with(PostgresConnectorConfig.PUBLICATION_NAME, \"cdc\")\n+                .with(PostgresConnectorConfig.TABLE_WHITELIST, \"public.numeric_table\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcyOTY0Mg==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434729642", "bodyText": "will do! seems like a good thing to have!", "author": "brbrown25", "createdAt": "2020-06-03T17:18:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMTY5OA==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434711698", "bodyText": "Could you clarify that this option only applies when pgoutput is used? Also, perhaps a link to upstream Postgres docs on the concept of publications?", "author": "gunnarmorling", "createdAt": "2020-06-03T16:47:47Z", "path": "documentation/modules/ROOT/pages/connectors/postgresql.adoc", "diffHunk": "@@ -1892,6 +1892,18 @@ See the {link-prefix}:{link-postgresql-connector}#postgresql-data-types[list of\n Each item (regular expression) must match the fully-qualified `<fully-qualified table>:<a comma-separated list of columns>` representing the custom key. +\n Fully-qualified tables could be defined as _schemaName_._tableName_.\n \n+|[[postgresql-publication-autocreate-mode]]<<postgresql-publication-autocreate-mode, `publication.autocreate.mode`>>\n+|_all_tables_\n+|Determine how creation of a publication should work, the default is all_tables.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMjYzNQ==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434712635", "bodyText": "Let's avoid the notion of \"current\" behavior, as it won't be clear to the future reader:\n\nIf no publication exists, the connector will create a new publication for all tables. Note this requires xyz grants. If the publication already exists, it will be used.", "author": "gunnarmorling", "createdAt": "2020-06-03T16:49:13Z", "path": "documentation/modules/ROOT/pages/connectors/postgresql.adoc", "diffHunk": "@@ -1892,6 +1892,18 @@ See the {link-prefix}:{link-postgresql-connector}#postgresql-data-types[list of\n Each item (regular expression) must match the fully-qualified `<fully-qualified table>:<a comma-separated list of columns>` representing the custom key. +\n Fully-qualified tables could be defined as _schemaName_._tableName_.\n \n+|[[postgresql-publication-autocreate-mode]]<<postgresql-publication-autocreate-mode, `publication.autocreate.mode`>>\n+|_all_tables_\n+|Determine how creation of a publication should work, the default is all_tables.\n+_disabled_ - The connector will not attempt to create a publication at all. The expectation is\n+that the user has created the publication up-front. If the publication isn't found to exist upon\n+startup, the connector will throw an exception and stop.\n+_all_tables_ - This acts like the current behavior where if the publication does not exist the", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMzczNg==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434713736", "bodyText": "If no publication exists, the connector will create a new publication for all those tables matching the current filter configuration (see table/database whitelist/blacklist properties). If the publication already exists, it will be used.", "author": "gunnarmorling", "createdAt": "2020-06-03T16:50:57Z", "path": "documentation/modules/ROOT/pages/connectors/postgresql.adoc", "diffHunk": "@@ -1892,6 +1892,18 @@ See the {link-prefix}:{link-postgresql-connector}#postgresql-data-types[list of\n Each item (regular expression) must match the fully-qualified `<fully-qualified table>:<a comma-separated list of columns>` representing the custom key. +\n Fully-qualified tables could be defined as _schemaName_._tableName_.\n \n+|[[postgresql-publication-autocreate-mode]]<<postgresql-publication-autocreate-mode, `publication.autocreate.mode`>>\n+|_all_tables_\n+|Determine how creation of a publication should work, the default is all_tables.\n+_disabled_ - The connector will not attempt to create a publication at all. The expectation is\n+that the user has created the publication up-front. If the publication isn't found to exist upon\n+startup, the connector will throw an exception and stop.\n+_all_tables_ - This acts like the current behavior where if the publication does not exist the\n+connector will create the publication for all tables. If the publication exists, we will use it.\n+i.e `CREATE PUBLICATION <publication_name> FOR ALL TABLES;`\n+_filtered_ - This would create the publication for matching tables only", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxNDc1Nw==", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434714757", "bodyText": "Same comment on \"current\" as further below.", "author": "gunnarmorling", "createdAt": "2020-06-03T16:52:39Z", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresConnectorConfig.java", "diffHunk": "@@ -592,6 +592,83 @@ public static SchemaRefreshMode parse(String value) {\n             .withDescription(\"The name of the Postgres 10+ publication used for streaming changes from a plugin.\" +\n                     \"Defaults to '\" + ReplicationConnection.Builder.DEFAULT_PUBLICATION_NAME + \"'\");\n \n+    public enum AutoCreateMode implements EnumeratedValue {\n+        /**\n+         * No Publication will be created, it's expected the user\n+         * has already created the publication.\n+         */\n+        DISABLED(\"disabled\"),\n+        /**\n+         * Enable publication for all tables.\n+         */\n+        ALL_TABLES(\"all_tables\"),\n+        /**\n+         * Enable publication on a specific set of tables.\n+         */\n+        FILTERED(\"filtered\");\n+\n+        private final String value;\n+\n+        AutoCreateMode(String value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public String getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Determine if the supplied value is one of the predefined options.\n+         *\n+         * @param value the configuration property value; may not be null\n+         * @return the matching option, or null if no match is found\n+         */\n+        public static AutoCreateMode parse(String value) {\n+            if (value == null) {\n+                return null;\n+            }\n+            value = value.trim();\n+            for (AutoCreateMode option : AutoCreateMode.values()) {\n+                if (option.getValue().equalsIgnoreCase(value)) {\n+                    return option;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        /**\n+         * Determine if the supplied value is one of the predefined options.\n+         *\n+         * @param value        the configuration property value; may not be null\n+         * @param defaultValue the default value; may be null\n+         * @return the matching option, or null if no match is found and the non-null default is invalid\n+         */\n+        public static AutoCreateMode parse(String value, String defaultValue) {\n+            AutoCreateMode mode = parse(value);\n+            if (mode == null && defaultValue != null) {\n+                mode = parse(defaultValue);\n+            }\n+            return mode;\n+        }\n+    }\n+\n+    public static final Field PUBLICATION_AUTOCREATE_MODE = Field.create(\"publication.autocreate.mode\")\n+            .withDisplayName(\"Publication Auto Create Mode\")\n+            .withEnum(AutoCreateMode.class, AutoCreateMode.ALL_TABLES)\n+            .withWidth(Width.MEDIUM)\n+            .withImportance(Importance.MEDIUM)\n+            .withDescription(\n+                    \"Determine how creation of a publication should work, the default is all_tables.\" +\n+                            \"DISABLED - The connector will not attempt to create a publication at all. The expectation is \" +\n+                            \"that the user has created the publication up-front. If the publication isn't found to exist upon \" +\n+                            \"startup, the connector will throw an exception and stop.\" +\n+                            \"ALL_TABLES - This acts like the current behavior where if the publication does not exist the \" +", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "dfa3e166b8219999a6969bbad0775c247dce96f0", "url": "https://github.com/debezium/debezium/commit/dfa3e166b8219999a6969bbad0775c247dce96f0", "message": "DBZ-1813 Adding ability to configure pgoutput publication based on table filters\ndefined.", "committedDate": "2020-06-04T16:08:19Z", "type": "commit"}, {"oid": "7323b56d7d2b8fda3792a68d9fc469b35e1e80c2", "url": "https://github.com/debezium/debezium/commit/7323b56d7d2b8fda3792a68d9fc469b35e1e80c2", "message": "DBZ-1813 Stabiling test", "committedDate": "2020-06-04T16:08:19Z", "type": "commit"}, {"oid": "26df1eba19cb6fbd226b84fcfaaa029a7b909458", "url": "https://github.com/debezium/debezium/commit/26df1eba19cb6fbd226b84fcfaaa029a7b909458", "message": "DBZ-1813 Misc. clean-up;\n\n* Removing unused method\n* Simplifying tests\n* Avoiding deprecated code", "committedDate": "2020-06-04T16:08:19Z", "type": "commit"}, {"oid": "26df1eba19cb6fbd226b84fcfaaa029a7b909458", "url": "https://github.com/debezium/debezium/commit/26df1eba19cb6fbd226b84fcfaaa029a7b909458", "message": "DBZ-1813 Misc. clean-up;\n\n* Removing unused method\n* Simplifying tests\n* Avoiding deprecated code", "committedDate": "2020-06-04T16:08:19Z", "type": "forcePushed"}]}