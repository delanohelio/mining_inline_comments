{"pr_number": 1673, "pr_title": "DBZ-730 add MySqlDecimalIT integration test for all decimal.handling.mode/s", "pr_createdAt": "2020-07-07T16:37:20Z", "pr_url": "https://github.com/debezium/debezium/pull/1673", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMjQ1Ng==", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451002456", "bodyText": "these 2 lines can be confusing.  especially when getFloat64 and getString behave differently (see below)", "author": "rk3rn3r", "createdAt": "2020-07-07T16:44:33Z", "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.mysql;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Path;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.debezium.config.Configuration;\n+import io.debezium.doc.FixFor;\n+import io.debezium.embedded.AbstractConnectorTest;\n+import io.debezium.relational.RelationalDatabaseConnectorConfig;\n+import io.debezium.util.Testing;\n+\n+/**\n+ * Verify correct DECIMAL handling with different types of io.debezium.relational.RelationalDatabaseConnectorConfig.DecimalHandlingMode.\n+ *\n+ * @author Ren\u00e9 Kerner\n+ */\n+public class MySqlDecimalIT extends AbstractConnectorTest {\n+\n+    private static final String TABLE_NAME = \"DBZ730\";\n+\n+    private static final Path DB_HISTORY_PATH = Testing.Files.createTestingPath(\"file-db-history-decimal.txt\")\n+            .toAbsolutePath();\n+    private final UniqueDatabase DATABASE = new UniqueDatabase(\"decimaldb\", \"decimal_test\")\n+            .withDbHistoryPath(DB_HISTORY_PATH);\n+\n+    private Configuration config;\n+\n+    @Before\n+    public void beforeEach() {\n+        stopConnector();\n+        DATABASE.createAndInitialize();\n+        initializeConnectorTestFramework();\n+        Testing.Files.delete(DB_HISTORY_PATH);\n+    }\n+\n+    @After\n+    public void afterEach() {\n+        try {\n+            stopConnector();\n+        }\n+        finally {\n+            Testing.Files.delete(DB_HISTORY_PATH);\n+        }\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testPreciseDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.PRECISE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertBigDecimalChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testDoubleDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertDoubleChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testStringDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.STRING)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertStringChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    private SourceRecord consumeInsert() throws InterruptedException {\n+        final int numDatabase = 2;\n+        final int numTables = 4;\n+        final int numOthers = 1;\n+\n+        SourceRecords records = consumeRecordsByTopic(numDatabase + numTables + numOthers);\n+\n+        assertThat(records).isNotNull();\n+\n+        List<SourceRecord> events = records.recordsForTopic(DATABASE.topicForTable(TABLE_NAME));\n+        assertThat(events).hasSize(1);\n+\n+        return events.get(0);\n+    }\n+\n+    private void assertBigDecimalChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.get(\"A\")).isEqualTo(new BigDecimal(\"1.33\"));\n+        Assertions.assertThat(change.get(\"B\")).isEqualTo(new BigDecimal(\"-2.111\"));\n+        Assertions.assertThat(change.get(\"C\")).isEqualTo(new BigDecimal(\"3.44400\"));\n+        Assertions.assertThat(change.get(\"D\")).isEqualTo(new BigDecimal(\"15.28000\")); // returns the default value\n+        Assertions.assertThat(change.getBytes(\"D\")).isNull(); // returns the real value, which is null", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNTcyMA==", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451015720", "bodyText": "Maybe we need to fix BigDecimal handling?", "author": "rk3rn3r", "createdAt": "2020-07-07T17:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4MDA1Mg==", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451380052", "bodyText": "You can use getWithoutDefault method", "author": "jpechane", "createdAt": "2020-07-08T08:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwMDg5Ng==", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451400896", "bodyText": "oh yes! omg. really, I just learned about that different default value behavior of get(). I would expect the opposite behaviour. get() comes without default and there is getWithDefault()... very interesting.", "author": "rk3rn3r", "createdAt": "2020-07-08T09:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMjQ1Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxMzgzNQ==", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451013835", "bodyText": "getString returns the \"real\" value, which is null. accessing the field with getBytes() isn't working here.", "author": "rk3rn3r", "createdAt": "2020-07-07T17:03:36Z", "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.mysql;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Path;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.debezium.config.Configuration;\n+import io.debezium.doc.FixFor;\n+import io.debezium.embedded.AbstractConnectorTest;\n+import io.debezium.relational.RelationalDatabaseConnectorConfig;\n+import io.debezium.util.Testing;\n+\n+/**\n+ * Verify correct DECIMAL handling with different types of io.debezium.relational.RelationalDatabaseConnectorConfig.DecimalHandlingMode.\n+ *\n+ * @author Ren\u00e9 Kerner\n+ */\n+public class MySqlDecimalIT extends AbstractConnectorTest {\n+\n+    private static final String TABLE_NAME = \"DBZ730\";\n+\n+    private static final Path DB_HISTORY_PATH = Testing.Files.createTestingPath(\"file-db-history-decimal.txt\")\n+            .toAbsolutePath();\n+    private final UniqueDatabase DATABASE = new UniqueDatabase(\"decimaldb\", \"decimal_test\")\n+            .withDbHistoryPath(DB_HISTORY_PATH);\n+\n+    private Configuration config;\n+\n+    @Before\n+    public void beforeEach() {\n+        stopConnector();\n+        DATABASE.createAndInitialize();\n+        initializeConnectorTestFramework();\n+        Testing.Files.delete(DB_HISTORY_PATH);\n+    }\n+\n+    @After\n+    public void afterEach() {\n+        try {\n+            stopConnector();\n+        }\n+        finally {\n+            Testing.Files.delete(DB_HISTORY_PATH);\n+        }\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testPreciseDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.PRECISE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertBigDecimalChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testDoubleDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertDoubleChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testStringDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.STRING)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertStringChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    private SourceRecord consumeInsert() throws InterruptedException {\n+        final int numDatabase = 2;\n+        final int numTables = 4;\n+        final int numOthers = 1;\n+\n+        SourceRecords records = consumeRecordsByTopic(numDatabase + numTables + numOthers);\n+\n+        assertThat(records).isNotNull();\n+\n+        List<SourceRecord> events = records.recordsForTopic(DATABASE.topicForTable(TABLE_NAME));\n+        assertThat(events).hasSize(1);\n+\n+        return events.get(0);\n+    }\n+\n+    private void assertBigDecimalChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.get(\"A\")).isEqualTo(new BigDecimal(\"1.33\"));\n+        Assertions.assertThat(change.get(\"B\")).isEqualTo(new BigDecimal(\"-2.111\"));\n+        Assertions.assertThat(change.get(\"C\")).isEqualTo(new BigDecimal(\"3.44400\"));\n+        Assertions.assertThat(change.get(\"D\")).isEqualTo(new BigDecimal(\"15.28000\")); // returns the default value\n+        Assertions.assertThat(change.getBytes(\"D\")).isNull(); // returns the real value, which is null\n+\n+        Assertions.assertThat(record.valueSchema().field(\"after\").schema().field(\"D\").schema().defaultValue())\n+                .isEqualTo(new BigDecimal(\"15.28000\"));\n+    }\n+\n+    private void assertDoubleChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.getFloat64(\"A\")).isEqualTo(1.33);\n+        Assertions.assertThat(change.getFloat64(\"B\")).isEqualTo(-2.111);\n+        Assertions.assertThat(change.getFloat64(\"C\")).isEqualTo(3.44400);\n+        Assertions.assertThat(change.getFloat64(\"D\")).isNull(); // returns the real value, not field's default value\n+        // Assertions.assertThat(change.getBytes(\"D\")).isNull(); // seems it's not possible to call getBytes on a Double ?\n+\n+        Assertions.assertThat(record.valueSchema().field(\"after\").schema().field(\"D\").schema().defaultValue())\n+                .isEqualTo(15.28000);\n+    }\n+\n+    private void assertStringChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.getString(\"A\").trim()).isEqualTo(\"1.33\");\n+        Assertions.assertThat(change.getString(\"B\").trim()).isEqualTo(\"-2.111\");\n+        Assertions.assertThat(change.getString(\"C\").trim()).isEqualTo(\"3.44400\");\n+        Assertions.assertThat(change.getString(\"D\")).isNull(); // returns the real value, not field's default value\n+        // Assertions.assertThat(change.getBytes(\"D\")).isNull(); // seems it's not possible to call getBytes on a String ?", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4MDY1OQ==", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451380659", "bodyText": "getBytes would work only if the schema would be BYTES - but it is String", "author": "jpechane", "createdAt": "2020-07-08T08:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxMzgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwMTMzOA==", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451401338", "bodyText": "I still want raw bytes! ;)", "author": "rk3rn3r", "createdAt": "2020-07-08T09:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxMzgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNDE4Mw==", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451014183", "bodyText": "getFloat64 returns the \"real\" value, which is null. accessing the field with getBytes() isn't working here.", "author": "rk3rn3r", "createdAt": "2020-07-07T17:04:07Z", "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.mysql;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Path;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.debezium.config.Configuration;\n+import io.debezium.doc.FixFor;\n+import io.debezium.embedded.AbstractConnectorTest;\n+import io.debezium.relational.RelationalDatabaseConnectorConfig;\n+import io.debezium.util.Testing;\n+\n+/**\n+ * Verify correct DECIMAL handling with different types of io.debezium.relational.RelationalDatabaseConnectorConfig.DecimalHandlingMode.\n+ *\n+ * @author Ren\u00e9 Kerner\n+ */\n+public class MySqlDecimalIT extends AbstractConnectorTest {\n+\n+    private static final String TABLE_NAME = \"DBZ730\";\n+\n+    private static final Path DB_HISTORY_PATH = Testing.Files.createTestingPath(\"file-db-history-decimal.txt\")\n+            .toAbsolutePath();\n+    private final UniqueDatabase DATABASE = new UniqueDatabase(\"decimaldb\", \"decimal_test\")\n+            .withDbHistoryPath(DB_HISTORY_PATH);\n+\n+    private Configuration config;\n+\n+    @Before\n+    public void beforeEach() {\n+        stopConnector();\n+        DATABASE.createAndInitialize();\n+        initializeConnectorTestFramework();\n+        Testing.Files.delete(DB_HISTORY_PATH);\n+    }\n+\n+    @After\n+    public void afterEach() {\n+        try {\n+            stopConnector();\n+        }\n+        finally {\n+            Testing.Files.delete(DB_HISTORY_PATH);\n+        }\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testPreciseDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.PRECISE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertBigDecimalChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testDoubleDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertDoubleChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testStringDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.STRING)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertStringChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    private SourceRecord consumeInsert() throws InterruptedException {\n+        final int numDatabase = 2;\n+        final int numTables = 4;\n+        final int numOthers = 1;\n+\n+        SourceRecords records = consumeRecordsByTopic(numDatabase + numTables + numOthers);\n+\n+        assertThat(records).isNotNull();\n+\n+        List<SourceRecord> events = records.recordsForTopic(DATABASE.topicForTable(TABLE_NAME));\n+        assertThat(events).hasSize(1);\n+\n+        return events.get(0);\n+    }\n+\n+    private void assertBigDecimalChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.get(\"A\")).isEqualTo(new BigDecimal(\"1.33\"));\n+        Assertions.assertThat(change.get(\"B\")).isEqualTo(new BigDecimal(\"-2.111\"));\n+        Assertions.assertThat(change.get(\"C\")).isEqualTo(new BigDecimal(\"3.44400\"));\n+        Assertions.assertThat(change.get(\"D\")).isEqualTo(new BigDecimal(\"15.28000\")); // returns the default value\n+        Assertions.assertThat(change.getBytes(\"D\")).isNull(); // returns the real value, which is null\n+\n+        Assertions.assertThat(record.valueSchema().field(\"after\").schema().field(\"D\").schema().defaultValue())\n+                .isEqualTo(new BigDecimal(\"15.28000\"));\n+    }\n+\n+    private void assertDoubleChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.getFloat64(\"A\")).isEqualTo(1.33);\n+        Assertions.assertThat(change.getFloat64(\"B\")).isEqualTo(-2.111);\n+        Assertions.assertThat(change.getFloat64(\"C\")).isEqualTo(3.44400);\n+        Assertions.assertThat(change.getFloat64(\"D\")).isNull(); // returns the real value, not field's default value\n+        // Assertions.assertThat(change.getBytes(\"D\")).isNull(); // seems it's not possible to call getBytes on a Double ?", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNTA1NA==", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451015054", "bodyText": "isn't this the correct config value?\nis it okay to change the parameter with that PR?", "author": "rk3rn3r", "createdAt": "2020-07-07T17:05:43Z", "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MysqlDefaultValueIT.java", "diffHunk": "@@ -525,7 +526,7 @@ public void realTest() throws InterruptedException {\n     public void numericAndDecimalToDoubleTest() throws InterruptedException {\n         config = DATABASE.defaultConfig()\n                 .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n-                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, JdbcValueConverters.DecimalMode.DOUBLE)\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4MDg4Nw==", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451380887", "bodyText": "Yes, that's ok", "author": "jpechane", "createdAt": "2020-07-08T08:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNTA1NA=="}], "type": "inlineReview"}, {"oid": "1490e43765711849a033b70b79655585bfb4215d", "url": "https://github.com/debezium/debezium/commit/1490e43765711849a033b70b79655585bfb4215d", "message": "DBZ-730 add MySqlDecimalIT integration test for all decimal.handling.mode/s", "committedDate": "2020-07-08T09:20:58Z", "type": "commit"}, {"oid": "1490e43765711849a033b70b79655585bfb4215d", "url": "https://github.com/debezium/debezium/commit/1490e43765711849a033b70b79655585bfb4215d", "message": "DBZ-730 add MySqlDecimalIT integration test for all decimal.handling.mode/s", "committedDate": "2020-07-08T09:20:58Z", "type": "forcePushed"}]}