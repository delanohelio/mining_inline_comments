{"pr_number": 4491, "pr_title": "CUSTCOM-70 Additional Fix to JAXRS Client With Embedded Dependency", "pr_createdAt": "2020-02-13T16:59:13Z", "pr_url": "https://github.com/payara/Payara/pull/4491", "timeline": [{"oid": "b39547dcaaa956be7640aebdbdfd1e721e48e9a6", "url": "https://github.com/payara/Payara/commit/b39547dcaaa956be7640aebdbdfd1e721e48e9a6", "message": "CUSTCOM-70 Fix JAXRS client with embedded dependency\n\nWhen Payara Embedded is used as a library rather than starting the\nembedded server, an exception will be thrown when using the JAX-RS\nclient caused by the request tracing service not having initialised.\n\nThe previous CUSTCOM-70 fix allowed a JAX-RS client request to be\nbuilt, but executing the request would still throw the same\nexception. This change allows the request to be executed as well.\n\nSigned-off-by: Matt Gill <matthew.gill@live.co.uk>", "committedDate": "2020-02-14T10:28:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM1OTY1MQ==", "url": "https://github.com/payara/Payara/pull/4491#discussion_r379359651", "bodyText": "Always use braces {}, but ignore it here, because previous comment makes these whole blocks unnecessary :)", "author": "dmatej", "createdAt": "2020-02-14T10:34:18Z", "path": "appserver/payara-appserver-modules/jaxrs-client-tracing/src/main/java/fish/payara/requesttracing/jaxrs/client/PayaraTracingServices.java", "diffHunk": "@@ -63,60 +63,88 @@\n \n     private static volatile boolean initialized;\n \n-    private static ServiceLocator basicServiceLocator;\n+    private static ServiceLocator baseServiceLocator;\n     private static RequestTracingService requestTracingService;\n     private static OpenTracingService openTracingService;\n \n-\n-    private static void checkInitialized() {\n+    /**\n+     * @return true if the Request Tracing services are available and have been\n+     *         initialised, or false if the services are not available.\n+     * @throws RuntimeException if an exception occurs initialising the services.\n+     */\n+    private static boolean checkInitialized() {\n         if (initialized) {\n-            return;\n+            return true;\n         }\n         synchronized (PayaraTracingServices.class) {\n             if (initialized) {\n-                return;\n+                return true;\n             }\n-            basicServiceLocator = Globals.getStaticBaseServiceLocator();\n-            requestTracingService = basicServiceLocator.getService(RequestTracingService.class);\n-            openTracingService = basicServiceLocator.getService(OpenTracingService.class);\n+\n+            baseServiceLocator = Globals.getStaticBaseServiceLocator();\n+            if (baseServiceLocator == null) {\n+                return false;\n+            }\n+\n+            ServiceHandle<RequestTracingService> requestTracingServiceHandle = baseServiceLocator.getServiceHandle(RequestTracingService.class);\n+            if (requestTracingServiceHandle != null) {\n+                requestTracingService = requestTracingServiceHandle.getService();\n+            } else return false;", "originalCommit": "b39547dcaaa956be7640aebdbdfd1e721e48e9a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM2NzQ5OQ==", "url": "https://github.com/payara/Payara/pull/4491#discussion_r379367499", "bodyText": "I would move it to constructor and made all fields non-statc final.\nConstructor would try to initialize objects fields:\n\nfirst it would call Globals.getDefaultHabitat() - it does not try to initialize the service loader and can return null.\nif the loader is null, set all services to null (final)\nelse\n\ninit all services via calls to private static method with API\n\n\n\n<T> T findService(ServiceLocator locator, Class<T> clazz) {\n  if (locator == null) {\n    return null;\n  } \n  ServiceHandle<RequestTracingService> handle = locator.getServiceHandle(clazz);\n  if (handle != null && handle.isActive()) {\n    return handle.getService();\n  }\n  return null;\n}\n\n\n\nThen created isTracingAvailable() returning true ONLY if all services were initialized.\ngetter will be only getters\nI would remove the serviceLoader field - all usages would use Globals directly, but only after checking isTracingAvailable() is true\ncreate yet getDeployment() getter\nTHEN\n\nJerseyOpenTracingAutoDiscoverable can use new PayaraTracingServices.isTracingAvailable and getDeployment\nJaxrsClientBuilderDecorator.requestTracingPresent can simply return new PayaraTracingServices().isTracingAvailable instead of it's current body.\nservice locator is not needed from PayaraTracingservices any more.", "author": "dmatej", "createdAt": "2020-02-14T10:51:41Z", "path": "appserver/payara-appserver-modules/jaxrs-client-tracing/src/main/java/fish/payara/requesttracing/jaxrs/client/PayaraTracingServices.java", "diffHunk": "@@ -63,60 +63,88 @@\n \n     private static volatile boolean initialized;\n \n-    private static ServiceLocator basicServiceLocator;\n+    private static ServiceLocator baseServiceLocator;\n     private static RequestTracingService requestTracingService;\n     private static OpenTracingService openTracingService;\n \n-\n-    private static void checkInitialized() {\n+    /**\n+     * @return true if the Request Tracing services are available and have been\n+     *         initialised, or false if the services are not available.\n+     * @throws RuntimeException if an exception occurs initialising the services.\n+     */\n+    private static boolean checkInitialized() {", "originalCommit": "b39547dcaaa956be7640aebdbdfd1e721e48e9a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM2Nzc1Mw==", "url": "https://github.com/payara/Payara/pull/4491#discussion_r379367753", "bodyText": "To be removed ...", "author": "dmatej", "createdAt": "2020-02-14T10:52:14Z", "path": "appserver/payara-appserver-modules/jaxrs-client-tracing/src/main/java/fish/payara/requesttracing/jaxrs/client/PayaraTracingServices.java", "diffHunk": "@@ -63,60 +63,88 @@\n \n     private static volatile boolean initialized;\n \n-    private static ServiceLocator basicServiceLocator;\n+    private static ServiceLocator baseServiceLocator;\n     private static RequestTracingService requestTracingService;\n     private static OpenTracingService openTracingService;\n \n-\n-    private static void checkInitialized() {\n+    /**\n+     * @return true if the Request Tracing services are available and have been\n+     *         initialised, or false if the services are not available.\n+     * @throws RuntimeException if an exception occurs initialising the services.\n+     */\n+    private static boolean checkInitialized() {\n         if (initialized) {\n-            return;\n+            return true;\n         }\n         synchronized (PayaraTracingServices.class) {\n             if (initialized) {\n-                return;\n+                return true;\n             }\n-            basicServiceLocator = Globals.getStaticBaseServiceLocator();\n-            requestTracingService = basicServiceLocator.getService(RequestTracingService.class);\n-            openTracingService = basicServiceLocator.getService(OpenTracingService.class);\n+\n+            baseServiceLocator = Globals.getStaticBaseServiceLocator();\n+            if (baseServiceLocator == null) {\n+                return false;\n+            }\n+\n+            ServiceHandle<RequestTracingService> requestTracingServiceHandle = baseServiceLocator.getServiceHandle(RequestTracingService.class);\n+            if (requestTracingServiceHandle != null) {\n+                requestTracingService = requestTracingServiceHandle.getService();\n+            } else return false;\n+\n+            ServiceHandle<OpenTracingService> openTracingServiceHandle = baseServiceLocator.getServiceHandle(OpenTracingService.class);\n+            if (openTracingServiceHandle != null) {\n+                openTracingService = openTracingServiceHandle.getService();\n+            } else return false;\n+\n             initialized = true;\n+            return true;\n         }\n     }\n \n \n     /**\n-     * @return default service locator, same as {@link Globals#getStaticBaseServiceLocator()}.\n+     * @return default service locator, same as\n+     *         {@link Globals#getStaticBaseServiceLocator()}, or null if the HK2\n+     *         service couldn't be initialised.\n      */\n     public ServiceLocator getBasicServiceLocator() {", "originalCommit": "b39547dcaaa956be7640aebdbdfd1e721e48e9a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM2ODA1MQ==", "url": "https://github.com/payara/Payara/pull/4491#discussion_r379368051", "bodyText": "Maybe we should also check the response. Sad my changes did not include this, it could detect that my idea was wrong.", "author": "dmatej", "createdAt": "2020-02-14T10:52:54Z", "path": "appserver/tests/payara-samples/classpath/embedded-vs-jersey/src/test/java/fish/payara/samples/classpath/embeddedvsjersey/JerseyClasspathTest.java", "diffHunk": "@@ -54,6 +54,6 @@\n     @Test\n     public void jerseyShouldInitialize() {\n         Client client = ClientBuilder.newClient();\n-        client.target(\"http://localhost:8080\").request().buildGet();\n+        client.target(\"http://localhost:8080\").request().get();", "originalCommit": "b39547dcaaa956be7640aebdbdfd1e721e48e9a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM3ODczOA==", "url": "https://github.com/payara/Payara/pull/4491#discussion_r379378738", "bodyText": "I think the response is irrelevant. The test still seems to work if you just fill the URL with a random string", "author": "MattGill98", "createdAt": "2020-02-14T11:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM2ODA1MQ=="}], "type": "inlineReview"}, {"oid": "60ad63dc6b99f6679e75b3fbb077f7be4592cb61", "url": "https://github.com/payara/Payara/commit/60ad63dc6b99f6679e75b3fbb077f7be4592cb61", "message": "CUSTCOM-70 Fix JAXRS client with embedded dependency\n\nWhen Payara Embedded is used as a library rather than starting the\nembedded server, an exception will be thrown when using the JAX-RS\nclient caused by the request tracing service not having initialised.\n\nThe previous CUSTCOM-70 fix allowed a JAX-RS client request to be\nbuilt, but executing the request would still throw the same\nexception. This change allows the request to be executed as well.\n\nSigned-off-by: Matt Gill <matthew.gill@live.co.uk>", "committedDate": "2020-02-14T11:12:19Z", "type": "forcePushed"}, {"oid": "3e96cfc33f605193b8dce77e94169564722897ed", "url": "https://github.com/payara/Payara/commit/3e96cfc33f605193b8dce77e94169564722897ed", "message": "CUSTCOM-70 Fix JAXRS client with embedded dependency\n\nWhen Payara Embedded is used as a library rather than starting the\nembedded server, an exception will be thrown when using the JAX-RS\nclient caused by the request tracing service not having initialised.\n\nThe previous CUSTCOM-70 fix allowed a JAX-RS client request to be\nbuilt, but executing the request would still throw the same\nexception. This change allows the request to be executed as well.\n\nSigned-off-by: Matt Gill <matthew.gill@live.co.uk>", "committedDate": "2020-02-14T11:13:14Z", "type": "forcePushed"}, {"oid": "33d983cfd430bdc4da386990aeb2412c54fc604f", "url": "https://github.com/payara/Payara/commit/33d983cfd430bdc4da386990aeb2412c54fc604f", "message": "CUSTCOM-70 Fix JAXRS client with embedded dependency\n\nWhen Payara Embedded is used as a library rather than starting the\nembedded server, an exception will be thrown when using the JAX-RS\nclient caused by the request tracing service not having initialised.\n\nThe previous CUSTCOM-70 fix allowed a JAX-RS client request to be\nbuilt, but executing the request would still throw the same\nexception. This change allows the request to be executed as well.\n\nSigned-off-by: Matt Gill <matthew.gill@live.co.uk>", "committedDate": "2020-02-14T11:59:56Z", "type": "forcePushed"}, {"oid": "7f3c321f41588c795b372653aa3c2a3896423cf5", "url": "https://github.com/payara/Payara/commit/7f3c321f41588c795b372653aa3c2a3896423cf5", "message": "CUSTCOM-70 Fix JAXRS client with embedded dependency\n\nWhen Payara Embedded is used as a library rather than starting the\nembedded server, an exception will be thrown when using the JAX-RS\nclient caused by the request tracing service not having initialised.\n\nThe previous CUSTCOM-70 fix allowed a JAX-RS client request to be\nbuilt, but executing the request would still throw the same\nexception. This change allows the request to be executed as well.\n\nSigned-off-by: Matt Gill <matthew.gill@live.co.uk>", "committedDate": "2020-02-14T12:04:04Z", "type": "forcePushed"}, {"oid": "11544370cc84a36a63d63e4e27457cc4355d4f79", "url": "https://github.com/payara/Payara/commit/11544370cc84a36a63d63e4e27457cc4355d4f79", "message": "CUSTCOM-70 Fix JAXRS client with embedded dependency\n\nWhen Payara Embedded is used as a library rather than starting the\nembedded server, an exception will be thrown when using the JAX-RS\nclient caused by the request tracing service not having initialised.\n\nThe previous CUSTCOM-70 fix allowed a JAX-RS client request to be\nbuilt, but executing the request would still throw the same\nexception. This change allows the request to be executed as well.\n\nSigned-off-by: Matt Gill <matthew.gill@live.co.uk>", "committedDate": "2020-02-14T12:17:25Z", "type": "forcePushed"}, {"oid": "e6f54ec72e74a715b7cf62ce3fb528173b543906", "url": "https://github.com/payara/Payara/commit/e6f54ec72e74a715b7cf62ce3fb528173b543906", "message": "CUSTCOM-70 Create listener for REST client test\n\nThe embedded rest client test won't work without a server running. This\nchange creates a simple Grizzly server on a random available port which\nwill be called by the REST client.\n\nSigned-off-by: Matt Gill <matthew.gill@live.co.uk>", "committedDate": "2020-02-14T12:53:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQyMzIyNQ==", "url": "https://github.com/payara/Payara/pull/4491#discussion_r379423225", "bodyText": "Simply return the field, you don't need the check here", "author": "dmatej", "createdAt": "2020-02-14T13:14:16Z", "path": "appserver/payara-appserver-modules/jaxrs-client-tracing/src/main/java/fish/payara/requesttracing/jaxrs/client/PayaraTracingServices.java", "diffHunk": "@@ -40,111 +40,117 @@\n \n package fish.payara.requesttracing.jaxrs.client;\n \n-import fish.payara.nucleus.requesttracing.RequestTracingService;\n-import fish.payara.opentracing.OpenTracingService;\n-\n-import io.opentracing.Tracer;\n-\n import org.glassfish.api.invocation.InvocationManager;\n+import org.glassfish.hk2.api.ServiceHandle;\n import org.glassfish.hk2.api.ServiceLocator;\n import org.glassfish.internal.api.Globals;\n \n+import fish.payara.nucleus.requesttracing.RequestTracingService;\n+import fish.payara.opentracing.OpenTracingService;\n+import io.opentracing.Tracer;\n+\n /**\n- * This is a class hiding internal mechanism of lookup of HK2 services.\n- * The lookup is lazy, done with first request, but this may be simply changed later.\n- * <p>\n- * The lazy lookup prevents problems with embedded distributions, when jersey lookups\n- * may detect filters in this package and try to use them before Payara started, which\n- * is not supported use case.\n+ * This is a class hiding internal mechanism of lookup of HK2 services. The\n+ * required services will be eagerly initialised using their service handles,\n+ * and throwing an exception if the handle is available but not the service\n+ * itself.\n  *\n  * @author David Matejcek\n  */\n public final class PayaraTracingServices {\n \n-    private static volatile boolean initialized;\n-\n-    private static ServiceLocator basicServiceLocator;\n-    private static RequestTracingService requestTracingService;\n-    private static OpenTracingService openTracingService;\n-\n-\n-    private static void checkInitialized() {\n-        if (initialized) {\n-            return;\n-        }\n-        synchronized (PayaraTracingServices.class) {\n-            if (initialized) {\n-                return;\n-            }\n-            basicServiceLocator = Globals.getStaticBaseServiceLocator();\n-            requestTracingService = basicServiceLocator.getService(RequestTracingService.class);\n-            openTracingService = basicServiceLocator.getService(OpenTracingService.class);\n-            initialized = true;\n-        }\n-    }\n-\n+    private final InvocationManager invocationManager;\n+    private final RequestTracingService requestTracingService;\n+    private final OpenTracingService openTracingService;\n \n     /**\n-     * @return default service locator, same as {@link Globals#getStaticBaseServiceLocator()}.\n+     * Initialise the tracing services if they are available.\n+     * \n+     * @throws RuntimeException if an exception occurs initialising the services.\n      */\n-    public ServiceLocator getBasicServiceLocator() {\n-        checkInitialized();\n-        return basicServiceLocator;\n-    }\n+    public PayaraTracingServices() {\n+        final ServiceLocator baseServiceLocator = Globals.getStaticBaseServiceLocator();\n \n+        requestTracingService = getFromServiceHandle(baseServiceLocator, RequestTracingService.class);\n+        openTracingService = getFromServiceHandle(baseServiceLocator, OpenTracingService.class);\n+        invocationManager = getFromServiceHandle(baseServiceLocator, InvocationManager.class);\n+    }\n \n     /**\n-     * @return {@link RequestTracingService}\n+     * @return {@link RequestTracingService}, or null if the HK2 service couldn't be\n+     *         initialised.\n      */\n     public RequestTracingService getRequestTracingService() {\n-        checkInitialized();\n-        return requestTracingService;\n+        if (checkInitialized()) {\n+            return requestTracingService;\n+        }\n+        return null;\n     }\n \n-\n     /**\n-     * @return {@link OpenTracingService}\n+     * @return {@link OpenTracingService}, or null if the HK2 service couldn't be\n+     *         initialised.\n      */\n     public OpenTracingService getOpenTracingService() {\n-        checkInitialized();\n-        return openTracingService;\n+        if (checkInitialized()) {\n+            return openTracingService;\n+        }\n+        return null;\n     }\n \n-\n     /**\n      * @return {@link InvocationManager}\n      */\n     public InvocationManager getInvocationManager() {\n-        checkInitialized();\n-        return basicServiceLocator.getService(InvocationManager.class);\n+        if (checkInitialized()) {", "originalCommit": "e6f54ec72e74a715b7cf62ce3fb528173b543906", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQyMzc3Ng==", "url": "https://github.com/payara/Payara/pull/4491#discussion_r379423776", "bodyText": "No need to call the check - it will be null if applicationName is null and applicationName is null if check ...", "author": "dmatej", "createdAt": "2020-02-14T13:15:44Z", "path": "appserver/payara-appserver-modules/jaxrs-client-tracing/src/main/java/fish/payara/requesttracing/jaxrs/client/PayaraTracingServices.java", "diffHunk": "@@ -40,111 +40,117 @@\n \n package fish.payara.requesttracing.jaxrs.client;\n \n-import fish.payara.nucleus.requesttracing.RequestTracingService;\n-import fish.payara.opentracing.OpenTracingService;\n-\n-import io.opentracing.Tracer;\n-\n import org.glassfish.api.invocation.InvocationManager;\n+import org.glassfish.hk2.api.ServiceHandle;\n import org.glassfish.hk2.api.ServiceLocator;\n import org.glassfish.internal.api.Globals;\n \n+import fish.payara.nucleus.requesttracing.RequestTracingService;\n+import fish.payara.opentracing.OpenTracingService;\n+import io.opentracing.Tracer;\n+\n /**\n- * This is a class hiding internal mechanism of lookup of HK2 services.\n- * The lookup is lazy, done with first request, but this may be simply changed later.\n- * <p>\n- * The lazy lookup prevents problems with embedded distributions, when jersey lookups\n- * may detect filters in this package and try to use them before Payara started, which\n- * is not supported use case.\n+ * This is a class hiding internal mechanism of lookup of HK2 services. The\n+ * required services will be eagerly initialised using their service handles,\n+ * and throwing an exception if the handle is available but not the service\n+ * itself.\n  *\n  * @author David Matejcek\n  */\n public final class PayaraTracingServices {\n \n-    private static volatile boolean initialized;\n-\n-    private static ServiceLocator basicServiceLocator;\n-    private static RequestTracingService requestTracingService;\n-    private static OpenTracingService openTracingService;\n-\n-\n-    private static void checkInitialized() {\n-        if (initialized) {\n-            return;\n-        }\n-        synchronized (PayaraTracingServices.class) {\n-            if (initialized) {\n-                return;\n-            }\n-            basicServiceLocator = Globals.getStaticBaseServiceLocator();\n-            requestTracingService = basicServiceLocator.getService(RequestTracingService.class);\n-            openTracingService = basicServiceLocator.getService(OpenTracingService.class);\n-            initialized = true;\n-        }\n-    }\n-\n+    private final InvocationManager invocationManager;\n+    private final RequestTracingService requestTracingService;\n+    private final OpenTracingService openTracingService;\n \n     /**\n-     * @return default service locator, same as {@link Globals#getStaticBaseServiceLocator()}.\n+     * Initialise the tracing services if they are available.\n+     * \n+     * @throws RuntimeException if an exception occurs initialising the services.\n      */\n-    public ServiceLocator getBasicServiceLocator() {\n-        checkInitialized();\n-        return basicServiceLocator;\n-    }\n+    public PayaraTracingServices() {\n+        final ServiceLocator baseServiceLocator = Globals.getStaticBaseServiceLocator();\n \n+        requestTracingService = getFromServiceHandle(baseServiceLocator, RequestTracingService.class);\n+        openTracingService = getFromServiceHandle(baseServiceLocator, OpenTracingService.class);\n+        invocationManager = getFromServiceHandle(baseServiceLocator, InvocationManager.class);\n+    }\n \n     /**\n-     * @return {@link RequestTracingService}\n+     * @return {@link RequestTracingService}, or null if the HK2 service couldn't be\n+     *         initialised.\n      */\n     public RequestTracingService getRequestTracingService() {\n-        checkInitialized();\n-        return requestTracingService;\n+        if (checkInitialized()) {\n+            return requestTracingService;\n+        }\n+        return null;\n     }\n \n-\n     /**\n-     * @return {@link OpenTracingService}\n+     * @return {@link OpenTracingService}, or null if the HK2 service couldn't be\n+     *         initialised.\n      */\n     public OpenTracingService getOpenTracingService() {\n-        checkInitialized();\n-        return openTracingService;\n+        if (checkInitialized()) {\n+            return openTracingService;\n+        }\n+        return null;\n     }\n \n-\n     /**\n      * @return {@link InvocationManager}\n      */\n     public InvocationManager getInvocationManager() {\n-        checkInitialized();\n-        return basicServiceLocator.getService(InvocationManager.class);\n+        if (checkInitialized()) {\n+            return invocationManager;\n+        }\n+        return null;\n     }\n \n-\n     /**\n-     * @return application name known to the actual {@link InvocationManager}.\n+     * @return application name known to the actual {@link InvocationManager}, or\n+     *         null if no invocation manager can be found.\n      */\n     public String getApplicationName() {\n-        final InvocationManager invocationManager = getInvocationManager();\n-        if (invocationManager == null) {\n-            return null;\n+        if (checkInitialized()) {\n+            return openTracingService.getApplicationName(invocationManager);\n         }\n-        final OpenTracingService otService = getOpenTracingService();\n-        return otService == null ? null : otService.getApplicationName(invocationManager);\n+        return null;\n     }\n \n-\n     /**\n-     * @return actually active {@link Tracer} for the current application.\n+     * @return actually active {@link Tracer} for the current application, or null\n+     *         if the tracing service is not available.\n      */\n     public Tracer getActiveTracer() {\n         final String applicationName = getApplicationName();\n-        if (applicationName == null) {\n+        if (applicationName == null || !checkInitialized()) {", "originalCommit": "e6f54ec72e74a715b7cf62ce3fb528173b543906", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQyNDA3NA==", "url": "https://github.com/payara/Payara/pull/4491#discussion_r379424074", "bodyText": "rename to isTracingAvailable and make it public.", "author": "dmatej", "createdAt": "2020-02-14T13:16:29Z", "path": "appserver/payara-appserver-modules/jaxrs-client-tracing/src/main/java/fish/payara/requesttracing/jaxrs/client/PayaraTracingServices.java", "diffHunk": "@@ -40,111 +40,117 @@\n \n package fish.payara.requesttracing.jaxrs.client;\n \n-import fish.payara.nucleus.requesttracing.RequestTracingService;\n-import fish.payara.opentracing.OpenTracingService;\n-\n-import io.opentracing.Tracer;\n-\n import org.glassfish.api.invocation.InvocationManager;\n+import org.glassfish.hk2.api.ServiceHandle;\n import org.glassfish.hk2.api.ServiceLocator;\n import org.glassfish.internal.api.Globals;\n \n+import fish.payara.nucleus.requesttracing.RequestTracingService;\n+import fish.payara.opentracing.OpenTracingService;\n+import io.opentracing.Tracer;\n+\n /**\n- * This is a class hiding internal mechanism of lookup of HK2 services.\n- * The lookup is lazy, done with first request, but this may be simply changed later.\n- * <p>\n- * The lazy lookup prevents problems with embedded distributions, when jersey lookups\n- * may detect filters in this package and try to use them before Payara started, which\n- * is not supported use case.\n+ * This is a class hiding internal mechanism of lookup of HK2 services. The\n+ * required services will be eagerly initialised using their service handles,\n+ * and throwing an exception if the handle is available but not the service\n+ * itself.\n  *\n  * @author David Matejcek\n  */\n public final class PayaraTracingServices {\n \n-    private static volatile boolean initialized;\n-\n-    private static ServiceLocator basicServiceLocator;\n-    private static RequestTracingService requestTracingService;\n-    private static OpenTracingService openTracingService;\n-\n-\n-    private static void checkInitialized() {\n-        if (initialized) {\n-            return;\n-        }\n-        synchronized (PayaraTracingServices.class) {\n-            if (initialized) {\n-                return;\n-            }\n-            basicServiceLocator = Globals.getStaticBaseServiceLocator();\n-            requestTracingService = basicServiceLocator.getService(RequestTracingService.class);\n-            openTracingService = basicServiceLocator.getService(OpenTracingService.class);\n-            initialized = true;\n-        }\n-    }\n-\n+    private final InvocationManager invocationManager;\n+    private final RequestTracingService requestTracingService;\n+    private final OpenTracingService openTracingService;\n \n     /**\n-     * @return default service locator, same as {@link Globals#getStaticBaseServiceLocator()}.\n+     * Initialise the tracing services if they are available.\n+     * \n+     * @throws RuntimeException if an exception occurs initialising the services.\n      */\n-    public ServiceLocator getBasicServiceLocator() {\n-        checkInitialized();\n-        return basicServiceLocator;\n-    }\n+    public PayaraTracingServices() {\n+        final ServiceLocator baseServiceLocator = Globals.getStaticBaseServiceLocator();\n \n+        requestTracingService = getFromServiceHandle(baseServiceLocator, RequestTracingService.class);\n+        openTracingService = getFromServiceHandle(baseServiceLocator, OpenTracingService.class);\n+        invocationManager = getFromServiceHandle(baseServiceLocator, InvocationManager.class);\n+    }\n \n     /**\n-     * @return {@link RequestTracingService}\n+     * @return {@link RequestTracingService}, or null if the HK2 service couldn't be\n+     *         initialised.\n      */\n     public RequestTracingService getRequestTracingService() {\n-        checkInitialized();\n-        return requestTracingService;\n+        if (checkInitialized()) {\n+            return requestTracingService;\n+        }\n+        return null;\n     }\n \n-\n     /**\n-     * @return {@link OpenTracingService}\n+     * @return {@link OpenTracingService}, or null if the HK2 service couldn't be\n+     *         initialised.\n      */\n     public OpenTracingService getOpenTracingService() {\n-        checkInitialized();\n-        return openTracingService;\n+        if (checkInitialized()) {\n+            return openTracingService;\n+        }\n+        return null;\n     }\n \n-\n     /**\n      * @return {@link InvocationManager}\n      */\n     public InvocationManager getInvocationManager() {\n-        checkInitialized();\n-        return basicServiceLocator.getService(InvocationManager.class);\n+        if (checkInitialized()) {\n+            return invocationManager;\n+        }\n+        return null;\n     }\n \n-\n     /**\n-     * @return application name known to the actual {@link InvocationManager}.\n+     * @return application name known to the actual {@link InvocationManager}, or\n+     *         null if no invocation manager can be found.\n      */\n     public String getApplicationName() {\n-        final InvocationManager invocationManager = getInvocationManager();\n-        if (invocationManager == null) {\n-            return null;\n+        if (checkInitialized()) {\n+            return openTracingService.getApplicationName(invocationManager);\n         }\n-        final OpenTracingService otService = getOpenTracingService();\n-        return otService == null ? null : otService.getApplicationName(invocationManager);\n+        return null;\n     }\n \n-\n     /**\n-     * @return actually active {@link Tracer} for the current application.\n+     * @return actually active {@link Tracer} for the current application, or null\n+     *         if the tracing service is not available.\n      */\n     public Tracer getActiveTracer() {\n         final String applicationName = getApplicationName();\n-        if (applicationName == null) {\n+        if (applicationName == null || !checkInitialized()) {\n             return null;\n         }\n-        final OpenTracingService otService = getOpenTracingService();\n-        if (otService == null) {\n-            return null;\n+        return openTracingService.getTracer(applicationName);\n+    }\n+\n+    /**\n+     * @return true if the Request Tracing services are available and have been\n+     *         initialised, or false if the services are not available.\n+     */\n+    private boolean checkInitialized() {", "originalCommit": "e6f54ec72e74a715b7cf62ce3fb528173b543906", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQyODk3MQ==", "url": "https://github.com/payara/Payara/pull/4491#discussion_r379428971", "bodyText": "This is wrong - autodiscoverable is the trap causing problems, Jersey will find it even without Payara runing and try to use it. So safe should be:\nfinal PayaraTracingServices services = new PayaraTracingServices();\nDeployment deployment = services.getDeployment(); // as other services\nif (deployment == null || deployment.getCurrentDeploymentContext() == null) {\n  return;\n}\n...\n\nnote: in fact the deployment will be a singleton instance of ApplicationLifecycle, says my Eclipse ...\nThis is about architecture and responsibilities - PayaraTracingServices is a border class, where on one side is Jersey and on the other is HK2. The border covers if it will provide those services or not, and Jersey then has no other dependency on HK2 services. This class has control and responsibility over it.", "author": "dmatej", "createdAt": "2020-02-14T13:28:13Z", "path": "appserver/payara-appserver-modules/microprofile/opentracing/src/main/java/fish/payara/microprofile/opentracing/jaxrs/JerseyOpenTracingAutoDiscoverable.java", "diffHunk": "@@ -58,7 +57,7 @@\n     @Override\n     public void configure(FeatureContext context) {\n         // Only register for application deployments (not the admin console)\n-        final ServiceLocator serviceLocator = new PayaraTracingServices().getBasicServiceLocator();\n+        final ServiceLocator serviceLocator = Globals.getStaticBaseServiceLocator();", "originalCommit": "e6f54ec72e74a715b7cf62ce3fb528173b543906", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQzMTQ5NA==", "url": "https://github.com/payara/Payara/pull/4491#discussion_r379431494", "bodyText": "This will start HK2 base service locator initialization. Don't use it. I hate Globals API and sooner or later I will delete that class, because I must always open it and look on it's content :-D\nBetter use new PayaraTracingServices().isTracingAvailable(). That should be safe (if Globals.getDefaultBaseServiceLocator() OR same getDefaultHabitat() returns null -> all services are null -> false)", "author": "dmatej", "createdAt": "2020-02-14T13:34:08Z", "path": "appserver/payara-appserver-modules/microprofile/opentracing/src/main/java/fish/payara/microprofile/opentracing/jaxrs/client/JaxrsClientBuilderDecorator.java", "diffHunk": "@@ -165,7 +164,7 @@ public Client build() {\n \n     private boolean requestTracingPresent() {\n         try {\n-            ServiceLocator locator = PAYARA_SERVICES.getBasicServiceLocator();\n+            ServiceLocator locator = Globals.getStaticBaseServiceLocator();", "originalCommit": "e6f54ec72e74a715b7cf62ce3fb528173b543906", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a201e8ce96b4925bab2a91a5ebfc9d6ac5450be0", "url": "https://github.com/payara/Payara/commit/a201e8ce96b4925bab2a91a5ebfc9d6ac5450be0", "message": "CUSTCOM-70 Fix JAXRS client with embedded dependency\n\nWhen Payara Embedded is used as a library rather than starting the\nembedded server, an exception will be thrown when using the JAX-RS\nclient caused by the request tracing service not having initialised.\n\nThe previous CUSTCOM-70 fix allowed a JAX-RS client request to be\nbuilt, but executing the request would still throw the same\nexception. This change allows the request to be executed as well.\n\nAdditional references to service locators were restricted to the\nPayaraTracingServices class to coordinate all service discovery in\nrequest tracing. This should help prevent future service locator related\nproblems in tracing, or at least make them easier to fix.\n\nSigned-off-by: Matt Gill <matthew.gill@live.co.uk>", "committedDate": "2020-02-14T14:14:17Z", "type": "commit"}, {"oid": "ca4be10e46813e03aeac36bba662732359dc9c56", "url": "https://github.com/payara/Payara/commit/ca4be10e46813e03aeac36bba662732359dc9c56", "message": "CUSTCOM-70 Create listener for REST client test\n\nThe embedded rest client test won't work without a server running. This\nchange creates a simple Grizzly server on a random available port which\nwill be called by the REST client.\n\nSigned-off-by: Matt Gill <matthew.gill@live.co.uk>", "committedDate": "2020-02-14T14:16:04Z", "type": "commit"}, {"oid": "ca4be10e46813e03aeac36bba662732359dc9c56", "url": "https://github.com/payara/Payara/commit/ca4be10e46813e03aeac36bba662732359dc9c56", "message": "CUSTCOM-70 Create listener for REST client test\n\nThe embedded rest client test won't work without a server running. This\nchange creates a simple Grizzly server on a random available port which\nwill be called by the REST client.\n\nSigned-off-by: Matt Gill <matthew.gill@live.co.uk>", "committedDate": "2020-02-14T14:16:04Z", "type": "forcePushed"}]}