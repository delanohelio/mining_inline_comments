{"pr_number": 4694, "pr_title": "APPSERV-149 Add Command to Generate Self-Signed Certificate", "pr_createdAt": "2020-06-02T16:42:20Z", "pr_url": "https://github.com/payara/Payara/pull/4694", "timeline": [{"oid": "4c55ac404b58f4dec46280fec2e662ffd1efdd8b", "url": "https://github.com/payara/Payara/commit/4c55ac404b58f4dec46280fec2e662ffd1efdd8b", "message": "APPSERV-149 Initial asadmin commands for generating self-signed certs", "committedDate": "2020-05-27T14:54:38Z", "type": "commit"}, {"oid": "66693c7f52ef0c26d6a0f949de41df0330cebb83", "url": "https://github.com/payara/Payara/commit/66693c7f52ef0c26d6a0f949de41df0330cebb83", "message": "APPSERV-149 Move local instance command under original command", "committedDate": "2020-05-27T14:55:05Z", "type": "commit"}, {"oid": "d4c4aaf472eec07c933b2ec0a88d0f94b43e01c3", "url": "https://github.com/payara/Payara/commit/d4c4aaf472eec07c933b2ec0a88d0f94b43e01c3", "message": "APPSERV-149 Remove unnecessary reload parameter", "committedDate": "2020-05-27T14:55:11Z", "type": "commit"}, {"oid": "b5ae88989c9672fd3ea631e18dfdb7d0813e6aff", "url": "https://github.com/payara/Payara/commit/b5ae88989c9672fd3ea631e18dfdb7d0813e6aff", "message": "APPSERV-149 Add support for password aliases, remove redundant code, and add javadoc", "committedDate": "2020-05-29T13:45:24Z", "type": "commit"}, {"oid": "03620e048a2e2b41b34fecf9a0ee012281b55336", "url": "https://github.com/payara/Payara/commit/03620e048a2e2b41b34fecf9a0ee012281b55336", "message": "APPSERV-149 Fix copyright and some formatting", "committedDate": "2020-06-01T07:59:50Z", "type": "commit"}, {"oid": "e8aa19953948c595af5ed8267b876fa51dfa7952", "url": "https://github.com/payara/Payara/commit/e8aa19953948c595af5ed8267b876fa51dfa7952", "message": "APPSERV-149 Add help text for command", "committedDate": "2020-06-01T14:40:29Z", "type": "commit"}, {"oid": "b8f3bd918f3c1344db0267625093e3f534c84d49", "url": "https://github.com/payara/Payara/commit/b8f3bd918f3c1344db0267625093e3f534c84d49", "message": "APPSERV-149 Move to extras and remove from featureset and packager", "committedDate": "2020-06-02T15:01:09Z", "type": "commit"}, {"oid": "ba57e865db8de429fb07c224de8d442479dfdf98", "url": "https://github.com/payara/Payara/commit/ba57e865db8de429fb07c224de8d442479dfdf98", "message": "APPSERV-149 Move under BuildExtras profile", "committedDate": "2020-06-02T15:03:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE2NjY4NA==", "url": "https://github.com/payara/Payara/pull/4694#discussion_r435166684", "bodyText": "domainName0 - is that intentional?", "author": "jbee", "createdAt": "2020-06-04T10:55:31Z", "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/admin/GenerateSelfSignedCertificateCommand.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.certificate.management.admin;\n+\n+import com.sun.enterprise.admin.cli.CLICommand;\n+import com.sun.enterprise.admin.cli.CLIConstants;\n+import com.sun.enterprise.admin.cli.Environment;\n+import com.sun.enterprise.admin.cli.ProgramOptions;\n+import com.sun.enterprise.admin.cli.cluster.SynchronizeInstanceCommand;\n+import com.sun.enterprise.admin.servermgmt.KeystoreManager;\n+import com.sun.enterprise.admin.servermgmt.RepositoryException;\n+import com.sun.enterprise.admin.servermgmt.cli.LocalDomainCommand;\n+import com.sun.enterprise.universal.xml.MiniXmlParser;\n+import com.sun.enterprise.universal.xml.MiniXmlParserException;\n+import com.sun.enterprise.util.SystemPropertyConstants;\n+import fish.payara.certificate.management.CertificateManagementUtils;\n+import org.glassfish.api.Param;\n+import org.glassfish.api.admin.CommandException;\n+import org.glassfish.config.support.TranslatedConfigView;\n+import org.glassfish.hk2.api.PerLookup;\n+import org.jvnet.hk2.annotations.Service;\n+\n+import java.io.File;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CLI command for generating self-signed certificates and placing them in an instance or listener's key\n+ * and trust stores.\n+ *\n+ * @author Andrew Pielage\n+ */\n+@Service(name = \"generate-self-signed-certificate\")\n+@PerLookup\n+public class GenerateSelfSignedCertificateCommand extends LocalDomainCommand {\n+\n+    private static final Logger logger = Logger.getLogger(CLICommand.class.getPackage().getName());\n+\n+    @Param(name = \"domain_name\", optional = true)\n+    private String domainName0;", "originalCommit": "ba57e865db8de429fb07c224de8d442479dfdf98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3NDUxMw==", "url": "https://github.com/payara/Payara/pull/4694#discussion_r435274513", "bodyText": "Yes, it mirrors the parameter naming used in other commands that inherit from LocalDomainCommand.", "author": "Pandrex247", "createdAt": "2020-06-04T13:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE2NjY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4ODY0Ng==", "url": "https://github.com/payara/Payara/pull/4694#discussion_r435188646", "bodyText": "Extending the util has a bit of a taste. I'd prefer using static method imports to use the util methods without qualified access.", "author": "jbee", "createdAt": "2020-06-04T11:39:06Z", "path": "appserver/extras/certificate-management/src/test/java/fish/payara/certificate/management/admin/GenerateSelfSignedCertificateCommandTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.certificate.management.admin;\n+\n+import fish.payara.certificate.management.CertificateManagementUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class GenerateSelfSignedCertificateCommandTest extends CertificateManagementUtils {", "originalCommit": "ba57e865db8de429fb07c224de8d442479dfdf98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIzMTUwMg==", "url": "https://github.com/payara/Payara/pull/4694#discussion_r435231502", "bodyText": "Testing suggests that this should be if (keystorePassword != null && keystorePassword.length > 0) {", "author": "jbee", "createdAt": "2020-06-04T12:57:09Z", "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/admin/GenerateSelfSignedCertificateCommand.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.certificate.management.admin;\n+\n+import com.sun.enterprise.admin.cli.CLICommand;\n+import com.sun.enterprise.admin.cli.CLIConstants;\n+import com.sun.enterprise.admin.cli.Environment;\n+import com.sun.enterprise.admin.cli.ProgramOptions;\n+import com.sun.enterprise.admin.cli.cluster.SynchronizeInstanceCommand;\n+import com.sun.enterprise.admin.servermgmt.KeystoreManager;\n+import com.sun.enterprise.admin.servermgmt.RepositoryException;\n+import com.sun.enterprise.admin.servermgmt.cli.LocalDomainCommand;\n+import com.sun.enterprise.universal.xml.MiniXmlParser;\n+import com.sun.enterprise.universal.xml.MiniXmlParserException;\n+import com.sun.enterprise.util.SystemPropertyConstants;\n+import fish.payara.certificate.management.CertificateManagementUtils;\n+import org.glassfish.api.Param;\n+import org.glassfish.api.admin.CommandException;\n+import org.glassfish.config.support.TranslatedConfigView;\n+import org.glassfish.hk2.api.PerLookup;\n+import org.jvnet.hk2.annotations.Service;\n+\n+import java.io.File;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CLI command for generating self-signed certificates and placing them in an instance or listener's key\n+ * and trust stores.\n+ *\n+ * @author Andrew Pielage\n+ */\n+@Service(name = \"generate-self-signed-certificate\")\n+@PerLookup\n+public class GenerateSelfSignedCertificateCommand extends LocalDomainCommand {\n+\n+    private static final Logger logger = Logger.getLogger(CLICommand.class.getPackage().getName());\n+\n+    @Param(name = \"domain_name\", optional = true)\n+    private String domainName0;\n+\n+    @Param(name = \"distinguishedname\", alias = \"dn\")\n+    private String dn;\n+\n+    @Param(name = \"alternativenames\", optional = true, alias = \"altnames\", separator = ';')\n+    private String[] altnames;\n+\n+    @Param(name = \"listener\", optional = true)\n+    private String listener;\n+\n+    @Param(name = \"target\", optional = true, defaultValue = SystemPropertyConstants.DAS_SERVER_NAME)\n+    private String target;\n+\n+    @Param(name = \"alias\", primary = true)\n+    private String alias;\n+\n+    private File keystore;\n+    private File truststore;\n+    private char[] keystorePassword;\n+    private char[] truststorePassword;\n+    private char[] masterPassword;\n+\n+    @Override\n+    protected void validate() throws CommandException {\n+        setDomainName(domainName0);\n+        super.validate();\n+    }\n+\n+    @Override\n+    protected int executeCommand() throws CommandException {\n+        // If we're targetting an instance that isn't the DAS, use a different command\n+        if (target != null && !target.equals(SystemPropertyConstants.DAS_SERVER_NAME)) {\n+            GenerateSelfSignedCertificateLocalInstanceCommand localInstanceCommand =\n+                    new GenerateSelfSignedCertificateLocalInstanceCommand(programOpts, env);\n+            localInstanceCommand.validate();\n+            return localInstanceCommand.executeCommand();\n+        }\n+\n+        // Parse the location of the key and trust stores, and the passwords required to access them\n+        try {\n+            MiniXmlParser parser = new MiniXmlParser(getDomainXml(), target);\n+            keystore = CertificateManagementUtils.resolveKeyStore(parser, listener, getDomainRootDir());\n+            truststore = CertificateManagementUtils.resolveTrustStore(parser, listener, getDomainRootDir());\n+            getStorePasswords(parser, listener, getDomainRootDir());\n+        } catch (MiniXmlParserException miniXmlParserException) {\n+            throw new CommandException(\"Error parsing domain.xml\", miniXmlParserException);\n+        }\n+\n+        // Run keytool command to generate self-signed cert and place in keystore\n+        try {\n+            addToKeystore();\n+        } catch (CommandException ce) {\n+            return CLIConstants.ERROR;\n+        }\n+\n+        try {\n+            addToTruststore();\n+        } catch (CommandException ce) {\n+            return CLIConstants.WARNING;\n+        }\n+\n+        return CLIConstants.SUCCESS;\n+    }\n+\n+    /**\n+     * Gets the passwords for the key and trust store.\n+     *\n+     * @param parser    The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener  The name of the HTTP or IIOP listener to get the key or trust store passwords from. Can be null.\n+     * @param serverDir The directory of the target instance, used for accessing the domain-passwords store\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     * @throws CommandException       If there's an issue getting the master password\n+     */\n+    private void getStorePasswords(MiniXmlParser parser, String listener, File serverDir)\n+            throws MiniXmlParserException, CommandException {\n+        if (listener != null) {\n+            // Check if listener has a password set\n+            keystorePassword = CertificateManagementUtils.getPasswordFromListener(parser, listener, \"key-store-password\");\n+            truststorePassword = CertificateManagementUtils.getPasswordFromListener(parser, listener, \"trust-store-password\");\n+        }\n+\n+        if (keystorePassword != null || keystorePassword.length > 0) {", "originalCommit": "ba57e865db8de429fb07c224de8d442479dfdf98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3MDg5NQ==", "url": "https://github.com/payara/Payara/pull/4694#discussion_r435270895", "bodyText": "This causes a NPE when listenerAttributes does not have a password attribute which I apparently managed to create as test case. I suspect the same applies to the assignment in 312.", "author": "jbee", "createdAt": "2020-06-04T13:48:43Z", "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/CertificateManagementUtils.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.certificate.management;\n+\n+import com.sun.enterprise.universal.xml.MiniXmlParser;\n+import com.sun.enterprise.universal.xml.MiniXmlParserException;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+import static com.sun.enterprise.util.StringUtils.ok;\n+\n+/**\n+ * Helper methods for various Certificate Management commands.\n+ *\n+ * @author Andrew Pielage\n+ */\n+public class CertificateManagementUtils {\n+\n+    public static final String DEFAULT_KEYSTORE = \"${com.sun.aas.instanceRoot}\"\n+            + File.separator + \"config\" + File.separator + \"keystore.jks\";\n+    public static final String DEFAULT_TRUSTSTORE = \"${com.sun.aas.instanceRoot}\"\n+            + File.separator + \"config\" + File.separator + \"cacerts.jks\";\n+\n+    /**\n+     * Determines and returns the key store.\n+     *\n+     * @param parser      The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener    The name of the HTTP or IIOP listener to get the key store from. Can be null.\n+     * @param instanceDir The directory of the target instance, used for relative paths\n+     * @return The key store of the target\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     */\n+    public static File resolveKeyStore(MiniXmlParser parser, String listener, File instanceDir)\n+            throws MiniXmlParserException {\n+        File keystore = null;\n+        if (listener != null) {\n+            // Check if listener is an HTTP listener\n+            keystore = getStoreFromHttpListeners(parser, listener, \"key-store\", instanceDir);\n+\n+            if (keystore == null) {\n+                // Check if listener is an IIOP listener\n+                keystore = getStoreFromIiopListeners(parser, listener, \"key-store\", instanceDir);\n+            }\n+        }\n+\n+        // Default to getting it from the JVM options if no non-default value found\n+        if (keystore == null) {\n+            keystore = getStoreFromJvmOptions(parser, \"keyStore\", instanceDir);\n+        }\n+\n+        // If it's STILL null, just go with default\n+        if (keystore == null) {\n+            keystore = new File(DEFAULT_KEYSTORE);\n+        }\n+\n+        return keystore;\n+    }\n+\n+    /**\n+     * Determines and returns the trust store.\n+     *\n+     * @param parser      The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener    The name of the HTTP or IIOP listener to get the trust store from. Can be null.\n+     * @param instanceDir The directory of the target instance, used for relative paths\n+     * @return The trust store of the target\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     */\n+    public static File resolveTrustStore(MiniXmlParser parser, String listener, File instanceDir)\n+            throws MiniXmlParserException {\n+        File truststore = null;\n+        if (listener != null) {\n+            // Check if listener is an HTTP listener\n+            truststore = getStoreFromHttpListeners(parser, listener, \"trust-store\", instanceDir);\n+\n+            if (truststore == null) {\n+                // Check if listener is an IIOP listener\n+                truststore = getStoreFromIiopListeners(parser, listener, \"trust-store\", instanceDir);\n+            }\n+        }\n+\n+        // Default to getting it from the JVM options if no non-default value found\n+        if (truststore == null) {\n+            truststore = getStoreFromJvmOptions(parser, \"trustStore\", instanceDir);\n+        }\n+\n+        // If it's STILL null, just go with default\n+        if (truststore == null) {\n+            truststore = new File(DEFAULT_TRUSTSTORE);\n+        }\n+\n+        return truststore;\n+    }\n+\n+    /**\n+     * Gets the store from a target HTTP listener\n+     *\n+     * @param parser         The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener       The name of the HTTP listener to get the store from.\n+     * @param storeAttribute The name of the store attribute to get (should be \"key-store\" or \"trust-store\")\n+     * @param instanceDir    The directory of the target instance, used for relative paths\n+     * @return The store of the target, or null if no matching listener or no store configured\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     */\n+    private static File getStoreFromHttpListeners(MiniXmlParser parser, String listener,\n+            String storeAttribute, File instanceDir) throws MiniXmlParserException {\n+        for (Map<String, String> listenerAttributes : parser.getProtocolAttributes()) {\n+            if (listenerAttributes.get(\"name\").equals(listener)) {\n+                // Get the keystore from the listener if it has a custom one\n+                return getStoreFromListenerAttribute(listenerAttributes.get(storeAttribute), instanceDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the store from a target IIOP listener\n+     *\n+     * @param parser         The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener       The name of the IIOP listener to get the store from.\n+     * @param storeAttribute The name of the store attribute to get (should be \"key-store\" or \"trust-store\")\n+     * @param instanceDir    The directory of the target instance, used for relative paths\n+     * @return The store of the target, or null if no matching listener or no store configured\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     */\n+    private static File getStoreFromIiopListeners(MiniXmlParser parser, String listener,\n+            String storeAttribute, File instanceDir) throws MiniXmlParserException {\n+        for (Map<String, String> listenerAttributes : parser.getIiopSslAttributes()) {\n+            if (listenerAttributes.get(\"id\").equals(listener)) {\n+                // Get the keystore from the listener if it has a custom one\n+                return getStoreFromListenerAttribute(listenerAttributes.get(storeAttribute), instanceDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Helper method that returns the store from a target listener's config attribute,\n+     * making any relative paths absolute.\n+     *\n+     * @param storePath   The path to the store to return as a {@link File}\n+     * @param instanceDir The instance directory, used for making relative paths absolute\n+     * @return The absolute path of the target store, or null if no store given\n+     */\n+    private static File getStoreFromListenerAttribute(String storePath, File instanceDir) {\n+        if (!ok(storePath)) {\n+            return null;\n+        }\n+\n+        File store = new File(storePath);\n+        if (!store.isAbsolute()) {\n+            store = new File(instanceDir.getAbsolutePath() + File.separator + store.getPath());\n+        }\n+\n+        return store;\n+    }\n+\n+    /**\n+     * Gets the store from a target config's JVM options\n+     *\n+     * @param parser      The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param storeName   The JVM option name of the store (should be keyStore or trustStore)\n+     * @param instanceDir The instance directory, used for SystemProperty substitution\n+     * @return The absolute path of the target store\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     */\n+    private static File getStoreFromJvmOptions(MiniXmlParser parser, String storeName, File instanceDir)\n+            throws MiniXmlParserException {\n+        for (MiniXmlParser.JvmOption jvmOption : parser.getJvmOptions()) {\n+            if (jvmOption.toString().startsWith(\"-Djavax.net.ssl.\" + storeName + \"=\")) {\n+                return new File(jvmOption.toString().split(\"=\")[1]\n+                        .replace(\"${com.sun.aas.instanceRoot}\", instanceDir.getAbsolutePath()));\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Constructs the command to pass to keytool for creating a self-signed cert\n+     *\n+     * @param keystore The key store to add the certificate to\n+     * @param password The password for the key store\n+     * @param alias    The alias of the certificate\n+     * @param dname    The distinguished name of the certificate\n+     * @param altnames The alternative names of the certificate\n+     * @return A String array to pass to {@link com.sun.enterprise.admin.servermgmt.KeystoreManager.KeytoolExecutor}\n+     */\n+    public static String[] constructGenerateCertKeytoolCommand(File keystore, char[] password,\n+            String alias, String dname, String[] altnames) {\n+        String[] keytoolCmd = new String[]{\"-genkeypair\", \"-keyalg\", \"RSA\", \"-keystore\", keystore.getAbsolutePath(),\n+                \"-alias\", alias, \"-dname\", dname,\n+                \"-validity\", \"365\", \"-keypass\", new String(password), \"-storepass\", new String(password)};\n+\n+        if (altnames != null && altnames.length != 0) {\n+            keytoolCmd = addSubjectAlternativeNames(keytoolCmd, altnames);\n+        }\n+\n+        return keytoolCmd;\n+    }\n+\n+    /**\n+     * Helper method that formats the String array of alternative names into the format that the keytool expects.\n+     *\n+     * @param keytoolCmd       The String array containing the keytool command before alternative names have been added.\n+     * @param alternativeNames The String array containing the alternatives names\n+     * @return A String array of the original keytool command with the alternative names added\n+     */\n+    protected static String[] addSubjectAlternativeNames(String[] keytoolCmd, String[] alternativeNames) {\n+        // Create a new array to make room for the extra commands\n+        String[] expandedKeytoolCmd = new String[keytoolCmd.length + 2];\n+        System.arraycopy(keytoolCmd, 0, expandedKeytoolCmd, 0, keytoolCmd.length);\n+\n+        int i = keytoolCmd.length;\n+        expandedKeytoolCmd[i] = \"-ext\";\n+        expandedKeytoolCmd[i + 1] = \"SAN=\";\n+\n+        for (String altName : alternativeNames) {\n+            // Check if the altname was provided without any additional info, assuming it's DNS if so\n+            if (!altName.contains(\",\") && !altName.contains(\":\")) {\n+                expandedKeytoolCmd[i + 1] += \"DNS:\" + altName;\n+            } else {\n+                expandedKeytoolCmd[i + 1] += altName;\n+            }\n+            expandedKeytoolCmd[i + 1] += \",\";\n+        }\n+\n+        // Remove trailing comma\n+        expandedKeytoolCmd[i + 1] = expandedKeytoolCmd[i + 1].substring(0, expandedKeytoolCmd[i + 1].length() - 1);\n+\n+        return expandedKeytoolCmd;\n+    }\n+\n+    /**\n+     * Constructs the command to pass to keytool for adding the self-signed cert to the trust store\n+     *\n+     * @param keystore           The target key store that the certificate was added to\n+     * @param truststore         The target trust store to add the certificate to\n+     * @param keystorePassword   The password for the key store\n+     * @param truststorePassword The password for the trust store\n+     * @param alias              The alias of the certificate\n+     * @return A String array to pass to {@link com.sun.enterprise.admin.servermgmt.KeystoreManager.KeytoolExecutor}\n+     */\n+    public static String[] constructImportCertKeytoolCommand(File keystore, File truststore, char[] keystorePassword,\n+            char[] truststorePassword, String alias) {\n+        String[] keytoolCmd = new String[]{\"-importkeystore\", \"-srckeystore\", keystore.getAbsolutePath(),\n+                \"-destkeystore\", truststore.getAbsolutePath(), \"-srcalias\", alias, \"-destalias\", alias,\n+                \"-srcstorepass\", new String(keystorePassword), \"-deststorepass\", new String(truststorePassword),\n+                \"-srckeypass\", new String(keystorePassword), \"-destkeypass\", new String(truststorePassword),\n+                \"-noprompt\"};\n+\n+        return keytoolCmd;\n+    }\n+\n+    /**\n+     * @param parser    The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener  The name of the listener to get the password from.\n+     * @param attribute The name of the store password attribute (should be key-store-password or trust-store-password)\n+     * @return A char array containing the password of the target listener, or null if no matches or password found\n+     * @throws MiniXmlParserException if there's an issue reading the domain.xml\n+     */\n+    public static char[] getPasswordFromListener(MiniXmlParser parser, String listener, String attribute)\n+            throws MiniXmlParserException {\n+        char[] password = null;\n+        for (Map<String, String> listenerAttributes : parser.getProtocolAttributes()) {\n+            if (listenerAttributes.get(\"name\").equals(listener)) {\n+                // Get the keystore from the listener if it has a custom one\n+                password = listenerAttributes.get(attribute).toCharArray();", "originalCommit": "ba57e865db8de429fb07c224de8d442479dfdf98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a1107cf25c8a8dc4de2793519934af758eaf5d76", "url": "https://github.com/payara/Payara/commit/a1107cf25c8a8dc4de2793519934af758eaf5d76", "message": "APPSERV-149 Fix NPEs and remove test inheritance", "committedDate": "2020-06-04T14:59:22Z", "type": "commit"}]}