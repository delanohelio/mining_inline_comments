{"pr_number": 4602, "pr_title": "APPSERV-114 Addresses possible sources of Race Conditions in InvocationManager", "pr_createdAt": "2020-04-02T09:28:30Z", "pr_url": "https://github.com/payara/Payara/pull/4602", "timeline": [{"oid": "4bb75031fd57af04cb2222d5918788d782272ea1", "url": "https://github.com/payara/Payara/commit/4bb75031fd57af04cb2222d5918788d782272ea1", "message": "APPSERV-114 cleanup invocation handlers", "committedDate": "2020-04-01T10:05:08Z", "type": "commit"}, {"oid": "b585421ebe9ca2307a0533f353f7c0ba4990a4a3", "url": "https://github.com/payara/Payara/commit/b585421ebe9ca2307a0533f353f7c0ba4990a4a3", "message": "APPSERV-114 use of concurrent collections in InvocationManagerImpl; adds tests for invocation frame logic", "committedDate": "2020-04-02T08:42:31Z", "type": "commit"}, {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99", "url": "https://github.com/payara/Payara/commit/1eca37c1479fc38ea61aa667b5393b26b3218a99", "message": "APPSERV-114 adds tests for AppEnvironment and WebServiceMethod stacks", "committedDate": "2020-04-02T09:02:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE3ODE5OA==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r402178198", "bodyText": "NB: while the use of thread local should ensure that multiple calls to getCurrentInvocation() should return the same instance it is better to not take changes and do it once. Also improves readability.", "author": "jbee", "createdAt": "2020-04-02T09:32:00Z", "path": "appserver/payara-appserver-modules/microprofile/metrics/src/main/java/fish/payara/microprofile/metrics/MetricsService.java", "diffHunk": "@@ -418,15 +419,16 @@ private void deregisterApplication(String applicationName) {\n     public String getApplicationName() {\n         InvocationManager invocationManager = Globals.getDefaultBaseServiceLocator()\n                 .getService(InvocationManager.class);\n-        if (invocationManager.getCurrentInvocation() == null) {", "originalCommit": "1eca37c1479fc38ea61aa667b5393b26b3218a99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4ODE0OQ==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r402188149", "bodyText": "NB. Using HashMap here is definitely not thread-safe but should be. But is is hard to see how this can cause the observed issues. However, we do talk about multi-threading so everything is possible :D", "author": "jbee", "createdAt": "2020-04-02T09:48:30Z", "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();", "originalCommit": "1eca37c1479fc38ea61aa667b5393b26b3218a99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4ODczNw==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r402188737", "bodyText": "NB. Replacing Stack here is more of a modernisation to avoid sychronized in favour of CAS based synchronisation.", "author": "jbee", "createdAt": "2020-04-02T09:49:30Z", "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);", "originalCommit": "1eca37c1479fc38ea61aa667b5393b26b3218a99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5MDkxOA==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r402190918", "bodyText": "NB. Missing try-finally here to make sure the frames.addLast(invocation); will definitely happen is my best guess on what might have caused the issue observed,", "author": "jbee", "createdAt": "2020-04-02T09:53:11Z", "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();\n-\n-    private final ComponentInvocationHandler[] invHandlers;\n+    private final InheritableThreadLocal<InvocationFrames> framesByThread;\n+    private final ThreadLocal<Deque<ApplicationEnvironment>> appEnvironments = withInitial(ConcurrentLinkedDeque::new);\n+    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ConcurrentLinkedDeque::new);\n+    private final ConcurrentMap<ComponentInvocationType, ListComponentInvocationHandler> typeHandlers = new ConcurrentHashMap<>();\n+    private final ComponentInvocationHandler allTypesHandler;\n \n     public InvocationManagerImpl() {\n-        this(null);\n+        this((ComponentInvocationHandler) null);\n+    }\n+\n+    public InvocationManagerImpl(ComponentInvocationHandler... handlers) {\n+        this(Arrays.asList(handlers));\n     }\n \n     @Inject\n     private InvocationManagerImpl(@Optional IterableProvider<ComponentInvocationHandler> handlers) {\n-        if (handlers == null) {\n-            invHandlers = null;\n-        } else {\n-            LinkedList<ComponentInvocationHandler> localHandlers = new LinkedList<ComponentInvocationHandler>();\n-            for (ComponentInvocationHandler handler : handlers) {\n-                localHandlers.add(handler);\n-            }\n+        this((Iterable<ComponentInvocationHandler>) handlers);\n+    }\n \n-            if (localHandlers.size() > 0) {\n-                invHandlers = localHandlers.toArray(new ComponentInvocationHandler[localHandlers.size()]);\n-            } else {\n-                invHandlers = null;\n-            }\n-        }\n+    private InvocationManagerImpl(Iterable<ComponentInvocationHandler> handlers) {\n+        this.allTypesHandler = initInvocationHandlers(handlers);\n \n-        frames = new InheritableThreadLocal<InvocationArray<ComponentInvocation>>() {\n+        framesByThread = new InheritableThreadLocal<InvocationFrames>() {\n \n-            protected InvocationArray<ComponentInvocation> initialValue() {\n-                return new InvocationArray<>();\n+            @Override\n+            protected InvocationFrames initialValue() {\n+                return new InvocationFrames();\n             }\n \n-            protected InvocationArray<ComponentInvocation> childValue(InvocationArray<ComponentInvocation> parentValue) {\n+            @Override\n+            protected InvocationFrames childValue(InvocationFrames parentValue) {\n                 return computeChildTheadInvocation(parentValue);\n             }\n         };\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+    private static ComponentInvocationHandler initInvocationHandlers(Iterable<ComponentInvocationHandler> handlers) {\n+        if (handlers == null) {\n+            return null;\n+        }\n+        List<ComponentInvocationHandler> hs = new ArrayList<>();\n+        handlers.forEach(hs::add);\n+        if (hs.isEmpty()) {\n+            return null;\n+        }\n+        if (hs.size() == 1) {\n+            return hs.get(0);\n+        }\n+        return new ListComponentInvocationHandler(hs);\n+    }\n+\n     @Override\n     public void setThreadInheritableInvocation(List<? extends ComponentInvocation> parentValue) {\n-        frames.set(computeChildTheadInvocation((InvocationArray<ComponentInvocation>) parentValue));\n+        framesByThread.set(computeChildTheadInvocation(InvocationFrames.valueOf(parentValue)));\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void preInvoke(T invocation) throws InvocationException {\n \n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(SERVICE_STARTUP);\n+            frames.setState(SERVICE_STARTUP);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        ComponentInvocation previousInvocation = beforeSize > 0 ? invocationArray.get(beforeSize - 1) : null;\n-\n-        // If ejb call EJBSecurityManager, for servlet call RealmAdapter\n-        ComponentInvocationType invocationType = invocation.getInvocationType();\n+        ComponentInvocation prev = frames.peekLast();\n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.beforePreInvoke(invocationType, previousInvocation, invocation);\n+        try {", "originalCommit": "1eca37c1479fc38ea61aa667b5393b26b3218a99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5NTUzNQ==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r402195535", "bodyText": "NB. You might have noticed that invocation is passed to afterPostInvoke instead of curInv. I believe this is just a inconsistency in the chosen way to express the logic. At this point curInv is (or really should be) invocation. To avoid any future confusion I unified it to use invocation everywhere as it is done in preInvoke and as I think it makes most sense as this is what is passed to the method as \"current\". It is unfortunate how the API was designed and that it leaves room for inconsistencies like calling postInvoke with a different value then preInvoke. postInvoke really should not have had an argument as the current is that pushed to the stack when invoking preInvoke. Or the API should have made clear that the argument is only passed to postInvoke to verify that the nesting is correct and that it indeed is the current top of the stack.", "author": "jbee", "createdAt": "2020-04-02T10:00:40Z", "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();\n-\n-    private final ComponentInvocationHandler[] invHandlers;\n+    private final InheritableThreadLocal<InvocationFrames> framesByThread;\n+    private final ThreadLocal<Deque<ApplicationEnvironment>> appEnvironments = withInitial(ConcurrentLinkedDeque::new);\n+    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ConcurrentLinkedDeque::new);\n+    private final ConcurrentMap<ComponentInvocationType, ListComponentInvocationHandler> typeHandlers = new ConcurrentHashMap<>();\n+    private final ComponentInvocationHandler allTypesHandler;\n \n     public InvocationManagerImpl() {\n-        this(null);\n+        this((ComponentInvocationHandler) null);\n+    }\n+\n+    public InvocationManagerImpl(ComponentInvocationHandler... handlers) {\n+        this(Arrays.asList(handlers));\n     }\n \n     @Inject\n     private InvocationManagerImpl(@Optional IterableProvider<ComponentInvocationHandler> handlers) {\n-        if (handlers == null) {\n-            invHandlers = null;\n-        } else {\n-            LinkedList<ComponentInvocationHandler> localHandlers = new LinkedList<ComponentInvocationHandler>();\n-            for (ComponentInvocationHandler handler : handlers) {\n-                localHandlers.add(handler);\n-            }\n+        this((Iterable<ComponentInvocationHandler>) handlers);\n+    }\n \n-            if (localHandlers.size() > 0) {\n-                invHandlers = localHandlers.toArray(new ComponentInvocationHandler[localHandlers.size()]);\n-            } else {\n-                invHandlers = null;\n-            }\n-        }\n+    private InvocationManagerImpl(Iterable<ComponentInvocationHandler> handlers) {\n+        this.allTypesHandler = initInvocationHandlers(handlers);\n \n-        frames = new InheritableThreadLocal<InvocationArray<ComponentInvocation>>() {\n+        framesByThread = new InheritableThreadLocal<InvocationFrames>() {\n \n-            protected InvocationArray<ComponentInvocation> initialValue() {\n-                return new InvocationArray<>();\n+            @Override\n+            protected InvocationFrames initialValue() {\n+                return new InvocationFrames();\n             }\n \n-            protected InvocationArray<ComponentInvocation> childValue(InvocationArray<ComponentInvocation> parentValue) {\n+            @Override\n+            protected InvocationFrames childValue(InvocationFrames parentValue) {\n                 return computeChildTheadInvocation(parentValue);\n             }\n         };\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+    private static ComponentInvocationHandler initInvocationHandlers(Iterable<ComponentInvocationHandler> handlers) {\n+        if (handlers == null) {\n+            return null;\n+        }\n+        List<ComponentInvocationHandler> hs = new ArrayList<>();\n+        handlers.forEach(hs::add);\n+        if (hs.isEmpty()) {\n+            return null;\n+        }\n+        if (hs.size() == 1) {\n+            return hs.get(0);\n+        }\n+        return new ListComponentInvocationHandler(hs);\n+    }\n+\n     @Override\n     public void setThreadInheritableInvocation(List<? extends ComponentInvocation> parentValue) {\n-        frames.set(computeChildTheadInvocation((InvocationArray<ComponentInvocation>) parentValue));\n+        framesByThread.set(computeChildTheadInvocation(InvocationFrames.valueOf(parentValue)));\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void preInvoke(T invocation) throws InvocationException {\n \n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(SERVICE_STARTUP);\n+            frames.setState(SERVICE_STARTUP);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        ComponentInvocation previousInvocation = beforeSize > 0 ? invocationArray.get(beforeSize - 1) : null;\n-\n-        // If ejb call EJBSecurityManager, for servlet call RealmAdapter\n-        ComponentInvocationType invocationType = invocation.getInvocationType();\n+        ComponentInvocation prev = frames.peekLast();\n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.beforePreInvoke(invocationType, previousInvocation, invocation);\n+        try {\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invocationType);\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().beforePreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        // Push this invocation on the stack\n-        invocationArray.add(invocation);\n+        } finally {\n+            // Push this invocation on the stack\n+            frames.addLast(invocation);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (allTypesHandler != null) {\n+                allTypesHandler.afterPreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.afterPreInvoke(type, prev, invocation);\n             }\n         }\n-\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void postInvoke(T invocation) throws InvocationException {\n-\n-        // Get this thread's ArrayList\n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(UN_INITIALIZED);\n+            frames.setState(UN_INITIALIZED);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        if (beforeSize == 0) {\n+        Iterator<ComponentInvocation> iter = frames.descendingIterator();\n+        if (!iter.hasNext()) {\n             throw new InvocationException();\n         }\n \n-        ComponentInvocation prevInv = beforeSize > 1 ? invocationArray.get(beforeSize - 2) : null;\n-        ComponentInvocation curInv = invocationArray.get(beforeSize - 1);\n+        iter.next(); // the last is the current is \"invocation\"\n+        ComponentInvocation prev = iter.hasNext() ? iter.next() : null;\n \n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n         try {\n-            ComponentInvocationType invType = invocation.getInvocationType();\n-\n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n-            List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invType);\n-            if (setCIH != null) {\n-                for (int i = 0; i < setCIH.size(); i++) {\n-                    setCIH.get(i).getComponentInvocationHandler().beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (typeHandler != null) {\n+                typeHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n         } finally {\n             // pop the stack\n-            invocationArray.remove(beforeSize - 1);\n+            frames.removeLast();\n \n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.afterPostInvoke(invocation.getInvocationType(), prevInv, invocation);", "originalCommit": "1eca37c1479fc38ea61aa667b5393b26b3218a99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDEyNzM1MQ==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r410127351", "bodyText": "I think it is worth a warning when this assumption doesn't hold and you actually have a good spot since you already jump over the invocation head.\nThis might disclose bugs we have around nested transactions or cleanups.", "author": "pdudits", "createdAt": "2020-04-17T10:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5NTUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5MzE4OA==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r410093188", "bodyText": "Isn't ArrayDequeue sufficient here, since it is guaranteed there will not be any cross-thread access as it is thread-local?", "author": "pdudits", "createdAt": "2020-04-17T09:07:40Z", "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();\n-\n-    private final ComponentInvocationHandler[] invHandlers;\n+    private final InheritableThreadLocal<InvocationFrames> framesByThread;\n+    private final ThreadLocal<Deque<ApplicationEnvironment>> appEnvironments = withInitial(ConcurrentLinkedDeque::new);\n+    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ConcurrentLinkedDeque::new);", "originalCommit": "1eca37c1479fc38ea61aa667b5393b26b3218a99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMDEzNw==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r411210137", "bodyText": "I'd say so, yes. Given the importance of the manager this was more of a \"better safe then sorry\" thing to give me peace of mind. Since we both think it is not necessary we might just make this unsynchronized.", "author": "jbee", "createdAt": "2020-04-20T08:57:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5MzE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDExNjIwMQ==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r410116201", "bodyText": "Also here I don't see InvocationFrames being used outside thread locals, so I'd infer it doesn't need additional CAS overhead and an ArrayDequeue is sufficient.\nI'm also afraid that extending rather than delegating makes too many public methods available.", "author": "pdudits", "createdAt": "2020-04-17T09:49:26Z", "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();\n-\n-    private final ComponentInvocationHandler[] invHandlers;\n+    private final InheritableThreadLocal<InvocationFrames> framesByThread;\n+    private final ThreadLocal<Deque<ApplicationEnvironment>> appEnvironments = withInitial(ConcurrentLinkedDeque::new);\n+    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ConcurrentLinkedDeque::new);\n+    private final ConcurrentMap<ComponentInvocationType, ListComponentInvocationHandler> typeHandlers = new ConcurrentHashMap<>();\n+    private final ComponentInvocationHandler allTypesHandler;\n \n     public InvocationManagerImpl() {\n-        this(null);\n+        this((ComponentInvocationHandler) null);\n+    }\n+\n+    public InvocationManagerImpl(ComponentInvocationHandler... handlers) {\n+        this(Arrays.asList(handlers));\n     }\n \n     @Inject\n     private InvocationManagerImpl(@Optional IterableProvider<ComponentInvocationHandler> handlers) {\n-        if (handlers == null) {\n-            invHandlers = null;\n-        } else {\n-            LinkedList<ComponentInvocationHandler> localHandlers = new LinkedList<ComponentInvocationHandler>();\n-            for (ComponentInvocationHandler handler : handlers) {\n-                localHandlers.add(handler);\n-            }\n+        this((Iterable<ComponentInvocationHandler>) handlers);\n+    }\n \n-            if (localHandlers.size() > 0) {\n-                invHandlers = localHandlers.toArray(new ComponentInvocationHandler[localHandlers.size()]);\n-            } else {\n-                invHandlers = null;\n-            }\n-        }\n+    private InvocationManagerImpl(Iterable<ComponentInvocationHandler> handlers) {\n+        this.allTypesHandler = initInvocationHandlers(handlers);\n \n-        frames = new InheritableThreadLocal<InvocationArray<ComponentInvocation>>() {\n+        framesByThread = new InheritableThreadLocal<InvocationFrames>() {\n \n-            protected InvocationArray<ComponentInvocation> initialValue() {\n-                return new InvocationArray<>();\n+            @Override\n+            protected InvocationFrames initialValue() {\n+                return new InvocationFrames();\n             }\n \n-            protected InvocationArray<ComponentInvocation> childValue(InvocationArray<ComponentInvocation> parentValue) {\n+            @Override\n+            protected InvocationFrames childValue(InvocationFrames parentValue) {\n                 return computeChildTheadInvocation(parentValue);\n             }\n         };\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+    private static ComponentInvocationHandler initInvocationHandlers(Iterable<ComponentInvocationHandler> handlers) {\n+        if (handlers == null) {\n+            return null;\n+        }\n+        List<ComponentInvocationHandler> hs = new ArrayList<>();\n+        handlers.forEach(hs::add);\n+        if (hs.isEmpty()) {\n+            return null;\n+        }\n+        if (hs.size() == 1) {\n+            return hs.get(0);\n+        }\n+        return new ListComponentInvocationHandler(hs);\n+    }\n+\n     @Override\n     public void setThreadInheritableInvocation(List<? extends ComponentInvocation> parentValue) {\n-        frames.set(computeChildTheadInvocation((InvocationArray<ComponentInvocation>) parentValue));\n+        framesByThread.set(computeChildTheadInvocation(InvocationFrames.valueOf(parentValue)));\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void preInvoke(T invocation) throws InvocationException {\n \n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(SERVICE_STARTUP);\n+            frames.setState(SERVICE_STARTUP);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        ComponentInvocation previousInvocation = beforeSize > 0 ? invocationArray.get(beforeSize - 1) : null;\n-\n-        // If ejb call EJBSecurityManager, for servlet call RealmAdapter\n-        ComponentInvocationType invocationType = invocation.getInvocationType();\n+        ComponentInvocation prev = frames.peekLast();\n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.beforePreInvoke(invocationType, previousInvocation, invocation);\n+        try {\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invocationType);\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().beforePreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        // Push this invocation on the stack\n-        invocationArray.add(invocation);\n+        } finally {\n+            // Push this invocation on the stack\n+            frames.addLast(invocation);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (allTypesHandler != null) {\n+                allTypesHandler.afterPreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.afterPreInvoke(type, prev, invocation);\n             }\n         }\n-\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void postInvoke(T invocation) throws InvocationException {\n-\n-        // Get this thread's ArrayList\n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(UN_INITIALIZED);\n+            frames.setState(UN_INITIALIZED);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        if (beforeSize == 0) {\n+        Iterator<ComponentInvocation> iter = frames.descendingIterator();\n+        if (!iter.hasNext()) {\n             throw new InvocationException();\n         }\n \n-        ComponentInvocation prevInv = beforeSize > 1 ? invocationArray.get(beforeSize - 2) : null;\n-        ComponentInvocation curInv = invocationArray.get(beforeSize - 1);\n+        iter.next(); // the last is the current is \"invocation\"\n+        ComponentInvocation prev = iter.hasNext() ? iter.next() : null;\n \n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n         try {\n-            ComponentInvocationType invType = invocation.getInvocationType();\n-\n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n-            List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invType);\n-            if (setCIH != null) {\n-                for (int i = 0; i < setCIH.size(); i++) {\n-                    setCIH.get(i).getComponentInvocationHandler().beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (typeHandler != null) {\n+                typeHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n         } finally {\n             // pop the stack\n-            invocationArray.remove(beforeSize - 1);\n+            frames.removeLast();\n \n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.afterPostInvoke(invocation.getInvocationType(), prevInv, invocation);\n-                }\n+            if (allTypesHandler != null) {\n+                allTypesHandler.afterPostInvoke(type, prev, invocation);\n             }\n-\n-            ComponentInvocationType invType = invocation.getInvocationType();\n-\n-            List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invType);\n-            if (setCIH != null) {\n-                for (int i = 0; i < setCIH.size(); i++) {\n-                    setCIH.get(i).getComponentInvocationHandler().afterPostInvoke(invType, prevInv, curInv);\n-                }\n+            if (typeHandler != null) {\n+                typeHandler.afterPostInvoke(type, prev, invocation);\n             }\n-\n         }\n-\n     }\n \n     /**\n-     * return true iff no invocations on the stack for this thread\n-     * @return\n+     * @return true iff no invocations on the stack for this thread\n      */\n     @Override\n     public boolean isInvocationStackEmpty() {\n-        InvocationArray<ComponentInvocation> invocations = frames.get();\n-        return invocations == null || invocations.size() == 0;\n+        InvocationFrames invocations = framesByThread.get();\n+        return invocations == null || invocations.isEmpty();\n     }\n \n     /**\n-     * return the Invocation object of the component being called\n-     * @param <T>\n-     * @return\n+     * @return the Invocation object of the component being called\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T extends ComponentInvocation> T getCurrentInvocation() {\n-        InvocationArray<ComponentInvocation> invocations = frames.get();\n-        int invocationsSize = invocations.size();\n-        if (invocationsSize == 0) {\n-            return null;\n-        }\n-\n-        return (T) invocations.get(invocationsSize - 1);\n+        return (T) framesByThread.get().peekLast();\n     }\n \n     /**\n-     * return the Invocation object of the caller\n-     * return null if none exist (e.g. caller is from another VM)\n-     * @param <T>\n-     * @return\n+     * @return the Invocation object of the caller or null if none exist (e.g. caller is from another VM)\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T extends ComponentInvocation> T getPreviousInvocation() throws InvocationException {\n-        InvocationArray<ComponentInvocation> invocations = frames.get();\n-        int invocationsSize = invocations.size();\n-        if (invocationsSize < 2) {\n+        Iterator<ComponentInvocation> iter = framesByThread.get().descendingIterator();\n+        if (!iter.hasNext()) {\n             return null;\n         }\n-\n-        return (T) invocations.get(invocationsSize - 2);\n+        iter.next();\n+        if (!iter.hasNext()) {\n+            return null;\n+        }\n+        return (T) iter.next();\n     }\n \n     @Override\n     public List<? extends ComponentInvocation> getAllInvocations() {\n-        return frames.get();\n+        InvocationFrames frames = framesByThread.get();\n+        return frames == null ? emptyList() : new ArrayList<>(frames);\n     }\n \n     @Override\n     public List<? extends ComponentInvocation> popAllInvocations() {\n-        List<? extends ComponentInvocation> result = frames.get();\n-        frames.set(null);\n+        List<? extends ComponentInvocation> result = getAllInvocations();\n+        framesByThread.set(null);\n         return result;\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public void putAllInvocations(List<? extends ComponentInvocation> invocations) {\n-        frames.set(new InvocationArray<>((List<ComponentInvocation>) invocations));\n+        framesByThread.set(InvocationFrames.valueOf(invocations));\n     }\n \n-    private InvocationArray<ComponentInvocation> computeChildTheadInvocation(InvocationArray<ComponentInvocation> parentValue) {\n-\n-        // Always creates a new ArrayList\n-        InvocationArray<ComponentInvocation> childInvocationArray = new InvocationArray<ComponentInvocation>();\n-        InvocationArray<ComponentInvocation> parentInvocationArray = parentValue;\n+    static InvocationFrames computeChildTheadInvocation(InvocationFrames parent) {\n+        InvocationFrames childFrames = new InvocationFrames();\n+        InvocationFrames parentFrames = parent;\n \n-        if (parentInvocationArray != null && parentInvocationArray.size() > 0 && parentInvocationArray.outsideStartup()) {\n+        if (parentFrames != null && !parentFrames.isEmpty() && !parentFrames.isStartup()) {\n \n             // Get current invocation\n-            ComponentInvocation parentInvocation = parentInvocationArray.get(parentInvocationArray.size() - 1);\n+            ComponentInvocation parentFrame = parentFrames.getLast();\n \n             // TODO: The following is ugly. The logic of what needs to be in the\n             // new ComponentInvocation should be with the respective container\n \n-            if (parentInvocation.getInvocationType() == SERVLET_INVOCATION) {\n+            ComponentInvocationType parentType = parentFrame.getInvocationType();\n+            if (parentType == SERVLET_INVOCATION) {\n \n                 // If this is a thread created by user in servlet's service method\n                 // create a new ComponentInvocation with transaction\n                 // left to null and instance left to null\n                 // so that the resource won't be enlisted or registered\n \n                 ComponentInvocation invocation = new ComponentInvocation();\n-                invocation.setComponentInvocationType(parentInvocation.getInvocationType());\n-                invocation.setComponentId(parentInvocation.getComponentId());\n-                invocation.setAppName(parentInvocation.getAppName());\n-                invocation.setModuleName(parentInvocation.getModuleName());\n-                invocation.setContainer(parentInvocation.getContainer());\n-                invocation.setJndiEnvironment(parentInvocation.getJndiEnvironment());\n-\n-                childInvocationArray.add(invocation);\n-            } else if (parentInvocation.getInvocationType() != EJB_INVOCATION) {\n-\n+                invocation.setComponentInvocationType(parentType);\n+                invocation.setComponentId(parentFrame.getComponentId());\n+                invocation.setAppName(parentFrame.getAppName());\n+                invocation.setModuleName(parentFrame.getModuleName());\n+                invocation.setContainer(parentFrame.getContainer());\n+                invocation.setJndiEnvironment(parentFrame.getJndiEnvironment());\n+\n+                childFrames.add(invocation);\n+            } else if (parentType != EJB_INVOCATION) {\n                 // Push a copy of invocation onto the new result\n-                // ArrayList\n-                ComponentInvocation cpy = new ComponentInvocation();\n-                cpy.componentId = parentInvocation.getComponentId();\n-                cpy.setComponentInvocationType(parentInvocation.getInvocationType());\n-                cpy.instance = parentInvocation.getInstance();\n-                cpy.container = parentInvocation.getContainerContext();\n-                cpy.transaction = parentInvocation.getTransaction();\n-\n-                childInvocationArray.add(cpy);\n+                childFrames.add(new ComponentInvocation(\n+                        parentFrame.getComponentId(),\n+                        parentType,\n+                        parentFrame.getInstance(),\n+                        parentFrame.getContainerContext(),\n+                        parentFrame.getTransaction()));\n             }\n         }\n \n-        return childInvocationArray;\n+        return childFrames;\n     }\n \n \n-    static class InvocationArray<T extends ComponentInvocation> extends ArrayList<T> {\n+    static final class InvocationFrames extends ConcurrentLinkedDeque<ComponentInvocation> {", "originalCommit": "1eca37c1479fc38ea61aa667b5393b26b3218a99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjQ5NA==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r411212494", "bodyText": "I'm also afraid that extending rather than delegating makes too many public methods available.\n\nInvocationFrames is only used privately.\nAgain, done this for peace of mind. Could go to ArrayDequeue.", "author": "jbee", "createdAt": "2020-04-20T09:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDExNjIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDExNzgwMg==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r410117802", "bodyText": "Isn't this thread safety requirement valid for all constructions of ListComponentInvocationHandler? If so, it is better handled in its constructors by copying whatever list is on input into its own list.", "author": "pdudits", "createdAt": "2020-04-17T09:52:17Z", "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();\n-\n-    private final ComponentInvocationHandler[] invHandlers;\n+    private final InheritableThreadLocal<InvocationFrames> framesByThread;\n+    private final ThreadLocal<Deque<ApplicationEnvironment>> appEnvironments = withInitial(ConcurrentLinkedDeque::new);\n+    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ConcurrentLinkedDeque::new);\n+    private final ConcurrentMap<ComponentInvocationType, ListComponentInvocationHandler> typeHandlers = new ConcurrentHashMap<>();\n+    private final ComponentInvocationHandler allTypesHandler;\n \n     public InvocationManagerImpl() {\n-        this(null);\n+        this((ComponentInvocationHandler) null);\n+    }\n+\n+    public InvocationManagerImpl(ComponentInvocationHandler... handlers) {\n+        this(Arrays.asList(handlers));\n     }\n \n     @Inject\n     private InvocationManagerImpl(@Optional IterableProvider<ComponentInvocationHandler> handlers) {\n-        if (handlers == null) {\n-            invHandlers = null;\n-        } else {\n-            LinkedList<ComponentInvocationHandler> localHandlers = new LinkedList<ComponentInvocationHandler>();\n-            for (ComponentInvocationHandler handler : handlers) {\n-                localHandlers.add(handler);\n-            }\n+        this((Iterable<ComponentInvocationHandler>) handlers);\n+    }\n \n-            if (localHandlers.size() > 0) {\n-                invHandlers = localHandlers.toArray(new ComponentInvocationHandler[localHandlers.size()]);\n-            } else {\n-                invHandlers = null;\n-            }\n-        }\n+    private InvocationManagerImpl(Iterable<ComponentInvocationHandler> handlers) {\n+        this.allTypesHandler = initInvocationHandlers(handlers);\n \n-        frames = new InheritableThreadLocal<InvocationArray<ComponentInvocation>>() {\n+        framesByThread = new InheritableThreadLocal<InvocationFrames>() {\n \n-            protected InvocationArray<ComponentInvocation> initialValue() {\n-                return new InvocationArray<>();\n+            @Override\n+            protected InvocationFrames initialValue() {\n+                return new InvocationFrames();\n             }\n \n-            protected InvocationArray<ComponentInvocation> childValue(InvocationArray<ComponentInvocation> parentValue) {\n+            @Override\n+            protected InvocationFrames childValue(InvocationFrames parentValue) {\n                 return computeChildTheadInvocation(parentValue);\n             }\n         };\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+    private static ComponentInvocationHandler initInvocationHandlers(Iterable<ComponentInvocationHandler> handlers) {\n+        if (handlers == null) {\n+            return null;\n+        }\n+        List<ComponentInvocationHandler> hs = new ArrayList<>();\n+        handlers.forEach(hs::add);\n+        if (hs.isEmpty()) {\n+            return null;\n+        }\n+        if (hs.size() == 1) {\n+            return hs.get(0);\n+        }\n+        return new ListComponentInvocationHandler(hs);\n+    }\n+\n     @Override\n     public void setThreadInheritableInvocation(List<? extends ComponentInvocation> parentValue) {\n-        frames.set(computeChildTheadInvocation((InvocationArray<ComponentInvocation>) parentValue));\n+        framesByThread.set(computeChildTheadInvocation(InvocationFrames.valueOf(parentValue)));\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void preInvoke(T invocation) throws InvocationException {\n \n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(SERVICE_STARTUP);\n+            frames.setState(SERVICE_STARTUP);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        ComponentInvocation previousInvocation = beforeSize > 0 ? invocationArray.get(beforeSize - 1) : null;\n-\n-        // If ejb call EJBSecurityManager, for servlet call RealmAdapter\n-        ComponentInvocationType invocationType = invocation.getInvocationType();\n+        ComponentInvocation prev = frames.peekLast();\n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.beforePreInvoke(invocationType, previousInvocation, invocation);\n+        try {\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invocationType);\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().beforePreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        // Push this invocation on the stack\n-        invocationArray.add(invocation);\n+        } finally {\n+            // Push this invocation on the stack\n+            frames.addLast(invocation);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (allTypesHandler != null) {\n+                allTypesHandler.afterPreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.afterPreInvoke(type, prev, invocation);\n             }\n         }\n-\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void postInvoke(T invocation) throws InvocationException {\n-\n-        // Get this thread's ArrayList\n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(UN_INITIALIZED);\n+            frames.setState(UN_INITIALIZED);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        if (beforeSize == 0) {\n+        Iterator<ComponentInvocation> iter = frames.descendingIterator();\n+        if (!iter.hasNext()) {\n             throw new InvocationException();\n         }\n \n-        ComponentInvocation prevInv = beforeSize > 1 ? invocationArray.get(beforeSize - 2) : null;\n-        ComponentInvocation curInv = invocationArray.get(beforeSize - 1);\n+        iter.next(); // the last is the current is \"invocation\"\n+        ComponentInvocation prev = iter.hasNext() ? iter.next() : null;\n \n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n         try {\n-            ComponentInvocationType invType = invocation.getInvocationType();\n-\n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n-            List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invType);\n-            if (setCIH != null) {\n-                for (int i = 0; i < setCIH.size(); i++) {\n-                    setCIH.get(i).getComponentInvocationHandler().beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (typeHandler != null) {\n+                typeHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n         } finally {\n             // pop the stack\n-            invocationArray.remove(beforeSize - 1);\n+            frames.removeLast();\n \n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.afterPostInvoke(invocation.getInvocationType(), prevInv, invocation);\n-                }\n+            if (allTypesHandler != null) {\n+                allTypesHandler.afterPostInvoke(type, prev, invocation);\n             }\n-\n-            ComponentInvocationType invType = invocation.getInvocationType();\n-\n-            List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invType);\n-            if (setCIH != null) {\n-                for (int i = 0; i < setCIH.size(); i++) {\n-                    setCIH.get(i).getComponentInvocationHandler().afterPostInvoke(invType, prevInv, curInv);\n-                }\n+            if (typeHandler != null) {\n+                typeHandler.afterPostInvoke(type, prev, invocation);\n             }\n-\n         }\n-\n     }\n \n     /**\n-     * return true iff no invocations on the stack for this thread\n-     * @return\n+     * @return true iff no invocations on the stack for this thread\n      */\n     @Override\n     public boolean isInvocationStackEmpty() {\n-        InvocationArray<ComponentInvocation> invocations = frames.get();\n-        return invocations == null || invocations.size() == 0;\n+        InvocationFrames invocations = framesByThread.get();\n+        return invocations == null || invocations.isEmpty();\n     }\n \n     /**\n-     * return the Invocation object of the component being called\n-     * @param <T>\n-     * @return\n+     * @return the Invocation object of the component being called\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T extends ComponentInvocation> T getCurrentInvocation() {\n-        InvocationArray<ComponentInvocation> invocations = frames.get();\n-        int invocationsSize = invocations.size();\n-        if (invocationsSize == 0) {\n-            return null;\n-        }\n-\n-        return (T) invocations.get(invocationsSize - 1);\n+        return (T) framesByThread.get().peekLast();\n     }\n \n     /**\n-     * return the Invocation object of the caller\n-     * return null if none exist (e.g. caller is from another VM)\n-     * @param <T>\n-     * @return\n+     * @return the Invocation object of the caller or null if none exist (e.g. caller is from another VM)\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T extends ComponentInvocation> T getPreviousInvocation() throws InvocationException {\n-        InvocationArray<ComponentInvocation> invocations = frames.get();\n-        int invocationsSize = invocations.size();\n-        if (invocationsSize < 2) {\n+        Iterator<ComponentInvocation> iter = framesByThread.get().descendingIterator();\n+        if (!iter.hasNext()) {\n             return null;\n         }\n-\n-        return (T) invocations.get(invocationsSize - 2);\n+        iter.next();\n+        if (!iter.hasNext()) {\n+            return null;\n+        }\n+        return (T) iter.next();\n     }\n \n     @Override\n     public List<? extends ComponentInvocation> getAllInvocations() {\n-        return frames.get();\n+        InvocationFrames frames = framesByThread.get();\n+        return frames == null ? emptyList() : new ArrayList<>(frames);\n     }\n \n     @Override\n     public List<? extends ComponentInvocation> popAllInvocations() {\n-        List<? extends ComponentInvocation> result = frames.get();\n-        frames.set(null);\n+        List<? extends ComponentInvocation> result = getAllInvocations();\n+        framesByThread.set(null);\n         return result;\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public void putAllInvocations(List<? extends ComponentInvocation> invocations) {\n-        frames.set(new InvocationArray<>((List<ComponentInvocation>) invocations));\n+        framesByThread.set(InvocationFrames.valueOf(invocations));\n     }\n \n-    private InvocationArray<ComponentInvocation> computeChildTheadInvocation(InvocationArray<ComponentInvocation> parentValue) {\n-\n-        // Always creates a new ArrayList\n-        InvocationArray<ComponentInvocation> childInvocationArray = new InvocationArray<ComponentInvocation>();\n-        InvocationArray<ComponentInvocation> parentInvocationArray = parentValue;\n+    static InvocationFrames computeChildTheadInvocation(InvocationFrames parent) {\n+        InvocationFrames childFrames = new InvocationFrames();\n+        InvocationFrames parentFrames = parent;\n \n-        if (parentInvocationArray != null && parentInvocationArray.size() > 0 && parentInvocationArray.outsideStartup()) {\n+        if (parentFrames != null && !parentFrames.isEmpty() && !parentFrames.isStartup()) {\n \n             // Get current invocation\n-            ComponentInvocation parentInvocation = parentInvocationArray.get(parentInvocationArray.size() - 1);\n+            ComponentInvocation parentFrame = parentFrames.getLast();\n \n             // TODO: The following is ugly. The logic of what needs to be in the\n             // new ComponentInvocation should be with the respective container\n \n-            if (parentInvocation.getInvocationType() == SERVLET_INVOCATION) {\n+            ComponentInvocationType parentType = parentFrame.getInvocationType();\n+            if (parentType == SERVLET_INVOCATION) {\n \n                 // If this is a thread created by user in servlet's service method\n                 // create a new ComponentInvocation with transaction\n                 // left to null and instance left to null\n                 // so that the resource won't be enlisted or registered\n \n                 ComponentInvocation invocation = new ComponentInvocation();\n-                invocation.setComponentInvocationType(parentInvocation.getInvocationType());\n-                invocation.setComponentId(parentInvocation.getComponentId());\n-                invocation.setAppName(parentInvocation.getAppName());\n-                invocation.setModuleName(parentInvocation.getModuleName());\n-                invocation.setContainer(parentInvocation.getContainer());\n-                invocation.setJndiEnvironment(parentInvocation.getJndiEnvironment());\n-\n-                childInvocationArray.add(invocation);\n-            } else if (parentInvocation.getInvocationType() != EJB_INVOCATION) {\n-\n+                invocation.setComponentInvocationType(parentType);\n+                invocation.setComponentId(parentFrame.getComponentId());\n+                invocation.setAppName(parentFrame.getAppName());\n+                invocation.setModuleName(parentFrame.getModuleName());\n+                invocation.setContainer(parentFrame.getContainer());\n+                invocation.setJndiEnvironment(parentFrame.getJndiEnvironment());\n+\n+                childFrames.add(invocation);\n+            } else if (parentType != EJB_INVOCATION) {\n                 // Push a copy of invocation onto the new result\n-                // ArrayList\n-                ComponentInvocation cpy = new ComponentInvocation();\n-                cpy.componentId = parentInvocation.getComponentId();\n-                cpy.setComponentInvocationType(parentInvocation.getInvocationType());\n-                cpy.instance = parentInvocation.getInstance();\n-                cpy.container = parentInvocation.getContainerContext();\n-                cpy.transaction = parentInvocation.getTransaction();\n-\n-                childInvocationArray.add(cpy);\n+                childFrames.add(new ComponentInvocation(\n+                        parentFrame.getComponentId(),\n+                        parentType,\n+                        parentFrame.getInstance(),\n+                        parentFrame.getContainerContext(),\n+                        parentFrame.getTransaction()));\n             }\n         }\n \n-        return childInvocationArray;\n+        return childFrames;\n     }\n \n \n-    static class InvocationArray<T extends ComponentInvocation> extends ArrayList<T> {\n+    static final class InvocationFrames extends ConcurrentLinkedDeque<ComponentInvocation> {\n \n         private static final long serialVersionUID = 1L;\n \n-        private ComponentInvocationType invocationAttribute;\n+        private ComponentInvocationType state;\n \n-        private InvocationArray(List<T> invocations) {\n-            super(invocations);\n+        static InvocationFrames valueOf(Collection<? extends ComponentInvocation> invocations) {\n+            return invocations instanceof InvocationFrames\n+                    ? (InvocationFrames) invocations\n+                    : new InvocationFrames(invocations == null ? emptyList() : invocations);\n         }\n \n-        private InvocationArray() {\n+        private InvocationFrames(Collection<? extends ComponentInvocation> invocations) {\n+            super(invocations);\n         }\n \n-        public void setInvocationAttribute(ComponentInvocationType attribute) {\n-            this.invocationAttribute = attribute;\n+        InvocationFrames() {\n         }\n \n-        public ComponentInvocationType getInvocationAttribute() {\n-            return invocationAttribute;\n+        void setState(ComponentInvocationType state) {\n+            this.state = state;\n         }\n \n-        public boolean outsideStartup() {\n-            return getInvocationAttribute() != SERVICE_STARTUP;\n+        boolean isStartup() {\n+            return state == SERVICE_STARTUP;\n         }\n     }\n \n     @Override\n     public void registerComponentInvocationHandler(ComponentInvocationType type, RegisteredComponentInvocationHandler handler) {\n-        List<RegisteredComponentInvocationHandler> setRegCompInvHandlers = regCompInvHandlerMap.get(type);\n-\n-        if (setRegCompInvHandlers == null) {\n-            setRegCompInvHandlers = new ArrayList<RegisteredComponentInvocationHandler>();\n-            regCompInvHandlerMap.put(type, setRegCompInvHandlers);\n-        }\n-\n-        if (setRegCompInvHandlers.size() == 0) {\n-            setRegCompInvHandlers.add(handler);\n-        }\n+        typeHandlers.computeIfAbsent(type,\n+                key -> new ListComponentInvocationHandler(new CopyOnWriteArrayList<>())) // OBS! must be thread safe List here", "originalCommit": "1eca37c1479fc38ea61aa667b5393b26b3218a99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMzc1Mw==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r411213753", "bodyText": "No, the allTypesHandler is composed once during construction and never changed so it does not need any form of synchronisation while the handlers per type can change while being used so they need it.", "author": "jbee", "createdAt": "2020-04-20T09:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDExNzgwMg=="}], "type": "inlineReview"}, {"oid": "d5691328622ef5cba6361ce2561d465e0c57143e", "url": "https://github.com/payara/Payara/commit/d5691328622ef5cba6361ce2561d465e0c57143e", "message": "APPSERV-114 uses unsynchronised collections withoin thread locals; adds warning in case postInvoke called with an unecpected invocation instance", "committedDate": "2020-04-20T11:52:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5MjEzMQ==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r412192131", "bodyText": "Last Nitpick would be, that only EjbInvocation provides reasonable toString(). It would be great to add one into WebComponentInvocation and ComponentInvocation.", "author": "pdudits", "createdAt": "2020-04-21T13:38:26Z", "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -173,7 +177,11 @@ public void setThreadInheritableInvocation(List<? extends ComponentInvocation> p\n             throw new InvocationException();\n         }\n \n-        iter.next(); // the last is the current is \"invocation\"\n+        ComponentInvocation current = iter.next(); // the last is the current is \"invocation\"\n+        if (invocation != current) {\n+            LOGGER.log(WARNING, \"postInvoke not called with top of the invocation stack. Expected {0} but was: {1}\",\n+                    new Object[] { current, invocation });", "originalCommit": "d5691328622ef5cba6361ce2561d465e0c57143e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5MDc0MA==", "url": "https://github.com/payara/Payara/pull/4602#discussion_r412390740", "bodyText": "Good point, I remember checking it myself but then forgot to do something about it. Too many context switches. Will look into it tomorrow.", "author": "jbee", "createdAt": "2020-04-21T18:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5MjEzMQ=="}], "type": "inlineReview"}, {"oid": "b5bdaa22791cbfeb36140511340825a2552f7e84", "url": "https://github.com/payara/Payara/commit/b5bdaa22791cbfeb36140511340825a2552f7e84", "message": "APPSERV-114 adds toString to ComponentInvocation to provide relevant info in log messages", "committedDate": "2020-04-22T08:44:59Z", "type": "commit"}]}