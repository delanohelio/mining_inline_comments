{"pr_number": 4777, "pr_title": "FISH-162 OpenAPI Class Data Processing", "pr_createdAt": "2020-07-09T14:19:14Z", "pr_url": "https://github.com/payara/Payara/pull/4777", "timeline": [{"oid": "8d65b9ebcbfd989d06862e1661e10d5385695482", "url": "https://github.com/payara/Payara/commit/8d65b9ebcbfd989d06862e1661e10d5385695482", "message": "FISH-162 OpenAPI Class Data Processing\n\nSigned-off-by: Gaurav Gupta <gaurav.gupta@payara.fish>", "committedDate": "2020-07-09T14:18:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI1NTg3OQ==", "url": "https://github.com/payara/Payara/pull/4777#discussion_r452255879", "bodyText": "suggestion: else-if and else not needed when you use return in the if-blocks.", "author": "jbee", "createdAt": "2020-07-09T14:23:08Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/OpenApiService.java", "diffHunk": "@@ -174,28 +174,49 @@ public void event(Event<?> event) {\n             if (isValidApp(appInfo)) {\n                 // Store the application mapping in the list\n                 mappings.add(new OpenApiMapping(appInfo));\n+                allDocuments = null;\n             }\n         } else if (event.is(Deployment.APPLICATION_UNLOADED)) {\n             ApplicationInfo appInfo = (ApplicationInfo) event.hook();\n             for (OpenApiMapping mapping : mappings) {\n                 if (mapping.getAppInfo().equals(appInfo)) {\n                     mappings.remove(mapping);\n+                    allDocuments = null;\n                     break;\n                 }\n             }\n         }\n     }\n \n     /**\n-     * @return the document for the most recently deployed application. Creates\n-     * one if it hasn't already been created.\n+     * @return the document If multiple application deployed then merge all the\n+     * documents. Creates one if it hasn't already been created.\n      * @throws OpenAPIBuildException if creating the document failed.\n      */\n     public OpenAPI getDocument() throws OpenAPIBuildException {\n         if (mappings.isEmpty() || !isEnabled()) {\n             return null;\n+        } else if (mappings.size() == 1) {\n+            OpenAPI document = mappings.peekLast().getDocument();\n+            if(document == null) {\n+               document = mappings.peekLast().buildDocument();\n+            }\n+            return document;\n+        } else {", "originalCommit": "8d65b9ebcbfd989d06862e1661e10d5385695482", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI2MTAxNg==", "url": "https://github.com/payara/Payara/pull/4777#discussion_r452261016", "bodyText": "Makes me wonder if there is an else case now - is it an error? Should we maybe log something?", "author": "jbee", "createdAt": "2020-07-09T14:30:15Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/processor/ApplicationProcessor.java", "diffHunk": "@@ -1087,8 +1075,8 @@ private boolean insertObjectReference(ApiContext context, Reference<?> referee,\n                     // Create the schema\n                     if (context.isAllowedType(referenceClassType)) {\n                         visitSchema(schemaAnnotation, referenceClass, context);\n-                    } else {\n-                        apiWalker.processAnnotations(singleton(referenceClassType), Schema.class, this::visitSchema);\n+                    } else if(referenceClassType instanceof ClassModel) {\n+                        apiWalker.processAnnotation((ClassModel)referenceClassType, this);", "originalCommit": "8d65b9ebcbfd989d06862e1661e10d5385695482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3NzMwMw==", "url": "https://github.com/payara/Payara/pull/4777#discussion_r452277303", "bodyText": "This comes from PR (#4764) although we now support scanning for the packaged jar that's an optional feature.", "author": "jGauravGupta", "createdAt": "2020-07-09T14:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI2MTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3NzkwNg==", "url": "https://github.com/payara/Payara/pull/4777#discussion_r452277906", "bodyText": "I will add log statement, thx.", "author": "jGauravGupta", "createdAt": "2020-07-09T14:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI2MTAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI2NzAzMg==", "url": "https://github.com/payara/Payara/pull/4777#discussion_r452267032", "bodyText": "I assume filtering is no longer needed because of the new way we extract class information or it is done elsewhere now?", "author": "jbee", "createdAt": "2020-07-09T14:38:43Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/visitor/OpenApiWalker.java", "diffHunk": "@@ -104,211 +95,161 @@\n import org.glassfish.hk2.classmodel.reflect.Types;\n \n /**\n- * A walker that visits each annotation and passes it to the visitor.\n+ * A walker that visits each filtered class type & it's members, scans for\n+ * OpenAPI annotations and passes it to the visitor.\n  */\n-public class OpenApiWalker implements ApiWalker {\n+public class OpenApiWalker<E extends AnnotatedElement> implements ApiWalker {\n \n-    private static final Logger LOGGER = Logger.getLogger(OpenApiWalker.class.getName());\n-\n-    private final OpenAPI api;\n-    private final Types allTypes;\n     private final Set<Type> allowedTypes;\n-    private final Map<String, Set<Type>> resourceMapping;\n-    private final ClassLoader appClassLoader;\n+    private final OpenApiContext context;\n+\n+    private Map<Class<? extends Annotation>, VisitorFunction<AnnotationModel, E>> annotationVisitor;\n+    private Map<Class<? extends Annotation>, Class<? extends Annotation>> annotationAlternatives;\n \n     public OpenApiWalker(OpenAPI api, Types allTypes, Set<Type> allowedTypes, ClassLoader appClassLoader) {\n-        this.api = api;\n-        this.allTypes = allTypes;\n         this.allowedTypes = new TreeSet<>(Comparator.comparing(Type::getName, String::compareTo));\n         this.allowedTypes.addAll(allowedTypes);\n-        this.appClassLoader = appClassLoader;\n-        this.resourceMapping = generateResourceMapping();\n+        this.context = new OpenApiContext(allTypes, this.allowedTypes, appClassLoader, api);\n     }\n \n     @Override\n     public void accept(ApiVisitor visitor) {\n-        processAnnotations(allowedTypes, visitor);\n-    }\n-\n-    public void processAnnotations(Set<Type> types, ApiVisitor visitor) {\n-        // OpenAPI necessary annotations\n-        processAnnotations(types, OpenAPIDefinition.class, visitor::visitOpenAPI);\n-\n-        // JAX-RS methods\n-        processAnnotations(types, GET.class, visitor::visitGET);\n-        processAnnotations(types, POST.class, visitor::visitPOST);\n-        processAnnotations(types, PUT.class, visitor::visitPUT);\n-        processAnnotations(types, DELETE.class, visitor::visitDELETE);\n-        processAnnotations(types, HEAD.class, visitor::visitHEAD);\n-        processAnnotations(types, OPTIONS.class, visitor::visitOPTIONS);\n-        processAnnotations(types, PATCH.class, visitor::visitPATCH);\n-\n-        // JAX-RS parameters\n-        processAnnotations(types, QueryParam.class, visitor::visitQueryParam);\n-        processAnnotations(types, PathParam.class, visitor::visitPathParam);\n-        processAnnotations(types, HeaderParam.class, visitor::visitHeaderParam);\n-        processAnnotations(types, CookieParam.class, visitor::visitCookieParam);\n-        processAnnotations(types, FormParam.class, visitor::visitFormParam);\n-\n-        // All other OpenAPI annotations\n-        processAnnotations(types, Schema.class, visitor::visitSchema);\n-        processAnnotations(types, Server.class, visitor::visitServer, Servers.class);\n-        processAnnotations(types, Servers.class, visitor::visitServers, Server.class);\n-        processAnnotations(types, Extensions.class, visitor::visitExtensions, Extension.class);\n-        processAnnotations(types, Extension.class, visitor::visitExtension, Extensions.class);\n-        processAnnotations(types, Operation.class, visitor::visitOperation);\n-        processAnnotations(types, Callback.class, visitor::visitCallback, Callbacks.class);\n-        processAnnotations(types, Callbacks.class, visitor::visitCallbacks, Callback.class);\n-        processAnnotations(types, APIResponse.class, visitor::visitAPIResponse, APIResponses.class);\n-        processAnnotations(types, APIResponses.class, visitor::visitAPIResponses, APIResponse.class);\n-        processAnnotations(types, Parameters.class, visitor::visitParameters, Parameter.class);\n-        processAnnotations(types, Parameter.class, visitor::visitParameter, Parameters.class);\n-        processAnnotations(types, ExternalDocumentation.class, visitor::visitExternalDocumentation);\n-        processAnnotations(types, Tag.class, visitor::visitTag, Tags.class);\n-        processAnnotations(types, Tags.class, visitor::visitTags, Tag.class);\n-        processAnnotations(types, SecurityScheme.class, visitor::visitSecurityScheme, SecuritySchemes.class);\n-        processAnnotations(types, SecuritySchemes.class, visitor::visitSecuritySchemes, SecurityScheme.class);\n-        processAnnotations(types, SecurityRequirement.class, visitor::visitSecurityRequirement, SecurityRequirements.class);\n-        processAnnotations(types, SecurityRequirements.class, visitor::visitSecurityRequirements, SecurityRequirement.class);\n-\n-        // JAX-RS response types\n-        processAnnotations(types, Produces.class, visitor::visitProduces);\n-        processAnnotations(types, Consumes.class, visitor::visitConsumes);\n-\n-        // OpenAPI response types\n-        processAnnotations(types, RequestBody.class, visitor::visitRequestBody);\n-        //redo schema, now all others have been to ensure sub-schemas work\n-        processAnnotations(types, Schema.class, visitor::visitSchema);\n-    }\n-\n-    @SafeVarargs\n-    public final <A extends Annotation, E extends AnnotatedElement> void processAnnotations(\n-            Set<Type> types,\n-            Class<A> annotationClass,\n-            VisitorFunction<AnnotationModel, E> annotationFunction,\n-            Class<? extends Annotation>... alternatives) {\n-\n-        for (Type type : types) {\n+        for (Type type : allowedTypes) {\n             if (type instanceof ClassModel) {\n-                processAnnotation((ClassModel) type, annotationClass, annotationFunction, alternatives);\n+                processAnnotation((ClassModel) type, visitor);\n             }\n         }\n     }\n \n-    @SafeVarargs\n-    private final <A extends Annotation, E extends AnnotatedElement> void processAnnotation(\n-            ClassModel annotatedClass, Class<A> annotationClass, VisitorFunction<AnnotationModel, E> annotationFunction,\n-            Class<? extends Annotation>... alternatives) {\n+    public final void processAnnotation(ClassModel annotatedClass, ApiVisitor visitor) {\n         AnnotationInfo annotations = AnnotationInfo.valueOf(annotatedClass);\n-        processAnnotation(annotatedClass, annotationClass, annotationFunction, annotations,\n-                new OpenApiContext(allTypes, allowedTypes, appClassLoader, api, getResourcePath(annotatedClass, resourceMapping)), alternatives);\n+        processAnnotation((E) annotatedClass, annotations, visitor, new OpenApiContext(context, annotatedClass));\n+\n+        for (final MethodModel method : annotatedClass.getMethods()) {\n+            processAnnotation((E) method, annotations, visitor, new OpenApiContext(context, method));\n+        }\n \n         for (final FieldModel field : annotatedClass.getFields()) {\n-            if (annotations.isAnnotationPresent(annotationClass, field)) {\n-                if (annotationClass == HeaderParam.class\n-                        || annotationClass == CookieParam.class\n-                        || annotationClass == PathParam.class\n-                        || annotationClass == QueryParam.class) {\n-                    // NB. if fields are annotated as Param all methods have it\n-                    for (MethodModel method : annotatedClass.getMethods()) {\n-                        OpenApiContext context = new OpenApiContext(allTypes, allowedTypes, appClassLoader, api,\n-                                getResourcePath(method, resourceMapping),\n-                                getOperation(method, api, resourceMapping));\n-                        if (context.getWorkingOperation() != null) {\n-                            processAnnotation(field, annotationClass, annotationFunction, annotations, context,\n-                                    alternatives);\n-                        }\n-                    }\n-                } else {\n-                    processAnnotation(field, annotationClass, annotationFunction, annotations,\n-                            new OpenApiContext(allTypes, allowedTypes, appClassLoader, api, null), alternatives);\n-                }\n-            }\n+            processAnnotation((E) field, annotations, visitor, new OpenApiContext(context, field));\n         }\n \n         for (final MethodModel method : annotatedClass.getMethods()) {\n-            OpenApiContext context = new OpenApiContext(allTypes, allowedTypes, appClassLoader, api,\n-                    getResourcePath(method, resourceMapping),\n-                    getOperation(method, api, resourceMapping));\n-            processAnnotation(method, annotationClass, annotationFunction, annotations, context, alternatives);\n-\n             for (org.glassfish.hk2.classmodel.reflect.Parameter parameter : method.getParameters()) {\n-                processAnnotation(parameter, annotationClass, annotationFunction, annotations, context, alternatives);\n+                processAnnotation((E) parameter, annotations, visitor, new OpenApiContext(context, method));\n             }\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @SafeVarargs\n-    private static <A extends Annotation, E extends AnnotatedElement> void processAnnotation(\n-            AnnotatedElement element,\n-            Class<A> annotationClass,\n-            VisitorFunction<AnnotationModel, E> annotationFunction,\n-            AnnotationInfo annotations,\n-            ApiContext context,\n-            Class<? extends Annotation>... alternatives\n-    ) {\n-        // If it's just the one annotation class\n-        // Check the element\n-        if (annotations.isAnnotationPresent(annotationClass, element)) {\n-            annotationFunction.apply(annotations.getAnnotation(annotationClass, element), (E) element, context);\n-        } else if (element instanceof MethodModel && annotations.isAnnotationPresent(annotationClass)\n-                && !annotations.isAnyAnnotationPresent(element, alternatives)) {\n-            // If the method isn't annotated, inherit the class annotation\n-            if (context.getPath() != null) {\n-                annotationFunction.apply(annotations.getAnnotation(annotationClass), (E) element, context);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Generates a map listing the location each resource class is mapped to.\n-     */\n-    private Map<String, Set<Type>> generateResourceMapping() {\n-        Set<Type> classList = new HashSet<>();\n-        Map<String, Set<Type>> mapping = new HashMap<>();\n-        for (Type type : allowedTypes) {\n-            if(type instanceof ClassModel) {\n-                ClassModel classModel = (ClassModel) type;\n-                if(classModel.getAnnotation(ApplicationPath.class.getName()) != null) {\n-                    // Produce the mapping\n-                    AnnotationModel annotation = classModel.getAnnotation(ApplicationPath.class.getName());\n-                    String key = annotation.getValue(\"value\", String.class);\n-                    Set<Type> resourceClasses = new HashSet<>();\n-                    mapping.put(key, resourceClasses);\n-                    try {\n-                        Class<?> clazz = appClassLoader.loadClass(classModel.getName());\n-                        Application app = (Application) clazz.newInstance();\n-                        // Add all classes contained in the application\n-                        resourceClasses.addAll(app.getClasses()\n-                                .stream()\n-                                .map(Class::getName)\n-                                .filter(name -> !name.startsWith(\"org.glassfish.jersey\")) // Remove all Jersey providers", "originalCommit": "8d65b9ebcbfd989d06862e1661e10d5385695482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI4Nzc5MQ==", "url": "https://github.com/payara/Payara/pull/4777#discussion_r452287791", "bodyText": "Added here:\n\n  \n    \n      Payara/appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/visitor/OpenApiContext.java\n    \n    \n         Line 166\n      in\n      8d65b9e\n    \n    \n    \n    \n\n        \n          \n           .filter(name -> !name.startsWith(\"org.glassfish.jersey\")) // Remove all Jersey providers", "author": "jGauravGupta", "createdAt": "2020-07-09T15:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI2NzAzMg=="}], "type": "inlineReview"}, {"oid": "0e198a35a6da401c09117e601cb5bb3d12edb119", "url": "https://github.com/payara/Payara/commit/0e198a35a6da401c09117e601cb5bb3d12edb119", "message": "FISH-162 PR Review changes\n\nSigned-off-by: Gaurav Gupta <gaurav.gupta@payara.fish>", "committedDate": "2020-07-09T15:15:09Z", "type": "commit"}]}