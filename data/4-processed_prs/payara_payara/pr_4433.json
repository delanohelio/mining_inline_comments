{"pr_number": 4433, "pr_title": "PAYARA-3324 APPSERV-16 APPSERV-23 Allow Encryption of Web Session Data and SFSBs Stored in Hazelcast", "pr_createdAt": "2020-01-14T17:36:06Z", "pr_url": "https://github.com/payara/Payara/pull/4433", "timeline": [{"oid": "2ddb2b43de1cd345f3ae46f2caf2b127323f74a6", "url": "https://github.com/payara/Payara/commit/2ddb2b43de1cd345f3ae46f2caf2b127323f74a6", "message": "PAYARA-3324 Generate encryption key and initial symmetric encryptor impl", "committedDate": "2020-01-14T16:50:04Z", "type": "commit"}, {"oid": "0a427d94a45af5ea70858a79c9167b0f2d3ba409", "url": "https://github.com/payara/Payara/commit/0a427d94a45af5ea70858a79c9167b0f2d3ba409", "message": "PAYARA-3324 sync datagrid key, and throw unprocessed event", "committedDate": "2020-01-14T16:50:24Z", "type": "commit"}, {"oid": "9a3f9423f21322caa22a99544a7d725412432f5e", "url": "https://github.com/payara/Payara/commit/9a3f9423f21322caa22a99544a7d725412432f5e", "message": "PAYARA-3324 Don't apply changes until restart and correct logic", "committedDate": "2020-01-14T16:50:35Z", "type": "commit"}, {"oid": "363119bc56fe5cdc5b1c09244653eb9378218327", "url": "https://github.com/payara/Payara/commit/363119bc56fe5cdc5b1c09244653eb9378218327", "message": "PAYARA-3324 APPSERV-23 Initial impl of session data encryption", "committedDate": "2020-01-14T16:50:54Z", "type": "commit"}, {"oid": "cf36e0d5384f536911760495ac81e3f4507c0e19", "url": "https://github.com/payara/Payara/commit/cf36e0d5384f536911760495ac81e3f4507c0e19", "message": "PAYARA-3324 Add SFSB Test", "committedDate": "2020-01-14T16:50:54Z", "type": "commit"}, {"oid": "62bcc30923c8bdb4bfcd0eb5446b971885817e4a", "url": "https://github.com/payara/Payara/commit/62bcc30923c8bdb4bfcd0eb5446b971885817e4a", "message": "PAYARA-3324 Copyright and formatting", "committedDate": "2020-01-14T16:50:56Z", "type": "commit"}, {"oid": "36c779e5b3ff4fd48062de7c3b8d71c6f7cf3067", "url": "https://github.com/payara/Payara/commit/36c779e5b3ff4fd48062de7c3b8d71c6f7cf3067", "message": "PAYARA-3324 Moar copyright", "committedDate": "2020-01-14T17:30:17Z", "type": "commit"}, {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408", "url": "https://github.com/payara/Payara/commit/93024348d2b320a12991bcc36a1c12bf08bb3408", "message": "PAYARA-3324 Prompt for key regeneration upon changing master password", "committedDate": "2020-01-15T17:08:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMzM4NA==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367303384", "bodyText": "I assume you have thought about it decided not throwing an exception is the way to go. Just want to point this out once more as it looks like a \"throw exception\" situation.", "author": "jbee", "createdAt": "2020-01-16T09:09:40Z", "path": "appserver/ha/ha-hazelcast-store/src/main/java/fish/payara/ha/hazelcast/store/HazelcastBackingStore.java", "diffHunk": "@@ -73,40 +74,45 @@ public BackingStoreFactory getBackingStoreFactory() {\n     @Override\n     public V load(K k, String string) throws BackingStoreException {\n         init();\n-        return imap.get(k);\n+        try {\n+            return (V) clusteredStore.get(storeName, k);\n+        } catch (ClassCastException cce) {\n+            Logger.getLogger(HazelcastBackingStore.class.getName()).log(Level.WARNING,\n+                    \"ClassCastException when reading value from store, returning null\", cce);\n+            return null;", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MjAzOA==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367392038", "bodyText": "Hmm, can't remember my exact intention here actually...\nReading the Javadoc for BackingStore would indicate that it probably should throw an exception - I'll make the change", "author": "Pandrex247", "createdAt": "2020-01-16T12:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMzM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMzMzY1MA==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367333650", "bodyText": "The TestEjb could implement toString to do this. The current implementation also has basically the same code twice which also should benefit from such a toString implementation.", "author": "jbee", "createdAt": "2020-01-16T10:12:26Z", "path": "appserver/tests/payara-samples/samples/datagrid-encryption/sfsb-passivation/src/main/java/fish/payara/samples/datagridencryption/sfsb/TestEjbEndpoints.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.samples.datagridencryption.sfsb;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.naming.InitialContext;\n+import javax.naming.NamingException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import java.io.Serializable;\n+import java.util.Random;\n+\n+/**\n+ * @author Andrew Pielage <andrew.pielage@payara.fish>\n+ */\n+@ApplicationScoped\n+@Path(\"/TestEjb\")\n+public class TestEjbEndpoints implements Serializable {\n+\n+    @Inject\n+    TestEjb testEjb;\n+\n+    @Inject\n+    TestEjb testEjb2;\n+\n+    @GET\n+    public String testEjb() {\n+        testEjb.addItem(\"apple\");\n+        testEjb.addItem(\"pear\");\n+        testEjb.addItem(\"bear\");\n+        testEjb.removeItem(\"bear\");\n+\n+        String items = \"\";\n+        for (String item : testEjb.getItems()) {\n+            items += item + \",\";\n+        }\n+        items = items.substring(0, items.length() - 1);\n+        return items;\n+    }\n+\n+    @GET\n+    @Path(\"2\")\n+    public String testEjb2() {\n+        testEjb2.addItem(\"bapple\");\n+        testEjb2.addItem(\"bear\");\n+        testEjb2.addItem(\"care\");\n+        testEjb2.removeItem(\"bear\");\n+\n+        String items = \"\";\n+        for (String item : testEjb2.getItems()) {\n+            items += item + \",\";\n+        }\n+        items = items.substring(0, items.length() - 1);", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMzNjMzNQ==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367336335", "bodyText": "A helper method void runCommand(String logMsg, String... cmdArgs) would make the above much more readable.", "author": "jbee", "createdAt": "2020-01-16T10:17:59Z", "path": "appserver/tests/payara-samples/test-utils/src/main/java/fish/payara/samples/ServerOperations.java", "diffHunk": "@@ -739,5 +739,84 @@ public static KeyStore getKeyStore(\n             throw new RuntimeException(ex);\n         }\n     }\n+\n+    public static void enableDataGridEncryption() {\n+        String javaEEServer = System.getProperty(\"javaEEServer\");\n+        if (\"payara-remote\".equals(javaEEServer)) {\n+            System.out.println(\"Enabling Data Grid Encryption\");\n+            List<String> cmd = new ArrayList<>();\n+            cmd.add(\"set-hazelcast-configuration\");\n+            cmd.add(\"--encryptdatagrid\");\n+            cmd.add(\"true\");\n+            CliCommands.payaraGlassFish(cmd);\n+\n+            System.out.println(\"Stopping Server\");\n+            String domain = System.getProperty(\"payara.domain.name\", \"domain1\");\n+            if (domain != null) {\n+                domain = getPayaraDomainFromServer();\n+                if (domain != null && !domain.equals(\"null\")) {\n+                    logger.info(\"Using domain \\\"\" + domain + \"\\\" obtained from server. \" +\n+                            \"If this is not correct use -Dpayara.domain.name to override.\");\n+                } else {\n+                    // Default to domain1\n+                    domain = \"domain1\";\n+                }\n+            }\n+            cmd = new ArrayList<>();\n+            cmd.add(\"stop-domain\");\n+            cmd.add(domain);\n+            CliCommands.payaraGlassFish(cmd);\n+\n+            System.out.println(\"Generating Encryption Key\");\n+            cmd = new ArrayList<>();\n+            cmd.add(\"-W\");\n+            cmd.add(Paths.get(\"\").toAbsolutePath() + \"/src/test/resources/passwordfile.txt\");\n+            cmd.add(\"generate-encryption-key\");\n+            CliCommands.payaraGlassFish(cmd);\n+\n+            System.out.println(\"Restarting Server\");\n+            cmd = new ArrayList<>();\n+            cmd.add(\"start-domain\");\n+            cmd.add(domain);\n+            CliCommands.payaraGlassFish(cmd);", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMzODYzNw==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367338637", "bodyText": "ouch", "author": "jbee", "createdAt": "2020-01-16T10:22:36Z", "path": "nucleus/admin/server-mgmt/src/main/java/com/sun/enterprise/admin/servermgmt/cli/ChangeMasterPasswordCommandDAS.java", "diffHunk": "@@ -120,11 +127,29 @@ protected int executeCommand() throws CommandException {\n             domainConfig.put(DomainConfig.K_SAVE_MASTER_PASSWORD, savemp);\n             manager.changeMasterPassword(domainConfig);\n \n+            try {\n+                if (dataGridEncryptionEnabled()) {\n+                    logger.warning(\"Data grid encryption is enabled - \" +\n+                            \"you will need to regenerate the encryption key\");\n+                }\n+            } catch (IOException | SAXException | ParserConfigurationException | NullPointerException exception) {\n+                logger.warning(\"Could not determine if data grid encryption is enabled - \" +\n+                        \"you will need to regenerate the encryption key if it is\");\n+            }\n+\n             return 0;\n         } catch(Exception e) {\n             throw new CommandException(e.getMessage(),e);\n         }\n     }\n+\n+    private boolean dataGridEncryptionEnabled() throws IOException, SAXException, ParserConfigurationException {\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder builder = factory.newDocumentBuilder();\n+        Document document = builder.parse(getDomainXml());\n+        return Boolean.valueOf(document.getElementsByTagName(\"hazelcast-runtime-configuration\")\n+                .item(0).getAttributes().getNamedItem(\"datagrid-encryption-enabled\").getNodeValue());\n+    }", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwMzY5Nw==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367403697", "bodyText": "Yep, it's horrendously heavyweight: if you have any suggestions I'd love them.\nI don't have access to config beans from the CLI as the server isn't running.\nI looked at the MiniXmlParser class but that's specific to configs, not root level domain stuff.\nI could write my own XmlStreamParser as the hazelcast configuration tends to be at the top, but as the many comments in the other parsers state, you can't guarantee the order.\nProbably still quicker though, I'll have another look", "author": "Pandrex247", "createdAt": "2020-01-16T13:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMzODYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzODY4MA==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367438680", "bodyText": "Only suggestion I have is to leave a comment on the method explaining why this has to be done this way, like \"Server isn't running, no access to config beans => have to do it manually\" so that later \"us\" seeing this don't go \"ouch, does this have to be like that?\" again.", "author": "jbee", "createdAt": "2020-01-16T14:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMzODYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0MTA2Mg==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367341062", "bodyText": "Choice of name is a bit unfortunate as there is a method of the same name in the super class which returns something else.", "author": "jbee", "createdAt": "2020-01-16T10:27:38Z", "path": "nucleus/admin/server-mgmt/src/main/java/fish/payara/admin/servermgmt/cli/GenerateEncryptionKey.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.admin.servermgmt.cli;\n+\n+import com.sun.enterprise.admin.servermgmt.cli.ChangeMasterPasswordCommandDAS;\n+import com.sun.enterprise.admin.servermgmt.cli.LocalDomainCommand;\n+import com.sun.enterprise.universal.i18n.LocalStringsImpl;\n+import com.sun.enterprise.util.HostAndPort;\n+import com.sun.enterprise.util.net.NetUtils;\n+import org.glassfish.api.admin.CommandException;\n+import org.glassfish.hk2.api.PerLookup;\n+import org.glassfish.security.common.FileProtectionUtility;\n+import org.jvnet.hk2.annotations.Service;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Base64;\n+import java.util.Random;\n+\n+@Service(name = \"generate-encryption-key\")\n+@PerLookup\n+public class GenerateEncryptionKey extends LocalDomainCommand {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final LocalStringsImpl SERVERMGMT_CLI_STRINGS =\n+            new LocalStringsImpl(ChangeMasterPasswordCommandDAS.class);\n+    private static final Random random = new SecureRandom();\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static final String AES = \"AES\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+\n+    @Override\n+    protected int executeCommand() throws CommandException {\n+        checkDomainIsNotRunning();\n+        char[] masterPasswordChars = verifyMasterPassword();\n+\n+        File datagridKeyFile = new File(getServerDirs().getConfigDir(), DATAGRID_KEY_FILE);\n+        if (!datagridKeyFile.exists()) {\n+            createDatagridEncryptionKeyFile(datagridKeyFile);\n+        }\n+\n+        byte[] encodedKey = generateAndEncryptKey(masterPasswordChars);\n+\n+        try {\n+            Files.write(datagridKeyFile.toPath(), encodedKey);\n+        } catch (IOException ioe) {\n+            throw new CommandException(\"Error writing encoded key to file\", ioe);\n+        }\n+\n+        return 0;\n+    }\n+\n+    private void checkDomainIsNotRunning() throws CommandException {\n+        HostAndPort adminAddress = getAdminAddress();\n+        if (NetUtils.isRunning(adminAddress.getHost(), adminAddress.getPort())) {\n+            throw new CommandException(SERVERMGMT_CLI_STRINGS.get(\"domain.is.running\",\n+                    getDomainName(), getDomainRootDir()));\n+        }\n+    }\n+\n+    private char[] verifyMasterPassword() throws CommandException {", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzNzQ2MA==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367437460", "bodyText": "There's only so many names in the world.\nThis is a private method with a different return type and parameters - I think it's fine personally.", "author": "Pandrex247", "createdAt": "2020-01-16T14:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0MTA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0NjU2Nw==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367346567", "bodyText": "I'm no security expert but the use of random salt confuses me. If the salt is random there is no way to redo this even if we would know the master password. Hence, the master password is irrelevant for this and we could equally just use random bytes. AFAIK salt usually is a fix yet configurable string that isn't accessible from the \"outside\".\n@rdebusscher WDYT?\nWith random salt I assume there is no way to verify that an encryption key belongs to a certain master password? So we rely on that password and encryption key change together? Is this how this kind of thing is done?", "author": "jbee", "createdAt": "2020-01-16T10:39:25Z", "path": "nucleus/admin/server-mgmt/src/main/java/fish/payara/admin/servermgmt/cli/GenerateEncryptionKey.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.admin.servermgmt.cli;\n+\n+import com.sun.enterprise.admin.servermgmt.cli.ChangeMasterPasswordCommandDAS;\n+import com.sun.enterprise.admin.servermgmt.cli.LocalDomainCommand;\n+import com.sun.enterprise.universal.i18n.LocalStringsImpl;\n+import com.sun.enterprise.util.HostAndPort;\n+import com.sun.enterprise.util.net.NetUtils;\n+import org.glassfish.api.admin.CommandException;\n+import org.glassfish.hk2.api.PerLookup;\n+import org.glassfish.security.common.FileProtectionUtility;\n+import org.jvnet.hk2.annotations.Service;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Base64;\n+import java.util.Random;\n+\n+@Service(name = \"generate-encryption-key\")\n+@PerLookup\n+public class GenerateEncryptionKey extends LocalDomainCommand {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final LocalStringsImpl SERVERMGMT_CLI_STRINGS =\n+            new LocalStringsImpl(ChangeMasterPasswordCommandDAS.class);\n+    private static final Random random = new SecureRandom();\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static final String AES = \"AES\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+\n+    @Override\n+    protected int executeCommand() throws CommandException {\n+        checkDomainIsNotRunning();\n+        char[] masterPasswordChars = verifyMasterPassword();\n+\n+        File datagridKeyFile = new File(getServerDirs().getConfigDir(), DATAGRID_KEY_FILE);\n+        if (!datagridKeyFile.exists()) {\n+            createDatagridEncryptionKeyFile(datagridKeyFile);\n+        }\n+\n+        byte[] encodedKey = generateAndEncryptKey(masterPasswordChars);\n+\n+        try {\n+            Files.write(datagridKeyFile.toPath(), encodedKey);\n+        } catch (IOException ioe) {\n+            throw new CommandException(\"Error writing encoded key to file\", ioe);\n+        }\n+\n+        return 0;\n+    }\n+\n+    private void checkDomainIsNotRunning() throws CommandException {\n+        HostAndPort adminAddress = getAdminAddress();\n+        if (NetUtils.isRunning(adminAddress.getHost(), adminAddress.getPort())) {\n+            throw new CommandException(SERVERMGMT_CLI_STRINGS.get(\"domain.is.running\",\n+                    getDomainName(), getDomainRootDir()));\n+        }\n+    }\n+\n+    private char[] verifyMasterPassword() throws CommandException {\n+        String masterpassword = super.readFromMasterPasswordFile();\n+        if (masterpassword == null) {\n+            masterpassword = passwords.get(\"AS_ADMIN_MASTERPASSWORD\");\n+            if (masterpassword == null) {\n+                char[] masterpasswordChars = super.readPassword(SERVERMGMT_CLI_STRINGS.get(\"current.mp\"));\n+                masterpassword = masterpasswordChars != null ? new String(masterpasswordChars) : null;\n+            }\n+        }\n+        if (masterpassword == null) {\n+            throw new CommandException(SERVERMGMT_CLI_STRINGS.get(\"no.console\"));\n+        }\n+        if (!super.verifyMasterPassword(masterpassword)) {\n+            throw new CommandException(SERVERMGMT_CLI_STRINGS.get(\"incorrect.mp\"));\n+        }\n+\n+        return masterpassword.toCharArray();\n+    }\n+\n+    private void createDatagridEncryptionKeyFile(File datagridKeyFile) throws CommandException {\n+        try {\n+            // Windows defaults to essentially \"7\" for current user, Admins, and System\n+            Files.createFile(datagridKeyFile.toPath());\n+            FileProtectionUtility.chmod0600(datagridKeyFile);\n+        } catch (IOException ioe) {\n+            throw new CommandException(ioe.getMessage(), ioe);\n+        }\n+    }\n+\n+    private byte[] generateAndEncryptKey(char[] masterpasswordChars) throws CommandException {\n+        byte[] saltBytes = new byte[20];\n+        random.nextBytes(saltBytes);", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQzOTE0Mw==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r368439143", "bodyText": "If the salt is random there is no way to redo this even if we would know the master password. With random salt I assume there is no way to verify that an encryption key belongs to a certain master password?\n\n@jbee Correct, but we also store the salt when we need the symmetric key. This implementation is correct. Lets recap the process.\n\nWe need a Symmetric Key for the encryption with the Data Grid (call it DataGridSymKey).\nThis key needs to be stored on disk because it needs to be transferred to to other nodes/instances. So we need to encrypt it when stored on disk.\nWe need to encrypt it with something user/domain specific which is already safely stored, like the master password\nPassword are bad for encryption because they are mostly too short, hence the use of the Key Derivation function.\nPBKDF needs a salt and password to generate an enhanced 'password' (which is again a Symmetric Key EncryptionSymKey, which can be used to encrypt the DataGridSymKey.\nWhen decoding to retrieve the DataGridSymKey, we need the EncryptionSymKey. This can be generated again using the Master password and the salt.\nThat is the reason why the salt is also part of the output (see line 165 and next)\n\nSo the salt is used to generate a unique key, although 2 systems have the same master password, the key is different .", "author": "rdebusscher", "createdAt": "2020-01-20T09:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0NjU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0Nzg1Ng==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367347856", "bodyText": "This code looks familiar...", "author": "jbee", "createdAt": "2020-01-16T10:42:09Z", "path": "nucleus/cluster/cli/src/main/java/com/sun/enterprise/admin/cli/cluster/ChangeNodeMasterPasswordCommand.java", "diffHunk": "@@ -242,4 +259,12 @@ private boolean isRunning(File instanceDir) throws CommandException {\n         }\n     }\n \n+    private boolean dataGridEncryptionEnabled() throws IOException, SAXException, ParserConfigurationException {\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder builder = factory.newDocumentBuilder();\n+        Document document = builder.parse(getDomainXml());\n+        return Boolean.valueOf(document.getElementsByTagName(\"hazelcast-runtime-configuration\")\n+                .item(0).getAttributes().getNamedItem(\"datagrid-encryption-enabled\").getNodeValue());\n+    }", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0ODI1OQ==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367348259", "bodyText": "Multi-threading?", "author": "jbee", "createdAt": "2020-01-16T10:43:03Z", "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/HazelcastCore.java", "diffHunk": "@@ -116,6 +118,8 @@\n     private String memberName;\n     private String memberGroup;\n \n+    private boolean datagridEncryptionChanged = false;", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0NDc2Ng==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367444766", "bodyText": "I wouldn't say it's any more of an issue than the other variables - changes are made transactionally.", "author": "Pandrex247", "createdAt": "2020-01-16T14:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0ODI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ1MDQwNg==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367450406", "bodyText": "If the @Service does not cause some wrapper or extension of the class that does some black magic then I don't see how the field is properly made visible when one thread is reading while another one is writing. This might be my lack of knowledge on HK2 or it is actually a problem. It sure looks like one to me. I'd consider the possibility that the same problem exists for the other values :D", "author": "jbee", "createdAt": "2020-01-16T14:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0ODI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1MDAzMA==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367350030", "bodyText": "Could be return datagridEncryptionChanged ^ configuration.getDatagridEncryptionEnabled().equalsIgnoreCase(\"true\")\nbut I don't get who a method called isDatagridEncryptionEnabled would return true when the configuration is false. That does not make sense for me even if the encryption has changed.", "author": "jbee", "createdAt": "2020-01-16T10:46:54Z", "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/HazelcastCore.java", "diffHunk": "@@ -555,6 +561,26 @@ public int getPort() {\n \n     @Override\n     public UnprocessedChangeEvents changed(PropertyChangeEvent[] pces) {\n-        return null;\n+        List<UnprocessedChangeEvent> unprocessedChanges = new ArrayList<>();\n+        for (PropertyChangeEvent pce : pces) {\n+            if (pce.getPropertyName().equalsIgnoreCase(\"datagrid-encryption-enabled\")) {\n+                datagridEncryptionChanged = true;\n+                unprocessedChanges.add(new UnprocessedChangeEvent(pce, \"Hazelcast encryption settings changed\"));\n+            }\n+        }\n+\n+        if (unprocessedChanges.isEmpty()) {\n+            return null;\n+        }\n+        return new UnprocessedChangeEvents(unprocessedChanges);\n+    }\n+\n+    public boolean isDatagridEncryptionEnabled() {\n+        // If the datagrid encryption settings have changed, we want to return the opposite of the current setting\n+        // to prevent the server changing encryption behaviour without a restart\n+        if (datagridEncryptionChanged) {\n+            return !configuration.getDatagridEncryptionEnabled().equalsIgnoreCase(\"true\");\n+        }\n+        return  configuration.getDatagridEncryptionEnabled().equalsIgnoreCase(\"true\");", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0MzAyMg==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367443022", "bodyText": "I don't get who a method called isDatagridEncryptionEnabled would return true when the configuration is false. That does not make sense for me even if the encryption has changed.\n\nI tried to explain why in the comment but I'll expand.\nIf you've changed the settings (let's say you've enabled it), this will be replicated to both the domain.xml and the config bean - any call to HazelcastRuntimeConfiguration.getDatagridEncryptionEnabled will return true. However, we don't want to suddenly start demanding that everything be encrypted otherwise we'll end up with a clustered store where only some things are encrypted. So until restart, we want to return the opposite.\nAlthough now thinking about it again, the current impl is flawed in that if you enable it and then disable it again without restarting the server, it'll start saying it's enabled - I'll change it so it stores the old value as it's changed and returns that.", "author": "Pandrex247", "createdAt": "2020-01-16T14:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1MDAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0NjYyNg==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367446626", "bodyText": "That sounds more reasonable. As I understand it this should always return the initial value at start.", "author": "jbee", "createdAt": "2020-01-16T14:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1MDAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1MTU3Mg==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367351572", "bodyText": "Looks exactly like the code generating the key if I'm not mistaken.", "author": "jbee", "createdAt": "2020-01-16T10:50:15Z", "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/encryption/SymmetricEncryptor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.hazelcast.encryption;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.nio.IOUtil;\n+import com.sun.enterprise.security.ssl.impl.MasterPasswordImpl;\n+import org.glassfish.api.admin.ServerEnvironment;\n+import org.glassfish.internal.api.Globals;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Base64;\n+import java.util.Random;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Class that encodes and decodes symmetric keys.\n+ *\n+ * @author Andrew Pielage <andrew.pielage@payara.fish>\n+ * @author Rudy De Busscher <rudy.de.busscher@payara.fish>\n+ */\n+public class SymmetricEncryptor {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final String AES = \"AES\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static Random random = new SecureRandom();\n+    private static SecretKey secretKey;\n+\n+    static {\n+        secretKey = readAndDecryptSecretKey();\n+    }\n+\n+    public static String encode(byte[] value) {\n+        // Generate IV.\n+        byte[] saltBytes = new byte[20];\n+        random.nextBytes(saltBytes);\n+\n+        try {\n+            // Encrypting the data\n+            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n+            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n+            AlgorithmParameters params = cipher.getParameters();\n+            byte[] ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n+            byte[] encryptedTextBytes = cipher.doFinal(value);\n+\n+            // Prepend salt and IV\n+            byte[] buffer = new byte[saltBytes.length + ivBytes.length + encryptedTextBytes.length];\n+            System.arraycopy(saltBytes, 0, buffer, 0, saltBytes.length);\n+            System.arraycopy(ivBytes, 0, buffer, saltBytes.length, ivBytes.length);\n+            System.arraycopy(encryptedTextBytes, 0, buffer, saltBytes.length + ivBytes.length,\n+                    encryptedTextBytes.length);\n+            return Base64.getEncoder().encodeToString(buffer);\n+        } catch (NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException | IllegalBlockSizeException", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1NDc1Mg==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367354752", "bodyText": "I don't see why this would be a String instead of byte[] directly. The extra step of encoding that as String again seems unnecessary and a potential source or trouble.", "author": "jbee", "createdAt": "2020-01-16T10:57:34Z", "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/encryption/PayaraHazelcastEncryptedValueHolder.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.hazelcast.encryption;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * @author Andrew Pielage <andrew.pielage@payara.fish>\n+ */\n+public class PayaraHazelcastEncryptedValueHolder implements Serializable {\n+\n+    private String encryptedObjectString;", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ1NDEwNQ==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367454105", "bodyText": "I don't know the low-level details well enough to comment on if there's an advantage to doing Base64.getEncoder().encodeToString(buffer); vs. Base64.getEncoder().encode(buffer);\nEven if there's no security advantage surely the difference is so low that it's never going to be the straw that broke the camel's back? Willing to be proven wrong but to me this seems like complaining about the use of int over short :P", "author": "Pandrex247", "createdAt": "2020-01-16T14:40:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1NDc1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ1NjY3OQ==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367456679", "bodyText": "My suggestion was to not do base64 at all. Just take what comes out of crypto. As I understand it the base64 is just to make the result human readable but here there is no need. Just raw bytes are fine and spare us some back and forth conversion.", "author": "jbee", "createdAt": "2020-01-16T14:44:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1NDc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1NTUxOQ==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367355519", "bodyText": "Is this intentionally build so it will not change until JVM is restarted even in case the underlying source (file?) should change?", "author": "jbee", "createdAt": "2020-01-16T10:59:12Z", "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/encryption/SymmetricEncryptor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.hazelcast.encryption;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.nio.IOUtil;\n+import com.sun.enterprise.security.ssl.impl.MasterPasswordImpl;\n+import org.glassfish.api.admin.ServerEnvironment;\n+import org.glassfish.internal.api.Globals;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Base64;\n+import java.util.Random;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Class that encodes and decodes symmetric keys.\n+ *\n+ * @author Andrew Pielage <andrew.pielage@payara.fish>\n+ * @author Rudy De Busscher <rudy.de.busscher@payara.fish>\n+ */\n+public class SymmetricEncryptor {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final String AES = \"AES\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static Random random = new SecureRandom();\n+    private static SecretKey secretKey;\n+\n+    static {\n+        secretKey = readAndDecryptSecretKey();", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NzY3NQ==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367547675", "bodyText": "Yes - to prevent things being stored using different encryption keys.\nThe key should be symmetric: domain-wide.", "author": "Pandrex247", "createdAt": "2020-01-16T17:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1NTUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1NjE4NQ==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367356185", "bodyText": "What about encrypting null references?\nIf I read code in store correctly nulls are not wrapped and stored \"plain\".", "author": "jbee", "createdAt": "2020-01-16T11:00:43Z", "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/encryption/SymmetricEncryptor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.hazelcast.encryption;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.nio.IOUtil;\n+import com.sun.enterprise.security.ssl.impl.MasterPasswordImpl;\n+import org.glassfish.api.admin.ServerEnvironment;\n+import org.glassfish.internal.api.Globals;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Base64;\n+import java.util.Random;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Class that encodes and decodes symmetric keys.\n+ *\n+ * @author Andrew Pielage <andrew.pielage@payara.fish>\n+ * @author Rudy De Busscher <rudy.de.busscher@payara.fish>\n+ */\n+public class SymmetricEncryptor {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final String AES = \"AES\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static Random random = new SecureRandom();\n+    private static SecretKey secretKey;\n+\n+    static {\n+        secretKey = readAndDecryptSecretKey();\n+    }\n+\n+    public static String encode(byte[] value) {\n+        // Generate IV.\n+        byte[] saltBytes = new byte[20];\n+        random.nextBytes(saltBytes);\n+\n+        try {\n+            // Encrypting the data\n+            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n+            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n+            AlgorithmParameters params = cipher.getParameters();\n+            byte[] ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n+            byte[] encryptedTextBytes = cipher.doFinal(value);\n+\n+            // Prepend salt and IV\n+            byte[] buffer = new byte[saltBytes.length + ivBytes.length + encryptedTextBytes.length];\n+            System.arraycopy(saltBytes, 0, buffer, 0, saltBytes.length);\n+            System.arraycopy(ivBytes, 0, buffer, saltBytes.length, ivBytes.length);\n+            System.arraycopy(encryptedTextBytes, 0, buffer, saltBytes.length + ivBytes.length,\n+                    encryptedTextBytes.length);\n+            return Base64.getEncoder().encodeToString(buffer);\n+        } catch (NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException | IllegalBlockSizeException\n+                | InvalidParameterSpecException | BadPaddingException exception) {\n+            throw new HazelcastException(exception);\n+        }\n+    }\n+\n+    public static byte[] decode(String encryptedText) {\n+        byte[] decryptedTextBytes;\n+        try {\n+            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n+            // Strip off the salt and IV\n+            ByteBuffer buffer = ByteBuffer.wrap(Base64.getDecoder().decode((encryptedText)));\n+            byte[] saltBytes = new byte[20];\n+            buffer.get(saltBytes, 0, saltBytes.length);\n+            byte[] ivBytes = new byte[cipher.getBlockSize()];\n+            buffer.get(ivBytes, 0, ivBytes.length);\n+            byte[] encryptedTextBytes = new byte[buffer.capacity() - saltBytes.length - ivBytes.length];\n+\n+            buffer.get(encryptedTextBytes);\n+            cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(ivBytes));\n+            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);\n+        } catch (BadPaddingException exception) {\n+            // BadPaddingException -> Wrong key\n+            throw new HazelcastException(\"BadPaddingException caught decoding data, \" +\n+                    \"this can be caused by an incorrect or changed key: \", exception);\n+        } catch (IllegalBlockSizeException | NoSuchAlgorithmException | InvalidAlgorithmParameterException\n+                | InvalidKeyException | NoSuchPaddingException exception) {\n+            throw new HazelcastException(exception);\n+        }\n+\n+        return decryptedTextBytes;\n+    }\n+\n+    private static SecretKey readAndDecryptSecretKey() {\n+        ServerEnvironment serverEnvironment = Globals.getDefaultBaseServiceLocator().getService(ServerEnvironment.class);\n+        char[] masterPassword = Globals.getDefaultBaseServiceLocator().getService(MasterPasswordImpl.class).getMasterPassword();\n+\n+        byte[] encryptedBytes = null;\n+        try {\n+            encryptedBytes = Files.readAllBytes(\n+                    new File(serverEnvironment.getConfigDirPath() + File.separator + DATAGRID_KEY_FILE).toPath());\n+        } catch (IOException ioe) {\n+            Logger.getLogger(SymmetricEncryptor.class.getName()).log(Level.SEVERE,\n+                    \"Error reading datagrid key, please check if it's accessible at expected location: \"\n+                            + serverEnvironment.getConfigDirPath() + File.separator + DATAGRID_KEY_FILE);\n+            throw new HazelcastException(\"Error reading encrypted key\", ioe);\n+        }\n+\n+        if (encryptedBytes == null) {\n+            throw new HazelcastException(\"Encrypted key appears to be null\");\n+        }\n+\n+        try {\n+            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n+\n+            // Strip off the salt and IV\n+            ByteBuffer buffer = ByteBuffer.wrap(Base64.getDecoder().decode(encryptedBytes));\n+            byte[] saltBytes = new byte[20];\n+            buffer.get(saltBytes, 0, saltBytes.length);\n+            byte[] ivBytes = new byte[cipher.getBlockSize()];\n+            buffer.get(ivBytes, 0, ivBytes.length);\n+            byte[] encryptedTextBytes = new byte[buffer.capacity() - saltBytes.length - ivBytes.length];\n+            buffer.get(encryptedTextBytes);\n+\n+            // Deriving the key\n+            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBKDF_ALGORITHM);\n+            PBEKeySpec spec = new PBEKeySpec(masterPassword, saltBytes, ITERATION_COUNT, KEYSIZE);\n+            SecretKey secretKeySpec = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), AES);\n+            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, new IvParameterSpec(ivBytes));\n+            return new SecretKeySpec(cipher.doFinal(encryptedTextBytes), \"AES\");\n+        } catch (BadPaddingException bpe) {\n+            throw new HazelcastException(\"BadPaddingException caught decrypting data grid key\" +\n+                    \"- likely caused by an incorrect or changed master password\", bpe);\n+        } catch (IllegalBlockSizeException | NoSuchAlgorithmException | InvalidAlgorithmParameterException\n+                | InvalidKeyException | InvalidKeySpecException | NoSuchPaddingException exception) {\n+            throw new HazelcastException(exception);\n+        }\n+    }\n+\n+    public static byte[] objectToByteArray(Object object) {\n+        byte[] bytes = null;\n+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bos)) {\n+            out.writeObject(object);\n+            bytes = bos.toByteArray();\n+        } catch (IOException ioe) {\n+            // See \"if (bytes == null)\"\n+        }\n+        if (bytes == null) {\n+            throw new HazelcastException(\"Error converting Object to Byte Array\");\n+        }\n+        return bytes;\n+    }\n+\n+    public static Object byteArrayToObject(byte[] bytes) {\n+        Object object;\n+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes)) {\n+            object = IOUtil.newObjectInputStream(Thread.currentThread().getContextClassLoader(), null, bis).readObject();\n+        } catch (IOException | ClassNotFoundException exception) {\n+            throw new HazelcastException(\"Error converting Byte Array to Object\", exception);\n+        }\n+        if (object == null) {\n+            throw new HazelcastException(\"Object appears to be null, something probably went wrong converting Byte Array to Object\");", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1MDk5Ng==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367550996", "bodyText": "Good spot!", "author": "Pandrex247", "createdAt": "2020-01-16T17:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1NjE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1ODA2MQ==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367358061", "bodyText": "Same code as above L194-200\nBTW: instanceof \"includes\" a check != null as a null reference will come out as false", "author": "jbee", "createdAt": "2020-01-16T11:05:19Z", "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/store/ClusteredStore.java", "diffHunk": "@@ -212,26 +226,19 @@ public void event(Event event) {\n             if (map != null) {\n                 Set<Serializable> keys = map.keySet();\n                 for (Serializable key : keys) {\n-                    result.put(key, (Serializable) map.get(key));\n+                    Serializable value = (Serializable) map.get(key);\n+\n+                    if (value != null && hzCore.isDatagridEncryptionEnabled()\n+                            && value instanceof PayaraHazelcastEncryptedValueHolder) {\n+                        value = (Serializable) SymmetricEncryptor.byteArrayToObject(\n+                                SymmetricEncryptor.decode(\n+                                        ((PayaraHazelcastEncryptedValueHolder) value).getEncryptedObjectString()));\n+                    }", "originalCommit": "93024348d2b320a12991bcc36a1c12bf08bb3408", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4d545b6ebb7598b7194def1bd2eb232d13f4fcf3", "url": "https://github.com/payara/Payara/commit/4d545b6ebb7598b7194def1bd2eb232d13f4fcf3", "message": "PAYARA-3324 Kill Hazelcast if error reading encryption key", "committedDate": "2020-01-16T11:58:03Z", "type": "commit"}, {"oid": "7d449bf7b9b98cd749077937fdd0a7d1470edc1f", "url": "https://github.com/payara/Payara/commit/7d449bf7b9b98cd749077937fdd0a7d1470edc1f", "message": "PAYARA-3324 Better null handling when checking if encryption is enabled", "committedDate": "2020-01-16T12:21:16Z", "type": "commit"}, {"oid": "34b0369f09b6d68c77be29de279fc6f3da0afca3", "url": "https://github.com/payara/Payara/commit/34b0369f09b6d68c77be29de279fc6f3da0afca3", "message": "PAYARA-3324 Address most review comments", "committedDate": "2020-01-17T11:58:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxNDQ1NQ==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r368014455", "bodyText": "If oldDatagridEncryptionValue is returned in case it is different to datagridEncryptionEnabled this method can be simplified to just return oldDatagridEncryptionValue.", "author": "jbee", "createdAt": "2020-01-17T16:08:57Z", "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/HazelcastCore.java", "diffHunk": "@@ -555,6 +561,26 @@ public int getPort() {\n \n     @Override\n     public UnprocessedChangeEvents changed(PropertyChangeEvent[] pces) {\n-        return null;\n+        List<UnprocessedChangeEvent> unprocessedChanges = new ArrayList<>();\n+        for (PropertyChangeEvent pce : pces) {\n+            if (pce.getPropertyName().equalsIgnoreCase(\"datagrid-encryption-enabled\")) {\n+                unprocessedChanges.add(new UnprocessedChangeEvent(pce, \"Hazelcast encryption settings changed\"));\n+            }\n+        }\n+\n+        if (unprocessedChanges.isEmpty()) {\n+            return null;\n+        }\n+        return new UnprocessedChangeEvents(unprocessedChanges);\n+    }\n+\n+    public boolean isDatagridEncryptionEnabled() {\n+        // If the datagrid encryption settings have changed, we want to return the opposite of the current setting\n+        // to prevent the server changing encryption behaviour without a restart\n+        boolean datagridEncryptionEnabled = configuration.getDatagridEncryptionEnabled().equalsIgnoreCase(\"true\");\n+        if (oldDatagridEncryptionValue != datagridEncryptionEnabled) {\n+            return oldDatagridEncryptionValue;\n+        }\n+        return datagridEncryptionEnabled;", "originalCommit": "34b0369f09b6d68c77be29de279fc6f3da0afca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzODA5Mw==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r368038093", "bodyText": "\ud83e\udd26\u200d\u2642\ufe0f", "author": "Pandrex247", "createdAt": "2020-01-17T16:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxNDQ1NQ=="}], "type": "inlineReview"}, {"oid": "7a84767d6d1414fa5306fd394fb6d51d878804f2", "url": "https://github.com/payara/Payara/commit/7a84767d6d1414fa5306fd394fb6d51d878804f2", "message": "D'oh!", "committedDate": "2020-01-17T17:01:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3MjExMA==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r368472110", "bodyText": "With Boolean.parseBoolean there is no autoboxing in the code.", "author": "rdebusscher", "createdAt": "2020-01-20T10:26:29Z", "path": "nucleus/admin/server-mgmt/src/main/java/com/sun/enterprise/admin/servermgmt/cli/LocalServerCommand.java", "diffHunk": "@@ -612,4 +619,25 @@ private long getEndTime() {\n         return CLIConstants.WAIT_FOR_DAS_TIME_MS + now();\n     }\n \n+    protected boolean dataGridEncryptionEnabled() throws IOException, XMLStreamException {\n+        // We can't access config beans from this invocation due to it being CLI vs. ASAdmin command - it's not\n+        // executing against a running server. This means we need to read directly from the domain.xml.\n+        XMLEventReader xmlReader = XMLInputFactory.newInstance().createXMLEventReader(new FileInputStream(getDomainXml()));\n+        while (xmlReader.hasNext()) {\n+            XMLEvent event = xmlReader.nextEvent();\n+\n+            if (event.isStartElement()\n+                    && event.asStartElement().getName().getLocalPart().equals(\"hazelcast-runtime-configuration\")) {\n+                Attribute attribute = event.asStartElement().getAttributeByName(new QName(\"datagrid-encryption-enabled\"));\n+                if (attribute == null) {\n+                    return false;\n+                }\n+                return Boolean.valueOf(attribute.getValue());", "originalCommit": "7a84767d6d1414fa5306fd394fb6d51d878804f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3MjYwMg==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r368472602", "bodyText": "Explicit types not needed.", "author": "rdebusscher", "createdAt": "2020-01-20T10:27:28Z", "path": "appserver/ha/ha-hazelcast-store/src/main/java/fish/payara/ha/hazelcast/store/HazelcastBackingStoreFactory.java", "diffHunk": "@@ -36,9 +60,12 @@ and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n     @Inject\n     HazelcastCore core;\n \n+    @Inject\n+    ClusteredStore clusteredStore;\n+\n     @Override\n     public <K extends Serializable, V extends Serializable> BackingStore<K, V> createBackingStore(BackingStoreConfiguration<K, V> bsc) throws BackingStoreException {\n-        return new HazelcastBackingStore<K, V>(this, bsc.getStoreName(), core);\n+        return new HazelcastBackingStore<K, V>(this, bsc.getStoreName(), clusteredStore);", "originalCommit": "7a84767d6d1414fa5306fd394fb6d51d878804f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3NDAxMQ==", "url": "https://github.com/payara/Payara/pull/4433#discussion_r368474011", "bodyText": "encryptedBytes is never null as Files.readAllBytes never returns null.", "author": "rdebusscher", "createdAt": "2020-01-20T10:30:18Z", "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/encryption/HazelcastSymmetricEncryptor.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.hazelcast.encryption;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.nio.IOUtil;\n+import com.sun.enterprise.security.ssl.impl.MasterPasswordImpl;\n+import fish.payara.nucleus.hazelcast.HazelcastCore;\n+import org.glassfish.api.admin.ServerEnvironment;\n+import org.glassfish.internal.api.Globals;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Random;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Class that encodes and decodes symmetric keys.\n+ *\n+ * @author Andrew Pielage <andrew.pielage@payara.fish>\n+ * @author Rudy De Busscher <rudy.de.busscher@payara.fish>\n+ */\n+public class HazelcastSymmetricEncryptor {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final String AES = \"AES\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static Random random = new SecureRandom();\n+    private static SecretKey secretKey;\n+\n+    static {\n+        try {\n+            secretKey = readAndDecryptSecretKey();\n+        } catch (Exception exception) {\n+            // Shutting down Payara from the thread we're running in can only be done in fairly brutal ways\n+            Logger.getLogger(HazelcastSymmetricEncryptor.class.getName()).log(Level.SEVERE,\n+                    \"Error starting Hazelcast due to exception reading encryption key\", exception);\n+            Globals.get(HazelcastCore.class).getInstance().shutdown();\n+        }\n+    }\n+\n+    public static byte[] encode(byte[] value) {\n+        // Generate IV.\n+        byte[] saltBytes = new byte[20];\n+        random.nextBytes(saltBytes);\n+\n+        try {\n+            // Encrypting the data\n+            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n+            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n+            AlgorithmParameters params = cipher.getParameters();\n+            byte[] ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n+            byte[] encryptedTextBytes = cipher.doFinal(value);\n+\n+            // Prepend salt and IV\n+            byte[] buffer = new byte[saltBytes.length + ivBytes.length + encryptedTextBytes.length];\n+            System.arraycopy(saltBytes, 0, buffer, 0, saltBytes.length);\n+            System.arraycopy(ivBytes, 0, buffer, saltBytes.length, ivBytes.length);\n+            System.arraycopy(encryptedTextBytes, 0, buffer, saltBytes.length + ivBytes.length,\n+                    encryptedTextBytes.length);\n+            return buffer;\n+        } catch (NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException | IllegalBlockSizeException\n+                | InvalidParameterSpecException | BadPaddingException exception) {\n+            throw new HazelcastException(exception);\n+        }\n+    }\n+\n+    public static byte[] decode(byte[] encryptedTextBytes) {\n+        byte[] decryptedTextBytes;\n+        try {\n+            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n+            // Strip off the salt and IV\n+            ByteBuffer buffer = ByteBuffer.wrap(encryptedTextBytes);\n+            byte[] saltBytes = new byte[20];\n+            buffer.get(saltBytes, 0, saltBytes.length);\n+            byte[] ivBytes = new byte[cipher.getBlockSize()];\n+            buffer.get(ivBytes, 0, ivBytes.length);\n+            encryptedTextBytes = new byte[buffer.capacity() - saltBytes.length - ivBytes.length];\n+\n+            buffer.get(encryptedTextBytes);\n+            cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(ivBytes));\n+            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);\n+        } catch (BadPaddingException exception) {\n+            // BadPaddingException -> Wrong key\n+            throw new HazelcastException(\"BadPaddingException caught decoding data, \" +\n+                    \"this can be caused by an incorrect or changed key: \", exception);\n+        } catch (IllegalBlockSizeException | NoSuchAlgorithmException | InvalidAlgorithmParameterException\n+                | InvalidKeyException | NoSuchPaddingException exception) {\n+            throw new HazelcastException(exception);\n+        }\n+\n+        return decryptedTextBytes;\n+    }\n+\n+    private static SecretKey readAndDecryptSecretKey() {\n+        ServerEnvironment serverEnvironment = Globals.getDefaultBaseServiceLocator().getService(ServerEnvironment.class);\n+        char[] masterPassword = Globals.getDefaultBaseServiceLocator().getService(MasterPasswordImpl.class).getMasterPassword();\n+\n+        byte[] encryptedBytes = null;\n+        try {\n+            encryptedBytes = Files.readAllBytes(\n+                    new File(serverEnvironment.getConfigDirPath() + File.separator + DATAGRID_KEY_FILE).toPath());\n+        } catch (IOException ioe) {\n+            Logger.getLogger(HazelcastSymmetricEncryptor.class.getName()).log(Level.SEVERE,\n+                    \"Error reading datagrid key, please check if it's accessible at expected location: \"\n+                            + serverEnvironment.getConfigDirPath() + File.separator + DATAGRID_KEY_FILE);\n+            throw new HazelcastException(\"Error reading encrypted key\", ioe);\n+        }\n+\n+        if (encryptedBytes == null) {", "originalCommit": "7a84767d6d1414fa5306fd394fb6d51d878804f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "969f3cff70a0bf27ad98ff698fa6723bbc7350dc", "url": "https://github.com/payara/Payara/commit/969f3cff70a0bf27ad98ff698fa6723bbc7350dc", "message": "Rdebusscher Review Comments\n\nRemove unnecessary autoboxing and null check, and use diamond operator", "committedDate": "2020-01-21T10:57:06Z", "type": "commit"}, {"oid": "bab2e6b860ca9650da239ece3fc4604e4916ab8c", "url": "https://github.com/payara/Payara/commit/bab2e6b860ca9650da239ece3fc4604e4916ab8c", "message": "APPSERV-41 Add encryption enabled log messages", "committedDate": "2020-01-22T15:28:15Z", "type": "commit"}]}