{"pr_number": 4452, "pr_title": "APPSERV-19 Adds monitoring of stuck and hogging threads to monitoring console", "pr_createdAt": "2020-01-23T13:09:56Z", "pr_url": "https://github.com/payara/Payara/pull/4452", "timeline": [{"oid": "4daf5f5d0292300240a36fb9ef7a2bd929ddf1cb", "url": "https://github.com/payara/Payara/commit/4daf5f5d0292300240a36fb9ef7a2bd929ddf1cb", "message": "Merge branch 'master' into APPSERV-14-slow-sql", "committedDate": "2020-01-22T15:29:17Z", "type": "commit"}, {"oid": "1c24432c7229cf29460e2729fd91fe9d158483a7", "url": "https://github.com/payara/Payara/commit/1c24432c7229cf29460e2729fd91fe9d158483a7", "message": "Merge branch 'master' into APPSERV-19-threads", "committedDate": "2020-01-22T15:40:19Z", "type": "commit"}, {"oid": "268b0075dfeb1522d4de81ca6c33d5ef931e91e0", "url": "https://github.com/payara/Payara/commit/268b0075dfeb1522d4de81ca6c33d5ef931e91e0", "message": "APPSERV-19 adds initial version of threads page showing stuck and hogging thread incidents", "committedDate": "2020-01-23T13:08:33Z", "type": "commit"}, {"oid": "430fb236623cc0778c256eb0ad150569efc371ac", "url": "https://github.com/payara/Payara/commit/430fb236623cc0778c256eb0ad150569efc371ac", "message": "APPSERV-19 updates copyright header and retry count min changed to zero", "committedDate": "2020-01-23T15:27:02Z", "type": "commit"}, {"oid": "3c882b33e8efc20138ece79385530a3a97946094", "url": "https://github.com/payara/Payara/commit/3c882b33e8efc20138ece79385530a3a97946094", "message": "APPSERV-19 adds unit tests for SeriesAnnotation keyed property", "committedDate": "2020-01-23T15:38:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMDU1MA==", "url": "https://github.com/payara/Payara/pull/4452#discussion_r370230550", "bodyText": "NB. using the interval from the options is only an approximation of the actual time passed in the measurement interval. As this now can be different intervals for the check run by the health check service and the monitoring data collection I changed this to use the actual time passed. This is also more accurate.", "author": "jbee", "createdAt": "2020-01-23T16:41:44Z", "path": "nucleus/payara-modules/healthcheck-core/src/main/java/fish/payara/nucleus/healthcheck/preliminary/HoggingThreadsHealthCheck.java", "diffHunk": "@@ -91,65 +142,107 @@ public String getDescription() {\n \n     @Override\n     protected HealthCheckResult doCheckInternal() {\n-        hoggingThreads.set(0);\n         HealthCheckResult result = new HealthCheckResult();\n-        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n-\n-        if (!threadBean.isCurrentThreadCpuTimeSupported()) {\n+        if (!supported) {\n             result.add(new HealthCheckResultEntry(HealthCheckResultStatus.CHECK_ERROR, \"JVM implementation or OS does\" +\n                     \" not support getting CPU times\"));\n             return result;\n         }\n+        acceptHoggingThreads(checkRecordsByThreadId, \n+                (percentage, threshold, totalTimeHogging, initialMethod, info) -> {\n+                    result.add(new HealthCheckResultEntry(HealthCheckResultStatus.CRITICAL,\n+                            \"Thread with <id-name>: \" + info.getThreadId() + \"-\" + info.getThreadName() +\n+                            \" is a hogging thread for the last \" +\n+                            prettyPrintDuration(totalTimeHogging) + \"\\n\" + prettyPrintStackTrace(info.getStackTrace())));\n+                });\n+        return result;\n+    }\n \n-        final long[] ids = threadBean.getAllThreadIds();\n-        for (long id : ids) {\n-            if (id == Thread.currentThread().getId())\n-                continue;\n-            final long c = threadBean.getThreadCpuTime(id);\n-            final long u = threadBean.getThreadUserTime(id);\n-            ThreadInfo threadInfo = threadBean.getThreadInfo(id);\n+    @Override\n+    @MonitoringData(ns = \"health\", intervalSeconds = 4)\n+    public void collect(MonitoringDataCollector collector) {\n+        if (options == null || !options.isEnabled() || !supported) {\n+            return;\n+        }\n+        AtomicInteger hoggingThreadCount = new AtomicInteger(0);\n+        AtomicLong hoggingThreadMaxDuration = new AtomicLong(0L);\n+        acceptHoggingThreads(colletionRecordsByThreadId, \n+                (percentage, threshold, totalTimeHogging, initialMethod, info) -> {\n+                    String thread = info.getThreadName();\n+                    if (thread == null || thread.isEmpty()) {\n+                        thread = String.valueOf(info.getThreadId());\n+                    }\n+                    collector.annotate(\"HoggingThreadDuration\", totalTimeHogging, true, //\n+                            \"Thread\", thread, //\n+                            \"Usage%\", String.valueOf(percentage), //\n+                            \"Threshold%\", String.valueOf(threshold), //\n+                            \"Method\", initialMethod, //\n+                            \"Exited\", String.valueOf(!initialMethod.equals(getMethod(info))));\n+                    hoggingThreadCount.incrementAndGet();\n+                    hoggingThreadMaxDuration.updateAndGet(value -> Math.max(value, totalTimeHogging));\n+                });\n+        collector\n+        .collect(\"HoggingThreadCount\", hoggingThreadCount)\n+        .collect(\"HoggingThreadDuration\", hoggingThreadMaxDuration);\n+    }\n \n-            if (c == -1 || u == -1)\n-                continue;\n+    @Override\n+    public void collect(MonitoringWatchCollector collector) {\n+        if (options == null || !options.isEnabled() || !supported) {\n+            return;\n+        }\n+        collector.watch(\"ns:health HoggingThreadCount\", \"Hogging Threads\", \"count\")\n+            .amber(0, -2, false, null, null, false)\n+            .red(1, -2, false, null, null, false);\n+    }\n \n-            ThreadTimes times = threadTimes.get(id);\n-            if (times == null) {\n-                times = new ThreadTimes();\n-                times.setId(id);\n-                times.setName(threadInfo.getThreadName());\n-                times.setStartCpuTime(c);\n-                times.setEndCpuTime(c);\n-                times.setStartUserTime(u);\n-                times.setEndUserTime(u);\n-                threadTimes.put(id, times);\n+    private void acceptHoggingThreads(Map<Long, ThreadCpuTimeRecord> recordsById, HoggingThreadConsumer consumer) {\n+        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+        long now = System.currentTimeMillis();\n+        long currentThreadId = Thread.currentThread().getId();\n+        int retryCount = options.getRetryCount();\n+        int threshold = options.getThresholdPercentage().intValue();\n+        for (long threadId : bean.getAllThreadIds()) {\n+            if (threadId == currentThreadId)\n+                continue;\n+            final long cpuTimeInNanos = bean.getThreadCpuTime(threadId);\n+            if (cpuTimeInNanos == -1)\n+                continue;\n+            long cpuTime = TimeUnit.NANOSECONDS.toMillis(cpuTimeInNanos); \n+            // from here all times are in millis\n+            ThreadCpuTimeRecord record = recordsById.get(threadId);\n+            if (record == null) {\n+                record = new ThreadCpuTimeRecord();\n+                recordsById.put(threadId, record);\n             } else {\n-                times.setStartCpuTime(times.getEndCpuTime());\n-                times.setStartUserTime(times.getEndUserTime());\n-                times.setEndCpuTime(c);\n-                times.setEndUserTime(u);\n-\n-                long checkTime = getOptions().getUnit().toMillis(getOptions().getTime());", "originalCommit": "3c882b33e8efc20138ece79385530a3a97946094", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMjQyNw==", "url": "https://github.com/payara/Payara/pull/4452#discussion_r370232427", "bodyText": "NB. As discussed in chat the timeHeld here was a semantic confusion. The map contained the timestamp when the thread started the work. I changed the algorithm accordingly and also changed all the computation to be based on milliseconds as nanosecond level only would make sense if we would run the check often and fast enough (every t with a t < 1ms)", "author": "jbee", "createdAt": "2020-01-23T16:45:15Z", "path": "nucleus/payara-modules/healthcheck-stuck/src/main/java/fish/payara/nucleus/healthcheck/stuck/StuckThreadsHealthCheck.java", "diffHunk": "@@ -59,58 +69,118 @@\n \n /**\n  * @since 4.1.2.173\n- * @author jonathan coustick\n+ * @author jonathan coustick (initial)\n+ * @author Jan Bernitt (consumer based and monitoring)\n  */\n @Service(name = \"healthcheck-stuck\")\n @RunLevel(StartupRunLevel.VAL)\n public class StuckThreadsHealthCheck extends\n-        BaseHealthCheck<HealthCheckStuckThreadExecutionOptions, StuckThreadsChecker> {\n+        BaseHealthCheck<HealthCheckStuckThreadExecutionOptions, StuckThreadsChecker>\n+        implements MonitoringDataSource, MonitoringWatchSource {\n+\n+    @FunctionalInterface\n+    private interface StuckThreadConsumer {\n+        void accept(long workStartedTime, long timeWorkingInMillis, long thresholdInMillis, ThreadInfo stuck);\n+    }\n \n     @Inject\n     StuckThreadsStore stuckThreadsStore;\n \n     @Inject\n     StuckThreadsChecker checker;\n \n-    private final Map<ThreadInfo, Long> stuckThreads = new ConcurrentHashMap<>();\n-\n     @PostConstruct\n     void postConstruct() {\n         postConstruct(this, StuckThreadsChecker.class);\n     }\n \n     @Override\n     protected HealthCheckResult doCheckInternal() {\n-        stuckThreads.clear();\n         HealthCheckResult result = new HealthCheckResult();\n-        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+        acceptStuckThreads((workStartedTime, timeWorkingInMillis, thresholdInMillis, info) ->\n+            result.add(new HealthCheckResultEntry(HealthCheckResultStatus.WARNING, \"Stuck Thread: \" + info.toString())));\n+        return result;\n+    }\n \n-        Long thresholdNanos = TimeUnit.NANOSECONDS.convert(options.getTimeStuck(), options.getUnitStuck());\n+    @Override\n+    @MonitoringData(ns = \"health\", intervalSeconds = 4)\n+    public void collect(MonitoringDataCollector collector) {\n+        if (options == null || !options.isEnabled()) {\n+            return;\n+        }\n+        AtomicInteger count = new AtomicInteger(0);\n+        AtomicLong maxDuration = new AtomicLong(0L);\n+        acceptStuckThreads((workStartedTime, timeWorkingInMillis, thresholdInMillis, info) -> {\n+            String thread = info.getThreadName();\n+            if (thread == null || thread.isEmpty()) {\n+                thread = String.valueOf(info.getThreadId());\n+            }\n+            collector.annotate(\"StuckThreadDuration\", timeWorkingInMillis, true, //\n+                    \"Thread\", thread, // OBS! must be the first attribute as it is the key.\n+                    \"Started\", String.valueOf(workStartedTime), //\n+                    \"Threshold\", String.valueOf(thresholdInMillis), //\n+                    \"Locked\", Boolean.toString(info.getLockInfo() != null), //\n+                    \"Suspended\", String.valueOf(info.isSuspended()), //\n+                    \"State\", composeStateText(info));\n+            count.incrementAndGet();\n+            maxDuration.updateAndGet(value -> Math.max(value, timeWorkingInMillis));\n+        });\n+        collector.collect(\"StuckThreadDuration\", maxDuration);\n+        collector.collect(\"StuckThreadCount\", count);\n+    }\n \n+    @Override\n+    public void collect(MonitoringWatchCollector collector) {\n+        if (options == null || !options.isEnabled()) {\n+            return;\n+        }\n+        collector.watch(\"ns:health StuckThreadDuration\", \"Stuck Threads\", \"ms\")\n+            .red(getThresholdInMillis(), -30000L, false, null, null, false);\n+    }\n+\n+    public String composeStateText(ThreadInfo info) {\n+        if (info.getLockInfo() == null) {\n+            return \"Running\";\n+        }\n+        Thread.State state = info.getThreadState();\n+        String action = state == State.BLOCKED ? \"Blocked on \" //\n+                : state == State.WAITING || state == State.TIMED_WAITING ? \"Waiting on \" : \"Running \";\n+        return action + info.getLockInfo().toString();\n+    }\n+\n+    private void acceptStuckThreads(StuckThreadConsumer consumer) {\n+        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+        long thresholdInMillis = getThresholdInMillis();\n+        long now = System.currentTimeMillis();\n         ConcurrentHashMap<Long, Long> threads = stuckThreadsStore.getThreads();\n-        for (Long thread : threads.keySet()){\n-            Long timeHeld = threads.get(thread);", "originalCommit": "3c882b33e8efc20138ece79385530a3a97946094", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYxMDc2Mg==", "url": "https://github.com/payara/Payara/pull/4452#discussion_r370610762", "bodyText": "I think this possibly needs a bit more cleanup, as you can still configure it with a threshold of 5 nanoseconds.\nParticularly in the monitoring console you get a funny situation where you get a Threshold listed as 0 in comparison to something like 5ms. In this case, you could possibly change it to have it say the threshold is <1ms", "author": "Pandrex247", "createdAt": "2020-01-24T12:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYyODAzMQ==", "url": "https://github.com/payara/Payara/pull/4452#discussion_r370628031", "bodyText": "Agreed, I think this should possibly be handled by a separate PR.", "author": "jbee", "createdAt": "2020-01-24T13:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY1NTMwMg==", "url": "https://github.com/payara/Payara/pull/4452#discussion_r370655302", "bodyText": "\ud83d\udc4d I'll create a separate Jira", "author": "Pandrex247", "createdAt": "2020-01-24T14:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMjQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5MDA1Nw==", "url": "https://github.com/payara/Payara/pull/4452#discussion_r370590057", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            annotations.poll();\n          \n          \n            \n                        annotations.poll();\n          \n      \n    \n    \n  \n\nRandom double indent", "author": "Pandrex247", "createdAt": "2020-01-24T11:31:16Z", "path": "appserver/monitoring-console/core/src/main/java/fish/payara/monitoring/store/InMemoryMonitoringDataRepository.java", "diffHunk": "@@ -289,19 +291,22 @@ private void addLocalPoint(CharSequence key, long value) {\n         }\n     }\n \n-    private void addLocalAnnotation(CharSequence series, long value, String[] annotations) {\n+    private void addLocalAnnotation(CharSequence series, long value, boolean keyed, String[] annotations) {\n         Series s = seriesOrNull(series);\n         if (s != null) {\n-            addAnnotation(new SeriesAnnotation(collectedSecond, s, instanceName, value, annotations));\n+            addAnnotation(new SeriesAnnotation(collectedSecond, s, instanceName, value, keyed, annotations));\n         }\n     }\n \n     private void addAnnotation(SeriesAnnotation annotation) {\n         Queue<SeriesAnnotation> annotations = annotationsBySeries.computeIfAbsent(annotation.getSeries(), //\n                 key -> new ConcurrentLinkedQueue<>());\n+        if (annotation.isKeyed()) {\n+            annotations.removeIf(a -> Objects.equals(a.getKeyAttribute(), annotation.getKeyAttribute()));\n+        }\n         annotations.add(annotation);\n-        if (annotations.size() > 20) {\n-            annotations.poll();\n+        if (annotations.size() > MAX_ANNOTATIONS_PER_SERIES) {\n+                annotations.poll();", "originalCommit": "3c882b33e8efc20138ece79385530a3a97946094", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5MDc2NA==", "url": "https://github.com/payara/Payara/pull/4452#discussion_r370590764", "bodyText": "Just checking - should Usage and Threshold have the %?", "author": "Pandrex247", "createdAt": "2020-01-24T11:33:17Z", "path": "appserver/monitoring-console/webapp/src/main/webapp/js/mc-model.js", "diffHunk": "@@ -262,6 +262,24 @@ MonitoringConsole.Model = (function() {\n \t\t\t\t\t\t\tdecorations: { alerts: { noOngoing: true, noAcknowledged: true}},\n \t\t\t\t\t\t\toptions: { noAnnotations: true}},\n \t\t\t\t\t],\n+\t\t\t\t},\n+\t\t\t\tthreads: {\n+\t\t\t\t\tname: 'Threads',\n+\t\t\t\t\tnumberOfColumns: 4,\n+\t\t\t\t\twidgets: [\n+\t\t\t\t\t\t{ series: 'ns:health StuckThreadDuration', type: 'annotation', mode: 'table', unit: 'ms',\n+\t\t\t\t\t\t\tdisplayName: 'Stuck Thread Incidents',\n+\t\t\t\t\t\t\tgrid: {column: 0, item: 1, colspan: 3, rowspan: 1},\n+\t\t\t\t\t\t\tfields: [\"Thread\", \"Started\", \"Value\", \"Threshold\", \"Suspended\", \"Locked\", \"State\"]},\n+\t\t\t\t\t\t{ series: 'ns:health HoggingThreadDuration', type: 'annotation', mode: 'table', unit: 'ms',\n+\t\t\t\t\t\t\tdisplayName: 'Hogging Thread Incidents',\n+\t\t\t\t\t\t\tgrid: {column: 0, item: 2, colspan: 3, rowspan: 1},\n+\t\t\t\t\t\t\tfields: [\"Thread\", \"When\", \"Value\", \"Usage%\", \"Threshold%\", \"Method\", \"Exited\"]},", "originalCommit": "3c882b33e8efc20138ece79385530a3a97946094", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYyNjk2Ng==", "url": "https://github.com/payara/Payara/pull/4452#discussion_r370626966", "bodyText": "yes, that was intentional.", "author": "jbee", "createdAt": "2020-01-24T13:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU5MDc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYwNzM1Nw==", "url": "https://github.com/payara/Payara/pull/4452#discussion_r370607357", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    .collect(\"HoggingThreadCount\", hoggingThreadCount)\n          \n          \n            \n                            .collect(\"HoggingThreadCount\", hoggingThreadCount)\n          \n      \n    \n    \n  \n\nIndenting", "author": "Pandrex247", "createdAt": "2020-01-24T12:22:08Z", "path": "nucleus/payara-modules/healthcheck-core/src/main/java/fish/payara/nucleus/healthcheck/preliminary/HoggingThreadsHealthCheck.java", "diffHunk": "@@ -91,65 +142,107 @@ public String getDescription() {\n \n     @Override\n     protected HealthCheckResult doCheckInternal() {\n-        hoggingThreads.set(0);\n         HealthCheckResult result = new HealthCheckResult();\n-        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n-\n-        if (!threadBean.isCurrentThreadCpuTimeSupported()) {\n+        if (!supported) {\n             result.add(new HealthCheckResultEntry(HealthCheckResultStatus.CHECK_ERROR, \"JVM implementation or OS does\" +\n                     \" not support getting CPU times\"));\n             return result;\n         }\n+        acceptHoggingThreads(checkRecordsByThreadId, \n+                (percentage, threshold, totalTimeHogging, initialMethod, info) -> {\n+                    result.add(new HealthCheckResultEntry(HealthCheckResultStatus.CRITICAL,\n+                            \"Thread with <id-name>: \" + info.getThreadId() + \"-\" + info.getThreadName() +\n+                            \" is a hogging thread for the last \" +\n+                            prettyPrintDuration(totalTimeHogging) + \"\\n\" + prettyPrintStackTrace(info.getStackTrace())));\n+                });\n+        return result;\n+    }\n \n-        final long[] ids = threadBean.getAllThreadIds();\n-        for (long id : ids) {\n-            if (id == Thread.currentThread().getId())\n-                continue;\n-            final long c = threadBean.getThreadCpuTime(id);\n-            final long u = threadBean.getThreadUserTime(id);\n-            ThreadInfo threadInfo = threadBean.getThreadInfo(id);\n+    @Override\n+    @MonitoringData(ns = \"health\", intervalSeconds = 4)\n+    public void collect(MonitoringDataCollector collector) {\n+        if (options == null || !options.isEnabled() || !supported) {\n+            return;\n+        }\n+        AtomicInteger hoggingThreadCount = new AtomicInteger(0);\n+        AtomicLong hoggingThreadMaxDuration = new AtomicLong(0L);\n+        acceptHoggingThreads(colletionRecordsByThreadId, \n+                (percentage, threshold, totalTimeHogging, initialMethod, info) -> {\n+                    String thread = info.getThreadName();\n+                    if (thread == null || thread.isEmpty()) {\n+                        thread = String.valueOf(info.getThreadId());\n+                    }\n+                    collector.annotate(\"HoggingThreadDuration\", totalTimeHogging, true, //\n+                            \"Thread\", thread, //\n+                            \"Usage%\", String.valueOf(percentage), //\n+                            \"Threshold%\", String.valueOf(threshold), //\n+                            \"Method\", initialMethod, //\n+                            \"Exited\", String.valueOf(!initialMethod.equals(getMethod(info))));\n+                    hoggingThreadCount.incrementAndGet();\n+                    hoggingThreadMaxDuration.updateAndGet(value -> Math.max(value, totalTimeHogging));\n+                });\n+        collector\n+        .collect(\"HoggingThreadCount\", hoggingThreadCount)", "originalCommit": "3c882b33e8efc20138ece79385530a3a97946094", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYwNzYyOA==", "url": "https://github.com/payara/Payara/pull/4452#discussion_r370607628", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    .collect(\"HoggingThreadDuration\", hoggingThreadMaxDuration);\n          \n          \n            \n                            .collect(\"HoggingThreadDuration\", hoggingThreadMaxDuration);\n          \n      \n    \n    \n  \n\nIndenting 2: The tab vs. space wars", "author": "Pandrex247", "createdAt": "2020-01-24T12:22:56Z", "path": "nucleus/payara-modules/healthcheck-core/src/main/java/fish/payara/nucleus/healthcheck/preliminary/HoggingThreadsHealthCheck.java", "diffHunk": "@@ -91,65 +142,107 @@ public String getDescription() {\n \n     @Override\n     protected HealthCheckResult doCheckInternal() {\n-        hoggingThreads.set(0);\n         HealthCheckResult result = new HealthCheckResult();\n-        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n-\n-        if (!threadBean.isCurrentThreadCpuTimeSupported()) {\n+        if (!supported) {\n             result.add(new HealthCheckResultEntry(HealthCheckResultStatus.CHECK_ERROR, \"JVM implementation or OS does\" +\n                     \" not support getting CPU times\"));\n             return result;\n         }\n+        acceptHoggingThreads(checkRecordsByThreadId, \n+                (percentage, threshold, totalTimeHogging, initialMethod, info) -> {\n+                    result.add(new HealthCheckResultEntry(HealthCheckResultStatus.CRITICAL,\n+                            \"Thread with <id-name>: \" + info.getThreadId() + \"-\" + info.getThreadName() +\n+                            \" is a hogging thread for the last \" +\n+                            prettyPrintDuration(totalTimeHogging) + \"\\n\" + prettyPrintStackTrace(info.getStackTrace())));\n+                });\n+        return result;\n+    }\n \n-        final long[] ids = threadBean.getAllThreadIds();\n-        for (long id : ids) {\n-            if (id == Thread.currentThread().getId())\n-                continue;\n-            final long c = threadBean.getThreadCpuTime(id);\n-            final long u = threadBean.getThreadUserTime(id);\n-            ThreadInfo threadInfo = threadBean.getThreadInfo(id);\n+    @Override\n+    @MonitoringData(ns = \"health\", intervalSeconds = 4)\n+    public void collect(MonitoringDataCollector collector) {\n+        if (options == null || !options.isEnabled() || !supported) {\n+            return;\n+        }\n+        AtomicInteger hoggingThreadCount = new AtomicInteger(0);\n+        AtomicLong hoggingThreadMaxDuration = new AtomicLong(0L);\n+        acceptHoggingThreads(colletionRecordsByThreadId, \n+                (percentage, threshold, totalTimeHogging, initialMethod, info) -> {\n+                    String thread = info.getThreadName();\n+                    if (thread == null || thread.isEmpty()) {\n+                        thread = String.valueOf(info.getThreadId());\n+                    }\n+                    collector.annotate(\"HoggingThreadDuration\", totalTimeHogging, true, //\n+                            \"Thread\", thread, //\n+                            \"Usage%\", String.valueOf(percentage), //\n+                            \"Threshold%\", String.valueOf(threshold), //\n+                            \"Method\", initialMethod, //\n+                            \"Exited\", String.valueOf(!initialMethod.equals(getMethod(info))));\n+                    hoggingThreadCount.incrementAndGet();\n+                    hoggingThreadMaxDuration.updateAndGet(value -> Math.max(value, totalTimeHogging));\n+                });\n+        collector\n+        .collect(\"HoggingThreadCount\", hoggingThreadCount)\n+        .collect(\"HoggingThreadDuration\", hoggingThreadMaxDuration);", "originalCommit": "3c882b33e8efc20138ece79385530a3a97946094", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a27d926445481241b78921d4deed860d546e9d89", "url": "https://github.com/payara/Payara/commit/a27d926445481241b78921d4deed860d546e9d89", "message": "Update appserver/monitoring-console/core/src/main/java/fish/payara/monitoring/store/InMemoryMonitoringDataRepository.java\n\nCo-Authored-By: Andrew Pielage <pandrex247@hotmail.com>", "committedDate": "2020-01-24T13:14:06Z", "type": "commit"}, {"oid": "2ede58b607f9213d05cfbcc1eeef132a76d7b34e", "url": "https://github.com/payara/Payara/commit/2ede58b607f9213d05cfbcc1eeef132a76d7b34e", "message": "Update nucleus/payara-modules/healthcheck-core/src/main/java/fish/payara/nucleus/healthcheck/preliminary/HoggingThreadsHealthCheck.java\n\nCo-Authored-By: Andrew Pielage <pandrex247@hotmail.com>", "committedDate": "2020-01-24T13:14:56Z", "type": "commit"}, {"oid": "268fd2a3e00c3fd29089de5498c07fb081b44cf8", "url": "https://github.com/payara/Payara/commit/268fd2a3e00c3fd29089de5498c07fb081b44cf8", "message": "Update nucleus/payara-modules/healthcheck-core/src/main/java/fish/payara/nucleus/healthcheck/preliminary/HoggingThreadsHealthCheck.java\n\nCo-Authored-By: Andrew Pielage <pandrex247@hotmail.com>", "committedDate": "2020-01-24T13:15:05Z", "type": "commit"}]}