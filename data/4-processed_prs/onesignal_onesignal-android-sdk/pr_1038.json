{"pr_number": 1038, "pr_title": "Refactor Influence module to Kotlin", "pr_createdAt": "2020-06-01T23:58:08Z", "pr_url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038", "timeline": [{"oid": "e18f64461eab0dd8fb460e134d271cf4679488f4", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/e18f64461eab0dd8fb460e134d271cf4679488f4", "message": "Refactor Influence module to Kotlin\n\n  * Change influence module classes from java to kotlin\n  * Remove instrumentedPackage from roboelectric tests, this will make time shadow to not work\n  * Add OSTime for time method access\n  * Mock OSTime on Tests", "committedDate": "2020-06-02T00:00:05Z", "type": "forcePushed"}, {"oid": "dd43281b803c63f2fcbbeca9b052e644d502ee72", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/dd43281b803c63f2fcbbeca9b052e644d502ee72", "message": "Refactor Influence module to Kotlin\n\n  * Change influence module classes from java to kotlin\n  * Remove instrumentedPackage from roboelectric tests, this will make time shadow to not work\n  * Add OSTime for time method access\n  * Mock OSTime on Tests", "committedDate": "2020-06-02T00:05:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwNDI5Nw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459004297", "bodyText": "This should go in the root build.gradle.", "author": "jkasten2", "createdAt": "2020-07-22T18:40:15Z", "path": "OneSignalSDK/onesignal/build.gradle", "diffHunk": "@@ -66,6 +68,11 @@ dependencies {\n \n     // compileOnly as this is just for fallback code if AppCompatActivity wasn't added to the project.\n     compileOnly 'com.android.support:appcompat-v7:26.1.0'\n+\n+    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n }\n \n apply from: 'maven-push.gradle'\n+repositories {\n+    mavenCentral()", "originalCommit": "dd43281b803c63f2fcbbeca9b052e644d502ee72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODE3NQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459028175", "bodyText": "This code has a lot of nesting, probably ok as an upper limit. Ideally I would like to set this as an early return instead of a large amount of code nested under this let block. Or moved into another method.", "author": "jkasten2", "createdAt": "2020-07-22T19:22:05Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "diffHunk": "@@ -0,0 +1,171 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OneSignal\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import com.onesignal.influence.model.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+abstract class OSChannelTracker internal constructor(protected var dataRepository: OSInfluenceDataRepository, var logger: OSLogger) {\n+    var influenceType: OSInfluenceType? = null\n+    var indirectIds: JSONArray? = null\n+    var directId: String? = null\n+\n+    abstract val idTag: String\n+    abstract val channelType: OSInfluenceChannel\n+\n+    @get:Throws(JSONException::class)\n+    abstract val lastChannelObjects: JSONArray\n+    abstract val channelLimit: Int\n+    abstract val indirectAttributionWindow: Int\n+    abstract fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray\n+    abstract fun saveChannelObjects(channelObjects: JSONArray)\n+    abstract fun initInfluencedTypeFromCache()\n+    abstract fun cacheState()\n+    abstract fun addSessionData(jsonObject: JSONObject, influence: OSInfluence)\n+\n+    private val isDirectSessionEnabled: Boolean\n+        get() = dataRepository.isDirectInfluenceEnabled\n+\n+    private val isIndirectSessionEnabled: Boolean\n+        get() = dataRepository.isIndirectInfluenceEnabled\n+\n+    private val isUnattributedSessionEnabled: Boolean\n+        get() = dataRepository.isUnattributedInfluenceEnabled\n+\n+    /**\n+     * Get the current session based on state + if outcomes features are enabled.\n+     */\n+    val currentSessionInfluence: OSInfluence\n+        get() {\n+            val sessionInfluence = OSInfluence(channelType, OSInfluenceType.DISABLED, null)\n+            // Channel weren't init yet because application is starting\n+            if (influenceType == null) initInfluencedTypeFromCache()\n+            influenceType?.let {", "originalCommit": "dd43281b803c63f2fcbbeca9b052e644d502ee72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAxMjI4NA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r461012284", "bodyText": "made an auxiliary currentInfluenceType to avoid null check", "author": "Jeasmine", "createdAt": "2020-07-27T16:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MDgxNw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r461940817", "bodyText": "\ud83d\udc4d val currentInfluenceType = influenceType ?: OSInfluenceType.DISABLED", "author": "jkasten2", "createdAt": "2020-07-28T22:59:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODk5Ng==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459028996", "bodyText": "Remove this., to be more consistent with the code above.", "author": "jkasten2", "createdAt": "2020-07-22T19:23:43Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "diffHunk": "@@ -0,0 +1,171 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OneSignal\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import com.onesignal.influence.model.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+abstract class OSChannelTracker internal constructor(protected var dataRepository: OSInfluenceDataRepository, var logger: OSLogger) {\n+    var influenceType: OSInfluenceType? = null\n+    var indirectIds: JSONArray? = null\n+    var directId: String? = null\n+\n+    abstract val idTag: String\n+    abstract val channelType: OSInfluenceChannel\n+\n+    @get:Throws(JSONException::class)\n+    abstract val lastChannelObjects: JSONArray\n+    abstract val channelLimit: Int\n+    abstract val indirectAttributionWindow: Int\n+    abstract fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray\n+    abstract fun saveChannelObjects(channelObjects: JSONArray)\n+    abstract fun initInfluencedTypeFromCache()\n+    abstract fun cacheState()\n+    abstract fun addSessionData(jsonObject: JSONObject, influence: OSInfluence)\n+\n+    private val isDirectSessionEnabled: Boolean\n+        get() = dataRepository.isDirectInfluenceEnabled\n+\n+    private val isIndirectSessionEnabled: Boolean\n+        get() = dataRepository.isIndirectInfluenceEnabled\n+\n+    private val isUnattributedSessionEnabled: Boolean\n+        get() = dataRepository.isUnattributedInfluenceEnabled\n+\n+    /**\n+     * Get the current session based on state + if outcomes features are enabled.\n+     */\n+    val currentSessionInfluence: OSInfluence\n+        get() {\n+            val sessionInfluence = OSInfluence(channelType, OSInfluenceType.DISABLED, null)\n+            // Channel weren't init yet because application is starting\n+            if (influenceType == null) initInfluencedTypeFromCache()\n+            influenceType?.let {\n+                if (it.isDirect()) {\n+                    if (isDirectSessionEnabled) {\n+                        sessionInfluence.apply {\n+                            ids = JSONArray().put(this@OSChannelTracker.directId)\n+                            influenceType = OSInfluenceType.DIRECT\n+                        }\n+                    }\n+                } else if (it.isIndirect()) {\n+                    if (isIndirectSessionEnabled) {\n+                        sessionInfluence.apply {\n+                            ids = this@OSChannelTracker.indirectIds\n+                            influenceType = OSInfluenceType.INDIRECT\n+                        }\n+                    }\n+                } else if (isUnattributedSessionEnabled) {\n+                    sessionInfluence.apply {\n+                        this.influenceType = OSInfluenceType.UNATTRIBUTED", "originalCommit": "dd43281b803c63f2fcbbeca9b052e644d502ee72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMTYxNg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459031616", "bodyText": "Might be better to use just object so there isn't a companion object under the hood.\nhttps://stackoverflow.com/a/50520935\n@Jeasmine Thoughts on this?", "author": "jkasten2", "createdAt": "2020-07-22T19:28:42Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.kt", "diffHunk": "@@ -0,0 +1,171 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OneSignal\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import com.onesignal.influence.model.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+abstract class OSChannelTracker internal constructor(protected var dataRepository: OSInfluenceDataRepository, var logger: OSLogger) {\n+    var influenceType: OSInfluenceType? = null\n+    var indirectIds: JSONArray? = null\n+    var directId: String? = null\n+\n+    abstract val idTag: String\n+    abstract val channelType: OSInfluenceChannel\n+\n+    @get:Throws(JSONException::class)\n+    abstract val lastChannelObjects: JSONArray\n+    abstract val channelLimit: Int\n+    abstract val indirectAttributionWindow: Int\n+    abstract fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray\n+    abstract fun saveChannelObjects(channelObjects: JSONArray)\n+    abstract fun initInfluencedTypeFromCache()\n+    abstract fun cacheState()\n+    abstract fun addSessionData(jsonObject: JSONObject, influence: OSInfluence)\n+\n+    private val isDirectSessionEnabled: Boolean\n+        get() = dataRepository.isDirectInfluenceEnabled\n+\n+    private val isIndirectSessionEnabled: Boolean\n+        get() = dataRepository.isIndirectInfluenceEnabled\n+\n+    private val isUnattributedSessionEnabled: Boolean\n+        get() = dataRepository.isUnattributedInfluenceEnabled\n+\n+    /**\n+     * Get the current session based on state + if outcomes features are enabled.\n+     */\n+    val currentSessionInfluence: OSInfluence\n+        get() {\n+            val sessionInfluence = OSInfluence(channelType, OSInfluenceType.DISABLED, null)\n+            // Channel weren't init yet because application is starting\n+            if (influenceType == null) initInfluencedTypeFromCache()\n+            influenceType?.let {\n+                if (it.isDirect()) {\n+                    if (isDirectSessionEnabled) {\n+                        sessionInfluence.apply {\n+                            ids = JSONArray().put(this@OSChannelTracker.directId)\n+                            influenceType = OSInfluenceType.DIRECT\n+                        }\n+                    }\n+                } else if (it.isIndirect()) {\n+                    if (isIndirectSessionEnabled) {\n+                        sessionInfluence.apply {\n+                            ids = this@OSChannelTracker.indirectIds\n+                            influenceType = OSInfluenceType.INDIRECT\n+                        }\n+                    }\n+                } else if (isUnattributedSessionEnabled) {\n+                    sessionInfluence.apply {\n+                        this.influenceType = OSInfluenceType.UNATTRIBUTED\n+                    }\n+                }\n+            }\n+            return sessionInfluence\n+        }\n+\n+    /**\n+     * Get all received ids that may influence actions\n+     *\n+     * @return ids that happen between attribution window\n+     */\n+    val lastReceivedIds: JSONArray\n+        get() {\n+            val ids = JSONArray()\n+            try {\n+                val lastChannelObjectReceived = lastChannelObjects\n+                logger.debug(\"OneSignal ChannelTracker getLastReceivedIds lastChannelObjectReceived: $lastChannelObjectReceived\")\n+                val attributionWindow = indirectAttributionWindow * 60 * 1000L\n+                val currentTime = OneSignal.getTime().currentTimeMillis\n+                for (i in 0 until lastChannelObjectReceived.length()) {\n+                    val jsonObject = lastChannelObjectReceived.getJSONObject(i)\n+                    val time = jsonObject.getLong(TIME)\n+                    val difference = currentTime - time\n+                    if (difference <= attributionWindow) {\n+                        val id = jsonObject.getString(idTag)\n+                        ids.put(id)\n+                    }\n+                }\n+            } catch (exception: JSONException) {\n+                logger.error(\"Generating tracker getLastReceivedIds JSONObject \", exception)\n+            }\n+            return ids\n+        }\n+\n+    fun resetAndInitInfluence() {\n+        directId = null\n+        indirectIds = lastReceivedIds\n+        influenceType = if (indirectIds?.length() ?: 0 > 0) OSInfluenceType.INDIRECT else OSInfluenceType.UNATTRIBUTED\n+        cacheState()\n+        logger.debug(\"OneSignal OSChannelTracker resetAndInitInfluence: $idTag finish with influenceType: $influenceType\")\n+    }\n+\n+    /**\n+     * Save state of last ids received\n+     */\n+    fun saveLastId(id: String?) {\n+        logger.debug(\"OneSignal OSChannelTracker for: $idTag saveLastId: $id\")\n+        if (id == null || id.isEmpty()) return\n+        val lastChannelObjectsReceived = getLastChannelObjectsReceivedByNewId(id)\n+        logger.debug(\"OneSignal OSChannelTracker for: $idTag saveLastId with lastChannelObjectsReceived: $lastChannelObjectsReceived\")\n+        try {\n+            val newInfluenceId = JSONObject()\n+                    .put(idTag, id)\n+                    .put(TIME, OneSignal.getTime().currentTimeMillis)\n+            lastChannelObjectsReceived.put(newInfluenceId)\n+        } catch (exception: JSONException) {\n+            logger.error(\"Generating tracker newInfluenceId JSONObject \", exception)\n+            // We don't have new data, stop logic\n+            return\n+        }\n+        val channelLimit = channelLimit\n+        var channelObjectToSave = lastChannelObjectsReceived\n+        // Only save the last ids without surpassing the limit\n+        // Always keep the max quantity of ids possible\n+        // If the attribution window increases, old ids might influence\n+        if (lastChannelObjectsReceived.length() > channelLimit) {\n+            val lengthDifference = lastChannelObjectsReceived.length() - channelLimit\n+            // If min sdk is greater than KITKAT we can refactor this logic to removeObject from JSONArray\n+            channelObjectToSave = JSONArray()\n+            for (i in lengthDifference until lastChannelObjectsReceived.length()) {\n+                try {\n+                    channelObjectToSave.put(lastChannelObjectsReceived[i])\n+                } catch (exception: JSONException) {\n+                    logger.error(\"Generating tracker lastChannelObjectsReceived get JSONObject \", exception)\n+                }\n+            }\n+        }\n+        logger.debug(\"OneSignal OSChannelTracker for: $idTag with channelObjectToSave: $channelObjectToSave\")\n+        saveChannelObjects(channelObjectToSave)\n+    }\n+\n+    override fun toString(): String {\n+        return \"OSChannelTracker{\" +\n+                \"tag=\" + idTag +\n+                \", influenceType=\" + influenceType +\n+                \", indirectIds=\" + indirectIds +\n+                \", directId=\" + directId +\n+                '}'\n+    }\n+\n+    override fun equals(other: Any?): Boolean {\n+        if (this === other) return true\n+        if (other == null || javaClass != other.javaClass) return false\n+        val tracker = other as OSChannelTracker\n+        return influenceType === tracker.influenceType && tracker.idTag == idTag\n+    }\n+\n+    override fun hashCode(): Int {\n+        var result = influenceType.hashCode()\n+        result = 31 * result + idTag.hashCode()\n+        return result\n+    }\n+\n+    companion object {\n+        private const val TIME = \"time\"", "originalCommit": "dd43281b803c63f2fcbbeca9b052e644d502ee72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExNjMzMQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r461116331", "bodyText": "Thanks for this comment! I was looking to de decompiled java code for companion object and object inside a class, for both cases constants object are inlined where used, but a static class is defined and not used, so I checked that the best way is to have a single object file, in that way we don't have companion/object in the classes. Also, companion is a special case of an object. We should only use a companion for static initialization or method access. For reference https://blog.egorand.me/where-do-i-put-my-constants-in-kotlin/", "author": "Jeasmine", "createdAt": "2020-07-27T19:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMTYxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk0MTYzNQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r461941635", "bodyText": "\ud83d\udc4d", "author": "jkasten2", "createdAt": "2020-07-28T23:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMTYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMjM1OQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459032359", "bodyText": "Same, see my const comment above.", "author": "jkasten2", "createdAt": "2020-07-22T19:30:04Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSInAppMessageTracker.kt", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import com.onesignal.influence.model.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+internal class OSInAppMessageTracker(dataRepository: OSInfluenceDataRepository, logger: OSLogger) : OSChannelTracker(dataRepository, logger) {\n+    override val idTag: String\n+        get() = iamIdTag\n+\n+    override val channelType: OSInfluenceChannel\n+        get() = OSInfluenceChannel.IAM\n+\n+    override fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray {\n+        var lastChannelObjectReceived: JSONArray\n+        lastChannelObjectReceived = try {\n+            lastChannelObjects\n+        } catch (exception: JSONException) {\n+            logger.error(\"Generating IAM tracker getLastChannelObjects JSONObject \", exception)\n+            return JSONArray()\n+        }\n+        // For IAM we handle redisplay, we need to remove duplicates for new influence Id\n+        // If min sdk is greater than KITKAT we can refactor this logic to removeObject from JSONArray\n+        try {\n+            val auxLastChannelObjectReceived = JSONArray()\n+            for (i in 0 until lastChannelObjectReceived.length()) {\n+                val objectId = lastChannelObjectReceived.getJSONObject(i).getString(idTag)\n+                if (id != objectId) {\n+                    auxLastChannelObjectReceived.put(lastChannelObjectReceived.getJSONObject(i))\n+                }\n+            }\n+            lastChannelObjectReceived = auxLastChannelObjectReceived\n+        } catch (exception: JSONException) {\n+            logger.error(\"Before KITKAT API, Generating tracker lastChannelObjectReceived get JSONObject \", exception)\n+        }\n+        return lastChannelObjectReceived\n+    }\n+\n+    @get:Throws(JSONException::class)\n+    override val lastChannelObjects: JSONArray\n+        get() = dataRepository.lastIAMsReceivedData\n+\n+    override val channelLimit: Int\n+        get() = dataRepository.iamLimit\n+\n+    override val indirectAttributionWindow: Int\n+        get() = dataRepository.iamIndirectAttributionWindow\n+\n+    override fun saveChannelObjects(channelObjects: JSONArray) {\n+        dataRepository.saveIAMs(channelObjects)\n+    }\n+\n+    override fun initInfluencedTypeFromCache() {\n+        influenceType = dataRepository.iamCachedInfluenceType.also {\n+            if (it.isIndirect()) indirectIds = lastReceivedIds\n+        }\n+        logger.debug(\"OneSignal InAppMessageTracker initInfluencedTypeFromCache: $this\")\n+    }\n+\n+    override fun addSessionData(jsonObject: JSONObject, influence: OSInfluence) { // In app message don't influence the session\n+    }\n+\n+    override fun cacheState() {\n+        dataRepository.cacheIAMInfluenceType((if (influenceType == null) OSInfluenceType.UNATTRIBUTED else influenceType)!!)\n+    }\n+\n+    companion object {\n+        @JvmField\n+        val TAG = OSInAppMessageTracker::class.java.canonicalName", "originalCommit": "dd43281b803c63f2fcbbeca9b052e644d502ee72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMjcxNg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459032716", "bodyText": "Same, see my const comment above.", "author": "jkasten2", "createdAt": "2020-07-22T19:30:42Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSInfluenceDataRepository.kt", "diffHunk": "@@ -0,0 +1,225 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSSharedPreferences\n+import com.onesignal.OneSignalRemoteParams\n+import com.onesignal.OneSignalRemoteParams.InfluenceParams\n+import com.onesignal.influence.model.OSInfluenceType\n+import com.onesignal.influence.model.OSInfluenceType.Companion.fromString\n+import org.json.JSONArray\n+import org.json.JSONException\n+\n+/**\n+ * Setter and Getter of Notifications received\n+ */\n+class OSInfluenceDataRepository(private val preferences: OSSharedPreferences) {\n+\n+    /**\n+     * Cache a influence type enum for Notification as a string\n+     */\n+    fun cacheNotificationInfluenceType(influenceType: OSInfluenceType) {\n+        preferences.saveString(\n+                preferences.preferencesName,\n+                PREFS_OS_OUTCOMES_CURRENT_NOTIFICATION_INFLUENCE,\n+                influenceType.toString()\n+        )\n+    }\n+\n+    /**\n+     * Get the current cached influence type string, convert it to the influence type enum, and return it\n+     */\n+    val notificationCachedInfluenceType: OSInfluenceType\n+        get() {\n+            val influenceType = preferences.getString(\n+                    preferences.preferencesName,\n+                    PREFS_OS_OUTCOMES_CURRENT_NOTIFICATION_INFLUENCE,\n+                    OSInfluenceType.UNATTRIBUTED.toString()\n+            )\n+            return fromString(influenceType)\n+        }\n+\n+    /**\n+     * Cache a influence type enum for IAM as a string\n+     */\n+    fun cacheIAMInfluenceType(influenceType: OSInfluenceType) {\n+        preferences.saveString(\n+                preferences.preferencesName,\n+                PREFS_OS_OUTCOMES_CURRENT_IAM_INFLUENCE,\n+                influenceType.toString()\n+        )\n+    }\n+\n+    /**\n+     * Get the current cached influence type string, convert it to the influence type enum, and return it\n+     */\n+    val iamCachedInfluenceType: OSInfluenceType\n+        get() {\n+            val influenceType = preferences.getString(\n+                    preferences.preferencesName,\n+                    PREFS_OS_OUTCOMES_CURRENT_IAM_INFLUENCE,\n+                    OSInfluenceType.UNATTRIBUTED.toString()\n+            )\n+            return fromString(influenceType)\n+        }\n+\n+    /**\n+     * Cache attributed notification opened\n+     */\n+    fun cacheNotificationOpenId(id: String?) {\n+        preferences.saveString(\n+                preferences.preferencesName,\n+                PREFS_OS_LAST_ATTRIBUTED_NOTIFICATION_OPEN,\n+                id\n+        )\n+    }\n+\n+    /**\n+     * Get the current cached notification id, null if not direct\n+     */\n+    val cachedNotificationOpenId: String?\n+        get() = preferences.getString(\n+                preferences.preferencesName,\n+                PREFS_OS_LAST_ATTRIBUTED_NOTIFICATION_OPEN,\n+                null\n+        )\n+\n+    fun saveNotifications(notifications: JSONArray) {\n+        preferences.saveString(\n+                preferences.preferencesName,\n+                PREFS_OS_LAST_NOTIFICATIONS_RECEIVED,\n+                notifications.toString())\n+    }\n+\n+    fun saveIAMs(iams: JSONArray) {\n+        preferences.saveString(\n+                preferences.preferencesName,\n+                PREFS_OS_LAST_IAMS_RECEIVED,\n+                iams.toString())\n+    }\n+\n+    @get:Throws(JSONException::class)\n+    val lastNotificationsReceivedData: JSONArray\n+        get() {\n+            val notificationsReceived = preferences.getString(\n+                    preferences.preferencesName,\n+                    PREFS_OS_LAST_NOTIFICATIONS_RECEIVED,\n+                    \"[]\")\n+            return notificationsReceived?.let { JSONArray(it) } ?: JSONArray()\n+        }\n+\n+    @get:Throws(JSONException::class)\n+    val lastIAMsReceivedData: JSONArray\n+        get() {\n+            val iamReceived = preferences.getString(\n+                    preferences.preferencesName,\n+                    PREFS_OS_LAST_IAMS_RECEIVED,\n+                    \"[]\")\n+            return iamReceived?.let { JSONArray(it) } ?: JSONArray()\n+        }\n+\n+    val notificationLimit: Int\n+        get() = preferences.getInt(\n+                preferences.preferencesName,\n+                PREFS_OS_NOTIFICATION_LIMIT,\n+                OneSignalRemoteParams.DEFAULT_NOTIFICATION_LIMIT\n+        )\n+\n+    val iamLimit: Int\n+        get() = preferences.getInt(\n+                preferences.preferencesName,\n+                PREFS_OS_IAM_LIMIT,\n+                OneSignalRemoteParams.DEFAULT_NOTIFICATION_LIMIT\n+        )\n+\n+    val notificationIndirectAttributionWindow: Int\n+        get() = preferences.getInt(\n+                preferences.preferencesName,\n+                PREFS_OS_NOTIFICATION_INDIRECT_ATTRIBUTION_WINDOW,\n+                OneSignalRemoteParams.DEFAULT_INDIRECT_ATTRIBUTION_WINDOW\n+        )\n+\n+    val iamIndirectAttributionWindow: Int\n+        get() = preferences.getInt(\n+                preferences.preferencesName,\n+                PREFS_OS_IAM_INDIRECT_ATTRIBUTION_WINDOW,\n+                OneSignalRemoteParams.DEFAULT_INDIRECT_ATTRIBUTION_WINDOW\n+        )\n+\n+    val isDirectInfluenceEnabled: Boolean\n+        get() = preferences.getBool(\n+                preferences.preferencesName,\n+                PREFS_OS_DIRECT_ENABLED,\n+                false\n+        )\n+\n+    val isIndirectInfluenceEnabled: Boolean\n+        get() = preferences.getBool(\n+                preferences.preferencesName,\n+                PREFS_OS_INDIRECT_ENABLED,\n+                false\n+        )\n+\n+    val isUnattributedInfluenceEnabled: Boolean\n+        get() = preferences.getBool(\n+                preferences.preferencesName,\n+                PREFS_OS_UNATTRIBUTED_ENABLED,\n+                false\n+        )\n+\n+    fun saveInfluenceParams(influenceParams: InfluenceParams) {\n+        preferences.saveBool(\n+                preferences.preferencesName,\n+                PREFS_OS_DIRECT_ENABLED,\n+                influenceParams.isDirectEnabled\n+        )\n+        preferences.saveBool(\n+                preferences.preferencesName,\n+                PREFS_OS_INDIRECT_ENABLED,\n+                influenceParams.isIndirectEnabled\n+        )\n+        preferences.saveBool(\n+                preferences.preferencesName,\n+                PREFS_OS_UNATTRIBUTED_ENABLED,\n+                influenceParams.isUnattributedEnabled\n+        )\n+        preferences.saveInt(\n+                preferences.preferencesName,\n+                PREFS_OS_NOTIFICATION_LIMIT,\n+                influenceParams.notificationLimit\n+        )\n+        preferences.saveInt(\n+                preferences.preferencesName,\n+                PREFS_OS_NOTIFICATION_INDIRECT_ATTRIBUTION_WINDOW,\n+                influenceParams.indirectNotificationAttributionWindow\n+        )\n+        preferences.saveInt(\n+                preferences.preferencesName,\n+                PREFS_OS_IAM_LIMIT,\n+                influenceParams.iamLimit\n+        )\n+        preferences.saveInt(\n+                preferences.preferencesName,\n+                PREFS_OS_IAM_INDIRECT_ATTRIBUTION_WINDOW,\n+                influenceParams.indirectIAMAttributionWindow\n+        )\n+    }\n+\n+    companion object {", "originalCommit": "dd43281b803c63f2fcbbeca9b052e644d502ee72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzNDYzMw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459034633", "bodyText": "\ud83d\udc4d Nice! Liking the single line if statements. Seems like this is encengaged based on the Kotlin docs too.", "author": "jkasten2", "createdAt": "2020-07-22T19:34:14Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSTrackerFactory.kt", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.onesignal.influence\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OSSharedPreferences\n+import com.onesignal.OneSignal.AppEntryAction\n+import com.onesignal.OneSignalRemoteParams.InfluenceParams\n+import com.onesignal.influence.model.OSInfluence\n+import com.onesignal.influence.model.OSInfluenceChannel\n+import org.json.JSONObject\n+import java.util.*\n+import java.util.concurrent.ConcurrentHashMap\n+\n+class OSTrackerFactory(preferences: OSSharedPreferences, logger: OSLogger) {\n+    private val trackers = ConcurrentHashMap<String, OSChannelTracker>()\n+    private val dataRepository: OSInfluenceDataRepository = OSInfluenceDataRepository(preferences)\n+\n+    val influences: List<OSInfluence>\n+        get() = trackers.values.map { it.currentSessionInfluence }\n+\n+    val iAMChannelTracker: OSChannelTracker\n+        get() = trackers[OSInAppMessageTracker.TAG]!!\n+\n+    val notificationChannelTracker: OSChannelTracker\n+        get() = trackers[OSNotificationTracker.TAG]!!\n+\n+    val channels: List<OSChannelTracker>\n+        get() {\n+            val channels: MutableList<OSChannelTracker> = mutableListOf()\n+            notificationChannelTracker?.let { channels.add(it) }\n+            iAMChannelTracker?.let { channels.add(it) }\n+            return channels\n+        }\n+\n+    init {\n+        trackers[OSInAppMessageTracker.TAG] = OSInAppMessageTracker(dataRepository, logger)\n+        trackers[OSNotificationTracker.TAG] = OSNotificationTracker(dataRepository, logger)\n+    }\n+\n+    fun initFromCache() {\n+        trackers.values.forEach {\n+            it.initInfluencedTypeFromCache()\n+        }\n+    }\n+\n+    fun saveInfluenceParams(influenceParams: InfluenceParams) {\n+        dataRepository.saveInfluenceParams(influenceParams)\n+    }\n+\n+    fun addSessionData(jsonObject: JSONObject, influences: List<OSInfluence>) {\n+        influences.forEach {\n+            when (it.influenceChannel) {\n+                OSInfluenceChannel.NOTIFICATION -> notificationChannelTracker?.addSessionData(jsonObject, it)\n+                OSInfluenceChannel.IAM -> {\n+                }\n+            }\n+        }\n+    }\n+\n+    fun getChannelByEntryAction(entryAction: AppEntryAction): OSChannelTracker? {\n+        return if (entryAction.isNotificationClick) notificationChannelTracker else null\n+    }\n+\n+    fun getChannelsToResetByEntryAction(entryAction: AppEntryAction): List<OSChannelTracker> {\n+        val channels: MutableList<OSChannelTracker> = ArrayList()\n+        // Avoid reset session if application is closed\n+        if (entryAction.isAppClose) return channels", "originalCommit": "dd43281b803c63f2fcbbeca9b052e644d502ee72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNzU1MA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r459137550", "bodyText": "This should be in the root build.gradle.", "author": "jkasten2", "createdAt": "2020-07-22T23:21:21Z", "path": "OneSignalSDK/unittest/build.gradle", "diffHunk": "@@ -52,4 +54,10 @@ dependencies {\n     testImplementation 'junit:junit:4.12'\n     testImplementation 'org.robolectric:robolectric:4.3.1'\n     testImplementation 'org.awaitility:awaitility:3.1.5'\n+    testImplementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n+\n+    testImplementation 'org.reflections:reflections:0.9.12'\n+}\n+repositories {\n+    mavenCentral()", "originalCommit": "dd43281b803c63f2fcbbeca9b052e644d502ee72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "72f396baa51d38d30937e3fce3228bf7a28bf17f", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/72f396baa51d38d30937e3fce3228bf7a28bf17f", "message": "Refactor Influence module to Kotlin\n\n  * Change influence module classes from java to kotlin\n  * Remove instrumentedPackage from roboelectric tests, this will make time shadow to not work\n  * Add OSTime for time method access\n  * Mock OSTime on Tests", "committedDate": "2020-07-28T22:44:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwOTc0NA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466609744", "bodyText": "Super nit picky here but lets use ' instead of \" so its consistent with others", "author": "mikechoch", "createdAt": "2020-08-06T18:35:36Z", "path": "OneSignalSDK/build.gradle", "diffHunk": "@@ -18,6 +19,8 @@ buildscript {\n     dependencies {\n         classpath 'com.android.tools.build:gradle:3.6.2'\n \n+        classpath 'com.google.gms:google-services:4.3.2'\n+        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"", "originalCommit": "dba89a3a54391538f99ccab383ccaa7e20a61af9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTE3Mg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466611172", "bodyText": "Also any reason we don't just add '1.3.72' to the end of the classpath instead of ext.kotlin_version = '1.3.72'", "author": "mikechoch", "createdAt": "2020-08-06T18:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwOTc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI0MjkxNw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r467242917", "bodyText": "I wanted to start cleaning this, I usually use ext to define versions, but is not a must, I can change to make all use this new format or remove it, let me know what you think", "author": "Jeasmine", "createdAt": "2020-08-07T20:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwOTc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTMxNw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466611317", "bodyText": "Super nit picky here but lets use ' instead of \" so its consistent with others", "author": "mikechoch", "createdAt": "2020-08-06T18:38:37Z", "path": "OneSignalSDK/onesignal/build.gradle", "diffHunk": "@@ -55,6 +57,8 @@ dependencies {\n     api 'androidx.browser:browser:[1.0.0, 1.99.99]'\n     api 'androidx.appcompat:appcompat:[1.0.0, 1.99.99]'\n     api 'androidx.work:work-runtime:[2.0.0, 2.99.99]'\n+\n+    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"", "originalCommit": "dba89a3a54391538f99ccab383ccaa7e20a61af9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI0MzU4OQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r467243589", "bodyText": "oh good eye!", "author": "Jeasmine", "createdAt": "2020-08-07T20:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI0NTQxNg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r467245416", "bodyText": "oooh actually if we want to start using $kotlin_version variables on gradle, it only use it with \" let mek nos if you prefer to continue with the old format", "author": "Jeasmine", "createdAt": "2020-08-07T20:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA0OTU3OA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r468049578", "bodyText": "Then maybe as we start replacing with ext. we will add \" to all other dependencies", "author": "mikechoch", "createdAt": "2020-08-10T17:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDAyOQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466614029", "bodyText": "Do we want this to be public?", "author": "mikechoch", "createdAt": "2020-08-06T18:43:54Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java", "diffHunk": "@@ -3072,9 +3073,17 @@ static void fireEmailUpdateFailure() {\n       }\n    }\n \n+   @NonNull\n+   public static OSTime getTime() {", "originalCommit": "dba89a3a54391538f99ccab383ccaa7e20a61af9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI0NzQ1Ng==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r467247456", "bodyText": "good catch!", "author": "Jeasmine", "createdAt": "2020-08-07T20:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNTI3Ng==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466615276", "bodyText": "Remove new line here", "author": "mikechoch", "createdAt": "2020-08-06T18:46:14Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/data/OSChannelTracker.kt", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.onesignal.influence.data\n+\n+import com.onesignal.OSLogger\n+import com.onesignal.OneSignal\n+import com.onesignal.influence.OSInfluenceConstants\n+import com.onesignal.influence.domain.OSInfluence\n+import com.onesignal.influence.domain.OSInfluenceChannel\n+import com.onesignal.influence.domain.OSInfluenceType\n+import org.json.JSONArray\n+import org.json.JSONException\n+import org.json.JSONObject\n+\n+abstract class OSChannelTracker internal constructor(protected var dataRepository: OSInfluenceDataRepository, var logger: OSLogger) {\n+    var influenceType: OSInfluenceType? = null\n+    var indirectIds: JSONArray? = null\n+    var directId: String? = null\n+\n+    abstract val idTag: String\n+    abstract val channelType: OSInfluenceChannel\n+\n+    @get:Throws(JSONException::class)\n+    abstract val lastChannelObjects: JSONArray\n+    abstract val channelLimit: Int\n+    abstract val indirectAttributionWindow: Int\n+    abstract fun getLastChannelObjectsReceivedByNewId(id: String?): JSONArray\n+    abstract fun saveChannelObjects(channelObjects: JSONArray)\n+    abstract fun initInfluencedTypeFromCache()\n+    abstract fun cacheState()\n+    abstract fun addSessionData(jsonObject: JSONObject, influence: OSInfluence)\n+\n+    private val isDirectSessionEnabled: Boolean\n+        get() = dataRepository.isDirectInfluenceEnabled\n+\n+    private val isIndirectSessionEnabled: Boolean\n+        get() = dataRepository.isIndirectInfluenceEnabled\n+\n+    private val isUnattributedSessionEnabled: Boolean\n+        get() = dataRepository.isUnattributedInfluenceEnabled\n+\n+    /**\n+     * Get the current session based on state + if outcomes features are enabled.\n+     */\n+    val currentSessionInfluence: OSInfluence\n+        get() {\n+            val sessionInfluence = OSInfluence(channelType, OSInfluenceType.DISABLED, null)\n+            // Channel weren't init yet because application is starting\n+            if (influenceType == null) initInfluencedTypeFromCache()\n+\n+            val currentInfluenceType = influenceType ?: OSInfluenceType.DISABLED\n+\n+            if (currentInfluenceType.isDirect()) {\n+                if (isDirectSessionEnabled) {\n+                    sessionInfluence.apply {\n+                        ids = JSONArray().put(this@OSChannelTracker.directId)\n+                        influenceType = OSInfluenceType.DIRECT\n+                    }\n+                }\n+            } else if (currentInfluenceType.isIndirect()) {\n+                if (isIndirectSessionEnabled) {\n+                    sessionInfluence.apply {\n+                        ids = this@OSChannelTracker.indirectIds\n+                        influenceType = OSInfluenceType.INDIRECT\n+                    }\n+                }\n+            } else if (isUnattributedSessionEnabled) {\n+                sessionInfluence.apply {\n+                    influenceType = OSInfluenceType.UNATTRIBUTED\n+                }\n+            }\n+\n+            return sessionInfluence\n+        }\n+\n+    /**\n+     * Get all received ids that may influence actions\n+     *", "originalCommit": "dba89a3a54391538f99ccab383ccaa7e20a61af9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNjI3Nw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466616277", "bodyText": "Rename to MockOSTimeImpl to match our real OSTimeImpl?", "author": "mikechoch", "createdAt": "2020-08-06T18:48:05Z", "path": "OneSignalSDK/unittest/src/test/java/com/onesignal/MockOSTime.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.onesignal;\n+\n+import android.os.SystemClock;\n+\n+public class MockOSTime implements OSTime {", "originalCommit": "dba89a3a54391538f99ccab383ccaa7e20a61af9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI0OTgyNA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r467249824", "bodyText": "love this one!", "author": "Jeasmine", "createdAt": "2020-08-07T20:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNjI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNzM4MQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466617381", "bodyText": "Instead of passing everything into the advanceSystemTimeBy maybe we should just call a method inside of time?\nExample:\ntime.advanceSystemTimeBy(604_801)?", "author": "mikechoch", "createdAt": "2020-08-06T18:50:05Z", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/GenerateNotificationRunner.java", "diffHunk": "@@ -836,7 +842,7 @@ public void shouldRestoreNotifications() {\n \n       // Go forward 1 week\n       // Note: Does not effect the SQL function strftime\n-      advanceSystemTimeBy(604_801);\n+      advanceSystemTimeBy(time, 604_801);", "originalCommit": "dba89a3a54391538f99ccab383ccaa7e20a61af9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1ODI0Ng==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r467258246", "bodyText": ":not_bad: \ud83d\udc4d", "author": "Jeasmine", "createdAt": "2020-08-07T20:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNzM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxOTQ1OA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466619458", "bodyText": "Add a space advanceSystemAndElapsedTimeBy(time, 0);", "author": "mikechoch", "createdAt": "2020-08-06T18:54:03Z", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/MainOneSignalClassRunner.java", "diffHunk": "@@ -2516,12 +2531,13 @@ public void ensureSyncJobServiceRescheduleOnApiTimeout() throws Exception {\n    }\n \n    private void useAppFor2minThenBackground() throws Exception {\n+      advanceSystemAndElapsedTimeBy(time,0);", "originalCommit": "dba89a3a54391538f99ccab383ccaa7e20a61af9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMTUwMg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1038#discussion_r466621502", "bodyText": "Add a space advanceSystemAndElapsedTimeBy(time, 31);", "author": "mikechoch", "createdAt": "2020-08-06T18:57:33Z", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/TestHelpers.java", "diffHunk": "@@ -241,11 +241,11 @@ static void fastColdRestartApp() throws Exception {\n       StaticResetHelper.restSetStaticFields();\n    }\n \n-   static void restartAppAndElapseTimeToNextSession() throws Exception {\n+   static void restartAppAndElapseTimeToNextSession(MockOSTime time) throws Exception {\n       stopAllOSThreads();\n       flushBufferedSharedPrefs();\n       StaticResetHelper.restSetStaticFields();\n-      advanceSystemTimeBy(31);\n+      advanceSystemAndElapsedTimeBy(time,31);", "originalCommit": "dba89a3a54391538f99ccab383ccaa7e20a61af9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d6186de2a9bd786c3a0d7ff096319e22df9f26e5", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/d6186de2a9bd786c3a0d7ff096319e22df9f26e5", "message": "Code improvement", "committedDate": "2020-08-10T15:24:14Z", "type": "forcePushed"}, {"oid": "37a4e04507d09d0c4820b410594359f3cff50017", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/37a4e04507d09d0c4820b410594359f3cff50017", "message": "Refactor Influence module to Kotlin\n\n  * Change influence module classes from java to kotlin\n  * Remove instrumentedPackage from roboelectric tests, this will make time shadow to not work\n  * Add OSTime for time method access\n  * Mock OSTime on Tests", "committedDate": "2020-08-10T18:20:41Z", "type": "commit"}, {"oid": "818c865eac21a663f1497c7d4c5afa0f25eb8fa4", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/818c865eac21a663f1497c7d4c5afa0f25eb8fa4", "message": "Improve code", "committedDate": "2020-08-10T18:20:41Z", "type": "commit"}, {"oid": "21c7760340816ab101c79d9e2eb373ba36a0edc5", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/21c7760340816ab101c79d9e2eb373ba36a0edc5", "message": "Code improvement", "committedDate": "2020-08-10T18:29:19Z", "type": "commit"}, {"oid": "de9acea2bf8429df57a37192fd022a60a12bdd56", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/de9acea2bf8429df57a37192fd022a60a12bdd56", "message": "Refactor Outcome module to Kotlin\n\n   * Change outcome module classes from java to kotlin", "committedDate": "2020-08-10T18:47:28Z", "type": "commit"}, {"oid": "de9acea2bf8429df57a37192fd022a60a12bdd56", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/de9acea2bf8429df57a37192fd022a60a12bdd56", "message": "Refactor Outcome module to Kotlin\n\n   * Change outcome module classes from java to kotlin", "committedDate": "2020-08-10T18:47:28Z", "type": "forcePushed"}]}