{"pr_number": 2433, "pr_title": "\ud83d\udcd6  Improve cache documentation", "pr_createdAt": "2020-07-08T11:41:48Z", "pr_url": "https://github.com/apollographql/apollo-android/pull/2433", "timeline": [{"oid": "5072febc0e2de28e1132a5b177da054a5e715b8d", "url": "https://github.com/apollographql/apollo-android/commit/5072febc0e2de28e1132a5b177da054a5e715b8d", "message": "wip", "committedDate": "2020-07-08T09:24:50Z", "type": "commit"}, {"oid": "37b9d71b6daced133de9ff5ec695fe74fc3c44ca", "url": "https://github.com/apollographql/apollo-android/commit/37b9d71b6daced133de9ff5ec695fe74fc3c44ca", "message": "separate HTTP and normalized cache and give more examples", "committedDate": "2020-07-08T11:38:24Z", "type": "commit"}, {"oid": "4a070dac291fb288f0d0c93cfe9ebac645ffdff9", "url": "https://github.com/apollographql/apollo-android/commit/4a070dac291fb288f0d0c93cfe9ebac645ffdff9", "message": "add a redirect", "committedDate": "2020-07-08T11:40:11Z", "type": "commit"}, {"oid": "4b0ddfec9d0c4db3e6096347cd944718f0949ca0", "url": "https://github.com/apollographql/apollo-android/commit/4b0ddfec9d0c4db3e6096347cd944718f0949ca0", "message": "fix title", "committedDate": "2020-07-08T12:34:26Z", "type": "commit"}, {"oid": "395ada98e009e2f54d799dedd8058be8bb769755", "url": "https://github.com/apollographql/apollo-android/commit/395ada98e009e2f54d799dedd8058be8bb769755", "message": "wording", "committedDate": "2020-07-08T12:35:09Z", "type": "commit"}, {"oid": "dccf9c479b1abfdb0bc958f16790d9e74932c34a", "url": "https://github.com/apollographql/apollo-android/commit/dccf9c479b1abfdb0bc958f16790d9e74932c34a", "message": "minor fixes", "committedDate": "2020-07-08T12:40:59Z", "type": "commit"}, {"oid": "cb2c5c96e5e956ced20ad1b93a0d5883604718bf", "url": "https://github.com/apollographql/apollo-android/commit/cb2c5c96e5e956ced20ad1b93a0d5883604718bf", "message": "add some info about manual cache manipulation", "committedDate": "2020-07-08T14:38:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMzc1MQ==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r451803751", "bodyText": "english nit: Once the dependency is added", "author": "designatednerd", "createdAt": "2020-07-08T20:22:48Z", "path": "docs/source/essentials/normalized-cache.mdx", "diffHunk": "@@ -0,0 +1,325 @@\n+---\n+title: Normalized cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the normalized cache. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).\n+\n+## Data Normalization:\n+\n+The normalized cache stores objects by ID.\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This is because the author is stored only once in the cache.\n+\n+## Storing your data in memory\n+\n+Apollo Android comes with a `LruNormalizedCache` that will store your data in memory:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+// Create a 10MB NormalizedCacheFactory\n+val cacheFactory = LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build())\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build())\n+```\n+\n+```java:title=Java\n+// Create a 10MB NormalizedCacheFactory\n+NormalizedCacheFactory cacheFactory = new LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build());\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Persisting your data in a SQLite database\n+\n+If the amount of data you store becomes too big to fit in memory or if you want your data to persist between app restarts, you can also use a `SqlNormalizedCacheFactory`. A `SqlNormalizedCacheFactory` will store your data in a [SQLDelight](https://github.com/cashapp/sqldelight) database and is defined in a separate dependency:\n+\n+```kotlin:title=build.gradle.kts\n+dependencies {\n+  implementation(\"com.apollographql.apollo:apollo-normalized-cache-sqlite:x.y.z\")\n+}\n+```\n+\n+**Note:** The `apollo-normalized-cache-sqlite` dependency has Kotlin multiplatform support and has multiple variants (`-jvm`, `-android`, `-ios-arm64`,...). If you are targetting Android and using custom `buildTypes`, you will need to help Gradle resolve the correct artifact by defining [matchingFallbacks](https://developer.android.com/studio/build/dependencies?authuser=2#resolve_matching_errors):\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=build.gradle\n+android {\n+  buildTypes {\n+    create(\"custom\") {\n+      // your code...\n+      matchingFallbacks = listOf(\"debug\")\n+    }\n+  }\n+}\n+```\n+\n+```groovy:title=build.gradle\n+android {\n+  buildTypes {\n+    custom {\n+      // your code...\n+      matchingFallbacks = [\"debug\"]\n+    }\n+  }\n+}\n+```\n+\n+</MultiCodeBlock>\n+\n+Once the dependency added, you can create the `SqlNormalizedCacheFactory`:", "originalCommit": "cb2c5c96e5e956ced20ad1b93a0d5883604718bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA0NTA2MA==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452045060", "bodyText": "Done, I also took this opportunity to switch to imperative voice, that felt more positive:\nOnce the dependency is added, create the `SqlNormalizedCacheFactory`:", "author": "martinbonnin", "createdAt": "2020-07-09T08:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMzc1MQ=="}], "type": "inlineReview"}, {"oid": "781df8ec4921ce02c0cd4ea6a6ab1991d2584040", "url": "https://github.com/apollographql/apollo-android/commit/781df8ec4921ce02c0cd4ea6a6ab1991d2584040", "message": "style fixes", "committedDate": "2020-07-09T08:11:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM0MDkxOQ==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452340919", "bodyText": "What do you think to mention that the selection set of fields should be the same or less than in cache? Otherwise we won;t be able to resolve it.", "author": "sav007", "createdAt": "2020-07-09T16:25:58Z", "path": "docs/source/essentials/normalized-cache.mdx", "diffHunk": "@@ -0,0 +1,325 @@\n+---\n+title: Normalized cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the normalized cache. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).\n+\n+## Data Normalization:\n+\n+The normalized cache stores objects by ID.\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This is because the author is stored only once in the cache.", "originalCommit": "781df8ec4921ce02c0cd4ea6a6ab1991d2584040", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM0ODM3Nw==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452348377", "bodyText": "I added a small explanation and a link to https://www.apollographql.com/blog/the-concepts-of-graphql-bc68bd819be3. Since the process of normalization is the same for all platforms, I'd like to focus on the Android specific parts in this page.", "author": "martinbonnin", "createdAt": "2020-07-09T16:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM0MDkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM0MzE3Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452343176", "bodyText": "Do you think we should add section like trouble shooting, what user should check first / pay attention to in case of cache miss or other issues?\nAlso we can mentioned here how to dump the cache content:\nMap<KClass<?>, Map<String, Record>> dump = apolloClient.getApolloStore().normalizedCache().dump();\nNormalizedCache.prettifyDump(dump)", "author": "sav007", "createdAt": "2020-07-09T16:29:39Z", "path": "docs/source/essentials/normalized-cache.mdx", "diffHunk": "@@ -0,0 +1,325 @@\n+---\n+title: Normalized cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the normalized cache. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).\n+\n+## Data Normalization:\n+\n+The normalized cache stores objects by ID.\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This is because the author is stored only once in the cache.\n+\n+## Storing your data in memory\n+\n+Apollo Android comes with a `LruNormalizedCache` that will store your data in memory:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+// Create a 10MB NormalizedCacheFactory\n+val cacheFactory = LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build())\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build())\n+```\n+\n+```java:title=Java\n+// Create a 10MB NormalizedCacheFactory\n+NormalizedCacheFactory cacheFactory = new LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build());\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Persisting your data in a SQLite database\n+\n+If the amount of data you store becomes too big to fit in memory or if you want your data to persist between app restarts, you can also use a `SqlNormalizedCacheFactory`. A `SqlNormalizedCacheFactory` will store your data in a [SQLDelight](https://github.com/cashapp/sqldelight) database and is defined in a separate dependency:\n+\n+```kotlin:title=build.gradle.kts\n+dependencies {\n+  implementation(\"com.apollographql.apollo:apollo-normalized-cache-sqlite:x.y.z\")\n+}\n+```\n+\n+**Note:** The `apollo-normalized-cache-sqlite` dependency has Kotlin multiplatform support and has multiple variants (`-jvm`, `-android`, `-ios-arm64`,...). If you are targetting Android and using custom `buildTypes`, you will need to help Gradle resolve the correct artifact by defining [matchingFallbacks](https://developer.android.com/studio/build/dependencies?authuser=2#resolve_matching_errors):\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=build.gradle\n+android {\n+  buildTypes {\n+    create(\"custom\") {\n+      // your code...\n+      matchingFallbacks = listOf(\"debug\")\n+    }\n+  }\n+}\n+```\n+\n+```groovy:title=build.gradle\n+android {\n+  buildTypes {\n+    custom {\n+      // your code...\n+      matchingFallbacks = [\"debug\"]\n+    }\n+  }\n+}\n+```\n+\n+</MultiCodeBlock>\n+\n+Once the dependency is added, create the `SqlNormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin\n+// Android\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(context, \"apollo.db\")\n+// JVM\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(\"jdbc:sqlite:apollo.db\")\n+// iOS\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(\"apollo.db\")\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(sqlNormalizedCacheFactory)\n+  .build())\n+```\n+\n+```java\n+// Android\n+SqlNormalizedCacheFactory sqlNormalizedCacheFactory = new SqlNormalizedCacheFactory(context, \"apollo.db\")\n+// JVM\n+SqlNormalizedCacheFactory sqlNormalizedCacheFactory = new SqlNormalizedCacheFactory(\"jdbc:sqlite:apollo.db\")\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(sqlNormalizedCacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Chaining caches\n+\n+To get the best of both caches, you can chain a `LruNormalizedCacheFactory` with a `SqlNormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+\n+val sqlCacheFactory = SqlNormalizedCacheFactory(context, \"db_name\")\n+val memoryFirstThenSqlCacheFactory = LruNormalizedCacheFactory(\n+    EvictionPolicy.builder().maxSizeBytes(10 * 1024).build()\n+).chain(sqlCacheFactory)\n+\n+```\n+\n+```java:title=Java\n+\n+NormalizedCacheFactory sqlCacheFactory = new SqlNormalizedCacheFactory(context, \"db_name\");\n+NormalizedCacheFactory memoryFirstThenSqlCacheFactory = new LruNormalizedCacheFactory(\n+  EvictionPolicy.builder().maxSizeBytes(10 * 1024).build()\n+).chain(sqlCacheFactory);\n+\n+```\n+</MultiCodeBlock>\n+\n+Reads will read from the first cache hit in the chain. Writes will propagate down the entire chain.\n+\n+## Specifying your object IDs\n+\n+By default, Apollo Android uses the field path as key to store data. Back to the original example:\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+This will store the following records:\n+\n+* `\"favoriteBook\"`: `{\"id\": \"book1\", \"title\": \"Les guerriers du silence\", \"author\": \"ApolloCacheReference{favoriteBook.author}\"}`\n+* `\"favoriteBook.author\"`: `{\"id\": \"author1\", name\": \"Pierre Bordage\"}`\n+* `\"author(\"id\": \"author1\")\"`: `{\"id\": \"author1\", \"name\": \"Pierre Bordage\"}`\n+* `\"QUERY_ROOT\"`: `{\"favoriteBook\": \"ApolloCacheReference{favoriteBook}\", \"author(\\\"id\\\": \\\"author1\\\")\": \"ApolloCacheReference{author(\\\"id\\\": \\\"author1\\\")}\"}`\n+\n+As you can see, the author is stored twice. This is unfortunate because it takes more space but also because changing data in one place will not notify other watchers. What we want instead is this:\n+\n+* `\"book1\"`: `{\"id\": \"book1\", \"title\": \"Les guerriers du silence\", \"author\": \"ApolloCacheReference{author1}\"}`\n+* `\"author1\"`: `{\"id\": \"author1\", name\": \"Pierre Bordage\"}`\n+* `\"QUERY_ROOT\"`: `{\"favoriteBook\": \"book1\", \"author(\\\"id\\\": \\\"author1\\\")\": \"author1\"}`\n+\n+To do this, specify a `CacheKeyResolver` when configuring your `NormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+val resolver: CacheKeyResolver = object : CacheKeyResolver() {\n+  override fun fromFieldRecordSet(field: ResponseField, recordSet: Map<String, Any>): CacheKey {\n+    // Retrieve the id from the object itself\n+    return CacheKey.from(recordSet[\"id\"] as String)\n+  }\n+\n+  override fun fromFieldArguments(field: ResponseField, variables: Operation.Variables): CacheKey {\n+    // Retrieve the id from the field arguments.\n+    // In the example, this allows to know that `author(id: \"author1\")` will retrive `author1`\n+    // That sounds straightforward but without this, the cache would have no way of finding the id before executing the request on the\n+    // network which is what we want to avoid\n+    return CacheKey.from(field.resolveArgument(\"id\", variables) as String)\n+  }\n+}\n+\n+val apolloClient = ApolloClient.builder()\n+    .serverUrl(\"https://...\")\n+    .normalizedCache(cacheFactory, resolver)\n+    .build()\n+```\n+\n+```java:title=Java\n+CacheKeyResolver resolver = new CacheKeyResolver() {\n+   @NotNull @Override\n+   public CacheKey fromFieldRecordSet(@NotNull ResponseField field, @NotNull Map<String, Object> recordSet) {\n+     // Retrieve the id from the object itself\n+     return CacheKey.from(((String) recordSet.get(\"id\"));\n+   }\n+\n+   @NotNull @Override\n+   public CacheKey fromFieldArguments(@NotNull ResponseField field, @NotNull Operation.Variables variables) {\n+     // Retrieve the id from the field arguments.\n+     // In the example, this allows to know that `author(id: \"author1\")` will retrive `author1`\n+     // That sounds straightforward but without this, the cache would have no way of finding the id before executing the request on the\n+     // network which is what we want to avoid\n+     return CacheKey.from(((String) field.resolveArgument(\"id\", variables));\n+   }\n+};\n+\n+//Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory, resolver)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+For this resolver to work, every object in your graph needs to have a globally unique ID. If some of them don't have one, you can fallback to using the path as cache key by returning `CacheKey.NO_KEY`.\n+\n+## Using the cache with your queries\n+\n+You control how the cache is used with [`ResponseFetchers`](https://github.com/apollographql/apollo-android/blob/master/apollo-runtime/src/main/java/com/apollographql/apollo/fetcher/ApolloResponseFetchers.java):\n+\n+<MultiCodeBlock>\n+\n+```kotlin\n+// Get a response from the cache if possible. Else, get a response from the network\n+// This is the default behavior\n+val apolloCall = apolloClient().query(BookWithAuthorName()).responseFetcher(ApolloResponseFetchers.CACHE_FIRST)\n+```\n+\n+```java\n+// Get a response from the cache if possible. Else, get a response from the network\n+// This is the default behavior\n+ApolloCall apolloCall = apolloClient().query(new BookWithAuthorName()).responseFetcher(ApolloResponseFetchers.CACHE_FIRST)\n+```\n+\n+</MultiCodeBlock>\n+\n+Other possibilities are CACHE_ONLY, NETWORK_ONLY, CACHE_AND_NETWORK_ONLY, NETWORK_FIST. See to the [`ResponseFetchers` class](https://github.com/apollographql/apollo-android/blob/master/apollo-runtime/src/main/java/com/apollographql/apollo/fetcher/ApolloResponseFetchers.java) for more details.\n+\n+## Reacting to changes in the cache\n+\n+One big advantage of using a normalized cache is that your UI can now react to changes in your cache data. If you want to be notified every time something changes in `book1`, you can use a `QueryWatcher`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin\n+  apolloClient.query(BookWithAuthorName()).watcher().toFlow().collect { response ->\n+      // This will be called every time the book or author changes\n+  }\n+```\n+\n+```java\n+  apolloClient.query(new BookWithAuthorName()).watcher().enqueueAndWatch(new ApolloCall.Callback<T>() {\n+     @Override public void onResponse(@NotNull Response<T> response) {\n+       // This will be called every time the book or author changes\n+     }\n+\n+     @Override public void onFailure(@NotNull ApolloException e) {\n+       // This will be called if an error happens\n+     }\n+  });\n+```\n+\n+</MultiCodeBlock>\n+\n+## Interacting with the cache\n+\n+To manipulate the cache directly, `ApolloStore` exposes `read()` and `write()` methods:\n+\n+```kotlin\n+  // Reading data from the store\n+  val data = apolloClient.apolloStore.read(BookWithAuthorName()).execute()\n+\n+  // Create data to write\n+  val data = BookWithAuthorName.Data(\n+    id = \"book1\",\n+    title = \"Les guerriers du silence\",\n+    author = BookWithAuthorName.Author(\n+      id = \"author1\",\n+      name = \"Pierre Bordage\"\n+    )\n+  )\n+  // Write to the store. All watchers will be notified\n+  apolloClient.apolloStore.writeAndPublish(BookWithAuthorName(), data).execute()\n+```", "originalCommit": "781df8ec4921ce02c0cd4ea6a6ab1991d2584040", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NDk3MA==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452354970", "bodyText": "Do you think we should add section like trouble shooting\n\nThat's definitely something that could be useful (See #2397). Not sure what to recommend though, did you have something specific in mind?\n\nAlso we can mentioned here how to dump the cache content\n\n\ud83d\udc4d", "author": "martinbonnin", "createdAt": "2020-07-09T16:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM0MzE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1OTIxMg==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452359212", "bodyText": "I think we should start with dump cache. Second we should mention to double check how cache key generated (make sure that there is stable ids). Third mention again about selection set should be the same or less. At least to start with these 3 points.\nMaybe later we can expand more.", "author": "sav007", "createdAt": "2020-07-09T16:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM0MzE3Ng=="}], "type": "inlineReview"}, {"oid": "496594c25a3a71277df25d5825c07d463da7769b", "url": "https://github.com/apollographql/apollo-android/commit/496594c25a3a71277df25d5825c07d463da7769b", "message": "add some more info about the process of cache normalization", "committedDate": "2020-07-09T16:35:45Z", "type": "commit"}, {"oid": "1f9f7db452aca036c5860b425740b6a63f489348", "url": "https://github.com/apollographql/apollo-android/commit/1f9f7db452aca036c5860b425740b6a63f489348", "message": "added a note about dumping the cache", "committedDate": "2020-07-09T16:48:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NzY1OQ==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452357659", "bodyText": ".BookWithAuthorName should be deleted?", "author": "sav007", "createdAt": "2020-07-09T16:53:51Z", "path": "docs/source/essentials/normalized-cache.mdx", "diffHunk": "@@ -0,0 +1,343 @@\n+---\n+title: Normalized cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the normalized cache. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).\n+\n+## Data Normalization:\n+\n+The normalized cache stores objects by ID.\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This works because the author is stored only once in the cache and all the fields where retrieved in the initial BookWithAuthorName query. If you were to request more fields, like `birthdate` for an example, that wouldn't work anymore.BookWithAuthorName", "originalCommit": "1f9f7db452aca036c5860b425740b6a63f489348", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1OTkxNA==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452359914", "bodyText": "Urg, thanks", "author": "martinbonnin", "createdAt": "2020-07-09T16:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NzY1OQ=="}], "type": "inlineReview"}, {"oid": "cb9645d446bbc605bd3d726e6794a7d6317959d0", "url": "https://github.com/apollographql/apollo-android/commit/cb9645d446bbc605bd3d726e6794a7d6317959d0", "message": "fix bad copy/paste", "committedDate": "2020-07-09T16:58:05Z", "type": "commit"}, {"oid": "330d33980ca51374265f7790cf8196ad31bc9f99", "url": "https://github.com/apollographql/apollo-android/commit/330d33980ca51374265f7790cf8196ad31bc9f99", "message": "added some more troubleshooting", "committedDate": "2020-07-09T17:27:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwOTM1NA==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452409354", "bodyText": "Lowercase 'C'", "author": "StephenBarlow", "createdAt": "2020-07-09T18:26:35Z", "path": "docs/source/essentials/http-cache.mdx", "diffHunk": "@@ -0,0 +1,101 @@\n+---\n+title: HTTP Cache", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMDA1Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452410056", "bodyText": "has->provides\n2->two\n\"an HTTP cache and a normalized cache\"\nsetup->set up", "author": "StephenBarlow", "createdAt": "2020-07-09T18:27:50Z", "path": "docs/source/essentials/http-cache.mdx", "diffHunk": "@@ -0,0 +1,101 @@\n+---\n+title: HTTP Cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the HTTP cache. If you want to deduplicate the storage of your objects and/or notify your UI when your data changes, take a look at the [normalized cache](./normalized-cache) instead.", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMDE1NQ==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452410155", "bodyText": "\"HTTP cache\"", "author": "StephenBarlow", "createdAt": "2020-07-09T18:28:01Z", "path": "docs/source/essentials/http-cache.mdx", "diffHunk": "@@ -0,0 +1,101 @@\n+---\n+title: HTTP Cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the HTTP cache. If you want to deduplicate the storage of your objects and/or notify your UI when your data changes, take a look at the [normalized cache](./normalized-cache) instead.\n+\n+## Http Cache", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMDQ1Mw==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452410453", "bodyText": "Lowercase 'C'\nCode font on build.gradle", "author": "StephenBarlow", "createdAt": "2020-07-09T18:28:36Z", "path": "docs/source/essentials/http-cache.mdx", "diffHunk": "@@ -0,0 +1,101 @@\n+---\n+title: HTTP Cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the HTTP cache. If you want to deduplicate the storage of your objects and/or notify your UI when your data changes, take a look at the [normalized cache](./normalized-cache) instead.\n+\n+## Http Cache\n+\n+To enable HTTP Cache support, add the dependency to your project's build.gradle file. The latest version is", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMDc2NA==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452410764", "bodyText": "\"response cache\" (we use sentence case everywhere for article titles and headings)", "author": "StephenBarlow", "createdAt": "2020-07-09T18:29:09Z", "path": "docs/source/essentials/http-cache.mdx", "diffHunk": "@@ -0,0 +1,101 @@\n+---\n+title: HTTP Cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the HTTP cache. If you want to deduplicate the storage of your objects and/or notify your UI when your data changes, take a look at the [normalized cache](./normalized-cache) instead.\n+\n+## Http Cache\n+\n+To enable HTTP Cache support, add the dependency to your project's build.gradle file. The latest version is\n+[![Download](https://api.bintray.com/packages/apollographql/android/apollo/images/download.svg)](https://bintray.com/apollographql/android/apollo-http-cache/_latestVersion)\n+\n+```kotlin:title=build.gradle\n+dependencies {\n+  implementation(\"com.apollographql.apollo:apollo-http-cache:x.y.z\")\n+}\n+```\n+\n+### Raw HTTP Response Cache", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMTUwMg==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452411502", "bodyText": "Is one of these the default? Let's specify if so.", "author": "StephenBarlow", "createdAt": "2020-07-09T18:30:27Z", "path": "docs/source/essentials/http-cache.mdx", "diffHunk": "@@ -0,0 +1,101 @@\n+---\n+title: HTTP Cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the HTTP cache. If you want to deduplicate the storage of your objects and/or notify your UI when your data changes, take a look at the [normalized cache](./normalized-cache) instead.\n+\n+## Http Cache\n+\n+To enable HTTP Cache support, add the dependency to your project's build.gradle file. The latest version is\n+[![Download](https://api.bintray.com/packages/apollographql/android/apollo/images/download.svg)](https://bintray.com/apollographql/android/apollo-http-cache/_latestVersion)\n+\n+```kotlin:title=build.gradle\n+dependencies {\n+  implementation(\"com.apollographql.apollo:apollo-http-cache:x.y.z\")\n+}\n+```\n+\n+### Raw HTTP Response Cache\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+// Directory where cached responses will be stored\n+val file = File(cacheDir, \"apolloCache\")\n+\n+// Size in bytes of the cache\n+val size: Long = 1024 * 1024\n+\n+// Create the http response cache store\n+val cacheStore = DiskLruHttpCacheStore(file, size)\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+    .serverUrl(\"/\")\n+    .httpCache(ApolloHttpCache(cacheStore))\n+    .okHttpClient(okHttpClient)\n+    .build()\n+                   \n+// Control the cache policy  \n+val query = FeedQuery(limit = 10, type = FeedType.HOT)\n+val dataResponse = apolloClient.query(query)\n+    .httpCachePolicy(HttpCachePolicy.CACHE_FIRST)\n+    .toDeferred()\n+    .await()\n+```\n+\n+```java:title=Java\n+//Directory where cached responses will be stored\n+File file = new File(cacheDir, \"apolloCache\");\n+\n+//Size in bytes of the cache\n+long size = 1024*1024;\n+\n+//Create the http response cache store\n+DiskLruHttpCacheStore cacheStore = new DiskLruHttpCacheStore(file, size); \n+\n+//Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"/\")\n+  .httpCache(new ApolloHttpCache(cacheStore))\n+  .okHttpClient(okHttpClient)\n+  .build();\n+\n+apolloClient\n+  .query(\n+    FeedQuery.builder()\n+      .limit(10)\n+      .type(FeedType.HOT)\n+      .build()\n+  )\n+  .httpCachePolicy(HttpCachePolicy.CACHE_FIRST)\n+  .enqueue(new ApolloCall.Callback<FeedQuery.Data>() {\n+    @Override public void onResponse(@NotNull Response<FeedQuery.Data> dataResponse) {\n+      ...\n+    }\n+\n+    @Override public void onFailure(@NotNull Throwable t) {\n+      ...\n+    }\n+  }); \n+```\n+\n+</MultiCodeBlock>\n+\n+**IMPORTANT:** Caching is provided only for `query` operations. It isn't available for `mutation` operations.\n+\n+There are four available cache policies `HttpCachePolicy`:\n+\n+- `CACHE_ONLY` - Fetch a response from the cache only, ignoring the network. If the cached response doesn't exist or is expired, then", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMTc3Mw==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452411773", "bodyText": "See comment at the top of the other cache article", "author": "StephenBarlow", "createdAt": "2020-07-09T18:30:59Z", "path": "docs/source/essentials/normalized-cache.mdx", "diffHunk": "@@ -0,0 +1,350 @@\n+---\n+title: Normalized cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the normalized cache. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMjI4NA==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452412284", "bodyText": "a -> an", "author": "StephenBarlow", "createdAt": "2020-07-09T18:31:58Z", "path": "docs/source/essentials/normalized-cache.mdx", "diffHunk": "@@ -0,0 +1,350 @@\n+---\n+title: Normalized cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the normalized cache. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).\n+\n+## Data Normalization:\n+\n+The normalized cache stores objects by ID.\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This works because the author is stored only once in the cache and all the fields where retrieved in the initial BookWithAuthorName query. If you were to request more fields, like `birthdate` for an example, that wouldn't work anymore.\n+\n+To learn more about the process of normalization, check this [blog post](https://www.apollographql.com/blog/the-concepts-of-graphql-bc68bd819be3)\n+\n+## Storing your data in memory\n+\n+Apollo Android comes with a `LruNormalizedCache` that will store your data in memory:", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMjU4MA==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452412580", "bodyText": "a -> an before Lru", "author": "StephenBarlow", "createdAt": "2020-07-09T18:32:28Z", "path": "docs/source/essentials/normalized-cache.mdx", "diffHunk": "@@ -0,0 +1,350 @@\n+---\n+title: Normalized cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the normalized cache. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).\n+\n+## Data Normalization:\n+\n+The normalized cache stores objects by ID.\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This works because the author is stored only once in the cache and all the fields where retrieved in the initial BookWithAuthorName query. If you were to request more fields, like `birthdate` for an example, that wouldn't work anymore.\n+\n+To learn more about the process of normalization, check this [blog post](https://www.apollographql.com/blog/the-concepts-of-graphql-bc68bd819be3)\n+\n+## Storing your data in memory\n+\n+Apollo Android comes with a `LruNormalizedCache` that will store your data in memory:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+// Create a 10MB NormalizedCacheFactory\n+val cacheFactory = LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build())\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build())\n+```\n+\n+```java:title=Java\n+// Create a 10MB NormalizedCacheFactory\n+NormalizedCacheFactory cacheFactory = new LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build());\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Persisting your data in a SQLite database\n+\n+If the amount of data you store becomes too big to fit in memory or if you want your data to persist between app restarts, you can also use a `SqlNormalizedCacheFactory`. A `SqlNormalizedCacheFactory` will store your data in a [SQLDelight](https://github.com/cashapp/sqldelight) database and is defined in a separate dependency:\n+\n+```kotlin:title=build.gradle.kts\n+dependencies {\n+  implementation(\"com.apollographql.apollo:apollo-normalized-cache-sqlite:x.y.z\")\n+}\n+```\n+\n+**Note:** The `apollo-normalized-cache-sqlite` dependency has Kotlin multiplatform support and has multiple variants (`-jvm`, `-android`, `-ios-arm64`,...). If you are targetting Android and using custom `buildTypes`, you will need to help Gradle resolve the correct artifact by defining [matchingFallbacks](https://developer.android.com/studio/build/dependencies?authuser=2#resolve_matching_errors):\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=build.gradle\n+android {\n+  buildTypes {\n+    create(\"custom\") {\n+      // your code...\n+      matchingFallbacks = listOf(\"debug\")\n+    }\n+  }\n+}\n+```\n+\n+```groovy:title=build.gradle\n+android {\n+  buildTypes {\n+    custom {\n+      // your code...\n+      matchingFallbacks = [\"debug\"]\n+    }\n+  }\n+}\n+```\n+\n+</MultiCodeBlock>\n+\n+Once the dependency is added, create the `SqlNormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin\n+// Android\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(context, \"apollo.db\")\n+// JVM\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(\"jdbc:sqlite:apollo.db\")\n+// iOS\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(\"apollo.db\")\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(sqlNormalizedCacheFactory)\n+  .build())\n+```\n+\n+```java\n+// Android\n+SqlNormalizedCacheFactory sqlNormalizedCacheFactory = new SqlNormalizedCacheFactory(context, \"apollo.db\")\n+// JVM\n+SqlNormalizedCacheFactory sqlNormalizedCacheFactory = new SqlNormalizedCacheFactory(\"jdbc:sqlite:apollo.db\")\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(sqlNormalizedCacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Chaining caches\n+\n+To get the best of both caches, you can chain a `LruNormalizedCacheFactory` with a `SqlNormalizedCacheFactory`:", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY3OTIyNg==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452679226", "bodyText": "Today I learnt I should use an before l if el is pronounced literally (\"el\")", "author": "martinbonnin", "createdAt": "2020-07-10T07:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxMjU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxNDExMQ==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452414111", "bodyText": "\"This is undesirable, both because it takes more space, and because modifying one of those objects will not notify the watchers of the other.\"", "author": "StephenBarlow", "createdAt": "2020-07-09T18:35:31Z", "path": "docs/source/essentials/normalized-cache.mdx", "diffHunk": "@@ -0,0 +1,350 @@\n+---\n+title: Normalized cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the normalized cache. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).\n+\n+## Data Normalization:\n+\n+The normalized cache stores objects by ID.\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This works because the author is stored only once in the cache and all the fields where retrieved in the initial BookWithAuthorName query. If you were to request more fields, like `birthdate` for an example, that wouldn't work anymore.\n+\n+To learn more about the process of normalization, check this [blog post](https://www.apollographql.com/blog/the-concepts-of-graphql-bc68bd819be3)\n+\n+## Storing your data in memory\n+\n+Apollo Android comes with a `LruNormalizedCache` that will store your data in memory:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+// Create a 10MB NormalizedCacheFactory\n+val cacheFactory = LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build())\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build())\n+```\n+\n+```java:title=Java\n+// Create a 10MB NormalizedCacheFactory\n+NormalizedCacheFactory cacheFactory = new LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build());\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Persisting your data in a SQLite database\n+\n+If the amount of data you store becomes too big to fit in memory or if you want your data to persist between app restarts, you can also use a `SqlNormalizedCacheFactory`. A `SqlNormalizedCacheFactory` will store your data in a [SQLDelight](https://github.com/cashapp/sqldelight) database and is defined in a separate dependency:\n+\n+```kotlin:title=build.gradle.kts\n+dependencies {\n+  implementation(\"com.apollographql.apollo:apollo-normalized-cache-sqlite:x.y.z\")\n+}\n+```\n+\n+**Note:** The `apollo-normalized-cache-sqlite` dependency has Kotlin multiplatform support and has multiple variants (`-jvm`, `-android`, `-ios-arm64`,...). If you are targetting Android and using custom `buildTypes`, you will need to help Gradle resolve the correct artifact by defining [matchingFallbacks](https://developer.android.com/studio/build/dependencies?authuser=2#resolve_matching_errors):\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=build.gradle\n+android {\n+  buildTypes {\n+    create(\"custom\") {\n+      // your code...\n+      matchingFallbacks = listOf(\"debug\")\n+    }\n+  }\n+}\n+```\n+\n+```groovy:title=build.gradle\n+android {\n+  buildTypes {\n+    custom {\n+      // your code...\n+      matchingFallbacks = [\"debug\"]\n+    }\n+  }\n+}\n+```\n+\n+</MultiCodeBlock>\n+\n+Once the dependency is added, create the `SqlNormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin\n+// Android\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(context, \"apollo.db\")\n+// JVM\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(\"jdbc:sqlite:apollo.db\")\n+// iOS\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(\"apollo.db\")\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(sqlNormalizedCacheFactory)\n+  .build())\n+```\n+\n+```java\n+// Android\n+SqlNormalizedCacheFactory sqlNormalizedCacheFactory = new SqlNormalizedCacheFactory(context, \"apollo.db\")\n+// JVM\n+SqlNormalizedCacheFactory sqlNormalizedCacheFactory = new SqlNormalizedCacheFactory(\"jdbc:sqlite:apollo.db\")\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(sqlNormalizedCacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Chaining caches\n+\n+To get the best of both caches, you can chain a `LruNormalizedCacheFactory` with a `SqlNormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+\n+val sqlCacheFactory = SqlNormalizedCacheFactory(context, \"db_name\")\n+val memoryFirstThenSqlCacheFactory = LruNormalizedCacheFactory(\n+    EvictionPolicy.builder().maxSizeBytes(10 * 1024).build()\n+).chain(sqlCacheFactory)\n+\n+```\n+\n+```java:title=Java\n+\n+NormalizedCacheFactory sqlCacheFactory = new SqlNormalizedCacheFactory(context, \"db_name\");\n+NormalizedCacheFactory memoryFirstThenSqlCacheFactory = new LruNormalizedCacheFactory(\n+  EvictionPolicy.builder().maxSizeBytes(10 * 1024).build()\n+).chain(sqlCacheFactory);\n+\n+```\n+</MultiCodeBlock>\n+\n+Reads will read from the first cache hit in the chain. Writes will propagate down the entire chain.\n+\n+## Specifying your object IDs\n+\n+By default, Apollo Android uses the field path as key to store data. Back to the original example:\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+This will store the following records:\n+\n+* `\"favoriteBook\"`: `{\"id\": \"book1\", \"title\": \"Les guerriers du silence\", \"author\": \"ApolloCacheReference{favoriteBook.author}\"}`\n+* `\"favoriteBook.author\"`: `{\"id\": \"author1\", name\": \"Pierre Bordage\"}`\n+* `\"author(\"id\": \"author1\")\"`: `{\"id\": \"author1\", \"name\": \"Pierre Bordage\"}`\n+* `\"QUERY_ROOT\"`: `{\"favoriteBook\": \"ApolloCacheReference{favoriteBook}\", \"author(\\\"id\\\": \\\"author1\\\")\": \"ApolloCacheReference{author(\\\"id\\\": \\\"author1\\\")}\"}`\n+\n+As you can see, the author is stored twice. This is unfortunate because it takes more space but also because changing data in one place will not notify other watchers. What we want instead is this:", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxNDI5Nw==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452414297", "bodyText": "\"fallback\" -> \"fall back\"", "author": "StephenBarlow", "createdAt": "2020-07-09T18:35:52Z", "path": "docs/source/essentials/normalized-cache.mdx", "diffHunk": "@@ -0,0 +1,350 @@\n+---\n+title: Normalized cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the normalized cache. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).\n+\n+## Data Normalization:\n+\n+The normalized cache stores objects by ID.\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This works because the author is stored only once in the cache and all the fields where retrieved in the initial BookWithAuthorName query. If you were to request more fields, like `birthdate` for an example, that wouldn't work anymore.\n+\n+To learn more about the process of normalization, check this [blog post](https://www.apollographql.com/blog/the-concepts-of-graphql-bc68bd819be3)\n+\n+## Storing your data in memory\n+\n+Apollo Android comes with a `LruNormalizedCache` that will store your data in memory:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+// Create a 10MB NormalizedCacheFactory\n+val cacheFactory = LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build())\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build())\n+```\n+\n+```java:title=Java\n+// Create a 10MB NormalizedCacheFactory\n+NormalizedCacheFactory cacheFactory = new LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build());\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Persisting your data in a SQLite database\n+\n+If the amount of data you store becomes too big to fit in memory or if you want your data to persist between app restarts, you can also use a `SqlNormalizedCacheFactory`. A `SqlNormalizedCacheFactory` will store your data in a [SQLDelight](https://github.com/cashapp/sqldelight) database and is defined in a separate dependency:\n+\n+```kotlin:title=build.gradle.kts\n+dependencies {\n+  implementation(\"com.apollographql.apollo:apollo-normalized-cache-sqlite:x.y.z\")\n+}\n+```\n+\n+**Note:** The `apollo-normalized-cache-sqlite` dependency has Kotlin multiplatform support and has multiple variants (`-jvm`, `-android`, `-ios-arm64`,...). If you are targetting Android and using custom `buildTypes`, you will need to help Gradle resolve the correct artifact by defining [matchingFallbacks](https://developer.android.com/studio/build/dependencies?authuser=2#resolve_matching_errors):\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=build.gradle\n+android {\n+  buildTypes {\n+    create(\"custom\") {\n+      // your code...\n+      matchingFallbacks = listOf(\"debug\")\n+    }\n+  }\n+}\n+```\n+\n+```groovy:title=build.gradle\n+android {\n+  buildTypes {\n+    custom {\n+      // your code...\n+      matchingFallbacks = [\"debug\"]\n+    }\n+  }\n+}\n+```\n+\n+</MultiCodeBlock>\n+\n+Once the dependency is added, create the `SqlNormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin\n+// Android\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(context, \"apollo.db\")\n+// JVM\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(\"jdbc:sqlite:apollo.db\")\n+// iOS\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(\"apollo.db\")\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(sqlNormalizedCacheFactory)\n+  .build())\n+```\n+\n+```java\n+// Android\n+SqlNormalizedCacheFactory sqlNormalizedCacheFactory = new SqlNormalizedCacheFactory(context, \"apollo.db\")\n+// JVM\n+SqlNormalizedCacheFactory sqlNormalizedCacheFactory = new SqlNormalizedCacheFactory(\"jdbc:sqlite:apollo.db\")\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(sqlNormalizedCacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Chaining caches\n+\n+To get the best of both caches, you can chain a `LruNormalizedCacheFactory` with a `SqlNormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+\n+val sqlCacheFactory = SqlNormalizedCacheFactory(context, \"db_name\")\n+val memoryFirstThenSqlCacheFactory = LruNormalizedCacheFactory(\n+    EvictionPolicy.builder().maxSizeBytes(10 * 1024).build()\n+).chain(sqlCacheFactory)\n+\n+```\n+\n+```java:title=Java\n+\n+NormalizedCacheFactory sqlCacheFactory = new SqlNormalizedCacheFactory(context, \"db_name\");\n+NormalizedCacheFactory memoryFirstThenSqlCacheFactory = new LruNormalizedCacheFactory(\n+  EvictionPolicy.builder().maxSizeBytes(10 * 1024).build()\n+).chain(sqlCacheFactory);\n+\n+```\n+</MultiCodeBlock>\n+\n+Reads will read from the first cache hit in the chain. Writes will propagate down the entire chain.\n+\n+## Specifying your object IDs\n+\n+By default, Apollo Android uses the field path as key to store data. Back to the original example:\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+This will store the following records:\n+\n+* `\"favoriteBook\"`: `{\"id\": \"book1\", \"title\": \"Les guerriers du silence\", \"author\": \"ApolloCacheReference{favoriteBook.author}\"}`\n+* `\"favoriteBook.author\"`: `{\"id\": \"author1\", name\": \"Pierre Bordage\"}`\n+* `\"author(\"id\": \"author1\")\"`: `{\"id\": \"author1\", \"name\": \"Pierre Bordage\"}`\n+* `\"QUERY_ROOT\"`: `{\"favoriteBook\": \"ApolloCacheReference{favoriteBook}\", \"author(\\\"id\\\": \\\"author1\\\")\": \"ApolloCacheReference{author(\\\"id\\\": \\\"author1\\\")}\"}`\n+\n+As you can see, the author is stored twice. This is unfortunate because it takes more space but also because changing data in one place will not notify other watchers. What we want instead is this:\n+\n+* `\"book1\"`: `{\"id\": \"book1\", \"title\": \"Les guerriers du silence\", \"author\": \"ApolloCacheReference{author1}\"}`\n+* `\"author1\"`: `{\"id\": \"author1\", name\": \"Pierre Bordage\"}`\n+* `\"QUERY_ROOT\"`: `{\"favoriteBook\": \"book1\", \"author(\\\"id\\\": \\\"author1\\\")\": \"author1\"}`\n+\n+To do this, specify a `CacheKeyResolver` when configuring your `NormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+val resolver: CacheKeyResolver = object : CacheKeyResolver() {\n+  override fun fromFieldRecordSet(field: ResponseField, recordSet: Map<String, Any>): CacheKey {\n+    // Retrieve the id from the object itself\n+    return CacheKey.from(recordSet[\"id\"] as String)\n+  }\n+\n+  override fun fromFieldArguments(field: ResponseField, variables: Operation.Variables): CacheKey {\n+    // Retrieve the id from the field arguments.\n+    // In the example, this allows to know that `author(id: \"author1\")` will retrive `author1`\n+    // That sounds straightforward but without this, the cache would have no way of finding the id before executing the request on the\n+    // network which is what we want to avoid\n+    return CacheKey.from(field.resolveArgument(\"id\", variables) as String)\n+  }\n+}\n+\n+val apolloClient = ApolloClient.builder()\n+    .serverUrl(\"https://...\")\n+    .normalizedCache(cacheFactory, resolver)\n+    .build()\n+```\n+\n+```java:title=Java\n+CacheKeyResolver resolver = new CacheKeyResolver() {\n+   @NotNull @Override\n+   public CacheKey fromFieldRecordSet(@NotNull ResponseField field, @NotNull Map<String, Object> recordSet) {\n+     // Retrieve the id from the object itself\n+     return CacheKey.from(((String) recordSet.get(\"id\"));\n+   }\n+\n+   @NotNull @Override\n+   public CacheKey fromFieldArguments(@NotNull ResponseField field, @NotNull Operation.Variables variables) {\n+     // Retrieve the id from the field arguments.\n+     // In the example, this allows to know that `author(id: \"author1\")` will retrive `author1`\n+     // That sounds straightforward but without this, the cache would have no way of finding the id before executing the request on the\n+     // network which is what we want to avoid\n+     return CacheKey.from(((String) field.resolveArgument(\"id\", variables));\n+   }\n+};\n+\n+//Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory, resolver)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+For this resolver to work, every object in your graph needs to have a globally unique ID. If some of them don't have one, you can fallback to using the path as cache key by returning `CacheKey.NO_KEY`.", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxNTcxNw==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452415717", "bodyText": "code voice for each constant\nadd 'and' between the last two constant values", "author": "StephenBarlow", "createdAt": "2020-07-09T18:38:35Z", "path": "docs/source/essentials/normalized-cache.mdx", "diffHunk": "@@ -0,0 +1,350 @@\n+---\n+title: Normalized cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the normalized cache. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).\n+\n+## Data Normalization:\n+\n+The normalized cache stores objects by ID.\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This works because the author is stored only once in the cache and all the fields where retrieved in the initial BookWithAuthorName query. If you were to request more fields, like `birthdate` for an example, that wouldn't work anymore.\n+\n+To learn more about the process of normalization, check this [blog post](https://www.apollographql.com/blog/the-concepts-of-graphql-bc68bd819be3)\n+\n+## Storing your data in memory\n+\n+Apollo Android comes with a `LruNormalizedCache` that will store your data in memory:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+// Create a 10MB NormalizedCacheFactory\n+val cacheFactory = LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build())\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build())\n+```\n+\n+```java:title=Java\n+// Create a 10MB NormalizedCacheFactory\n+NormalizedCacheFactory cacheFactory = new LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build());\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Persisting your data in a SQLite database\n+\n+If the amount of data you store becomes too big to fit in memory or if you want your data to persist between app restarts, you can also use a `SqlNormalizedCacheFactory`. A `SqlNormalizedCacheFactory` will store your data in a [SQLDelight](https://github.com/cashapp/sqldelight) database and is defined in a separate dependency:\n+\n+```kotlin:title=build.gradle.kts\n+dependencies {\n+  implementation(\"com.apollographql.apollo:apollo-normalized-cache-sqlite:x.y.z\")\n+}\n+```\n+\n+**Note:** The `apollo-normalized-cache-sqlite` dependency has Kotlin multiplatform support and has multiple variants (`-jvm`, `-android`, `-ios-arm64`,...). If you are targetting Android and using custom `buildTypes`, you will need to help Gradle resolve the correct artifact by defining [matchingFallbacks](https://developer.android.com/studio/build/dependencies?authuser=2#resolve_matching_errors):\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=build.gradle\n+android {\n+  buildTypes {\n+    create(\"custom\") {\n+      // your code...\n+      matchingFallbacks = listOf(\"debug\")\n+    }\n+  }\n+}\n+```\n+\n+```groovy:title=build.gradle\n+android {\n+  buildTypes {\n+    custom {\n+      // your code...\n+      matchingFallbacks = [\"debug\"]\n+    }\n+  }\n+}\n+```\n+\n+</MultiCodeBlock>\n+\n+Once the dependency is added, create the `SqlNormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin\n+// Android\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(context, \"apollo.db\")\n+// JVM\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(\"jdbc:sqlite:apollo.db\")\n+// iOS\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(\"apollo.db\")\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(sqlNormalizedCacheFactory)\n+  .build())\n+```\n+\n+```java\n+// Android\n+SqlNormalizedCacheFactory sqlNormalizedCacheFactory = new SqlNormalizedCacheFactory(context, \"apollo.db\")\n+// JVM\n+SqlNormalizedCacheFactory sqlNormalizedCacheFactory = new SqlNormalizedCacheFactory(\"jdbc:sqlite:apollo.db\")\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(sqlNormalizedCacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Chaining caches\n+\n+To get the best of both caches, you can chain a `LruNormalizedCacheFactory` with a `SqlNormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+\n+val sqlCacheFactory = SqlNormalizedCacheFactory(context, \"db_name\")\n+val memoryFirstThenSqlCacheFactory = LruNormalizedCacheFactory(\n+    EvictionPolicy.builder().maxSizeBytes(10 * 1024).build()\n+).chain(sqlCacheFactory)\n+\n+```\n+\n+```java:title=Java\n+\n+NormalizedCacheFactory sqlCacheFactory = new SqlNormalizedCacheFactory(context, \"db_name\");\n+NormalizedCacheFactory memoryFirstThenSqlCacheFactory = new LruNormalizedCacheFactory(\n+  EvictionPolicy.builder().maxSizeBytes(10 * 1024).build()\n+).chain(sqlCacheFactory);\n+\n+```\n+</MultiCodeBlock>\n+\n+Reads will read from the first cache hit in the chain. Writes will propagate down the entire chain.\n+\n+## Specifying your object IDs\n+\n+By default, Apollo Android uses the field path as key to store data. Back to the original example:\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+This will store the following records:\n+\n+* `\"favoriteBook\"`: `{\"id\": \"book1\", \"title\": \"Les guerriers du silence\", \"author\": \"ApolloCacheReference{favoriteBook.author}\"}`\n+* `\"favoriteBook.author\"`: `{\"id\": \"author1\", name\": \"Pierre Bordage\"}`\n+* `\"author(\"id\": \"author1\")\"`: `{\"id\": \"author1\", \"name\": \"Pierre Bordage\"}`\n+* `\"QUERY_ROOT\"`: `{\"favoriteBook\": \"ApolloCacheReference{favoriteBook}\", \"author(\\\"id\\\": \\\"author1\\\")\": \"ApolloCacheReference{author(\\\"id\\\": \\\"author1\\\")}\"}`\n+\n+As you can see, the author is stored twice. This is unfortunate because it takes more space but also because changing data in one place will not notify other watchers. What we want instead is this:\n+\n+* `\"book1\"`: `{\"id\": \"book1\", \"title\": \"Les guerriers du silence\", \"author\": \"ApolloCacheReference{author1}\"}`\n+* `\"author1\"`: `{\"id\": \"author1\", name\": \"Pierre Bordage\"}`\n+* `\"QUERY_ROOT\"`: `{\"favoriteBook\": \"book1\", \"author(\\\"id\\\": \\\"author1\\\")\": \"author1\"}`\n+\n+To do this, specify a `CacheKeyResolver` when configuring your `NormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+val resolver: CacheKeyResolver = object : CacheKeyResolver() {\n+  override fun fromFieldRecordSet(field: ResponseField, recordSet: Map<String, Any>): CacheKey {\n+    // Retrieve the id from the object itself\n+    return CacheKey.from(recordSet[\"id\"] as String)\n+  }\n+\n+  override fun fromFieldArguments(field: ResponseField, variables: Operation.Variables): CacheKey {\n+    // Retrieve the id from the field arguments.\n+    // In the example, this allows to know that `author(id: \"author1\")` will retrive `author1`\n+    // That sounds straightforward but without this, the cache would have no way of finding the id before executing the request on the\n+    // network which is what we want to avoid\n+    return CacheKey.from(field.resolveArgument(\"id\", variables) as String)\n+  }\n+}\n+\n+val apolloClient = ApolloClient.builder()\n+    .serverUrl(\"https://...\")\n+    .normalizedCache(cacheFactory, resolver)\n+    .build()\n+```\n+\n+```java:title=Java\n+CacheKeyResolver resolver = new CacheKeyResolver() {\n+   @NotNull @Override\n+   public CacheKey fromFieldRecordSet(@NotNull ResponseField field, @NotNull Map<String, Object> recordSet) {\n+     // Retrieve the id from the object itself\n+     return CacheKey.from(((String) recordSet.get(\"id\"));\n+   }\n+\n+   @NotNull @Override\n+   public CacheKey fromFieldArguments(@NotNull ResponseField field, @NotNull Operation.Variables variables) {\n+     // Retrieve the id from the field arguments.\n+     // In the example, this allows to know that `author(id: \"author1\")` will retrive `author1`\n+     // That sounds straightforward but without this, the cache would have no way of finding the id before executing the request on the\n+     // network which is what we want to avoid\n+     return CacheKey.from(((String) field.resolveArgument(\"id\", variables));\n+   }\n+};\n+\n+//Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory, resolver)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+For this resolver to work, every object in your graph needs to have a globally unique ID. If some of them don't have one, you can fallback to using the path as cache key by returning `CacheKey.NO_KEY`.\n+\n+## Using the cache with your queries\n+\n+You control how the cache is used with [`ResponseFetchers`](https://github.com/apollographql/apollo-android/blob/master/apollo-runtime/src/main/java/com/apollographql/apollo/fetcher/ApolloResponseFetchers.java):\n+\n+<MultiCodeBlock>\n+\n+```kotlin\n+// Get a response from the cache if possible. Else, get a response from the network\n+// This is the default behavior\n+val apolloCall = apolloClient().query(BookWithAuthorName()).responseFetcher(ApolloResponseFetchers.CACHE_FIRST)\n+```\n+\n+```java\n+// Get a response from the cache if possible. Else, get a response from the network\n+// This is the default behavior\n+ApolloCall apolloCall = apolloClient().query(new BookWithAuthorName()).responseFetcher(ApolloResponseFetchers.CACHE_FIRST)\n+```\n+\n+</MultiCodeBlock>\n+\n+Other possibilities are CACHE_ONLY, NETWORK_ONLY, CACHE_AND_NETWORK_ONLY, NETWORK_FIST. See to the [`ResponseFetchers` class](https://github.com/apollographql/apollo-android/blob/master/apollo-runtime/src/main/java/com/apollographql/apollo/fetcher/ApolloResponseFetchers.java) for more details.", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxNjE2Mw==", "url": "https://github.com/apollographql/apollo-android/pull/2433#discussion_r452416163", "bodyText": "Code voice for CacheKey and CacheKeyResolver", "author": "StephenBarlow", "createdAt": "2020-07-09T18:39:29Z", "path": "docs/source/essentials/normalized-cache.mdx", "diffHunk": "@@ -0,0 +1,350 @@\n+---\n+title: Normalized cache\n+---\n+\n+import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';\n+\n+Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the normalized cache. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).\n+\n+## Data Normalization:\n+\n+The normalized cache stores objects by ID.\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This works because the author is stored only once in the cache and all the fields where retrieved in the initial BookWithAuthorName query. If you were to request more fields, like `birthdate` for an example, that wouldn't work anymore.\n+\n+To learn more about the process of normalization, check this [blog post](https://www.apollographql.com/blog/the-concepts-of-graphql-bc68bd819be3)\n+\n+## Storing your data in memory\n+\n+Apollo Android comes with a `LruNormalizedCache` that will store your data in memory:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+// Create a 10MB NormalizedCacheFactory\n+val cacheFactory = LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build())\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build())\n+```\n+\n+```java:title=Java\n+// Create a 10MB NormalizedCacheFactory\n+NormalizedCacheFactory cacheFactory = new LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build());\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Persisting your data in a SQLite database\n+\n+If the amount of data you store becomes too big to fit in memory or if you want your data to persist between app restarts, you can also use a `SqlNormalizedCacheFactory`. A `SqlNormalizedCacheFactory` will store your data in a [SQLDelight](https://github.com/cashapp/sqldelight) database and is defined in a separate dependency:\n+\n+```kotlin:title=build.gradle.kts\n+dependencies {\n+  implementation(\"com.apollographql.apollo:apollo-normalized-cache-sqlite:x.y.z\")\n+}\n+```\n+\n+**Note:** The `apollo-normalized-cache-sqlite` dependency has Kotlin multiplatform support and has multiple variants (`-jvm`, `-android`, `-ios-arm64`,...). If you are targetting Android and using custom `buildTypes`, you will need to help Gradle resolve the correct artifact by defining [matchingFallbacks](https://developer.android.com/studio/build/dependencies?authuser=2#resolve_matching_errors):\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=build.gradle\n+android {\n+  buildTypes {\n+    create(\"custom\") {\n+      // your code...\n+      matchingFallbacks = listOf(\"debug\")\n+    }\n+  }\n+}\n+```\n+\n+```groovy:title=build.gradle\n+android {\n+  buildTypes {\n+    custom {\n+      // your code...\n+      matchingFallbacks = [\"debug\"]\n+    }\n+  }\n+}\n+```\n+\n+</MultiCodeBlock>\n+\n+Once the dependency is added, create the `SqlNormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin\n+// Android\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(context, \"apollo.db\")\n+// JVM\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(\"jdbc:sqlite:apollo.db\")\n+// iOS\n+val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(\"apollo.db\")\n+\n+// Build the ApolloClient\n+val apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(sqlNormalizedCacheFactory)\n+  .build())\n+```\n+\n+```java\n+// Android\n+SqlNormalizedCacheFactory sqlNormalizedCacheFactory = new SqlNormalizedCacheFactory(context, \"apollo.db\")\n+// JVM\n+SqlNormalizedCacheFactory sqlNormalizedCacheFactory = new SqlNormalizedCacheFactory(\"jdbc:sqlite:apollo.db\")\n+\n+// Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(sqlNormalizedCacheFactory)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+## Chaining caches\n+\n+To get the best of both caches, you can chain a `LruNormalizedCacheFactory` with a `SqlNormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+\n+val sqlCacheFactory = SqlNormalizedCacheFactory(context, \"db_name\")\n+val memoryFirstThenSqlCacheFactory = LruNormalizedCacheFactory(\n+    EvictionPolicy.builder().maxSizeBytes(10 * 1024).build()\n+).chain(sqlCacheFactory)\n+\n+```\n+\n+```java:title=Java\n+\n+NormalizedCacheFactory sqlCacheFactory = new SqlNormalizedCacheFactory(context, \"db_name\");\n+NormalizedCacheFactory memoryFirstThenSqlCacheFactory = new LruNormalizedCacheFactory(\n+  EvictionPolicy.builder().maxSizeBytes(10 * 1024).build()\n+).chain(sqlCacheFactory);\n+\n+```\n+</MultiCodeBlock>\n+\n+Reads will read from the first cache hit in the chain. Writes will propagate down the entire chain.\n+\n+## Specifying your object IDs\n+\n+By default, Apollo Android uses the field path as key to store data. Back to the original example:\n+\n+```graphl\n+query BookWithAuthorName {\n+  favoriteBook {\n+    id\n+    title\n+    author {\n+      id\n+      name\n+    }\n+  }\n+}\n+\n+query AuthorById($id: String!) {\n+  author(id: $id) {\n+      id\n+      name\n+    }\n+  }\n+}\n+```\n+\n+This will store the following records:\n+\n+* `\"favoriteBook\"`: `{\"id\": \"book1\", \"title\": \"Les guerriers du silence\", \"author\": \"ApolloCacheReference{favoriteBook.author}\"}`\n+* `\"favoriteBook.author\"`: `{\"id\": \"author1\", name\": \"Pierre Bordage\"}`\n+* `\"author(\"id\": \"author1\")\"`: `{\"id\": \"author1\", \"name\": \"Pierre Bordage\"}`\n+* `\"QUERY_ROOT\"`: `{\"favoriteBook\": \"ApolloCacheReference{favoriteBook}\", \"author(\\\"id\\\": \\\"author1\\\")\": \"ApolloCacheReference{author(\\\"id\\\": \\\"author1\\\")}\"}`\n+\n+As you can see, the author is stored twice. This is unfortunate because it takes more space but also because changing data in one place will not notify other watchers. What we want instead is this:\n+\n+* `\"book1\"`: `{\"id\": \"book1\", \"title\": \"Les guerriers du silence\", \"author\": \"ApolloCacheReference{author1}\"}`\n+* `\"author1\"`: `{\"id\": \"author1\", name\": \"Pierre Bordage\"}`\n+* `\"QUERY_ROOT\"`: `{\"favoriteBook\": \"book1\", \"author(\\\"id\\\": \\\"author1\\\")\": \"author1\"}`\n+\n+To do this, specify a `CacheKeyResolver` when configuring your `NormalizedCacheFactory`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin:title=Kotlin\n+val resolver: CacheKeyResolver = object : CacheKeyResolver() {\n+  override fun fromFieldRecordSet(field: ResponseField, recordSet: Map<String, Any>): CacheKey {\n+    // Retrieve the id from the object itself\n+    return CacheKey.from(recordSet[\"id\"] as String)\n+  }\n+\n+  override fun fromFieldArguments(field: ResponseField, variables: Operation.Variables): CacheKey {\n+    // Retrieve the id from the field arguments.\n+    // In the example, this allows to know that `author(id: \"author1\")` will retrive `author1`\n+    // That sounds straightforward but without this, the cache would have no way of finding the id before executing the request on the\n+    // network which is what we want to avoid\n+    return CacheKey.from(field.resolveArgument(\"id\", variables) as String)\n+  }\n+}\n+\n+val apolloClient = ApolloClient.builder()\n+    .serverUrl(\"https://...\")\n+    .normalizedCache(cacheFactory, resolver)\n+    .build()\n+```\n+\n+```java:title=Java\n+CacheKeyResolver resolver = new CacheKeyResolver() {\n+   @NotNull @Override\n+   public CacheKey fromFieldRecordSet(@NotNull ResponseField field, @NotNull Map<String, Object> recordSet) {\n+     // Retrieve the id from the object itself\n+     return CacheKey.from(((String) recordSet.get(\"id\"));\n+   }\n+\n+   @NotNull @Override\n+   public CacheKey fromFieldArguments(@NotNull ResponseField field, @NotNull Operation.Variables variables) {\n+     // Retrieve the id from the field arguments.\n+     // In the example, this allows to know that `author(id: \"author1\")` will retrive `author1`\n+     // That sounds straightforward but without this, the cache would have no way of finding the id before executing the request on the\n+     // network which is what we want to avoid\n+     return CacheKey.from(((String) field.resolveArgument(\"id\", variables));\n+   }\n+};\n+\n+//Build the ApolloClient\n+ApolloClient apolloClient = ApolloClient.builder()\n+  .serverUrl(\"https://...\")\n+  .normalizedCache(cacheFactory, resolver)\n+  .build();\n+```\n+\n+</MultiCodeBlock>\n+\n+For this resolver to work, every object in your graph needs to have a globally unique ID. If some of them don't have one, you can fallback to using the path as cache key by returning `CacheKey.NO_KEY`.\n+\n+## Using the cache with your queries\n+\n+You control how the cache is used with [`ResponseFetchers`](https://github.com/apollographql/apollo-android/blob/master/apollo-runtime/src/main/java/com/apollographql/apollo/fetcher/ApolloResponseFetchers.java):\n+\n+<MultiCodeBlock>\n+\n+```kotlin\n+// Get a response from the cache if possible. Else, get a response from the network\n+// This is the default behavior\n+val apolloCall = apolloClient().query(BookWithAuthorName()).responseFetcher(ApolloResponseFetchers.CACHE_FIRST)\n+```\n+\n+```java\n+// Get a response from the cache if possible. Else, get a response from the network\n+// This is the default behavior\n+ApolloCall apolloCall = apolloClient().query(new BookWithAuthorName()).responseFetcher(ApolloResponseFetchers.CACHE_FIRST)\n+```\n+\n+</MultiCodeBlock>\n+\n+Other possibilities are CACHE_ONLY, NETWORK_ONLY, CACHE_AND_NETWORK_ONLY, NETWORK_FIST. See to the [`ResponseFetchers` class](https://github.com/apollographql/apollo-android/blob/master/apollo-runtime/src/main/java/com/apollographql/apollo/fetcher/ApolloResponseFetchers.java) for more details.\n+\n+## Reacting to changes in the cache\n+\n+One big advantage of using a normalized cache is that your UI can now react to changes in your cache data. If you want to be notified every time something changes in `book1`, you can use a `QueryWatcher`:\n+\n+<MultiCodeBlock>\n+\n+```kotlin\n+  apolloClient.query(BookWithAuthorName()).watcher().toFlow().collect { response ->\n+      // This will be called every time the book or author changes\n+  }\n+```\n+\n+```java\n+  apolloClient.query(new BookWithAuthorName()).watcher().enqueueAndWatch(new ApolloCall.Callback<T>() {\n+     @Override public void onResponse(@NotNull Response<T> response) {\n+       // This will be called every time the book or author changes\n+     }\n+\n+     @Override public void onFailure(@NotNull ApolloException e) {\n+       // This will be called if an error happens\n+     }\n+  });\n+```\n+\n+</MultiCodeBlock>\n+\n+## Interacting with the cache\n+\n+To manipulate the cache directly, `ApolloStore` exposes `read()` and `write()` methods:\n+\n+```kotlin\n+  // Reading data from the store\n+  val data = apolloClient.apolloStore.read(BookWithAuthorName()).execute()\n+\n+  // Create data to write\n+  val data = BookWithAuthorName.Data(\n+    id = \"book1\",\n+    title = \"Les guerriers du silence\",\n+    author = BookWithAuthorName.Author(\n+      id = \"author1\",\n+      name = \"Pierre Bordage\"\n+    )\n+  )\n+  // Write to the store. All watchers will be notified\n+  apolloClient.apolloStore.writeAndPublish(BookWithAuthorName(), data).execute()\n+```\n+\n+## Troubleshooting\n+\n+If the cache does not behave like you would expect and you are experiencing cache misses, you can dump the contents of the cache:\n+\n+<MultiCodeBlock>\n+\n+```kotlin\n+val dump = apolloClient.getApolloStore().normalizedCache().dump();\n+NormalizedCache.prettifyDump(dump)\n+```\n+\n+```java\n+Map<KClass<?>, Map<String, Record>> dump = apolloClient.getApolloStore().normalizedCache().dump();\n+NormalizedCache.prettifyDump(dump)\n+```\n+\n+</MultiCodeBlock>\n+\n+Make sure that no data is duplicated in the dump. If it is the case, it probably means that some objects have a wrong CacheKey. Make sure to provide a CacheKeyResolver that can work with your graph. All objects should have a unique and stable ID. That means that the ID should be the same no matter what path the object is in the graph. That also mean you have to include the identifier field in your queries to be able to use in from the `CacheKeyResolver`.", "originalCommit": "330d33980ca51374265f7790cf8196ad31bc9f99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "607a5ee6e4e45555c180b3ff15e5bd5d26853d40", "url": "https://github.com/apollographql/apollo-android/commit/607a5ee6e4e45555c180b3ff15e5bd5d26853d40", "message": "feedback", "committedDate": "2020-07-10T07:47:24Z", "type": "commit"}]}