{"pr_number": 2514, "pr_title": "Multi-module support", "pr_createdAt": "2020-08-10T10:05:32Z", "pr_url": "https://github.com/apollographql/apollo-android/pull/2514", "timeline": [{"oid": "6d31664e33567d710f1c5fcb60e15cee509cdfe9", "url": "https://github.com/apollographql/apollo-android/commit/6d31664e33567d710f1c5fcb60e15cee509cdfe9", "message": "unbreak tests", "committedDate": "2020-08-10T16:00:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNDAxOA==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r468224018", "bodyText": "Nit: unneeded space", "author": "Jawnnypoo", "createdAt": "2020-08-10T22:37:36Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ir/Fragment.kt", "diffHunk": "@@ -20,9 +22,9 @@ data class Fragment(\n     val fields: List<Field>,\n     val fragmentRefs: List<FragmentRef>,\n     val inlineFragments: List<InlineFragment>,\n-    val filePath: String,\n+    val filePath: String?, // might be null if coming from another module\n     val sourceLocation: SourceLocation\n-) : CodeGenerator {\n+  ) : CodeGenerator {", "originalCommit": "b3b3ec89b02989a46e39689fae45b450a0324f24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1aa4e9d9a4205166c9ffa240fd5b020b80142e39", "url": "https://github.com/apollographql/apollo-android/commit/1aa4e9d9a4205166c9ffa240fd5b020b80142e39", "message": "First drop for multi-module support", "committedDate": "2020-08-12T14:21:17Z", "type": "forcePushed"}, {"oid": "3a0e42467c20f6b705a39a6c7f0f22235eb52738", "url": "https://github.com/apollographql/apollo-android/commit/3a0e42467c20f6b705a39a6c7f0f22235eb52738", "message": "add more tests", "committedDate": "2020-08-27T14:49:53Z", "type": "forcePushed"}, {"oid": "41d46b62a65e5b987611ffd657a313dfbe161d37", "url": "https://github.com/apollographql/apollo-android/commit/41d46b62a65e5b987611ffd657a313dfbe161d37", "message": "First drop for multi-module support", "committedDate": "2020-08-27T14:51:14Z", "type": "commit"}, {"oid": "f1c2f030af44c46a7c444a0b24aa6fa83246a1e7", "url": "https://github.com/apollographql/apollo-android/commit/f1c2f030af44c46a7c444a0b24aa6fa83246a1e7", "message": "update metalava", "committedDate": "2020-08-27T14:51:16Z", "type": "commit"}, {"oid": "03954e6929c79f8a3cd3f9dec09642eaee182d72", "url": "https://github.com/apollographql/apollo-android/commit/03954e6929c79f8a3cd3f9dec09642eaee182d72", "message": "add alwaysGenerateTypesMatching and a few unit tests", "committedDate": "2020-08-27T14:58:21Z", "type": "commit"}, {"oid": "8a2f7aa8b848a475ea595802755e4d814dd0a220", "url": "https://github.com/apollographql/apollo-android/commit/8a2f7aa8b848a475ea595802755e4d814dd0a220", "message": "added some tests", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "7605cb7f205b65423c4809bebbc813260c887e9c", "url": "https://github.com/apollographql/apollo-android/commit/7605cb7f205b65423c4809bebbc813260c887e9c", "message": "minor tweaks", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "2a11615d0bfb96fe54d1d65e48dc5ce9ef2735cd", "url": "https://github.com/apollographql/apollo-android/commit/2a11615d0bfb96fe54d1d65e48dc5ce9ef2735cd", "message": "update metalava", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "146ee4f272db9246fb8efc04198a278711dfc0dc", "url": "https://github.com/apollographql/apollo-android/commit/146ee4f272db9246fb8efc04198a278711dfc0dc", "message": "stay on Gradle 6.0", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "672948d4171bb70c1630ab8f0dfcc169555e3db2", "url": "https://github.com/apollographql/apollo-android/commit/672948d4171bb70c1630ab8f0dfcc169555e3db2", "message": "add more gradle tests", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "f74d53cb640291cb242137bc12219e3226f9d658", "url": "https://github.com/apollographql/apollo-android/commit/f74d53cb640291cb242137bc12219e3226f9d658", "message": "wip", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "f43bada2b25b85c19ee73c96b45666a7c1ed6f1c", "url": "https://github.com/apollographql/apollo-android/commit/f43bada2b25b85c19ee73c96b45666a7c1ed6f1c", "message": "wip", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "847bd1d09deb5ff503af4bbdc4bc28a3d2040f29", "url": "https://github.com/apollographql/apollo-android/commit/847bd1d09deb5ff503af4bbdc4bc28a3d2040f29", "message": "better place to put the workaround", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "30876bf9af5c8b423bd0143d8cd204c7f2b46dfc", "url": "https://github.com/apollographql/apollo-android/commit/30876bf9af5c8b423bd0143d8cd204c7f2b46dfc", "message": "add experimental markers", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "2e4261dcb3142b5ece37c5c2d9eb005af77a1b12", "url": "https://github.com/apollographql/apollo-android/commit/2e4261dcb3142b5ece37c5c2d9eb005af77a1b12", "message": "remove some references to zip", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "aa51d5c5f212f9f4093cca5cb382c85920dc3754", "url": "https://github.com/apollographql/apollo-android/commit/aa51d5c5f212f9f4093cca5cb382c85920dc3754", "message": "fix test", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "3eca929bcd1c0b7ff148d3ae0fabea5997d360cd", "url": "https://github.com/apollographql/apollo-android/commit/3eca929bcd1c0b7ff148d3ae0fabea5997d360cd", "message": "add a test for diamond-shaped dependencies", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "8f0a857cec15e6477fa9de75661a026659599167", "url": "https://github.com/apollographql/apollo-android/commit/8f0a857cec15e6477fa9de75661a026659599167", "message": "work in progress on a duplicates task", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "3d9d2717eb5773c03cf5289fb9de6f8e8046f3a2", "url": "https://github.com/apollographql/apollo-android/commit/3d9d2717eb5773c03cf5289fb9de6f8e8046f3a2", "message": "add more tests", "committedDate": "2020-08-27T14:58:23Z", "type": "commit"}, {"oid": "0757f8878f4011146cf3ef88429ecc94c1d4f62c", "url": "https://github.com/apollographql/apollo-android/commit/0757f8878f4011146cf3ef88429ecc94c1d4f62c", "message": "fix tests", "committedDate": "2020-08-27T15:18:10Z", "type": "commit"}, {"oid": "0757f8878f4011146cf3ef88429ecc94c1d4f62c", "url": "https://github.com/apollographql/apollo-android/commit/0757f8878f4011146cf3ef88429ecc94c1d4f62c", "message": "fix tests", "committedDate": "2020-08-27T15:18:10Z", "type": "forcePushed"}, {"oid": "661420dd35157682cbb7c412cf4cfbe4e8eea8d4", "url": "https://github.com/apollographql/apollo-android/commit/661420dd35157682cbb7c412cf4cfbe4e8eea8d4", "message": "remove debug", "committedDate": "2020-08-27T15:40:53Z", "type": "commit"}, {"oid": "3eca9f5ad6fe53219641bbbbdca1375b064734fc", "url": "https://github.com/apollographql/apollo-android/commit/3eca9f5ad6fe53219641bbbbdca1375b064734fc", "message": "typo", "committedDate": "2020-08-27T16:25:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU0NTgxMQ==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r478545811", "bodyText": "There are a lot of changes in this file because I moved some of the IR logic that was in the Gradle plugin here.", "author": "martinbonnin", "createdAt": "2020-08-27T16:28:08Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/GraphQLCompiler.kt", "diffHunk": "@@ -1,52 +1,174 @@\n package com.apollographql.apollo.compiler\n \n+import com.apollographql.apollo.api.internal.QueryDocumentMinifier\n+import com.apollographql.apollo.compiler.ApolloMetadata.Companion.merge\n import com.apollographql.apollo.compiler.codegen.kotlin.GraphQLKompiler\n import com.apollographql.apollo.compiler.ir.CodeGenerationContext\n import com.apollographql.apollo.compiler.ir.CodeGenerationIR\n+import com.apollographql.apollo.compiler.ir.IRBuilder\n import com.apollographql.apollo.compiler.ir.ScalarType\n-import com.apollographql.apollo.compiler.ir.TypeDeclaration\n-import com.apollographql.apollo.compiler.operationoutput.OperationOutput\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration.Companion.KIND_ENUM\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration.Companion.KIND_INPUT_OBJECT_TYPE\n+import com.apollographql.apollo.compiler.operationoutput.OperationDescriptor\n+import com.apollographql.apollo.compiler.operationoutput.toJson\n+import com.apollographql.apollo.compiler.parser.graphql.GraphQLDocumentParser\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema.Companion.toIntrospectionSchema\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema.Companion.wrap\n+import com.apollographql.apollo.compiler.parser.sdl.GraphSdlSchema\n+import com.apollographql.apollo.compiler.parser.sdl.toIntrospectionSchema\n import com.squareup.javapoet.JavaFile\n+import com.squareup.kotlinpoet.asClassName\n import java.io.File\n \n class GraphQLCompiler {\n   fun write(args: Arguments) {", "originalCommit": "3eca9f5ad6fe53219641bbbbdca1375b064734fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU0NzcxOQ==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r478547719", "bodyText": "That's the workaround to not break Gradle build cache and still be able to read back into the file to display nice parse errors.", "author": "martinbonnin", "createdAt": "2020-08-27T16:31:08Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/GraphQLCompiler.kt", "diffHunk": "@@ -1,52 +1,174 @@\n package com.apollographql.apollo.compiler\n \n+import com.apollographql.apollo.api.internal.QueryDocumentMinifier\n+import com.apollographql.apollo.compiler.ApolloMetadata.Companion.merge\n import com.apollographql.apollo.compiler.codegen.kotlin.GraphQLKompiler\n import com.apollographql.apollo.compiler.ir.CodeGenerationContext\n import com.apollographql.apollo.compiler.ir.CodeGenerationIR\n+import com.apollographql.apollo.compiler.ir.IRBuilder\n import com.apollographql.apollo.compiler.ir.ScalarType\n-import com.apollographql.apollo.compiler.ir.TypeDeclaration\n-import com.apollographql.apollo.compiler.operationoutput.OperationOutput\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration.Companion.KIND_ENUM\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration.Companion.KIND_INPUT_OBJECT_TYPE\n+import com.apollographql.apollo.compiler.operationoutput.OperationDescriptor\n+import com.apollographql.apollo.compiler.operationoutput.toJson\n+import com.apollographql.apollo.compiler.parser.graphql.GraphQLDocumentParser\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema.Companion.toIntrospectionSchema\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema.Companion.wrap\n+import com.apollographql.apollo.compiler.parser.sdl.GraphSdlSchema\n+import com.apollographql.apollo.compiler.parser.sdl.toIntrospectionSchema\n import com.squareup.javapoet.JavaFile\n+import com.squareup.kotlinpoet.asClassName\n import java.io.File\n \n class GraphQLCompiler {\n   fun write(args: Arguments) {\n-    val ir = args.ir\n-    val customTypeMap = args.customTypeMap.supportedTypeMap(ir.typesUsed)\n-    val context = CodeGenerationContext(\n-        reservedTypeNames = emptyList(),\n-        typeDeclarations = ir.typesUsed,\n-        customTypeMap = customTypeMap,\n-        operationOutput = args.operationOutput,\n-        nullableValueType = args.nullableValueType,\n-        ir = ir,\n-        useSemanticNaming = args.useSemanticNaming,\n-        generateModelBuilder = args.generateModelBuilder,\n-        useJavaBeansSemanticNaming = args.useJavaBeansSemanticNaming,\n-        suppressRawTypesWarning = args.suppressRawTypesWarning,\n-        generateVisitorForPolymorphicDatatypes = args.generateVisitorForPolymorphicDatatypes\n+    args.outputDir.deleteRecursively()\n+    args.outputDir.mkdirs()\n+\n+    val roots = Roots(args.rootFolders)\n+    val metadata = collectMetadata(args.metadata, args.rootProjectDir)\n+\n+    val (introspectionSchema, schemaPackageName) = getSchemaInfo(roots, args.rootPackageName, args.schemaFile, metadata)\n+\n+    val generateKotlinModels = metadata?.generateKotlinModels ?: args.generateKotlinModels\n+    val userCustomTypesMap = metadata?.customTypesMap ?: args.customTypeMap\n+\n+    val packageNameProvider = DefaultPackageNameProvider(\n+        roots = roots,\n+        rootPackageName = args.rootPackageName\n     )\n \n-    if (args.generateKotlinModels) {\n+    val files = args.graphqlFiles\n+    checkDuplicateFiles(roots, files)\n+\n+    val parseResult = GraphQLDocumentParser(\n+        schema = introspectionSchema,\n+        packageNameProvider = packageNameProvider\n+    ).parse(files)\n+\n+    val ir = IRBuilder(\n+        schema = introspectionSchema,\n+        schemaPackageName = schemaPackageName,\n+        incomingMetadata = metadata,\n+        alwaysGenerateTypesMatching = args.alwaysGenerateTypesMatching,\n+        generateMetadata = args.generateMetadata\n+    ).build(parseResult)\n+\n+    val operationOutput = ir.operations.map {\n+      OperationDescriptor(\n+          name = it.operationName,\n+          packageName = it.packageName,\n+          filePath = it.filePath,\n+          source = QueryDocumentMinifier.minify(it.sourceWithFragments)\n+      )\n+    }.let {\n+      args.operationOutputGenerator.generate(it)\n+    }\n+\n+    check(operationOutput.size == ir.operations.size) {\n+      \"\"\"The number of operation IDs (${operationOutput.size}) should match the number of operations (${ir.operations.size}).\n+        |Check that all your IDs are unique.\n+      \"\"\".trimMargin()\n+    }\n+\n+    if (args.operationOutputFile != null) {\n+      args.operationOutputFile.writeText(operationOutput.toJson(\"  \"))\n+    }\n+\n+    val customTypeMap = (introspectionSchema.types.values.filter {\n+      it is IntrospectionSchema.Type.Scalar && ScalarType.forName(it.name) == null\n+    }.map { it.name } + ScalarType.ID.name)\n+        .supportedTypeMap(userCustomTypesMap, generateKotlinModels)\n+\n+    if (generateKotlinModels) {\n       GraphQLKompiler(\n           ir = ir,\n-          customTypeMap = args.customTypeMap,\n-          operationOutput = args.operationOutput,\n+          customTypeMap = customTypeMap,\n+          operationOutput = operationOutput,\n           useSemanticNaming = args.useSemanticNaming,\n           generateAsInternal = args.generateAsInternal,\n           kotlinMultiPlatformProject = args.kotlinMultiPlatformProject,\n           enumAsSealedClassPatternFilters = args.enumAsSealedClassPatternFilters.map { it.toRegex() }\n       ).write(args.outputDir)\n     } else {\n+      val context = CodeGenerationContext(\n+          reservedTypeNames = emptyList(),\n+          typeDeclarations = ir.typeDeclarations,\n+          customTypeMap = customTypeMap,\n+          operationOutput = operationOutput,\n+          nullableValueType = args.nullableValueType,\n+          ir = ir,\n+          useSemanticNaming = args.useSemanticNaming,\n+          generateModelBuilder = args.generateModelBuilder,\n+          useJavaBeansSemanticNaming = args.useJavaBeansSemanticNaming,\n+          suppressRawTypesWarning = args.suppressRawTypesWarning,\n+          generateVisitorForPolymorphicDatatypes = args.generateVisitorForPolymorphicDatatypes\n+      )\n+\n       ir.writeJavaFiles(\n           context = context,\n           outputDir = args.outputDir\n       )\n     }\n+\n+    args.metadataOutputFile.parentFile.mkdirs()\n+    if (args.generateMetadata) {\n+      val outgoingMetadata = ApolloMetadata(\n+          schema = if (metadata == null) introspectionSchema.wrap() else null,\n+          schemaPackageName = schemaPackageName,\n+          moduleName = args.moduleName,\n+          types = ir.enumsToGenerate + ir.inputObjectsToGenerate,\n+          fragments = ir.fragments.filter { ir.fragmentsToGenerate.contains(it.fragmentName) },\n+          generateKotlinModels = generateKotlinModels,\n+          customTypesMap = args.customTypeMap,\n+          pluginVersion = com.apollographql.apollo.compiler.VERSION\n+      ).let {\n+        if (args.rootProjectDir != null) {\n+          it.withRelativeFragments(args.rootProjectDir)", "originalCommit": "3eca9f5ad6fe53219641bbbbdca1375b064734fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1MDM3MA==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r478550370", "bodyText": "The code around custom scalars is more complex now, I'll most likely try to refactor in a subsequent pull request. customTypeMap here contains all the scalar types from the schema and their matching className either defined by the user or by us (for ID and Any).", "author": "martinbonnin", "createdAt": "2020-08-27T16:35:34Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/GraphQLCompiler.kt", "diffHunk": "@@ -1,52 +1,174 @@\n package com.apollographql.apollo.compiler\n \n+import com.apollographql.apollo.api.internal.QueryDocumentMinifier\n+import com.apollographql.apollo.compiler.ApolloMetadata.Companion.merge\n import com.apollographql.apollo.compiler.codegen.kotlin.GraphQLKompiler\n import com.apollographql.apollo.compiler.ir.CodeGenerationContext\n import com.apollographql.apollo.compiler.ir.CodeGenerationIR\n+import com.apollographql.apollo.compiler.ir.IRBuilder\n import com.apollographql.apollo.compiler.ir.ScalarType\n-import com.apollographql.apollo.compiler.ir.TypeDeclaration\n-import com.apollographql.apollo.compiler.operationoutput.OperationOutput\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration.Companion.KIND_ENUM\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration.Companion.KIND_INPUT_OBJECT_TYPE\n+import com.apollographql.apollo.compiler.operationoutput.OperationDescriptor\n+import com.apollographql.apollo.compiler.operationoutput.toJson\n+import com.apollographql.apollo.compiler.parser.graphql.GraphQLDocumentParser\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema.Companion.toIntrospectionSchema\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema.Companion.wrap\n+import com.apollographql.apollo.compiler.parser.sdl.GraphSdlSchema\n+import com.apollographql.apollo.compiler.parser.sdl.toIntrospectionSchema\n import com.squareup.javapoet.JavaFile\n+import com.squareup.kotlinpoet.asClassName\n import java.io.File\n \n class GraphQLCompiler {\n   fun write(args: Arguments) {\n-    val ir = args.ir\n-    val customTypeMap = args.customTypeMap.supportedTypeMap(ir.typesUsed)\n-    val context = CodeGenerationContext(\n-        reservedTypeNames = emptyList(),\n-        typeDeclarations = ir.typesUsed,\n-        customTypeMap = customTypeMap,\n-        operationOutput = args.operationOutput,\n-        nullableValueType = args.nullableValueType,\n-        ir = ir,\n-        useSemanticNaming = args.useSemanticNaming,\n-        generateModelBuilder = args.generateModelBuilder,\n-        useJavaBeansSemanticNaming = args.useJavaBeansSemanticNaming,\n-        suppressRawTypesWarning = args.suppressRawTypesWarning,\n-        generateVisitorForPolymorphicDatatypes = args.generateVisitorForPolymorphicDatatypes\n+    args.outputDir.deleteRecursively()\n+    args.outputDir.mkdirs()\n+\n+    val roots = Roots(args.rootFolders)\n+    val metadata = collectMetadata(args.metadata, args.rootProjectDir)\n+\n+    val (introspectionSchema, schemaPackageName) = getSchemaInfo(roots, args.rootPackageName, args.schemaFile, metadata)\n+\n+    val generateKotlinModels = metadata?.generateKotlinModels ?: args.generateKotlinModels\n+    val userCustomTypesMap = metadata?.customTypesMap ?: args.customTypeMap\n+\n+    val packageNameProvider = DefaultPackageNameProvider(\n+        roots = roots,\n+        rootPackageName = args.rootPackageName\n     )\n \n-    if (args.generateKotlinModels) {\n+    val files = args.graphqlFiles\n+    checkDuplicateFiles(roots, files)\n+\n+    val parseResult = GraphQLDocumentParser(\n+        schema = introspectionSchema,\n+        packageNameProvider = packageNameProvider\n+    ).parse(files)\n+\n+    val ir = IRBuilder(\n+        schema = introspectionSchema,\n+        schemaPackageName = schemaPackageName,\n+        incomingMetadata = metadata,\n+        alwaysGenerateTypesMatching = args.alwaysGenerateTypesMatching,\n+        generateMetadata = args.generateMetadata\n+    ).build(parseResult)\n+\n+    val operationOutput = ir.operations.map {\n+      OperationDescriptor(\n+          name = it.operationName,\n+          packageName = it.packageName,\n+          filePath = it.filePath,\n+          source = QueryDocumentMinifier.minify(it.sourceWithFragments)\n+      )\n+    }.let {\n+      args.operationOutputGenerator.generate(it)\n+    }\n+\n+    check(operationOutput.size == ir.operations.size) {\n+      \"\"\"The number of operation IDs (${operationOutput.size}) should match the number of operations (${ir.operations.size}).\n+        |Check that all your IDs are unique.\n+      \"\"\".trimMargin()\n+    }\n+\n+    if (args.operationOutputFile != null) {\n+      args.operationOutputFile.writeText(operationOutput.toJson(\"  \"))\n+    }\n+\n+    val customTypeMap = (introspectionSchema.types.values.filter {\n+      it is IntrospectionSchema.Type.Scalar && ScalarType.forName(it.name) == null\n+    }.map { it.name } + ScalarType.ID.name)\n+        .supportedTypeMap(userCustomTypesMap, generateKotlinModels)", "originalCommit": "3eca9f5ad6fe53219641bbbbdca1375b064734fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1MTMwNA==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r478551304", "bodyText": "That's where we tell the compiler to only generate a subset of input objects", "author": "martinbonnin", "createdAt": "2020-08-27T16:37:05Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ast/builder/SchemaBuilder.kt", "diffHunk": "@@ -19,16 +18,26 @@ internal fun CodeGenerationIR.ast(\n     useSemanticNaming: Boolean,\n     operationOutput: OperationOutput\n ): Schema {\n-  val enums = typesUsed.filter { it.kind == TypeDeclaration.KIND_ENUM }.map { it.ast() }\n-  val inputTypes = typesUsed.filter { it.kind == TypeDeclaration.KIND_INPUT_OBJECT_TYPE }.map {\n+  val enums = typeDeclarations.filter {\n+    it.kind == TypeDeclaration.KIND_ENUM\n+        // && enumsToGenerate.contains(it.name) // filtering is done later as the rest of the codegen needs all enums\n+  }.map {\n+    it.ast()\n+  }\n+  val inputTypes = typeDeclarations.filter {\n+    it.kind == TypeDeclaration.KIND_INPUT_OBJECT_TYPE\n+        && inputObjectsToGenerate.contains(it.name)", "originalCommit": "3eca9f5ad6fe53219641bbbbdca1375b064734fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1MTY3OA==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r478551678", "bodyText": "same for fragments (all fragments are still needed as input to validate arguments, type conditions, etc...)", "author": "martinbonnin", "createdAt": "2020-08-27T16:37:44Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ast/builder/SchemaBuilder.kt", "diffHunk": "@@ -19,16 +18,26 @@ internal fun CodeGenerationIR.ast(\n     useSemanticNaming: Boolean,\n     operationOutput: OperationOutput\n ): Schema {\n-  val enums = typesUsed.filter { it.kind == TypeDeclaration.KIND_ENUM }.map { it.ast() }\n-  val inputTypes = typesUsed.filter { it.kind == TypeDeclaration.KIND_INPUT_OBJECT_TYPE }.map {\n+  val enums = typeDeclarations.filter {\n+    it.kind == TypeDeclaration.KIND_ENUM\n+        // && enumsToGenerate.contains(it.name) // filtering is done later as the rest of the codegen needs all enums\n+  }.map {\n+    it.ast()\n+  }\n+  val inputTypes = typeDeclarations.filter {\n+    it.kind == TypeDeclaration.KIND_INPUT_OBJECT_TYPE\n+        && inputObjectsToGenerate.contains(it.name)\n+  }.map {\n     it.ast(\n         enums = enums,\n         customTypeMap = customTypeMap,\n         typesPackageName = typesPackageName\n     )\n   }\n   val irFragments = fragments.associateBy { it.fragmentName }\n-  val fragments = fragments.map {\n+  val fragments = fragments.filter {\n+    fragmentsToGenerate.contains(it.fragmentName)", "originalCommit": "3eca9f5ad6fe53219641bbbbdca1375b064734fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1Mjg3NA==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r478552874", "bodyText": "The IR is made serializable (to save the Fragment in the metadata). The serialization is only done if generateMetadata is true so as not to slow down compilation in the general case.", "author": "martinbonnin", "createdAt": "2020-08-27T16:39:44Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ir/Argument.kt", "diffHunk": "@@ -1,5 +1,8 @@\n package com.apollographql.apollo.compiler.ir\n \n+import com.squareup.moshi.JsonClass\n+\n+@JsonClass(generateAdapter = true)", "originalCommit": "3eca9f5ad6fe53219641bbbbdca1375b064734fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1MzkxNw==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r478553917", "bodyText": "This method decides what types to generate/not generate. The rest of this file is mainly code copied from GraphQLDocumentParser. GraphQLDocumentParser is now only responsible for parsing and IRBuilder does more global operation such as determining the types to generate and including the fragments sources.", "author": "martinbonnin", "createdAt": "2020-08-27T16:41:27Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ir/IRBuilder.kt", "diffHunk": "@@ -0,0 +1,258 @@\n+package com.apollographql.apollo.compiler.ir\n+\n+import com.apollographql.apollo.compiler.ApolloMetadata\n+import com.apollographql.apollo.compiler.applyIf\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration.Companion.KIND_ENUM\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration.Companion.KIND_INPUT_OBJECT_TYPE\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration.Companion.KIND_SCALAR_TYPE\n+import com.apollographql.apollo.compiler.parser.error.DocumentParseException\n+import com.apollographql.apollo.compiler.parser.error.ParseException\n+import com.apollographql.apollo.compiler.parser.graphql.DocumentParseResult\n+import com.apollographql.apollo.compiler.parser.graphql.checkMultipleFragmentDefinitions\n+import com.apollographql.apollo.compiler.parser.graphql.checkMultipleOperationDefinitions\n+import com.apollographql.apollo.compiler.parser.graphql.validateArguments\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema\n+import com.apollographql.apollo.compiler.parser.introspection.asGraphQLType\n+import com.apollographql.apollo.compiler.parser.introspection.possibleTypes\n+\n+class IRBuilder(private val schema: IntrospectionSchema,\n+                private val schemaPackageName: String,\n+                private val incomingMetadata: ApolloMetadata?,\n+                private val alwaysGenerateTypesMatching: Set<String>?,\n+                generateMetadata: Boolean\n+) {\n+  private val isRootCompilationUnit = incomingMetadata == null && generateMetadata\n+\n+  private fun extraTypes(): Set<String> {\n+    val regexes = (alwaysGenerateTypesMatching ?: (listOf(\".*\").takeIf { isRootCompilationUnit } ?: emptyList()))\n+        .map { Regex(it) }\n+\n+    return schema.types.values.filter { type ->\n+      (type.kind == IntrospectionSchema.Kind.ENUM\n+          || type.kind == IntrospectionSchema.Kind.INPUT_OBJECT)\n+          && regexes.indexOfFirst { it.matches(type.name) } >= 0\n+    }.map { it.name }\n+        .toSet()\n+  }\n+\n+  fun build(documentParseResult: DocumentParseResult): CodeGenerationIR {", "originalCommit": "3eca9f5ad6fe53219641bbbbdca1375b064734fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1NTA1NQ==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r478555055", "bodyText": "Do we need to generate \"ID\" in the CustomType enum? Is there a use case where users can register a custom adapter for \"ID\" ? In the spec, it is treated like Int, String and other builtin scalar types, it feels asymmetrical to give it a specific treatment there.", "author": "martinbonnin", "createdAt": "2020-08-27T16:43:25Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ir/IRBuilder.kt", "diffHunk": "@@ -0,0 +1,258 @@\n+package com.apollographql.apollo.compiler.ir\n+\n+import com.apollographql.apollo.compiler.ApolloMetadata\n+import com.apollographql.apollo.compiler.applyIf\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration.Companion.KIND_ENUM\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration.Companion.KIND_INPUT_OBJECT_TYPE\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration.Companion.KIND_SCALAR_TYPE\n+import com.apollographql.apollo.compiler.parser.error.DocumentParseException\n+import com.apollographql.apollo.compiler.parser.error.ParseException\n+import com.apollographql.apollo.compiler.parser.graphql.DocumentParseResult\n+import com.apollographql.apollo.compiler.parser.graphql.checkMultipleFragmentDefinitions\n+import com.apollographql.apollo.compiler.parser.graphql.checkMultipleOperationDefinitions\n+import com.apollographql.apollo.compiler.parser.graphql.validateArguments\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema\n+import com.apollographql.apollo.compiler.parser.introspection.asGraphQLType\n+import com.apollographql.apollo.compiler.parser.introspection.possibleTypes\n+\n+class IRBuilder(private val schema: IntrospectionSchema,\n+                private val schemaPackageName: String,\n+                private val incomingMetadata: ApolloMetadata?,\n+                private val alwaysGenerateTypesMatching: Set<String>?,\n+                generateMetadata: Boolean\n+) {\n+  private val isRootCompilationUnit = incomingMetadata == null && generateMetadata\n+\n+  private fun extraTypes(): Set<String> {\n+    val regexes = (alwaysGenerateTypesMatching ?: (listOf(\".*\").takeIf { isRootCompilationUnit } ?: emptyList()))\n+        .map { Regex(it) }\n+\n+    return schema.types.values.filter { type ->\n+      (type.kind == IntrospectionSchema.Kind.ENUM\n+          || type.kind == IntrospectionSchema.Kind.INPUT_OBJECT)\n+          && regexes.indexOfFirst { it.matches(type.name) } >= 0\n+    }.map { it.name }\n+        .toSet()\n+  }\n+\n+  fun build(documentParseResult: DocumentParseResult): CodeGenerationIR {\n+    val allFragments = (incomingMetadata?.fragments ?: emptyList()) + documentParseResult.fragments\n+\n+    documentParseResult.operations.checkMultipleOperationDefinitions()\n+    allFragments.checkMultipleFragmentDefinitions()\n+\n+    val fragmentsToGenerate = documentParseResult.fragments.map { it.fragmentName }\n+\n+    val incomingTypes = incomingMetadata?.types ?: emptySet()\n+    val extraTypes = extraTypes()\n+\n+    val typeDeclarations = (documentParseResult.usedTypes + extraTypes) .usedTypeDeclarations()\n+\n+    val enumsToGenerate = typeDeclarations.filter { it.kind == KIND_ENUM }\n+        .map { it.name }\n+        .filter { !incomingTypes.contains(it) }\n+\n+    val inputObjectsToGenerate = typeDeclarations.filter { it.kind == KIND_INPUT_OBJECT_TYPE }\n+        .map { it.name }\n+        .filter { !incomingTypes.contains(it) }\n+\n+    // Always generate the extra \"ID\" scalar type\n+    // I'm not 100% sure why this is required but keep this for backward compatibility", "originalCommit": "3eca9f5ad6fe53219641bbbbdca1375b064734fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1ODY3NA==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r478558674", "bodyText": "Refactored these tests slightly to have one test for Java and another for Kotlin", "author": "martinbonnin", "createdAt": "2020-08-27T16:49:21Z", "path": "apollo-compiler/src/test/kotlin/com/apollographql/apollo/compiler/CodegenTest.kt", "diffHunk": "@@ -218,16 +175,21 @@ class CodeGenTest(private val folder: File) {\n           generateVisitorForPolymorphicDatatypes = generateVisitorForPolymorphicDatatypes,\n           generateAsInternal = generateAsInternal,\n           kotlinMultiPlatformProject = true,\n-          enumAsSealedClassPatternFilters = enumAsSealedClassPatternFilters\n+          enumAsSealedClassPatternFilters = enumAsSealedClassPatternFilters,\n+          metadataOutputFile = File(\"build/generated/test/${folder.name}/metadata/$language\"),\n       )\n     }\n \n     @JvmStatic\n-    @Parameterized.Parameters(name = \"{0}\")\n-    fun data(): Collection<File> {\n+    @Parameterized.Parameters(name = \"{0}-{1}\")\n+    fun data(): Collection<Array<Any>> {\n       return File(\"src/test/graphql/com/example/\")\n           .listFiles()!!\n           .filter { it.isDirectory }\n+          .flatMap { listOf(\n+              arrayOf(it, TestLanguage.Java),\n+              arrayOf(it, TestLanguage.Kotlin)\n+          ) }", "originalCommit": "3eca9f5ad6fe53219641bbbbdca1375b064734fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1OTMxMg==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r478559312", "bodyText": "I expect multi-module to stay in experimental for some time so that we can tweak the APIs if needed.", "author": "martinbonnin", "createdAt": "2020-08-27T16:50:26Z", "path": "apollo-gradle-plugin/src/main/kotlin/com/apollographql/apollo/gradle/api/CompilerParams.kt", "diffHunk": "@@ -193,4 +194,29 @@ interface CompilerParams {\n    * the client was compiled against an older schema that doesn't have knowledge of the new enums.\n    */\n   val sealedClassesForEnumsMatching: ListProperty<String>\n+\n+  /**\n+   * Whether or not to generate Apollo metadata. Apollo metadata is used for multi-module support. Set this to true if you want other\n+   * modules to be able to re-use fragments and types from this module.\n+   *\n+   * This is currently experimental and this API might change in the future.\n+   *\n+   * Default value: false\n+   */\n+  @ApolloExperimental\n+  val generateApolloMetadata: Property<Boolean>", "originalCommit": "3eca9f5ad6fe53219641bbbbdca1375b064734fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2MDUwNg==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r478560506", "bodyText": "This is a pain. For 3.0, I'd like to do something about test variants. Most likely remove them... Do we know if anyone uses .graphql files in test source sets? Anything that could not be solved with a fair amount of R8?", "author": "martinbonnin", "createdAt": "2020-08-27T16:52:31Z", "path": "apollo-gradle-plugin/src/main/kotlin/com/apollographql/apollo/gradle/internal/DefaultCompilationUnit.kt", "diffHunk": "@@ -45,17 +45,29 @@ abstract class DefaultCompilationUnit @Inject constructor(\n     }\n \n     if (!compilerParams.schemaFile.isPresent) {\n-      compilerParams.schemaFile.set {\n-        project.file(\n+      // This needs to be lazy for:\n+      // - test variants that don't have a schema", "originalCommit": "3eca9f5ad6fe53219641bbbbdca1375b064734fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA0MzA5OA==", "url": "https://github.com/apollographql/apollo-android/pull/2514#discussion_r486043098", "bodyText": "Yeah we can remove this. not really sure what is the benefit of having unique graphql queries for test variants", "author": "sav007", "createdAt": "2020-09-10T03:36:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2MDUwNg=="}], "type": "inlineReview"}, {"oid": "10c43d5c9b1ea74c69b5a031caced11e47582e58", "url": "https://github.com/apollographql/apollo-android/commit/10c43d5c9b1ea74c69b5a031caced11e47582e58", "message": "Merge branch 'master' into feature-1973/multi-module", "committedDate": "2020-09-10T08:22:20Z", "type": "commit"}, {"oid": "4bca7855630a89d4ff61282b0ab6b7cb9d5f1071", "url": "https://github.com/apollographql/apollo-android/commit/4bca7855630a89d4ff61282b0ab6b7cb9d5f1071", "message": "in the compiler module, use 'metadata' instead of 'multi-module'", "committedDate": "2020-09-10T08:35:11Z", "type": "commit"}, {"oid": "25b40e738787bac10008535406e443c2ebdd2978", "url": "https://github.com/apollographql/apollo-android/commit/25b40e738787bac10008535406e443c2ebdd2978", "message": "added a few comments", "committedDate": "2020-09-10T09:35:29Z", "type": "commit"}, {"oid": "4332254ec9c8ef30c2bf84071f27f78d069ea43e", "url": "https://github.com/apollographql/apollo-android/commit/4332254ec9c8ef30c2bf84071f27f78d069ea43e", "message": "fix tests", "committedDate": "2020-09-10T09:49:27Z", "type": "commit"}, {"oid": "aa107e8b03496f40caeb10eb8b7390a670f7bbe9", "url": "https://github.com/apollographql/apollo-android/commit/aa107e8b03496f40caeb10eb8b7390a670f7bbe9", "message": "make Service and Variant public", "committedDate": "2020-09-10T10:47:14Z", "type": "commit"}, {"oid": "b99c69db35c7d36858e39872899a830142ada90c", "url": "https://github.com/apollographql/apollo-android/commit/b99c69db35c7d36858e39872899a830142ada90c", "message": "update metalava", "committedDate": "2020-09-10T11:22:33Z", "type": "commit"}]}