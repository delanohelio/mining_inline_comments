{"pr_number": 2203, "pr_title": "Convert ApolloStore to kotlin (#2144)", "pr_createdAt": "2020-04-21T21:13:46Z", "pr_url": "https://github.com/apollographql/apollo-android/pull/2203", "timeline": [{"oid": "3abbccfed7a5dff67ecbc33350a44c87ace8939a", "url": "https://github.com/apollographql/apollo-android/commit/3abbccfed7a5dff67ecbc33350a44c87ace8939a", "message": "Convert ApolloStore to kotlin (#2144)", "committedDate": "2020-04-21T21:13:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMTQ0MQ==", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412511441", "bodyText": "Would it be possible to put all parameters and then the return type on a new line?", "author": "tasomaniac", "createdAt": "2020-04-21T21:41:42Z", "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.api.GraphqlFragment\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.ApolloStore.RecordChangeSubscriber\n+import com.apollographql.apollo.cache.normalized.internal.NoOpApolloStore\n+import com.apollographql.apollo.cache.normalized.internal.ReadableStore\n+import com.apollographql.apollo.cache.normalized.internal.ResponseNormalizer\n+import com.apollographql.apollo.cache.normalized.internal.Transaction\n+import com.apollographql.apollo.cache.normalized.internal.WriteableStore\n+import java.util.UUID\n+\n+/**\n+ * ApolloStore exposes a thread-safe api to access a [com.apollographql.apollo.cache.normalized.NormalizedCache].\n+ * It also maintains a list of [RecordChangeSubscriber] that will be notified with changed records.\n+ *\n+ * Most clients should have no need to directly interface with an [ApolloStore].\n+ */\n+interface ApolloStore {\n+  /**\n+   * Listens to changed record keys dispatched via [.publish].\n+   */\n+  interface RecordChangeSubscriber {\n+    /**\n+     * @param changedRecordKeys A set of record keys which correspond to records which have had content changes.\n+     */\n+    fun onCacheRecordsChanged(changedRecordKeys: Set<String>)\n+  }\n+\n+  fun subscribe(subscriber: RecordChangeSubscriber)\n+  fun unsubscribe(subscriber: RecordChangeSubscriber)\n+\n+  /**\n+   * @param keys A set of keys of [Record] which have changed.\n+   */\n+  fun publish(keys: Set<String>)\n+\n+  /**\n+   * Clear all records from this [ApolloStore].\n+   *\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if all records was\n+   * successfully removed, `false` otherwise\n+   */\n+  fun clearAll(): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @param cascade defines if remove operation is propagated to the referenced entities\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey, cascade: Boolean): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache records by the list of keys\n+   *\n+   * @param cacheKeys keys of records to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with the count of records been removed\n+   */\n+  fun remove(cacheKeys: List<CacheKey>): ApolloStoreOperation<Int>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the network.\n+   */\n+  fun networkResponseNormalizer(): ResponseNormalizer<Map<String, Any>>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the cache.\n+   */\n+  fun cacheResponseNormalizer(): ResponseNormalizer<Record>\n+\n+  /**\n+   * Run a operation inside a read-lock. Blocks until read-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the read lock is acquired.\n+   * @param <R>         The result type of this read operation.\n+   * @return A result from the read operation.\n+  </R> */\n+  fun <R> readTransaction(transaction: Transaction<ReadableStore, R>): R\n+\n+  /**\n+   * Run a operation inside a write-lock. Blocks until write-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the write lock is acquired.\n+   * @param <R>         The result type of this write operation.\n+   * @return A result from the write operation.\n+  </R> */\n+  fun <R> writeTransaction(transaction: Transaction<WriteableStore, R>): R\n+\n+  /**\n+   * @return The [NormalizedCache] which backs this ApolloStore.\n+   */\n+  fun normalizedCache(): NormalizedCache\n+\n+  /**\n+   * @return the [CacheKeyResolver] used for resolving field cache keys\n+   */\n+  fun cacheKeyResolver(): CacheKeyResolver\n+\n+  /**\n+   * Read GraphQL operation from store.\n+   *\n+   * @param operation to be read\n+   * @param <D>       type of GraphQL operation data\n+   * @param <T>       type operation cached data will be wrapped with\n+   * @param <V>       type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached data for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>): ApolloStoreOperation<T>\n+\n+  /**\n+   * Read GraphQL operation response from store.\n+   *\n+   * @param operation           response of which should be read\n+   * @param responseFieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param responseNormalizer  [ResponseNormalizer] to be used when reading cached response\n+   * @param cacheHeaders        [CacheHeaders] to be used when reading cached response\n+   * @param <D>                 type of GraphQL operation data\n+   * @param <T>                 type operation cached data will be wrapped with\n+   * @param <V>                 type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached response for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>, responseFieldMapper: ResponseFieldMapper<D>,", "originalCommit": "3abbccfed7a5dff67ecbc33350a44c87ace8939a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY4Njk1Mw==", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412686953", "bodyText": "Do you mean something like this?\nfun <D : Operation.Data, T, V : Operation.Variables> read(\n      operation: Operation<D, T, V>, responseFieldMapper: ResponseFieldMapper<D>,\n      responseNormalizer: ResponseNormalizer<Record>, cacheHeaders: CacheHeaders\n): ApolloStoreOperation<Response<T>>", "author": "SubhrajyotiSen", "createdAt": "2020-04-22T05:46:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEzODU0MA==", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r413138540", "bodyText": "Yes. Actually every single param can be on a new line. That is what is recommended by Kotlin style guide when the function is too long.", "author": "tasomaniac", "createdAt": "2020-04-22T16:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMTYxMw==", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412511613", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  operation: Operation<D, T, V>): ApolloStoreOperation<T>\n          \n          \n            \n                  operation: Operation<D, T, V>\n          \n          \n            \n              ): ApolloStoreOperation<T>", "author": "tasomaniac", "createdAt": "2020-04-21T21:42:02Z", "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.api.GraphqlFragment\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.ApolloStore.RecordChangeSubscriber\n+import com.apollographql.apollo.cache.normalized.internal.NoOpApolloStore\n+import com.apollographql.apollo.cache.normalized.internal.ReadableStore\n+import com.apollographql.apollo.cache.normalized.internal.ResponseNormalizer\n+import com.apollographql.apollo.cache.normalized.internal.Transaction\n+import com.apollographql.apollo.cache.normalized.internal.WriteableStore\n+import java.util.UUID\n+\n+/**\n+ * ApolloStore exposes a thread-safe api to access a [com.apollographql.apollo.cache.normalized.NormalizedCache].\n+ * It also maintains a list of [RecordChangeSubscriber] that will be notified with changed records.\n+ *\n+ * Most clients should have no need to directly interface with an [ApolloStore].\n+ */\n+interface ApolloStore {\n+  /**\n+   * Listens to changed record keys dispatched via [.publish].\n+   */\n+  interface RecordChangeSubscriber {\n+    /**\n+     * @param changedRecordKeys A set of record keys which correspond to records which have had content changes.\n+     */\n+    fun onCacheRecordsChanged(changedRecordKeys: Set<String>)\n+  }\n+\n+  fun subscribe(subscriber: RecordChangeSubscriber)\n+  fun unsubscribe(subscriber: RecordChangeSubscriber)\n+\n+  /**\n+   * @param keys A set of keys of [Record] which have changed.\n+   */\n+  fun publish(keys: Set<String>)\n+\n+  /**\n+   * Clear all records from this [ApolloStore].\n+   *\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if all records was\n+   * successfully removed, `false` otherwise\n+   */\n+  fun clearAll(): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @param cascade defines if remove operation is propagated to the referenced entities\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey, cascade: Boolean): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache records by the list of keys\n+   *\n+   * @param cacheKeys keys of records to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with the count of records been removed\n+   */\n+  fun remove(cacheKeys: List<CacheKey>): ApolloStoreOperation<Int>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the network.\n+   */\n+  fun networkResponseNormalizer(): ResponseNormalizer<Map<String, Any>>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the cache.\n+   */\n+  fun cacheResponseNormalizer(): ResponseNormalizer<Record>\n+\n+  /**\n+   * Run a operation inside a read-lock. Blocks until read-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the read lock is acquired.\n+   * @param <R>         The result type of this read operation.\n+   * @return A result from the read operation.\n+  </R> */\n+  fun <R> readTransaction(transaction: Transaction<ReadableStore, R>): R\n+\n+  /**\n+   * Run a operation inside a write-lock. Blocks until write-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the write lock is acquired.\n+   * @param <R>         The result type of this write operation.\n+   * @return A result from the write operation.\n+  </R> */\n+  fun <R> writeTransaction(transaction: Transaction<WriteableStore, R>): R\n+\n+  /**\n+   * @return The [NormalizedCache] which backs this ApolloStore.\n+   */\n+  fun normalizedCache(): NormalizedCache\n+\n+  /**\n+   * @return the [CacheKeyResolver] used for resolving field cache keys\n+   */\n+  fun cacheKeyResolver(): CacheKeyResolver\n+\n+  /**\n+   * Read GraphQL operation from store.\n+   *\n+   * @param operation to be read\n+   * @param <D>       type of GraphQL operation data\n+   * @param <T>       type operation cached data will be wrapped with\n+   * @param <V>       type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached data for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>): ApolloStoreOperation<T>", "originalCommit": "3abbccfed7a5dff67ecbc33350a44c87ace8939a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMjkyNg==", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412512926", "bodyText": "This line says any [ ]. Is that a mistake? What should [ ] have?", "author": "tasomaniac", "createdAt": "2020-04-21T21:44:29Z", "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.api.GraphqlFragment\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.ApolloStore.RecordChangeSubscriber\n+import com.apollographql.apollo.cache.normalized.internal.NoOpApolloStore\n+import com.apollographql.apollo.cache.normalized.internal.ReadableStore\n+import com.apollographql.apollo.cache.normalized.internal.ResponseNormalizer\n+import com.apollographql.apollo.cache.normalized.internal.Transaction\n+import com.apollographql.apollo.cache.normalized.internal.WriteableStore\n+import java.util.UUID\n+\n+/**\n+ * ApolloStore exposes a thread-safe api to access a [com.apollographql.apollo.cache.normalized.NormalizedCache].\n+ * It also maintains a list of [RecordChangeSubscriber] that will be notified with changed records.\n+ *\n+ * Most clients should have no need to directly interface with an [ApolloStore].\n+ */\n+interface ApolloStore {\n+  /**\n+   * Listens to changed record keys dispatched via [.publish].\n+   */\n+  interface RecordChangeSubscriber {\n+    /**\n+     * @param changedRecordKeys A set of record keys which correspond to records which have had content changes.\n+     */\n+    fun onCacheRecordsChanged(changedRecordKeys: Set<String>)\n+  }\n+\n+  fun subscribe(subscriber: RecordChangeSubscriber)\n+  fun unsubscribe(subscriber: RecordChangeSubscriber)\n+\n+  /**\n+   * @param keys A set of keys of [Record] which have changed.\n+   */\n+  fun publish(keys: Set<String>)\n+\n+  /**\n+   * Clear all records from this [ApolloStore].\n+   *\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if all records was\n+   * successfully removed, `false` otherwise\n+   */\n+  fun clearAll(): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @param cascade defines if remove operation is propagated to the referenced entities\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey, cascade: Boolean): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache records by the list of keys\n+   *\n+   * @param cacheKeys keys of records to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with the count of records been removed\n+   */\n+  fun remove(cacheKeys: List<CacheKey>): ApolloStoreOperation<Int>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the network.\n+   */\n+  fun networkResponseNormalizer(): ResponseNormalizer<Map<String, Any>>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the cache.\n+   */\n+  fun cacheResponseNormalizer(): ResponseNormalizer<Record>\n+\n+  /**\n+   * Run a operation inside a read-lock. Blocks until read-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the read lock is acquired.\n+   * @param <R>         The result type of this read operation.\n+   * @return A result from the read operation.\n+  </R> */\n+  fun <R> readTransaction(transaction: Transaction<ReadableStore, R>): R\n+\n+  /**\n+   * Run a operation inside a write-lock. Blocks until write-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the write lock is acquired.\n+   * @param <R>         The result type of this write operation.\n+   * @return A result from the write operation.\n+  </R> */\n+  fun <R> writeTransaction(transaction: Transaction<WriteableStore, R>): R\n+\n+  /**\n+   * @return The [NormalizedCache] which backs this ApolloStore.\n+   */\n+  fun normalizedCache(): NormalizedCache\n+\n+  /**\n+   * @return the [CacheKeyResolver] used for resolving field cache keys\n+   */\n+  fun cacheKeyResolver(): CacheKeyResolver\n+\n+  /**\n+   * Read GraphQL operation from store.\n+   *\n+   * @param operation to be read\n+   * @param <D>       type of GraphQL operation data\n+   * @param <T>       type operation cached data will be wrapped with\n+   * @param <V>       type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached data for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>): ApolloStoreOperation<T>\n+\n+  /**\n+   * Read GraphQL operation response from store.\n+   *\n+   * @param operation           response of which should be read\n+   * @param responseFieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param responseNormalizer  [ResponseNormalizer] to be used when reading cached response\n+   * @param cacheHeaders        [CacheHeaders] to be used when reading cached response\n+   * @param <D>                 type of GraphQL operation data\n+   * @param <T>                 type operation cached data will be wrapped with\n+   * @param <V>                 type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached response for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>, responseFieldMapper: ResponseFieldMapper<D>,\n+      responseNormalizer: ResponseNormalizer<Record>, cacheHeaders: CacheHeaders): ApolloStoreOperation<Response<T>>\n+\n+  /**\n+   * Read GraphQL fragment from store.\n+   *\n+   * @param fieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param cacheKey    [CacheKey] to be used to find cache record for the fragment\n+   * @param variables   [Operation.Variables] required for fragment arguments resolving\n+   * @param <F>         type of fragment to be read\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached fragment data\n+  </F> */\n+  fun <F : GraphqlFragment> read(fieldMapper: ResponseFieldMapper<F>,\n+                                  cacheKey: CacheKey, variables: Operation.Variables): ApolloStoreOperation<F>\n+\n+  /**\n+   * Write operation to the store.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> write(\n+      operation: Operation<D, T, V>, operationData: D): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write operation to the store and publish changes of [Record] which have changed, that will notify any [ ] that depends on these [Record] to re-fetch.", "originalCommit": "3abbccfed7a5dff67ecbc33350a44c87ace8939a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMzI5Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412513296", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * notify any {@linkcom.apollographql.apollo.ApolloQueryWatcher} that depends on these [Record] to re-fetch.\n          \n          \n            \n               * notify any [com.apollographql.apollo.ApolloQueryWatcher] that depends on these [Record] to re-fetch.", "author": "tasomaniac", "createdAt": "2020-04-21T21:45:12Z", "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.api.GraphqlFragment\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.ApolloStore.RecordChangeSubscriber\n+import com.apollographql.apollo.cache.normalized.internal.NoOpApolloStore\n+import com.apollographql.apollo.cache.normalized.internal.ReadableStore\n+import com.apollographql.apollo.cache.normalized.internal.ResponseNormalizer\n+import com.apollographql.apollo.cache.normalized.internal.Transaction\n+import com.apollographql.apollo.cache.normalized.internal.WriteableStore\n+import java.util.UUID\n+\n+/**\n+ * ApolloStore exposes a thread-safe api to access a [com.apollographql.apollo.cache.normalized.NormalizedCache].\n+ * It also maintains a list of [RecordChangeSubscriber] that will be notified with changed records.\n+ *\n+ * Most clients should have no need to directly interface with an [ApolloStore].\n+ */\n+interface ApolloStore {\n+  /**\n+   * Listens to changed record keys dispatched via [.publish].\n+   */\n+  interface RecordChangeSubscriber {\n+    /**\n+     * @param changedRecordKeys A set of record keys which correspond to records which have had content changes.\n+     */\n+    fun onCacheRecordsChanged(changedRecordKeys: Set<String>)\n+  }\n+\n+  fun subscribe(subscriber: RecordChangeSubscriber)\n+  fun unsubscribe(subscriber: RecordChangeSubscriber)\n+\n+  /**\n+   * @param keys A set of keys of [Record] which have changed.\n+   */\n+  fun publish(keys: Set<String>)\n+\n+  /**\n+   * Clear all records from this [ApolloStore].\n+   *\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if all records was\n+   * successfully removed, `false` otherwise\n+   */\n+  fun clearAll(): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @param cascade defines if remove operation is propagated to the referenced entities\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey, cascade: Boolean): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache records by the list of keys\n+   *\n+   * @param cacheKeys keys of records to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with the count of records been removed\n+   */\n+  fun remove(cacheKeys: List<CacheKey>): ApolloStoreOperation<Int>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the network.\n+   */\n+  fun networkResponseNormalizer(): ResponseNormalizer<Map<String, Any>>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the cache.\n+   */\n+  fun cacheResponseNormalizer(): ResponseNormalizer<Record>\n+\n+  /**\n+   * Run a operation inside a read-lock. Blocks until read-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the read lock is acquired.\n+   * @param <R>         The result type of this read operation.\n+   * @return A result from the read operation.\n+  </R> */\n+  fun <R> readTransaction(transaction: Transaction<ReadableStore, R>): R\n+\n+  /**\n+   * Run a operation inside a write-lock. Blocks until write-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the write lock is acquired.\n+   * @param <R>         The result type of this write operation.\n+   * @return A result from the write operation.\n+  </R> */\n+  fun <R> writeTransaction(transaction: Transaction<WriteableStore, R>): R\n+\n+  /**\n+   * @return The [NormalizedCache] which backs this ApolloStore.\n+   */\n+  fun normalizedCache(): NormalizedCache\n+\n+  /**\n+   * @return the [CacheKeyResolver] used for resolving field cache keys\n+   */\n+  fun cacheKeyResolver(): CacheKeyResolver\n+\n+  /**\n+   * Read GraphQL operation from store.\n+   *\n+   * @param operation to be read\n+   * @param <D>       type of GraphQL operation data\n+   * @param <T>       type operation cached data will be wrapped with\n+   * @param <V>       type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached data for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>): ApolloStoreOperation<T>\n+\n+  /**\n+   * Read GraphQL operation response from store.\n+   *\n+   * @param operation           response of which should be read\n+   * @param responseFieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param responseNormalizer  [ResponseNormalizer] to be used when reading cached response\n+   * @param cacheHeaders        [CacheHeaders] to be used when reading cached response\n+   * @param <D>                 type of GraphQL operation data\n+   * @param <T>                 type operation cached data will be wrapped with\n+   * @param <V>                 type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached response for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>, responseFieldMapper: ResponseFieldMapper<D>,\n+      responseNormalizer: ResponseNormalizer<Record>, cacheHeaders: CacheHeaders): ApolloStoreOperation<Response<T>>\n+\n+  /**\n+   * Read GraphQL fragment from store.\n+   *\n+   * @param fieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param cacheKey    [CacheKey] to be used to find cache record for the fragment\n+   * @param variables   [Operation.Variables] required for fragment arguments resolving\n+   * @param <F>         type of fragment to be read\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached fragment data\n+  </F> */\n+  fun <F : GraphqlFragment> read(fieldMapper: ResponseFieldMapper<F>,\n+                                  cacheKey: CacheKey, variables: Operation.Variables): ApolloStoreOperation<F>\n+\n+  /**\n+   * Write operation to the store.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> write(\n+      operation: Operation<D, T, V>, operationData: D): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write operation to the store and publish changes of [Record] which have changed, that will notify any [ ] that depends on these [Record] to re-fetch.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> writeAndPublish(\n+      operation: Operation<D, T, V>, operationData: D): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Write fragment to the store.\n+   *\n+   * @param fragment data to be written to the store\n+   * @param cacheKey [CacheKey] to be used as root record key\n+   * @param {@link   Operation.Variables} required for fragment arguments resolving\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+   */\n+  fun write(fragment: GraphqlFragment, cacheKey: CacheKey,\n+            variables: Operation.Variables): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write fragment to the store and publish changes of [Record] which have changed, that will notify any ApolloQueryWatcher that\n+   * depends on these [Record] to re-fetch.\n+   *\n+   * @param fragment data to be written to the store\n+   * @param cacheKey [CacheKey] to be used as root record key\n+   * @param variables [Operation.Variables] required for fragment arguments resolving\n+   * @return [ApolloStoreOperation] to be performed\n+   */\n+  fun writeAndPublish(fragment: GraphqlFragment, cacheKey: CacheKey,\n+                      variables: Operation.Variables): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Write operation data to the optimistic store.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param mutationId    mutation unique identifier\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+   */\n+  fun <D : Operation.Data, T, V : Operation.Variables> writeOptimisticUpdates(operation: Operation<D, T, V>, operationData: D, mutationId: UUID): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write operation data to the optimistic store and publish changes of [Record]s which have changed, that will\n+   * notify any {@linkcom.apollographql.apollo.ApolloQueryWatcher} that depends on these [Record] to re-fetch.", "originalCommit": "3abbccfed7a5dff67ecbc33350a44c87ace8939a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMzU0OQ==", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412513549", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * notify any {@linkcom.apollographql.apollo.ApolloQueryWatcher} that depends on these [Record] to re-fetch.\n          \n          \n            \n               * notify any [com.apollographql.apollo.ApolloQueryWatcher] that depends on these [Record] to re-fetch.", "author": "tasomaniac", "createdAt": "2020-04-21T21:45:40Z", "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.api.GraphqlFragment\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.ApolloStore.RecordChangeSubscriber\n+import com.apollographql.apollo.cache.normalized.internal.NoOpApolloStore\n+import com.apollographql.apollo.cache.normalized.internal.ReadableStore\n+import com.apollographql.apollo.cache.normalized.internal.ResponseNormalizer\n+import com.apollographql.apollo.cache.normalized.internal.Transaction\n+import com.apollographql.apollo.cache.normalized.internal.WriteableStore\n+import java.util.UUID\n+\n+/**\n+ * ApolloStore exposes a thread-safe api to access a [com.apollographql.apollo.cache.normalized.NormalizedCache].\n+ * It also maintains a list of [RecordChangeSubscriber] that will be notified with changed records.\n+ *\n+ * Most clients should have no need to directly interface with an [ApolloStore].\n+ */\n+interface ApolloStore {\n+  /**\n+   * Listens to changed record keys dispatched via [.publish].\n+   */\n+  interface RecordChangeSubscriber {\n+    /**\n+     * @param changedRecordKeys A set of record keys which correspond to records which have had content changes.\n+     */\n+    fun onCacheRecordsChanged(changedRecordKeys: Set<String>)\n+  }\n+\n+  fun subscribe(subscriber: RecordChangeSubscriber)\n+  fun unsubscribe(subscriber: RecordChangeSubscriber)\n+\n+  /**\n+   * @param keys A set of keys of [Record] which have changed.\n+   */\n+  fun publish(keys: Set<String>)\n+\n+  /**\n+   * Clear all records from this [ApolloStore].\n+   *\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if all records was\n+   * successfully removed, `false` otherwise\n+   */\n+  fun clearAll(): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @param cascade defines if remove operation is propagated to the referenced entities\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey, cascade: Boolean): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache records by the list of keys\n+   *\n+   * @param cacheKeys keys of records to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with the count of records been removed\n+   */\n+  fun remove(cacheKeys: List<CacheKey>): ApolloStoreOperation<Int>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the network.\n+   */\n+  fun networkResponseNormalizer(): ResponseNormalizer<Map<String, Any>>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the cache.\n+   */\n+  fun cacheResponseNormalizer(): ResponseNormalizer<Record>\n+\n+  /**\n+   * Run a operation inside a read-lock. Blocks until read-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the read lock is acquired.\n+   * @param <R>         The result type of this read operation.\n+   * @return A result from the read operation.\n+  </R> */\n+  fun <R> readTransaction(transaction: Transaction<ReadableStore, R>): R\n+\n+  /**\n+   * Run a operation inside a write-lock. Blocks until write-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the write lock is acquired.\n+   * @param <R>         The result type of this write operation.\n+   * @return A result from the write operation.\n+  </R> */\n+  fun <R> writeTransaction(transaction: Transaction<WriteableStore, R>): R\n+\n+  /**\n+   * @return The [NormalizedCache] which backs this ApolloStore.\n+   */\n+  fun normalizedCache(): NormalizedCache\n+\n+  /**\n+   * @return the [CacheKeyResolver] used for resolving field cache keys\n+   */\n+  fun cacheKeyResolver(): CacheKeyResolver\n+\n+  /**\n+   * Read GraphQL operation from store.\n+   *\n+   * @param operation to be read\n+   * @param <D>       type of GraphQL operation data\n+   * @param <T>       type operation cached data will be wrapped with\n+   * @param <V>       type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached data for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>): ApolloStoreOperation<T>\n+\n+  /**\n+   * Read GraphQL operation response from store.\n+   *\n+   * @param operation           response of which should be read\n+   * @param responseFieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param responseNormalizer  [ResponseNormalizer] to be used when reading cached response\n+   * @param cacheHeaders        [CacheHeaders] to be used when reading cached response\n+   * @param <D>                 type of GraphQL operation data\n+   * @param <T>                 type operation cached data will be wrapped with\n+   * @param <V>                 type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached response for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>, responseFieldMapper: ResponseFieldMapper<D>,\n+      responseNormalizer: ResponseNormalizer<Record>, cacheHeaders: CacheHeaders): ApolloStoreOperation<Response<T>>\n+\n+  /**\n+   * Read GraphQL fragment from store.\n+   *\n+   * @param fieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param cacheKey    [CacheKey] to be used to find cache record for the fragment\n+   * @param variables   [Operation.Variables] required for fragment arguments resolving\n+   * @param <F>         type of fragment to be read\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached fragment data\n+  </F> */\n+  fun <F : GraphqlFragment> read(fieldMapper: ResponseFieldMapper<F>,\n+                                  cacheKey: CacheKey, variables: Operation.Variables): ApolloStoreOperation<F>\n+\n+  /**\n+   * Write operation to the store.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> write(\n+      operation: Operation<D, T, V>, operationData: D): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write operation to the store and publish changes of [Record] which have changed, that will notify any [ ] that depends on these [Record] to re-fetch.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> writeAndPublish(\n+      operation: Operation<D, T, V>, operationData: D): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Write fragment to the store.\n+   *\n+   * @param fragment data to be written to the store\n+   * @param cacheKey [CacheKey] to be used as root record key\n+   * @param {@link   Operation.Variables} required for fragment arguments resolving\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+   */\n+  fun write(fragment: GraphqlFragment, cacheKey: CacheKey,\n+            variables: Operation.Variables): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write fragment to the store and publish changes of [Record] which have changed, that will notify any ApolloQueryWatcher that\n+   * depends on these [Record] to re-fetch.\n+   *\n+   * @param fragment data to be written to the store\n+   * @param cacheKey [CacheKey] to be used as root record key\n+   * @param variables [Operation.Variables] required for fragment arguments resolving\n+   * @return [ApolloStoreOperation] to be performed\n+   */\n+  fun writeAndPublish(fragment: GraphqlFragment, cacheKey: CacheKey,\n+                      variables: Operation.Variables): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Write operation data to the optimistic store.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param mutationId    mutation unique identifier\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+   */\n+  fun <D : Operation.Data, T, V : Operation.Variables> writeOptimisticUpdates(operation: Operation<D, T, V>, operationData: D, mutationId: UUID): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write operation data to the optimistic store and publish changes of [Record]s which have changed, that will\n+   * notify any {@linkcom.apollographql.apollo.ApolloQueryWatcher} that depends on these [Record] to re-fetch.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param mutationId    mutation unique identifier\n+   * @return {@ApolloStoreOperation} to be performed\n+   */\n+  fun <D : Operation.Data, T, V : Operation.Variables> writeOptimisticUpdatesAndPublish(operation: Operation<D, T, V>, operationData: D,\n+                                                                                          mutationId: UUID): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Rollback operation data optimistic updates.\n+   *\n+   * @param mutationId mutation unique identifier\n+   * @return {@ApolloStoreOperation} to be performed\n+   */\n+  fun rollbackOptimisticUpdates(mutationId: UUID): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Rollback operation data optimistic updates and publish changes of [Record]s which have changed, that will\n+   * notify any {@linkcom.apollographql.apollo.ApolloQueryWatcher} that depends on these [Record] to re-fetch.", "originalCommit": "3abbccfed7a5dff67ecbc33350a44c87ace8939a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNDU5Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412514596", "bodyText": "I think it would be ok to keep the dispatcher NotNull.", "author": "tasomaniac", "createdAt": "2020-04-21T21:47:38Z", "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStoreOperation.kt", "diffHunk": "@@ -0,0 +1,102 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.exception.ApolloException\n+import java.util.concurrent.Executor\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * Apollo store operation to be performed.\n+ *\n+ *\n+ * This class is a wrapper around operation to be performed on [ApolloStore]. Due to the fact that any operation\n+ * can potentially include SQLite instruction, any operation on [ApolloStore] must be performed in background\n+ * thread. Use [.enqueue] to schedule such operation in the dispatcher with a callback to get results.\n+ *\n+ *\n+ * @param <T> result type for this operation\n+</T> */\n+abstract class ApolloStoreOperation<T> protected constructor(private val dispatcher: Executor?) {", "originalCommit": "3abbccfed7a5dff67ecbc33350a44c87ace8939a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY4Mjk1Nw==", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412682957", "bodyText": "emptyOperation passes null as a dispatcher", "author": "SubhrajyotiSen", "createdAt": "2020-04-22T05:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNDU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgxOTQ2Mw==", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r414819463", "bodyText": "emptyOperation is the least important there. I think it would be good to keep the constructor nice since it is exposed. What about implementing an emptyExecutor() to pass to emptyOperation. That would be just couple of lines there.", "author": "tasomaniac", "createdAt": "2020-04-24T19:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNDU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNTI5Nw==", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412515297", "bodyText": "Let's put 1 space between properties and the function\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected abstract fun perform(): T\n          \n          \n            \n            \n          \n          \n            \n              protected abstract fun perform(): T", "author": "tasomaniac", "createdAt": "2020-04-21T21:48:53Z", "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStoreOperation.kt", "diffHunk": "@@ -0,0 +1,102 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.exception.ApolloException\n+import java.util.concurrent.Executor\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * Apollo store operation to be performed.\n+ *\n+ *\n+ * This class is a wrapper around operation to be performed on [ApolloStore]. Due to the fact that any operation\n+ * can potentially include SQLite instruction, any operation on [ApolloStore] must be performed in background\n+ * thread. Use [.enqueue] to schedule such operation in the dispatcher with a callback to get results.\n+ *\n+ *\n+ * @param <T> result type for this operation\n+</T> */\n+abstract class ApolloStoreOperation<T> protected constructor(private val dispatcher: Executor?) {\n+  private val callback = AtomicReference<Callback<T>?>()\n+  private val executed = AtomicBoolean()\n+  protected abstract fun perform(): T", "originalCommit": "3abbccfed7a5dff67ecbc33350a44c87ace8939a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6dab3ecdd8f70f2dbe1c91d812231e5a93337e6a", "url": "https://github.com/apollographql/apollo-android/commit/6dab3ecdd8f70f2dbe1c91d812231e5a93337e6a", "message": "Fix formatting and missing documentation references", "committedDate": "2020-04-22T19:02:36Z", "type": "commit"}, {"oid": "6dab3ecdd8f70f2dbe1c91d812231e5a93337e6a", "url": "https://github.com/apollographql/apollo-android/commit/6dab3ecdd8f70f2dbe1c91d812231e5a93337e6a", "message": "Fix formatting and missing documentation references", "committedDate": "2020-04-22T19:02:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgxNzI2Nw==", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r414817267", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param {@link   Operation.Variables} required for fragment arguments resolving\n          \n          \n            \n               * @param variables [Operation.Variables] required for fragment arguments resolving", "author": "tasomaniac", "createdAt": "2020-04-24T19:38:18Z", "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.api.GraphqlFragment\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.ApolloStore.RecordChangeSubscriber\n+import com.apollographql.apollo.cache.normalized.internal.NoOpApolloStore\n+import com.apollographql.apollo.cache.normalized.internal.ReadableStore\n+import com.apollographql.apollo.cache.normalized.internal.ResponseNormalizer\n+import com.apollographql.apollo.cache.normalized.internal.Transaction\n+import com.apollographql.apollo.cache.normalized.internal.WriteableStore\n+import java.util.UUID\n+\n+/**\n+ * ApolloStore exposes a thread-safe api to access a [com.apollographql.apollo.cache.normalized.NormalizedCache].\n+ * It also maintains a list of [RecordChangeSubscriber] that will be notified with changed records.\n+ *\n+ * Most clients should have no need to directly interface with an [ApolloStore].\n+ */\n+interface ApolloStore {\n+  /**\n+   * Listens to changed record keys dispatched via [.publish].\n+   */\n+  interface RecordChangeSubscriber {\n+    /**\n+     * @param changedRecordKeys A set of record keys which correspond to records which have had content changes.\n+     */\n+    fun onCacheRecordsChanged(changedRecordKeys: Set<String>)\n+  }\n+\n+  fun subscribe(subscriber: RecordChangeSubscriber)\n+  fun unsubscribe(subscriber: RecordChangeSubscriber)\n+\n+  /**\n+   * @param keys A set of keys of [Record] which have changed.\n+   */\n+  fun publish(keys: Set<String>)\n+\n+  /**\n+   * Clear all records from this [ApolloStore].\n+   *\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if all records was\n+   * successfully removed, `false` otherwise\n+   */\n+  fun clearAll(): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @param cascade defines if remove operation is propagated to the referenced entities\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey, cascade: Boolean): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache records by the list of keys\n+   *\n+   * @param cacheKeys keys of records to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with the count of records been removed\n+   */\n+  fun remove(cacheKeys: List<CacheKey>): ApolloStoreOperation<Int>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the network.\n+   */\n+  fun networkResponseNormalizer(): ResponseNormalizer<Map<String, Any>>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the cache.\n+   */\n+  fun cacheResponseNormalizer(): ResponseNormalizer<Record>\n+\n+  /**\n+   * Run a operation inside a read-lock. Blocks until read-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the read lock is acquired.\n+   * @param <R>         The result type of this read operation.\n+   * @return A result from the read operation.\n+  </R> */\n+  fun <R> readTransaction(transaction: Transaction<ReadableStore, R>): R\n+\n+  /**\n+   * Run a operation inside a write-lock. Blocks until write-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the write lock is acquired.\n+   * @param <R>         The result type of this write operation.\n+   * @return A result from the write operation.\n+  </R> */\n+  fun <R> writeTransaction(transaction: Transaction<WriteableStore, R>): R\n+\n+  /**\n+   * @return The [NormalizedCache] which backs this ApolloStore.\n+   */\n+  fun normalizedCache(): NormalizedCache\n+\n+  /**\n+   * @return the [CacheKeyResolver] used for resolving field cache keys\n+   */\n+  fun cacheKeyResolver(): CacheKeyResolver\n+\n+  /**\n+   * Read GraphQL operation from store.\n+   *\n+   * @param operation to be read\n+   * @param <D>       type of GraphQL operation data\n+   * @param <T>       type operation cached data will be wrapped with\n+   * @param <V>       type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached data for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>\n+  ): ApolloStoreOperation<T>\n+\n+  /**\n+   * Read GraphQL operation response from store.\n+   *\n+   * @param operation           response of which should be read\n+   * @param responseFieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param responseNormalizer  [ResponseNormalizer] to be used when reading cached response\n+   * @param cacheHeaders        [CacheHeaders] to be used when reading cached response\n+   * @param <D>                 type of GraphQL operation data\n+   * @param <T>                 type operation cached data will be wrapped with\n+   * @param <V>                 type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached response for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>,\n+      responseFieldMapper: ResponseFieldMapper<D>,\n+      responseNormalizer: ResponseNormalizer<Record>,\n+      cacheHeaders: CacheHeaders\n+  ): ApolloStoreOperation<Response<T>>\n+\n+  /**\n+   * Read GraphQL fragment from store.\n+   *\n+   * @param fieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param cacheKey    [CacheKey] to be used to find cache record for the fragment\n+   * @param variables   [Operation.Variables] required for fragment arguments resolving\n+   * @param <F>         type of fragment to be read\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached fragment data\n+  </F> */\n+  fun <F : GraphqlFragment> read(\n+      fieldMapper: ResponseFieldMapper<F>,\n+      cacheKey: CacheKey,\n+      variables: Operation.Variables\n+  ): ApolloStoreOperation<F>\n+\n+  /**\n+   * Write operation to the store.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> write(\n+      operation: Operation<D, T, V>,\n+      operationData: D\n+  ): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write operation to the store and publish changes of [Record] which have changed, that will notify any [com.apollographql.apollo.ApolloQueryWatcher] that depends on these [Record] to re-fetch.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> writeAndPublish(\n+      operation: Operation<D, T, V>,\n+      operationData: D\n+  ): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Write fragment to the store.\n+   *\n+   * @param fragment data to be written to the store\n+   * @param cacheKey [CacheKey] to be used as root record key\n+   * @param {@link   Operation.Variables} required for fragment arguments resolving", "originalCommit": "6dab3ecdd8f70f2dbe1c91d812231e5a93337e6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1476ca3873584c0eb188d89711357ea3237a3d8a", "url": "https://github.com/apollographql/apollo-android/commit/1476ca3873584c0eb188d89711357ea3237a3d8a", "message": "Update apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "committedDate": "2020-04-24T19:38:36Z", "type": "commit"}, {"oid": "8a93f20a58b7208e6fdbd3ac312d500b2f7d0701", "url": "https://github.com/apollographql/apollo-android/commit/8a93f20a58b7208e6fdbd3ac312d500b2f7d0701", "message": "Make dispatcher NotNull in ApolloStoreOperation", "committedDate": "2020-04-25T03:48:15Z", "type": "commit"}]}