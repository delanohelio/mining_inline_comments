{"pr_number": 2256, "pr_title": "Kotlin runtime initial structure", "pr_createdAt": "2020-05-08T05:08:33Z", "pr_url": "https://github.com/apollographql/apollo-android/pull/2256", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0MzcxNg==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r421943716", "bodyText": "Sample of custom user RequestExecutor", "author": "sav007", "createdAt": "2020-05-08T05:19:29Z", "path": "apollo-runtime-kotlin/src/commonTest/kotlin/com/apollographql/apollo/mock/TestLoggerExecutor.kt", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.apollographql.apollo.mock\n+\n+import com.apollographql.apollo.executor.ExecutionRequest\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.executor.RequestExecutor\n+import com.apollographql.apollo.executor.RequestExecutorChain\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.catch\n+import kotlinx.coroutines.flow.onEach\n+import kotlinx.coroutines.flow.onStart\n+\n+object TestLoggerExecutor : RequestExecutor {", "originalCommit": "074d7bf0f7af26324761b168ccf662710a21f982", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0NDE3MQ==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r421944171", "bodyText": "KN doesn't provide runBlocking in common coroutines artifact, only in JVM and KN.", "author": "sav007", "createdAt": "2020-05-08T05:21:15Z", "path": "apollo-runtime-kotlin/src/commonTest/kotlin/com/apollographql/apollo/TestUtils.kt", "diffHunk": "@@ -0,0 +1,7 @@\n+package com.apollographql.apollo\n+\n+import kotlinx.coroutines.CoroutineScope\n+import kotlin.coroutines.CoroutineContext\n+import kotlin.coroutines.EmptyCoroutineContext\n+\n+expect fun <T> runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T", "originalCommit": "074d7bf0f7af26324761b168ccf662710a21f982", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5OTMxNw==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422199317", "bodyText": "silly question: Why is this a class and not a data class?", "author": "designatednerd", "createdAt": "2020-05-08T15:09:57Z", "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/network/NetworkRequest.kt", "diffHunk": "@@ -0,0 +1,8 @@\n+package com.apollographql.apollo.network\n+\n+class NetworkRequest(\n+    val operationName: String,\n+    val document: String,\n+    val variables: String,\n+    val extensions: String = \"\"\n+)", "originalCommit": "074d7bf0f7af26324761b168ccf662710a21f982", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0MTQ0Mg==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422341442", "bodyText": "for now there's no need it to be data class, as we don't need extra byte code to be generated that we aren't going to use (such as copy, equals, toString etc.)", "author": "sav007", "createdAt": "2020-05-08T19:53:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5OTMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMDc0OQ==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422200749", "bodyText": "omg i want the retryWhen API for everything I do now", "author": "designatednerd", "createdAt": "2020-05-08T15:12:43Z", "path": "apollo-runtime-kotlin/src/commonTest/kotlin/com/apollographql/apollo/ApolloClientTest.kt", "diffHunk": "@@ -0,0 +1,108 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.context.DispatchersContext\n+import com.apollographql.apollo.mock.MockNetworkTransport\n+import com.apollographql.apollo.mock.MockQuery\n+import com.apollographql.apollo.mock.TestLoggerExecutor\n+import com.apollographql.apollo.network.NetworkResponse\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.flow.retryWhen\n+import kotlinx.coroutines.flow.single\n+import okio.Buffer\n+import okio.ByteString.Companion.encodeUtf8\n+import kotlin.test.BeforeTest\n+import kotlin.test.Test\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNotNull\n+import kotlin.test.assertTrue\n+\n+@Suppress(\"EXPERIMENTAL_API_USAGE\")\n+class ApolloClientTest {\n+  private lateinit var networkTransport: MockNetworkTransport\n+  private lateinit var apolloClient: ApolloClient\n+\n+  @BeforeTest\n+  fun setUp() {\n+    networkTransport = MockNetworkTransport()\n+    apolloClient = ApolloClient(\n+        networkTransport = networkTransport,\n+        executionContext = ExecutionContext.Empty + DispatchersContext(\n+            ioDispatcher = Dispatchers.Unconfined\n+        ),\n+        executors = listOf(TestLoggerExecutor)\n+    )\n+  }\n+\n+  @Test\n+  fun `when query and success network response, assert success`() {\n+    networkTransport.offer(\n+        NetworkResponse(\n+            body = Buffer().write(\"{\\\"data\\\":{\\\"name\\\":\\\"MockQuery\\\"}}\".encodeUtf8()),\n+            executionContext = ExecutionContext.Empty\n+        )\n+    )\n+\n+    val response = runBlocking {\n+      apolloClient\n+          .query(MockQuery())\n+          .execute()\n+          .single()\n+    }\n+\n+    assertNotNull(response.data)\n+    assertEquals(expected = MockQuery.Data, actual = response.data)\n+  }\n+\n+  @Test\n+  fun `when query and malformed network response, assert parse error`() {\n+    networkTransport.offer(\n+        NetworkResponse(\n+            body = Buffer(),\n+            executionContext = ExecutionContext.Empty\n+        )\n+    )\n+\n+    val result = runBlocking {\n+      kotlin.runCatching {\n+        apolloClient\n+            .query(MockQuery())\n+            .execute()\n+            .single()\n+      }\n+    }\n+\n+    assertTrue(result.isFailure)\n+    result.onFailure { e ->\n+      assertTrue(e is ApolloException)\n+      assertTrue(e.error is ApolloError.ParseError)\n+    }\n+  }\n+\n+  @Test\n+  fun `when query and malformed network response, assert success after retry`() {\n+    networkTransport.offer(\n+        NetworkResponse(\n+            body = Buffer(),\n+            executionContext = ExecutionContext.Empty\n+        )\n+    )\n+    networkTransport.offer(\n+        NetworkResponse(\n+            body = Buffer().write(\"{\\\"data\\\":{\\\"name\\\":\\\"MockQuery\\\"}}\".encodeUtf8()),\n+            executionContext = ExecutionContext.Empty\n+        )\n+    )\n+\n+    val response = runBlocking {\n+      apolloClient\n+          .query(MockQuery())\n+          .execute()\n+          .retryWhen { cause, attempt -> cause is ApolloException && attempt == 0L }", "originalCommit": "074d7bf0f7af26324761b168ccf662710a21f982", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0MTY0NQ==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422341645", "bodyText": "yeah nice that we get this out of the box with Flow", "author": "sav007", "createdAt": "2020-05-08T19:53:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMDc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMTQ1MA==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422201450", "bodyText": "Do these need tot be TODO or should they actively throw an exception?", "author": "designatednerd", "createdAt": "2020-05-08T15:13:55Z", "path": "apollo-runtime-kotlin/src/commonTest/kotlin/com/apollographql/apollo/mock/MockQuery.kt", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.apollographql.apollo.mock\n+\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.OperationName\n+import com.apollographql.apollo.api.Query\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.api.internal.ResponseFieldMarshaller\n+import okio.BufferedSource\n+import okio.ByteString\n+\n+internal class MockQuery : Query<MockQuery.Data, MockQuery.Data, Operation.Variables> {\n+\n+  override fun composeRequestBody(\n+      autoPersistQueries: Boolean,\n+      withQueryDocument: Boolean,\n+      scalarTypeAdapters: ScalarTypeAdapters\n+  ): ByteString {\n+    return ByteString.of()\n+  }\n+\n+  override fun queryDocument(): String = \"query MockQuery { name }\"\n+\n+  override fun variables(): Operation.Variables = Operation.EMPTY_VARIABLES\n+\n+  override fun responseFieldMapper(): ResponseFieldMapper<Data> = ResponseFieldMapper.invoke {\n+    Data\n+  }\n+\n+  override fun wrapData(data: Data?): Data? = data\n+\n+  override fun name(): OperationName = object : OperationName {\n+    override fun name(): String = \"MockQuery\"\n+  }\n+\n+  override fun operationId(): String = \"operationId\"\n+\n+  override fun parse(source: BufferedSource, scalarTypeAdapters: ScalarTypeAdapters): Response<Data> {\n+    require(source.readUtf8() == \"{\\\"data\\\":{\\\"name\\\":\\\"MockQuery\\\"}}\")\n+    return Response(\n+        operation = this,\n+        data = Data\n+    )\n+  }\n+\n+  override fun parse(byteString: ByteString, scalarTypeAdapters: ScalarTypeAdapters): Response<Data> {\n+    require(byteString.toString() == \"{\\\"data\\\":{\\\"name\\\":\\\"MockQuery\\\"}}\")\n+    return Response(\n+        operation = this,\n+        data = Data\n+    )\n+  }\n+\n+  override fun parse(source: BufferedSource): Response<Data> {\n+    return parse(source, ScalarTypeAdapters.DEFAULT)\n+  }\n+\n+  override fun parse(byteString: ByteString): Response<Data> {\n+    return parse(byteString, ScalarTypeAdapters.DEFAULT)\n+  }\n+\n+  override fun composeRequestBody(scalarTypeAdapters: ScalarTypeAdapters): ByteString {\n+    TODO(\"Unsupported\")", "originalCommit": "074d7bf0f7af26324761b168ccf662710a21f982", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0MTg3OA==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422341878", "bodyText": "technically they throw exceptions, but I will replace with explicit ones", "author": "sav007", "createdAt": "2020-05-08T19:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMTQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMTMyNg==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422421326", "bodyText": "why not use the interceptors wording here instead ? Executors always remind me of https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executor.html but maybe I've done too much java.", "author": "martinbonnin", "createdAt": "2020-05-08T23:43:52Z", "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/ApolloClient.kt", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.Mutation\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Query\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.executor.NetworkExecutor\n+import com.apollographql.apollo.executor.RequestExecutor\n+import com.apollographql.apollo.internal.RealApolloCall\n+import com.apollographql.apollo.network.NetworkTransport\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi\n+class ApolloClient constructor(\n+    private val networkTransport: NetworkTransport,\n+    private val scalarTypeAdapters: ScalarTypeAdapters = ScalarTypeAdapters.DEFAULT,\n+    private val executors: List<RequestExecutor> = emptyList(),", "originalCommit": "074d7bf0f7af26324761b168ccf662710a21f982", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzgyNA==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422423824", "bodyText": "Sure we can name it as interceptors, no objection.", "author": "sav007", "createdAt": "2020-05-08T23:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMTMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMjEyNw==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422422127", "bodyText": "I guess operationId will need to be in there as well ?", "author": "martinbonnin", "createdAt": "2020-05-08T23:48:00Z", "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/network/NetworkRequest.kt", "diffHunk": "@@ -0,0 +1,8 @@\n+package com.apollographql.apollo.network\n+\n+class NetworkRequest(\n+    val operationName: String,\n+    val document: String,\n+    val variables: String,\n+    val extensions: String = \"\"", "originalCommit": "074d7bf0f7af26324761b168ccf662710a21f982", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMjk2MQ==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422422961", "bodyText": "Why not just:\nreturn RealRequestExecutorChain(executors).proceed(request = request)\n\n?", "author": "martinbonnin", "createdAt": "2020-05-08T23:52:39Z", "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/internal/RealApolloCall.kt", "diffHunk": "@@ -0,0 +1,39 @@\n+package com.apollographql.apollo.internal\n+\n+import com.apollographql.apollo.ApolloMutationCall\n+import com.apollographql.apollo.ApolloQueryCall\n+import com.apollographql.apollo.executor.ExecutionRequest\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.executor.RealRequestExecutorChain\n+import com.apollographql.apollo.executor.RequestExecutor\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.flatMapLatest\n+import kotlinx.coroutines.flow.flow\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi\n+class RealApolloCall<T> constructor(\n+    private val operation: Operation<*, T, *>,\n+    private val scalarTypeAdapters: ScalarTypeAdapters,\n+    private val executors: List<RequestExecutor>,\n+    private val executionContext: ExecutionContext\n+) : ApolloQueryCall<T>, ApolloMutationCall<T> {\n+\n+  override fun execute(): Flow<Response<T>> {\n+    val request = ExecutionRequest(\n+        operation = operation,\n+        scalarTypeAdapters = scalarTypeAdapters,\n+        executionContext = executionContext\n+    )\n+    return flow {\n+      emit(RealRequestExecutorChain(executors))\n+    }.flatMapLatest { executorChain ->\n+      executorChain.proceed(request)\n+    }", "originalCommit": "074d7bf0f7af26324761b168ccf662710a21f982", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMzc0OA==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422423748", "bodyText": "Because we want make returned flow to be re-tryable, means when user uses .retry() flow API we should re-try whole chain of executors not just a final version of built flow.", "author": "sav007", "createdAt": "2020-05-08T23:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMjk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzM1Nw==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422427357", "bodyText": "Do we need the dispatcher to be configurable per-request ? I was thinking this could be a property of the NetworkTransport instead ?", "author": "martinbonnin", "createdAt": "2020-05-09T00:15:13Z", "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/executor/NetworkExecutor.kt", "diffHunk": "@@ -0,0 +1,90 @@\n+package com.apollographql.apollo.executor\n+\n+import com.apollographql.apollo.ApolloError\n+import com.apollographql.apollo.ApolloException\n+import com.apollographql.apollo.context.DispatchersContext\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.network.NetworkRequest\n+import com.apollographql.apollo.network.NetworkResponse\n+import com.apollographql.apollo.network.NetworkTransport\n+import kotlinx.coroutines.CoroutineDispatcher\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.catch\n+import kotlinx.coroutines.flow.flatMapLatest\n+import kotlinx.coroutines.flow.flow\n+import kotlinx.coroutines.flow.flowOn\n+import kotlinx.coroutines.flow.map\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi\n+class NetworkExecutor(\n+    private val networkTransport: NetworkTransport\n+) : RequestExecutor {\n+\n+  override fun <T> execute(request: ExecutionRequest<T>, executorChain: RequestExecutorChain): Flow<Response<T>> {\n+    return flow { emit(request.toNetworkRequest()) }\n+        .flatMapLatest { networkRequest -> networkRequest.execute(request.executionContext) }\n+        .map { networkResponse -> networkResponse.parse(request) }\n+        .flowOn(request.executionContext.ioDispatcher)", "originalCommit": "074d7bf0f7af26324761b168ccf662710a21f982", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0NzMxMw==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422447313", "bodyText": "ApolloClient configures RealApolloCall:\nclass ApolloClient (...) {\n  ...\n  fun <D : Operation.Data, T, V : Operation.Variables> query(query: Query<D, T, V>): ApolloQueryCall<T> {\n    return RealApolloCall(\n        operation = query,\n        scalarTypeAdapters = scalarTypeAdapters,\n        executors = executors + NetworkExecutor(networkTransport),\n        executionContext = executionContext\n    )\n  }\n\nThen RealApolloCall configures ExecutionRequest:\nval request = ExecutionRequest(\n        operation = operation,\n        scalarTypeAdapters = scalarTypeAdapters,\n        executionContext = executionContext\n    )\n\nSo dispatchers will be set only once in ApolloClient and will carry over to the request and every executor can get access to them.\nIn this way we have one place where we can set dispatchers per ApolloClient instance.", "author": "sav007", "createdAt": "2020-05-09T03:24:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYxMzUwNw==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422613507", "bodyText": "So dispatchers will be set only once in ApolloClient and will carry over to the request and every executor can get access to them.\n\nWhat other executor than the NetworkExecutor would require a dispatcher ?\n\nIn this way we have one place where we can set dispatchers per ApolloClient instance.\n\nI was thinking that setting it on the NetworkTransport would make it more explicit to callers where the dispatcher is used. Obviously that doesn't work if other executors need to access it.", "author": "martinbonnin", "createdAt": "2020-05-10T08:59:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY5MDI3Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422690276", "bodyText": "After working on network layer I think we can drop passing any executor in the execution context for now. We can leave it to the client to decide, for example:\napolloClient\n  .query(repositoriesQuery)\n  .execute()\n  .flowOn(Dispatchers.IO) // up to the client to provide this\n  .single()", "author": "sav007", "createdAt": "2020-05-10T19:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwNDE3Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422704176", "bodyText": "Even better \ud83d\udc4d", "author": "martinbonnin", "createdAt": "2020-05-10T21:40:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzM1Nw=="}], "type": "inlineReview"}, {"oid": "4e531a18ada0b09161aea833468ad5d989185142", "url": "https://github.com/apollographql/apollo-android/commit/4e531a18ada0b09161aea833468ad5d989185142", "message": "Network layer + update sample", "committedDate": "2020-05-10T19:42:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY5MDQ5Mw==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422690493", "bodyText": "will be rebased after merge this PR: #2258", "author": "sav007", "createdAt": "2020-05-10T19:43:46Z", "path": "apollo-api/src/commonMain/kotlin/com/apollographql/apollo/api/ExecutionContext.kt", "diffHunk": "@@ -8,46 +8,110 @@ import kotlin.jvm.JvmField\n  * A context of GraphQL operation execution, represented as a set of [Key] keys and corresponding [Element] values.\n  */\n @ApolloExperimental\n-class ExecutionContext private constructor(private val context: Map<Key<*>, Element>) {\n+interface ExecutionContext {", "originalCommit": "4e531a18ada0b09161aea833468ad5d989185142", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwNTg2Mw==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422705863", "bodyText": "Some users might not want to enable ExperimentalCoroutinesApi in their repo. As long as it's only for multiplatform I guess it's fine but the day apollo-runtime-kotlin becomes the default JVM implementation, it might be an issue (if the api hasn't been promoted to stable before that)", "author": "martinbonnin", "createdAt": "2020-05-10T21:56:27Z", "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/ApolloClient.kt", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.Mutation\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Query\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.executor.NetworkExecutor\n+import com.apollographql.apollo.executor.RequestExecutor\n+import com.apollographql.apollo.internal.RealApolloCall\n+import com.apollographql.apollo.network.NetworkTransport\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi", "originalCommit": "4e531a18ada0b09161aea833468ad5d989185142", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcyMDExNw==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422720117", "bodyText": "Well, flow operators are still marked with flatMapLatest, so no sure what we do with this?", "author": "sav007", "createdAt": "2020-05-10T23:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwNTg2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg0MzAzMw==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422843033", "bodyText": "I guess it means keeping the JVM runtime around long enough for these flow operators to become stable?", "author": "martinbonnin", "createdAt": "2020-05-11T07:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwNTg2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0NzkzMw==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423347933", "bodyText": "yeah, we should keep JVM for some time.", "author": "sav007", "createdAt": "2020-05-11T22:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwNTg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwOTUyOQ==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422709529", "bodyText": "A common use case is to have an interceptor that can refresh the token. Should we add a concept of interceptors there as well ?", "author": "martinbonnin", "createdAt": "2020-05-10T22:30:22Z", "path": "samples/multiplatform/kmp-lib-sample/src/commonMain/kotlin/com/apollographql/apollo/kmpsample/data/ApolloCoroutinesRepository.kt", "diffHunk": "@@ -1,26 +1,39 @@\n package com.apollographql.apollo.kmpsample.data\n \n-import com.apollographql.apollo.kmpsample.fragment.RepositoryFragment\n+import com.apollographql.apollo.ApolloClient\n import com.apollographql.apollo.kmpsample.GithubRepositoriesQuery\n import com.apollographql.apollo.kmpsample.GithubRepositoryCommitsQuery\n import com.apollographql.apollo.kmpsample.GithubRepositoryDetailQuery\n import com.apollographql.apollo.kmpsample.fragment.RepositoryDetail\n+import com.apollographql.apollo.kmpsample.fragment.RepositoryFragment\n import com.apollographql.apollo.kmpsample.type.OrderDirection\n import com.apollographql.apollo.kmpsample.type.PullRequestState\n import com.apollographql.apollo.kmpsample.type.RepositoryOrderField\n+import com.apollographql.apollo.network.ApolloHttpNetworkTransport\n+import kotlinx.coroutines.flow.single\n \n /**\n  * An implementation of a [GitHubDataSource] that shows how we can use coroutines to make our apollo requests.\n  */\n-class ApolloCoroutinesRepository(private val service: ApolloCoroutinesService) {\n+class ApolloCoroutinesRepository {\n+  private val apolloClient = ApolloClient(\n+      networkTransport = ApolloHttpNetworkTransport(\n+          serverUrl = \"https://api.github.com/graphql\",\n+          httpHeaders = mapOf(\n+              \"Accept\" to \"application/json\",\n+              \"Content-Type\" to \"application/json\",\n+              \"Authorization\" to \"bearer $GITHUB_KEY\"", "originalCommit": "4e531a18ada0b09161aea833468ad5d989185142", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcxOTg1Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422719856", "bodyText": "Sure, we can. I guess we can do this in next PR. As we have to make abstraction that works for both OkHttp and NSURLSession.", "author": "sav007", "createdAt": "2020-05-10T23:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwOTUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwOTU4OQ==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422709589", "bodyText": "\ud83d\ude0e", "author": "martinbonnin", "createdAt": "2020-05-10T22:30:53Z", "path": "samples/multiplatform/kmp-lib-sample/src/iosMain/kotlin/com/apollographql/apollo/kmpsample/data/ApolloNetworkClient.kt", "diffHunk": "@@ -1,138 +0,0 @@\n-package com.apollographql.apollo.kmpsample.data\n-\n-import com.apollographql.apollo.api.Operation\n-import com.apollographql.apollo.api.Response\n-import kotlinx.cinterop.COpaquePointer\n-import kotlinx.cinterop.StableRef\n-import kotlinx.cinterop.addressOf\n-import kotlinx.cinterop.asStableRef\n-import kotlinx.cinterop.convert\n-import kotlinx.cinterop.staticCFunction\n-import kotlinx.cinterop.usePinned\n-import kotlinx.coroutines.CancellableContinuation\n-import kotlinx.coroutines.suspendCancellableCoroutine\n-import okio.IOException\n-import okio.toByteString\n-import platform.Foundation.NSData\n-import platform.Foundation.NSError\n-import platform.Foundation.NSHTTPURLResponse\n-import platform.Foundation.NSMutableData\n-import platform.Foundation.NSMutableURLRequest\n-import platform.Foundation.NSThread\n-import platform.Foundation.NSURL\n-import platform.Foundation.NSURLRequestReloadIgnoringCacheData\n-import platform.Foundation.NSURLResponse\n-import platform.Foundation.NSURLSession\n-import platform.Foundation.NSURLSessionConfiguration\n-import platform.Foundation.appendBytes\n-import platform.Foundation.dataTaskWithRequest\n-import platform.Foundation.setHTTPBody\n-import platform.Foundation.setHTTPMethod\n-import platform.Foundation.setValue\n-import platform.darwin.dispatch_async_f\n-import platform.darwin.dispatch_get_main_queue\n-import kotlin.coroutines.resume\n-import kotlin.coroutines.resumeWithException\n-import kotlin.native.concurrent.freeze\n-\n-internal class ApolloNetworkClient(", "originalCommit": "4e531a18ada0b09161aea833468ad5d989185142", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a4533ed25b147c22e17218d2899dff4866d98bcd", "url": "https://github.com/apollographql/apollo-android/commit/a4533ed25b147c22e17218d2899dff4866d98bcd", "message": "Network layer + update sample", "committedDate": "2020-05-11T00:57:13Z", "type": "forcePushed"}, {"oid": "3972ff739de1933abb97d29d717d567fb7a0c542", "url": "https://github.com/apollographql/apollo-android/commit/3972ff739de1933abb97d29d717d567fb7a0c542", "message": "Introduce GraphQL execution context\n\nProvide type safe container to customize and extend `Response` with additional context, such as providing access to raw OkHttp response.\n\nCloses https://github.com/apollographql/apollo-android/issues/2205", "committedDate": "2020-05-11T22:08:55Z", "type": "commit"}, {"oid": "ae27b274382b33ddfe967f6f0ad6230c62217865", "url": "https://github.com/apollographql/apollo-android/commit/ae27b274382b33ddfe967f6f0ad6230c62217865", "message": "Feedback", "committedDate": "2020-05-11T22:08:55Z", "type": "commit"}, {"oid": "f74bbcf35c52a74dea04b257b76e3a3a9e6d9eb0", "url": "https://github.com/apollographql/apollo-android/commit/f74bbcf35c52a74dea04b257b76e3a3a9e6d9eb0", "message": "Kotlin runtime initial structure\n\nIntroduce new `apollo-runtime-kotlin` module with initial structure:\n- `ApolloClient` similar to JVM version, a facade for user interface\n- `RequestExecutor` is a business logic layer responsible for query execution. Allows to create a chain / pipeline of several executors. Each executor observes, modifies, and potentially short-circuits GraphQL operation requests. `NetworkExecutor` is a final / terminal request executor in the chain, responsible for network execution via configured `NetworkTransport`\n- `NetworkTransport` is an abstraction for networking. Apollo is going to provide several `NetworkTransport` implementations: Http(JVM/iOS) and WebSocket(JVM/iOS)\n- `DispatchersContext` provides configuration for coroutine dispatchers, that will be put into `ExecutionContext`\n\nPart of https://github.com/apollographql/apollo-android/issues/2222", "committedDate": "2020-05-11T22:08:55Z", "type": "commit"}, {"oid": "4793711acfac8aba6e6e6fe43fc697d9f139293f", "url": "https://github.com/apollographql/apollo-android/commit/4793711acfac8aba6e6e6fe43fc697d9f139293f", "message": "Network layer + update sample", "committedDate": "2020-05-11T22:08:55Z", "type": "commit"}, {"oid": "4793711acfac8aba6e6e6fe43fc697d9f139293f", "url": "https://github.com/apollographql/apollo-android/commit/4793711acfac8aba6e6e6fe43fc697d9f139293f", "message": "Network layer + update sample", "committedDate": "2020-05-11T22:08:55Z", "type": "forcePushed"}, {"oid": "f1fac05dae8a5a2e02c12669c5a65bc743d44fa4", "url": "https://github.com/apollographql/apollo-android/commit/f1fac05dae8a5a2e02c12669c5a65bc743d44fa4", "message": "Address feedback", "committedDate": "2020-05-12T00:44:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzNDQzMg==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423434432", "bodyText": "I have two somewhat contradictory questions:\n\nWhy are we using multiple interfaces here if they're not adding any functionality?\nWhy isn't there an ApolloSubscriptionCall<T>?", "author": "designatednerd", "createdAt": "2020-05-12T03:03:10Z", "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/ApolloCall.kt", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.api.Response\n+import kotlinx.coroutines.flow.Flow\n+\n+interface ApolloCall<T> {\n+  fun execute(): Flow<Response<T>>\n+}\n+\n+interface ApolloQueryCall<T> : ApolloCall<T>\n+\n+interface ApolloMutationCall<T> : ApolloCall<T>", "originalCommit": "f1fac05dae8a5a2e02c12669c5a65bc743d44fa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ3ODM5Mw==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423478393", "bodyText": "it's for the future like normalized cache, any API for normalized cache will be defined as an extension functions, but we need to have 2 separate interfaces as only for cache is supported for ApolloQueryCall\n\n\nApolloSubscriptionCall  will be added when we start working on subscription KN version.", "author": "sav007", "createdAt": "2020-05-12T05:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzNDQzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MTU4NQ==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423881585", "bodyText": "I suspect people will want mutation results to update the cache as well, but that makes sense.", "author": "designatednerd", "createdAt": "2020-05-12T16:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzNDQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzODY1MQ==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423438651", "bodyText": "is it such a rare occurrence that ref would be null that the force-unwrap is appropriate here?", "author": "designatednerd", "createdAt": "2020-05-12T03:20:36Z", "path": "apollo-runtime-kotlin/src/iosMain/kotlin/com/apollographql/apollo/network/ApolloHttpNetworkTransport.kt", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.apollographql.apollo.network\n+\n+import com.apollographql.apollo.ApolloError\n+import com.apollographql.apollo.ApolloException\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import kotlinx.cinterop.COpaquePointer\n+import kotlinx.cinterop.StableRef\n+import kotlinx.cinterop.addressOf\n+import kotlinx.cinterop.asStableRef\n+import kotlinx.cinterop.convert\n+import kotlinx.cinterop.staticCFunction\n+import kotlinx.cinterop.usePinned\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.channels.ProducerScope\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import okio.Buffer\n+import okio.IOException\n+import okio.toByteString\n+import platform.Foundation.NSData\n+import platform.Foundation.NSError\n+import platform.Foundation.NSHTTPURLResponse\n+import platform.Foundation.NSMutableData\n+import platform.Foundation.NSMutableURLRequest\n+import platform.Foundation.NSThread\n+import platform.Foundation.NSURL\n+import platform.Foundation.NSURLComponents\n+import platform.Foundation.NSURLQueryItem\n+import platform.Foundation.NSURLRequestReloadIgnoringCacheData\n+import platform.Foundation.NSURLResponse\n+import platform.Foundation.NSURLSession\n+import platform.Foundation.NSURLSessionConfiguration\n+import platform.Foundation.appendBytes\n+import platform.Foundation.dataTaskWithRequest\n+import platform.Foundation.setHTTPBody\n+import platform.Foundation.setHTTPMethod\n+import platform.Foundation.setValue\n+import platform.darwin.dispatch_async_f\n+import platform.darwin.dispatch_get_main_queue\n+import kotlin.native.concurrent.freeze\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi\n+actual class ApolloHttpNetworkTransport(\n+    private val serverUrl: NSURL,\n+    private val httpHeaders: Map<String, String>,\n+    private val httpMethod: HttpMethod,\n+    private val urlSession: NSURLSession\n+) : NetworkTransport {\n+\n+  actual constructor(\n+      serverUrl: String,\n+      httpHeaders: Map<String, String>,\n+      httpMethod: HttpMethod\n+  ) : this(\n+      serverUrl = NSURL(string = serverUrl),\n+      httpHeaders = httpHeaders,\n+      httpMethod = httpMethod,\n+      urlSession = NSURLSession.sessionWithConfiguration(NSURLSessionConfiguration.defaultSessionConfiguration())\n+  )\n+\n+  override fun execute(request: GraphQLRequest): Flow<GraphQLResponse> {\n+    return callbackFlow {\n+      assert(NSThread.isMainThread())\n+\n+      val producerRef = StableRef.create(this).asCPointer()\n+      val delegate = { httpData: NSData?, httpResponse: NSURLResponse?, error: NSError? ->\n+        initRuntimeIfNeeded()\n+        val response = parse(\n+            data = httpData,\n+            httpResponse = httpResponse as NSHTTPURLResponse,\n+            error = error\n+        )\n+        response.dispatchOnMain(producerRef)\n+      }\n+      val httpRequest = request.toHttpRequest()\n+      val task = urlSession.dataTaskWithRequest(httpRequest.freeze(), delegate.freeze()).apply {\n+        resume()\n+      }\n+      awaitClose {\n+        task.cancel()\n+      }\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpRequest(): NSMutableURLRequest {\n+    return when (httpMethod) {\n+      HttpMethod.Get -> toHttpGetRequest()\n+      HttpMethod.Post -> toHttpPostRequest()\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpGetRequest(): NSMutableURLRequest {\n+    val urlComponents = NSURLComponents(uRL = serverUrl, resolvingAgainstBaseURL = false)\n+    urlComponents.queryItems = listOfNotNull(\n+        NSURLQueryItem(name = \"query\", value = document),\n+        NSURLQueryItem(name = \"operationName\", value = operationName),\n+        if (variables.isNotEmpty()) NSURLQueryItem(name = \"variables\", value = variables) else null\n+    )\n+    return NSMutableURLRequest.requestWithURL(urlComponents.URL!!).apply {\n+      setHTTPMethod(\"GET\")\n+      httpHeaders.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpPostRequest(): NSMutableURLRequest {\n+    return NSMutableURLRequest.requestWithURL(serverUrl).apply {\n+      val buffer = Buffer()\n+      JsonWriter.of(buffer)\n+          .beginObject()\n+          .name(\"operationName\").value(operationName)\n+          .name(\"query\").value(document)\n+          .name(\"variables\").value(variables)\n+          .endObject()\n+          .close()\n+      val postBody = buffer.readByteArray().toNSData()\n+\n+      setHTTPMethod(\"POST\")\n+      httpHeaders.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+      setHTTPBody(postBody)\n+    }\n+  }\n+\n+  private fun parse(\n+      data: NSData?,\n+      httpResponse: NSHTTPURLResponse,\n+      error: NSError?\n+  ): Result {\n+    if (error != null) return Result.Failure(\n+        ApolloException(\n+            message = \"Failed to execute GraphQL http network request\",\n+            error = ApolloError.Network,\n+            cause = IOException(error.localizedDescription)\n+        )\n+    )\n+\n+    val statusCode = httpResponse.statusCode.toInt()\n+    if (statusCode !in 200..299) return Result.Failure(\n+        ApolloException(\n+            message = \"Http request failed with status code `$statusCode`\",\n+            error = ApolloError.Network\n+        )\n+    )\n+\n+    if (data == null) return Result.Failure(\n+        ApolloException(\n+            message = \"Failed to parse GraphQL http network response: EOF\",\n+            error = ApolloError.Network\n+        )\n+    )\n+\n+    return Result.Success(data)\n+  }\n+\n+  sealed class Result {\n+    class Success(val data: NSData) : Result()\n+    class Failure(val cause: ApolloException) : Result()\n+  }\n+\n+  private fun ByteArray.toNSData(): NSData = NSMutableData().apply {\n+    if (isEmpty()) return@apply\n+    this@toNSData.usePinned {\n+      appendBytes(it.addressOf(0), size.convert())\n+    }\n+  }\n+\n+  @Suppress(\"NAME_SHADOWING\")\n+  private fun Result.dispatchOnMain(producerRef: COpaquePointer) {\n+    val producerWithResultRef = StableRef.create((producerRef to this).freeze())\n+    dispatch_async_f(\n+        queue = dispatch_get_main_queue(),\n+        context = producerWithResultRef.asCPointer(),\n+        work = staticCFunction { ref ->\n+          val producerWithResultRef = ref!!.asStableRef<Pair<COpaquePointer, Result>>()", "originalCommit": "f1fac05dae8a5a2e02c12669c5a65bc743d44fa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ3OTE3MQ==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423479171", "bodyText": "staticCFunction signature defines argument as nullable, but we pass context as non nullable value, ref should never be null that's why force unwrap", "author": "sav007", "createdAt": "2020-05-12T05:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzODY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzOTMzNQ==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423439335", "bodyText": "context and queue here are properties of NetworkTransport, right? I think you're OK in terms of automatic reference counting here, but it might be worth doing some profiling to make sure you're not creating retain cycles.", "author": "designatednerd", "createdAt": "2020-05-12T03:23:44Z", "path": "apollo-runtime-kotlin/src/iosMain/kotlin/com/apollographql/apollo/network/ApolloHttpNetworkTransport.kt", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.apollographql.apollo.network\n+\n+import com.apollographql.apollo.ApolloError\n+import com.apollographql.apollo.ApolloException\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import kotlinx.cinterop.COpaquePointer\n+import kotlinx.cinterop.StableRef\n+import kotlinx.cinterop.addressOf\n+import kotlinx.cinterop.asStableRef\n+import kotlinx.cinterop.convert\n+import kotlinx.cinterop.staticCFunction\n+import kotlinx.cinterop.usePinned\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.channels.ProducerScope\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import okio.Buffer\n+import okio.IOException\n+import okio.toByteString\n+import platform.Foundation.NSData\n+import platform.Foundation.NSError\n+import platform.Foundation.NSHTTPURLResponse\n+import platform.Foundation.NSMutableData\n+import platform.Foundation.NSMutableURLRequest\n+import platform.Foundation.NSThread\n+import platform.Foundation.NSURL\n+import platform.Foundation.NSURLComponents\n+import platform.Foundation.NSURLQueryItem\n+import platform.Foundation.NSURLRequestReloadIgnoringCacheData\n+import platform.Foundation.NSURLResponse\n+import platform.Foundation.NSURLSession\n+import platform.Foundation.NSURLSessionConfiguration\n+import platform.Foundation.appendBytes\n+import platform.Foundation.dataTaskWithRequest\n+import platform.Foundation.setHTTPBody\n+import platform.Foundation.setHTTPMethod\n+import platform.Foundation.setValue\n+import platform.darwin.dispatch_async_f\n+import platform.darwin.dispatch_get_main_queue\n+import kotlin.native.concurrent.freeze\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi\n+actual class ApolloHttpNetworkTransport(\n+    private val serverUrl: NSURL,\n+    private val httpHeaders: Map<String, String>,\n+    private val httpMethod: HttpMethod,\n+    private val urlSession: NSURLSession\n+) : NetworkTransport {\n+\n+  actual constructor(\n+      serverUrl: String,\n+      httpHeaders: Map<String, String>,\n+      httpMethod: HttpMethod\n+  ) : this(\n+      serverUrl = NSURL(string = serverUrl),\n+      httpHeaders = httpHeaders,\n+      httpMethod = httpMethod,\n+      urlSession = NSURLSession.sessionWithConfiguration(NSURLSessionConfiguration.defaultSessionConfiguration())\n+  )\n+\n+  override fun execute(request: GraphQLRequest): Flow<GraphQLResponse> {\n+    return callbackFlow {\n+      assert(NSThread.isMainThread())\n+\n+      val producerRef = StableRef.create(this).asCPointer()\n+      val delegate = { httpData: NSData?, httpResponse: NSURLResponse?, error: NSError? ->\n+        initRuntimeIfNeeded()\n+        val response = parse(\n+            data = httpData,\n+            httpResponse = httpResponse as NSHTTPURLResponse,\n+            error = error\n+        )\n+        response.dispatchOnMain(producerRef)\n+      }\n+      val httpRequest = request.toHttpRequest()\n+      val task = urlSession.dataTaskWithRequest(httpRequest.freeze(), delegate.freeze()).apply {\n+        resume()\n+      }\n+      awaitClose {\n+        task.cancel()\n+      }\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpRequest(): NSMutableURLRequest {\n+    return when (httpMethod) {\n+      HttpMethod.Get -> toHttpGetRequest()\n+      HttpMethod.Post -> toHttpPostRequest()\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpGetRequest(): NSMutableURLRequest {\n+    val urlComponents = NSURLComponents(uRL = serverUrl, resolvingAgainstBaseURL = false)\n+    urlComponents.queryItems = listOfNotNull(\n+        NSURLQueryItem(name = \"query\", value = document),\n+        NSURLQueryItem(name = \"operationName\", value = operationName),\n+        if (variables.isNotEmpty()) NSURLQueryItem(name = \"variables\", value = variables) else null\n+    )\n+    return NSMutableURLRequest.requestWithURL(urlComponents.URL!!).apply {\n+      setHTTPMethod(\"GET\")\n+      httpHeaders.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpPostRequest(): NSMutableURLRequest {\n+    return NSMutableURLRequest.requestWithURL(serverUrl).apply {\n+      val buffer = Buffer()\n+      JsonWriter.of(buffer)\n+          .beginObject()\n+          .name(\"operationName\").value(operationName)\n+          .name(\"query\").value(document)\n+          .name(\"variables\").value(variables)\n+          .endObject()\n+          .close()\n+      val postBody = buffer.readByteArray().toNSData()\n+\n+      setHTTPMethod(\"POST\")\n+      httpHeaders.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+      setHTTPBody(postBody)\n+    }\n+  }\n+\n+  private fun parse(\n+      data: NSData?,\n+      httpResponse: NSHTTPURLResponse,\n+      error: NSError?\n+  ): Result {\n+    if (error != null) return Result.Failure(\n+        ApolloException(\n+            message = \"Failed to execute GraphQL http network request\",\n+            error = ApolloError.Network,\n+            cause = IOException(error.localizedDescription)\n+        )\n+    )\n+\n+    val statusCode = httpResponse.statusCode.toInt()\n+    if (statusCode !in 200..299) return Result.Failure(\n+        ApolloException(\n+            message = \"Http request failed with status code `$statusCode`\",\n+            error = ApolloError.Network\n+        )\n+    )\n+\n+    if (data == null) return Result.Failure(\n+        ApolloException(\n+            message = \"Failed to parse GraphQL http network response: EOF\",\n+            error = ApolloError.Network\n+        )\n+    )\n+\n+    return Result.Success(data)\n+  }\n+\n+  sealed class Result {\n+    class Success(val data: NSData) : Result()\n+    class Failure(val cause: ApolloException) : Result()\n+  }\n+\n+  private fun ByteArray.toNSData(): NSData = NSMutableData().apply {\n+    if (isEmpty()) return@apply\n+    this@toNSData.usePinned {\n+      appendBytes(it.addressOf(0), size.convert())\n+    }\n+  }\n+\n+  @Suppress(\"NAME_SHADOWING\")\n+  private fun Result.dispatchOnMain(producerRef: COpaquePointer) {\n+    val producerWithResultRef = StableRef.create((producerRef to this).freeze())\n+    dispatch_async_f(\n+        queue = dispatch_get_main_queue(),\n+        context = producerWithResultRef.asCPointer(),", "originalCommit": "f1fac05dae8a5a2e02c12669c5a65bc743d44fa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4MDA0Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423480046", "bodyText": "context and queue here are properties of NetworkTransport, right\n\nnot sure I follow, queue and context  are named arguments for dispatch_async_f  C function.\ndispatch_get_main_queue() - gives access to main queue\nproducerWithResultRef.asCPointer() - just a pointer", "author": "sav007", "createdAt": "2020-05-12T06:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzOTMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEyNDUwNg==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r424124506", "bodyText": "ah ok-  I wasn't quite clear on the fact that they were named arguments for the function rather than vars declared elsewhere. Thanks!", "author": "designatednerd", "createdAt": "2020-05-13T01:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzOTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzOTcxMw==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423439713", "bodyText": "Again if producer is a property of NetworkTransport, it's worth looking into what happens if the instance gets deallocated before this gets called. This is where you see [weak self] sprinkled liberally around Swift code, I'm not entirely sure what the equivalent is with coroutines and flows.", "author": "designatednerd", "createdAt": "2020-05-12T03:25:20Z", "path": "apollo-runtime-kotlin/src/iosMain/kotlin/com/apollographql/apollo/network/ApolloHttpNetworkTransport.kt", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.apollographql.apollo.network\n+\n+import com.apollographql.apollo.ApolloError\n+import com.apollographql.apollo.ApolloException\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import kotlinx.cinterop.COpaquePointer\n+import kotlinx.cinterop.StableRef\n+import kotlinx.cinterop.addressOf\n+import kotlinx.cinterop.asStableRef\n+import kotlinx.cinterop.convert\n+import kotlinx.cinterop.staticCFunction\n+import kotlinx.cinterop.usePinned\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.channels.ProducerScope\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import okio.Buffer\n+import okio.IOException\n+import okio.toByteString\n+import platform.Foundation.NSData\n+import platform.Foundation.NSError\n+import platform.Foundation.NSHTTPURLResponse\n+import platform.Foundation.NSMutableData\n+import platform.Foundation.NSMutableURLRequest\n+import platform.Foundation.NSThread\n+import platform.Foundation.NSURL\n+import platform.Foundation.NSURLComponents\n+import platform.Foundation.NSURLQueryItem\n+import platform.Foundation.NSURLRequestReloadIgnoringCacheData\n+import platform.Foundation.NSURLResponse\n+import platform.Foundation.NSURLSession\n+import platform.Foundation.NSURLSessionConfiguration\n+import platform.Foundation.appendBytes\n+import platform.Foundation.dataTaskWithRequest\n+import platform.Foundation.setHTTPBody\n+import platform.Foundation.setHTTPMethod\n+import platform.Foundation.setValue\n+import platform.darwin.dispatch_async_f\n+import platform.darwin.dispatch_get_main_queue\n+import kotlin.native.concurrent.freeze\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi\n+actual class ApolloHttpNetworkTransport(\n+    private val serverUrl: NSURL,\n+    private val httpHeaders: Map<String, String>,\n+    private val httpMethod: HttpMethod,\n+    private val urlSession: NSURLSession\n+) : NetworkTransport {\n+\n+  actual constructor(\n+      serverUrl: String,\n+      httpHeaders: Map<String, String>,\n+      httpMethod: HttpMethod\n+  ) : this(\n+      serverUrl = NSURL(string = serverUrl),\n+      httpHeaders = httpHeaders,\n+      httpMethod = httpMethod,\n+      urlSession = NSURLSession.sessionWithConfiguration(NSURLSessionConfiguration.defaultSessionConfiguration())\n+  )\n+\n+  override fun execute(request: GraphQLRequest): Flow<GraphQLResponse> {\n+    return callbackFlow {\n+      assert(NSThread.isMainThread())\n+\n+      val producerRef = StableRef.create(this).asCPointer()\n+      val delegate = { httpData: NSData?, httpResponse: NSURLResponse?, error: NSError? ->\n+        initRuntimeIfNeeded()\n+        val response = parse(\n+            data = httpData,\n+            httpResponse = httpResponse as NSHTTPURLResponse,\n+            error = error\n+        )\n+        response.dispatchOnMain(producerRef)\n+      }\n+      val httpRequest = request.toHttpRequest()\n+      val task = urlSession.dataTaskWithRequest(httpRequest.freeze(), delegate.freeze()).apply {\n+        resume()\n+      }\n+      awaitClose {\n+        task.cancel()\n+      }\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpRequest(): NSMutableURLRequest {\n+    return when (httpMethod) {\n+      HttpMethod.Get -> toHttpGetRequest()\n+      HttpMethod.Post -> toHttpPostRequest()\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpGetRequest(): NSMutableURLRequest {\n+    val urlComponents = NSURLComponents(uRL = serverUrl, resolvingAgainstBaseURL = false)\n+    urlComponents.queryItems = listOfNotNull(\n+        NSURLQueryItem(name = \"query\", value = document),\n+        NSURLQueryItem(name = \"operationName\", value = operationName),\n+        if (variables.isNotEmpty()) NSURLQueryItem(name = \"variables\", value = variables) else null\n+    )\n+    return NSMutableURLRequest.requestWithURL(urlComponents.URL!!).apply {\n+      setHTTPMethod(\"GET\")\n+      httpHeaders.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpPostRequest(): NSMutableURLRequest {\n+    return NSMutableURLRequest.requestWithURL(serverUrl).apply {\n+      val buffer = Buffer()\n+      JsonWriter.of(buffer)\n+          .beginObject()\n+          .name(\"operationName\").value(operationName)\n+          .name(\"query\").value(document)\n+          .name(\"variables\").value(variables)\n+          .endObject()\n+          .close()\n+      val postBody = buffer.readByteArray().toNSData()\n+\n+      setHTTPMethod(\"POST\")\n+      httpHeaders.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+      setHTTPBody(postBody)\n+    }\n+  }\n+\n+  private fun parse(\n+      data: NSData?,\n+      httpResponse: NSHTTPURLResponse,\n+      error: NSError?\n+  ): Result {\n+    if (error != null) return Result.Failure(\n+        ApolloException(\n+            message = \"Failed to execute GraphQL http network request\",\n+            error = ApolloError.Network,\n+            cause = IOException(error.localizedDescription)\n+        )\n+    )\n+\n+    val statusCode = httpResponse.statusCode.toInt()\n+    if (statusCode !in 200..299) return Result.Failure(\n+        ApolloException(\n+            message = \"Http request failed with status code `$statusCode`\",\n+            error = ApolloError.Network\n+        )\n+    )\n+\n+    if (data == null) return Result.Failure(\n+        ApolloException(\n+            message = \"Failed to parse GraphQL http network response: EOF\",\n+            error = ApolloError.Network\n+        )\n+    )\n+\n+    return Result.Success(data)\n+  }\n+\n+  sealed class Result {\n+    class Success(val data: NSData) : Result()\n+    class Failure(val cause: ApolloException) : Result()\n+  }\n+\n+  private fun ByteArray.toNSData(): NSData = NSMutableData().apply {\n+    if (isEmpty()) return@apply\n+    this@toNSData.usePinned {\n+      appendBytes(it.addressOf(0), size.convert())\n+    }\n+  }\n+\n+  @Suppress(\"NAME_SHADOWING\")\n+  private fun Result.dispatchOnMain(producerRef: COpaquePointer) {\n+    val producerWithResultRef = StableRef.create((producerRef to this).freeze())\n+    dispatch_async_f(\n+        queue = dispatch_get_main_queue(),\n+        context = producerWithResultRef.asCPointer(),\n+        work = staticCFunction { ref ->\n+          val producerWithResultRef = ref!!.asStableRef<Pair<COpaquePointer, Result>>()\n+          val (producerPointer, result) = producerWithResultRef.get()\n+          producerWithResultRef.dispose()\n+\n+          val producerRef = producerPointer.asStableRef<ProducerScope<GraphQLResponse>>()\n+          val producer = producerRef.get()\n+          producerRef.dispose()\n+\n+          when (result) {\n+            is Result.Success -> {\n+              producer.offer(", "originalCommit": "f1fac05dae8a5a2e02c12669c5a65bc743d44fa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4MzkxNQ==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423483915", "bodyText": "We are safe here as producer  is not part of NetworkTransport, I mean NetworkTransport  doesn't hold reference.\nIt's a flow that holds reference, that returned to the user when he calls ApolloClient.query. KN doesn't have such concept as weak ref, but even if we keep reference for the producer, it's ok flow cancelation should take care of cleaning up.\nAnd any collecting is tied to the coroutine scope, so if user doesn't leak scope and proper cancel flow we are safe here.\nThe only I guess improvements we missing here is to check if producer still alive before offer:\nproducer.isActive\nproducer.offer(...", "author": "sav007", "createdAt": "2020-05-12T06:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzOTcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNDUzOQ==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423534539", "bodyText": "The only I guess improvements we missing here is to check if producer still alive before offer\n\nIsn't this the case already a few lines above ? (\n  \n    \n      apollo-android/apollo-runtime-kotlin/src/iosMain/kotlin/com/apollographql/apollo/network/ApolloHttpNetworkTransport.kt\n    \n    \n         Line 204\n      in\n      d464cf4\n    \n    \n    \n    \n\n        \n          \n           if (!producer.isActive) return \n        \n    \n  \n\n)\nAll in all, I think we should wrap all .offer() with runCaching {}. We've been hit by  Kotlin/kotlinx.coroutines#974 before.", "author": "martinbonnin", "createdAt": "2020-05-12T07:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzOTcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgwNzkwMg==", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423807902", "bodyText": "Isn't this the case already a few lines above\n\nI've just added this right away.\n\nAll in all, I think we should wrap all .offer() with runCaching {}\n\nRight, I was thinking that even checking for isActive won't enough as it could be RC. Will wrap into runCatching", "author": "sav007", "createdAt": "2020-05-12T15:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzOTcxMw=="}], "type": "inlineReview"}, {"oid": "294f0b9764dc07d92267f2996a73cd636e17ab00", "url": "https://github.com/apollographql/apollo-android/commit/294f0b9764dc07d92267f2996a73cd636e17ab00", "message": "iOS ApolloHttpNetworkTransportTest", "committedDate": "2020-05-12T05:52:02Z", "type": "commit"}, {"oid": "d464cf4fb0450f1f39716e2c4a41730dcf26f49b", "url": "https://github.com/apollographql/apollo-android/commit/d464cf4fb0450f1f39716e2c4a41730dcf26f49b", "message": "Check if flow is still active before dispatch", "committedDate": "2020-05-12T06:16:09Z", "type": "commit"}, {"oid": "03036dab549beb8602b5d613c6792baa93370f6e", "url": "https://github.com/apollographql/apollo-android/commit/03036dab549beb8602b5d613c6792baa93370f6e", "message": "Wrap dispatching GraphQL response with `runCatching`", "committedDate": "2020-05-12T15:18:11Z", "type": "commit"}, {"oid": "09b9f263f67b964de8e108a24e794ca99c4592bb", "url": "https://github.com/apollographql/apollo-android/commit/09b9f263f67b964de8e108a24e794ca99c4592bb", "message": "Address issue with `callbackFlow`. When http request is completed we call `producer#close` that cancels OkHttp call (via `awaitClose {call.cancel}`) that closes http response before we parse it.\n\nReplace callbackFlow with regular `flow` + `suspendCancellableCoroutine`\n\nFix Android sample\n\nRename `NetworkExecutor` to `NetworkInterceptor`", "committedDate": "2020-05-13T04:02:43Z", "type": "commit"}]}