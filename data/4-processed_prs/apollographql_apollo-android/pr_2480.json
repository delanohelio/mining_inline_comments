{"pr_number": 2480, "pr_title": "Add is disposed checking to single", "pr_createdAt": "2020-07-28T06:23:56Z", "pr_url": "https://github.com/apollographql/apollo-android/pull/2480", "timeline": [{"oid": "3b577e1213d343b524ff590951ae182e7d68bfdc", "url": "https://github.com/apollographql/apollo-android/commit/3b577e1213d343b524ff590951ae182e7d68bfdc", "message": "add is disposed checking", "committedDate": "2020-07-28T06:21:27Z", "type": "commit"}, {"oid": "39f9d94e5293238ca46c762dde8282a4230ced54", "url": "https://github.com/apollographql/apollo-android/commit/39f9d94e5293238ca46c762dde8282a4230ced54", "message": "remove the android plugin from integration tests", "committedDate": "2020-07-29T16:29:14Z", "type": "commit"}, {"oid": "87228d419c17ddd966735bca10afbc646e412bd0", "url": "https://github.com/apollographql/apollo-android/commit/87228d419c17ddd966735bca10afbc646e412bd0", "message": "remove unused import", "committedDate": "2020-07-29T16:29:41Z", "type": "commit"}, {"oid": "e847ad49f25dd609293c691714fa697527f28746", "url": "https://github.com/apollographql/apollo-android/commit/e847ad49f25dd609293c691714fa697527f28746", "message": "fix test without the android plugin", "committedDate": "2020-07-29T16:30:14Z", "type": "commit"}, {"oid": "c527cc647c920c993c5e0dc1e499f146c74e0441", "url": "https://github.com/apollographql/apollo-android/commit/c527cc647c920c993c5e0dc1e499f146c74e0441", "message": "cleanup buildSrc a bit and do not do network accesses during task\nconfigueration", "committedDate": "2020-07-29T16:30:39Z", "type": "commit"}, {"oid": "428b4ce17650bbbc7b34e58bd8a87eaf4fc63c3d", "url": "https://github.com/apollographql/apollo-android/commit/428b4ce17650bbbc7b34e58bd8a87eaf4fc63c3d", "message": "add a failing test case", "committedDate": "2020-07-29T16:30:49Z", "type": "commit"}, {"oid": "44fdceac0a0cc3abc06c68afe404af1103a99382", "url": "https://github.com/apollographql/apollo-android/commit/44fdceac0a0cc3abc06c68afe404af1103a99382", "message": "same test for RxJava3", "committedDate": "2020-07-29T16:30:59Z", "type": "commit"}, {"oid": "355a340fabcf873e7c6b982a7634151c3517af5b", "url": "https://github.com/apollographql/apollo-android/commit/355a340fabcf873e7c6b982a7634151c3517af5b", "message": "add comments", "committedDate": "2020-07-29T16:35:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzNTU1NA==", "url": "https://github.com/apollographql/apollo-android/pull/2480#discussion_r462435554", "bodyText": "This is the test that failed before the patch \u261d\ufe0f", "author": "martinbonnin", "createdAt": "2020-07-29T16:37:42Z", "path": "apollo-integration/src/test/java/com/apollographql/apollo/Rx2ApolloTest.kt", "diffHunk": "@@ -0,0 +1,256 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.Utils.immediateExecutor\n+import com.apollographql.apollo.Utils.immediateExecutorService\n+import com.apollographql.apollo.Utils.mockResponse\n+import com.apollographql.apollo.api.Input\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import com.apollographql.apollo.cache.normalized.lru.EvictionPolicy\n+import com.apollographql.apollo.cache.normalized.lru.LruNormalizedCacheFactory\n+import com.apollographql.apollo.cache.normalized.NormalizedCacheFactory\n+import com.apollographql.apollo.fetcher.ApolloResponseFetchers.NETWORK_ONLY\n+import com.apollographql.apollo.integration.normalizer.EpisodeHeroNameQuery\n+import com.apollographql.apollo.integration.normalizer.HeroAndFriendsNamesWithIDsQuery\n+import com.apollographql.apollo.integration.normalizer.type.Episode.EMPIRE\n+import com.apollographql.apollo.integration.normalizer.type.Episode.NEWHOPE\n+import com.apollographql.apollo.rx2.Rx2Apollo\n+import com.google.common.truth.Truth\n+import com.google.common.truth.Truth.assertThat\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.observers.TestObserver\n+import io.reactivex.plugins.RxJavaPlugins\n+import io.reactivex.schedulers.TestScheduler\n+import okhttp3.Dispatcher\n+import okhttp3.OkHttpClient\n+import okhttp3.mockwebserver.MockWebServer\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+\n+\n+class Rx2ApolloTest {\n+  private lateinit var apolloClient: ApolloClient\n+\n+  @get:Rule\n+  val server = MockWebServer()\n+\n+  @Before\n+  fun setup() {\n+    val okHttpClient = OkHttpClient.Builder()\n+        .dispatcher(Dispatcher(immediateExecutorService()))\n+        .build()\n+    apolloClient = ApolloClient.builder()\n+        .serverUrl(server.url(\"/\"))\n+        .dispatcher(immediateExecutor())\n+        .okHttpClient(okHttpClient)\n+        .normalizedCache(LruNormalizedCacheFactory(EvictionPolicy.NO_EVICTION), IdFieldCacheKeyResolver())\n+        .build()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun callProducesValue() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .test()\n+        .assertNoErrors()\n+        .assertComplete()\n+        .assertValue({ response ->\n+          assertThat(response.data()?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        })\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun callIsCanceledWhenDisposed() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<Response<EpisodeHeroNameQuery.Data>> = TestObserver<Response<EpisodeHeroNameQuery.Data>>()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .subscribeWith(testObserver)\n+    disposable.dispose()\n+    testObserver.assertComplete()\n+    Truth.assertThat(testObserver.isDisposed()).isTrue()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun prefetchCompletes() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    Rx2Apollo\n+        .from(apolloClient.prefetch(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .test()\n+        .assertNoErrors()\n+        .assertComplete()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun prefetchIsCanceledWhenDisposed() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.prefetch(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .observeOn(TestScheduler())\n+        .subscribeWith(testObserver)\n+    disposable.dispose()\n+    testObserver.assertNotComplete()\n+    Truth.assertThat(testObserver.isDisposed()).isTrue()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherUpdatedSameQueryDifferentResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_CHANGE))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE)))\n+        .responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    observer.assertValueCount(2)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+        .assertValueAt(1) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"Artoo\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherNotUpdatedSameQuerySameResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    observer\n+        .assertValueCount(1)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherUpdatedDifferentQueryDifferentResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(\"HeroAndFriendsNameWithIdsNameChange.json\"))\n+    apolloClient.query(HeroAndFriendsNamesWithIDsQuery(Input.fromNullable(NEWHOPE))).enqueue(null)\n+    observer\n+        .assertValueCount(2)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+        .assertValueAt(1) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"Artoo\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherNotCalledWhenCanceled() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    val scheduler = TestScheduler()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .observeOn(scheduler)\n+        .subscribeWith(testObserver)\n+    scheduler.triggerActions()\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_CHANGE))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    disposable.dispose()\n+    scheduler.triggerActions()\n+    testObserver\n+        .assertValueCount(1)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  fun disposingAnOperationDoesNotThrowUndeliverableException() {", "originalCommit": "355a340fabcf873e7c6b982a7634151c3517af5b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MDE0MQ==", "url": "https://github.com/apollographql/apollo-android/pull/2480#discussion_r462650141", "bodyText": "I've also used this approach to verify no error has been thrown.\nhttps://bryanherbst.com/2020/07/15/rxjava-uncaught-exception-tests/", "author": "s1ee", "createdAt": "2020-07-29T23:39:09Z", "path": "apollo-integration/src/test/java/com/apollographql/apollo/Rx2ApolloTest.kt", "diffHunk": "@@ -0,0 +1,256 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.Utils.immediateExecutor\n+import com.apollographql.apollo.Utils.immediateExecutorService\n+import com.apollographql.apollo.Utils.mockResponse\n+import com.apollographql.apollo.api.Input\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import com.apollographql.apollo.cache.normalized.lru.EvictionPolicy\n+import com.apollographql.apollo.cache.normalized.lru.LruNormalizedCacheFactory\n+import com.apollographql.apollo.cache.normalized.NormalizedCacheFactory\n+import com.apollographql.apollo.fetcher.ApolloResponseFetchers.NETWORK_ONLY\n+import com.apollographql.apollo.integration.normalizer.EpisodeHeroNameQuery\n+import com.apollographql.apollo.integration.normalizer.HeroAndFriendsNamesWithIDsQuery\n+import com.apollographql.apollo.integration.normalizer.type.Episode.EMPIRE\n+import com.apollographql.apollo.integration.normalizer.type.Episode.NEWHOPE\n+import com.apollographql.apollo.rx2.Rx2Apollo\n+import com.google.common.truth.Truth\n+import com.google.common.truth.Truth.assertThat\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.observers.TestObserver\n+import io.reactivex.plugins.RxJavaPlugins\n+import io.reactivex.schedulers.TestScheduler\n+import okhttp3.Dispatcher\n+import okhttp3.OkHttpClient\n+import okhttp3.mockwebserver.MockWebServer\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+\n+\n+class Rx2ApolloTest {\n+  private lateinit var apolloClient: ApolloClient\n+\n+  @get:Rule\n+  val server = MockWebServer()\n+\n+  @Before\n+  fun setup() {\n+    val okHttpClient = OkHttpClient.Builder()\n+        .dispatcher(Dispatcher(immediateExecutorService()))\n+        .build()\n+    apolloClient = ApolloClient.builder()\n+        .serverUrl(server.url(\"/\"))\n+        .dispatcher(immediateExecutor())\n+        .okHttpClient(okHttpClient)\n+        .normalizedCache(LruNormalizedCacheFactory(EvictionPolicy.NO_EVICTION), IdFieldCacheKeyResolver())\n+        .build()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun callProducesValue() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .test()\n+        .assertNoErrors()\n+        .assertComplete()\n+        .assertValue({ response ->\n+          assertThat(response.data()?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        })\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun callIsCanceledWhenDisposed() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<Response<EpisodeHeroNameQuery.Data>> = TestObserver<Response<EpisodeHeroNameQuery.Data>>()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .subscribeWith(testObserver)\n+    disposable.dispose()\n+    testObserver.assertComplete()\n+    Truth.assertThat(testObserver.isDisposed()).isTrue()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun prefetchCompletes() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    Rx2Apollo\n+        .from(apolloClient.prefetch(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .test()\n+        .assertNoErrors()\n+        .assertComplete()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun prefetchIsCanceledWhenDisposed() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.prefetch(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .observeOn(TestScheduler())\n+        .subscribeWith(testObserver)\n+    disposable.dispose()\n+    testObserver.assertNotComplete()\n+    Truth.assertThat(testObserver.isDisposed()).isTrue()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherUpdatedSameQueryDifferentResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_CHANGE))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE)))\n+        .responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    observer.assertValueCount(2)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+        .assertValueAt(1) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"Artoo\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherNotUpdatedSameQuerySameResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    observer\n+        .assertValueCount(1)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherUpdatedDifferentQueryDifferentResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(\"HeroAndFriendsNameWithIdsNameChange.json\"))\n+    apolloClient.query(HeroAndFriendsNamesWithIDsQuery(Input.fromNullable(NEWHOPE))).enqueue(null)\n+    observer\n+        .assertValueCount(2)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+        .assertValueAt(1) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"Artoo\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherNotCalledWhenCanceled() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    val scheduler = TestScheduler()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .observeOn(scheduler)\n+        .subscribeWith(testObserver)\n+    scheduler.triggerActions()\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_CHANGE))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    disposable.dispose()\n+    scheduler.triggerActions()\n+    testObserver\n+        .assertValueCount(1)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  fun disposingAnOperationDoesNotThrowUndeliverableException() {\n+    /*\n+     * A simple cache that will always throw errors\n+     */\n+    val cacheFactory = object: NormalizedCacheFactory<NormalizedCache>() {\n+      override fun create(recordFieldAdapter: RecordFieldJsonAdapter): NormalizedCache {\n+        return object: NormalizedCache() {\n+          override fun clearAll() {\n+            throw Exception(\"not implemented\")\n+          }\n+\n+          override fun loadRecord(key: String, cacheHeaders: CacheHeaders): Record? {\n+            throw Exception(\"not implemented\")\n+          }\n+\n+          override fun performMerge(apolloRecord: Record, oldRecord: Record?, cacheHeaders: CacheHeaders): Set<String> {\n+            throw Exception(\"not implemented\")\n+          }\n+\n+          override fun remove(cacheKey: CacheKey, cascade: Boolean): Boolean {\n+            throw Exception(\"not implemented\")\n+          }\n+        }\n+      }\n+    }\n+\n+    val apolloClient = ApolloClient.builder()\n+        .normalizedCache(cacheFactory)\n+        .serverUrl(\"https://unused/\")\n+        .build()\n+\n+\n+    val savedHandler = RxJavaPlugins.getErrorHandler()\n+\n+    var undeliverableException: Throwable? = null\n+    RxJavaPlugins.setErrorHandler {\n+      undeliverableException = it\n+    }\n+\n+    val operation = apolloClient.apolloStore.write(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE)), EpisodeHeroNameQuery.Data(EpisodeHeroNameQuery.Hero(\"\", \"\")))\n+    val testObserver = Rx2Apollo.from(operation)\n+        .test()\n+\n+    testObserver.dispose()\n+\n+    // Since there is no cancellation mechanism for the ApolloStoreOperation, the only way to see if an error is thrown is to wait here\n+    Thread.sleep(200)", "originalCommit": "355a340fabcf873e7c6b982a7634151c3517af5b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MDQwMQ==", "url": "https://github.com/apollographql/apollo-android/pull/2480#discussion_r462650401", "bodyText": "I totally forgot this library supports Rx3 as well \ud83e\udd26", "author": "s1ee", "createdAt": "2020-07-29T23:39:55Z", "path": "apollo-rx3-support/src/main/java/com/apollographql/apollo/rx3/Rx3Apollo.java", "diffHunk": "@@ -212,12 +212,16 @@ public void subscribe(final SingleEmitter<T> emitter) {\n         operation.enqueue(new ApolloStoreOperation.Callback<T>() {\n           @Override\n           public void onSuccess(T result) {\n-            emitter.onSuccess(result);\n+            if (!emitter.isDisposed()) {", "originalCommit": "355a340fabcf873e7c6b982a7634151c3517af5b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}