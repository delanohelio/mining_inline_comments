{"pr_number": 2257, "pr_title": "Fix issue with GraphQL document parse perf.", "pr_createdAt": "2020-05-08T19:37:56Z", "pr_url": "https://github.com/apollographql/apollo-android/pull/2257", "timeline": [{"oid": "8a83f99d446b4423b06aee1fe0d075ef7946de98", "url": "https://github.com/apollographql/apollo-android/commit/8a83f99d446b4423b06aee1fe0d075ef7946de98", "message": "Fix issue with GraphQL document parse perf.\n\nCloses https://github.com/apollographql/apollo-android/issues/2243", "committedDate": "2020-05-08T19:37:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzkxMA==", "url": "https://github.com/apollographql/apollo-android/pull/2257#discussion_r422417910", "bodyText": "Just curious: does this actually save time ?", "author": "martinbonnin", "createdAt": "2020-05-08T23:26:32Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/GraphQLDocumentParser.kt", "diffHunk": "@@ -645,29 +645,48 @@ class GraphQLDocumentParser(val schema: Schema, private val packageNameProvider:\n     }\n   }\n \n-  private fun Set<String>.usedSchemaTypes(exclude: Set<String> = emptySet()): Set<Schema.Type> {\n+  private fun Set<String>.usedSchemaTypes(): Set<Schema.Type> {\n     if (isEmpty()) {\n       return emptySet()\n     }\n \n-    val usedSchemaTypes = filter { ScalarType.forName(it) == null }\n+    val (scalarTypes, inputObjectTypes) = filter { ScalarType.forName(it) == null }\n         .map { schema[it] ?: throw GraphQLParseException(message = \"Undefined schema type `$it`\") }\n         .filter { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM || type.kind == Schema.Kind.INPUT_OBJECT }\n-        .toSet()\n+        .partition { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM }\n+        .let { (scalarTypes, inputObjectTypes) ->\n+          @Suppress(\"UNCHECKED_CAST\")\n+          scalarTypes to (inputObjectTypes as List<Schema.Type.InputObject>)\n+        }\n \n-    val inputObjectUsedTypes = usedSchemaTypes\n-        .mapNotNull { type -> type as? Schema.Type.InputObject }\n-        .flatMap { inputObject -> inputObject.usedTypes(exclude = this + exclude) }\n-        .toSet()\n-        .usedSchemaTypes(this + exclude)\n+    val usedTypes = (scalarTypes + inputObjectTypes).toMutableSet()\n+    val visitedTypeNames = scalarTypes.map { it.name }.toMutableSet()\n \n-    return usedSchemaTypes + inputObjectUsedTypes\n-  }\n+    val inputTypesToVisit = inputObjectTypes.toMutableList()\n+    while (inputTypesToVisit.isNotEmpty()) {\n+      val inputType = inputTypesToVisit.removeAt(inputTypesToVisit.lastIndex).also {\n+        usedTypes.add(it)\n+        visitedTypeNames.add(it.name)\n+      }\n+      val (nestedScalarTypes, nestedInputTypes) = inputType\n+          .inputFields\n+          .asSequence()", "originalCommit": "8a83f99d446b4423b06aee1fe0d075ef7946de98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDA3OA==", "url": "https://github.com/apollographql/apollo-android/pull/2257#discussion_r422420078", "bodyText": "No, it's just a small optimization probably even not noticeable.\nWhat really saves time is:\n\nrecursion replaced with loop\nwe were visiting the same input types over and over when traverse deep nested tree.", "author": "sav007", "createdAt": "2020-05-08T23:37:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODA0Mw==", "url": "https://github.com/apollographql/apollo-android/pull/2257#discussion_r422418043", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      .let { (scalaTypes, inputTypes) ->\n          \n          \n            \n                        @Suppress(\"UNCHECKED_CAST\")\n          \n          \n            \n                        scalaTypes.filter { ScalarType.forName(it.name) == null } to (inputTypes as List<Schema.Type.InputObject>)\n          \n          \n            \n                      .let { (scalarTypes, inputTypes) ->\n          \n          \n            \n                        @Suppress(\"UNCHECKED_CAST\")\n          \n          \n            \n                        scalarTypes.filter { ScalarType.forName(it.name) == null } to (inputTypes as List<Schema.Type.InputObject>)", "author": "martinbonnin", "createdAt": "2020-05-08T23:27:09Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/GraphQLDocumentParser.kt", "diffHunk": "@@ -645,29 +645,48 @@ class GraphQLDocumentParser(val schema: Schema, private val packageNameProvider:\n     }\n   }\n \n-  private fun Set<String>.usedSchemaTypes(exclude: Set<String> = emptySet()): Set<Schema.Type> {\n+  private fun Set<String>.usedSchemaTypes(): Set<Schema.Type> {\n     if (isEmpty()) {\n       return emptySet()\n     }\n \n-    val usedSchemaTypes = filter { ScalarType.forName(it) == null }\n+    val (scalarTypes, inputObjectTypes) = filter { ScalarType.forName(it) == null }\n         .map { schema[it] ?: throw GraphQLParseException(message = \"Undefined schema type `$it`\") }\n         .filter { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM || type.kind == Schema.Kind.INPUT_OBJECT }\n-        .toSet()\n+        .partition { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM }\n+        .let { (scalarTypes, inputObjectTypes) ->\n+          @Suppress(\"UNCHECKED_CAST\")\n+          scalarTypes to (inputObjectTypes as List<Schema.Type.InputObject>)\n+        }\n \n-    val inputObjectUsedTypes = usedSchemaTypes\n-        .mapNotNull { type -> type as? Schema.Type.InputObject }\n-        .flatMap { inputObject -> inputObject.usedTypes(exclude = this + exclude) }\n-        .toSet()\n-        .usedSchemaTypes(this + exclude)\n+    val usedTypes = (scalarTypes + inputObjectTypes).toMutableSet()\n+    val visitedTypeNames = scalarTypes.map { it.name }.toMutableSet()\n \n-    return usedSchemaTypes + inputObjectUsedTypes\n-  }\n+    val inputTypesToVisit = inputObjectTypes.toMutableList()\n+    while (inputTypesToVisit.isNotEmpty()) {\n+      val inputType = inputTypesToVisit.removeAt(inputTypesToVisit.lastIndex).also {\n+        usedTypes.add(it)\n+        visitedTypeNames.add(it.name)\n+      }\n+      val (nestedScalarTypes, nestedInputTypes) = inputType\n+          .inputFields\n+          .asSequence()\n+          .map { field -> field.type.rawType.name!! }\n+          .filterNot { type -> visitedTypeNames.contains(type) }\n+          .map { schema[it] ?: throw GraphQLParseException(message = \"Undefined schema type `$it`\") }\n+          .filter { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM || type.kind == Schema.Kind.INPUT_OBJECT }\n+          .partition { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM }\n+          .let { (scalaTypes, inputTypes) ->\n+            @Suppress(\"UNCHECKED_CAST\")\n+            scalaTypes.filter { ScalarType.forName(it.name) == null } to (inputTypes as List<Schema.Type.InputObject>)", "originalCommit": "8a83f99d446b4423b06aee1fe0d075ef7946de98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e7f260c3412ebeedc17438fd7757e88e6ace9b1b", "url": "https://github.com/apollographql/apollo-android/commit/e7f260c3412ebeedc17438fd7757e88e6ace9b1b", "message": "Update apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/GraphQLDocumentParser.kt\n\nCo-authored-by: Martin Bonnin <martin@mbonnin.net>", "committedDate": "2020-05-08T23:37:24Z", "type": "commit"}]}