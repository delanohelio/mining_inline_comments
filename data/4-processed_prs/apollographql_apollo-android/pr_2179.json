{"pr_number": 2179, "pr_title": "Add networking layer to KMP sample", "pr_createdAt": "2020-04-15T18:25:15Z", "pr_url": "https://github.com/apollographql/apollo-android/pull/2179", "timeline": [{"oid": "84094a563f370e1648e0811151058549af215d71", "url": "https://github.com/apollographql/apollo-android/commit/84094a563f370e1648e0811151058549af215d71", "message": "Add networking layer to KMP sample", "committedDate": "2020-04-15T18:24:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAwMDkxNQ==", "url": "https://github.com/apollographql/apollo-android/pull/2179#discussion_r411000915", "bodyText": "@sav007 Is there any specific reason to use DetachedObjectGraph here compared to just StableRef ? I was under the impression that the  advantage of DetachedObjectGraph was that it could work with unfrozen references by making sure no one else accesses them but since everything is frozen here, a StableRef would work just as well ?", "author": "martinbonnin", "createdAt": "2020-04-19T21:58:48Z", "path": "samples/multiplatform/kmp-lib-sample/src/iosMain/kotlin/com/apollographql/apollo/kmpsample/data/ApolloNetworkClient.kt", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.apollographql.apollo.kmpsample.data\n+\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import kotlinx.cinterop.ByteVar\n+import kotlinx.cinterop.COpaquePointer\n+import kotlinx.cinterop.CPointer\n+import kotlinx.cinterop.StableRef\n+import kotlinx.cinterop.addressOf\n+import kotlinx.cinterop.asStableRef\n+import kotlinx.cinterop.convert\n+import kotlinx.cinterop.get\n+import kotlinx.cinterop.reinterpret\n+import kotlinx.cinterop.staticCFunction\n+import kotlinx.cinterop.usePinned\n+import kotlinx.coroutines.CancellableContinuation\n+import kotlinx.coroutines.suspendCancellableCoroutine\n+import okio.Buffer\n+import okio.IOException\n+import platform.Foundation.NSData\n+import platform.Foundation.NSError\n+import platform.Foundation.NSHTTPURLResponse\n+import platform.Foundation.NSMutableData\n+import platform.Foundation.NSMutableURLRequest\n+import platform.Foundation.NSThread\n+import platform.Foundation.NSURL\n+import platform.Foundation.NSURLRequestReloadIgnoringCacheData\n+import platform.Foundation.NSURLResponse\n+import platform.Foundation.NSURLSession\n+import platform.Foundation.NSURLSessionConfiguration\n+import platform.Foundation.appendBytes\n+import platform.Foundation.dataTaskWithRequest\n+import platform.Foundation.setHTTPBody\n+import platform.Foundation.setHTTPMethod\n+import platform.Foundation.setValue\n+import platform.darwin.dispatch_async_f\n+import platform.darwin.dispatch_get_main_queue\n+import kotlin.coroutines.resume\n+import kotlin.coroutines.resumeWithException\n+import kotlin.native.concurrent.DetachedObjectGraph\n+import kotlin.native.concurrent.attach\n+import kotlin.native.concurrent.freeze\n+\n+internal class ApolloNetworkClient(\n+    private val url: String,\n+    private val headers: Map<String, String> = emptyMap()\n+) {\n+\n+  suspend fun <T : Operation.Data> Operation<*, T, *>.send(): Response<T> {\n+    val session = NSURLSession.sessionWithConfiguration(NSURLSessionConfiguration.defaultSessionConfiguration())\n+    val request = prepareRequest(url = url, headers = headers)\n+    return suspendCancellableCoroutine { continuation ->\n+      assert(NSThread.isMainThread())\n+      val continuationRef = StableRef.create(continuation).asCPointer()\n+      try {\n+        val delegate = { httpData: NSData?, httpResponse: NSURLResponse?, error: NSError? ->\n+          initRuntimeIfNeeded()\n+          val response = parse(\n+              data = httpData,\n+              httpResponse = httpResponse as NSHTTPURLResponse,\n+              error = error\n+          )\n+          response.dispatchOnMain(continuationRef)\n+        }\n+        session.dataTaskWithRequest(request.freeze(), delegate.freeze()).resume()\n+      } catch (e: Exception) {\n+        continuationRef.asStableRef<CancellableContinuation<Response<T>>>().dispose()\n+        continuation.resumeWithException(e)\n+      }\n+    }\n+  }\n+\n+  private fun <D : Operation.Data> Operation<D, *, *>.prepareRequest(\n+      url: String,\n+      headers: Map<String, String> = emptyMap()\n+  ): NSMutableURLRequest {\n+    return NSMutableURLRequest.requestWithURL(NSURL(string = url)).apply {\n+      setHTTPMethod(\"POST\")\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+      headers.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setValue(operationId(), forHTTPHeaderField = \"X-APOLLO-OPERATION-ID\")\n+      setValue(name().name(), forHTTPHeaderField = \"X-APOLLO-OPERATION-NAME\")\n+      setHTTPBody(composeRequestBody().toByteArray().toNSData())\n+    }\n+  }\n+\n+  private fun <T : Operation.Data> Operation<*, T, *>.parse(\n+      data: NSData?,\n+      httpResponse: NSHTTPURLResponse,\n+      error: NSError?\n+  ): Result<T> {\n+    if (error != null) {\n+      return Result.Failure(IOException(error.localizedDescription))\n+    }\n+\n+    return try {\n+      val statusCode = httpResponse.statusCode.toInt()\n+      if (statusCode in 200..299) {\n+        val payload = data!!.toByteArray()\n+        val response = parse(Buffer().write(payload))\n+        Result.Success(response)\n+      } else {\n+        Result.Failure(IOException(\"Network request failed, HTTP status code `$statusCode`\"))\n+      }\n+    } catch (e: Exception) {\n+      Result.Failure(e)\n+    }\n+  }\n+\n+  private sealed class Result<T : Operation.Data> {\n+    class Success<T : Operation.Data>(val value: Response<T>) : Result<T>()\n+    class Failure<T : Operation.Data>(val error: Exception) : Result<T>()\n+  }\n+\n+  private fun ByteArray.toNSData(): NSData = NSMutableData().apply {\n+    if (isEmpty()) return@apply\n+    this@toNSData.usePinned {\n+      appendBytes(it.addressOf(0), size.convert())\n+    }\n+  }\n+\n+  private fun NSData.toByteArray(): ByteArray {\n+    val data: CPointer<ByteVar> = bytes!!.reinterpret()\n+    return ByteArray(length.toInt()) { index -> data[index] }\n+  }\n+\n+  @Suppress(\"NAME_SHADOWING\")\n+  private fun <T : Operation.Data> Result<T>.dispatchOnMain(continuationRef: COpaquePointer) {\n+    dispatch_async_f(\n+        queue = dispatch_get_main_queue(),\n+        context = DetachedObjectGraph { (continuationRef to this).freeze() }.asCPointer(),", "originalCommit": "84094a563f370e1648e0811151058549af215d71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAwMzkzOQ==", "url": "https://github.com/apollographql/apollo-android/pull/2179#discussion_r411003939", "bodyText": "I think you are right here, have to double-check but looks like no need for detached object wrapper. Will check", "author": "sav007", "createdAt": "2020-04-19T22:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAwMDkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAwOTk5Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2179#discussion_r411009996", "bodyText": "@Suppress(\"NAME_SHADOWING\")\n  private fun <T : Operation.Data> Result<T>.dispatchOnMain(continuationRef: COpaquePointer) {\n    val continuationWithResultRef = StableRef.create((continuationRef to this).freeze())\n    dispatch_async_f(\n        queue = dispatch_get_main_queue(),\n        context = continuationWithResultRef.asCPointer(),\n        work = staticCFunction { ref ->\n          val continuationWithResultRef = ref!!.asStableRef<Pair<COpaquePointer, Result<T>>>()\n          val (continuationPointer, result) = continuationWithResultRef.get()\n          continuationWithResultRef.dispose()\n\n          val continuationRef = continuationPointer.asStableRef<CancellableContinuation<Response<T>>>()\n          val continuation = continuationRef.get()\n          continuationRef.dispose()\n\n          when (result) {\n            is Result.Success -> continuation.resume(result.value)\n            is Result.Failure -> continuation.resumeWithException(result.error)\n          }\n        }\n    )\n  }\n\nThis works perfectly. Will open PR.", "author": "sav007", "createdAt": "2020-04-19T22:54:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAwMDkxNQ=="}], "type": "inlineReview"}]}