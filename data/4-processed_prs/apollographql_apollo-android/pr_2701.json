{"pr_number": 2701, "pr_title": "Rework backend compiler", "pr_createdAt": "2020-10-26T03:07:48Z", "pr_url": "https://github.com/apollographql/apollo-android/pull/2701", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI4NjkzMg==", "url": "https://github.com/apollographql/apollo-android/pull/2701#discussion_r530286932", "bodyText": "Yay for better distinction between compiler and code generator \ud83d\ude4c", "author": "martinbonnin", "createdAt": "2020-11-25T11:01:52Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/GraphQLCompiler.kt", "diffHunk": "@@ -98,8 +98,8 @@ class GraphQLCompiler(val logger: Logger = NoOpLogger) {\n     }.map { it.name } + ScalarType.ID.name)\n         .supportedTypeMap(userCustomTypesMap, generateKotlinModels)\n \n-    GraphQLKompiler(\n-        ir = ir,\n+    GraphQLCodeGenerator(", "originalCommit": "d1904518827d9f5c87d771f7544356e882181d86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI4OTUxNA==", "url": "https://github.com/apollographql/apollo-android/pull/2701#discussion_r530289514", "bodyText": "Can we add a top level Kdoc block to explain what the backend Ast is? I'd expect it to be very close to the Kotlin language but the Operation and Fragment below let me think it's not?", "author": "martinbonnin", "createdAt": "2020-11-25T11:05:56Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/backend/ast/Ast.kt", "diffHunk": "@@ -1,6 +1,6 @@\n-package com.apollographql.apollo.compiler.ast\n+package com.apollographql.apollo.compiler.backend.ast\n \n-internal typealias ObjectTypeContainer = Map<CodeGenerationAst.TypeRef, CodeGenerationAst.ObjectType>\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema\n \n internal typealias CustomTypes = Map<String, CodeGenerationAst.CustomType>\n ", "originalCommit": "d1904518827d9f5c87d771f7544356e882181d86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY4MDE1Mg==", "url": "https://github.com/apollographql/apollo-android/pull/2701#discussion_r530680152", "bodyText": "I will think if we can remove AST and directly generate code from BackendIR", "author": "sav007", "createdAt": "2020-11-25T22:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI4OTUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5MjA0Mg==", "url": "https://github.com/apollographql/apollo-android/pull/2701#discussion_r530692042", "bodyText": "Actually I will take this back. We do some BackendIr lowering here so we should keep it.", "author": "sav007", "createdAt": "2020-11-25T23:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI4OTUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI5MjUxNQ==", "url": "https://github.com/apollographql/apollo-android/pull/2701#discussion_r530292515", "bodyText": "It looks like this is only used in ObjectType.primaryConstructorSpec, can we use introspectionSchemaType.rawType.name instead ? That'll make the Ast more independant of the introspection.", "author": "martinbonnin", "createdAt": "2020-11-25T11:10:50Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/backend/ast/Ast.kt", "diffHunk": "@@ -27,37 +27,32 @@ internal data class CodeGenerationAst(\n       val operationId: String,\n       val queryDocument: String,\n       val variables: List<InputField>,\n-      val dataType: OperationDataType,\n-      val filePath: String\n+      val dataType: ObjectType,\n   ) {\n     enum class Type {\n       QUERY, MUTATION, SUBSCRIPTION\n     }\n   }\n \n-  data class OperationDataType(\n-      val rootType: TypeRef,\n-      val nestedTypes: ObjectTypeContainer\n-  )\n-\n   data class FragmentType(\n+      val name: String,\n       val graphqlName: String,\n-      val rootType: TypeRef,\n-      val defaultImplementation: TypeRef,\n-      val nestedTypes: ObjectTypeContainer,\n+      val description: String,\n+      val interfaceType: ObjectType,\n+      val implementationType: ObjectType,\n       val fragmentDefinition: String\n   )\n \n   data class ObjectType(\n       val name: String,\n       val description: String,\n-      val deprecated: Boolean,\n-      val deprecationReason: String,\n+      val deprecationReason: String?,\n       val fields: List<Field>,\n+      val nestedObjects: List<ObjectType>,\n       val implements: Set<TypeRef>,\n-      val schemaType: String?,\n       val kind: Kind,\n-      val typeRef: TypeRef\n+      val typeRef: TypeRef,\n+      val introspectionSchemaType: IntrospectionSchema.TypeRef?,", "originalCommit": "d1904518827d9f5c87d771f7544356e882181d86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI5MzAyOA==", "url": "https://github.com/apollographql/apollo-android/pull/2701#discussion_r530293028", "bodyText": "\ud83d\udc4d", "author": "martinbonnin", "createdAt": "2020-11-25T11:11:44Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/backend/ast/Ast.kt", "diffHunk": "@@ -82,8 +77,7 @@ internal data class CodeGenerationAst(\n       val schemaName: String,\n       val type: FieldType,\n       val description: String,\n-      val deprecated: Boolean,\n-      val deprecationReason: String,\n+      val deprecationReason: String?,", "originalCommit": "d1904518827d9f5c87d771f7544356e882181d86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMyNTQ3Nw==", "url": "https://github.com/apollographql/apollo-android/pull/2701#discussion_r530325477", "bodyText": "Shouldn't there be a list of named fragments there as well? Or do you map the named fragments to inline fragments since they're quite similar?", "author": "martinbonnin", "createdAt": "2020-11-25T12:08:12Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/backend/ir/BackendIr.kt", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.apollographql.apollo.compiler.backend.ir\n+\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema\n+\n+internal data class SelectionKey(\n+    val root: String,\n+    val keys: List<String>,\n+    val type: Type,\n+) {\n+  operator fun plus(name: String): SelectionKey {\n+    return this.copy(\n+        keys = this.keys + name\n+    )\n+  }\n+\n+  enum class Type {\n+    Query, Fragment\n+  }\n+}\n+\n+internal data class BackendIr(\n+    val operations: List<Operation>,\n+    val fragments: List<NamedFragment>,\n+    val typeDeclarations: List<IntrospectionSchema.TypeRef>,\n+    val typesPackageName: String,\n+    val fragmentsPackageName: String,\n+) {\n+  data class Operation(\n+      val name: String,\n+      val operationName: String,\n+      val targetPackageName: String,\n+      val operationType: IntrospectionSchema.TypeRef,\n+      val comment: String,\n+      val variables: List<Variable>,\n+      val definition: String,\n+      val dataField: Field,\n+  )\n+\n+  data class Variable(\n+      val name: String,\n+      val type: IntrospectionSchema.TypeRef,\n+  )\n+\n+  data class Field(\n+      val name: String,\n+      val alias: String?,\n+      val type: IntrospectionSchema.TypeRef,\n+      val args: List<Argument>,\n+      val fields: List<Field>,\n+      val fragments: List<InlineFragment>,\n+      val conditions: List<Condition>,\n+      val description: String,\n+      val deprecationReason: String?,\n+      val selectionKeys: Set<SelectionKey>,", "originalCommit": "d1904518827d9f5c87d771f7544356e882181d86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMzODc5Mg==", "url": "https://github.com/apollographql/apollo-android/pull/2701#discussion_r530338792", "bodyText": "This feels weird. I'd expect the arguments to be the same at this point. Should we throw if they're not?", "author": "martinbonnin", "createdAt": "2020-11-25T12:31:46Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/backend/ir/FieldMergeUtils.kt", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.apollographql.apollo.compiler.backend.ir\n+\n+internal object FieldMergeUtils {\n+\n+  fun List<BackendIr.Field>.mergeFields(otherFields: List<BackendIr.Field>): List<BackendIr.Field> {\n+    val fieldsToAdd = otherFields.toMutableList()\n+    return this.map { field ->\n+      val fieldToMergeIndex = fieldsToAdd.indexOfFirst { otherField -> otherField.responseName == field.responseName }\n+      val fieldToMerge = if (fieldToMergeIndex >= 0) fieldsToAdd.removeAt(fieldToMergeIndex) else null\n+      if (fieldToMerge == null) {\n+        field\n+      } else {\n+        field.merge(fieldToMerge)\n+      }\n+    } + fieldsToAdd\n+  }\n+\n+  private fun BackendIr.Field.merge(otherField: BackendIr.Field): BackendIr.Field {\n+    val mergedFields = this.fields.mergeFields(otherField.fields)\n+    return this.copy(\n+        args = (this.args + otherField.args).distinct(),", "originalCommit": "d1904518827d9f5c87d771f7544356e882181d86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NzA1OA==", "url": "https://github.com/apollographql/apollo-android/pull/2701#discussion_r530487058", "bodyText": "At some point we need to restrict the possible types to the type in scope. With the following scenario:\ninterface Being\ninterface HasLegs\n\ntype Human implements Being, HasLegs\ntype Droid implements Being\ntype Table implements HasLegs\n\nquery {\n  hero {\n    ... on HasLegs\n  }\n}\n\nWe will end up taking Table in consideration in the fromResponse.when statement", "author": "martinbonnin", "createdAt": "2020-11-25T16:08:21Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/backend/ir/BackendIrBuilder.kt", "diffHunk": "@@ -0,0 +1,658 @@\n+package com.apollographql.apollo.compiler.backend.ir\n+\n+import com.apollographql.apollo.compiler.backend.ir.FieldMergeUtils.mergeFields\n+import com.apollographql.apollo.compiler.backend.ir.SelectionKeyUtils.addFieldSelectionKey\n+import com.apollographql.apollo.compiler.backend.ir.SelectionKeyUtils.addFieldSelectionKeys\n+//import com.apollographql.apollo.compiler.backend.ir.FieldMerger.mergeParentFields\n+import com.apollographql.apollo.compiler.ir.CodeGenerationIR\n+import com.apollographql.apollo.compiler.ir.Condition\n+import com.apollographql.apollo.compiler.ir.Field\n+import com.apollographql.apollo.compiler.ir.Fragment\n+import com.apollographql.apollo.compiler.ir.FragmentRef\n+import com.apollographql.apollo.compiler.ir.InlineFragment\n+import com.apollographql.apollo.compiler.ir.Operation\n+import com.apollographql.apollo.compiler.ir.SourceLocation\n+import com.apollographql.apollo.compiler.ir.TypeDeclaration\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema\n+import com.apollographql.apollo.compiler.parser.introspection.resolveType\n+\n+internal class BackendIrBuilder private constructor(\n+    private val schema: IntrospectionSchema,\n+    private val namedFragments: List<Fragment>,\n+    private val useSemanticNaming: Boolean,\n+) {\n+  companion object {\n+\n+    fun CodeGenerationIR.buildBackendIr(\n+        schema: IntrospectionSchema,\n+        useSemanticNaming: Boolean,\n+    ): BackendIr {\n+      return BackendIrBuilder(\n+          schema = schema,\n+          namedFragments = this.fragments,\n+          useSemanticNaming = useSemanticNaming,\n+      ).buildBackendIR(this)\n+    }\n+  }\n+\n+  private fun buildBackendIR(frontendIr: CodeGenerationIR): BackendIr {\n+    return BackendIr(\n+        operations = frontendIr.operations.map { operation ->\n+          operation.buildBackendIrOperation()\n+        },\n+        fragments = frontendIr.fragments\n+            .filter { fragment ->\n+              fragment.fragmentName in frontendIr.fragmentsToGenerate\n+            }\n+            .map { fragment ->\n+              fragment.buildBackendIrNamedFragment()\n+            },\n+        typeDeclarations = frontendIr.typeDeclarations\n+            .filter { typeDeclaration ->\n+              when (typeDeclaration.kind) {\n+                TypeDeclaration.KIND_ENUM -> typeDeclaration.name in frontendIr.enumsToGenerate\n+                TypeDeclaration.KIND_INPUT_OBJECT_TYPE -> typeDeclaration.name in frontendIr.inputObjectsToGenerate\n+                else -> true\n+              }\n+            }\n+            .map { typeDeclaration ->\n+              schema.resolveType(typeDeclaration.name)\n+            },\n+        typesPackageName = frontendIr.typesPackageName,\n+        fragmentsPackageName = frontendIr.fragmentsPackageName,\n+    )\n+  }\n+\n+  private fun Operation.buildBackendIrOperation(): BackendIr.Operation {\n+    val normalizedName = this.normalizeOperationName()\n+    val typeRef = this.operationTypeRef\n+    val selectionKey = SelectionKey(\n+        root = normalizedName,\n+        keys = listOf(normalizedName, \"data\"),\n+        type = SelectionKey.Type.Query,\n+    )\n+    val dataField = Field(\n+        fieldName = \"data\",\n+        responseName = \"data\",\n+        type = typeRef.name!!,\n+        fields = this.fields,\n+        inlineFragments = this.inlineFragments,\n+        fragmentRefs = this.fragments,\n+        typeDescription = \"\",\n+        sourceLocation = SourceLocation.UNKNOWN\n+    ).buildBackendIrField(\n+        selectionKey = selectionKey,\n+        generateFragmentImplementations = true,\n+    )\n+    val variables = this.variables.map { variable ->\n+      BackendIr.Variable(\n+          name = variable.name,\n+          type = schema.resolveType(variable.type)\n+      )\n+    }\n+    return BackendIr.Operation(\n+        name = normalizedName,\n+        operationName = this.operationName,\n+        targetPackageName = this.packageName,\n+        operationType = typeRef,\n+        comment = this.description,\n+        variables = variables,\n+        definition = this.sourceWithFragments,\n+        dataField = dataField,\n+    )\n+  }\n+\n+  private val Operation.operationTypeRef: IntrospectionSchema.TypeRef\n+    get() {\n+      return when {\n+        this.isQuery() -> schema.resolveType(schema.queryType)\n+        this.isMutation() -> schema.resolveType(schema.queryType)\n+        this.isSubscription() -> schema.resolveType(schema.queryType)\n+        else -> throw IllegalStateException(\"Unsupported GraphQL operation type: $operationType\")\n+      }\n+    }\n+\n+  private fun Operation.normalizeOperationName(): String {\n+    fun normalizeOperationName(\n+        useSemanticNaming: Boolean,\n+        operationNameSuffix: String,\n+    ): String {\n+      return if (useSemanticNaming && !operationName.endsWith(operationNameSuffix)) {\n+        operationName.capitalize() + operationNameSuffix\n+      } else {\n+        operationName.capitalize()\n+      }\n+    }\n+    return when {\n+      this.isQuery() -> normalizeOperationName(useSemanticNaming, \"Query\")\n+      this.isMutation() -> normalizeOperationName(useSemanticNaming, \"Mutation\")\n+      this.isSubscription() -> normalizeOperationName(useSemanticNaming, \"Subscription\")\n+      else -> throw IllegalStateException(\"Unsupported GraphQL operation type: $operationType\")\n+    }\n+  }\n+\n+  private fun Field.buildBackendIrField(\n+      selectionKey: SelectionKey,\n+      generateFragmentImplementations: Boolean,\n+  ): BackendIr.Field {\n+    val selectionSet = this.fields.buildBackendIrFields(\n+        selectionKey = selectionKey,\n+        generateFragmentImplementations = generateFragmentImplementations,\n+    )\n+    val fragments = this.buildBackendIrFragments(\n+        selectionKey = selectionKey,\n+        selectionSet = selectionSet,\n+        generateFragmentImplementations = generateFragmentImplementations,\n+    )\n+    val arguments = this.args.map { argument ->\n+      BackendIr.Argument(\n+          name = argument.name,\n+          value = argument.value,\n+          type = schema.resolveType(this.type)\n+      )\n+    }\n+    val conditions = this.conditions.map { condition ->\n+      BackendIr.Condition(\n+          kind = condition.kind,\n+          variableName = condition.variableName,\n+          inverted = condition.inverted,\n+          type = BackendIr.Condition.Type.Boolean\n+      )\n+    }\n+    return BackendIr.Field(\n+        name = this.fieldName,\n+        alias = this.responseName.takeIf { this.fieldName != this.responseName },\n+        type = schema.resolveType(this.type),\n+        args = arguments,\n+        fields = selectionSet,\n+        fragments = fragments,\n+        deprecationReason = this.deprecationReason.takeIf { this.isDeprecated },\n+        description = this.description,\n+        conditions = conditions,\n+        selectionKeys = setOf(selectionKey),\n+    )\n+  }\n+\n+  private fun List<Field>.buildBackendIrFields(\n+      selectionKey: SelectionKey,\n+      generateFragmentImplementations: Boolean,\n+  ): List<BackendIr.Field> {\n+    return this.map { field ->\n+      field.buildBackendIrField(\n+          selectionKey = selectionKey + field.responseName,\n+          generateFragmentImplementations = generateFragmentImplementations\n+      )\n+    }\n+  }\n+\n+  private fun Fragment.buildBackendIrNamedFragment(): BackendIr.NamedFragment {\n+    val selectionSet = buildSelectionSet(\n+        rootSelectionKey = SelectionKey(\n+            root = this.fragmentName,\n+            keys = listOf(this.fragmentName),\n+            type = SelectionKey.Type.Fragment,\n+        ),\n+        generateFragmentImplementations = false,\n+    )\n+    val defaultSelectionSet = buildSelectionSet(\n+        rootSelectionKey = SelectionKey(\n+            root = this.fragmentName,\n+            keys = listOf(this.fragmentName, \"DefaultImpl\"),\n+            type = SelectionKey.Type.Fragment,\n+        ),\n+        generateFragmentImplementations = true,\n+    )\n+    return BackendIr.NamedFragment(\n+        name = this.fragmentName,\n+        source = this.source,\n+        comment = this.description,\n+        selectionSet = selectionSet,\n+        defaultSelectionSet = defaultSelectionSet,\n+    )\n+  }\n+\n+  private fun Fragment.buildSelectionSet(\n+      rootSelectionKey: SelectionKey,\n+      generateFragmentImplementations: Boolean,\n+  ): BackendIr.NamedFragment.SelectionSet {\n+    val dataField = Field(\n+        responseName = \"\",\n+        fieldName = \"\",\n+        type = this.typeCondition,\n+        typeDescription = \"\",\n+        fields = this.fields,\n+        fragmentRefs = this.fragmentRefs,\n+        inlineFragments = this.inlineFragments,\n+        sourceLocation = SourceLocation.UNKNOWN,\n+    ).buildBackendIrField(\n+        selectionKey = rootSelectionKey,\n+        generateFragmentImplementations = generateFragmentImplementations,\n+    )\n+    return BackendIr.NamedFragment.SelectionSet(\n+        fields = dataField.fields,\n+        fragments = dataField.fragments,\n+        typeCondition = schema.resolveType(this.typeCondition),\n+        possibleTypes = this.possibleTypes.map { possibleType -> schema.resolveType(possibleType) },\n+        selectionKeys = dataField.selectionKeys\n+    )\n+  }\n+\n+  // builds fragment interfaces and implementations for given field\n+  private fun Field.buildBackendIrFragments(\n+      selectionKey: SelectionKey,\n+      selectionSet: List<BackendIr.Field>,\n+      generateFragmentImplementations: Boolean,\n+  ): List<BackendIr.InlineFragment> {\n+    // build interfaces for the fragments\n+    val fragmentInterfaces = this.buildBackendIrFragmentInterfaces(\n+        selectionKey = selectionKey,\n+        selectionSet = selectionSet,\n+    )\n+\n+    // build implementations for the fragments if we allowed to do so\n+    val fragmentImplementations = if (generateFragmentImplementations) {\n+      this.buildFragmentImplementations(\n+          selectionKey = selectionKey,\n+          selectionSet = selectionSet,\n+      )\n+    } else emptyList()\n+\n+    return fragmentInterfaces + fragmentImplementations\n+  }\n+\n+  private fun Field.buildBackendIrFragmentInterfaces(\n+      selectionKey: SelectionKey,\n+      selectionSet: List<BackendIr.Field>,\n+  ): List<BackendIr.InlineFragment.Interface> {\n+    // build all defined fragment interfaces including nested ones\n+    val fragments = this.buildGenericFragments(\n+        selectionKey = selectionKey,\n+        selectionSet = selectionSet,\n+        generateFragmentImplementations = false\n+    )\n+        // flatten fragments structure (remove nesting)\n+        .flatten()\n+\n+    // we might get fragments defined with the same type condition - group them\n+    val groupedFragments = fragments.groupBy { fragment -> fragment.name }\n+\n+    // merge fragments with the same type condition into one interface\n+    return groupedFragments.map { (_, fragments) ->\n+      val selectionSet = fragments.fold(emptyList<BackendIr.Field>()) { acc, fragment ->\n+        acc.mergeFields(fragment.selectionSet)\n+      }\n+      val selectionsKeys = fragments.fold(emptySet<SelectionKey>()) { acc, fragment ->\n+        acc.plus(fragment.selectionKeys)\n+      }\n+      BackendIr.InlineFragment.Interface(\n+          name = fragments.first().name,\n+          fields = selectionSet,\n+          selectionKeys = selectionsKeys,\n+          possibleTypes = fragments.first().possibleTypes,\n+          description = fragments.first().description,\n+          typeCondition = fragments.first().typeCondition,\n+      )\n+    }\n+  }\n+\n+  private fun Field.buildFragmentImplementations(\n+      selectionKey: SelectionKey,\n+      selectionSet: List<BackendIr.Field>,\n+  ): List<BackendIr.InlineFragment.Implementation> {\n+    // build all defined fragment implementations including nested ones\n+    val fragments = this.buildGenericFragments(\n+        selectionKey = selectionKey,\n+        selectionSet = selectionSet,\n+        generateFragmentImplementations = true\n+    )\n+        // flatten fragments structure (remove nesting)\n+        .flatten()\n+\n+    // we might get fragments that intersects by possible type - group them\n+    val groupedFragments = fragments.groupFragmentsByPossibleTypes()\n+\n+    // merge fragments with possible types intersection into one implementation\n+    return groupedFragments.map { (fragments, possibleTypes) ->\n+      val fragmentName = fragments.formatFragmentImplementationName(\n+          postfix = this.responseName\n+      )\n+      val selectionSet = fragments.fold(emptyList<BackendIr.Field>()) { acc, fragment ->\n+        acc.mergeFields(fragment.selectionSet)\n+      }\n+      val selectionsKeys = fragments.fold(emptySet<SelectionKey>()) { acc, fragment ->\n+        acc.plus(fragment.selectionKeys)\n+      }\n+      val description = if (fragments.size == 1) {\n+        fragments.first().description\n+      } else null\n+\n+      BackendIr.InlineFragment.Implementation(\n+          name = fragmentName,\n+          fields = selectionSet,\n+          possibleTypes = possibleTypes,\n+          selectionKeys = selectionsKeys,\n+          description = description,\n+      )\n+    }\n+  }\n+\n+  private fun List<GenericFragment>.flatten(): List<GenericFragment> {\n+    return this.flatMap { fragment ->\n+      listOf(fragment.copy(nestedFragments = emptyList())) + fragment.nestedFragments.flatten()\n+    }\n+  }\n+\n+  private fun Field.buildGenericFragments(\n+      selectionKey: SelectionKey,\n+      selectionSet: List<BackendIr.Field>,\n+      generateFragmentImplementations: Boolean,\n+  ): List<GenericFragment> {\n+    // build generic fragments from inline fragments\n+    val inlineFragments = this.inlineFragments.map { inlineFragment ->\n+      inlineFragment.buildGenericFragment(\n+          parentSelectionKey = selectionKey,\n+          parentSelectionSet = selectionSet,\n+          parentNamedFragmentSelectionKeys = emptySet(),\n+          generateFragmentImplementations = generateFragmentImplementations\n+      )\n+    }\n+    // build generic fragments from named fragments\n+    val namedFragments = this.fragmentRefs\n+        .map { fragmentRef -> lookupForNamedFragment(fragmentRef) }\n+        .map { namedFragment ->\n+          namedFragment.buildGenericFragment(\n+              parentSelectionKey = selectionKey,\n+              parentSelectionSet = selectionSet,\n+              parentNamedFragmentSelectionKeys = emptySet(),\n+              generateFragmentImplementations = generateFragmentImplementations\n+          )\n+        }\n+    return inlineFragments + namedFragments\n+  }\n+\n+  private fun InlineFragment.buildGenericFragment(\n+      parentSelectionKey: SelectionKey,\n+      parentSelectionSet: List<BackendIr.Field>,\n+      parentNamedFragmentSelectionKeys: Set<SelectionKey>,\n+      generateFragmentImplementations: Boolean,\n+  ): GenericFragment {\n+    return buildGenericFragment(\n+        fragmentTypeCondition = schema.resolveType(this.typeCondition),\n+        fragmentFields = this.fields,\n+        fragmentPossibleTypes = this.possibleTypes.map { possibleType -> schema.resolveType(possibleType) },\n+        fragmentDescription = this.description,\n+        fragmentConditions = this.conditions,\n+        namedFragmentSelectionKey = null,\n+        nestedInlineFragments = this.inlineFragments,\n+        nestedNamedFragments = this.fragments.map { fragmentRef -> lookupForNamedFragment(fragmentRef) },\n+        parentSelectionKey = parentSelectionKey,\n+        parentSelectionSet = parentSelectionSet,\n+        parentNamedFragmentSelectionKeys = parentNamedFragmentSelectionKeys,\n+        generateFragmentImplementations = generateFragmentImplementations\n+    )\n+  }\n+\n+  private fun Fragment.buildGenericFragment(\n+      parentSelectionKey: SelectionKey,\n+      parentSelectionSet: List<BackendIr.Field>,\n+      parentNamedFragmentSelectionKeys: Set<SelectionKey>,\n+      generateFragmentImplementations: Boolean,\n+  ): GenericFragment {\n+    return buildGenericFragment(\n+        fragmentTypeCondition = schema.resolveType(this.typeCondition),\n+        fragmentFields = this.fields,\n+        fragmentPossibleTypes = this.possibleTypes.map { possibleType -> schema.resolveType(possibleType) },\n+        fragmentDescription = this.description,\n+        fragmentConditions = emptyList(),\n+        namedFragmentSelectionKey = SelectionKey(\n+            root = this.fragmentName.capitalize(),\n+            keys = listOf(this.fragmentName.capitalize()),\n+            type = SelectionKey.Type.Fragment,\n+        ),\n+        nestedInlineFragments = this.inlineFragments,\n+        nestedNamedFragments = this.fragmentRefs.map { fragmentRef -> lookupForNamedFragment(fragmentRef) },\n+        parentSelectionKey = parentSelectionKey,\n+        parentSelectionSet = parentSelectionSet,\n+        parentNamedFragmentSelectionKeys = parentNamedFragmentSelectionKeys,\n+        generateFragmentImplementations = generateFragmentImplementations\n+    )\n+  }\n+\n+  /**\n+   * Build generic fragment with merged parent fields and any nested fragments.\n+   *\n+   * case 1:\n+   * ```\n+   * query TestQuery {\n+   *  hero {\n+   *    name\n+   *    ... on Human { <--- imagine we are building this fragment\n+   *      height\n+   *    }\n+   *  }\n+   *}\n+   * ```\n+   * we must carry down field `name` into built fragment for `Human`\n+   *\n+   * case 2:\n+   * ```\n+   * fragment HeroDetails on Character {\n+   *  id\n+   *  friends {\n+   *    name\n+   *  }\n+   *  ... on Droid { <--- imagine we are building this fragment\n+   *    name\n+   *    friends {\n+   *      id\n+   *    }\n+   *  }\n+   * ```\n+   * we must carry down `id` and `friends` fields (including any nested fields `friends.name`)\n+   * from the parent `HeroDetails` fragment\n+   *\n+   *\n+   * case 3:\n+   * ```\n+   * fragment HeroDetails on Character {\n+   *  name\n+   *  ... on Droid { <--- imagine we are building this fragment\n+   *    id\n+   *    ...DroidDetails\n+   *  }\n+   *}\n+   *\n+   *fragment DroidDetails on Droid {\n+   *  friends {\n+   *    name\n+   *  }\n+   * }\n+   * ```\n+   */\n+  private fun buildGenericFragment(\n+      fragmentTypeCondition: IntrospectionSchema.TypeRef,\n+      fragmentFields: List<Field>,\n+      fragmentPossibleTypes: List<IntrospectionSchema.TypeRef>,\n+      fragmentDescription: String,\n+      fragmentConditions: List<Condition>,\n+      namedFragmentSelectionKey: SelectionKey?,\n+      nestedInlineFragments: List<InlineFragment>,\n+      nestedNamedFragments: List<Fragment>,\n+      parentSelectionKey: SelectionKey,\n+      parentSelectionSet: List<BackendIr.Field>,\n+      parentNamedFragmentSelectionKeys: Set<SelectionKey>,\n+      generateFragmentImplementations: Boolean,\n+  ): GenericFragment {\n+    val fragmentName = fragmentTypeCondition.name!!.capitalize()\n+    val fragmentSelectionSet = fragmentFields.buildBackendIrFields(\n+        selectionKey = parentSelectionKey + fragmentName,\n+        generateFragmentImplementations = generateFragmentImplementations,\n+    ).addFieldSelectionKey(namedFragmentSelectionKey)\n+    val selectionSet = parentSelectionSet\n+        .addFieldSelectionKey(parentSelectionKey + fragmentName)\n+        .map { field ->\n+          field.addFieldSelectionKeys(\n+              field.selectionKeys\n+                  .filter { selectionKey -> selectionKey.type == SelectionKey.Type.Fragment }\n+                  .map { selectionKey ->\n+                    selectionKey.copy(\n+                        keys = listOf(selectionKey.keys.first(), fragmentName, selectionKey.keys.last())\n+                    )\n+                  }\n+                  .toSet()\n+          )\n+        }\n+        .mergeFields(fragmentSelectionSet)\n+    val childInlineFragments = nestedInlineFragments.map { inlineFragment ->\n+      val fragment = buildGenericFragment(\n+          fragmentTypeCondition = schema.resolveType(inlineFragment.typeCondition),\n+          fragmentFields = inlineFragment.fields,\n+          fragmentPossibleTypes = inlineFragment.possibleTypes.map { possibleType -> schema.resolveType(possibleType) },\n+          fragmentDescription = inlineFragment.description,\n+          fragmentConditions = inlineFragment.conditions,\n+          namedFragmentSelectionKey = namedFragmentSelectionKey?.let { selectionKey ->\n+            selectionKey.copy(\n+                keys = listOf(selectionKey.keys.first(), inlineFragment.typeCondition.capitalize())\n+            )\n+          },\n+          nestedInlineFragments = inlineFragment.inlineFragments,\n+          nestedNamedFragments = inlineFragment.fragments.map { fragmentRef -> lookupForNamedFragment(fragmentRef) },\n+          parentSelectionKey = parentSelectionKey,\n+          parentSelectionSet = selectionSet,\n+          parentNamedFragmentSelectionKeys = parentNamedFragmentSelectionKeys.run {\n+            if (namedFragmentSelectionKey != null) {\n+              this + namedFragmentSelectionKey\n+            } else this\n+          },\n+          generateFragmentImplementations = generateFragmentImplementations\n+      )\n+      fragment.copy(\n+          selectionKeys = fragment.selectionKeys + (parentSelectionKey + fragmentName)\n+      )\n+    }\n+    val childNamedFragments = nestedNamedFragments.map { namedFragment ->\n+      buildGenericFragment(\n+          fragmentTypeCondition = schema.resolveType(namedFragment.typeCondition),\n+          fragmentFields = namedFragment.fields,\n+          fragmentPossibleTypes = namedFragment.possibleTypes.map { possibleType -> schema.resolveType(possibleType) },\n+          fragmentDescription = namedFragment.description,\n+          fragmentConditions = emptyList(),\n+          namedFragmentSelectionKey = SelectionKey(\n+              root = namedFragment.fragmentName.capitalize(),\n+              keys = listOf(namedFragment.fragmentName.capitalize()),\n+              type = SelectionKey.Type.Fragment,\n+          ),\n+          nestedInlineFragments = namedFragment.inlineFragments,\n+          nestedNamedFragments = namedFragment.fragmentRefs.map { fragmentRef -> lookupForNamedFragment(fragmentRef) },\n+          parentSelectionKey = parentSelectionKey,\n+          parentSelectionSet = selectionSet,\n+          parentNamedFragmentSelectionKeys = parentNamedFragmentSelectionKeys.run {\n+            if (namedFragmentSelectionKey != null) {\n+              this + namedFragmentSelectionKey\n+            } else this\n+          },\n+          generateFragmentImplementations = generateFragmentImplementations\n+      )\n+    }\n+    val selectionKeys = setOf(\n+        parentSelectionKey,\n+        parentSelectionKey + fragmentName,\n+    ).plus(\n+        parentNamedFragmentSelectionKeys.map { selectionKey ->\n+          //TODO figure out why this happens when we have nested fragments defined on the same type condition\n+          selectionKey\n+              .takeIf { selectionKey.keys.last() == fragmentName }\n+              ?: selectionKey + fragmentName\n+        }\n+    ).run {\n+      if (namedFragmentSelectionKey != null) {\n+        this + namedFragmentSelectionKey\n+      } else this\n+    }\n+    return GenericFragment(\n+        name = fragmentName,\n+        typeCondition = fragmentTypeCondition,\n+        possibleTypes = fragmentPossibleTypes,\n+        description = fragmentDescription,\n+        selectionSet = selectionSet,\n+        conditions = fragmentConditions,\n+        nestedFragments = childInlineFragments + childNamedFragments,\n+        selectionKeys = selectionKeys,\n+    )\n+  }\n+\n+  /**\n+   * Formats fragment implementation name by joining type conditions:\n+   * ```\n+   *  query TestOperation {\n+   *   random {\n+   *    ... on Being {\n+   *    }\n+   *    ... on Human {\n+   *    }\n+   *  }\n+   *}\n+   * ```\n+   * generated name is going to be `BeingHumanRandom`.\n+   */\n+  private fun List<GenericFragment>.formatFragmentImplementationName(postfix: String): String {\n+    return this\n+        .distinctBy { fragment -> fragment.typeCondition }\n+        .joinToString(separator = \"\", postfix = postfix.capitalize()) { fragment ->\n+          fragment.typeCondition.name!!.capitalize()\n+        }\n+  }\n+\n+  /**\n+   * Groups provided list of fragments by intersection of possible types.\n+   * ```\n+   * query TestOperation {\n+   *   random {\n+   *     ... on Being {\n+   *      ... on Human {\n+   *      }\n+   *      ... on Wookie {\n+   *      }\n+   *     }\n+   *  }\n+   *}\n+   * ```\n+   * as `Human` and `Wookie` are subtypes of `Being` grouped fragment map is going to be:\n+   * ```\n+   * [\n+   *  [Being, Human]: [\"Human\"],\n+   *  [Being, Wookie]: [\"Wookie\"]\n+   * ]\n+   * ```\n+   */\n+  private fun List<GenericFragment>.groupFragmentsByPossibleTypes()\n+      : Map<List<GenericFragment>, List<IntrospectionSchema.TypeRef>> {\n+    return this\n+        .flatMap { fragment -> fragment.possibleTypes }\n+        .toSet()\n+        .map { possibleType ->\n+          possibleType to this.filter { fragment ->\n+            fragment.possibleTypes.contains(possibleType)\n+          }\n+        }.fold(emptyMap()) { acc, (possibleType, fragments) ->\n+          acc + (fragments to (acc[fragments]?.plus(possibleType) ?: listOf(possibleType)))\n+        }", "originalCommit": "d1904518827d9f5c87d771f7544356e882181d86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a2ed2319b8ca0ad9f2bd330d2e8e5c24e22901fb", "url": "https://github.com/apollographql/apollo-android/commit/a2ed2319b8ca0ad9f2bd330d2e8e5c24e22901fb", "message": "Feedback", "committedDate": "2020-11-25T23:58:28Z", "type": "forcePushed"}, {"oid": "925ea0688987297be6055bdf9da9febb8186cd91", "url": "https://github.com/apollographql/apollo-android/commit/925ea0688987297be6055bdf9da9febb8186cd91", "message": "Fragment with inline fragment", "committedDate": "2020-11-26T21:44:47Z", "type": "commit"}, {"oid": "f7a6435e8a54f58686874a758764ba6f0daeace0", "url": "https://github.com/apollographql/apollo-android/commit/f7a6435e8a54f58686874a758764ba6f0daeace0", "message": "Rework backend compiler\n\nAddress issues with nested inline fragments and properly merging fields.", "committedDate": "2020-11-26T21:49:06Z", "type": "commit"}, {"oid": "93f4423c846f92eff910a0e620fd7c230950e491", "url": "https://github.com/apollographql/apollo-android/commit/93f4423c846f92eff910a0e620fd7c230950e491", "message": "Update test fixtures", "committedDate": "2020-11-26T21:50:04Z", "type": "commit"}, {"oid": "59a65cbc04963b64343c8d2adb6bef3906236896", "url": "https://github.com/apollographql/apollo-android/commit/59a65cbc04963b64343c8d2adb6bef3906236896", "message": "Feedback + rebase", "committedDate": "2020-11-26T23:40:17Z", "type": "forcePushed"}, {"oid": "e4ff432e4a08b1dd3d9e0bef0cba4f3d7474f621", "url": "https://github.com/apollographql/apollo-android/commit/e4ff432e4a08b1dd3d9e0bef0cba4f3d7474f621", "message": "Feedback + rebase", "committedDate": "2020-11-27T06:15:39Z", "type": "commit"}, {"oid": "e4ff432e4a08b1dd3d9e0bef0cba4f3d7474f621", "url": "https://github.com/apollographql/apollo-android/commit/e4ff432e4a08b1dd3d9e0bef0cba4f3d7474f621", "message": "Feedback + rebase", "committedDate": "2020-11-27T06:15:39Z", "type": "forcePushed"}, {"oid": "9fcef00724305c220c1167eda266617da34bc11a", "url": "https://github.com/apollographql/apollo-android/commit/9fcef00724305c220c1167eda266617da34bc11a", "message": "Fix sample apps", "committedDate": "2020-11-27T06:35:06Z", "type": "commit"}, {"oid": "16c24aefd95e8d71b6f9d7639ee06bc5564c98d7", "url": "https://github.com/apollographql/apollo-android/commit/16c24aefd95e8d71b6f9d7639ee06bc5564c98d7", "message": "Fix scalar type generation", "committedDate": "2020-11-28T02:38:28Z", "type": "commit"}, {"oid": "0abed834ece400c28ac41314ef930f813ae07ba1", "url": "https://github.com/apollographql/apollo-android/commit/0abed834ece400c28ac41314ef930f813ae07ba1", "message": "Generate fragment default implementations", "committedDate": "2020-11-29T04:59:01Z", "type": "commit"}, {"oid": "8da01d761d4d4c2fbab1749f9193f1c2a4addad9", "url": "https://github.com/apollographql/apollo-android/commit/8da01d761d4d4c2fbab1749f9193f1c2a4addad9", "message": "Rework custom type filtering", "committedDate": "2020-11-29T05:18:15Z", "type": "commit"}, {"oid": "fc5de2831b6075d24dcdc7489ab393a8b9c1eef0", "url": "https://github.com/apollographql/apollo-android/commit/fc5de2831b6075d24dcdc7489ab393a8b9c1eef0", "message": "All good, all aboard.", "committedDate": "2020-11-29T05:31:10Z", "type": "commit"}, {"oid": "deb020a9c6a888c2300ef67904246238b7e2c56d", "url": "https://github.com/apollographql/apollo-android/commit/deb020a9c6a888c2300ef67904246238b7e2c56d", "message": "Address issue with codegeneration for duplicated inline fragment case.\nFix metadata tests", "committedDate": "2020-11-29T20:58:40Z", "type": "commit"}, {"oid": "3ec4acf4021fdec335b7ff41b3e9c317d8ace9e3", "url": "https://github.com/apollographql/apollo-android/commit/3ec4acf4021fdec335b7ff41b3e9c317d8ace9e3", "message": "Fix ID codegen to be handled as String everywhere\nFix issue with Response Adapter when writing list of nullable objects.\nFix plugin tests", "committedDate": "2020-11-30T01:03:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYwMzMxNA==", "url": "https://github.com/apollographql/apollo-android/pull/2701#discussion_r532603314", "bodyText": "Typo: inline_fragment_intersection", "author": "martinbonnin", "createdAt": "2020-11-30T13:40:17Z", "path": "apollo-compiler/src/test/graphql/com/example/inline_frgament_intersection/TestOperation.kt", "diffHunk": "@@ -0,0 +1,386 @@\n+// AUTO-GENERATED FILE. DO NOT MODIFY.\n+//\n+// This class was automatically generated by Apollo GraphQL plugin from the GraphQL queries it found.\n+// It should not be modified by hand.\n+//\n+package com.example.inline_frgament_intersection", "originalCommit": "3ec4acf4021fdec335b7ff41b3e9c317d8ace9e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}