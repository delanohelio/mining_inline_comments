{"pr_number": 2806, "pr_title": "Rework code gen (again) to better support nested fragments", "pr_createdAt": "2020-12-16T05:01:47Z", "pr_url": "https://github.com/apollographql/apollo-android/pull/2806", "timeline": [{"oid": "8627a652e07958f76e803c5d54518eb906515850", "url": "https://github.com/apollographql/apollo-android/commit/8627a652e07958f76e803c5d54518eb906515850", "message": "Rework code genn (again) to better support nested fragments", "committedDate": "2020-12-16T05:01:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzNTk3Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2806#discussion_r544335976", "bodyText": "What about?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  val name: String,\n          \n          \n            \n                  val typeCondition: String,\n          \n      \n    \n    \n  \n\nAs name could be mistaken with the fragment spread name", "author": "martinbonnin", "createdAt": "2020-12-16T14:21:14Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/backend/ir/BackendIr.kt", "diffHunk": "@@ -99,46 +97,38 @@ internal data class BackendIr(\n       }\n     }\n \n-    data class Variable(val name: String, val inverted: Boolean) : Condition() {\n-    }\n+    data class Variable(val name: String, val inverted: Boolean) : Condition()\n   }\n \n-  sealed class Fragment {\n-    abstract val name: String\n-    abstract val fields: List<Field>\n-    abstract val possibleTypes: Set<IntrospectionSchema.TypeRef>\n-    abstract val selectionKeys: Set<SelectionKey>\n-    abstract val description: String?\n-\n-    data class Interface(\n-        override val name: String,\n-        override val fields: List<Field>,\n-        override val possibleTypes: Set<IntrospectionSchema.TypeRef>,\n-        override val selectionKeys: Set<SelectionKey>,\n-        override val description: String?,\n-        val typeCondition: IntrospectionSchema.TypeRef,\n-    ) : Fragment()\n-\n-    data class Implementation(\n-        override val name: String,\n-        override val fields: List<Field>,\n-        override val possibleTypes: Set<IntrospectionSchema.TypeRef>,\n-        override val selectionKeys: Set<SelectionKey>,\n-        override val description: String?,\n-    ) : Fragment()\n+  data class Fragments(\n+      val fragments: List<Fragment>,\n+      val accessors: Map<String, SelectionKey>,\n+  ) : List<Fragment> by fragments\n+\n+  data class Fragment(\n+      val name: String,", "originalCommit": "8627a652e07958f76e803c5d54518eb906515850", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MDAyOQ==", "url": "https://github.com/apollographql/apollo-android/pull/2806#discussion_r544340029", "bodyText": "Got it. It's not directly typeCondition but typeCondition.capitalize so it's the name of the generated class. Oh well, naming is hard... Maybe we could postpone the capitalization to the codegen phase and use only typeCondition in BackendIr?", "author": "martinbonnin", "createdAt": "2020-12-16T14:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzNTk3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk1NDY1Nw==", "url": "https://github.com/apollographql/apollo-android/pull/2806#discussion_r545954657", "bodyText": "We could but there some logic around selection key comparison + formatting names for accessors, default implementation etc. Even if remove it there will be only 2 places at most.", "author": "sav007", "createdAt": "2020-12-18T16:43:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzNTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0NzgzMA==", "url": "https://github.com/apollographql/apollo-android/pull/2806#discussion_r544347830", "bodyText": "There are two addFieldSelectionKeys methods here that seem unused", "author": "martinbonnin", "createdAt": "2020-12-16T14:36:33Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/backend/ir/SelectionKeyUtils.kt", "diffHunk": "@@ -21,10 +21,13 @@ internal object SelectionKeyUtils {\n     }", "originalCommit": "8627a652e07958f76e803c5d54518eb906515850", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0ODk4Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2806#discussion_r544348986", "bodyText": "Nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  parentSelectionSet: List<BackendIr.Field>,\n          \n          \n            \n                  fields: List<BackendIr.Field>,", "author": "martinbonnin", "createdAt": "2020-12-16T14:38:00Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/backend/ir/BackendIrMergeUtils.kt", "diffHunk": "@@ -19,15 +19,18 @@ internal object BackendIrMergeUtils {\n     val mergedFields = this.fields.mergeFields(otherField.fields)\n     return this.copy(\n         fields = mergedFields,\n-        fragments = this.fragments.mergeFragments(\n-            parentSelectionSet = mergedFields,\n-            otherFragments = otherField.fragments\n+        fragments = this.fragments.copy(\n+            fragments = this.fragments.mergeFragments(\n+                parentSelectionSet = mergedFields,\n+                otherFragments = otherField.fragments\n+            ),\n+            accessors = this.fragments.accessors + otherField.fragments.accessors,\n         ),\n         selectionKeys = this.selectionKeys + otherField.selectionKeys,\n     )\n   }\n \n-  private fun List<BackendIr.Fragment>.mergeFragments(\n+  fun List<BackendIr.Fragment>.mergeFragments(\n       parentSelectionSet: List<BackendIr.Field>,", "originalCommit": "8627a652e07958f76e803c5d54518eb906515850", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM2ODgwMA==", "url": "https://github.com/apollographql/apollo-android/pull/2806#discussion_r544368800", "bodyText": "I hate to be the bearer of bad news but we'll need to recurse nested inline fragments as well. One exemple is there: 2c2b39a", "author": "martinbonnin", "createdAt": "2020-12-16T15:01:06Z", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/backend/ir/BackendIrBuilder.kt", "diffHunk": "@@ -452,144 +410,161 @@ internal class BackendIrBuilder constructor(\n       // as fragment can be defined on interface that has more possible implementations than field type where it used\n       // build intersection of fragment's and field's possible types\n       val possibleTypes = fragments.first().possibleTypes.intersect(fieldPossibleTypes)\n-      BackendIr.Fragment.Interface(\n+      BackendIr.Fragment(\n           name = fragments.first().name,\n           fields = selectionSet,\n           selectionKeys = selectionsKeys,\n           possibleTypes = possibleTypes.map { GQLNamedType(sourceLocation = SourceLocation.UNKNOWN, it).toSchemaType(schema) }.toSet(),\n           description = fragments.first().description,\n-          typeCondition = fragments.first().typeCondition,\n+          kind = BackendIr.Fragment.Kind.Interface,\n       )\n     }\n   }\n \n-  private fun buildFragmentImplementations(\n-      parentSelectionName: String,\n-      inlineFragments: List<FrontendIr.Selection.InlineFragment>,\n-      namedFragments: List<FrontendIr.Selection.FragmentSpread>,\n-      fieldPossibleTypes: Set<String>,\n+  private fun BackendIr.Field.buildFragmentImplementations(\n       selectionKey: SelectionKey,\n-      fields: List<BackendIr.Field>,\n-  ): List<BackendIr.Fragment.Implementation> {\n-    // build all defined fragment implementations including nested ones\n-    val fragments = buildGenericFragments(\n-        inlineFragments = inlineFragments,\n-        namedFragments = namedFragments,\n-        selectionKey = selectionKey,\n-        selectionSet = fields,\n-        generateFragmentImplementations = true\n-    )\n-        // flatten fragments structure (remove nesting)\n-        .flatten()\n-\n-    // we might get fragments that intersects by possible type - group them\n-    val groupedFragments = fragments.groupFragmentsByPossibleTypes()\n-\n-    // merge fragments with possible types intersection into one implementation\n-    return groupedFragments.map { (fragments, fragmentsPossibleTypes) ->\n-      val fragmentName = fragments.formatFragmentImplementationName(\n-          postfix = parentSelectionName,\n+  ): BackendIr.Field {\n+    return if (this.fragments.isEmpty()) {\n+      this.copy(\n+          fields = this.fields.map { field ->\n+            field.buildFragmentImplementations(\n+                selectionKey = selectionKey + field.responseName,\n+            )\n+          }\n       )\n-      val selectionSet = fragments.fold(emptyList<BackendIr.Field>()) { acc, fragment ->\n-        acc.mergeFields(fragment.selectionSet)\n+    } else {\n+      val fragmentInterfaces = this.fragments.filter { it.kind == BackendIr.Fragment.Kind.Interface }\n+      val groupedFragmentInterfaces = fragmentInterfaces.groupFragmentsByPossibleTypes()\n+      val fieldPossibleTypes = schema.typeDefinition(this.type.rawType.name!!)\n+          .possibleTypes(schema.typeDefinitions)\n+          .map { GQLNamedType(sourceLocation = SourceLocation.UNKNOWN, it).toSchemaType(schema) }\n+          .toSet()\n+      val fragmentImplementations = groupedFragmentInterfaces.map { (fragments, fragmentsPossibleTypes) ->\n+        fragments.buildFragmentImplementation(\n+            parentName = this.responseName,\n+            parentSelectionSet = this.fields,\n+            possibleTypes = fieldPossibleTypes.intersect(fragmentsPossibleTypes),\n+            selectionKey = selectionKey,\n+        )\n       }\n-      val selectionsKeys = fragments.fold(emptySet<SelectionKey>()) { acc, fragment ->\n-        acc.plus(fragment.selectionKeys)\n+      val fields = this.fields.map { field ->\n+        field.buildFragmentImplementations(\n+            selectionKey = selectionKey + field.responseName,\n+        )\n       }\n-      val description = if (fragments.size == 1) {\n-        fragments.first().description\n-      } else null\n-      // as fragment can be defined on interface that has more possible implementation types than field's type where it used\n-      // build intersection of fragment's and field's possible types\n-      val possibleTypes = fragmentsPossibleTypes.intersect(fieldPossibleTypes)\n-      BackendIr.Fragment.Implementation(\n-          name = fragmentName,\n-          fields = selectionSet,\n-          possibleTypes = possibleTypes.map { GQLNamedType(sourceLocation = SourceLocation.UNKNOWN, it).toSchemaType(schema) }.toSet(),\n-          selectionKeys = selectionsKeys,\n-          description = description,\n+\n+      val defaultImplementation = BackendIr.Fragment(\n+          name = \"Other${this.responseName.capitalize()}\",\n+          fields = fields,\n+          possibleTypes = emptySet(),\n+          selectionKeys = this.selectionKeys + selectionKey,\n+          description = null,\n+          kind = BackendIr.Fragment.Kind.Fallback,\n+      )\n+\n+      this.copy(\n+          fields = fields,\n+          fragments = createFragments(\n+              selectionKey = selectionKey,\n+              fragments = fragmentInterfaces + fragmentImplementations + defaultImplementation,\n+          ),\n+          selectionKeys = this.selectionKeys + selectionKey,\n       )\n     }\n   }\n \n-  private fun List<GenericFragment>.flatten(): List<GenericFragment> {\n-    return this.flatMap { fragment ->\n-      listOf(fragment.copy(nestedFragments = emptyList())) + fragment.nestedFragments.flatten()\n+  private fun List<BackendIr.Fragment>.buildFragmentImplementation(\n+      parentName: String,\n+      parentSelectionSet: List<BackendIr.Field>,\n+      possibleTypes: Set<IntrospectionSchema.TypeRef>,\n+      selectionKey: SelectionKey,\n+  ): BackendIr.Fragment {\n+    val fragmentName = this.distinctBy { fragment -> fragment.name }\n+        .joinToString(separator = \"\", postfix = parentName.capitalize()) { fragment -> fragment.name.capitalize() }\n+\n+    val selectionSet = this.fold(parentSelectionSet) { acc, fragment ->\n+      acc.mergeFields(\n+          fragment.fields.addFieldSelectionKey(selectionKey + fragmentName)\n+      )\n+    }.map { field ->\n+      field.buildFragmentImplementations(\n+          selectionKey = selectionKey + fragmentName + field.responseName,\n+      )\n     }\n+\n+    val selectionsKeys = this.fold(emptySet<SelectionKey>()) { acc, fragment ->\n+      acc.plus(fragment.selectionKeys)\n+    }.plus(selectionKey)\n+\n+    return BackendIr.Fragment(\n+        name = fragmentName,\n+        fields = selectionSet,\n+        possibleTypes = possibleTypes.toSet(),\n+        selectionKeys = selectionsKeys,\n+        description = null,\n+        kind = BackendIr.Fragment.Kind.Implementation,\n+    )\n   }\n \n   private fun buildGenericFragments(\n       inlineFragments: List<FrontendIr.Selection.InlineFragment>,\n       namedFragments: List<FrontendIr.Selection.FragmentSpread>,\n-      selectionKey: SelectionKey,\n-      selectionSet: List<BackendIr.Field>,\n-      generateFragmentImplementations: Boolean,\n+      parentSelectionKey: SelectionKey,\n+      parentSelectionSet: List<BackendIr.Field>,\n+      parentNamedFragmentSelectionKey: SelectionKey? = null,\n   ): List<GenericFragment> {\n-    // build generic fragments from inline fragments\n     val genericInlineFragments = inlineFragments\n         .map { inlineFragment ->\n-          inlineFragment.buildGenericFragment(\n-              parentSelectionKey = selectionKey,\n-              parentSelectionSet = selectionSet,\n-              parentNamedFragmentSelectionKeys = emptySet(),\n-              generateFragmentImplementations = generateFragmentImplementations\n+          val fragmentName = inlineFragment.fragmentDefinition.typeCondition.name.capitalize()\n+          buildGenericFragment(\n+              fragmentName = fragmentName,\n+              fragmentTypeCondition = inlineFragment.fragmentDefinition.typeCondition.name,\n+              fragmentSelectionSet = inlineFragment.fragmentDefinition.selections,\n+              fragmentDescription = inlineFragment.fragmentDefinition.typeCondition.description ?: \"\",\n+              fragmentCondition = inlineFragment.condition.toBackendIrCondition(),\n+              namedFragmentSelectionKey = parentNamedFragmentSelectionKey?.plus(fragmentName),\n+              parentSelectionKey = parentSelectionKey,\n+              parentSelectionSet = parentSelectionSet.addFieldSelectionKey(\n+                  parentNamedFragmentSelectionKey?.plus(fragmentName)\n+              ),", "originalCommit": "8627a652e07958f76e803c5d54518eb906515850", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk2MDI0Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2806#discussion_r545960246", "bodyText": "should be fixed with this commit a68fb53#diff-7cee39198b0604492035a9fe87f2c7c4395fe30c6bad0c7a312849e4f73a2da4R171", "author": "sav007", "createdAt": "2020-12-18T16:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM2ODgwMA=="}], "type": "inlineReview"}, {"oid": "9da849f21419fa118bb438b68d622d62266a7ba6", "url": "https://github.com/apollographql/apollo-android/commit/9da849f21419fa118bb438b68d622d62266a7ba6", "message": "Feedback + fix default implementation fix", "committedDate": "2020-12-18T16:46:45Z", "type": "forcePushed"}, {"oid": "a68fb53966b6626e653d061a3ae3eca7dd524d62", "url": "https://github.com/apollographql/apollo-android/commit/a68fb53966b6626e653d061a3ae3eca7dd524d62", "message": "Feedback + fix default implementation fix", "committedDate": "2020-12-18T16:52:37Z", "type": "forcePushed"}, {"oid": "4c2c4bea3c8eadeb1c62c177aad5a7dcfceeb58e", "url": "https://github.com/apollographql/apollo-android/commit/4c2c4bea3c8eadeb1c62c177aad5a7dcfceeb58e", "message": "Feedback + fix default implementation fix", "committedDate": "2020-12-18T17:05:20Z", "type": "commit"}, {"oid": "4c2c4bea3c8eadeb1c62c177aad5a7dcfceeb58e", "url": "https://github.com/apollographql/apollo-android/commit/4c2c4bea3c8eadeb1c62c177aad5a7dcfceeb58e", "message": "Feedback + fix default implementation fix", "committedDate": "2020-12-18T17:05:20Z", "type": "forcePushed"}]}