{"pr_number": 2809, "pr_title": "Implement support for AWS AppSync in WebSocketSubscriptionTransport", "pr_createdAt": "2020-12-17T02:27:47Z", "pr_url": "https://github.com/apollographql/apollo-android/pull/2809", "timeline": [{"oid": "bb01aa88c2ff6ca4be5122d45001dd30f3b5e5cd", "url": "https://github.com/apollographql/apollo-android/commit/bb01aa88c2ff6ca4be5122d45001dd30f3b5e5cd", "message": "Rename .java to .kt", "committedDate": "2020-12-17T00:09:57Z", "type": "commit"}, {"oid": "ecea94ecad96883a46b1e914147ec9462ea73f42", "url": "https://github.com/apollographql/apollo-android/commit/ecea94ecad96883a46b1e914147ec9462ea73f42", "message": "Convert WebSocketSubscriptionTransport to Kotlin", "committedDate": "2020-12-17T00:09:57Z", "type": "commit"}, {"oid": "227c29953f56ba1606a5fa16df015d5f1db4755d", "url": "https://github.com/apollographql/apollo-android/commit/227c29953f56ba1606a5fa16df015d5f1db4755d", "message": "Rename .java to .kt", "committedDate": "2020-12-17T01:04:41Z", "type": "commit"}, {"oid": "c8a5fa259ff75798ea6f83728554e321f46ad148", "url": "https://github.com/apollographql/apollo-android/commit/c8a5fa259ff75798ea6f83728554e321f46ad148", "message": "Rewrite OperationClientMessage to a sealed class", "committedDate": "2020-12-17T01:04:41Z", "type": "commit"}, {"oid": "a9cdfbde4ae07c847ecdd645701ed32939c41a15", "url": "https://github.com/apollographql/apollo-android/commit/a9cdfbde4ae07c847ecdd645701ed32939c41a15", "message": "Implement support for AWS AppSync in WebSocketSubscriptionTransport", "committedDate": "2020-12-17T02:14:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NDU5Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r544764596", "bodyText": "Ideally I would want these to be internal but since they live in a separate module the cannot.\nThey are very handy in making the code more readable and makes manual JSON writing much less error prone.", "author": "ansman", "createdAt": "2020-12-17T02:28:44Z", "path": "apollo-api/src/commonMain/kotlin/com/apollographql/apollo/api/internal/json/JsonWriters.kt", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.apollographql.apollo.api.internal.json\n+\n+inline fun JsonWriter.writeObject(crossinline block: JsonWriter.() -> Unit) {", "originalCommit": "a9cdfbde4ae07c847ecdd645701ed32939c41a15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE0NDA5NA==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545144094", "bodyText": "Since the package is marked as internal, it should be ok", "author": "martinbonnin", "createdAt": "2020-12-17T14:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NDU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NTI4Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r544765286", "bodyText": "I kept this as internal since I'm assuming it's there to avoid the synthetic accessor methods from being generated?", "author": "ansman", "createdAt": "2020-12-17T02:30:33Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransport.kt", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.subscription.OperationClientMessage.Start.Companion.jsonValue\n+import okhttp3.HttpUrl\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okio.Buffer\n+import java.lang.ref.WeakReference\n+import java.util.Base64\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * [SubscriptionTransport] implementation based on [WebSocket].\n+ */\n+class WebSocketSubscriptionTransport @JvmOverloads constructor(\n+    private val webSocketRequest: Request,\n+    private val webSocketConnectionFactory: WebSocket.Factory,\n+    private val callback: SubscriptionTransport.Callback,\n+    private val writePayloadAsJsonString: Boolean = false,\n+    private val extensions: Map<String, Any?> = emptyMap()\n+) : SubscriptionTransport {\n+  internal val webSocket = AtomicReference<WebSocket>()\n+  internal val webSocketListener = AtomicReference<WebSocketListener>()\n+\n+  override fun connect() {\n+    val webSocketListener = WebSocketListener(this)\n+    check(this.webSocketListener.compareAndSet(null, webSocketListener)) {\n+      \"Already connected\"\n+    }\n+    webSocket.set(webSocketConnectionFactory.newWebSocket(webSocketRequest, webSocketListener))\n+  }\n+\n+  override fun disconnect(message: OperationClientMessage) {\n+    webSocket.getAndSet(null)\n+        ?.close(1001, message.serializeToJson())\n+    release()\n+  }\n+\n+  override fun send(message: OperationClientMessage) {\n+    val socket = webSocket.get() ?: run {\n+      callback.onFailure(IllegalStateException(\"Send attempted on closed connection\"))\n+      return\n+    }\n+    socket.send(message.serializeToJson())\n+  }\n+\n+  internal fun onOpen() {\n+    callback.onConnected()\n+  }\n+\n+  internal fun onMessage(message: OperationServerMessage?) {\n+    callback.onMessage(message)\n+  }\n+\n+  internal fun onFailure(t: Throwable?) {\n+    try {\n+      callback.onFailure(t)\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  internal fun onClosed() {\n+    try {\n+      callback.onClosed()\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  private fun release() {\n+    webSocketListener.getAndSet(null)?.release()\n+    webSocket.set(null)\n+  }\n+\n+  private fun OperationClientMessage.serializeToJson(): String =\n+      toJsonString(\n+        writePayloadAsJsonString = writePayloadAsJsonString,\n+        extensions = extensions\n+    )\n+\n+  internal class WebSocketListener(delegate: WebSocketSubscriptionTransport) : okhttp3.WebSocketListener() {", "originalCommit": "a9cdfbde4ae07c847ecdd645701ed32939c41a15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE2MDUyOA==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545160528", "bodyText": "I think this used to be package private in Java. This could certainly be private except we're using it from tests so internal seems good", "author": "martinbonnin", "createdAt": "2020-12-17T15:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NTI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NjA3OA==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r544766078", "bodyText": "I'm not very happy with the format of this change and I'm happy talk alternatives.\nI like being able to pass arbitrary extensions but not how this is triggered.\nOne alternative would be to introduce some sort of \"format\" or \"dialect\" enum which there are 2 off. I tried to find some official specification for the websocket format but there doesn't seem to be one?", "author": "ansman", "createdAt": "2020-12-17T02:32:37Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransport.kt", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.subscription.OperationClientMessage.Start.Companion.jsonValue\n+import okhttp3.HttpUrl\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okio.Buffer\n+import java.lang.ref.WeakReference\n+import java.util.Base64\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * [SubscriptionTransport] implementation based on [WebSocket].\n+ */\n+class WebSocketSubscriptionTransport @JvmOverloads constructor(\n+    private val webSocketRequest: Request,\n+    private val webSocketConnectionFactory: WebSocket.Factory,\n+    private val callback: SubscriptionTransport.Callback,\n+    private val writePayloadAsJsonString: Boolean = false,\n+    private val extensions: Map<String, Any?> = emptyMap()\n+) : SubscriptionTransport {\n+  internal val webSocket = AtomicReference<WebSocket>()\n+  internal val webSocketListener = AtomicReference<WebSocketListener>()\n+\n+  override fun connect() {\n+    val webSocketListener = WebSocketListener(this)\n+    check(this.webSocketListener.compareAndSet(null, webSocketListener)) {\n+      \"Already connected\"\n+    }\n+    webSocket.set(webSocketConnectionFactory.newWebSocket(webSocketRequest, webSocketListener))\n+  }\n+\n+  override fun disconnect(message: OperationClientMessage) {\n+    webSocket.getAndSet(null)\n+        ?.close(1001, message.serializeToJson())\n+    release()\n+  }\n+\n+  override fun send(message: OperationClientMessage) {\n+    val socket = webSocket.get() ?: run {\n+      callback.onFailure(IllegalStateException(\"Send attempted on closed connection\"))\n+      return\n+    }\n+    socket.send(message.serializeToJson())\n+  }\n+\n+  internal fun onOpen() {\n+    callback.onConnected()\n+  }\n+\n+  internal fun onMessage(message: OperationServerMessage?) {\n+    callback.onMessage(message)\n+  }\n+\n+  internal fun onFailure(t: Throwable?) {\n+    try {\n+      callback.onFailure(t)\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  internal fun onClosed() {\n+    try {\n+      callback.onClosed()\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  private fun release() {\n+    webSocketListener.getAndSet(null)?.release()\n+    webSocket.set(null)\n+  }\n+\n+  private fun OperationClientMessage.serializeToJson(): String =\n+      toJsonString(\n+        writePayloadAsJsonString = writePayloadAsJsonString,\n+        extensions = extensions\n+    )\n+\n+  internal class WebSocketListener(delegate: WebSocketSubscriptionTransport) : okhttp3.WebSocketListener() {\n+    private val delegateRef = WeakReference(delegate)\n+\n+    override fun onOpen(webSocket: WebSocket, response: Response) {\n+      delegateRef.get()?.onOpen()\n+    }\n+\n+    override fun onMessage(webSocket: WebSocket, text: String) {\n+      delegateRef.get()?.onMessage(OperationServerMessage.fromJsonString(text))\n+    }\n+\n+    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {\n+      delegateRef.get()?.onFailure(t)\n+    }\n+\n+    override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    fun release() {\n+      delegateRef.clear()\n+    }\n+  }\n+\n+  /**\n+   * @param webSocketUrl The URL of the GraphQL WebSocket API\n+   * @param webSocketConnectionFactory The [WebSocket.Factory] to use to create the websockets\n+   * @param writePayloadAsJsonString If the payload should be serialized as a JSON String (default false). Set this to `true` for AWS\n+   *                                 AppSync integrations.\n+   * @param extensions Any additional extensions to when sending start commands. Must not be changed after this creating the factory.\n+   */\n+  class Factory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      private val writePayloadAsJsonString: Boolean = false,", "originalCommit": "a9cdfbde4ae07c847ecdd645701ed32939c41a15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NjQ5Mw==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r544766493", "bodyText": "This was created as a convenience to do two things for the user:\n\nAdd the header and payload query parameters which AppSync requires\nAdd the authorization as an extension to the start messages.", "author": "ansman", "createdAt": "2020-12-17T02:33:52Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransport.kt", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.subscription.OperationClientMessage.Start.Companion.jsonValue\n+import okhttp3.HttpUrl\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okio.Buffer\n+import java.lang.ref.WeakReference\n+import java.util.Base64\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * [SubscriptionTransport] implementation based on [WebSocket].\n+ */\n+class WebSocketSubscriptionTransport @JvmOverloads constructor(\n+    private val webSocketRequest: Request,\n+    private val webSocketConnectionFactory: WebSocket.Factory,\n+    private val callback: SubscriptionTransport.Callback,\n+    private val writePayloadAsJsonString: Boolean = false,\n+    private val extensions: Map<String, Any?> = emptyMap()\n+) : SubscriptionTransport {\n+  internal val webSocket = AtomicReference<WebSocket>()\n+  internal val webSocketListener = AtomicReference<WebSocketListener>()\n+\n+  override fun connect() {\n+    val webSocketListener = WebSocketListener(this)\n+    check(this.webSocketListener.compareAndSet(null, webSocketListener)) {\n+      \"Already connected\"\n+    }\n+    webSocket.set(webSocketConnectionFactory.newWebSocket(webSocketRequest, webSocketListener))\n+  }\n+\n+  override fun disconnect(message: OperationClientMessage) {\n+    webSocket.getAndSet(null)\n+        ?.close(1001, message.serializeToJson())\n+    release()\n+  }\n+\n+  override fun send(message: OperationClientMessage) {\n+    val socket = webSocket.get() ?: run {\n+      callback.onFailure(IllegalStateException(\"Send attempted on closed connection\"))\n+      return\n+    }\n+    socket.send(message.serializeToJson())\n+  }\n+\n+  internal fun onOpen() {\n+    callback.onConnected()\n+  }\n+\n+  internal fun onMessage(message: OperationServerMessage?) {\n+    callback.onMessage(message)\n+  }\n+\n+  internal fun onFailure(t: Throwable?) {\n+    try {\n+      callback.onFailure(t)\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  internal fun onClosed() {\n+    try {\n+      callback.onClosed()\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  private fun release() {\n+    webSocketListener.getAndSet(null)?.release()\n+    webSocket.set(null)\n+  }\n+\n+  private fun OperationClientMessage.serializeToJson(): String =\n+      toJsonString(\n+        writePayloadAsJsonString = writePayloadAsJsonString,\n+        extensions = extensions\n+    )\n+\n+  internal class WebSocketListener(delegate: WebSocketSubscriptionTransport) : okhttp3.WebSocketListener() {\n+    private val delegateRef = WeakReference(delegate)\n+\n+    override fun onOpen(webSocket: WebSocket, response: Response) {\n+      delegateRef.get()?.onOpen()\n+    }\n+\n+    override fun onMessage(webSocket: WebSocket, text: String) {\n+      delegateRef.get()?.onMessage(OperationServerMessage.fromJsonString(text))\n+    }\n+\n+    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {\n+      delegateRef.get()?.onFailure(t)\n+    }\n+\n+    override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    fun release() {\n+      delegateRef.clear()\n+    }\n+  }\n+\n+  /**\n+   * @param webSocketUrl The URL of the GraphQL WebSocket API\n+   * @param webSocketConnectionFactory The [WebSocket.Factory] to use to create the websockets\n+   * @param writePayloadAsJsonString If the payload should be serialized as a JSON String (default false). Set this to `true` for AWS\n+   *                                 AppSync integrations.\n+   * @param extensions Any additional extensions to when sending start commands. Must not be changed after this creating the factory.\n+   */\n+  class Factory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      private val writePayloadAsJsonString: Boolean = false,\n+      private val extensions: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory {\n+    private val webSocketRequest: Request = Request.Builder()\n+        .url(webSocketUrl)\n+        .addHeader(\"Sec-WebSocket-Protocol\", \"graphql-ws\")\n+        .addHeader(\"Cookie\", \"\")\n+        .build()\n+\n+    override fun create(callback: SubscriptionTransport.Callback): SubscriptionTransport =\n+        WebSocketSubscriptionTransport(webSocketRequest, webSocketConnectionFactory, callback, writePayloadAsJsonString, extensions)\n+  }\n+\n+  class AppSyncFactory @JvmOverloads constructor(", "originalCommit": "a9cdfbde4ae07c847ecdd645701ed32939c41a15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NjkwNw==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r544766907", "bodyText": "This duplicates what Request.url does when passing a string. We use it so that we can leverage OkHttp's URL handling here.", "author": "ansman", "createdAt": "2020-12-17T02:34:59Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransport.kt", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.subscription.OperationClientMessage.Start.Companion.jsonValue\n+import okhttp3.HttpUrl\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okio.Buffer\n+import java.lang.ref.WeakReference\n+import java.util.Base64\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * [SubscriptionTransport] implementation based on [WebSocket].\n+ */\n+class WebSocketSubscriptionTransport @JvmOverloads constructor(\n+    private val webSocketRequest: Request,\n+    private val webSocketConnectionFactory: WebSocket.Factory,\n+    private val callback: SubscriptionTransport.Callback,\n+    private val writePayloadAsJsonString: Boolean = false,\n+    private val extensions: Map<String, Any?> = emptyMap()\n+) : SubscriptionTransport {\n+  internal val webSocket = AtomicReference<WebSocket>()\n+  internal val webSocketListener = AtomicReference<WebSocketListener>()\n+\n+  override fun connect() {\n+    val webSocketListener = WebSocketListener(this)\n+    check(this.webSocketListener.compareAndSet(null, webSocketListener)) {\n+      \"Already connected\"\n+    }\n+    webSocket.set(webSocketConnectionFactory.newWebSocket(webSocketRequest, webSocketListener))\n+  }\n+\n+  override fun disconnect(message: OperationClientMessage) {\n+    webSocket.getAndSet(null)\n+        ?.close(1001, message.serializeToJson())\n+    release()\n+  }\n+\n+  override fun send(message: OperationClientMessage) {\n+    val socket = webSocket.get() ?: run {\n+      callback.onFailure(IllegalStateException(\"Send attempted on closed connection\"))\n+      return\n+    }\n+    socket.send(message.serializeToJson())\n+  }\n+\n+  internal fun onOpen() {\n+    callback.onConnected()\n+  }\n+\n+  internal fun onMessage(message: OperationServerMessage?) {\n+    callback.onMessage(message)\n+  }\n+\n+  internal fun onFailure(t: Throwable?) {\n+    try {\n+      callback.onFailure(t)\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  internal fun onClosed() {\n+    try {\n+      callback.onClosed()\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  private fun release() {\n+    webSocketListener.getAndSet(null)?.release()\n+    webSocket.set(null)\n+  }\n+\n+  private fun OperationClientMessage.serializeToJson(): String =\n+      toJsonString(\n+        writePayloadAsJsonString = writePayloadAsJsonString,\n+        extensions = extensions\n+    )\n+\n+  internal class WebSocketListener(delegate: WebSocketSubscriptionTransport) : okhttp3.WebSocketListener() {\n+    private val delegateRef = WeakReference(delegate)\n+\n+    override fun onOpen(webSocket: WebSocket, response: Response) {\n+      delegateRef.get()?.onOpen()\n+    }\n+\n+    override fun onMessage(webSocket: WebSocket, text: String) {\n+      delegateRef.get()?.onMessage(OperationServerMessage.fromJsonString(text))\n+    }\n+\n+    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {\n+      delegateRef.get()?.onFailure(t)\n+    }\n+\n+    override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    fun release() {\n+      delegateRef.clear()\n+    }\n+  }\n+\n+  /**\n+   * @param webSocketUrl The URL of the GraphQL WebSocket API\n+   * @param webSocketConnectionFactory The [WebSocket.Factory] to use to create the websockets\n+   * @param writePayloadAsJsonString If the payload should be serialized as a JSON String (default false). Set this to `true` for AWS\n+   *                                 AppSync integrations.\n+   * @param extensions Any additional extensions to when sending start commands. Must not be changed after this creating the factory.\n+   */\n+  class Factory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      private val writePayloadAsJsonString: Boolean = false,\n+      private val extensions: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory {\n+    private val webSocketRequest: Request = Request.Builder()\n+        .url(webSocketUrl)\n+        .addHeader(\"Sec-WebSocket-Protocol\", \"graphql-ws\")\n+        .addHeader(\"Cookie\", \"\")\n+        .build()\n+\n+    override fun create(callback: SubscriptionTransport.Callback): SubscriptionTransport =\n+        WebSocketSubscriptionTransport(webSocketRequest, webSocketConnectionFactory, callback, writePayloadAsJsonString, extensions)\n+  }\n+\n+  class AppSyncFactory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      authorization: Map<String, Any?>,\n+      payload: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory by Factory(\n+      webSocketUrl = webSocketUrl\n+          .let {\n+            HttpUrl.get(when {", "originalCommit": "a9cdfbde4ae07c847ecdd645701ed32939c41a15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE0OTY3MA==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545149670", "bodyText": "Can you add a comment about this?", "author": "martinbonnin", "createdAt": "2020-12-17T14:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NjkwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE1MTAwMA==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545151000", "bodyText": "Yeah, will do", "author": "ansman", "createdAt": "2020-12-17T14:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NjkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NzA2Mg==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r544767062", "bodyText": "I considered checking if the query param is already present but if the user is passing the header manually they shouldn't use the AppSyncFactory.", "author": "ansman", "createdAt": "2020-12-17T02:35:30Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransport.kt", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.subscription.OperationClientMessage.Start.Companion.jsonValue\n+import okhttp3.HttpUrl\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okio.Buffer\n+import java.lang.ref.WeakReference\n+import java.util.Base64\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * [SubscriptionTransport] implementation based on [WebSocket].\n+ */\n+class WebSocketSubscriptionTransport @JvmOverloads constructor(\n+    private val webSocketRequest: Request,\n+    private val webSocketConnectionFactory: WebSocket.Factory,\n+    private val callback: SubscriptionTransport.Callback,\n+    private val writePayloadAsJsonString: Boolean = false,\n+    private val extensions: Map<String, Any?> = emptyMap()\n+) : SubscriptionTransport {\n+  internal val webSocket = AtomicReference<WebSocket>()\n+  internal val webSocketListener = AtomicReference<WebSocketListener>()\n+\n+  override fun connect() {\n+    val webSocketListener = WebSocketListener(this)\n+    check(this.webSocketListener.compareAndSet(null, webSocketListener)) {\n+      \"Already connected\"\n+    }\n+    webSocket.set(webSocketConnectionFactory.newWebSocket(webSocketRequest, webSocketListener))\n+  }\n+\n+  override fun disconnect(message: OperationClientMessage) {\n+    webSocket.getAndSet(null)\n+        ?.close(1001, message.serializeToJson())\n+    release()\n+  }\n+\n+  override fun send(message: OperationClientMessage) {\n+    val socket = webSocket.get() ?: run {\n+      callback.onFailure(IllegalStateException(\"Send attempted on closed connection\"))\n+      return\n+    }\n+    socket.send(message.serializeToJson())\n+  }\n+\n+  internal fun onOpen() {\n+    callback.onConnected()\n+  }\n+\n+  internal fun onMessage(message: OperationServerMessage?) {\n+    callback.onMessage(message)\n+  }\n+\n+  internal fun onFailure(t: Throwable?) {\n+    try {\n+      callback.onFailure(t)\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  internal fun onClosed() {\n+    try {\n+      callback.onClosed()\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  private fun release() {\n+    webSocketListener.getAndSet(null)?.release()\n+    webSocket.set(null)\n+  }\n+\n+  private fun OperationClientMessage.serializeToJson(): String =\n+      toJsonString(\n+        writePayloadAsJsonString = writePayloadAsJsonString,\n+        extensions = extensions\n+    )\n+\n+  internal class WebSocketListener(delegate: WebSocketSubscriptionTransport) : okhttp3.WebSocketListener() {\n+    private val delegateRef = WeakReference(delegate)\n+\n+    override fun onOpen(webSocket: WebSocket, response: Response) {\n+      delegateRef.get()?.onOpen()\n+    }\n+\n+    override fun onMessage(webSocket: WebSocket, text: String) {\n+      delegateRef.get()?.onMessage(OperationServerMessage.fromJsonString(text))\n+    }\n+\n+    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {\n+      delegateRef.get()?.onFailure(t)\n+    }\n+\n+    override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    fun release() {\n+      delegateRef.clear()\n+    }\n+  }\n+\n+  /**\n+   * @param webSocketUrl The URL of the GraphQL WebSocket API\n+   * @param webSocketConnectionFactory The [WebSocket.Factory] to use to create the websockets\n+   * @param writePayloadAsJsonString If the payload should be serialized as a JSON String (default false). Set this to `true` for AWS\n+   *                                 AppSync integrations.\n+   * @param extensions Any additional extensions to when sending start commands. Must not be changed after this creating the factory.\n+   */\n+  class Factory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      private val writePayloadAsJsonString: Boolean = false,\n+      private val extensions: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory {\n+    private val webSocketRequest: Request = Request.Builder()\n+        .url(webSocketUrl)\n+        .addHeader(\"Sec-WebSocket-Protocol\", \"graphql-ws\")\n+        .addHeader(\"Cookie\", \"\")\n+        .build()\n+\n+    override fun create(callback: SubscriptionTransport.Callback): SubscriptionTransport =\n+        WebSocketSubscriptionTransport(webSocketRequest, webSocketConnectionFactory, callback, writePayloadAsJsonString, extensions)\n+  }\n+\n+  class AppSyncFactory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      authorization: Map<String, Any?>,\n+      payload: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory by Factory(\n+      webSocketUrl = webSocketUrl\n+          .let {\n+            HttpUrl.get(when {\n+              it.startsWith(\"ws://\", ignoreCase = true) -> \"http\" + it.drop(2)\n+              it.startsWith(\"wss://\", ignoreCase = true) -> \"https\" + it.drop(3)\n+              else -> it\n+            })\n+          }\n+          .newBuilder()\n+          .setQueryParameter(\"header\", authorization.encodeAsQueryParam())", "originalCommit": "a9cdfbde4ae07c847ecdd645701ed32939c41a15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9b22fb7a00e34342eefb54f38eebfce3ed4b4332", "url": "https://github.com/apollographql/apollo-android/commit/9b22fb7a00e34342eefb54f38eebfce3ed4b4332", "message": "Rename .java to .kt", "committedDate": "2020-12-17T02:54:21Z", "type": "commit"}, {"oid": "72c340297bc30e4401a5f277c6ae1ab184a56414", "url": "https://github.com/apollographql/apollo-android/commit/72c340297bc30e4401a5f277c6ae1ab184a56414", "message": "Fix the broken test", "committedDate": "2020-12-17T02:54:22Z", "type": "commit"}, {"oid": "d18c9ef9558231dfee13f80083fc7656e035948d", "url": "https://github.com/apollographql/apollo-android/commit/d18c9ef9558231dfee13f80083fc7656e035948d", "message": "Fix the binary compatibility", "committedDate": "2020-12-17T14:35:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzNzEwNg==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545137106", "bodyText": "This is still binary compatible", "author": "ansman", "createdAt": "2020-12-17T14:35:53Z", "path": "apollo-runtime/api.txt", "diffHunk": "@@ -373,38 +373,65 @@ package com.apollographql.apollo.response {\n \n package com.apollographql.apollo.subscription {\n \n+  public final class JsonWritersKt {\n+  }\n+\n   public interface OnSubscriptionManagerStateChangeListener {\n     method public void onStateChange(com.apollographql.apollo.subscription.SubscriptionManagerState!, com.apollographql.apollo.subscription.SubscriptionManagerState!);\n   }\n \n-  public abstract class OperationClientMessage {\n-    method public String toJsonString();\n-    method public abstract void writeToJson(com.apollographql.apollo.api.internal.json.JsonWriter);\n+  public abstract sealed class OperationClientMessage {\n+    method public final String toJsonString(boolean writePayloadAsJsonString = false, java.util.Map<java.lang.String,?> extensions = emptyMap());\n+    method public final String toJsonString(boolean writePayloadAsJsonString = false);\n+    method public final String toJsonString();\n+    method @kotlin.jvm.Throws(exceptionClasses=IOException::class) public final void writeToJson(com.apollographql.apollo.api.internal.json.JsonWriter writer);\n+    method public final void writeToJson(com.apollographql.apollo.api.internal.json.JsonWriter writer, boolean writePayloadAsJsonString);\n+    method @kotlin.jvm.Throws(exceptionClasses=IOException::class) public abstract void writeToJson(com.apollographql.apollo.api.internal.json.JsonWriter writer, boolean writePayloadAsJsonString = false, java.util.Map<java.lang.String,?> extensions = emptyMap());\n+    field public static final com.apollographql.apollo.subscription.OperationClientMessage.Companion Companion;\n+  }\n+\n+  public static final class OperationClientMessage.Companion {\n   }\n \n   public static final class OperationClientMessage.Init extends com.apollographql.apollo.subscription.OperationClientMessage {\n-    ctor public OperationClientMessage.Init(Map<String,Object>);\n-    method public void writeToJson(com.apollographql.apollo.api.internal.json.JsonWriter);\n+    ctor public OperationClientMessage.Init(java.util.Map<java.lang.String,?> connectionParams);", "originalCommit": "d18c9ef9558231dfee13f80083fc7656e035948d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzNzYxNA==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545137614", "bodyText": "All of the changes here are fine since it was not possible to subclass this class anyway.", "author": "ansman", "createdAt": "2020-12-17T14:36:36Z", "path": "apollo-runtime/api.txt", "diffHunk": "@@ -373,38 +373,65 @@ package com.apollographql.apollo.response {\n \n package com.apollographql.apollo.subscription {\n \n+  public final class JsonWritersKt {\n+  }\n+\n   public interface OnSubscriptionManagerStateChangeListener {\n     method public void onStateChange(com.apollographql.apollo.subscription.SubscriptionManagerState!, com.apollographql.apollo.subscription.SubscriptionManagerState!);\n   }\n \n-  public abstract class OperationClientMessage {\n-    method public String toJsonString();\n-    method public abstract void writeToJson(com.apollographql.apollo.api.internal.json.JsonWriter);\n+  public abstract sealed class OperationClientMessage {", "originalCommit": "d18c9ef9558231dfee13f80083fc7656e035948d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE1MjMzMA==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545152330", "bodyText": "Maybe call this method toBase64() ? It's used as a query param but the method itself uses Base64 and not urlencoding.", "author": "martinbonnin", "createdAt": "2020-12-17T14:55:33Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransport.kt", "diffHunk": "@@ -0,0 +1,165 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okhttp3.HttpUrl\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okio.Buffer\n+import java.lang.ref.WeakReference\n+import java.util.Base64\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * [SubscriptionTransport] implementation based on [WebSocket].\n+ */\n+class WebSocketSubscriptionTransport @JvmOverloads constructor(\n+    private val webSocketRequest: Request,\n+    private val webSocketConnectionFactory: WebSocket.Factory,\n+    private val callback: SubscriptionTransport.Callback,\n+    private val writePayloadAsJsonString: Boolean = false,\n+    private val extensions: Map<String, Any?> = emptyMap()\n+) : SubscriptionTransport {\n+  internal val webSocket = AtomicReference<WebSocket>()\n+  internal val webSocketListener = AtomicReference<WebSocketListener>()\n+\n+  override fun connect() {\n+    val webSocketListener = WebSocketListener(this)\n+    check(this.webSocketListener.compareAndSet(null, webSocketListener)) {\n+      \"Already connected\"\n+    }\n+    webSocket.set(webSocketConnectionFactory.newWebSocket(webSocketRequest, webSocketListener))\n+  }\n+\n+  override fun disconnect(message: OperationClientMessage) {\n+    webSocket.getAndSet(null)\n+        ?.close(1001, message.serializeToJson())\n+    release()\n+  }\n+\n+  override fun send(message: OperationClientMessage) {\n+    val socket = webSocket.get() ?: run {\n+      callback.onFailure(IllegalStateException(\"Send attempted on closed connection\"))\n+      return\n+    }\n+    socket.send(message.serializeToJson())\n+  }\n+\n+  internal fun onOpen() {\n+    callback.onConnected()\n+  }\n+\n+  internal fun onMessage(message: OperationServerMessage?) {\n+    callback.onMessage(message)\n+  }\n+\n+  internal fun onFailure(t: Throwable?) {\n+    try {\n+      callback.onFailure(t)\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  internal fun onClosed() {\n+    try {\n+      callback.onClosed()\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  private fun release() {\n+    webSocketListener.getAndSet(null)?.release()\n+    webSocket.set(null)\n+  }\n+\n+  private fun OperationClientMessage.serializeToJson(): String =\n+      toJsonString(\n+        writePayloadAsJsonString = writePayloadAsJsonString,\n+        extensions = extensions\n+    )\n+\n+  internal class WebSocketListener(delegate: WebSocketSubscriptionTransport) : okhttp3.WebSocketListener() {\n+    private val delegateRef = WeakReference(delegate)\n+\n+    override fun onOpen(webSocket: WebSocket, response: Response) {\n+      delegateRef.get()?.onOpen()\n+    }\n+\n+    override fun onMessage(webSocket: WebSocket, text: String) {\n+      delegateRef.get()?.onMessage(OperationServerMessage.fromJsonString(text))\n+    }\n+\n+    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {\n+      delegateRef.get()?.onFailure(t)\n+    }\n+\n+    override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    fun release() {\n+      delegateRef.clear()\n+    }\n+  }\n+\n+  /**\n+   * @param webSocketUrl The URL of the GraphQL WebSocket API\n+   * @param webSocketConnectionFactory The [WebSocket.Factory] to use to create the websockets\n+   * @param writePayloadAsJsonString If the payload should be serialized as a JSON String (default false). Set this to `true` for AWS\n+   *                                 AppSync integrations.\n+   * @param extensions Any additional extensions to when sending start commands. Must not be changed after this creating the factory.\n+   */\n+  class Factory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      private val writePayloadAsJsonString: Boolean = false,\n+      private val extensions: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory {\n+    private val webSocketRequest: Request = Request.Builder()\n+        .url(webSocketUrl)\n+        .addHeader(\"Sec-WebSocket-Protocol\", \"graphql-ws\")\n+        .addHeader(\"Cookie\", \"\")\n+        .build()\n+\n+    override fun create(callback: SubscriptionTransport.Callback): SubscriptionTransport =\n+        WebSocketSubscriptionTransport(webSocketRequest, webSocketConnectionFactory, callback, writePayloadAsJsonString, extensions)\n+  }\n+\n+  class AppSyncFactory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      authorization: Map<String, Any?>,\n+      payload: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory by Factory(\n+      webSocketUrl = webSocketUrl\n+          .let {\n+            HttpUrl.get(when {\n+              it.startsWith(\"ws://\", ignoreCase = true) -> \"http\" + it.drop(2)\n+              it.startsWith(\"wss://\", ignoreCase = true) -> \"https\" + it.drop(3)\n+              else -> it\n+            })\n+          }\n+          .newBuilder()\n+          .setQueryParameter(\"header\", authorization.encodeAsQueryParam())\n+          .setQueryParameter(\"payload\", payload.encodeAsQueryParam())\n+          .build()\n+          .toString(),\n+      webSocketConnectionFactory = webSocketConnectionFactory,\n+      writePayloadAsJsonString = true,\n+      extensions = mapOf(\"authorization\" to authorization)\n+  ) {\n+    companion object {\n+      private fun Map<String, Any?>.encodeAsQueryParam(): String {\n+        val buffer = Buffer()\n+        JsonWriter.of(buffer).jsonValue(this)\n+        return Base64.getUrlEncoder().encodeToString(buffer.readByteArray())", "originalCommit": "d18c9ef9558231dfee13f80083fc7656e035948d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5MTE0Mw==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545291143", "bodyText": "Done.", "author": "ansman", "createdAt": "2020-12-17T18:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE1MjMzMA=="}], "type": "inlineReview"}, {"oid": "d4d5739107434d4f99b9c3f4034d114f291dfca7", "url": "https://github.com/apollographql/apollo-android/commit/d4d5739107434d4f99b9c3f4034d114f291dfca7", "message": "Use Utils.writeToJson", "committedDate": "2020-12-17T15:15:41Z", "type": "commit"}, {"oid": "56e74d858766eca98a4e23c4cf4ee379ef1efda4", "url": "https://github.com/apollographql/apollo-android/commit/56e74d858766eca98a4e23c4cf4ee379ef1efda4", "message": "Use Utils.writeToJson", "committedDate": "2020-12-17T15:16:05Z", "type": "commit"}, {"oid": "334600f5cf428411e7b795a7ae19b06df21f1083", "url": "https://github.com/apollographql/apollo-android/commit/334600f5cf428411e7b795a7ae19b06df21f1083", "message": "Rename .java to .kt", "committedDate": "2020-12-17T15:44:11Z", "type": "commit"}, {"oid": "57ece09b6632d4cb29ba475511b54dd64edd0786", "url": "https://github.com/apollographql/apollo-android/commit/57ece09b6632d4cb29ba475511b54dd64edd0786", "message": "Convert OperationServerMessage to a sealed class", "committedDate": "2020-12-17T15:44:11Z", "type": "commit"}, {"oid": "fb914ea49077c9e137d0979696975dd17c3b4ce7", "url": "https://github.com/apollographql/apollo-android/commit/fb914ea49077c9e137d0979696975dd17c3b4ce7", "message": "Rewrite the writing and reading to use a serializer", "committedDate": "2020-12-17T18:03:18Z", "type": "forcePushed"}, {"oid": "5cf1552f6d55502fde7953f373e31f923c8015ae", "url": "https://github.com/apollographql/apollo-android/commit/5cf1552f6d55502fde7953f373e31f923c8015ae", "message": "Rewrite the writing and reading to use a serializer", "committedDate": "2020-12-17T18:08:42Z", "type": "forcePushed"}, {"oid": "fa441e1ac3e8cb69433860be8636c22e16261866", "url": "https://github.com/apollographql/apollo-android/commit/fa441e1ac3e8cb69433860be8636c22e16261866", "message": "Rewrite the writing and reading to use a serializer", "committedDate": "2020-12-17T18:53:21Z", "type": "commit"}, {"oid": "fa441e1ac3e8cb69433860be8636c22e16261866", "url": "https://github.com/apollographql/apollo-android/commit/fa441e1ac3e8cb69433860be8636c22e16261866", "message": "Rewrite the writing and reading to use a serializer", "committedDate": "2020-12-17T18:53:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQyNjY4Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545426686", "bodyText": "Any reason this is a class and not an object like ApolloOperationMessageSerializer ?", "author": "martinbonnin", "createdAt": "2020-12-17T21:51:43Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(", "originalCommit": "fa441e1ac3e8cb69433860be8636c22e16261866", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQyOTU1Mg==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545429552", "bodyText": "Because it accepts the authorization object and cannot be static for that reason.", "author": "ansman", "createdAt": "2020-12-17T21:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQyNjY4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzNTY3Nw==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545435677", "bodyText": "Damn, silly me \ud83d\udc4d", "author": "martinbonnin", "createdAt": "2020-12-17T22:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQyNjY4Ng=="}], "type": "inlineReview"}, {"oid": "5181d2d7691f2118f27e709a0ea06245f129d5e2", "url": "https://github.com/apollographql/apollo-android/commit/5181d2d7691f2118f27e709a0ea06245f129d5e2", "message": "Replace the data classes with regular classes", "committedDate": "2020-12-17T21:55:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQyODU0MQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545428541", "bodyText": "Is the implementation by delegation needed here ? I think the same result could be done by actually implementing the readServerMessage method\n  override fun readServerMessage(source: BufferedSource) = ApolloOperationMessageSerializer.readServerMessage(source)\n \n\nIt's a few more bytes but avoid using the \"implement by delegate\" pattern which isn't used a lot in the codebase and it might produce a bit less bytecode too.", "author": "martinbonnin", "createdAt": "2020-12-17T21:55:26Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(\n+    private val authorization: Map<String, Any?>\n+) : OperationMessageSerializer by ApolloOperationMessageSerializer {", "originalCommit": "fa441e1ac3e8cb69433860be8636c22e16261866", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "980a4cc7ed26f35a0777e57e7dfae66452421bda", "url": "https://github.com/apollographql/apollo-android/commit/980a4cc7ed26f35a0777e57e7dfae66452421bda", "message": "Replace delegation with method calls", "committedDate": "2020-12-17T21:59:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzMTQ3MA==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545431470", "bodyText": "Ouch. I guess we want to keep the ws:// to avoid confusing any user there, even if ultimately, okhttp is going to replace everything with http:// ? That feels a bit awkward but I don't really have another suggestion besides using java.net.URL that will end up equally verbose.\nEdit: thinking a bit more about it, if someone passes a http url, this will turn it into a ws url so maybe messing with java.net.URL is better?", "author": "martinbonnin", "createdAt": "2020-12-17T22:01:08Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(\n+    private val authorization: Map<String, Any?>\n+) : OperationMessageSerializer by ApolloOperationMessageSerializer {\n+  override fun OperationClientMessage.writeTo(sink: BufferedSink) {\n+    when (this) {\n+      is OperationClientMessage.Start -> JsonWriter.of(sink).use { writeTo(it) }\n+      is OperationClientMessage.Init,\n+      is OperationClientMessage.Stop,\n+      is OperationClientMessage.Terminate -> with(ApolloOperationMessageSerializer) { writeTo(sink) }\n+    }\n+  }\n+\n+  private fun OperationClientMessage.Start.writeTo(writer: JsonWriter) {\n+    writer.writeObject {\n+      name(ApolloOperationMessageSerializer.JSON_KEY_ID).value(subscriptionId)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_TYPE).value(OperationClientMessage.Start.TYPE)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_PAYLOAD).writeObject {\n+        name(JSON_KEY_DATA).writeObject {\n+          writePayloadContentsTo(writer)\n+        }\n+\n+        if (autoPersistSubscription) {\n+          name(ApolloOperationMessageSerializer.JSON_KEY_EXTENSIONS).writeObject {\n+            name(\"authorization\")\n+            Utils.writeToJson(authorization, writer)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  companion object {\n+    private const val JSON_KEY_DATA = \"data\"\n+\n+    @JvmOverloads\n+    @JvmStatic\n+    fun buildAppSyncWebSocketUrl(\n+        baseWebSocketUrl: String,\n+        authorization: Map<String, Any?>,\n+        payload: Map<String, Any?> = emptyMap(),\n+    ): String =\n+        baseWebSocketUrl\n+          .let { url ->\n+            when {\n+              url.startsWith(\"ws://\", ignoreCase = true) -> \"http\" + url.drop(2)\n+              url.startsWith(\"wss://\", ignoreCase = true) -> \"https\" + url.drop(3)\n+              else -> url\n+            }\n+          }\n+          .let { HttpUrl.get(it) }\n+          .newBuilder()\n+          .setQueryParameter(\"header\", authorization.base64Encode())\n+          .setQueryParameter(\"payload\", payload.base64Encode())\n+          .build()\n+          .toString()\n+          .let { url ->\n+            when {\n+              url.startsWith(\"http://\", ignoreCase = true) -> \"ws\" + url.drop(4)\n+              url.startsWith(\"https://\", ignoreCase = true) -> \"wss\" + url.drop(5)\n+              else -> url", "originalCommit": "5181d2d7691f2118f27e709a0ea06245f129d5e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzMzYxNA==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545433614", "bodyText": "Yeah, that's what I thought too. URL doesn't help here because it doesn't have any builder pattern.", "author": "ansman", "createdAt": "2020-12-17T22:05:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzMTQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5MjA5MQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545292091", "bodyText": "This is needed because the old, public, implementation of OperationServerMessage.writeToJson needs to write only the contents, not the outer object.", "author": "ansman", "createdAt": "2020-12-17T18:01:40Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/ApolloOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.BufferedSourceJsonReader\n+import com.apollographql.apollo.api.internal.json.JsonReader\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.ResponseJsonStreamReader\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import okio.BufferedSink\n+import okio.BufferedSource\n+import java.io.IOException\n+import java.util.Collections\n+\n+object ApolloOperationMessageSerializer : OperationMessageSerializer {\n+  override fun OperationClientMessage.writeTo(sink: BufferedSink) {\n+    JsonWriter.of(sink).use { writer ->\n+      writer.writeObject {\n+        writeContentsTo(writer)\n+      }\n+    }\n+  }\n+\n+  override fun readServerMessage(source: BufferedSource): OperationServerMessage =\n+      try {\n+        source.peek().use {\n+          BufferedSourceJsonReader(it).use { reader ->\n+            reader.readServerMessage()\n+          }\n+        }\n+      } catch (e: Exception) {\n+        OperationServerMessage.Unsupported(source.readUtf8())\n+      }\n+\n+  internal fun OperationClientMessage.writeContentsTo(writer: JsonWriter) {", "originalCommit": "af1b05fbc1dd88f9b7c7a745fce529b7b1218634", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5NzI4OQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545297289", "bodyText": "I moved this to an function instead of doing it automatically for you.", "author": "ansman", "createdAt": "2020-12-17T18:09:59Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(\n+    private val authorization: Map<String, Any?>\n+) : OperationMessageSerializer by ApolloOperationMessageSerializer {\n+  override fun OperationClientMessage.writeTo(sink: BufferedSink) {\n+    when (this) {\n+      is OperationClientMessage.Start -> JsonWriter.of(sink).use { writeTo(it) }\n+      is OperationClientMessage.Init,\n+      is OperationClientMessage.Stop,\n+      is OperationClientMessage.Terminate -> with(ApolloOperationMessageSerializer) { writeTo(sink) }\n+    }\n+  }\n+\n+  private fun OperationClientMessage.Start.writeTo(writer: JsonWriter) {\n+    writer.writeObject {\n+      name(ApolloOperationMessageSerializer.JSON_KEY_ID).value(subscriptionId)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_TYPE).value(OperationClientMessage.Start.TYPE)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_PAYLOAD).writeObject {\n+        name(JSON_KEY_DATA).writeObject {\n+          writePayloadContentsTo(writer)\n+        }\n+\n+        if (autoPersistSubscription) {\n+          name(ApolloOperationMessageSerializer.JSON_KEY_EXTENSIONS).writeObject {\n+            name(\"authorization\")\n+            Utils.writeToJson(authorization, writer)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  companion object {\n+    private const val JSON_KEY_DATA = \"data\"\n+\n+    @JvmOverloads\n+    fun buildAppSyncWebSocketUrl(", "originalCommit": "5cf1552f6d55502fde7953f373e31f923c8015ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzOTQ2MA==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545439460", "bodyText": "\ud83d\udc4d maybe rename to buildWebSocketUrl since there is already AppSync in AppSyncOperationMessageSerializer?", "author": "martinbonnin", "createdAt": "2020-12-17T22:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5NzI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5NzU3Mw==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545297573", "bodyText": "payload should always be empty but this future proofs it in case AWS decides that you need to pass something here.", "author": "ansman", "createdAt": "2020-12-17T18:10:29Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(\n+    private val authorization: Map<String, Any?>\n+) : OperationMessageSerializer by ApolloOperationMessageSerializer {\n+  override fun OperationClientMessage.writeTo(sink: BufferedSink) {\n+    when (this) {\n+      is OperationClientMessage.Start -> JsonWriter.of(sink).use { writeTo(it) }\n+      is OperationClientMessage.Init,\n+      is OperationClientMessage.Stop,\n+      is OperationClientMessage.Terminate -> with(ApolloOperationMessageSerializer) { writeTo(sink) }\n+    }\n+  }\n+\n+  private fun OperationClientMessage.Start.writeTo(writer: JsonWriter) {\n+    writer.writeObject {\n+      name(ApolloOperationMessageSerializer.JSON_KEY_ID).value(subscriptionId)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_TYPE).value(OperationClientMessage.Start.TYPE)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_PAYLOAD).writeObject {\n+        name(JSON_KEY_DATA).writeObject {\n+          writePayloadContentsTo(writer)\n+        }\n+\n+        if (autoPersistSubscription) {\n+          name(ApolloOperationMessageSerializer.JSON_KEY_EXTENSIONS).writeObject {\n+            name(\"authorization\")\n+            Utils.writeToJson(authorization, writer)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  companion object {\n+    private const val JSON_KEY_DATA = \"data\"\n+\n+    @JvmOverloads\n+    fun buildAppSyncWebSocketUrl(\n+        baseWebSocketUrl: String,\n+        authorization: Map<String, Any?>,\n+        payload: Map<String, Any?> = emptyMap(),", "originalCommit": "5cf1552f6d55502fde7953f373e31f923c8015ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5OTQ5Ng==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545299496", "bodyText": "I decided to re-add the original scheme since this is now returned rather than being used internally.", "author": "ansman", "createdAt": "2020-12-17T18:13:29Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(\n+    private val authorization: Map<String, Any?>\n+) : OperationMessageSerializer by ApolloOperationMessageSerializer {\n+  override fun OperationClientMessage.writeTo(sink: BufferedSink) {\n+    when (this) {\n+      is OperationClientMessage.Start -> JsonWriter.of(sink).use { writeTo(it) }\n+      is OperationClientMessage.Init,\n+      is OperationClientMessage.Stop,\n+      is OperationClientMessage.Terminate -> with(ApolloOperationMessageSerializer) { writeTo(sink) }\n+    }\n+  }\n+\n+  private fun OperationClientMessage.Start.writeTo(writer: JsonWriter) {\n+    writer.writeObject {\n+      name(ApolloOperationMessageSerializer.JSON_KEY_ID).value(subscriptionId)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_TYPE).value(OperationClientMessage.Start.TYPE)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_PAYLOAD).writeObject {\n+        name(JSON_KEY_DATA).writeObject {\n+          writePayloadContentsTo(writer)\n+        }\n+\n+        if (autoPersistSubscription) {\n+          name(ApolloOperationMessageSerializer.JSON_KEY_EXTENSIONS).writeObject {\n+            name(\"authorization\")\n+            Utils.writeToJson(authorization, writer)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  companion object {\n+    private const val JSON_KEY_DATA = \"data\"\n+\n+    @JvmOverloads\n+    fun buildAppSyncWebSocketUrl(\n+        baseWebSocketUrl: String,\n+        authorization: Map<String, Any?>,\n+        payload: Map<String, Any?> = emptyMap(),\n+    ): String =\n+        baseWebSocketUrl\n+          .let { url ->\n+            when {\n+              url.startsWith(\"ws://\", ignoreCase = true) -> \"http\" + url.drop(2)\n+              url.startsWith(\"wss://\", ignoreCase = true) -> \"https\" + url.drop(3)\n+              else -> url\n+            }\n+          }\n+          .let { HttpUrl.get(it) }\n+          .newBuilder()\n+          .setQueryParameter(\"header\", authorization.base64Encode())\n+          .setQueryParameter(\"payload\", payload.base64Encode())\n+          .build()\n+          .toString()\n+          .let { url ->\n+            when {\n+              url.startsWith(\"http://\", ignoreCase = true) -> \"ws\" + url.drop(4)\n+              url.startsWith(\"https://\", ignoreCase = true) -> \"wss\" + url.drop(5)", "originalCommit": "5cf1552f6d55502fde7953f373e31f923c8015ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5OTkyMQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545299921", "bodyText": "I made these data classes now. They don't have to be however.", "author": "ansman", "createdAt": "2020-12-17T18:14:15Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationClientMessage.kt", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.Subscription\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okio.Buffer\n+import java.io.IOException\n+\n+sealed class OperationClientMessage {\n+  @Deprecated(\"Use a serializer instead\")\n+  fun toJsonString(): String =\n+      try {\n+        val buffer = Buffer()\n+        with(ApolloOperationMessageSerializer) { writeTo(buffer) }\n+        buffer.readUtf8()\n+      } catch (e: IOException) {\n+        throw RuntimeException(\"Failed to serialize to json\", e)\n+      }\n+\n+  @Suppress(\"DeprecatedCallableAddReplaceWith\")\n+  @Throws(IOException::class)\n+  @Deprecated(\"Use a serializer instead\")\n+  fun writeToJson(writer: JsonWriter) {\n+    with(ApolloOperationMessageSerializer) { writeContentsTo(writer) }\n+  }\n+\n+  data class Init(val connectionParams: Map<String, Any?>) : OperationClientMessage() {", "originalCommit": "5cf1552f6d55502fde7953f373e31f923c8015ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMwMDI0MA==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545300240", "bodyText": "All properties here (besides scalarTypeAdapters) have to be @JvmField to keep backwards compatibility.", "author": "ansman", "createdAt": "2020-12-17T18:14:42Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationClientMessage.kt", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.Subscription\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okio.Buffer\n+import java.io.IOException\n+\n+sealed class OperationClientMessage {\n+  @Deprecated(\"Use a serializer instead\")\n+  fun toJsonString(): String =\n+      try {\n+        val buffer = Buffer()\n+        with(ApolloOperationMessageSerializer) { writeTo(buffer) }\n+        buffer.readUtf8()\n+      } catch (e: IOException) {\n+        throw RuntimeException(\"Failed to serialize to json\", e)\n+      }\n+\n+  @Suppress(\"DeprecatedCallableAddReplaceWith\")\n+  @Throws(IOException::class)\n+  @Deprecated(\"Use a serializer instead\")\n+  fun writeToJson(writer: JsonWriter) {\n+    with(ApolloOperationMessageSerializer) { writeContentsTo(writer) }\n+  }\n+\n+  data class Init(val connectionParams: Map<String, Any?>) : OperationClientMessage() {\n+    companion object {\n+      internal const val TYPE = \"connection_init\"\n+    }\n+  }\n+\n+  data class Start(\n+      @JvmField", "originalCommit": "5cf1552f6d55502fde7953f373e31f923c8015ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMwMDU0MQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545300541", "bodyText": "This has to be public now that the writing is done externally.", "author": "ansman", "createdAt": "2020-12-17T18:15:07Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationClientMessage.kt", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.Subscription\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okio.Buffer\n+import java.io.IOException\n+\n+sealed class OperationClientMessage {\n+  @Deprecated(\"Use a serializer instead\")\n+  fun toJsonString(): String =\n+      try {\n+        val buffer = Buffer()\n+        with(ApolloOperationMessageSerializer) { writeTo(buffer) }\n+        buffer.readUtf8()\n+      } catch (e: IOException) {\n+        throw RuntimeException(\"Failed to serialize to json\", e)\n+      }\n+\n+  @Suppress(\"DeprecatedCallableAddReplaceWith\")\n+  @Throws(IOException::class)\n+  @Deprecated(\"Use a serializer instead\")\n+  fun writeToJson(writer: JsonWriter) {\n+    with(ApolloOperationMessageSerializer) { writeContentsTo(writer) }\n+  }\n+\n+  data class Init(val connectionParams: Map<String, Any?>) : OperationClientMessage() {\n+    companion object {\n+      internal const val TYPE = \"connection_init\"\n+    }\n+  }\n+\n+  data class Start(\n+      @JvmField\n+      val subscriptionId: String,\n+      @JvmField\n+      val subscription: Subscription<*, *, *>,\n+      @JvmField\n+      val scalarTypeAdapters: ScalarTypeAdapters,", "originalCommit": "5cf1552f6d55502fde7953f373e31f923c8015ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMwMDc4MQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545300781", "bodyText": "This should ideally be an object but that is a breaking change so I just added hashCode and equals for consistency.", "author": "ansman", "createdAt": "2020-12-17T18:15:33Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationClientMessage.kt", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.Subscription\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okio.Buffer\n+import java.io.IOException\n+\n+sealed class OperationClientMessage {\n+  @Deprecated(\"Use a serializer instead\")\n+  fun toJsonString(): String =\n+      try {\n+        val buffer = Buffer()\n+        with(ApolloOperationMessageSerializer) { writeTo(buffer) }\n+        buffer.readUtf8()\n+      } catch (e: IOException) {\n+        throw RuntimeException(\"Failed to serialize to json\", e)\n+      }\n+\n+  @Suppress(\"DeprecatedCallableAddReplaceWith\")\n+  @Throws(IOException::class)\n+  @Deprecated(\"Use a serializer instead\")\n+  fun writeToJson(writer: JsonWriter) {\n+    with(ApolloOperationMessageSerializer) { writeContentsTo(writer) }\n+  }\n+\n+  data class Init(val connectionParams: Map<String, Any?>) : OperationClientMessage() {\n+    companion object {\n+      internal const val TYPE = \"connection_init\"\n+    }\n+  }\n+\n+  data class Start(\n+      @JvmField\n+      val subscriptionId: String,\n+      @JvmField\n+      val subscription: Subscription<*, *, *>,\n+      @JvmField\n+      val scalarTypeAdapters: ScalarTypeAdapters,\n+      @JvmField\n+      val autoPersistSubscription: Boolean,\n+      @JvmField\n+      val sendSubscriptionDocument: Boolean\n+  ) : OperationClientMessage() {\n+    companion object {\n+      internal const val TYPE = \"start\"\n+    }\n+  }\n+\n+  data class Stop(@JvmField val subscriptionId: String) : OperationClientMessage() {\n+    companion object {\n+      internal const val TYPE = \"stop\"\n+    }\n+  }\n+\n+  class Terminate : OperationClientMessage() {", "originalCommit": "5cf1552f6d55502fde7953f373e31f923c8015ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMwMTA5MQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545301091", "bodyText": "Same here, these are all data classes now. But this can easily be changed.", "author": "ansman", "createdAt": "2020-12-17T18:16:02Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationServerMessage.kt", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.apollographql.apollo.subscription\n+\n+import okio.Buffer\n+\n+sealed class OperationServerMessage {\n+  class ConnectionError(val payload: Map<String, Any?>) : OperationServerMessage() {\n+    override fun hashCode(): Int = javaClass.hashCode()\n+    override fun equals(other: Any?): Boolean = other is ConnectionError\n+\n+    companion object {\n+      const val TYPE = \"connection_error\"\n+    }\n+  }\n+\n+  class ConnectionAcknowledge : OperationServerMessage() {\n+    override fun hashCode(): Int = javaClass.hashCode()\n+    override fun equals(other: Any?): Boolean = other is ConnectionAcknowledge\n+\n+    companion object {\n+      const val TYPE = \"connection_ack\"\n+    }\n+  }\n+\n+  data class Data(@JvmField val id: String?, @JvmField val payload: Map<String, Any?>) : OperationServerMessage() {", "originalCommit": "5cf1552f6d55502fde7953f373e31f923c8015ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzMzE2NQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545433165", "bodyText": "What about writeClientMessage(sink: BufferedSink, message: OperationClientMessage) so that it's more symmetrical with readServerMessage ? I don't have a strong opinion there so either work for me though.", "author": "martinbonnin", "createdAt": "2020-12-17T22:04:50Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.apollographql.apollo.subscription\n+\n+import okio.BufferedSink\n+import okio.BufferedSource\n+import java.io.IOException\n+\n+interface OperationMessageSerializer {\n+  @Throws(IOException::class)\n+  fun OperationClientMessage.writeTo(sink: BufferedSink)", "originalCommit": "5181d2d7691f2118f27e709a0ea06245f129d5e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzNDMxOQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545434319", "bodyText": "Me neither. I figured the receiver pattern worked well because it would be like a function on OperationClientMessage so the implementation looks cleaner.", "author": "ansman", "createdAt": "2020-12-17T22:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzMzE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzNDAwMQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545434001", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Deprecated(\"This method should be used any more. Instead you should use a serializer\")\n          \n          \n            \n                @Deprecated(\"This method is deprecated. Use an OperationMessageSerializer instead.\")", "author": "martinbonnin", "createdAt": "2020-12-17T22:06:37Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationServerMessage.kt", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.apollographql.apollo.subscription\n+\n+import okio.Buffer\n+\n+sealed class OperationServerMessage {\n+  companion object {\n+    const val JSON_KEY_ID = \"id\"\n+    const val JSON_KEY_TYPE = \"type\"\n+    const val JSON_KEY_PAYLOAD = \"payload\"\n+\n+    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n+    @Deprecated(\"This method should be used any more. Instead you should use a serializer\")", "originalCommit": "5181d2d7691f2118f27e709a0ea06245f129d5e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzNDQyOQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545434429", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Deprecated(\"Use a serializer instead\")\n          \n          \n            \n                @Deprecated(\"This method is deprecated. Use an OperationMessageSerializer instead.\")", "author": "martinbonnin", "createdAt": "2020-12-17T22:07:15Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationClientMessage.kt", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.Subscription\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okio.Buffer\n+import java.io.IOException\n+\n+sealed class OperationClientMessage {\n+  @Deprecated(\"Use a serializer instead\")\n+  fun toJsonString(): String =\n+      try {\n+        val buffer = Buffer()\n+        with(ApolloOperationMessageSerializer) { writeTo(buffer) }\n+        buffer.readUtf8()\n+      } catch (e: IOException) {\n+        throw RuntimeException(\"Failed to serialize to json\", e)\n+      }\n+\n+  @Suppress(\"DeprecatedCallableAddReplaceWith\")\n+  @Throws(IOException::class)\n+  @Deprecated(\"Use a serializer instead\")", "originalCommit": "5181d2d7691f2118f27e709a0ea06245f129d5e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzNDUwMA==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545434500", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Deprecated(\"Use a serializer instead\")\n          \n          \n            \n                @Deprecated(\"This method is deprecated. Use an OperationMessageSerializer instead.\")", "author": "martinbonnin", "createdAt": "2020-12-17T22:07:25Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationClientMessage.kt", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.Subscription\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okio.Buffer\n+import java.io.IOException\n+\n+sealed class OperationClientMessage {\n+  @Deprecated(\"Use a serializer instead\")", "originalCommit": "5181d2d7691f2118f27e709a0ea06245f129d5e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "06b5ac33de7eb6631c136c68b62c1cd9dc693a72", "url": "https://github.com/apollographql/apollo-android/commit/06b5ac33de7eb6631c136c68b62c1cd9dc693a72", "message": "Update the deprecation message", "committedDate": "2020-12-17T22:07:41Z", "type": "commit"}, {"oid": "e4ac3a093bb7c711619783ac26a5e6b682de448b", "url": "https://github.com/apollographql/apollo-android/commit/e4ac3a093bb7c711619783ac26a5e6b682de448b", "message": "Rename buildAppSyncWebSocketUrl to buildWebSocketUrl", "committedDate": "2020-12-17T22:18:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Nzc3Nw==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545447777", "bodyText": "This reads weirdly. I know it works but it can be tempting to replace with ApolloOperationMessageSerializer.writeTo(sink), which doesn't. That's an argument to rename writeTo to writeClientMessage(sink, message). This is what moshi does for an exemple and will be less surprising for users?", "author": "martinbonnin", "createdAt": "2020-12-17T22:34:44Z", "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import okio.BufferedSource\n+import java.net.URL\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(\n+    private val authorization: Map<String, Any?>\n+) : OperationMessageSerializer {\n+  override fun OperationClientMessage.writeTo(sink: BufferedSink) {\n+    when (this) {\n+      is OperationClientMessage.Start -> JsonWriter.of(sink).use { writeTo(it) }\n+      is OperationClientMessage.Init,\n+      is OperationClientMessage.Stop,\n+      is OperationClientMessage.Terminate -> with(ApolloOperationMessageSerializer) { writeTo(sink) }", "originalCommit": "e4ac3a093bb7c711619783ac26a5e6b682de448b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0ODY1NQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545448655", "bodyText": "Yeah, the caller ergonomics isn't great. Will change.", "author": "ansman", "createdAt": "2020-12-17T22:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Nzc3Nw=="}], "type": "inlineReview"}, {"oid": "283cd1f92b9240f518c19f8d8a17c4b081835590", "url": "https://github.com/apollographql/apollo-android/commit/283cd1f92b9240f518c19f8d8a17c4b081835590", "message": "Rename .java to .kt", "committedDate": "2020-12-18T02:06:54Z", "type": "commit"}, {"oid": "e00cd9ef9b8f32bf4fc81feb8afde91c46dfc7f6", "url": "https://github.com/apollographql/apollo-android/commit/e00cd9ef9b8f32bf4fc81feb8afde91c46dfc7f6", "message": "Add tests and documentation", "committedDate": "2020-12-18T02:06:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyNjkxNQ==", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545526915", "bodyText": "I ended up rewriting this to Kotlin too since it had some warnings.", "author": "ansman", "createdAt": "2020-12-18T02:10:16Z", "path": "apollo-runtime/src/test/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransportMessageTest.kt", "diffHunk": "@@ -0,0 +1,191 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.google.common.truth.Truth.assertThat\n+import okhttp3.Protocol\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okhttp3.WebSocketListener\n+import okio.ByteString\n+import org.junit.Before\n+import org.junit.Test\n+import java.math.BigDecimal\n+\n+class WebSocketSubscriptionTransportMessageTest {", "originalCommit": "e00cd9ef9b8f32bf4fc81feb8afde91c46dfc7f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}