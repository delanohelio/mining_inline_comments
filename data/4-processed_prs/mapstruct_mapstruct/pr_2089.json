{"pr_number": 2089, "pr_title": "Add EnumTransformationStrategy SPI ", "pr_createdAt": "2020-05-03T09:57:44Z", "pr_url": "https://github.com/mapstruct/mapstruct/pull/2089", "timeline": [{"oid": "0ee86c75a2df1968c1f6a050039fb196c4a77187", "url": "https://github.com/mapstruct/mapstruct/commit/0ee86c75a2df1968c1f6a050039fb196c4a77187", "message": "Spike EnumTransformationStrategy", "committedDate": "2020-05-03T09:51:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NDE4Mw==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419094183", "bodyText": "Maybe a different name then type? As far as I understood this has to be the same value than nameTransformStrategy in the new EnumMapping annotation?", "author": "chris922", "createdAt": "2020-05-03T12:07:04Z", "path": "processor/src/main/java/org/mapstruct/ap/spi/SuffixEnumTransformationStrategy.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright MapStruct Authors.\n+ *\n+ * Licensed under the Apache License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.mapstruct.ap.spi;\n+\n+/**\n+ * @author Filip Hrisafov\n+ */\n+public class SuffixEnumTransformationStrategy implements EnumTransformationStrategy {\n+\n+    @Override\n+    public String getType() {", "originalCommit": "0ee86c75a2df1968c1f6a050039fb196c4a77187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTExMjA1Nw==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419112057", "bodyText": "Yes this is the name / type of the strategy that you can reference in nameTransformStrategy. What would you propose? I of course need to add Javadoc", "author": "filiphr", "createdAt": "2020-05-03T14:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NDE4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzNTI5OA==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419135298", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String getType() {\n          \n          \n            \n                public String getStrategyName() {\n          \n      \n    \n    \n  \n\nMaybe?", "author": "chris922", "createdAt": "2020-05-03T17:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NDE4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzNjc5Nw==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419136797", "bodyText": "Good idea. Will apply it", "author": "filiphr", "createdAt": "2020-05-03T17:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NDE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NDQ0Mw==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419094443", "bodyText": "What are the reasons to have a new annotation and not reusing ValueMapping? Isn't ValueMapping also meant for enumerations?", "author": "chris922", "createdAt": "2020-05-03T12:09:20Z", "path": "core/src/main/java/org/mapstruct/EnumMapping.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright MapStruct Authors.\n+ *\n+ * Licensed under the Apache License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.mapstruct;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * @author Filip Hrisafov\n+ */\n+@Target(ElementType.METHOD)\n+@Retention(RetentionPolicy.CLASS)\n+public @interface EnumMapping {", "originalCommit": "0ee86c75a2df1968c1f6a050039fb196c4a77187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTExMjE5OQ==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419112199", "bodyText": "I was thinking the same thing. The thing with @ValueMapping is that it is closer to @Mapping. It has a source and target. The new @EnumMapping is closer to @BeanMapping. The idea is to be able to configure general mapping only once for value mappings", "author": "filiphr", "createdAt": "2020-05-03T14:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzNTYwMw==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419135603", "bodyText": "Ahh, correct! @ValueMapping could be used multiple times", "author": "chris922", "createdAt": "2020-05-03T17:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NDQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NDUwOQ==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419094509", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String nameTransformStrategy();\n          \n          \n            \n                String nameTransformationStrategy();\n          \n      \n    \n    \n  \n\n?", "author": "chris922", "createdAt": "2020-05-03T12:09:46Z", "path": "core/src/main/java/org/mapstruct/EnumMapping.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright MapStruct Authors.\n+ *\n+ * Licensed under the Apache License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.mapstruct;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * @author Filip Hrisafov\n+ */\n+@Target(ElementType.METHOD)\n+@Retention(RetentionPolicy.CLASS)\n+public @interface EnumMapping {\n+\n+    String nameTransformStrategy();", "originalCommit": "0ee86c75a2df1968c1f6a050039fb196c4a77187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTExMjI1OQ==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419112259", "bodyText": "The suggestion makes sense. I'll do it", "author": "filiphr", "createdAt": "2020-05-03T14:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NDUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NDc3MQ==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419094771", "bodyText": "Null check required or could it never be null when build is called? The initializeEnumTransformationStrategy that will be called after this if-clause includes a null check", "author": "chris922", "createdAt": "2020-05-03T12:11:58Z", "path": "processor/src/main/java/org/mapstruct/ap/internal/model/ValueMappingMethod.java", "diffHunk": "@@ -61,7 +67,18 @@ public Builder valueMappings(List<ValueMappingOptions> valueMappings) {\n             return this;\n         }\n \n-        public ValueMappingMethod build( ) {\n+        public Builder enumMapping(EnumMappingOptions enumMapping) {\n+            this.enumMapping = enumMapping;\n+            return this;\n+        }\n+\n+        public ValueMappingMethod build() {\n+\n+            if ( !enumMapping.isValid() ) {", "originalCommit": "0ee86c75a2df1968c1f6a050039fb196c4a77187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTExMjQ4MA==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419112480", "bodyText": "Good spot. I'll need to verify this again. In theory it can never be null, since we always create it (like the BeanMappingOptions). All tests are green as well, so the if condition is never hit it seems.", "author": "filiphr", "createdAt": "2020-05-03T14:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NDc3MQ=="}], "type": "inlineReview"}, {"oid": "117dacb831d4b3681f26cfd1c7a724dedf3501b3", "url": "https://github.com/mapstruct/mapstruct/commit/117dacb831d4b3681f26cfd1c7a724dedf3501b3", "message": "Apply review comments", "committedDate": "2020-05-03T17:27:34Z", "type": "commit"}, {"oid": "659fe28b79a550058a209ca12aff5c41c82e2794", "url": "https://github.com/mapstruct/mapstruct/commit/659fe28b79a550058a209ca12aff5c41c82e2794", "message": "Add documentation", "committedDate": "2020-05-03T17:44:12Z", "type": "commit"}, {"oid": "bacc9f02135d34a2b79d1431e80bc9921f0b258a", "url": "https://github.com/mapstruct/mapstruct/commit/bacc9f02135d34a2b79d1431e80bc9921f0b258a", "message": "Fix typo in javadoc", "committedDate": "2020-05-03T17:49:53Z", "type": "commit"}, {"oid": "1d619fd4be5f87ef9e58e76e0ed240a06a3964d2", "url": "https://github.com/mapstruct/mapstruct/commit/1d619fd4be5f87ef9e58e76e0ed240a06a3964d2", "message": "Use getStrategyName instead of getType", "committedDate": "2020-05-03T17:53:01Z", "type": "commit"}, {"oid": "5a0d7decc3d027beb036b9b7dfe57df003a7591a", "url": "https://github.com/mapstruct/mapstruct/commit/5a0d7decc3d027beb036b9b7dfe57df003a7591a", "message": "Fix checkstyle", "committedDate": "2020-05-03T18:04:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNTQwMw==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419335403", "bodyText": "is this the inverse? What happens with inverse mappings?", "author": "sjaakd", "createdAt": "2020-05-04T10:12:42Z", "path": "documentation/src/main/asciidoc/chapter-8-mapping-values.asciidoc", "diffHunk": "@@ -159,3 +159,106 @@ MapStruct supports enum to a String mapping along the same lines as is described\n 2. Similarity: `<ANY_UNMAPPED`> stops after handling defined mapping and proceeds to the switch/default clause value.\n 3. Similarity: `<ANY_REMAINING>` will create a mapping for each target enum constant and proceed to the switch/default clause value.\n 4. Difference: A switch/default value needs to be provided to have a determined outcome (enum has a limited set of values, `String` has unlimited options). Failing to specify `<ANY_REMAINING>` or `<ANY_UNMAPPED`> will result in a warning.\n+\n+=== Custom name transformation\n+\n+When no `@ValueMapping`(s) are defined then each constant from the source enum is mapped to a constant with the same name in the target enum type.\n+However, there are cases where the source enum needs to be transformed before doing the mapping.\n+E.g. a suffix needs to be applied to map from the source into the target enum.\n+\n+.Enum types\n+====\n+[source, java, linenums]\n+[subs=\"verbatim,attributes\"]\n+----\n+public enum CheeseType {\n+\n+    BRIE,\n+    ROQUEFORT\n+}\n+\n+public enum CheeseTypeSuffixed {\n+\n+    BRIE_TYPE,\n+    ROQUEFORT_TYPE\n+}\n+----\n+====\n+\n+.Enum mapping method with custom name transformation strategy\n+====\n+[source, java, linenums]\n+[subs=\"verbatim,attributes\"]\n+----\n+@Mapper\n+public interface CheeseMapper {\n+\n+    CheeseMapper INSTANCE = Mappers.getMapper( CheeseMapper.class );\n+\n+    @EnumMapping(nameTransformationStrategy = \"suffix\", configuration = \"_TYPE\")\n+    CheeseTypeSuffixed map(CheeseType cheese);\n+\n+    @InheritInverseConfiguration\n+    CheeseType map(CheeseTypeSuffix cheese);\n+}\n+----\n+====\n+\n+.Enum mapping method with custom name transformation strategy result\n+====\n+[source, java, linenums]\n+[subs=\"verbatim,attributes\"]\n+----\n+// GENERATED CODE\n+public class CheeseSuffixMapperImpl implements CheeseSuffixMapper {\n+\n+    @Override\n+    public CheeseTypeSuffixed map(CheeseType cheese) {\n+        if ( cheese == null ) {\n+            return null;\n+        }\n+\n+        CheeseTypeSuffixed cheeseTypeSuffixed;\n+\n+        switch ( cheese ) {\n+            case BRIE: cheeseTypeSuffixed = CheeseTypeSuffixed.BRIE_TYPE;\n+            break;\n+            case ROQUEFORT: cheeseTypeSuffixed = CheeseTypeSuffixed.ROQUEFORT_TYPE;\n+            break;\n+            default: throw new IllegalArgumentException( \"Unexpected enum constant: \" + cheese );\n+        }\n+\n+        return cheeseTypeSuffixed;\n+    }\n+\n+    @Override\n+    public CheeseType map(CheeseTypeSuffixed cheese) {\n+        if ( cheese == null ) {\n+            return null;\n+        }\n+\n+        CheeseType cheeseType;\n+\n+        switch ( cheese ) {\n+            case BRIE_TYPE: cheeseType = CheeseType.BRIE;\n+            break;\n+            case ROQUEFORT_TYPE: cheeseType = CheeseType.ROQUEFORT;\n+            break;\n+            default: throw new IllegalArgumentException( \"Unexpected enum constant: \" + cheese );\n+        }\n+\n+        return cheeseType;\n+    }\n+}\n+----\n+====\n+\n+MapStruct provides the following out of the box enum name transformation strategies:\n+\n+* _suffix_ - Applies a suffix on the source enum\n+* _stripSuffix_ - Strips a suffix from the source enum", "originalCommit": "5a0d7decc3d027beb036b9b7dfe57df003a7591a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYwMjIyMA==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r422602220", "bodyText": "Yes and no. I've implemented the reverse a tiny bit different. Have a look at\nhttps://github.com/mapstruct/mapstruct/pull/2089/files#diff-281a6edb3173036b540a79288468f9ddR157-R186\nBasically, I am applying the normal strategy on the target enum instead of the source enum. That way no special handling is needed", "author": "filiphr", "createdAt": "2020-05-10T07:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNTQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNjI4NA==", "url": "https://github.com/mapstruct/mapstruct/pull/2089#discussion_r419336284", "bodyText": "ah.. here it is..", "author": "sjaakd", "createdAt": "2020-05-04T10:14:30Z", "path": "processor/src/main/java/org/mapstruct/ap/internal/model/source/EnumMappingOptions.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright MapStruct Authors.\n+ *\n+ * Licensed under the Apache License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.mapstruct.ap.internal.model.source;\n+\n+import java.util.Map;\n+import javax.lang.model.element.ExecutableElement;\n+\n+import org.mapstruct.ap.internal.gem.EnumMappingGem;\n+import org.mapstruct.ap.internal.util.FormattingMessager;\n+import org.mapstruct.ap.internal.util.Strings;\n+import org.mapstruct.ap.spi.EnumTransformationStrategy;\n+\n+import static org.mapstruct.ap.internal.util.Message.ENUMMAPPING_INCORRECT_TRANSFORMATION_STRATEGY;\n+\n+/**\n+ * @author Filip Hrisafov\n+ */\n+public class EnumMappingOptions extends DelegatingOptions {\n+\n+    private final EnumMappingGem enumMapping;\n+    private final boolean inverse;\n+    private final boolean valid;\n+\n+    private EnumMappingOptions(EnumMappingGem enumMapping, boolean inverse, boolean valid, DelegatingOptions next) {\n+        super( next );\n+        this.enumMapping = enumMapping;\n+        this.inverse = inverse;\n+        this.valid = valid;\n+    }\n+\n+    @Override\n+    public boolean hasAnnotation() {\n+        return enumMapping != null;\n+    }\n+\n+    public boolean isValid() {\n+        return valid;\n+    }\n+\n+    public String getNameTransformationStrategy() {\n+        return enumMapping.nameTransformationStrategy().get();\n+    }\n+\n+    public String getNameTransformationConfiguration() {\n+        return enumMapping.configuration().get();\n+    }\n+\n+    public boolean isInverse() {\n+        return inverse;\n+    }\n+\n+    public EnumMappingOptions inverse() {", "originalCommit": "5a0d7decc3d027beb036b9b7dfe57df003a7591a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}