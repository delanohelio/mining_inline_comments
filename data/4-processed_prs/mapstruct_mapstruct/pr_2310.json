{"pr_number": 2310, "pr_title": "#2301 Implicitly ignore forward inherited mappings from different method types", "pr_createdAt": "2020-12-19T19:02:40Z", "pr_url": "https://github.com/mapstruct/mapstruct/pull/2310", "timeline": [{"oid": "fb69376392cedbde253545d490b4be70095a9fde", "url": "https://github.com/mapstruct/mapstruct/commit/fb69376392cedbde253545d490b4be70095a9fde", "message": "#2301 Implicitly ignore forward inherited mappings from different method types", "committedDate": "2020-12-19T19:10:19Z", "type": "commit"}, {"oid": "fb69376392cedbde253545d490b4be70095a9fde", "url": "https://github.com/mapstruct/mapstruct/commit/fb69376392cedbde253545d490b4be70095a9fde", "message": "#2301 Implicitly ignore forward inherited mappings from different method types", "committedDate": "2020-12-19T19:10:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDE3OTk4Ng==", "url": "https://github.com/mapstruct/mapstruct/pull/2310#discussion_r550179986", "bodyText": "I don't get it.. Why would you not inherit a configuration in this case? The whole idea of inheritance is that you don't have to specify mappings for update and create mappings seperately. I'm using this all the time in my own code (defining one config and then using it for both create- and update mappings. That will break now, right?\nAnd why only forward and not reverse? That seems to me like asymetry too..", "author": "sjaakd", "createdAt": "2020-12-30T12:35:14Z", "path": "processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java", "diffHunk": "@@ -938,6 +938,15 @@ private boolean handleDefinedMapping(MappingReference mappingRef, Type resultTyp\n \n             if ( targetWriteAccessor == null ) {\n                 if ( targetReadAccessor == null ) {\n+                    if ( mapping.getInheritContext() != null && mapping.getInheritContext().isForwarded() &&\n+                        mapping.getInheritContext().getTemplateMethod().isUpdateMethod() != method.isUpdateMethod() ) {", "originalCommit": "fb69376392cedbde253545d490b4be70095a9fde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0Mjc4Nw==", "url": "https://github.com/mapstruct/mapstruct/pull/2310#discussion_r550442787", "bodyText": "This is an extremely special case, which was handled like this in 1.3 as well. Basically it ignores explicitly defined @Mapping for properties that have no write and read accessors once they are inherited.\nTake the test case. The normal mapping has write accessors for dependantBuildRecord and dependantBuildRecords (due to the builder) and you explicitly ignore both. However, the update mapping does not have an accessor for dependantBuildRecord and thus the @InheritConfiguration right now leads to an error in compilation.\nBefore this checks were only done when the TargetReference was created and those were done only on the template method. Right now they are done when handling the mapping and thus we have to explicitly handle it here.\nNote: this is only done for the error handling, i.e. no target read and write accessors are available and we only ignore the \"error\" in this special edge case.", "author": "filiphr", "createdAt": "2020-12-31T09:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDE3OTk4Ng=="}], "type": "inlineReview"}]}