{"pr_number": 2100, "pr_title": "Add EnumNamingStrategy SPI", "pr_createdAt": "2020-05-18T05:26:20Z", "pr_url": "https://github.com/mapstruct/mapstruct/pull/2100", "timeline": [{"oid": "35622df45c2080b176f0f4aeed94b26cfdb4a8b8", "url": "https://github.com/mapstruct/mapstruct/commit/35622df45c2080b176f0f4aeed94b26cfdb4a8b8", "message": "Add EnumNamingStrategy SPI\n\nAdd a new EnumNamingStrategy SPI which can be used for customizing the way enums are matched by name.\nIt is similar to the AccessorNamingStrategy such that it allows implementors to provide a custom way of defining a property.", "committedDate": "2020-05-18T05:23:53Z", "type": "commit"}, {"oid": "5d7d672f572e055a79b9855b1f00e3a6aa25bc2b", "url": "https://github.com/mapstruct/mapstruct/commit/5d7d672f572e055a79b9855b1f00e3a6aa25bc2b", "message": "Add getDefaultNullEnumConstant to the EnumNamingStrategy", "committedDate": "2020-05-21T09:05:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0Mzk2Mg==", "url": "https://github.com/mapstruct/mapstruct/pull/2100#discussion_r428743962", "bodyText": "shouldn't CheeseTypeMapperImpl not implement CheeseTypeMapper?\nThe mapper you defined has signature\n@Mapper\n public interface CheeseTypeMapper {\n\n     CheeseType map(CheeseTypeProtobuf cheese);\n\n     CheeseTypeProtobuf map(CheeseType cheese);\n }\nI'm reading this now several times, and I don't understand", "author": "sjaakd", "createdAt": "2020-05-21T15:50:09Z", "path": "documentation/src/main/asciidoc/chapter-13-using-mapstruct-spi.asciidoc", "diffHunk": "@@ -199,6 +199,164 @@ include::{processor-ap-main}/spi/NoOpBuilderProvider.java[tag=documentation]\n ----\n ====\n \n+[[custom-enum-naming-strategy]]\n+=== Custom Enum Naming Strategy\n+\n+MapStruct offers the possibility to override the `EnumNamingStrategy` via the Service Provider Interface (SPI).\n+A nice example is the use of the Protobuf Enum [style guide](https://developers.google.com/protocol-buffers/docs/style#enums).\n+\n+.Normal Enum\n+====\n+[source, java, linenums]\n+[subs=\"verbatim,attributes\"]\n+----\n+public enum CheeseType {\n+    BRIE,\n+    ROQUEFORT;\n+}\n+----\n+====\n+\n+.Protobuf generated enum\n+====\n+[source, java, linenums]\n+[subs=\"verbatim,attributes\"]\n+----\n+public enum CheeseTypeProtobuf implements ProtocolMessageEnum {\n+\n+    CHEESE_TYPE_PROTOBUF_UNSPECIFIED,\n+    CHEESE_TYPE_PROTOBUF_BRIE,\n+    CHEESE_TYPE_PROTOBUF_ROQUEFORT;\n+}\n+----\n+====\n+\n+We want `CheeseType` and `CheeseTypeProtobuf` to be mapped without the need to manually define the value mappings:\n+\n+.Protobuf enum mapping\n+====\n+[source, java, linenums]\n+[subs=\"verbatim,attributes\"]\n+----\n+@Mapper\n+public interface CheeseTypeMapper {\n+\n+    CheeseType map(CheeseTypeProtobuf cheese);\n+\n+    CheeseTypeProtobuf map(CheeseType cheese);\n+}\n+----\n+====\n+\n+This can be achieved with implementing the SPI `org.mapstruct.ap.spi.EnumNamingStrategy` as in the following example.\n+Here\u2019s an implemented `org.mapstruct.ap.spi.EnumNamingStrategy`:\n+\n+.Custom Protobuf enum naming strategy\n+====\n+[source, java, linenums]\n+[subs=\"verbatim,attributes\"]\n+----\n+public class ProtobufEnumNamingStrategy extends DefaultEnumNamingStrategy {\n+\n+    private static final String PROTOBUF_ENUM_INTERFACE = \"com.google.protobuf.ProtocolMessageEnum\";\n+    private static final String PROTOBUF_LITE_ENUM_INTERFACE = \"com.google.protobuf.Internal.EnumLite\";\n+\n+    protected final Map<TypeElement, Boolean> knownEnums = new HashMap<>();\n+\n+    @Override\n+    public void init(MapStructProcessingEnvironment processingEnvironment) {\n+        super.init( processingEnvironment );\n+    }\n+\n+    @Override\n+    public String getEnumConstant(TypeElement enumType, String enumConstant) {\n+\n+        Boolean isProtobufEnum = knownEnums.computeIfAbsent( enumType, this::isProtobufEnum );\n+\n+        if ( isProtobufEnum ) {\n+            String matchingEnum = removeEnumNamePrefixFromConstant( enumType, enumConstant );\n+            if ( \"UNSPECIFIED\" .equals( matchingEnum ) ) {\n+                return MappingConstants.NULL;\n+            }\n+            return matchingEnum;\n+        }\n+\n+        return super.getEnumConstant( enumType, enumConstant );\n+    }\n+\n+    private boolean isProtobufEnum(TypeElement enumType) {\n+        for ( TypeMirror enumInterface : enumType.getInterfaces() ) {\n+            Name interfaceFqn = ( (TypeElement) typeUtils.asElement( enumInterface ) ).getQualifiedName();\n+            if ( interfaceFqn.contentEquals( PROTOBUF_ENUM_INTERFACE ) ||\n+                interfaceFqn.contentEquals( PROTOBUF_LITE_ENUM_INTERFACE ) ) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private String removeEnumNamePrefixFromConstant(TypeElement enumType, String sourceEnumValue) {\n+        String enumName = enumType.getSimpleName().toString();\n+        String prefix = CaseFormat.UPPER_CAMEL.to( CaseFormat.UPPER_UNDERSCORE, enumName );\n+\n+        return sourceEnumValue.replace( prefix + \"_\", \"\" );\n+    }\n+}\n+----\n+====\n+\n+The generated code then for the `CheeseMapper` looks like:\n+\n+.Generated Protobuf CheeseTypeMapper\n+====\n+[source, java, linenums]\n+[subs=\"verbatim,attributes\"]\n+----\n+public class CheeseTypeMapperImpl implements CheeseTypeMapper {\n+\n+    @Override\n+    public CheeseType map(CustomCheeseType cheese) {", "originalCommit": "5d7d672f572e055a79b9855b1f00e3a6aa25bc2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3MTQ1Nw==", "url": "https://github.com/mapstruct/mapstruct/pull/2100#discussion_r428871457", "bodyText": "Seems like I have made a mistake there. Thanks for spotting it", "author": "filiphr", "createdAt": "2020-05-21T19:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0Mzk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0ODAxMA==", "url": "https://github.com/mapstruct/mapstruct/pull/2100#discussion_r428748010", "bodyText": "It's not clear from the example what you want to achieve.. In depth protobuf knowledge is needed to know, from what I now (seem to) understand  that protobuf generates an enum from a specification file with values that are unique in the realm of the interface. Hence it seems to prefix stuf with the enum name. Mapping to your business enum requires you to follow a fixed pattens.", "author": "sjaakd", "createdAt": "2020-05-21T15:54:52Z", "path": "documentation/src/main/asciidoc/chapter-13-using-mapstruct-spi.asciidoc", "diffHunk": "@@ -199,6 +199,164 @@ include::{processor-ap-main}/spi/NoOpBuilderProvider.java[tag=documentation]\n ----\n ====\n \n+[[custom-enum-naming-strategy]]\n+=== Custom Enum Naming Strategy\n+\n+MapStruct offers the possibility to override the `EnumNamingStrategy` via the Service Provider Interface (SPI).\n+A nice example is the use of the Protobuf Enum [style guide](https://developers.google.com/protocol-buffers/docs/style#enums).\n+", "originalCommit": "5d7d672f572e055a79b9855b1f00e3a6aa25bc2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0ODY0NA==", "url": "https://github.com/mapstruct/mapstruct/pull/2100#discussion_r428748644", "bodyText": "what happens if you want to do 'regular' enum mappings (without the strategy applied) in the same mapper??", "author": "sjaakd", "createdAt": "2020-05-21T15:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0ODAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc5MTM1NA==", "url": "https://github.com/mapstruct/mapstruct/pull/2100#discussion_r428791354", "bodyText": "what I miss is how this interacts with the enum mechanism in the 'other' PR..", "author": "sjaakd", "createdAt": "2020-05-21T17:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0ODAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3MjgxOQ==", "url": "https://github.com/mapstruct/mapstruct/pull/2100#discussion_r428872819", "bodyText": "I will try to iterate over this documentation. Basically this offers an alternative enum name mapping for some enums. Like the one in the tests marked with CustomEnumMarker.\nThis does not interact with the other enum mechanism a lot. It is orthogonal to it. You can actually use them in parallel. The other is on a case by case basis.", "author": "filiphr", "createdAt": "2020-05-21T19:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0ODAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0MTc2OA==", "url": "https://github.com/mapstruct/mapstruct/pull/2100#discussion_r428941768", "bodyText": "ok.", "author": "sjaakd", "createdAt": "2020-05-21T22:05:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0ODAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc5NDQzNw==", "url": "https://github.com/mapstruct/mapstruct/pull/2100#discussion_r428794437", "bodyText": "what would happen if in the \"non custom\" you would have a prefix CUSTOM_ would a user expect this if it's the enum related to protobuf for instance?", "author": "sjaakd", "createdAt": "2020-05-21T17:15:17Z", "path": "processor/src/test/java/org/mapstruct/ap/test/value/spi/CustomEnumNamingStrategyTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright MapStruct Authors.\n+ *\n+ * Licensed under the Apache License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.mapstruct.ap.test.value.spi;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mapstruct.ap.testutil.WithClasses;\n+import org.mapstruct.ap.testutil.WithServiceImplementation;\n+import org.mapstruct.ap.testutil.runner.AnnotationProcessorTestRunner;\n+import org.mapstruct.ap.testutil.runner.GeneratedSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+/**\n+ * @author Filip Hrisafov\n+ */\n+@RunWith(AnnotationProcessorTestRunner.class)\n+@WithClasses({\n+    CheeseType.class,\n+    CustomCheeseType.class,\n+    CustomEnumMarker.class,\n+})\n+@WithServiceImplementation(CustomEnumNamingStrategy.class)\n+public class CustomEnumNamingStrategyTest {\n+\n+    @Rule\n+    public final GeneratedSource generatedSource = new GeneratedSource();\n+\n+    @Test\n+    @WithClasses({\n+        CustomCheeseMapper.class\n+    })\n+    public void shouldApplyCustomEnumNamingStrategy() {\n+        generatedSource.addComparisonToFixtureFor( CustomCheeseMapper.class );\n+        CustomCheeseMapper mapper = CustomCheeseMapper.INSTANCE;\n+\n+        // CheeseType -> CustomCheeseType\n+        assertThat( mapper.map( (CheeseType) null ) ).isEqualTo( CustomCheeseType.UNSPECIFIED );\n+        assertThat( mapper.map( CheeseType.BRIE ) ).isEqualTo( CustomCheeseType.CUSTOM_BRIE );\n+        assertThat( mapper.map( CheeseType.ROQUEFORT ) ).isEqualTo( CustomCheeseType.CUSTOM_ROQUEFORT );\n+\n+        // CustomCheeseType -> CheeseType\n+        assertThat( mapper.map( (CustomCheeseType) null ) ).isNull();\n+        assertThat( mapper.map( CustomCheeseType.UNSPECIFIED ) ).isNull();\n+        assertThat( mapper.map( CustomCheeseType.CUSTOM_BRIE ) ).isEqualTo( CheeseType.BRIE );\n+        assertThat( mapper.map( CustomCheeseType.CUSTOM_ROQUEFORT ) ).isEqualTo( CheeseType.ROQUEFORT );\n+        assertThat( mapper.map( CustomCheeseType.UNRECOGNIZED ) ).isNull();\n+\n+        // CheeseType -> String\n+        assertThat( mapper.mapToString( (CheeseType) null ) ).isNull();\n+        assertThat( mapper.mapToString( CheeseType.BRIE ) ).isEqualTo( \"BRIE\" );\n+        assertThat( mapper.mapToString( CheeseType.ROQUEFORT ) ).isEqualTo( \"ROQUEFORT\" );\n+\n+        // CustomCheeseType -> String\n+        assertThat( mapper.mapToString( (CustomCheeseType) null ) ).isNull();\n+        assertThat( mapper.mapToString( CustomCheeseType.UNSPECIFIED ) ).isNull();\n+        assertThat( mapper.mapToString( CustomCheeseType.CUSTOM_BRIE ) ).isEqualTo( \"BRIE\" );\n+        assertThat( mapper.mapToString( CustomCheeseType.CUSTOM_ROQUEFORT ) ).isEqualTo( \"ROQUEFORT\" );\n+        assertThat( mapper.mapToString( CustomCheeseType.UNRECOGNIZED ) ).isNull();\n+\n+        // String - > CheeseType\n+        assertThat( mapper.mapStringToCheese( null ) ).isNull();\n+        assertThat( mapper.mapStringToCheese( \"BRIE\" ) ).isEqualTo( CheeseType.BRIE );\n+        assertThat( mapper.mapStringToCheese( \"ROQUEFORT\" ) ).isEqualTo( CheeseType.ROQUEFORT );", "originalCommit": "5d7d672f572e055a79b9855b1f00e3a6aa25bc2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3NDEyNA==", "url": "https://github.com/mapstruct/mapstruct/pull/2100#discussion_r428874124", "bodyText": "This is mapping String to CheeseType. CheeseType is a regular enum. The special enum is CustomCheeseType for that one you would expect the String BRIE to match the enum CustomCheeseType.CUSTOM_BRIE. Since the name based mapping constant for the CustomCheeseType is stripping the CUSTOM_ prefix", "author": "filiphr", "createdAt": "2020-05-21T19:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc5NDQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0MDE2Ng==", "url": "https://github.com/mapstruct/mapstruct/pull/2100#discussion_r428940166", "bodyText": "ah.. I get it.. Ok. nice one.. The user is in control.", "author": "sjaakd", "createdAt": "2020-05-21T22:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc5NDQzNw=="}], "type": "inlineReview"}, {"oid": "dccf4155cb7253b8298d8f9deb7fe20afa215c7a", "url": "https://github.com/mapstruct/mapstruct/commit/dccf4155cb7253b8298d8f9deb7fe20afa215c7a", "message": "Review documentation changes", "committedDate": "2020-05-21T20:17:52Z", "type": "commit"}]}