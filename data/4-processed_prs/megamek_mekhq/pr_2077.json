{"pr_number": 2077, "pr_title": "Standardizing MRMS Options", "pr_createdAt": "2020-09-30T19:38:38Z", "pr_url": "https://github.com/MegaMek/mekhq/pull/2077", "timeline": [{"oid": "3d845d949c600fb7dcc46ef3922f0c336d4f3e3e", "url": "https://github.com/MegaMek/mekhq/commit/3d845d949c600fb7dcc46ef3922f0c336d4f3e3e", "message": "Standardizing MRMS Options", "committedDate": "2020-09-30T19:13:48Z", "type": "commit"}, {"oid": "53658aba26652dbbac7a25dc1ea79ab44079a59b", "url": "https://github.com/MegaMek/mekhq/commit/53658aba26652dbbac7a25dc1ea79ab44079a59b", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_MRMSOptions", "committedDate": "2020-09-30T19:25:49Z", "type": "commit"}, {"oid": "c2d0988f7f69fa06002d7aeb19d68606a313d9e4", "url": "https://github.com/MegaMek/mekhq/commit/c2d0988f7f69fa06002d7aeb19d68606a313d9e4", "message": "Fixing merge conflicts", "committedDate": "2020-10-03T17:37:06Z", "type": "commit"}, {"oid": "ae5fb7e9fcec99a93a19afdab481d116899c125f", "url": "https://github.com/MegaMek/mekhq/commit/ae5fb7e9fcec99a93a19afdab481d116899c125f", "message": "Logger standardization", "committedDate": "2020-10-03T17:38:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2ODk1OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2077#discussion_r499168959", "bodyText": "If this should be immutable then prefer Collections.emptyList(). (realizing this was perhaps inherited code)", "author": "sixlettervariables", "createdAt": "2020-10-03T18:04:15Z", "path": "MekHQ/src/mekhq/service/MassRepairConfiguredOptions.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package mekhq.service;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.CampaignOptions;\n+import mekhq.gui.dialog.MassRepairSalvageDialog;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class MassRepairConfiguredOptions {\n+    //region Variable Declarations\n+    private boolean useExtraTime;\n+    private boolean useRushJob;\n+    private boolean allowCarryover;\n+    private boolean optimizeToCompleteToday;\n+    private boolean useAssignedTechsFirst;\n+    private boolean scrapImpossible;\n+    private boolean replacePodParts;\n+    private List<MassRepairOption> massRepairOptions;\n+    private transient boolean hasActiveMassRepairOption;\n+    //endregion Variable Declarations\n+\n+    //region Constructors\n+    public MassRepairConfiguredOptions(Campaign campaign) {\n+        setup(campaign.getCampaignOptions());\n+    }\n+\n+    public MassRepairConfiguredOptions(MassRepairSalvageDialog massRepairSalvageDialog) {\n+        setup(massRepairSalvageDialog);\n+    }\n+    //endregion Constructors\n+\n+    //region Initialization\n+    public void setup(CampaignOptions options) {\n+        setUseExtraTime(options.massRepairUseExtraTime());\n+        setUseRushJob(options.massRepairUseRushJob());\n+        setAllowCarryover(options.massRepairAllowCarryover());\n+        setOptimizeToCompleteToday(options.massRepairOptimizeToCompleteToday());\n+        setScrapImpossible(options.massRepairScrapImpossible());\n+        setUseAssignedTechsFirst(options.massRepairUseAssignedTechsFirst());\n+        setReplacePodParts(options.massRepairReplacePod());\n+        setMassRepairOptions(options.getMassRepairOptions());\n+        for (MassRepairOption mro : getMassRepairOptions()) {\n+            if (mro.isActive()) {\n+                hasActiveMassRepairOption = true;\n+                break;\n+            }\n+        }\n+    }\n+\n+    public void setup(MassRepairSalvageDialog dlg) {\n+        setUseExtraTime(dlg.getUseExtraTimeBox().isSelected());\n+        setUseRushJob(dlg.getUseRushJobBox().isSelected());\n+        setAllowCarryover(dlg.getAllowCarryoverBox().isSelected());\n+        setOptimizeToCompleteToday(dlg.getOptimizeToCompleteTodayBox().isSelected());\n+\n+        if (dlg.getScrapImpossibleBox() != null) {\n+            setScrapImpossible(dlg.getScrapImpossibleBox().isSelected());\n+        }\n+\n+        if (dlg.getUseAssignedTechsFirstBox() != null) {\n+            setUseAssignedTechsFirst(dlg.getUseAssignedTechsFirstBox().isSelected());\n+        }\n+\n+        if (dlg.getReplacePodPartsBox() != null) {\n+            setReplacePodParts(dlg.getReplacePodPartsBox().isSelected());\n+        }\n+\n+        setMassRepairOptions(new ArrayList<>());\n+        for (int i = 0; i < MassRepairOption.VALID_REPAIR_TYPES.length; i++) {\n+            int type = MassRepairOption.VALID_REPAIR_TYPES[i];\n+\n+            MassRepairSalvageDialog.MassRepairOptionControl mroc = dlg.getMassRepairOptionControlMap().get(type);\n+\n+            if (mroc == null) {\n+                continue;\n+            }\n+\n+            MassRepairOption mro = new MassRepairOption(type, mroc.getActiveBox().isSelected(),\n+                    mroc.getMinSkillCBox().getSelectedIndex(), mroc.getMaxSkillCBox().getSelectedIndex(),\n+                    (Integer) mroc.getMinBTHSpn().getValue(), (Integer) mroc.getMaxBTHSpn().getValue());\n+\n+            if (mro.isActive()) {\n+                setHasActiveMassRepairOption(true);\n+            }\n+\n+            getMassRepairOptions().add(mro);\n+        }\n+    }\n+    //endregion Initialization\n+\n+    //region Getters/Setters\n+    public boolean isUseExtraTime() {\n+        return useExtraTime;\n+    }\n+\n+    public void setUseExtraTime(boolean useExtraTime) {\n+        this.useExtraTime = useExtraTime;\n+    }\n+\n+    public boolean isUseRushJob() {\n+        return useRushJob;\n+    }\n+\n+    public void setUseRushJob(boolean useRushJob) {\n+        this.useRushJob = useRushJob;\n+    }\n+\n+    public boolean isAllowCarryover() {\n+        return allowCarryover;\n+    }\n+\n+    public void setAllowCarryover(boolean allowCarryover) {\n+        this.allowCarryover = allowCarryover;\n+    }\n+\n+    public boolean isOptimizeToCompleteToday() {\n+        return optimizeToCompleteToday;\n+    }\n+\n+    public void setOptimizeToCompleteToday(boolean optimizeToCompleteToday) {\n+        this.optimizeToCompleteToday = optimizeToCompleteToday;\n+    }\n+\n+    public boolean isUseAssignedTechsFirst() {\n+        return useAssignedTechsFirst;\n+    }\n+\n+    public void setUseAssignedTechsFirst(boolean useAssignedTechsFirst) {\n+        this.useAssignedTechsFirst = useAssignedTechsFirst;\n+    }\n+\n+    public boolean isScrapImpossible() {\n+        return scrapImpossible;\n+    }\n+\n+    public void setScrapImpossible(boolean scrapImpossible) {\n+        this.scrapImpossible = scrapImpossible;\n+    }\n+\n+    public boolean isReplacePodParts() {\n+        return replacePodParts;\n+    }\n+\n+    public void setReplacePodParts(boolean replacePodParts) {\n+        this.replacePodParts = replacePodParts;\n+    }\n+\n+    public List<MassRepairOption> getMassRepairOptions() {\n+        return massRepairOptions;\n+    }\n+\n+    public void setMassRepairOptions(List<MassRepairOption> massRepairOptions) {\n+        this.massRepairOptions = massRepairOptions;\n+    }\n+\n+    public boolean hasActiveMassRepairOption() {\n+        return hasActiveMassRepairOption;\n+    }\n+\n+    public void setHasActiveMassRepairOption(boolean hasActiveMassRepairOption) {\n+        this.hasActiveMassRepairOption = hasActiveMassRepairOption;\n+    }\n+    //endregion Getters/Setters\n+\n+    public List<MassRepairOption> getActiveMassRepairOptions() {\n+        if (!hasActiveMassRepairOption()) {\n+            return new ArrayList<>();", "originalCommit": "ae5fb7e9fcec99a93a19afdab481d116899c125f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTEwMA==", "url": "https://github.com/MegaMek/mekhq/pull/2077#discussion_r499169100", "bodyText": "Should this instead be debug?", "author": "sixlettervariables", "createdAt": "2020-10-03T18:05:48Z", "path": "MekHQ/src/mekhq/service/MassRepairOption.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package mekhq.service;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.parts.Part;\n+import mekhq.campaign.personnel.SkillType;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class MassRepairOption {\n+    //region Variable Declarations\n+    private int type;\n+    private boolean active;\n+    private int skillMin;\n+    private int skillMax;\n+    private int bthMin;\n+    private int bthMax;\n+\n+    public static final int[] VALID_REPAIR_TYPES = new int[] { Part.REPAIR_PART_TYPE.ARMOR, Part.REPAIR_PART_TYPE.AMMO,\n+            Part.REPAIR_PART_TYPE.WEAPON, Part.REPAIR_PART_TYPE.GENERAL_LOCATION, Part.REPAIR_PART_TYPE.ENGINE,\n+            Part.REPAIR_PART_TYPE.GYRO, Part.REPAIR_PART_TYPE.ACTUATOR, Part.REPAIR_PART_TYPE.ELECTRONICS,\n+            Part.REPAIR_PART_TYPE.POD_SPACE, Part.REPAIR_PART_TYPE.GENERAL };\n+    //endregion Variable Declarations\n+\n+    //region Constructors\n+    public MassRepairOption(int type) {\n+        this (type, false, SkillType.EXP_ULTRA_GREEN, SkillType.EXP_ELITE, 4, 4);\n+    }\n+\n+    public MassRepairOption(int type, boolean active, int skillMin, int skillMax, int bthMin, int bthMax) {\n+        this.type = type;\n+        this.active = active;\n+        this.skillMin = skillMin;\n+        this.skillMax = skillMax;\n+        this.bthMin = bthMin;\n+        this.bthMax = bthMax;\n+    }\n+    //endregion Constructors\n+\n+    //region Getters/Setters\n+    public int getType() {\n+        return type;\n+    }\n+\n+    public void setType(int type) {\n+        this.type = type;\n+    }\n+\n+    public boolean isActive() {\n+        return active;\n+    }\n+\n+    public void setActive(boolean active) {\n+        this.active = active;\n+    }\n+\n+    public int getSkillMin() {\n+        return skillMin;\n+    }\n+\n+    public void setSkillMin(int skillMin) {\n+        this.skillMin = skillMin;\n+    }\n+\n+    public int getSkillMax() {\n+        return skillMax;\n+    }\n+\n+    public void setSkillMax(int skillMax) {\n+        this.skillMax = skillMax;\n+    }\n+\n+    public int getBthMin() {\n+        return bthMin;\n+    }\n+\n+    public void setBthMin(int bthMin) {\n+        this.bthMin = bthMin;\n+    }\n+\n+    public int getBthMax() {\n+        return bthMax;\n+    }\n+\n+    public void setBthMax(int bthMax) {\n+        this.bthMax = bthMax;\n+    }\n+    //endregion Getters/Setters\n+\n+    //region File IO\n+    public void writeToXML(PrintWriter pw1, int indent) {\n+        MekHqXmlUtil.writeSimpleXMLOpenIndentedLine(pw1, indent++, \"massRepairOption\");\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"type\", getType());\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"active\", isActive() ? 1 : 0);\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"skillMin\", getSkillMin());\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"skillMax\", getSkillMax());\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"btnMin\", getBthMin());\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"btnMax\", getBthMax());\n+        MekHqXmlUtil.writeSimpleXMLCloseIndentedLine(pw1, --indent, \"massRepairOption\");\n+    }\n+\n+    public static List<MassRepairOption> parseListFromXML(Node wn2) {\n+        List<MassRepairOption> massRepairOptions = new ArrayList<>();\n+        NodeList mroList = wn2.getChildNodes();\n+\n+        for (int mroIdx = 0; mroIdx < mroList.getLength(); mroIdx++) {\n+            Node mroNode = mroList.item(mroIdx);\n+\n+            if (mroNode.getNodeType() != Node.ELEMENT_NODE) {\n+                continue;\n+            }\n+\n+            try {\n+                MassRepairOption mro = parseFromXML(mroNode);\n+                if ((mro.getType() == -1) || (mro.getType() >= VALID_REPAIR_TYPES.length)) {\n+                    MekHQ.getLogger().error(\"Attempted to load MassRepairOption with illegal type id of \" + mro.getType());\n+                } else {\n+                    massRepairOptions.add(mro);\n+                }\n+            } catch (Exception e) {\n+                MekHQ.getLogger().error(\"Failed to parse MassRepairOption from XML\", e);\n+            }\n+        }\n+\n+        return massRepairOptions;\n+    }\n+\n+    public static MassRepairOption parseFromXML(Node mroNode) {\n+        MassRepairOption mro = new MassRepairOption(-1);\n+\n+        NodeList mroItemList = mroNode.getChildNodes();\n+        for (int mroItemIdx = 0; mroItemIdx < mroItemList.getLength(); mroItemIdx++) {\n+            Node mroItemNode = mroItemList.item(mroItemIdx);\n+\n+            if (mroItemNode.getNodeType() != Node.ELEMENT_NODE) {\n+                continue;\n+            }\n+\n+            if (mroItemNode.getNodeName().equalsIgnoreCase(\"type\")) {\n+                mro.setType(Integer.parseInt(mroItemNode.getTextContent().trim()));\n+            } else if (mroItemNode.getNodeName().equalsIgnoreCase(\"active\")) {\n+                mro.setActive(Integer.parseInt(mroItemNode.getTextContent().trim()) == 1);\n+            } else if (mroItemNode.getNodeName().equalsIgnoreCase(\"skillMin\")) {\n+                mro.setSkillMin(Integer.parseInt(mroItemNode.getTextContent().trim()));\n+            } else if (mroItemNode.getNodeName().equalsIgnoreCase(\"skillMax\")) {\n+                mro.setSkillMax(Integer.parseInt(mroItemNode.getTextContent().trim()));\n+            } else if (mroItemNode.getNodeName().equalsIgnoreCase(\"btnMin\")) {\n+                mro.setBthMin(Integer.parseInt(mroItemNode.getTextContent().trim()));\n+            } else if (mroItemNode.getNodeName().equalsIgnoreCase(\"btnMax\")) {\n+                mro.setBthMax(Integer.parseInt(mroItemNode.getTextContent().trim()));\n+            }\n+\n+            MekHQ.getLogger().info(String.format(\"massRepairOption %d.%s\\n\\t%s\",", "originalCommit": "ae5fb7e9fcec99a93a19afdab481d116899c125f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTIzOQ==", "url": "https://github.com/MegaMek/mekhq/pull/2077#discussion_r499169239", "bodyText": "We currently use info for this and campaign options... but I'd say yes", "author": "Windchild292", "createdAt": "2020-10-03T18:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTEwMA=="}], "type": "inlineReview"}, {"oid": "4cbfe0385408ef27d3cd9f908a192f46fee7541b", "url": "https://github.com/MegaMek/mekhq/commit/4cbfe0385408ef27d3cd9f908a192f46fee7541b", "message": "Applying changes from review", "committedDate": "2020-10-03T18:21:18Z", "type": "commit"}]}