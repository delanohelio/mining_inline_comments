{"pr_number": 790, "pr_title": "CLDR-14202 B Simple tool for checking conversions", "pr_createdAt": "2020-10-15T03:41:28Z", "pr_url": "https://github.com/unicode-org/cldr/pull/790", "timeline": [{"oid": "9f351c060160afb23196638e8914a92fe6c422b4", "url": "https://github.com/unicode-org/cldr/commit/9f351c060160afb23196638e8914a92fe6c422b4", "message": "CLDR-14202 B Simple tool for checking conversions", "committedDate": "2020-10-15T03:39:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU2NzEzNA==", "url": "https://github.com/unicode-org/cldr/pull/790#discussion_r505567134", "bodyText": "there's not a great way to do this", "author": "srl295", "createdAt": "2020-10-15T14:00:58Z", "path": "tools/java/org/unicode/cldr/tool/VerifyConverterResults.java", "diffHunk": "@@ -0,0 +1,340 @@\n+package org.unicode.cldr.tool;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.draft.FileUtilities;\n+import org.unicode.cldr.util.CLDRConfig;\n+import org.unicode.cldr.util.CLDRPaths;\n+import org.unicode.cldr.util.DtdData;\n+import org.unicode.cldr.util.DtdData.AttributeStatus;\n+import org.unicode.cldr.util.DtdType;\n+import org.unicode.cldr.util.Pair;\n+import org.unicode.cldr.util.PathStarrer;\n+import org.unicode.cldr.util.SupplementalDataInfo;\n+import org.unicode.cldr.util.XMLFileReader;\n+import org.unicode.cldr.util.XPathParts;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonStreamParser;\n+\n+/** Simple tool to help verify that CLDR data is getting transferred.\n+ *\n+ * @author markdavis\n+ *\n+ */\n+public class VerifyConverterResults {\n+    public static final CLDRConfig CONFIG = CLDRConfig.getInstance();\n+    public static final SupplementalDataInfo SDI = CONFIG.getSupplementalDataInfo();\n+    public static final PathStarrer PATH_STARRER = new PathStarrer().setSubstitutionPattern(\"*\");\n+\n+    enum SourceType {\n+        text,\n+        json,\n+        rb}\n+\n+    public static void main(String[] args) {\n+        // TODO, make these arguments\n+        SourceType sourceType = SourceType.json;\n+\n+        String dirBase = CLDRPaths.STAGING_DIRECTORY + \"production/\";\n+        String textSource = \"/Users/markdavis/GitHub/macchiati/icu/icu4c/source/data\";\n+        String jsonSource = \"/Users/markdavis/Downloads/38JsonBetaAll\";\n+        String locale = \"de\";\n+        boolean isVerbose = false;\n+\n+\n+        String source;\n+        Matcher fileMatcher;\n+        Matcher parentMatcher = null;\n+        switch(sourceType) {\n+        case text:\n+            source = textSource;\n+            fileMatcher = Pattern.compile(locale + \".txt\").matcher(\"\");\n+            break;\n+        case json:\n+            source = jsonSource;\n+            fileMatcher = Pattern.compile(\".*\\\\.json\").matcher(\"\");\n+            parentMatcher = Pattern.compile(locale + \"|cldr-core|supplemental\").matcher(\"\");\n+            break;\n+        default: throw new IllegalArgumentException(\"No code yet for \" + sourceType);\n+        }\n+\n+        Set<String> skipSupplementalFiles = ImmutableSet.of(\n+            // purposely excluded from clients\n+            \"subdivisions.xml\",\n+\n+            // internal to CLDR, not applicable for clients\n+            \"attributeValueValidity.xml\", \"coverageLevels.xml\"\n+\n+            // the format changes so dramatically we can't compare\n+\n+            );\n+\n+        Set<String> converted = getConvertedData(sourceType, new File(source), fileMatcher, parentMatcher, new TreeSet<>());\n+        Set<String> excludeDraftStatus = ImmutableSet.of(\"unconfirmed\", \"provisional\");\n+\n+        // Now check that the data values in CLDR are contained\n+        for (String dir : Iterables.concat(DtdType.ldml.directories, DtdType.supplementalData.directories)) {\n+            switch(dir) {\n+\n+            case \"annotationsDerived\": case \"annotations\":\n+                if (sourceType != SourceType.text) {\n+                    break;\n+                }\n+                System.out.println(dir + \"\\t##SKIPPING\\t\" + \"excluded from ICU\");\n+                continue;\n+\n+            case \"casing\":\n+                System.out.println(dir + \"\\t##SKIPPING\\t\" + \"internal to CLDR, not applicable for conversion\");\n+                continue;\n+\n+            case \"subdivisions\":\n+                System.out.println(dir + \"\\t##SKIPPING\\t\" + \"purposely excluded from conversion\");\n+                continue;\n+\n+            case \"collation\":\n+            case \"rbnf\":\n+            case \"transforms\":\n+            case \"segments\":\n+            case \"validity\":\n+                System.out.println(dir + \"\\t##SKIPPING\\t\" + \"format changes so dramatically we can't compare yet\");\n+                continue;\n+            }\n+\n+            final boolean isSupplemental = DtdType.supplementalData.directories.contains(dir);\n+            DtdData supplementalDtdData = isSupplemental ? DtdData.getInstance(DtdType.supplementalData) : null;\n+\n+            Matcher cldrFileMatcher = Pattern.compile(locale + \".xml\").matcher(\"\");\n+\n+            FileData filedata = new FileData(converted);\n+            String current = dirBase + \"common/\" + dir;\n+\n+            for (File child : new File(current).listFiles()) {\n+                final String name = child.getName();\n+                if (isSupplemental) {\n+                    if (skipSupplementalFiles.contains(name)) {\n+                        continue;\n+                    }\n+                } else {\n+                    if (!cldrFileMatcher.reset(name).matches()) {\n+                        continue;\n+                    }\n+                }\n+                filedata.clear();\n+                for (Pair<String, String> line : XMLFileReader.loadPathValues(child.toString(), new ArrayList<>(), false)) {\n+                    final String value = line.getSecond();\n+                    final String path = line.getFirst();\n+                    XPathParts parts = XPathParts.getFrozenInstance(path);\n+                    String draftStatus = parts.getAttributeValue(-1, \"draft\");\n+                    if (draftStatus != null && excludeDraftStatus.contains(draftStatus)) {\n+                        // doesn't need to be copied; up to client\n+                        continue;\n+                    } else if (path.startsWith(\"//supplementalData/metadata/suppress/attributes\")\n+                        || path.startsWith(\"//supplementalData/metadata/serialElements\")) {\n+                        // internal to CLDR\n+                        continue;\n+                    }\n+                    filedata.checkValue(dir, name, path, value);\n+\n+                    // for supplemental data, also check the value attributes\n+                    if (isSupplemental) {\n+                        for (int elementIndex = 0; elementIndex < parts.size(); ++elementIndex) {\n+                            String element = parts.getElement(elementIndex);\n+                            for (Entry<String, String> attribute : parts.getAttributes(elementIndex).entrySet()) {\n+                                if (AttributeStatus.value == supplementalDtdData.getAttributeStatus(element, attribute.getKey())) {\n+                                    filedata.checkValue(dir, name, path, attribute.getValue());\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                filedata.print(isVerbose);\n+                System.out.println(dir + \"\\t##Missing Paths #:\\t\" + (filedata.filedata.size() == 0? \"NONE\"\n+                    : filedata.filedata.size()));\n+            }\n+        }\n+    }\n+\n+    static class FileData {\n+        Set<String> converted;\n+        TreeMultimap<String, String> filedata =  TreeMultimap.create();\n+        TreeMap<String, String> starredData = new TreeMap<>();\n+\n+        public FileData(Set<String> converted) {\n+            this.converted = converted;\n+        }\n+\n+        public void clear() {\n+            filedata.clear();\n+            starredData.clear();\n+        }\n+\n+        public void checkValue(final String dir, final String name, final String path, String value) {\n+            if (value.isEmpty()) {\n+                return;\n+            }\n+            value = value.replace('\\n', ' ');\n+            if (converted.contains(value)) {\n+                return;\n+            }\n+            filedata.put(dir + \"\\t\" + name + \"\\t\" + path, value);\n+            starredData.put(dir + \"\\t\" + name + \"\\t\" + PATH_STARRER.set(path), value);\n+        }\n+\n+        void print(boolean isVerbose) {\n+            final Set<Entry<String, String>> items = isVerbose ? filedata.entries() : starredData.entrySet();\n+            for (Entry<String, String> entry : items) {\n+                System.out.println(entry.getKey() + \"\\t\" + entry.getValue());\n+            }\n+        }\n+    }\n+\n+    private static Set<String> getConvertedData(SourceType sourceType, File target, Matcher fileMatcher, Matcher parentMatcher, Set<String> accummulatedValues) {\n+        if (target.isDirectory()) {\n+            for (File child : target.listFiles()) {\n+                getConvertedData(sourceType, child, fileMatcher, parentMatcher, accummulatedValues);\n+            }\n+        } else {\n+            if (target.toString().contains(\"/de/\")) {\n+                int debug = 0;\n+            }\n+            boolean ok = true;\n+            if (parentMatcher != null) {\n+                String parentName = target.getParentFile().getName();\n+                ok = parentMatcher.reset(parentName).matches();\n+            }\n+            if (ok) {\n+                ok = fileMatcher.reset(target.getName()).matches();\n+            }\n+            if (ok) { // not directory, matches\n+                int startCount = accummulatedValues.size();\n+                switch (sourceType) {\n+                case text:\n+                    processText(target, accummulatedValues);\n+                    break;\n+                case json:\n+                    processJson(target, accummulatedValues);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"No code yet for \" + sourceType);\n+                }\n+                int endCount = accummulatedValues.size();\n+                System.out.println(\"Processed Converted\" + target + \"; \"\n+                    + (startCount == endCount ? \"NO CHANGE\" : startCount + \" => \" + endCount));\n+            }\n+        }\n+        return accummulatedValues;\n+    }\n+\n+\n+    private static void processJson(File target, Set<String> accummulatedValues) {\n+        try (Reader reader = FileUtilities.openFile(target, Charset.forName(\"utf8\"))) {\n+            JsonStreamParser gsonParser = new JsonStreamParser(reader);\n+            gsonParser.forEachRemaining((JsonElement x) -> process(x, accummulatedValues));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private static void process(JsonElement x, Set<String> accummulatedValues) {\n+        if (x.isJsonPrimitive()) {\n+            accummulatedValues.add(x.getAsString());\n+        } else if (x.isJsonArray()) {\n+            for (JsonElement y : x.getAsJsonArray()) {\n+                process(y, accummulatedValues);\n+            }\n+        } else if (x.isJsonObject()) {\n+            for (Entry<String, JsonElement> y : x.getAsJsonObject().entrySet()) {\n+                process(y.getValue(), accummulatedValues);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"No code yet for \");\n+        }\n+    }\n+\n+    public static void processText(File target, Set<String> accummulatedValues) {\n+        Matcher quoteMatcher = Pattern.compile(\"\\\"([^\\\"]*)\\\"\").matcher(\"\");\n+        for (String line : FileUtilities.in(target)) {\n+            if (line.startsWith(\"//\")) {\n+                continue;\n+            }\n+            quoteMatcher.reset(line);\n+            while (quoteMatcher.find()) {\n+                final String value = quoteMatcher.group(1);\n+                accummulatedValues.add(value);\n+            }\n+        }\n+    }\n+\n+    /*\n+    public static void main(String[] args) throws UnsupportedEncodingException {\n+        for (final String baseName : getBaseNames()) {\n+            gatherData(baseName);\n+        }\n+    }\n+    // Ugly hack to get base names", "originalCommit": "9f351c060160afb23196638e8914a92fe6c422b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}