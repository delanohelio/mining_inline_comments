{"pr_number": 607, "pr_title": "CLDR-13857 Add normalized XMLSource cache", "pr_createdAt": "2020-08-04T19:36:26Z", "pr_url": "https://github.com/unicode-org/cldr/pull/607", "timeline": [{"oid": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "url": "https://github.com/unicode-org/cldr/commit/15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "message": "CLDR-13857 Add normalized XMLSource cache", "committedDate": "2020-08-04T19:27:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzNTY0Ng==", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465335646", "bodyText": "Set instead of List", "author": "AlintaLu", "createdAt": "2020-08-04T21:17:17Z", "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;", "originalCommit": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzNjQ0Nw==", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465336447", "bodyText": "throw if empty", "author": "AlintaLu", "createdAt": "2020-08-04T21:19:06Z", "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {\n+                return false;\n+            }\n+            if (minimalDraftStatus != other.minimalDraftStatus) {\n+                return false;\n+            }\n+            if (!Objects.equals(localeId, other.localeId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static XMLSource getFrozenInstance(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+        XMLSourceCacheKey key = new XMLSourceCacheKey(localeId, dirs, minimalDraftStatus);\n+        return cache.getUnchecked(key);\n+    }\n+\n+    private static XMLSource makeXMLSource(XMLSourceCacheKey key) {\n+        if (key.dirs == null || key.dirs.size() == 0) {", "originalCommit": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzODA2NQ==", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465338065", "bodyText": "Add\nif(hashCode != other.hashCode) {\nreturn false;\n}", "author": "macchiati", "createdAt": "2020-08-04T21:22:35Z", "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {", "originalCommit": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NDE0Mg==", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465344142", "bodyText": "NO need StringBuilder, String plus", "author": "AlintaLu", "createdAt": "2020-08-04T21:36:20Z", "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {\n+                return false;\n+            }\n+            if (minimalDraftStatus != other.minimalDraftStatus) {\n+                return false;\n+            }\n+            if (!Objects.equals(localeId, other.localeId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static XMLSource getFrozenInstance(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+        XMLSourceCacheKey key = new XMLSourceCacheKey(localeId, dirs, minimalDraftStatus);\n+        return cache.getUnchecked(key);\n+    }\n+\n+    private static XMLSource makeXMLSource(XMLSourceCacheKey key) {\n+        if (key.dirs == null || key.dirs.size() == 0) {\n+            return null;\n+        }\n+\n+        XMLSource source = null;\n+        if (key.dirs.size() == 1) {\n+            File file = new File(key.dirs.get(0), key.localeId + \".xml\");\n+            source = loadXMLFile(file, key.localeId, key.minimalDraftStatus);\n+            source.freeze();\n+            return source;\n+        }\n+\n+        // if contains more than one file, make XMLSource from each file and then combine them to a combined XMLSource,\n+        // so that can cache single file XMLSource as well as combined XMLSource\n+        List<XMLSource> list = new ArrayList<>();\n+        List<File> dirList = new ArrayList<>();\n+        for (File dir: key.dirs) {\n+            dirList.clear();\n+            dirList.add(dir);\n+            XMLSourceCacheKey singleKey = new XMLSourceCacheKey(key.localeId, dirList, key.minimalDraftStatus);\n+            XMLSource singleSource = cache.getUnchecked(singleKey);\n+            list.add(singleSource);\n+        }\n+\n+        source = list.get(0).cloneAsThawed();\n+        for (int i = 1; i < list.size(); i++) {\n+            XMLSource other = list.get(i);\n+            source.putAll(other, 0); // 0 --> merge_keep_mine\n+            source.getXpathComments().joinAll(other.getXpathComments());\n+        }\n+        source.freeze();\n+        return source;\n+    }\n+\n+    public static XMLSource loadXMLFile(File f, String localeId, DraftStatus minimalDraftStatus) {\n+        String fullFileName = null;\n+        try {\n+            fullFileName = f.getCanonicalPath();\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");", "originalCommit": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NDM1MA==", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465344350", "bodyText": "No StringBuilder", "author": "AlintaLu", "createdAt": "2020-08-04T21:36:41Z", "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {\n+                return false;\n+            }\n+            if (minimalDraftStatus != other.minimalDraftStatus) {\n+                return false;\n+            }\n+            if (!Objects.equals(localeId, other.localeId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static XMLSource getFrozenInstance(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+        XMLSourceCacheKey key = new XMLSourceCacheKey(localeId, dirs, minimalDraftStatus);\n+        return cache.getUnchecked(key);\n+    }\n+\n+    private static XMLSource makeXMLSource(XMLSourceCacheKey key) {\n+        if (key.dirs == null || key.dirs.size() == 0) {\n+            return null;\n+        }\n+\n+        XMLSource source = null;\n+        if (key.dirs.size() == 1) {\n+            File file = new File(key.dirs.get(0), key.localeId + \".xml\");\n+            source = loadXMLFile(file, key.localeId, key.minimalDraftStatus);\n+            source.freeze();\n+            return source;\n+        }\n+\n+        // if contains more than one file, make XMLSource from each file and then combine them to a combined XMLSource,\n+        // so that can cache single file XMLSource as well as combined XMLSource\n+        List<XMLSource> list = new ArrayList<>();\n+        List<File> dirList = new ArrayList<>();\n+        for (File dir: key.dirs) {\n+            dirList.clear();\n+            dirList.add(dir);\n+            XMLSourceCacheKey singleKey = new XMLSourceCacheKey(key.localeId, dirList, key.minimalDraftStatus);\n+            XMLSource singleSource = cache.getUnchecked(singleKey);\n+            list.add(singleSource);\n+        }\n+\n+        source = list.get(0).cloneAsThawed();\n+        for (int i = 1; i < list.size(); i++) {\n+            XMLSource other = list.get(i);\n+            source.putAll(other, 0); // 0 --> merge_keep_mine\n+            source.getXpathComments().joinAll(other.getXpathComments());\n+        }\n+        source.freeze();\n+        return source;\n+    }\n+\n+    public static XMLSource loadXMLFile(File f, String localeId, DraftStatus minimalDraftStatus) {\n+        String fullFileName = null;\n+        try {\n+            fullFileName = f.getCanonicalPath();\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");\n+            sb.append(f);\n+            throw new ICUUncheckedIOException(sb.toString(), e);\n+        }\n+        // use try-with-resources statement\n+        try (\n+            InputStream fis = new StripUTF8BOMInputStream(new FileInputStream(f));\n+            InputStreamReader reader = new InputStreamReader(fis, Charset.forName(\"UTF-8\"))\n+        ) {\n+            XMLSource source = new SimpleXMLSource(localeId);\n+            XMLNormalizingHandler XML_HANDLER = new XMLNormalizingHandler(source, minimalDraftStatus);\n+            XMLFileReader.read(fullFileName, reader, -1, true, XML_HANDLER);\n+            if (XML_HANDLER.supplementalStatus == SupplementalStatus.NEVER_SET) {\n+                throw new IllegalArgumentException(\"root of file must be either ldml or supplementalData\");\n+            }\n+            source.setNonInheriting(XML_HANDLER.supplementalStatus == SupplementalStatus.NOT_SUPPLEMENTAL);\n+            if (XML_HANDLER.overrideCount > 0) {\n+                throw new IllegalArgumentException(\"Internal problems: either data file has duplicate path, or\" +\n+                    \" CLDRFile.isDistinguishing() or CLDRFile.isOrdered() need updating: \"\n+                    + XML_HANDLER.overrideCount\n+                    + \"; The exact problems are printed on the console above.\");\n+            }\n+            return source;\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");", "originalCommit": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMTE4Ng==", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465421186", "bodyText": "Nitpick: the cast to IllegalArgumentException is not needed.", "author": "mihnita", "createdAt": "2020-08-05T01:36:27Z", "path": "tools/java/org/unicode/cldr/util/XMLSource.java", "diffHunk": "@@ -1747,4 +1749,84 @@ public DtdType getDtdType() {\n         }\n         return null;\n     }\n+\n+    /**\n+     * XMLNormalizingDtdType is set in XMLNormalizingHandler loading XML process\n+     */\n+    private DtdType XMLNormalizingDtdType;\n+    private static final boolean LOG_PROGRESS = false;\n+\n+    public DtdType getXMLNormalizingDtdType() {\n+        return this.XMLNormalizingDtdType;\n+    }\n+\n+    public void setXMLNormalizingDtdType(DtdType dtdType) {\n+        this.XMLNormalizingDtdType = dtdType;\n+    }\n+\n+    /**\n+     * Sets the initial comment, replacing everything that was there\n+     * Use in XMLNormalizingHandler only\n+     */\n+    public XMLSource setInitialComment(String comment) {\n+        if (locked) throw new UnsupportedOperationException(\"Attempt to modify locked object\");\n+        Log.logln(LOG_PROGRESS, \"SET initial Comment: \\t\" + comment);\n+        this.getXpathComments().setInitialComment(comment);\n+        return this;\n+    }\n+\n+    /**\n+     * Use in XMLNormalizingHandler only\n+     */\n+    public XMLSource addComment(String xpath, String comment, Comments.CommentType type) {\n+        if (locked) throw new UnsupportedOperationException(\"Attempt to modify locked object\");\n+        Log.logln(LOG_PROGRESS, \"ADDING Comment: \\t\" + type + \"\\t\" + xpath + \" \\t\" + comment);\n+        if (xpath == null || xpath.length() == 0) {\n+            this.getXpathComments().setFinalComment(\n+                CldrUtility.joinWithSeparation(this.getXpathComments().getFinalComment(), XPathParts.NEWLINE,\n+                    comment));\n+        } else {\n+            xpath = CLDRFile.getDistinguishingXPath(xpath, null);\n+            this.getXpathComments().addComment(type, xpath, comment);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Use in XMLNormalizingHandler only\n+     */\n+    public String getFullXPath(String xpath) {\n+        if (xpath == null) {\n+            throw new NullPointerException(\"Null distinguishing xpath\");\n+        }\n+        String result = this.getFullPath(xpath);\n+        return result != null ? result : xpath; // we can't add any non-distinguishing values if there is nothing there.\n+    }\n+\n+    /**\n+     * Add a new element to a XMLSource\n+     * Use in XMLNormalizingHandler only\n+     */\n+    public XMLSource add(String currentFullXPath, String value) {\n+        if (locked) throw new UnsupportedOperationException(\"Attempt to modify locked object\");\n+        Log.logln(LOG_PROGRESS, \"ADDING: \\t\" + currentFullXPath + \" \\t\" + value + \"\\t\" + currentFullXPath);\n+        try {\n+            this.putValueAtPath(currentFullXPath, value);\n+        } catch (RuntimeException e) {\n+            throw (IllegalArgumentException) new IllegalArgumentException(\"failed adding \" + currentFullXPath + \",\\t\"", "originalCommit": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMjQ5Nw==", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465422497", "bodyText": "Nitpick: final static and uppercase (it is a constant, never changes)", "author": "mihnita", "createdAt": "2020-08-05T01:41:27Z", "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {\n+                return false;\n+            }\n+            if (minimalDraftStatus != other.minimalDraftStatus) {\n+                return false;\n+            }\n+            if (!Objects.equals(localeId, other.localeId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static XMLSource getFrozenInstance(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+        XMLSourceCacheKey key = new XMLSourceCacheKey(localeId, dirs, minimalDraftStatus);\n+        return cache.getUnchecked(key);\n+    }\n+\n+    private static XMLSource makeXMLSource(XMLSourceCacheKey key) {\n+        if (key.dirs == null || key.dirs.size() == 0) {\n+            return null;\n+        }\n+\n+        XMLSource source = null;\n+        if (key.dirs.size() == 1) {\n+            File file = new File(key.dirs.get(0), key.localeId + \".xml\");\n+            source = loadXMLFile(file, key.localeId, key.minimalDraftStatus);\n+            source.freeze();\n+            return source;\n+        }\n+\n+        // if contains more than one file, make XMLSource from each file and then combine them to a combined XMLSource,\n+        // so that can cache single file XMLSource as well as combined XMLSource\n+        List<XMLSource> list = new ArrayList<>();\n+        List<File> dirList = new ArrayList<>();\n+        for (File dir: key.dirs) {\n+            dirList.clear();\n+            dirList.add(dir);\n+            XMLSourceCacheKey singleKey = new XMLSourceCacheKey(key.localeId, dirList, key.minimalDraftStatus);\n+            XMLSource singleSource = cache.getUnchecked(singleKey);\n+            list.add(singleSource);\n+        }\n+\n+        source = list.get(0).cloneAsThawed();\n+        for (int i = 1; i < list.size(); i++) {\n+            XMLSource other = list.get(i);\n+            source.putAll(other, 0); // 0 --> merge_keep_mine\n+            source.getXpathComments().joinAll(other.getXpathComments());\n+        }\n+        source.freeze();\n+        return source;\n+    }\n+\n+    public static XMLSource loadXMLFile(File f, String localeId, DraftStatus minimalDraftStatus) {\n+        String fullFileName = null;\n+        try {\n+            fullFileName = f.getCanonicalPath();\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");\n+            sb.append(f);\n+            throw new ICUUncheckedIOException(sb.toString(), e);\n+        }\n+        // use try-with-resources statement\n+        try (\n+            InputStream fis = new StripUTF8BOMInputStream(new FileInputStream(f));\n+            InputStreamReader reader = new InputStreamReader(fis, Charset.forName(\"UTF-8\"))\n+        ) {\n+            XMLSource source = new SimpleXMLSource(localeId);\n+            XMLNormalizingHandler XML_HANDLER = new XMLNormalizingHandler(source, minimalDraftStatus);\n+            XMLFileReader.read(fullFileName, reader, -1, true, XML_HANDLER);\n+            if (XML_HANDLER.supplementalStatus == SupplementalStatus.NEVER_SET) {\n+                throw new IllegalArgumentException(\"root of file must be either ldml or supplementalData\");\n+            }\n+            source.setNonInheriting(XML_HANDLER.supplementalStatus == SupplementalStatus.NOT_SUPPLEMENTAL);\n+            if (XML_HANDLER.overrideCount > 0) {\n+                throw new IllegalArgumentException(\"Internal problems: either data file has duplicate path, or\" +\n+                    \" CLDRFile.isDistinguishing() or CLDRFile.isOrdered() need updating: \"\n+                    + XML_HANDLER.overrideCount\n+                    + \"; The exact problems are printed on the console above.\");\n+            }\n+            return source;\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");\n+            sb.append(f);\n+            throw new ICUUncheckedIOException(sb.toString(), e);\n+        }\n+    }\n+\n+    private static class XMLNormalizingHandler implements AllHandler {\n+        private DraftStatus minimalDraftStatus;\n+        private static final boolean SHOW_START_END = false;\n+        private int commentStackIndex;\n+        private boolean justPopped = false;\n+        private String lastChars = \"\";\n+        private StringBuilder currentFullXPathSb = new StringBuilder(\"/\");\n+        private String comment = null;\n+        private Map<String, String> attributeOrder;\n+        private DtdData dtdData;\n+        private XMLSource source;\n+        private String lastActiveLeafNode;\n+        private String lastLeafNode;\n+        private SupplementalStatus supplementalStatus = SupplementalStatus.NEVER_SET;\n+        private int maxDepth = 30; // just make deep enough to handle any CLDR file.", "originalCommit": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyNTU3Nw==", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465425577", "bodyText": "Nitpick: you can move String fullFileName = f.getCanonicalPath();  to be the first thing in the main try { }\nIt is not used outside the try, and that already catches the exception.\nSo instead of 2 try-catch blocks you only have one.", "author": "mihnita", "createdAt": "2020-08-05T01:52:22Z", "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {\n+                return false;\n+            }\n+            if (minimalDraftStatus != other.minimalDraftStatus) {\n+                return false;\n+            }\n+            if (!Objects.equals(localeId, other.localeId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static XMLSource getFrozenInstance(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+        XMLSourceCacheKey key = new XMLSourceCacheKey(localeId, dirs, minimalDraftStatus);\n+        return cache.getUnchecked(key);\n+    }\n+\n+    private static XMLSource makeXMLSource(XMLSourceCacheKey key) {\n+        if (key.dirs == null || key.dirs.size() == 0) {\n+            return null;\n+        }\n+\n+        XMLSource source = null;\n+        if (key.dirs.size() == 1) {\n+            File file = new File(key.dirs.get(0), key.localeId + \".xml\");\n+            source = loadXMLFile(file, key.localeId, key.minimalDraftStatus);\n+            source.freeze();\n+            return source;\n+        }\n+\n+        // if contains more than one file, make XMLSource from each file and then combine them to a combined XMLSource,\n+        // so that can cache single file XMLSource as well as combined XMLSource\n+        List<XMLSource> list = new ArrayList<>();\n+        List<File> dirList = new ArrayList<>();\n+        for (File dir: key.dirs) {\n+            dirList.clear();\n+            dirList.add(dir);\n+            XMLSourceCacheKey singleKey = new XMLSourceCacheKey(key.localeId, dirList, key.minimalDraftStatus);\n+            XMLSource singleSource = cache.getUnchecked(singleKey);\n+            list.add(singleSource);\n+        }\n+\n+        source = list.get(0).cloneAsThawed();\n+        for (int i = 1; i < list.size(); i++) {\n+            XMLSource other = list.get(i);\n+            source.putAll(other, 0); // 0 --> merge_keep_mine\n+            source.getXpathComments().joinAll(other.getXpathComments());\n+        }\n+        source.freeze();\n+        return source;\n+    }\n+\n+    public static XMLSource loadXMLFile(File f, String localeId, DraftStatus minimalDraftStatus) {\n+        String fullFileName = null;", "originalCommit": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyNjU4MA==", "url": "https://github.com/unicode-org/cldr/pull/607#discussion_r465426580", "bodyText": "Nitpick: you can make this line comment (//).\nThe types are private, so they don't need to generate javadoc.\nA regular comment for the programmer reading this code is enough, and only takes 1 line, not 3.", "author": "mihnita", "createdAt": "2020-08-05T01:55:53Z", "path": "tools/java/org/unicode/cldr/util/XMLNormalizingLoader.java", "diffHunk": "@@ -0,0 +1,686 @@\n+package org.unicode.cldr.util;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.unicode.cldr.util.CLDRFile.DraftStatus;\n+import org.unicode.cldr.util.XMLFileReader.AllHandler;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.SAXParseException;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.ibm.icu.impl.Utility;\n+import com.ibm.icu.text.UnicodeSet;\n+import com.ibm.icu.util.ICUUncheckedIOException;\n+import com.ibm.icu.util.VersionInfo;\n+\n+/**\n+ * Loading Normalized XMLSource\n+ */\n+public class XMLNormalizingLoader{\n+\n+    /**\n+     *  This size could maximum speed up TestAll by loading almost all files only once\n+     *  combine with softValues eviction to satisfy memory demand\n+     */\n+    private static final int CACHE_LIMIT = 1500;\n+\n+    /**\n+     * Use guava loading cache, which could automatically load or compute value associated with a key\n+     */\n+    private static LoadingCache<XMLSourceCacheKey, XMLSource> cache = CacheBuilder.newBuilder()\n+        .maximumSize(CACHE_LIMIT)\n+        .softValues()   // will garbage-collected in LRU manner in response to memory demand\n+        .build(\n+            new CacheLoader<XMLSourceCacheKey, XMLSource>() {\n+                @Override\n+                public XMLSource load(XMLSourceCacheKey key) {\n+                    return makeXMLSource(key);\n+                }\n+            });\n+\n+    private static final boolean LOG_PROGRESS = false;\n+    private static final boolean DEBUG = false;\n+    enum SupplementalStatus {\n+        NEVER_SET, IS_SUMPPLEMENTAL, NOT_SUPPLEMENTAL\n+    };\n+\n+    private static class XMLSourceCacheKey {\n+        private final String localeId;\n+        private final List<File> dirs;\n+        private final DraftStatus minimalDraftStatus;\n+        private final int hashCode;\n+        public XMLSourceCacheKey(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+            this.localeId = localeId;\n+            this.dirs = dirs;\n+            this.minimalDraftStatus = minimalDraftStatus;\n+            this.hashCode = Objects.hash(this.localeId, this.dirs, this.minimalDraftStatus);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            XMLSourceCacheKey other = (XMLSourceCacheKey) obj;\n+            if (!Objects.equals(dirs, other.dirs)) {\n+                return false;\n+            }\n+            if (minimalDraftStatus != other.minimalDraftStatus) {\n+                return false;\n+            }\n+            if (!Objects.equals(localeId, other.localeId)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static XMLSource getFrozenInstance(String localeId, List<File> dirs, DraftStatus minimalDraftStatus) {\n+        XMLSourceCacheKey key = new XMLSourceCacheKey(localeId, dirs, minimalDraftStatus);\n+        return cache.getUnchecked(key);\n+    }\n+\n+    private static XMLSource makeXMLSource(XMLSourceCacheKey key) {\n+        if (key.dirs == null || key.dirs.size() == 0) {\n+            return null;\n+        }\n+\n+        XMLSource source = null;\n+        if (key.dirs.size() == 1) {\n+            File file = new File(key.dirs.get(0), key.localeId + \".xml\");\n+            source = loadXMLFile(file, key.localeId, key.minimalDraftStatus);\n+            source.freeze();\n+            return source;\n+        }\n+\n+        // if contains more than one file, make XMLSource from each file and then combine them to a combined XMLSource,\n+        // so that can cache single file XMLSource as well as combined XMLSource\n+        List<XMLSource> list = new ArrayList<>();\n+        List<File> dirList = new ArrayList<>();\n+        for (File dir: key.dirs) {\n+            dirList.clear();\n+            dirList.add(dir);\n+            XMLSourceCacheKey singleKey = new XMLSourceCacheKey(key.localeId, dirList, key.minimalDraftStatus);\n+            XMLSource singleSource = cache.getUnchecked(singleKey);\n+            list.add(singleSource);\n+        }\n+\n+        source = list.get(0).cloneAsThawed();\n+        for (int i = 1; i < list.size(); i++) {\n+            XMLSource other = list.get(i);\n+            source.putAll(other, 0); // 0 --> merge_keep_mine\n+            source.getXpathComments().joinAll(other.getXpathComments());\n+        }\n+        source.freeze();\n+        return source;\n+    }\n+\n+    public static XMLSource loadXMLFile(File f, String localeId, DraftStatus minimalDraftStatus) {\n+        String fullFileName = null;\n+        try {\n+            fullFileName = f.getCanonicalPath();\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");\n+            sb.append(f);\n+            throw new ICUUncheckedIOException(sb.toString(), e);\n+        }\n+        // use try-with-resources statement\n+        try (\n+            InputStream fis = new StripUTF8BOMInputStream(new FileInputStream(f));\n+            InputStreamReader reader = new InputStreamReader(fis, Charset.forName(\"UTF-8\"))\n+        ) {\n+            XMLSource source = new SimpleXMLSource(localeId);\n+            XMLNormalizingHandler XML_HANDLER = new XMLNormalizingHandler(source, minimalDraftStatus);\n+            XMLFileReader.read(fullFileName, reader, -1, true, XML_HANDLER);\n+            if (XML_HANDLER.supplementalStatus == SupplementalStatus.NEVER_SET) {\n+                throw new IllegalArgumentException(\"root of file must be either ldml or supplementalData\");\n+            }\n+            source.setNonInheriting(XML_HANDLER.supplementalStatus == SupplementalStatus.NOT_SUPPLEMENTAL);\n+            if (XML_HANDLER.overrideCount > 0) {\n+                throw new IllegalArgumentException(\"Internal problems: either data file has duplicate path, or\" +\n+                    \" CLDRFile.isDistinguishing() or CLDRFile.isOrdered() need updating: \"\n+                    + XML_HANDLER.overrideCount\n+                    + \"; The exact problems are printed on the console above.\");\n+            }\n+            return source;\n+        } catch (IOException e) {\n+            StringBuilder sb = new StringBuilder(\"Cannot read the file '\");\n+            sb.append(f);\n+            throw new ICUUncheckedIOException(sb.toString(), e);\n+        }\n+    }\n+\n+    private static class XMLNormalizingHandler implements AllHandler {\n+        private DraftStatus minimalDraftStatus;\n+        private static final boolean SHOW_START_END = false;\n+        private int commentStackIndex;\n+        private boolean justPopped = false;\n+        private String lastChars = \"\";\n+        private StringBuilder currentFullXPathSb = new StringBuilder(\"/\");\n+        private String comment = null;\n+        private Map<String, String> attributeOrder;\n+        private DtdData dtdData;\n+        private XMLSource source;\n+        private String lastActiveLeafNode;\n+        private String lastLeafNode;\n+        private SupplementalStatus supplementalStatus = SupplementalStatus.NEVER_SET;\n+        private int maxDepth = 30; // just make deep enough to handle any CLDR file.\n+        // orderedCounter, orderedString, and level logically form a single class that allows adding elements, but never removed.\n+        private int[] orderedCounter = new int[maxDepth];\n+        private String[] orderedString = new String[maxDepth];\n+        private int level = 0;\n+        private int overrideCount = 0;\n+        /**", "originalCommit": "15d7eafaac35d93fa9b3bbc256790bbd4d10cc4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7bbf03f7a8e619365959600a2539e15987e9f0fa", "url": "https://github.com/unicode-org/cldr/commit/7bbf03f7a8e619365959600a2539e15987e9f0fa", "message": "CLDR-13857 Fix reviews for XMLNormalizingLoader and XMLSource", "committedDate": "2020-08-05T18:10:06Z", "type": "commit"}, {"oid": "bfd43f233557a3a8b23530554d861934e816f64c", "url": "https://github.com/unicode-org/cldr/commit/bfd43f233557a3a8b23530554d861934e816f64c", "message": "CLDR-13857 disabling SimpleFactory.combinedCache and only use XMLNormalizingLoader.cache to avoid double-caching", "committedDate": "2020-08-07T22:19:59Z", "type": "commit"}]}