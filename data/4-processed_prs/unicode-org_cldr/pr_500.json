{"pr_number": 500, "pr_title": "CLDR-13654 units: add consistency examples and checks, and ability to generate compound names to that end.", "pr_createdAt": "2020-06-02T01:28:07Z", "pr_url": "https://github.com/unicode-org/cldr/pull/500", "timeline": [{"oid": "090c5ba71c31ba37f61b194a80177bc6cc6d8c36", "url": "https://github.com/unicode-org/cldr/commit/090c5ba71c31ba37f61b194a80177bc6cc6d8c36", "message": "CLDR-13654 Add examples and checks\n\nSee #500", "committedDate": "2020-06-05T16:38:46Z", "type": "forcePushed"}, {"oid": "1a25e7509bb6a6cc8c5f52aec8bac0cb7203f56c", "url": "https://github.com/unicode-org/cldr/commit/1a25e7509bb6a6cc8c5f52aec8bac0cb7203f56c", "message": "CLDR-13654 merging changes from master\n\n# Conflicts:\n#\ttools/java/org/unicode/cldr/test/CheckUnits.java\n#\ttools/java/org/unicode/cldr/util/CLDRFile.java\n#\ttools/java/org/unicode/cldr/util/GrammarInfo.java\n#\ttools/java/org/unicode/cldr/util/UnitConverter.java", "committedDate": "2020-06-05T22:44:08Z", "type": "forcePushed"}, {"oid": "51dacbf87ba8b578de2ed28fd6f3aa7d6517927d", "url": "https://github.com/unicode-org/cldr/commit/51dacbf87ba8b578de2ed28fd6f3aa7d6517927d", "message": "CLDR-13654 units: add consistency examples and checks, and ability to generate compound names to that end.\n\nSee #500", "committedDate": "2020-06-07T01:01:09Z", "type": "commit"}, {"oid": "51dacbf87ba8b578de2ed28fd6f3aa7d6517927d", "url": "https://github.com/unicode-org/cldr/commit/51dacbf87ba8b578de2ed28fd6f3aa7d6517927d", "message": "CLDR-13654 units: add consistency examples and checks, and ability to generate compound names to that end.\n\nSee #500", "committedDate": "2020-06-07T01:01:09Z", "type": "forcePushed"}, {"oid": "77b7bc2e7f588bd162b2960e06e51c5a2d207d0d", "url": "https://github.com/unicode-org/cldr/commit/77b7bc2e7f588bd162b2960e06e51c5a2d207d0d", "message": "CLDR-13654 Skip unusual pattern in Ewe", "committedDate": "2020-06-07T04:06:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1MDc2Nw==", "url": "https://github.com/unicode-org/cldr/pull/500#discussion_r437050767", "bodyText": "There are units that do not follow those 3 types, for example in Korean:\n    <unit type=\"concentr-milligram-per-deciliter\">\n        <displayName>\ub370\uc2dc\ub9ac\ud130\ub2f9 \ubc00\ub9ac\uadf8\ub7a8</displayName>\n        <unitPattern count=\"other\">\ub370\uc2dc\ub9ac\ud130\ub2f9 {0}\ubc00\ub9ac\uadf8\ub7a8</unitPattern>\n    </unit>\n\nWill that be an issue here (since it is for per patterns)?", "author": "pedberg-icu", "createdAt": "2020-06-08T23:12:27Z", "path": "tools/java/org/unicode/cldr/util/UnitConverter.java", "diffHunk": "@@ -646,6 +727,175 @@ public String toString() {\n             }\n             return builder.toString();\n         }\n+\n+        public String toString(LocaleStringProvider resolvedFile, String width, String _pluralCategory, String caseVariant, Multimap<UnitPathType, String> partsUsed, boolean maximal) {\n+            if (partsUsed != null) {\n+                partsUsed.clear();\n+            }\n+            String result = null;\n+            String numerator = null;\n+            String timesPattern = null;\n+            boolean before = false;\n+            String placeholderPattern = null;\n+            Output<Integer> deprefix = new Output<>();\n+            Matcher placeholderMatcher = PLACEHOLDER.matcher(\"\");\n+            PluralInfo pluralInfo = CLDRConfig.getInstance().getSupplementalDataInfo().getPlurals(resolvedFile.getLocaleID());\n+            PluralRules pluralRules = pluralInfo.getPluralRules();\n+            String singularPluralCategory = pluralRules.select(1d);\n+            final ULocale locale = new ULocale(resolvedFile.getLocaleID());\n+            String fullPerPattern = null;\n+            int negCount = 0;\n+\n+            for (int i = 1; i >= 0; --i) { // two passes, numerator then den.\n+                boolean positivePass = i > 0;\n+                if (!positivePass) {\n+                    switch(locale.toString()) {\n+                    case \"de\": caseVariant = \"accusative\"; break; // German pro rule\n+                    }\n+                    numerator = result; // from now on, result ::= denominator\n+                    result = null;\n+                }\n+\n+                Map<String, Integer> target = positivePass ? numUnitsToPowers : denUnitsToPowers;\n+                int unitsLeft = target.size();\n+                for (Entry<String, Integer> entry : target.entrySet()) {\n+                    String possiblyPrefixedUnit = entry.getKey();\n+                    String unit = stripPrefixInt(possiblyPrefixedUnit, deprefix);\n+                    String genderVariant = UnitPathType.gender.getTrans(resolvedFile, \"long\", unit, null, null, null, partsUsed);\n+\n+                    int power = entry.getValue();\n+                    unitsLeft--;\n+                    String pluralCategory = unitsLeft == 0 && positivePass ? _pluralCategory : singularPluralCategory;\n+\n+                    if (!positivePass) {\n+                        if (maximal && 0 == negCount++) { // special case exact match for per form, and no previous result\n+                            if (true) {\n+                                throw new UnsupportedOperationException(\"not yet implemented fully\");\n+                            }\n+                            String fullUnit;\n+                            switch(power) {\n+                            case 1: fullUnit = unit; break;\n+                            case 2: fullUnit = \"square-\" + unit; break;\n+                            case 3: fullUnit = \"cubic-\" + unit; break;\n+                            default: throw new IllegalArgumentException(\"powers > 3 not supported\");\n+                            }\n+                            fullPerPattern = UnitPathType.perUnit.getTrans(resolvedFile, width, fullUnit, _pluralCategory, caseVariant, genderVariant, partsUsed);\n+                            // if there is a special form, we'll use it\n+                            if (fullPerPattern != null) {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+\n+                    // handle prefix, like kilo-\n+                    String prefixPattern = null;\n+                    if (deprefix.value != 1) {\n+                        prefixPattern = UnitPathType.prefix.getTrans(resolvedFile, width, \"10p\" + deprefix.value, _pluralCategory, caseVariant, genderVariant, partsUsed);\n+                    }\n+\n+                    // get the core pattern. Detect and remove the the placeholder (and surrounding spaces)\n+                    String unitPattern = UnitPathType.unit.getTrans(resolvedFile, width, unit, pluralCategory, caseVariant, genderVariant, partsUsed);\n+                    if (unitPattern == null) {\n+                        return null; // unavailable\n+                    }\n+                    // we are set up for 2 kinds of placeholder patterns for units. {0}\\s?stuff or stuff\\s?{0}, or nothing(Eg Arabic)", "originalCommit": "77b7bc2e7f588bd162b2960e06e51c5a2d207d0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}