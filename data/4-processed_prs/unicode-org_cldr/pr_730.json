{"pr_number": 730, "pr_title": "CLDR-14016 Revise localeId canonicalization specification", "pr_createdAt": "2020-09-23T03:47:40Z", "pr_url": "https://github.com/unicode-org/cldr/pull/730", "timeline": [{"oid": "24bf00ddadb1f6fd9920f01617fa8060eb2c1172", "url": "https://github.com/unicode-org/cldr/commit/24bf00ddadb1f6fd9920f01617fa8060eb2c1172", "message": "CLDR-14016 Revise localeId canonicalization specification", "committedDate": "2020-09-23T03:46:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MTIwMw==", "url": "https://github.com/unicode-org/cldr/pull/730#discussion_r493191203", "bodyText": "Should probably fix the space after ja-Latn-, that could be confusing", "author": "pedberg-icu", "createdAt": "2020-09-23T04:33:26Z", "path": "docs/ldml/tr35.html", "diffHunk": "@@ -8564,6 +8564,268 @@ <h2><a name=\"Links_to_Other_Parts\" href=\"#Links_to_Other_Parts\"\n       </tr>\n     </table>\n     <hr>\n+    <div class='changed'>\n+\t  <h2><a href=\"#LocaleId_Canonicalization\" name=\"LocaleId_Canonicalization\">Annex C. LocaleId Canonicalization</a></h2>\n+\t  <p>&nbsp;</p>\n+\t\t  <p>The languageAlias, scriptAlias, territoryAlias, and variantAlias elements are used as rules to transform an input\u00a0<em>source\u00a0localeId</em>. The first step is to transform the\u00a0<em>languageId</em>\u00a0portion of the localeId. <br>\n+      </p>\n+\t\t  <blockquote>Note: in the following discussion, the separator '-' is used. That is also used in examples of XML alias data, even though for compatibility reasons that alias data actually uses '_' as a separator. The processing can also be applied to syntax while maintaining the separator '_', <em>mutatis mutandis</em>. CLDR also uses &ldquo;territory&rdquo; and &ldquo;region&rdquo; interchangeably.</blockquote>\n+\t  <h3 >Definitions</h3>\n+\t  <h4 >1. Multimap interpretation</h4>\n+\t\t  <p>Interpret each languageId as a multimap from a <em>fieldId</em> (language, script, region, variants) to a\u00a0<strong>set</strong>\u00a0of field values.</p>\n+\t  <p><em>Examples:</em></p>\n+\t\t  <a ></a><a ></a>\n+\t\t  <table class='simple'>\n+\t\t    <tbody>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"2\"><p> </p>\n+\t\t          <p><strong>Source</strong></p></td>\n+\t\t        <td colspan=\"4\" rowspan=\"1\"><p><strong>Fields</strong></p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>Language</strong></p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>Script</strong></p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>Region</strong></p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>Variants</strong></p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>en-GB</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{en}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{GB}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>und-GB</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{GB}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>ja-Latn-YU-hepburn-heploc</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{ja}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{Latn}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{YU}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{hepburn, heploc}</p></td>\n+\t          </tr>\n+\t        </tbody>\n+      </table>\n+\t\t  <p> </p>\n+\t\t  <ul>\n+\t\t    <li>This can be represented as an abbreviated format: {L={ja}, S={Latn}, R={YU}, V={hepburn, heploc}}, skipping empty sets.</li>\n+\t\t    <li>&ldquo;und&rdquo; is a special language code that is treated as an empty set.</li>\n+\t\t    <li>Of course, only the Variants can contain more than one item: the others are either empty or contain exactly 1 item.</li>\n+      </ul>\n+\t  <h4 >2. Alias elements</h4>\n+\t\t  <p>For the languageAlias elements, the\u00a0<em>type</em>\u00a0and\u00a0<em>replacements</em>\u00a0are languageIds.</p>\n+\t\t  <p>For the script-, territory- (aka region), and variant- Alias elements, the\u00a0type\u00a0and\u00a0replacements\u00a0are interpreted as a languageIds,\u00a0<em>after</em>\u00a0prefixing with &ldquo;und-&rdquo;. Thus</p>\n+\t\t  <code>&lt;territoryAlias\u00a0type=\"AN\"\u00a0replacement=\"CW SX BQ\"\u00a0reason=\"deprecated\"/&gt;</code>\n+\t\t  <p>is interpreted as:</p>\n+\t\t  <code>&lt;territoryAlias\u00a0type=\"und-AN\"\u00a0replacement=\"und-CW und-SX und-BQ\"\u00a0reason=\"deprecated\"/&gt;</code>\n+\t\t  <p>Note that for the case of\u00a0territoryAlias, there may be multiple replacement values separated by spaces in the text (such as\u00a0replacement=\"und-CW und-SX und-BQ\"); other rules only ever have a single replacement value.</p>\n+\t\t  <p> </p>\n+\t  <h4 >3. Matches</h4>\n+\t\t  <p>A rule\u00a0matches\u00a0a source if and only for all fields, each\u00a0<em>source</em>\u00a0field \u2287\u00a0<em>type</em>\u00a0field.</p>\n+\t\t  <blockquote>\n+\t\t  <p><em>Examples:</em></p>\n+\t\t  <p>source=&ldquo;ja-heploc-hepburn&rdquo; and type=&rdquo;und-hepburn&rdquo;</p>\n+\t\t  <table class='simple'>\n+\t\t    <tbody>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{ja} \u2287 {}\u00a0</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>success, und = {}</p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{hepburn, heploc} \u2287 {hepburn}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>success</strong></p></td>\n+\t          </tr>\n+\t        </tbody>\n+\t\t    </table>\n+\t\t  <p>so the rule matches the source. (Note that order of variants is immaterial to matching)</p>\n+\t\t  <p>&nbsp;</p>\n+\t\t  <p> </p>\n+\t\t  <p>source=&ldquo;ja-hepburn&rdquo; and type=&rdquo;und-hepburn-heploc&rdquo;</p>\n+\t\t  <table class='simple'>\n+\t\t    <tbody>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{ja} \u2287 {}\u00a0</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>success, und = {}</p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{hepburn} \u2289 {hepburn, heploc}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>failure</strong></p></td>\n+\t          </tr>\n+\t        </tbody>\n+\t\t    </table>\n+\t\t  <p>so the rule\u00a0does not\u00a0match the source.</p></blockquote>\n+\t  <h4 >4. Replacement</h4>\n+\t  <p>A matching rule can be used to\u00a0transform\u00a0the source fields\u00a0as follows</p>\n+\t\t  <ul>\n+\t\t    <li>if type.field \u2260 {}\n+\t\t      <ul>\n+\t\t        <li>source.field = (source.field - type.field) \u222a replacement.field</li>\n+\t          </ul>\n+\t\t    </li>\n+      \n+\t\t    <li>else if source.field = {} and replacement.field \u2260 {}\n+\t\t      <ul>\n+\t\t        <li>source.field = replacement.field</li>\n+\t          </ul>\n+\t\t    </li>\n+      </ul>\n+\t\t  <p><em>Example:</em></p>\n+\t\t  <blockquote><p>source=ja-Latn- fonipa-hepburn-heploc</p>", "originalCommit": "24bf00ddadb1f6fd9920f01617fa8060eb2c1172", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2MzczMg==", "url": "https://github.com/unicode-org/cldr/pull/730#discussion_r493863732", "bodyText": "fixing 2 instances", "author": "macchiati", "createdAt": "2020-09-23T20:06:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MTIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MTI5Mw==", "url": "https://github.com/unicode-org/cldr/pull/730#discussion_r493191293", "bodyText": "Should probably fix the space after ja-Latn-", "author": "pedberg-icu", "createdAt": "2020-09-23T04:33:56Z", "path": "docs/ldml/tr35.html", "diffHunk": "@@ -8564,6 +8564,268 @@ <h2><a name=\"Links_to_Other_Parts\" href=\"#Links_to_Other_Parts\"\n       </tr>\n     </table>\n     <hr>\n+    <div class='changed'>\n+\t  <h2><a href=\"#LocaleId_Canonicalization\" name=\"LocaleId_Canonicalization\">Annex C. LocaleId Canonicalization</a></h2>\n+\t  <p>&nbsp;</p>\n+\t\t  <p>The languageAlias, scriptAlias, territoryAlias, and variantAlias elements are used as rules to transform an input\u00a0<em>source\u00a0localeId</em>. The first step is to transform the\u00a0<em>languageId</em>\u00a0portion of the localeId. <br>\n+      </p>\n+\t\t  <blockquote>Note: in the following discussion, the separator '-' is used. That is also used in examples of XML alias data, even though for compatibility reasons that alias data actually uses '_' as a separator. The processing can also be applied to syntax while maintaining the separator '_', <em>mutatis mutandis</em>. CLDR also uses &ldquo;territory&rdquo; and &ldquo;region&rdquo; interchangeably.</blockquote>\n+\t  <h3 >Definitions</h3>\n+\t  <h4 >1. Multimap interpretation</h4>\n+\t\t  <p>Interpret each languageId as a multimap from a <em>fieldId</em> (language, script, region, variants) to a\u00a0<strong>set</strong>\u00a0of field values.</p>\n+\t  <p><em>Examples:</em></p>\n+\t\t  <a ></a><a ></a>\n+\t\t  <table class='simple'>\n+\t\t    <tbody>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"2\"><p> </p>\n+\t\t          <p><strong>Source</strong></p></td>\n+\t\t        <td colspan=\"4\" rowspan=\"1\"><p><strong>Fields</strong></p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>Language</strong></p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>Script</strong></p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>Region</strong></p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>Variants</strong></p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>en-GB</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{en}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{GB}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>und-GB</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{GB}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>ja-Latn-YU-hepburn-heploc</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{ja}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{Latn}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{YU}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{hepburn, heploc}</p></td>\n+\t          </tr>\n+\t        </tbody>\n+      </table>\n+\t\t  <p> </p>\n+\t\t  <ul>\n+\t\t    <li>This can be represented as an abbreviated format: {L={ja}, S={Latn}, R={YU}, V={hepburn, heploc}}, skipping empty sets.</li>\n+\t\t    <li>&ldquo;und&rdquo; is a special language code that is treated as an empty set.</li>\n+\t\t    <li>Of course, only the Variants can contain more than one item: the others are either empty or contain exactly 1 item.</li>\n+      </ul>\n+\t  <h4 >2. Alias elements</h4>\n+\t\t  <p>For the languageAlias elements, the\u00a0<em>type</em>\u00a0and\u00a0<em>replacements</em>\u00a0are languageIds.</p>\n+\t\t  <p>For the script-, territory- (aka region), and variant- Alias elements, the\u00a0type\u00a0and\u00a0replacements\u00a0are interpreted as a languageIds,\u00a0<em>after</em>\u00a0prefixing with &ldquo;und-&rdquo;. Thus</p>\n+\t\t  <code>&lt;territoryAlias\u00a0type=\"AN\"\u00a0replacement=\"CW SX BQ\"\u00a0reason=\"deprecated\"/&gt;</code>\n+\t\t  <p>is interpreted as:</p>\n+\t\t  <code>&lt;territoryAlias\u00a0type=\"und-AN\"\u00a0replacement=\"und-CW und-SX und-BQ\"\u00a0reason=\"deprecated\"/&gt;</code>\n+\t\t  <p>Note that for the case of\u00a0territoryAlias, there may be multiple replacement values separated by spaces in the text (such as\u00a0replacement=\"und-CW und-SX und-BQ\"); other rules only ever have a single replacement value.</p>\n+\t\t  <p> </p>\n+\t  <h4 >3. Matches</h4>\n+\t\t  <p>A rule\u00a0matches\u00a0a source if and only for all fields, each\u00a0<em>source</em>\u00a0field \u2287\u00a0<em>type</em>\u00a0field.</p>\n+\t\t  <blockquote>\n+\t\t  <p><em>Examples:</em></p>\n+\t\t  <p>source=&ldquo;ja-heploc-hepburn&rdquo; and type=&rdquo;und-hepburn&rdquo;</p>\n+\t\t  <table class='simple'>\n+\t\t    <tbody>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{ja} \u2287 {}\u00a0</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>success, und = {}</p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{hepburn, heploc} \u2287 {hepburn}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>success</strong></p></td>\n+\t          </tr>\n+\t        </tbody>\n+\t\t    </table>\n+\t\t  <p>so the rule matches the source. (Note that order of variants is immaterial to matching)</p>\n+\t\t  <p>&nbsp;</p>\n+\t\t  <p> </p>\n+\t\t  <p>source=&ldquo;ja-hepburn&rdquo; and type=&rdquo;und-hepburn-heploc&rdquo;</p>\n+\t\t  <table class='simple'>\n+\t\t    <tbody>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{ja} \u2287 {}\u00a0</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>success, und = {}</p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{hepburn} \u2289 {hepburn, heploc}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>failure</strong></p></td>\n+\t          </tr>\n+\t        </tbody>\n+\t\t    </table>\n+\t\t  <p>so the rule\u00a0does not\u00a0match the source.</p></blockquote>\n+\t  <h4 >4. Replacement</h4>\n+\t  <p>A matching rule can be used to\u00a0transform\u00a0the source fields\u00a0as follows</p>\n+\t\t  <ul>\n+\t\t    <li>if type.field \u2260 {}\n+\t\t      <ul>\n+\t\t        <li>source.field = (source.field - type.field) \u222a replacement.field</li>\n+\t          </ul>\n+\t\t    </li>\n+      \n+\t\t    <li>else if source.field = {} and replacement.field \u2260 {}\n+\t\t      <ul>\n+\t\t        <li>source.field = replacement.field</li>\n+\t          </ul>\n+\t\t    </li>\n+      </ul>\n+\t\t  <p><em>Example:</em></p>\n+\t\t  <blockquote><p>source=ja-Latn- fonipa-hepburn-heploc</p>\n+\t\t  <p>rule =&rdquo;&lt;languageAlias type=\"und-hepburn-heploc\"</p>\n+\t\t  <p>replacement=\"und-alalc97\"&gt;&rdquo;</p>\n+\t\t  <p>&nbsp;</p>\n+\t\t  <p>result=&rdquo;ja-Latn-alalc97-fonipa&rdquo; // note that CLDR canonical order of variants is alphabetical</p></blockquote>\n+\t  <h5 >Territory Exception</h5>\n+\t\t  <p>If the field = territory, and the replacement.field has more than one value, then look up the most likely territory* for the base language code (and script, if there is one). If that likely territory is in the list of replacements, use it. Otherwise, use the first territory in the list.</p>\n+\t\t  <p><em>Example:</em></p>\n+\t  <blockquote><p>source=ja-Latn- fonipa-hepburn-heploc</p>", "originalCommit": "24bf00ddadb1f6fd9920f01617fa8060eb2c1172", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MTc3Nw==", "url": "https://github.com/unicode-org/cldr/pull/730#discussion_r493191777", "bodyText": "Shouldn't the prepend be \"und-\" ?", "author": "pedberg-icu", "createdAt": "2020-09-23T04:35:46Z", "path": "docs/ldml/tr35.html", "diffHunk": "@@ -8564,6 +8564,268 @@ <h2><a name=\"Links_to_Other_Parts\" href=\"#Links_to_Other_Parts\"\n       </tr>\n     </table>\n     <hr>\n+    <div class='changed'>\n+\t  <h2><a href=\"#LocaleId_Canonicalization\" name=\"LocaleId_Canonicalization\">Annex C. LocaleId Canonicalization</a></h2>\n+\t  <p>&nbsp;</p>\n+\t\t  <p>The languageAlias, scriptAlias, territoryAlias, and variantAlias elements are used as rules to transform an input\u00a0<em>source\u00a0localeId</em>. The first step is to transform the\u00a0<em>languageId</em>\u00a0portion of the localeId. <br>\n+      </p>\n+\t\t  <blockquote>Note: in the following discussion, the separator '-' is used. That is also used in examples of XML alias data, even though for compatibility reasons that alias data actually uses '_' as a separator. The processing can also be applied to syntax while maintaining the separator '_', <em>mutatis mutandis</em>. CLDR also uses &ldquo;territory&rdquo; and &ldquo;region&rdquo; interchangeably.</blockquote>\n+\t  <h3 >Definitions</h3>\n+\t  <h4 >1. Multimap interpretation</h4>\n+\t\t  <p>Interpret each languageId as a multimap from a <em>fieldId</em> (language, script, region, variants) to a\u00a0<strong>set</strong>\u00a0of field values.</p>\n+\t  <p><em>Examples:</em></p>\n+\t\t  <a ></a><a ></a>\n+\t\t  <table class='simple'>\n+\t\t    <tbody>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"2\"><p> </p>\n+\t\t          <p><strong>Source</strong></p></td>\n+\t\t        <td colspan=\"4\" rowspan=\"1\"><p><strong>Fields</strong></p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>Language</strong></p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>Script</strong></p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>Region</strong></p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>Variants</strong></p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>en-GB</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{en}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{GB}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>und-GB</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{GB}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{}</p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>ja-Latn-YU-hepburn-heploc</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{ja}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{Latn}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{YU}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{hepburn, heploc}</p></td>\n+\t          </tr>\n+\t        </tbody>\n+      </table>\n+\t\t  <p> </p>\n+\t\t  <ul>\n+\t\t    <li>This can be represented as an abbreviated format: {L={ja}, S={Latn}, R={YU}, V={hepburn, heploc}}, skipping empty sets.</li>\n+\t\t    <li>&ldquo;und&rdquo; is a special language code that is treated as an empty set.</li>\n+\t\t    <li>Of course, only the Variants can contain more than one item: the others are either empty or contain exactly 1 item.</li>\n+      </ul>\n+\t  <h4 >2. Alias elements</h4>\n+\t\t  <p>For the languageAlias elements, the\u00a0<em>type</em>\u00a0and\u00a0<em>replacements</em>\u00a0are languageIds.</p>\n+\t\t  <p>For the script-, territory- (aka region), and variant- Alias elements, the\u00a0type\u00a0and\u00a0replacements\u00a0are interpreted as a languageIds,\u00a0<em>after</em>\u00a0prefixing with &ldquo;und-&rdquo;. Thus</p>\n+\t\t  <code>&lt;territoryAlias\u00a0type=\"AN\"\u00a0replacement=\"CW SX BQ\"\u00a0reason=\"deprecated\"/&gt;</code>\n+\t\t  <p>is interpreted as:</p>\n+\t\t  <code>&lt;territoryAlias\u00a0type=\"und-AN\"\u00a0replacement=\"und-CW und-SX und-BQ\"\u00a0reason=\"deprecated\"/&gt;</code>\n+\t\t  <p>Note that for the case of\u00a0territoryAlias, there may be multiple replacement values separated by spaces in the text (such as\u00a0replacement=\"und-CW und-SX und-BQ\"); other rules only ever have a single replacement value.</p>\n+\t\t  <p> </p>\n+\t  <h4 >3. Matches</h4>\n+\t\t  <p>A rule\u00a0matches\u00a0a source if and only for all fields, each\u00a0<em>source</em>\u00a0field \u2287\u00a0<em>type</em>\u00a0field.</p>\n+\t\t  <blockquote>\n+\t\t  <p><em>Examples:</em></p>\n+\t\t  <p>source=&ldquo;ja-heploc-hepburn&rdquo; and type=&rdquo;und-hepburn&rdquo;</p>\n+\t\t  <table class='simple'>\n+\t\t    <tbody>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{ja} \u2287 {}\u00a0</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>success, und = {}</p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{hepburn, heploc} \u2287 {hepburn}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>success</strong></p></td>\n+\t          </tr>\n+\t        </tbody>\n+\t\t    </table>\n+\t\t  <p>so the rule matches the source. (Note that order of variants is immaterial to matching)</p>\n+\t\t  <p>&nbsp;</p>\n+\t\t  <p> </p>\n+\t\t  <p>source=&ldquo;ja-hepburn&rdquo; and type=&rdquo;und-hepburn-heploc&rdquo;</p>\n+\t\t  <table class='simple'>\n+\t\t    <tbody>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{ja} \u2287 {}\u00a0</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>success, und = {}</p></td>\n+\t          </tr>\n+\t\t      <tr>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p>{hepburn} \u2289 {hepburn, heploc}</p></td>\n+\t\t        <td colspan=\"1\" rowspan=\"1\"><p><strong>failure</strong></p></td>\n+\t          </tr>\n+\t        </tbody>\n+\t\t    </table>\n+\t\t  <p>so the rule\u00a0does not\u00a0match the source.</p></blockquote>\n+\t  <h4 >4. Replacement</h4>\n+\t  <p>A matching rule can be used to\u00a0transform\u00a0the source fields\u00a0as follows</p>\n+\t\t  <ul>\n+\t\t    <li>if type.field \u2260 {}\n+\t\t      <ul>\n+\t\t        <li>source.field = (source.field - type.field) \u222a replacement.field</li>\n+\t          </ul>\n+\t\t    </li>\n+      \n+\t\t    <li>else if source.field = {} and replacement.field \u2260 {}\n+\t\t      <ul>\n+\t\t        <li>source.field = replacement.field</li>\n+\t          </ul>\n+\t\t    </li>\n+      </ul>\n+\t\t  <p><em>Example:</em></p>\n+\t\t  <blockquote><p>source=ja-Latn- fonipa-hepburn-heploc</p>\n+\t\t  <p>rule =&rdquo;&lt;languageAlias type=\"und-hepburn-heploc\"</p>\n+\t\t  <p>replacement=\"und-alalc97\"&gt;&rdquo;</p>\n+\t\t  <p>&nbsp;</p>\n+\t\t  <p>result=&rdquo;ja-Latn-alalc97-fonipa&rdquo; // note that CLDR canonical order of variants is alphabetical</p></blockquote>\n+\t  <h5 >Territory Exception</h5>\n+\t\t  <p>If the field = territory, and the replacement.field has more than one value, then look up the most likely territory* for the base language code (and script, if there is one). If that likely territory is in the list of replacements, use it. Otherwise, use the first territory in the list.</p>\n+\t\t  <p><em>Example:</em></p>\n+\t  <blockquote><p>source=ja-Latn- fonipa-hepburn-heploc</p>\n+\t    <p>rule =&rdquo;&lt;languageAlias type=\"und-hepburn-heploc\"</p>\n+\t\t  <p>replacement=\"und-alalc97\"&gt;&rdquo;</p>\n+\t    <p>&nbsp;</p>\n+\t    <p>result=&rdquo;ja-Latn-alalc97-fonipa&rdquo; <em>// note that CLDR canonical order of variants is alphabetical</em></p>\n+\t\t  </blockquote>\n+\t  <h4>5. Canonicalizing Syntax</h4>\n+\t\t<p>To canonicalize the syntax of <em>source</em>: </p>\n+\t\t<ul>\n+\t\t  <li>Initial Script Subtag\n+\t\t    <ul>\n+\t\t      <li>If the first subtag has 4 letters, prepend the source with &quot;-und&quot;</li>", "originalCommit": "24bf00ddadb1f6fd9920f01617fa8060eb2c1172", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2NDU0MA==", "url": "https://github.com/unicode-org/cldr/pull/730#discussion_r493864540", "bodyText": "got it.", "author": "macchiati", "createdAt": "2020-09-23T20:08:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MTc3Nw=="}], "type": "inlineReview"}, {"oid": "402f12d88a18e8d86c9ee8426ac06e4f04741f91", "url": "https://github.com/unicode-org/cldr/commit/402f12d88a18e8d86c9ee8426ac06e4f04741f91", "message": "CLDR-14016 fixing 3 problems noticed in review.", "committedDate": "2020-09-23T20:08:26Z", "type": "commit"}]}