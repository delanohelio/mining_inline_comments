{"pr_number": 4897, "pr_title": "DHFPROD-6201: Visualize history of a record in the document metadata view", "pr_createdAt": "2020-11-20T17:19:22Z", "pr_url": "https://github.com/marklogic/marklogic-data-hub/pull/4897", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxNjAxMw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r527916013", "bodyText": "Should we be ignoring \"hub-core-artifacts\" for both flowNames and stepNames here?\nWe can use a Set for flowNames and stepNames instead of an array.\nNo need to JSON.stringify here since name is already a string.", "author": "akshaysonvane", "createdAt": "2020-11-20T19:10:02Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/entities/entity-search-lib.sjs", "diffHunk": "@@ -535,11 +540,58 @@ function isHubEntityInstance(docUri) {\n   return isHubEntityInstance;\n }\n \n+function getRecordHistory(docUri) {\n+  const history = [];\n+  const provResults = xdmp.invokeFunction(function () {\n+    const match = {\n+      attributes: {\n+        location: docUri\n+      }\n+    };\n+    const out = {\n+      dateTime: '?',\n+      relations: {'associatedWith': '?', 'attributedTo': '?'}\n+    };\n+    const kvPattern = ps.opTriplePattern(match, out);\n+    return op.fromTriples(kvPattern).result();\n+  }, { 'database' : xdmp.database(datahub.config.JOBDATABASE)}).toArray();\n+\n+  if(provResults.length == 0) {\n+    const metadata = xdmp.documentGetMetadata(docUri);\n+    if(metadata) {\n+      const currentObject = {};\n+      currentObject.updatedTime = metadata.datahubCreatedOn ? metadata.datahubCreatedOn : undefined;\n+      currentObject.flow = metadata.datahubCreatedInFlow ? metadata.datahubCreatedInFlow : undefined;\n+      currentObject.step = metadata.datahubCreatedByStep ? metadata.datahubCreatedByStep : undefined;\n+      currentObject.user = metadata.datahubCreatedBy ? metadata.datahubCreatedBy : undefined;\n+      history.push(currentObject);\n+    }\n+  } else {\n+    const flowNames = fn.collection(\"http://marklogic.com/data-hub/flow\").toArray().map(flow => JSON.stringify(flow.toObject().name));\n+    const stepNames = fn.collection([\"http://marklogic.com/data-hub/steps\", \"http://marklogic.com/data-hub/step-definition\"]).toArray().map(step => JSON.stringify(step.toObject().name));", "originalCommit": "6578d19fd325b74ace6bd76e52cb7e57cd8a5651", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxNzIxMw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r527917213", "bodyText": "Once flowNames and stepNames become a Set we can use has instead of includes\nSince provResults[j].associatedWith is an object, we can use String() or .toString() here.", "author": "akshaysonvane", "createdAt": "2020-11-20T19:12:25Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/entities/entity-search-lib.sjs", "diffHunk": "@@ -535,11 +540,58 @@ function isHubEntityInstance(docUri) {\n   return isHubEntityInstance;\n }\n \n+function getRecordHistory(docUri) {\n+  const history = [];\n+  const provResults = xdmp.invokeFunction(function () {\n+    const match = {\n+      attributes: {\n+        location: docUri\n+      }\n+    };\n+    const out = {\n+      dateTime: '?',\n+      relations: {'associatedWith': '?', 'attributedTo': '?'}\n+    };\n+    const kvPattern = ps.opTriplePattern(match, out);\n+    return op.fromTriples(kvPattern).result();\n+  }, { 'database' : xdmp.database(datahub.config.JOBDATABASE)}).toArray();\n+\n+  if(provResults.length == 0) {\n+    const metadata = xdmp.documentGetMetadata(docUri);\n+    if(metadata) {\n+      const currentObject = {};\n+      currentObject.updatedTime = metadata.datahubCreatedOn ? metadata.datahubCreatedOn : undefined;\n+      currentObject.flow = metadata.datahubCreatedInFlow ? metadata.datahubCreatedInFlow : undefined;\n+      currentObject.step = metadata.datahubCreatedByStep ? metadata.datahubCreatedByStep : undefined;\n+      currentObject.user = metadata.datahubCreatedBy ? metadata.datahubCreatedBy : undefined;\n+      history.push(currentObject);\n+    }\n+  } else {\n+    const flowNames = fn.collection(\"http://marklogic.com/data-hub/flow\").toArray().map(flow => JSON.stringify(flow.toObject().name));\n+    const stepNames = fn.collection([\"http://marklogic.com/data-hub/steps\", \"http://marklogic.com/data-hub/step-definition\"]).toArray().map(step => JSON.stringify(step.toObject().name));\n+    for(let i=0; i<provResults.length; i+=3) {\n+      const currentObject = {};\n+      currentObject.updatedTime = provResults[i].dateTime ? provResults[i].dateTime : undefined;\n+      for(let j=i; j<i+3; j++) {\n+        if(flowNames.includes(JSON.stringify(provResults[j].associatedWith))) {\n+          currentObject.flow = provResults[j].associatedWith;\n+        } else if(stepNames.includes(JSON.stringify(provResults[j].associatedWith))) {\n+          currentObject.step = provResults[j].associatedWith;", "originalCommit": "6578d19fd325b74ace6bd76e52cb7e57cd8a5651", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTg2MA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r527959860", "bodyText": "Only this part needs to be amped. And we have a natural home for it - in prov.sjs. But let's not put it in the Provenance class (I don't think we can amp it either if we do that). Just make a new exported function in there.\nTo keep it flexible, make \"out\" (if that is really \"output\", let's call it \"output\" - abbreviations rarely buy us anything) an argument to the function. So how about - findProvenance(uri, relations).\nThen, make the above amp \"findProvenance.json\" - no need for \"amp\" or \"dhf\" in the filename.\nI think it's worth putting the invokeFunction in the amped function too, so that the client doesn't have to worry about doing that part.", "author": "rjrudin", "createdAt": "2020-11-20T20:43:22Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/entities/entity-search-lib.sjs", "diffHunk": "@@ -535,11 +540,58 @@ function isHubEntityInstance(docUri) {\n   return isHubEntityInstance;\n }\n \n+function getRecordHistory(docUri) {\n+  const history = [];\n+  const provResults = xdmp.invokeFunction(function () {", "originalCommit": "6578d19fd325b74ace6bd76e52cb7e57cd8a5651", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2MDE0NA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r527960144", "bodyText": "To shorten this function, put all of this logic into a separate function - e.g. \"getRecordMetadata\".", "author": "rjrudin", "createdAt": "2020-11-20T20:44:01Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/entities/entity-search-lib.sjs", "diffHunk": "@@ -535,11 +540,58 @@ function isHubEntityInstance(docUri) {\n   return isHubEntityInstance;\n }\n \n+function getRecordHistory(docUri) {\n+  const history = [];\n+  const provResults = xdmp.invokeFunction(function () {\n+    const match = {\n+      attributes: {\n+        location: docUri\n+      }\n+    };\n+    const out = {\n+      dateTime: '?',\n+      relations: {'associatedWith': '?', 'attributedTo': '?'}\n+    };\n+    const kvPattern = ps.opTriplePattern(match, out);\n+    return op.fromTriples(kvPattern).result();\n+  }, { 'database' : xdmp.database(datahub.config.JOBDATABASE)}).toArray();\n+\n+  if(provResults.length == 0) {\n+    const metadata = xdmp.documentGetMetadata(docUri);", "originalCommit": "6578d19fd325b74ace6bd76e52cb7e57cd8a5651", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2MTY5Nw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r527961697", "bodyText": "Getting all objects in a collection is generally not a safe practice. While we don't expect there to be hundreds of flows or steps, we can't prevent that.\nInstead, try the following approach:\n\nIterate through provResults first, building up the history array and also building arrays of flow and step names.\nTake all the flow names and use those to query for only the flow objects you need.\nTake all the step names and use those to query for only the steps / step definitions that you need.\nIterate back over the provResults, replacing flow/step if it doesn't exist.\n\nThough - what's the requirement behind populating flow/step only if the flow/step still exists? If it's something for the UI, I think it would be better to add boolean properties of flowExists and stepExists. We shouldn't hide the flow/step name just because it no longer exists.", "author": "rjrudin", "createdAt": "2020-11-20T20:47:30Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/entities/entity-search-lib.sjs", "diffHunk": "@@ -535,11 +540,58 @@ function isHubEntityInstance(docUri) {\n   return isHubEntityInstance;\n }\n \n+function getRecordHistory(docUri) {\n+  const history = [];\n+  const provResults = xdmp.invokeFunction(function () {\n+    const match = {\n+      attributes: {\n+        location: docUri\n+      }\n+    };\n+    const out = {\n+      dateTime: '?',\n+      relations: {'associatedWith': '?', 'attributedTo': '?'}\n+    };\n+    const kvPattern = ps.opTriplePattern(match, out);\n+    return op.fromTriples(kvPattern).result();\n+  }, { 'database' : xdmp.database(datahub.config.JOBDATABASE)}).toArray();\n+\n+  if(provResults.length == 0) {\n+    const metadata = xdmp.documentGetMetadata(docUri);\n+    if(metadata) {\n+      const currentObject = {};\n+      currentObject.updatedTime = metadata.datahubCreatedOn ? metadata.datahubCreatedOn : undefined;\n+      currentObject.flow = metadata.datahubCreatedInFlow ? metadata.datahubCreatedInFlow : undefined;\n+      currentObject.step = metadata.datahubCreatedByStep ? metadata.datahubCreatedByStep : undefined;\n+      currentObject.user = metadata.datahubCreatedBy ? metadata.datahubCreatedBy : undefined;\n+      history.push(currentObject);\n+    }\n+  } else {\n+    const flowNames = fn.collection(\"http://marklogic.com/data-hub/flow\").toArray().map(flow => JSON.stringify(flow.toObject().name));", "originalCommit": "6578d19fd325b74ace6bd76e52cb7e57cd8a5651", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2NDY2Nw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r527964667", "bodyText": "It's difficult to read this test and see that the 3 scenarios called out in the story - no prov records, 1 prov record, and 2 prov records - are being tested.\nAlso, I'd much rather see this tests in core DHF as opposed to HC. In HC, a single smoke test will do the trick.\nSo move the tests to core DHF, write the test against the EntitySearchService - call it GetRecordTest, since you're testing the getRecord endpoint - and I recommend a separate test method for each of the 3 scenarios. The steps don't matter. So for the first one, you can just ingest a record. For the second one, ingest it and map it. For the 3rd, ingest it, map it, and maybe use a custom step (or 2 custom steps instead of map). All values in each row in the history object need to be verified.", "author": "rjrudin", "createdAt": "2020-11-20T20:54:20Z", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -108,9 +108,17 @@ void testCRUDOnSavedQuery() throws Exception {\n         verifyRequestIsForbidden(MockMvcRequestBuilders.delete(SAVED_QUERIES_PATH + \"/query\").param(\"id\", \"some-id\"));\n     }\n \n+    // This test is done at the Java layer as multiple scenarios cannot be tested in ml-unit-tests due to the optic calls occurring in the same request.\n+    // There appears to be a bug with Optic caching values in the same request that is being investigated.\n     @Test\n     void testGetDocumentByURI() throws Exception {\n         ReferenceModelProject project = installOnlyReferenceModelEntities(true);\n+        project.setCustomerDocumentMetadata(new DocumentMetadataHandle()", "originalCommit": "6578d19fd325b74ace6bd76e52cb7e57cd8a5651", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3NjAzMg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r527976032", "bodyText": "There is a getRecordHistoryTest.sjs for that covers all the scenarios. getRecord.sjs test is failing as multiple scenarios cannot be tested in ml-unit-tests due to the optic calls occurring in the same request. There appears to be a bug with Optic caching values in the same request that is being investigated.", "author": "rahulvudutala", "createdAt": "2020-11-20T21:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2NDY2Nw=="}], "type": "inlineReview"}, {"oid": "bbdb468e18dffc811fd08f5df9e7c3597f0bd8cf", "url": "https://github.com/marklogic/marklogic-data-hub/commit/bbdb468e18dffc811fd08f5df9e7c3597f0bd8cf", "message": "DHFPROD-6201: Visualize history of a record in the document metadata view", "committedDate": "2020-11-23T07:50:01Z", "type": "forcePushed"}, {"oid": "65d37a1e4305c77b7959460f509a5b948d75c390", "url": "https://github.com/marklogic/marklogic-data-hub/commit/65d37a1e4305c77b7959460f509a5b948d75c390", "message": "DHFPROD-6201: Visualize history of a record in the document metadata view", "committedDate": "2020-11-23T08:14:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODczMDE0Mg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r528730142", "bodyText": "Please move this to the prov.sjs library, as that library already has a couple functions like this, and this function isn't specific to entity search.", "author": "rjrudin", "createdAt": "2020-11-23T14:12:15Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/entities/entity-search-lib.sjs", "diffHunk": "@@ -535,11 +541,138 @@ function isHubEntityInstance(docUri) {\n   return isHubEntityInstance;\n }\n \n+function getRecordHistory(docUri) {\n+  const history = [];\n+  const relations = {'associatedWith': '?', 'attributedTo': '?'};\n+  const provenanceRecords = entitySearchLib.findProvenance(docUri, relations);\n+\n+  if(provenanceRecords.length) {\n+    const provenanceRecordsById = deNormalizeProvenanceRecordsById(provenanceRecords);\n+    Object.keys(provenanceRecordsById).forEach((provenanceId) => {\n+      const historyObject = {};\n+      const flowAndStepNames = findFlowAndStepNameFromDeNormalizedProvenanceRecords(provenanceRecordsById, provenanceId);\n+      historyObject[\"updatedTime\"] = provenanceRecordsById[provenanceId][\"dateTime\"] ? provenanceRecordsById[provenanceId][\"dateTime\"] : undefined;\n+      historyObject[\"flow\"] = flowAndStepNames[\"flowName\"] ? flowAndStepNames[\"flowName\"] : undefined;\n+      historyObject[\"step\"] = flowAndStepNames[\"stepName\"] ? flowAndStepNames[\"stepName\"] : undefined;\n+      historyObject[\"user\"] = provenanceRecordsById[provenanceId][\"attributedTo\"] ? provenanceRecordsById[provenanceId][\"attributedTo\"] : undefined;\n+      history.push(historyObject);\n+    });\n+  } else {\n+    history.push(getRecordMetadata(docUri));\n+  }\n+  return history;\n+}\n+\n+function deNormalizeProvenanceRecordsById(provenanceRecords) {\n+  const provenanceRecordsById = {};\n+  provenanceRecords.forEach(provenanceRecord => {\n+    const provenanceId = provenanceRecord[\"provID\"];\n+    if(provenanceRecordsById[provenanceId]) {\n+      provenanceRecordsById[provenanceId][\"associatedWith\"].push(provenanceRecord[\"associatedWith\"].toString());\n+    } else {\n+      provenanceRecordsById[provenanceId] = {\n+        \"dateTime\": provenanceRecord[\"dateTime\"],\n+        \"associatedWith\": [provenanceRecord[\"associatedWith\"].toString()],\n+        \"attributedTo\": provenanceRecord[\"attributedTo\"]\n+      };\n+    }\n+  });\n+  return provenanceRecordsById;\n+}\n+\n+function findFlowAndStepNameFromDeNormalizedProvenanceRecords(provenanceRecordsById, provenanceId) {\n+  const flowAndStepNames = {};\n+  const flowNames = findAllFlowNames();\n+  const associatedWith = provenanceRecordsById[provenanceId].associatedWith;\n+  const commonFlowNames = flowNames.filter(artifactName => associatedWith.includes(artifactName));\n+  commonFlowNames.every(artifactName => {\n+    if(provenanceId.includes(artifactName)) {\n+      flowAndStepNames[\"flowName\"] = artifactName;\n+      for (let currentIndex=0; currentIndex<associatedWith.length-1; currentIndex++) {\n+        if(associatedWith[currentIndex] === artifactName) {\n+          let artifactTobeRemoved =  associatedWith[currentIndex];\n+          associatedWith[currentIndex] = associatedWith[associatedWith.length-1];\n+          associatedWith[associatedWith.length-1] = artifactTobeRemoved;\n+          break;\n+        }\n+      }\n+      associatedWith.pop();\n+    }\n+  });\n+\n+  const stepNames = findAllStepNames();\n+  const commonStepNames = stepNames.filter(artifactName => associatedWith.includes(artifactName));\n+  flowAndStepNames[\"stepName\"] = commonStepNames.length ? commonStepNames[0] : undefined;\n+  if(commonStepNames.length == 0) {\n+    const stepDefinitionNames = findAllStepDefinitionNames();\n+    const commonStepDefinitionNames = stepDefinitionNames.filter(artifactName => associatedWith.includes(artifactName));\n+    flowAndStepNames[\"stepName\"] = commonStepDefinitionNames.length ? commonStepDefinitionNames[0] : undefined;\n+  }\n+\n+  return flowAndStepNames;\n+}\n+\n+function getRecordMetadata(docUri) {\n+  const metadata = xdmp.documentGetMetadata(docUri);\n+  const currentObject = {};\n+  if(metadata) {\n+    currentObject.updatedTime = metadata.datahubCreatedOn ? metadata.datahubCreatedOn : undefined;\n+    currentObject.flow = metadata.datahubCreatedInFlow ? metadata.datahubCreatedInFlow : undefined;\n+    currentObject.step = metadata.datahubCreatedByStep ? metadata.datahubCreatedByStep : undefined;\n+    currentObject.user = metadata.datahubCreatedBy ? metadata.datahubCreatedBy : undefined;\n+  }\n+  return currentObject;\n+}\n+\n+function findAllFlowNames() {\n+  const flowArtifactCollection = \"http://marklogic.com/data-hub/flow\";\n+  const flowArtifactUris = cts.uris(null, null, cts.collectionQuery(flowArtifactCollection)).toObject();\n+  const flowNames = flowArtifactUris.map(docUri => docUri.toString().replace('/flows/','').replace(new RegExp('.flow.json' + '$'), '').split(\"/\").pop());\n+  return flowNames;\n+}\n+\n+function findAllStepNames() {\n+  const stepArtifactCollection = \"http://marklogic.com/data-hub/steps\";\n+  const stepArtifactUris = cts.uris(null, null, cts.collectionQuery(stepArtifactCollection)).toObject();\n+  const stepNames = stepArtifactUris.map(docUri => docUri.toString().replace('/steps/','').replace(new RegExp('.step.json' + '$'), '').split(\"/\").pop());\n+  return stepNames;\n+}\n+\n+function findAllStepDefinitionNames() {\n+  const stepDefinitionArtifactCollection = \"http://marklogic.com/data-hub/step-definition\";\n+  const stepDefinitionArtifactUris = cts.uris(null, null, cts.collectionQuery(stepDefinitionArtifactCollection)).toObject();\n+  const stepDefinitionNames = stepDefinitionArtifactUris.map(docUri => docUri.toString().replace('/step-definitions/','').replace(new RegExp('.step.json' + '$'), '').split(\"/\").pop());\n+  return stepDefinitionNames;\n+}\n+\n+module.exports.findProvenance = module.amp(", "originalCommit": "65d37a1e4305c77b7959460f509a5b948d75c390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODczMzgwMA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r528733800", "bodyText": "There's some duplication across these 3 functions for flows, steps, and step definitions. A function like this should eliminate that:\nfunction getArtifactNamesFromUris(collection, expectedPrefix, expectedSuffix) {\n  const names = [];\n  cts.uris(null, null, cts.collectionQuery(collection)).toArray().map(uri => {\n    uri = uri.toString();\n    if (uri.startsWith(expectedPrefix) && uri.endsWith(expectedSuffix)) {\n      flowNames.push(uri.replace(...))\n    }\n  });\n  return names;\n}\n\nAlso, the collection names are defined in consts.sjs already. So import that library, and then you can just do:\nreturn getArtifactNamesFromUris(consts.FLOW_COLLECTION, \"/flows/\", \".flow.json\")", "author": "rjrudin", "createdAt": "2020-11-23T14:17:38Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/entities/entity-search-lib.sjs", "diffHunk": "@@ -535,11 +541,138 @@ function isHubEntityInstance(docUri) {\n   return isHubEntityInstance;\n }\n \n+function getRecordHistory(docUri) {\n+  const history = [];\n+  const relations = {'associatedWith': '?', 'attributedTo': '?'};\n+  const provenanceRecords = entitySearchLib.findProvenance(docUri, relations);\n+\n+  if(provenanceRecords.length) {\n+    const provenanceRecordsById = deNormalizeProvenanceRecordsById(provenanceRecords);\n+    Object.keys(provenanceRecordsById).forEach((provenanceId) => {\n+      const historyObject = {};\n+      const flowAndStepNames = findFlowAndStepNameFromDeNormalizedProvenanceRecords(provenanceRecordsById, provenanceId);\n+      historyObject[\"updatedTime\"] = provenanceRecordsById[provenanceId][\"dateTime\"] ? provenanceRecordsById[provenanceId][\"dateTime\"] : undefined;\n+      historyObject[\"flow\"] = flowAndStepNames[\"flowName\"] ? flowAndStepNames[\"flowName\"] : undefined;\n+      historyObject[\"step\"] = flowAndStepNames[\"stepName\"] ? flowAndStepNames[\"stepName\"] : undefined;\n+      historyObject[\"user\"] = provenanceRecordsById[provenanceId][\"attributedTo\"] ? provenanceRecordsById[provenanceId][\"attributedTo\"] : undefined;\n+      history.push(historyObject);\n+    });\n+  } else {\n+    history.push(getRecordMetadata(docUri));\n+  }\n+  return history;\n+}\n+\n+function deNormalizeProvenanceRecordsById(provenanceRecords) {\n+  const provenanceRecordsById = {};\n+  provenanceRecords.forEach(provenanceRecord => {\n+    const provenanceId = provenanceRecord[\"provID\"];\n+    if(provenanceRecordsById[provenanceId]) {\n+      provenanceRecordsById[provenanceId][\"associatedWith\"].push(provenanceRecord[\"associatedWith\"].toString());\n+    } else {\n+      provenanceRecordsById[provenanceId] = {\n+        \"dateTime\": provenanceRecord[\"dateTime\"],\n+        \"associatedWith\": [provenanceRecord[\"associatedWith\"].toString()],\n+        \"attributedTo\": provenanceRecord[\"attributedTo\"]\n+      };\n+    }\n+  });\n+  return provenanceRecordsById;\n+}\n+\n+function findFlowAndStepNameFromDeNormalizedProvenanceRecords(provenanceRecordsById, provenanceId) {\n+  const flowAndStepNames = {};\n+  const flowNames = findAllFlowNames();\n+  const associatedWith = provenanceRecordsById[provenanceId].associatedWith;\n+  const commonFlowNames = flowNames.filter(artifactName => associatedWith.includes(artifactName));\n+  commonFlowNames.every(artifactName => {\n+    if(provenanceId.includes(artifactName)) {\n+      flowAndStepNames[\"flowName\"] = artifactName;\n+      for (let currentIndex=0; currentIndex<associatedWith.length-1; currentIndex++) {\n+        if(associatedWith[currentIndex] === artifactName) {\n+          let artifactTobeRemoved =  associatedWith[currentIndex];\n+          associatedWith[currentIndex] = associatedWith[associatedWith.length-1];\n+          associatedWith[associatedWith.length-1] = artifactTobeRemoved;\n+          break;\n+        }\n+      }\n+      associatedWith.pop();\n+    }\n+  });\n+\n+  const stepNames = findAllStepNames();\n+  const commonStepNames = stepNames.filter(artifactName => associatedWith.includes(artifactName));\n+  flowAndStepNames[\"stepName\"] = commonStepNames.length ? commonStepNames[0] : undefined;\n+  if(commonStepNames.length == 0) {\n+    const stepDefinitionNames = findAllStepDefinitionNames();\n+    const commonStepDefinitionNames = stepDefinitionNames.filter(artifactName => associatedWith.includes(artifactName));\n+    flowAndStepNames[\"stepName\"] = commonStepDefinitionNames.length ? commonStepDefinitionNames[0] : undefined;\n+  }\n+\n+  return flowAndStepNames;\n+}\n+\n+function getRecordMetadata(docUri) {\n+  const metadata = xdmp.documentGetMetadata(docUri);\n+  const currentObject = {};\n+  if(metadata) {\n+    currentObject.updatedTime = metadata.datahubCreatedOn ? metadata.datahubCreatedOn : undefined;\n+    currentObject.flow = metadata.datahubCreatedInFlow ? metadata.datahubCreatedInFlow : undefined;\n+    currentObject.step = metadata.datahubCreatedByStep ? metadata.datahubCreatedByStep : undefined;\n+    currentObject.user = metadata.datahubCreatedBy ? metadata.datahubCreatedBy : undefined;\n+  }\n+  return currentObject;\n+}\n+\n+function findAllFlowNames() {\n+  const flowArtifactCollection = \"http://marklogic.com/data-hub/flow\";", "originalCommit": "65d37a1e4305c77b7959460f509a5b948d75c390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODczNDUxNg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r528734516", "bodyText": "Let's include a comment on this function to explain why we're using \"updatedTime\" for something that's called \"datahubCreatedOn\" - i.e. we need to explain that the names in the data are incorrect, and what we're really capturing is when the record was last updated.", "author": "rjrudin", "createdAt": "2020-11-23T14:18:46Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/entities/entity-search-lib.sjs", "diffHunk": "@@ -535,11 +541,138 @@ function isHubEntityInstance(docUri) {\n   return isHubEntityInstance;\n }\n \n+function getRecordHistory(docUri) {\n+  const history = [];\n+  const relations = {'associatedWith': '?', 'attributedTo': '?'};\n+  const provenanceRecords = entitySearchLib.findProvenance(docUri, relations);\n+\n+  if(provenanceRecords.length) {\n+    const provenanceRecordsById = deNormalizeProvenanceRecordsById(provenanceRecords);\n+    Object.keys(provenanceRecordsById).forEach((provenanceId) => {\n+      const historyObject = {};\n+      const flowAndStepNames = findFlowAndStepNameFromDeNormalizedProvenanceRecords(provenanceRecordsById, provenanceId);\n+      historyObject[\"updatedTime\"] = provenanceRecordsById[provenanceId][\"dateTime\"] ? provenanceRecordsById[provenanceId][\"dateTime\"] : undefined;\n+      historyObject[\"flow\"] = flowAndStepNames[\"flowName\"] ? flowAndStepNames[\"flowName\"] : undefined;\n+      historyObject[\"step\"] = flowAndStepNames[\"stepName\"] ? flowAndStepNames[\"stepName\"] : undefined;\n+      historyObject[\"user\"] = provenanceRecordsById[provenanceId][\"attributedTo\"] ? provenanceRecordsById[provenanceId][\"attributedTo\"] : undefined;\n+      history.push(historyObject);\n+    });\n+  } else {\n+    history.push(getRecordMetadata(docUri));\n+  }\n+  return history;\n+}\n+\n+function deNormalizeProvenanceRecordsById(provenanceRecords) {\n+  const provenanceRecordsById = {};\n+  provenanceRecords.forEach(provenanceRecord => {\n+    const provenanceId = provenanceRecord[\"provID\"];\n+    if(provenanceRecordsById[provenanceId]) {\n+      provenanceRecordsById[provenanceId][\"associatedWith\"].push(provenanceRecord[\"associatedWith\"].toString());\n+    } else {\n+      provenanceRecordsById[provenanceId] = {\n+        \"dateTime\": provenanceRecord[\"dateTime\"],\n+        \"associatedWith\": [provenanceRecord[\"associatedWith\"].toString()],\n+        \"attributedTo\": provenanceRecord[\"attributedTo\"]\n+      };\n+    }\n+  });\n+  return provenanceRecordsById;\n+}\n+\n+function findFlowAndStepNameFromDeNormalizedProvenanceRecords(provenanceRecordsById, provenanceId) {\n+  const flowAndStepNames = {};\n+  const flowNames = findAllFlowNames();\n+  const associatedWith = provenanceRecordsById[provenanceId].associatedWith;\n+  const commonFlowNames = flowNames.filter(artifactName => associatedWith.includes(artifactName));\n+  commonFlowNames.every(artifactName => {\n+    if(provenanceId.includes(artifactName)) {\n+      flowAndStepNames[\"flowName\"] = artifactName;\n+      for (let currentIndex=0; currentIndex<associatedWith.length-1; currentIndex++) {\n+        if(associatedWith[currentIndex] === artifactName) {\n+          let artifactTobeRemoved =  associatedWith[currentIndex];\n+          associatedWith[currentIndex] = associatedWith[associatedWith.length-1];\n+          associatedWith[associatedWith.length-1] = artifactTobeRemoved;\n+          break;\n+        }\n+      }\n+      associatedWith.pop();\n+    }\n+  });\n+\n+  const stepNames = findAllStepNames();\n+  const commonStepNames = stepNames.filter(artifactName => associatedWith.includes(artifactName));\n+  flowAndStepNames[\"stepName\"] = commonStepNames.length ? commonStepNames[0] : undefined;\n+  if(commonStepNames.length == 0) {\n+    const stepDefinitionNames = findAllStepDefinitionNames();\n+    const commonStepDefinitionNames = stepDefinitionNames.filter(artifactName => associatedWith.includes(artifactName));\n+    flowAndStepNames[\"stepName\"] = commonStepDefinitionNames.length ? commonStepDefinitionNames[0] : undefined;\n+  }\n+\n+  return flowAndStepNames;\n+}\n+\n+function getRecordMetadata(docUri) {\n+  const metadata = xdmp.documentGetMetadata(docUri);\n+  const currentObject = {};\n+  if(metadata) {\n+    currentObject.updatedTime = metadata.datahubCreatedOn ? metadata.datahubCreatedOn : undefined;", "originalCommit": "65d37a1e4305c77b7959460f509a5b948d75c390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc0MTA5OA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r528741098", "bodyText": "I'm not following the implementation here, and this is also doing potentially 3 queries within a loop. If a record has thousands of provenance records (theoretically possible), that could result in thousands of queries.\nI was thinking the way to identify whether associatedWith is a flow, step, or step definition name is by the following:\n\nFind all flow / step / step definition names, store those in 3 separate arrays\nGroup the prov rows by prov ID (I think you can do this in the Optic query as well, so you don't have to code it yourself)\nFor each prov record, convert it into a history entry. To do so, look at the values of attributedWith - if one is in flowNames, then we have a flow name. If one is in step names, we have a step name; else if one is in step definition names, we have a step name too. And you can get updatedTime / user from the first prov row, as those should be the same for each prov row.\nIf needed, order the history array by updatedTime\n\nThat way, we only do 3 queries, regardless of the number of prov rows.", "author": "rjrudin", "createdAt": "2020-11-23T14:27:55Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/entities/entity-search-lib.sjs", "diffHunk": "@@ -535,11 +541,138 @@ function isHubEntityInstance(docUri) {\n   return isHubEntityInstance;\n }\n \n+function getRecordHistory(docUri) {\n+  const history = [];\n+  const relations = {'associatedWith': '?', 'attributedTo': '?'};\n+  const provenanceRecords = entitySearchLib.findProvenance(docUri, relations);\n+\n+  if(provenanceRecords.length) {\n+    const provenanceRecordsById = deNormalizeProvenanceRecordsById(provenanceRecords);\n+    Object.keys(provenanceRecordsById).forEach((provenanceId) => {\n+      const historyObject = {};\n+      const flowAndStepNames = findFlowAndStepNameFromDeNormalizedProvenanceRecords(provenanceRecordsById, provenanceId);", "originalCommit": "65d37a1e4305c77b7959460f509a5b948d75c390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc0MTkzMg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r528741932", "bodyText": "You should be able to do a groupBy here on provID.", "author": "rjrudin", "createdAt": "2020-11-23T14:29:04Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/entities/entity-search-lib.sjs", "diffHunk": "@@ -535,11 +541,138 @@ function isHubEntityInstance(docUri) {\n   return isHubEntityInstance;\n }\n \n+function getRecordHistory(docUri) {\n+  const history = [];\n+  const relations = {'associatedWith': '?', 'attributedTo': '?'};\n+  const provenanceRecords = entitySearchLib.findProvenance(docUri, relations);\n+\n+  if(provenanceRecords.length) {\n+    const provenanceRecordsById = deNormalizeProvenanceRecordsById(provenanceRecords);\n+    Object.keys(provenanceRecordsById).forEach((provenanceId) => {\n+      const historyObject = {};\n+      const flowAndStepNames = findFlowAndStepNameFromDeNormalizedProvenanceRecords(provenanceRecordsById, provenanceId);\n+      historyObject[\"updatedTime\"] = provenanceRecordsById[provenanceId][\"dateTime\"] ? provenanceRecordsById[provenanceId][\"dateTime\"] : undefined;\n+      historyObject[\"flow\"] = flowAndStepNames[\"flowName\"] ? flowAndStepNames[\"flowName\"] : undefined;\n+      historyObject[\"step\"] = flowAndStepNames[\"stepName\"] ? flowAndStepNames[\"stepName\"] : undefined;\n+      historyObject[\"user\"] = provenanceRecordsById[provenanceId][\"attributedTo\"] ? provenanceRecordsById[provenanceId][\"attributedTo\"] : undefined;\n+      history.push(historyObject);\n+    });\n+  } else {\n+    history.push(getRecordMetadata(docUri));\n+  }\n+  return history;\n+}\n+\n+function deNormalizeProvenanceRecordsById(provenanceRecords) {\n+  const provenanceRecordsById = {};\n+  provenanceRecords.forEach(provenanceRecord => {\n+    const provenanceId = provenanceRecord[\"provID\"];\n+    if(provenanceRecordsById[provenanceId]) {\n+      provenanceRecordsById[provenanceId][\"associatedWith\"].push(provenanceRecord[\"associatedWith\"].toString());\n+    } else {\n+      provenanceRecordsById[provenanceId] = {\n+        \"dateTime\": provenanceRecord[\"dateTime\"],\n+        \"associatedWith\": [provenanceRecord[\"associatedWith\"].toString()],\n+        \"attributedTo\": provenanceRecord[\"attributedTo\"]\n+      };\n+    }\n+  });\n+  return provenanceRecordsById;\n+}\n+\n+function findFlowAndStepNameFromDeNormalizedProvenanceRecords(provenanceRecordsById, provenanceId) {\n+  const flowAndStepNames = {};\n+  const flowNames = findAllFlowNames();\n+  const associatedWith = provenanceRecordsById[provenanceId].associatedWith;\n+  const commonFlowNames = flowNames.filter(artifactName => associatedWith.includes(artifactName));\n+  commonFlowNames.every(artifactName => {\n+    if(provenanceId.includes(artifactName)) {\n+      flowAndStepNames[\"flowName\"] = artifactName;\n+      for (let currentIndex=0; currentIndex<associatedWith.length-1; currentIndex++) {\n+        if(associatedWith[currentIndex] === artifactName) {\n+          let artifactTobeRemoved =  associatedWith[currentIndex];\n+          associatedWith[currentIndex] = associatedWith[associatedWith.length-1];\n+          associatedWith[associatedWith.length-1] = artifactTobeRemoved;\n+          break;\n+        }\n+      }\n+      associatedWith.pop();\n+    }\n+  });\n+\n+  const stepNames = findAllStepNames();\n+  const commonStepNames = stepNames.filter(artifactName => associatedWith.includes(artifactName));\n+  flowAndStepNames[\"stepName\"] = commonStepNames.length ? commonStepNames[0] : undefined;\n+  if(commonStepNames.length == 0) {\n+    const stepDefinitionNames = findAllStepDefinitionNames();\n+    const commonStepDefinitionNames = stepDefinitionNames.filter(artifactName => associatedWith.includes(artifactName));\n+    flowAndStepNames[\"stepName\"] = commonStepDefinitionNames.length ? commonStepDefinitionNames[0] : undefined;\n+  }\n+\n+  return flowAndStepNames;\n+}\n+\n+function getRecordMetadata(docUri) {\n+  const metadata = xdmp.documentGetMetadata(docUri);\n+  const currentObject = {};\n+  if(metadata) {\n+    currentObject.updatedTime = metadata.datahubCreatedOn ? metadata.datahubCreatedOn : undefined;\n+    currentObject.flow = metadata.datahubCreatedInFlow ? metadata.datahubCreatedInFlow : undefined;\n+    currentObject.step = metadata.datahubCreatedByStep ? metadata.datahubCreatedByStep : undefined;\n+    currentObject.user = metadata.datahubCreatedBy ? metadata.datahubCreatedBy : undefined;\n+  }\n+  return currentObject;\n+}\n+\n+function findAllFlowNames() {\n+  const flowArtifactCollection = \"http://marklogic.com/data-hub/flow\";\n+  const flowArtifactUris = cts.uris(null, null, cts.collectionQuery(flowArtifactCollection)).toObject();\n+  const flowNames = flowArtifactUris.map(docUri => docUri.toString().replace('/flows/','').replace(new RegExp('.flow.json' + '$'), '').split(\"/\").pop());\n+  return flowNames;\n+}\n+\n+function findAllStepNames() {\n+  const stepArtifactCollection = \"http://marklogic.com/data-hub/steps\";\n+  const stepArtifactUris = cts.uris(null, null, cts.collectionQuery(stepArtifactCollection)).toObject();\n+  const stepNames = stepArtifactUris.map(docUri => docUri.toString().replace('/steps/','').replace(new RegExp('.step.json' + '$'), '').split(\"/\").pop());\n+  return stepNames;\n+}\n+\n+function findAllStepDefinitionNames() {\n+  const stepDefinitionArtifactCollection = \"http://marklogic.com/data-hub/step-definition\";\n+  const stepDefinitionArtifactUris = cts.uris(null, null, cts.collectionQuery(stepDefinitionArtifactCollection)).toObject();\n+  const stepDefinitionNames = stepDefinitionArtifactUris.map(docUri => docUri.toString().replace('/step-definitions/','').replace(new RegExp('.step.json' + '$'), '').split(\"/\").pop());\n+  return stepDefinitionNames;\n+}\n+\n+module.exports.findProvenance = module.amp(\n+    function findProvenance(docUri, relations) {\n+      return xdmp.invokeFunction(function () {\n+        const match = {\n+          attributes: {\n+            location: docUri\n+          }\n+        };\n+        const output = {\n+          dateTime: '?',\n+          relations: relations\n+        };\n+        const kvPattern = ps.opTriplePattern(match, output);\n+        return op.fromTriples(kvPattern).result();", "originalCommit": "65d37a1e4305c77b7959460f509a5b948d75c390", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyMTQ2NA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r528921464", "bodyText": "Though I'm not 100% sure - check with Erik about it. If groupBy doesn't work, custom code is fine.", "author": "rjrudin", "createdAt": "2020-11-23T18:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc0MTkzMg=="}], "type": "inlineReview"}, {"oid": "319a877274f5be12f22eb5d8aad00c60803b2e48", "url": "https://github.com/marklogic/marklogic-data-hub/commit/319a877274f5be12f22eb5d8aad00c60803b2e48", "message": "DHFPROD-6201: Visualize history of a record in the document metadata view", "committedDate": "2020-11-24T03:35:05Z", "type": "forcePushed"}, {"oid": "31755019342ce0602287ccc7b513ee8f95382476", "url": "https://github.com/marklogic/marklogic-data-hub/commit/31755019342ce0602287ccc7b513ee8f95382476", "message": "DHFPROD-6201: Visualize history of a record in the document metadata view", "committedDate": "2020-11-24T03:43:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwMzc1Ng==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r529603756", "bodyText": "I didn't see anywhere that this needed to be exported, I think it can be private to this library.", "author": "rjrudin", "createdAt": "2020-11-24T14:51:29Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/entities/entity-search-lib.sjs", "diffHunk": "@@ -535,11 +537,94 @@ function isHubEntityInstance(docUri) {\n   return isHubEntityInstance;\n }\n \n+function getRecordHistory(docUri) {\n+  const history = [];\n+  const relations = {'associatedWith': '?', 'attributedTo': '?'};\n+  const provenanceRecords = Provenance.findProvenance(docUri, relations);\n+\n+  if(provenanceRecords.length) {\n+    const flowNames = getArtifactNamesFromUris(consts.FLOW_COLLECTION, \"/flows/\", \".flow.json\");\n+    const stepNames = getArtifactNamesFromUris(consts.STEP_COLLECTION, '/steps', '.step.json');\n+    const stepDefinitionNames = getArtifactNamesFromUris(consts.STEP_DEFINITION_COLLECTION, '/step-definitions/', '.step.json');\n+    provenanceRecords.forEach((provenanceRecord) => {\n+      const historyObject = {};\n+      const flowAndStepNames = findFlowAndStepNameFromProvenanceRecords(provenanceRecord, flowNames, stepNames, stepDefinitionNames);\n+      historyObject[\"updatedTime\"] = provenanceRecord[\"dateTime\"] ? provenanceRecord[\"dateTime\"] : undefined;\n+      historyObject[\"flow\"] = flowAndStepNames[\"flowName\"] ? flowAndStepNames[\"flowName\"] : undefined;\n+      historyObject[\"step\"] = flowAndStepNames[\"stepName\"] ? flowAndStepNames[\"stepName\"] : undefined;\n+      historyObject[\"user\"] = provenanceRecord[\"attributedTo\"] ? provenanceRecord[\"attributedTo\"] : undefined;\n+      history.push(historyObject);\n+    });\n+  } else {\n+    const metadata = getRecordMetadata(docUri);\n+    if(Object.keys(metadata).length) {\n+      history.push(getRecordMetadata(docUri));\n+    }\n+  }\n+  return history;\n+}\n+\n+function findFlowAndStepNameFromProvenanceRecords(provenanceRecord, flowNames, stepNames, stepDefinitionNames) {\n+  const flowAndStepNames = {};\n+  const associatedWith = provenanceRecord.associatedWith.toObject();\n+  const commonFlowNames = associatedWith.filter(artifactName => flowNames.includes(artifactName.toString()));\n+\n+  commonFlowNames.forEach(artifactName => {\n+    if(provenanceRecord[\"provID\"].toString().includes(artifactName)) {\n+      flowAndStepNames[\"flowName\"] = artifactName;\n+      for (let currentIndex=0; currentIndex<associatedWith.length-1; currentIndex++) {\n+        if(associatedWith[currentIndex] === artifactName) {\n+          let artifactTobeRemoved =  associatedWith[currentIndex];\n+          associatedWith[currentIndex] = associatedWith[associatedWith.length-1];\n+          associatedWith[associatedWith.length-1] = artifactTobeRemoved;\n+          break;\n+        }\n+      }\n+      associatedWith.pop();\n+    }\n+  });\n+\n+  const commonStepNames = associatedWith.filter(artifactName => stepNames.includes(artifactName));\n+  flowAndStepNames[\"stepName\"] = commonStepNames.length ? commonStepNames[0] : undefined;\n+  if(commonStepNames.length == 0) {\n+    const commonStepDefinitionNames = associatedWith.filter(artifactName => stepDefinitionNames.includes(artifactName));\n+    flowAndStepNames[\"stepName\"] = commonStepDefinitionNames.length ? commonStepDefinitionNames[0] : undefined;\n+  }\n+\n+  return flowAndStepNames;\n+}\n+\n+function getRecordMetadata(docUri) {\n+  const metadata = xdmp.documentGetMetadata(docUri);\n+  const currentObject = {};\n+  if(metadata) {\n+    // datahubCreatedOn field captures the document/record last updated timestamp. It is not the document/record creation timestamp\n+    currentObject.updatedTime = metadata.datahubCreatedOn ? metadata.datahubCreatedOn : undefined;\n+    currentObject.flow = metadata.datahubCreatedInFlow ? metadata.datahubCreatedInFlow : undefined;\n+    currentObject.step = metadata.datahubCreatedByStep ? metadata.datahubCreatedByStep : undefined;\n+    currentObject.user = metadata.datahubCreatedBy ? metadata.datahubCreatedBy : undefined;\n+  }\n+  return currentObject;\n+}\n+\n+function getArtifactNamesFromUris(collection, expectedPrefix, expectedSuffix) {\n+  const artifactNames = [];\n+  cts.uris(null, null, cts.collectionQuery(collection)).toArray().map(uri => {\n+    uri = uri.toString();\n+    if (uri.startsWith(expectedPrefix) && uri.endsWith(expectedSuffix)) {\n+      artifactNames.push(uri.replace(expectedPrefix,'').replace(new RegExp(expectedSuffix + '$'), '').split(\"/\").pop());\n+    }\n+  });\n+  return artifactNames;\n+}\n+\n module.exports = {\n   addDocumentMetadataToSearchResults,\n   addPropertiesToSearchResponse,\n   buildPropertyMetadata,\n+  getArtifactNamesFromUris,", "originalCommit": "31755019342ce0602287ccc7b513ee8f95382476", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNDU2MA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r529604560", "bodyText": "To make it clear what this scenario is testing, name this \"recordHasMetadataButNoProvenance\".", "author": "rjrudin", "createdAt": "2020-11-24T14:52:24Z", "path": "marklogic-data-hub/src/test/java/com/marklogic/hub/dataservices/entitySearch/GetRecordTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package com.marklogic.hub.dataservices.entitySearch;\n+\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.marklogic.client.io.DocumentMetadataHandle;\n+import com.marklogic.client.io.Format;\n+import com.marklogic.hub.AbstractHubCoreTest;\n+import com.marklogic.hub.dataservices.EntitySearchService;\n+import com.marklogic.hub.flow.FlowInputs;\n+import com.marklogic.hub.flow.FlowRunner;\n+import com.marklogic.hub.flow.RunFlowResponse;\n+import com.marklogic.hub.flow.impl.FlowRunnerImpl;\n+import com.marklogic.hub.test.Customer;\n+import com.marklogic.hub.test.ReferenceModelProject;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+//This test is done at the Java layer as multiple scenarios cannot be tested in ml-unit-tests due to the optic calls occurring in the same request.\n+// There appears to be a bug with Optic caching values in the same request that is being investigated.\n+public class GetRecordTest extends AbstractHubCoreTest {\n+\n+    private EntitySearchService service;\n+    private ReferenceModelProject project;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        service = EntitySearchService.on(getHubClient().getFinalClient());\n+        project = installReferenceModelProject();\n+    }\n+\n+    @Test\n+    void testGetRecord() {", "originalCommit": "31755019342ce0602287ccc7b513ee8f95382476", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxMjgxOA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r529612818", "bodyText": "This is testing all other properties in the response from getRecord endpoint except for the history. There are 3 methods for 3 different scenarios for record history", "author": "rahulvudutala", "createdAt": "2020-11-24T15:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNDU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNTMwNg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r529605306", "bodyText": "I think JUnit is fine here, but was the problem that you had multiple scenarios in one test module? Or was there a problem with multiple test modules, each testing one scenario? In ml-unit-test, the setup.xqy module can be used for doing setup before each test module.", "author": "rjrudin", "createdAt": "2020-11-24T14:53:10Z", "path": "marklogic-data-hub/src/test/java/com/marklogic/hub/dataservices/entitySearch/GetRecordTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package com.marklogic.hub.dataservices.entitySearch;\n+\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.marklogic.client.io.DocumentMetadataHandle;\n+import com.marklogic.client.io.Format;\n+import com.marklogic.hub.AbstractHubCoreTest;\n+import com.marklogic.hub.dataservices.EntitySearchService;\n+import com.marklogic.hub.flow.FlowInputs;\n+import com.marklogic.hub.flow.FlowRunner;\n+import com.marklogic.hub.flow.RunFlowResponse;\n+import com.marklogic.hub.flow.impl.FlowRunnerImpl;\n+import com.marklogic.hub.test.Customer;\n+import com.marklogic.hub.test.ReferenceModelProject;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+//This test is done at the Java layer as multiple scenarios cannot be tested in ml-unit-tests due to the optic calls occurring in the same request.", "originalCommit": "31755019342ce0602287ccc7b513ee8f95382476", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyODI1MQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r529628251", "bodyText": "This was the error.\nOPTIC-INVALARGS: fn.error(null, 'OPTIC-INVALARGS', errMsg+arg); -- Invalid arguments: cannot call pattern() with invalid predicates : [object Object]\nI had multiple multiple scenarios in one test module", "author": "rahulvudutala", "createdAt": "2020-11-24T15:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNTMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNjQyNw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r529606427", "bodyText": "Why not use the existing ingestion / mapping steps in this flow? I ask because this project gets loaded by a lot of tests, so I'd like to only add a new artifact to it if we really need it.", "author": "rjrudin", "createdAt": "2020-11-24T14:54:37Z", "path": "marklogic-data-hub/src/test/resources/entity-reference-model/flows/ingestToFinal.flow.json", "diffHunk": "@@ -37,6 +37,12 @@\n         \"targetDatabase\": \"data-hub-STAGING\",\n         \"permissions\": \"data-hub-common,read,data-hub-common,update\"\n       }\n+    },", "originalCommit": "31755019342ce0602287ccc7b513ee8f95382476", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxMzAxMg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r529613012", "bodyText": "Added new steps to verify if the step name is returned or not. Otherwise step-defintion name is returned when the existing steps are used.", "author": "rahulvudutala", "createdAt": "2020-11-24T15:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNjQyNw=="}], "type": "inlineReview"}, {"oid": "47bcd69ad2ad0e51957cad163b677f930415fd8d", "url": "https://github.com/marklogic/marklogic-data-hub/commit/47bcd69ad2ad0e51957cad163b677f930415fd8d", "message": "DHFPROD-6201: Visualize history of a record in the document metadata view", "committedDate": "2020-11-24T15:36:17Z", "type": "forcePushed"}, {"oid": "aa90c419e6bf558d0a1941640a112e98c5051ecf", "url": "https://github.com/marklogic/marklogic-data-hub/commit/aa90c419e6bf558d0a1941640a112e98c5051ecf", "message": "DHFPROD-6201: Visualize history of a record in the document metadata view", "committedDate": "2020-11-24T18:41:34Z", "type": "forcePushed"}, {"oid": "0ddfc4a856318d1531e595ff09b7d38d374f2c05", "url": "https://github.com/marklogic/marklogic-data-hub/commit/0ddfc4a856318d1531e595ff09b7d38d374f2c05", "message": "DHFPROD-6201: Visualize history of a record in the document metadata view", "committedDate": "2020-11-24T18:54:51Z", "type": "forcePushed"}, {"oid": "4d7458b419aee92038da3d0cddff539961dd99c8", "url": "https://github.com/marklogic/marklogic-data-hub/commit/4d7458b419aee92038da3d0cddff539961dd99c8", "message": "DHFPROD-6201: Visualize history of a record in the document metadata view", "committedDate": "2020-11-24T19:34:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgyOTQ3Mg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r529829472", "bodyText": "You don't need this anymore, as flowNames = Object.keys(flows).\nAlso, I recommend renaming \"flows\" to \"flowsMap\". That makes it self-documenting that it's a map and not an array or sequence, which is what \"flows\" implies.", "author": "rjrudin", "createdAt": "2020-11-24T19:34:54Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/entities/entity-search-lib.sjs", "diffHunk": "@@ -535,11 +537,112 @@ function isHubEntityInstance(docUri) {\n   return isHubEntityInstance;\n }\n \n+function getRecordHistory(docUri) {\n+  const history = [];\n+  const relations = {'associatedWith': '?', 'attributedTo': '?'};\n+  const provenanceRecords = Provenance.findProvenance(docUri, relations);\n+\n+  if(provenanceRecords.length) {\n+    const flows = findFlowsAsMap();\n+    const flowNames = getArtifactNamesFromUris(consts.FLOW_COLLECTION, \"/flows/\", \".flow.json\");", "originalCommit": "4d7458b419aee92038da3d0cddff539961dd99c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgzMDA0MQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4897#discussion_r529830041", "bodyText": "Recommend removing this so there's no expectation that a range index is needed.", "author": "rjrudin", "createdAt": "2020-11-24T19:35:56Z", "path": "marklogic-data-hub/src/test/resources/test-projects/provenance-test/entities/Customer.entity.json", "diffHunk": "@@ -0,0 +1,17 @@\n+{\n+  \"info\": {\n+    \"title\": \"Customer\",\n+    \"version\": \"0.0.1\",\n+    \"baseUri\": \"http://example.org/\"\n+  },\n+  \"definitions\": {\n+    \"Customer\": {\n+      \"properties\": {\n+        \"customerId\": {\n+          \"datatype\": \"integer\",\n+          \"sortable\": true", "originalCommit": "4d7458b419aee92038da3d0cddff539961dd99c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3a400e2f02915d5818e6d23e9748f0119f3a9d5e", "url": "https://github.com/marklogic/marklogic-data-hub/commit/3a400e2f02915d5818e6d23e9748f0119f3a9d5e", "message": "DHFPROD-6201: Visualize history of a record in the document metadata view", "committedDate": "2020-11-24T19:59:14Z", "type": "commit"}, {"oid": "3a400e2f02915d5818e6d23e9748f0119f3a9d5e", "url": "https://github.com/marklogic/marklogic-data-hub/commit/3a400e2f02915d5818e6d23e9748f0119f3a9d5e", "message": "DHFPROD-6201: Visualize history of a record in the document metadata view", "committedDate": "2020-11-24T19:59:14Z", "type": "forcePushed"}]}