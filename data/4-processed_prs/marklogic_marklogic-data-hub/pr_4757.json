{"pr_number": 4757, "pr_title": "DHFPROD-5664: Run Hub Central merge steps", "pr_createdAt": "2020-10-23T17:41:41Z", "pr_url": "https://github.com/marklogic/marklogic-data-hub/pull/4757", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5NzE2Mg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4757#discussion_r511197162", "bodyText": "ds-utils.sjs can be used for this, though it needs a throwNotFound function for handling a 400.", "author": "rjrudin", "createdAt": "2020-10-23T23:34:04Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/builtins/steps/mastering/default/merging.sjs", "diffHunk": "@@ -22,13 +22,24 @@ const processedURIs = [];\n \n function main(content, options) {\n   // These index references can't be out this function scope or the jobReport will error, since they don't exist for the jobs DB\n+  if (options.stepId) {\n+    const stepDoc = fn.head(cts.search(cts.andQuery([\n+      cts.collectionQuery(\"http://marklogic.com/data-hub/steps\"),\n+      cts.jsonPropertyValueQuery(\"stepId\", options.stepId, \"case-insensitive\")\n+    ])));\n+    if (stepDoc) {\n+      options = stepDoc.toObject();\n+      isSeparateMatchStep = true;\n+    } else {\n+      fn.error(null, 'RESTAPI-SRVEXERR', Sequence.from([400, `Could not find step with stepId ${options.stepId}`]));", "originalCommit": "17a9588b3f482f5b0f1d8b76a13861deb6d2da23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5NzE3NQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4757#discussion_r511197175", "bodyText": "Is it known what type of step this is - i.e. is it known to be a merging step, since this is the merging module? If so, can the artifacts/core library be used here instead to find the step document?", "author": "rjrudin", "createdAt": "2020-10-23T23:34:09Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/builtins/steps/mastering/default/merging.sjs", "diffHunk": "@@ -22,13 +22,24 @@ const processedURIs = [];\n \n function main(content, options) {\n   // These index references can't be out this function scope or the jobReport will error, since they don't exist for the jobs DB\n+  if (options.stepId) {\n+    const stepDoc = fn.head(cts.search(cts.andQuery([", "originalCommit": "17a9588b3f482f5b0f1d8b76a13861deb6d2da23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5ODE2Ng==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4757#discussion_r511198166", "bodyText": "I think a cache needs a comment describing why it helps. Based on the code below, my assumption would be that build-merging-map is called multiple times, and thus we're avoid a potentially expensive operation - the md5/describe call. But I only see build-merging-map called by compile-merge-options. Is that called enough times to warrant having a cache around?", "author": "rjrudin", "createdAt": "2020-10-23T23:39:23Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/survivorship/merging/options.xqy", "diffHunk": "@@ -564,3 +583,300 @@ declare function merge-impl:propertyspec-to-json($property-spec as element()) as\n     json:transform-to-json($transformed-xml, $config)/*\n };\n \n+declare variable $_cached-compiled-merge-options as map:map := map:map();\n+\n+declare function merge-impl:compile-merge-options(\n+  $merge-options as item() (: as node()|json:object :)\n+) {\n+  merge-impl:compile-merge-options(\n+    $merge-options,\n+    fn:false()\n+  )\n+};\n+\n+(:\n+ : Calculate merge information once per unique merge options in request to reduce repeat logic\n+ : @param $merge-options  Options specifying how documents will be merged\n+ : @param $only-warn-on-error  boolean indicating if errors should be returned rather than thrown\n+ : @return map:map with compiled information about merge options\n+ :)\n+declare function merge-impl:compile-merge-options(\n+  $merge-options as item() (: as node()|json:object :),\n+  $only-warn-on-error as xs:boolean\n+) {\n+  let $merge-options :=\n+    typeswitch($merge-options)\n+    case json:object|map:map return\n+        xdmp:to-json($merge-options)/object-node()\n+    case node() return\n+      $merge-options\n+    default return\n+      fn:error((), \"Shouldn't happen\", $merge-options)\n+  let $merge-options := if (fn:exists($merge-options/(*:options|mergeOptions))) then\n+      $merge-options/(*:options|mergeOptions)\n+    else\n+      $merge-options\n+  let $cache-id :=\n+      xdmp:md5(xdmp:describe($merge-options, (), ()))\n+  return\n+    if (map:contains($_cached-compiled-merge-options, $cache-id)) then\n+      map:get($_cached-compiled-merge-options, $cache-id)\n+    else\n+      let $_trace := if (xdmp:trace-enabled($const:TRACE-MERGE-RESULTS)) then\n+          xdmp:trace($const:TRACE-MERGE-RESULTS, \"compiling merge options: \" || xdmp:describe($merge-options, (), ()))\n+        else\n+          ()\n+    let $message-output :=\n+      if ($only-warn-on-error) then\n+        map:map()\n+      else ()\n+    let $target-entity := $merge-options/(*:target-entity|targetEntity|targetEntityType) ! fn:string(.)\n+    let $target-entity-type-def := es-helper:get-entity-def($target-entity)\n+    let $target-entity-type := $target-entity-type-def/entityIRI ! fn:string(.)\n+    let $merge-rules := $merge-options/(merging:merging/merging:merge|merge|mergeRules)\n+    let $property-defs := $merge-options/(*:property-defs|propertyDefs)\n+    let $property-names-to-values :=\n+      util-impl:properties-to-values-functions(\n+        $merge-rules,\n+        $property-defs,\n+        $target-entity-type-def/entityIRI,\n+        fn:true(),\n+        $message-output\n+      )\n+  let $merge-algorithms := merge-impl:build-merging-map((\n+      (: old algorithm format :)\n+      $merge-options/*:algorithms/(custom|merging:algorithm),\n+      (: new algorithm format :)\n+      $merge-rules/(mergeStrategies|mergeRules)[mergeModulePath[fn:normalize-space(.)]]\n+    ))\n+  let $namespaces :=\n+    if (fn:exists($property-defs/namespaces)) then\n+      xdmp:from-json($property-defs/namespaces)\n+    else\n+      merge-impl:build-prefix-map($property-defs)\n+  let $merge-options-uri := $merge-options ! xdmp:node-uri(.)\n+  let $merge-options-ref :=\n+    if (fn:exists($merge-options-uri)) then\n+      $merge-options-uri\n+    else if (fn:exists($merge-options)) then\n+      xdmp:base64-encode(xdmp:describe($merge-options, (), ()))\n+    else\n+      null-node{}\n+  let $on-no-match := $merge-options/(*:algorithms/*:collections|targetCollections)/(merging:on-no-match|onNoMatch)\n+  let $on-archive := $merge-options/(*:algorithms/*:collections|targetCollections)/(merging:on-archive|onArchive)\n+  let $on-merge := $merge-options/(*:algorithms/*:collections|targetCollections)/(merging:on-merge|onMerge)\n+  let $on-notification := $merge-options/(*:algorithms/*:collections|targetCollections)/(merging:on-notification|onNotification)\n+  let $ts-ns-path := $merge-options/(*:algorithms/(merging:std-algorithm|stdAlgorithm)|lastUpdatedLocation)\n+  let $ts-path := fn:string($ts-ns-path/(*:timestamp/(@path|path)|documentXPath))\n+  let $ts-ns-map :=\n+    if (fn:exists($ts-ns-path/namespaces)) then\n+      xdmp:from-json($ts-ns-path/namespaces)\n+    else if (fn:exists($ts-ns-path)) then\n+      merge-impl:build-prefix-map($ts-ns-path)\n+    else ()\n+  let $last-updated-function := function($document) {\n+    if (fn:string-length($ts-path) > 0) then\n+      fn:head(xdmp:unpath($ts-path, $ts-ns-map, $document)[. castable as xs:dateTime] ! xs:dateTime(.))\n+    else ()\n+  }\n+  let $default-merge-rule-info :=\n+      map:entry(\"mergeAlgorithm\", merge-impl:standard#3)\n+        => map:with(\"mergeAlgorithmName\", \"standard\")\n+        => map:with(\"mergeRule\", merge-impl:expand-merge-rule($merge-options, ()))\n+  let $compiled-merge-options :=\n+      map:entry(\"targetEntityType\", $target-entity-type)\n+        => map:with(\"targetEntityTypeDefinition\", $target-entity-type-def)\n+        => map:with(\"mergeOptionsNode\", $merge-options)\n+        => map:with(\"lastUpdatedFunction\", $last-updated-function)\n+        => map:with(\"namespaces\", $namespaces)\n+        => map:with(\"onNoMatch\", $on-no-match)\n+        => map:with(\"onArchive\", $on-archive)\n+        => map:with(\"onMerge\", $on-merge)\n+        => map:with(\"onNotification\", $on-notification)\n+        => map:with(\"mergeOptionsRef\", $merge-options-ref)\n+        => map:with(\"defaultMergeRuleInfo\", $default-merge-rule-info)\n+        => map:with(\"mergeRulesInfo\",\n+          let $explicit-merge-rules :=\n+            for $merge-rule in $merge-rules\n+            let $merge-rule := merge-impl:expand-merge-rule($merge-options, $merge-rule)\n+            let $property-name := fn:string(fn:head($merge-rule/(@property-name|propertyName|entityPropertyPath|documentXPath)))\n+            let $property-def := $property-defs/(merging:property|properties)[(@name|name) = $property-name]\n+            let $path := fn:head((\n+                $merge-rule/documentXPath,\n+                $property-def/(@path|path)\n+              ))\n+            let $property-qname := fn:head((\n+                $property-def[localname] ! fn:QName(fn:string(./namespace), fn:string(./localname)),\n+                $property-def[@localname] ! fn:QName(fn:string(./@namespace), fn:string(./@localname)),\n+                $target-entity-type-def ! fn:QName(fn:string(./namespaceURI), $property-name)\n+              ))\n+            let $to-property-values := $property-names-to-values => map:get($property-name)\n+            let $algorithm-name := if (fn:exists($merge-rule/mergeFunction[fn:normalize-space(.)])) then\n+                                      fn:string($merge-rule/mergeModulePath) || \":\" || fn:string($merge-rule/mergeFunction)\n+                                  else\n+                                      fn:string(fn:head($merge-rule/(@algorithm-ref|algorithmRef)))\n+            let $merge-algorithm := $merge-algorithms => map:get($algorithm-name)\n+            return (\n+              xdmp:trace($const:TRACE-MERGE-RESULTS, \"Explicit merge for property: \" || $property-name),\n+              map:entry(\"propertyName\", $property-name)\n+                => map:with(\"propertyQName\", $property-qname)\n+                => map:with(\"documentToValuesFunction\", $to-property-values)\n+                => map:with(\"mergeAlgorithm\", $merge-algorithm)\n+                => map:with(\"mergeAlgorithmName\", $algorithm-name)\n+                => map:with(\"mergeRule\", $merge-rule)\n+                => map:with(\"path\", $path)\n+                => map:with(\"namespaces\", fn:head(($merge-rule/namespaces ! xdmp:from-json(.), $namespaces)))\n+            )\n+          let $implicit-top-level-merges :=\n+            for $top-level-property-name in map:keys($property-names-to-values)[fn:not(fn:contains(.,\".\"))]\n+            let $prefix := $top-level-property-name || \".\"\n+            where fn:empty($explicit-merge-rules[map:get(., \"propertyName\")[. = $top-level-property-name or fn:starts-with(., $prefix)]])\n+            return\n+              let $to-property-values := $property-names-to-values => map:get($top-level-property-name)\n+              let $merge-rule := merge-impl:expand-merge-rule($merge-options, ())\n+              let $property-qname := fn:QName(fn:string($target-entity-type-def/namespaceURI), $top-level-property-name)\n+              return (\n+                xdmp:trace($const:TRACE-MERGE-RESULTS, \"Implicit merge for top-level property: \" || $top-level-property-name),\n+                map:new((\n+                  $default-merge-rule-info,\n+                  map:entry(\"propertyName\", $top-level-property-name)\n+                    => map:with(\"propertyQName\", $property-qname)\n+                    => map:with(\"documentToValuesFunction\", $to-property-values)\n+                    => map:with(\"mergeRule\", $merge-rule)\n+                ))\n+              )\n+          return ($explicit-merge-rules, $implicit-top-level-merges)\n+        )\n+  return (\n+    if (xdmp:trace-enabled($const:TRACE-MERGE-RESULTS)) then\n+      xdmp:trace($const:TRACE-MERGE-RESULTS, \"Compiled merge options: \" || xdmp:to-json-string($compiled-merge-options))\n+    else (),\n+    $compiled-merge-options,\n+    if (xdmp:trace-enabled($const:TRACE-MERGE-RESULTS)) then\n+      xdmp:trace($const:TRACE-MERGE-RESULTS, \"Caching compiled merge options with key: \" || $cache-id)\n+    else (),\n+    map:put($_cached-compiled-merge-options, $cache-id, $compiled-merge-options)\n+  )\n+};\n+\n+declare function merge-impl:build-prefix-map($source)\n+{\n+  map:new(\n+    for $prefix in ($source ! fn:in-scope-prefixes(.))\n+    where fn:not($prefix = \"\")\n+    return\n+      map:entry($prefix, fn:namespace-uri-for-prefix($prefix, $source))\n+  )\n+};\n+\n+(:\n+ : Get a function reference to the default merging function. The function must\n+ : be in the http://marklogic.com/smart-mastering/survivorship/merging\n+ : namespace.\n+ : @param $name  localname of the function to be applied\n+ : @param $arity  number of parameters the function takes\n+ : @return function reference if found\n+ :)\n+declare function merge-impl:default-function-lookup(\n+  $name as xs:string?,\n+  $arity as xs:int\n+) as function(*)?\n+{\n+  fn:function-lookup(\n+    fn:QName(\n+      \"http://marklogic.com/smart-mastering/survivorship/merging\",\n+      if (fn:exists($name[. ne \"\"])) then\n+        $name\n+      else\n+        \"standard\"\n+    ),\n+    $arity\n+  )\n+};\n+\n+declare variable $cached-merging-map as map:map := map:map();", "originalCommit": "17a9588b3f482f5b0f1d8b76a13861deb6d2da23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5ODg1NQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/4757#discussion_r511198855", "bodyText": "I'm wondering if this function can be broken up into several smaller functions. It's about 150 lines with many conditionals, and thus it's difficult to understand all the things that comprise compiling match options. Perhaps it's an exercise for later, I just find long methods like this to be difficult to read and understand.\nI know it can be difficult too to create lots of small functions in XQuery. My experience has been that in the absence of classes (which are very effective at carrying out related bits of data with self-documenting field names), we can use maps and arbitrary XML fragments to carry around related bits of data. So a typical problem I've run into with trying to decompose a large XQuery function into smaller functions is I've got a lot of state represented by variables, and I may have to pass in several arguments to a function in order for it to do what it needs to do. So I do find it more difficult to create lots of small functions with self-documenting names that do one thing and one thing only - at least it's more difficult in XQuery than in Java. Still, I think at some point, we need more of this in the mastering code to help more developers be able to read and understand it, and thus be able to maintain and enhance it.", "author": "rjrudin", "createdAt": "2020-10-23T23:43:14Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/survivorship/merging/options.xqy", "diffHunk": "@@ -564,3 +583,300 @@ declare function merge-impl:propertyspec-to-json($property-spec as element()) as\n     json:transform-to-json($transformed-xml, $config)/*\n };\n \n+declare variable $_cached-compiled-merge-options as map:map := map:map();\n+\n+declare function merge-impl:compile-merge-options(\n+  $merge-options as item() (: as node()|json:object :)\n+) {\n+  merge-impl:compile-merge-options(\n+    $merge-options,\n+    fn:false()\n+  )\n+};\n+\n+(:\n+ : Calculate merge information once per unique merge options in request to reduce repeat logic\n+ : @param $merge-options  Options specifying how documents will be merged\n+ : @param $only-warn-on-error  boolean indicating if errors should be returned rather than thrown\n+ : @return map:map with compiled information about merge options\n+ :)\n+declare function merge-impl:compile-merge-options(", "originalCommit": "17a9588b3f482f5b0f1d8b76a13861deb6d2da23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "761d3e78df9d1dc8fdd185b2965ef081954ebffa", "url": "https://github.com/marklogic/marklogic-data-hub/commit/761d3e78df9d1dc8fdd185b2965ef081954ebffa", "message": "DHFPROD-5664: Run Hub Central merge steps", "committedDate": "2020-10-27T05:19:55Z", "type": "forcePushed"}, {"oid": "cf9a251b6f7482e007ca4864a24d6819a3aac76b", "url": "https://github.com/marklogic/marklogic-data-hub/commit/cf9a251b6f7482e007ca4864a24d6819a3aac76b", "message": "DHFPROD-5664: Run Hub Central merge steps", "committedDate": "2020-10-27T21:04:17Z", "type": "forcePushed"}, {"oid": "5612f46b7157802b68c564eec75bbbb7e2ae1246", "url": "https://github.com/marklogic/marklogic-data-hub/commit/5612f46b7157802b68c564eec75bbbb7e2ae1246", "message": "DHFPROD-5664: Run Hub Central merge steps", "committedDate": "2020-10-28T03:28:55Z", "type": "commit"}, {"oid": "5612f46b7157802b68c564eec75bbbb7e2ae1246", "url": "https://github.com/marklogic/marklogic-data-hub/commit/5612f46b7157802b68c564eec75bbbb7e2ae1246", "message": "DHFPROD-5664: Run Hub Central merge steps", "committedDate": "2020-10-28T03:28:55Z", "type": "forcePushed"}]}