{"pr_number": 5019, "pr_title": "DHFPROD-5236: Make multi value properties work for the match step fro\u2026", "pr_createdAt": "2020-12-17T20:00:41Z", "pr_url": "https://github.com/marklogic/marklogic-data-hub/pull/5019", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxNjE5MQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r545416191", "bodyText": "This is throwing an error, likely due to a rebase. This variable should be $target-entity-type-def now.", "author": "ryanjdew", "createdAt": "2020-12-17T21:31:05Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/matcher-impl/options-impl.xqy", "diffHunk": "@@ -424,71 +424,78 @@ declare function opt-impl:compile-match-options(\n           $rule-set/matchRules\n         else\n           $rule-set\n+      let $multi-struct-prop-multi-value-map :=\n+        if ($is-complex-rule) then\n+          opt-impl:multi-struct-prop-multi-value-map($match-rules, $target-entity-def)", "originalCommit": "99a2cdf5890af44592f1e317860fe87aac8ff30b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxODY0MA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r545418640", "bodyText": "Yes, from rebase. Fixed.", "author": "fsnow", "createdAt": "2020-12-17T21:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxNjE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Mzk2Nw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r545443967", "bodyText": "This should be or instead of ||", "author": "ryanjdew", "createdAt": "2020-12-17T22:26:32Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/matcher-impl/matcher-impl.xqy", "diffHunk": "@@ -355,20 +373,84 @@ declare function match-impl:query-map-to-query(\n       return (\n         if (fn:exists($query-prov)) then\n           for $query-hash in document {$query}//schema-element(cts:query) ! xdmp:md5(document{.})\n-          where fn:not(map:contains($query-prov,$query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n+          where fn:not(map:contains($query-prov, $query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n           return map:put($query-prov, $query-hash, $sub-query-map)\n         else (),\n         $query\n+      ),\n+\n+      match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity)\n       )\n     (: We want to be certain that didn't lose any queries in the match ruleset, since we don't call the function if no values exist :)\n-    where fn:exists($queries) and fn:count($queries) eq fn:count($sub-query-maps)\n+    (: FSnow: need to remove the count check since we are returning one query for multiple properties in the structured property case :)\n+    where fn:exists($queries) (: and fn:count($queries) eq fn:count($sub-query-maps) :)\n     return (\n-      map:put($cached-queries, $query-map => map:get(\"matchRulesetId\"), $queries),\n+      (: no caching in the structured properties case (yet) :)\n+      if (fn:not(map:contains($query-map, \"multiStructPropMultiValueMap\"))) then\n+        map:put($cached-queries, $query-map => map:get(\"matchRulesetId\"), $queries)\n+      else\n+        ()\n+      ,\n       $queries\n     )\n \n };\n \n+declare function match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity as xs:string?)\n+  as cts:query*\n+{\n+  let $multi-struct-prop-multi-value-map := map:get($query-map, \"multiStructPropMultiValueMap\")\n+  return\n+    if (fn:empty($multi-struct-prop-multi-value-map) || fn:empty($target-entity)) then", "originalCommit": "c80a0408b663db523ad1ada675ca2d55fd6ccffe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ2NDMxMw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r545464313", "bodyText": "I think here we will want to use the valuesToQueryFunction from the individual match rules in the query-map in order so we can call match functions other than 'exact'.", "author": "ryanjdew", "createdAt": "2020-12-17T23:08:54Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/matcher-impl/matcher-impl.xqy", "diffHunk": "@@ -355,20 +373,84 @@ declare function match-impl:query-map-to-query(\n       return (\n         if (fn:exists($query-prov)) then\n           for $query-hash in document {$query}//schema-element(cts:query) ! xdmp:md5(document{.})\n-          where fn:not(map:contains($query-prov,$query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n+          where fn:not(map:contains($query-prov, $query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n           return map:put($query-prov, $query-hash, $sub-query-map)\n         else (),\n         $query\n+      ),\n+\n+      match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity)\n       )\n     (: We want to be certain that didn't lose any queries in the match ruleset, since we don't call the function if no values exist :)\n-    where fn:exists($queries) and fn:count($queries) eq fn:count($sub-query-maps)\n+    (: FSnow: need to remove the count check since we are returning one query for multiple properties in the structured property case :)\n+    where fn:exists($queries) (: and fn:count($queries) eq fn:count($sub-query-maps) :)\n     return (\n-      map:put($cached-queries, $query-map => map:get(\"matchRulesetId\"), $queries),\n+      (: no caching in the structured properties case (yet) :)\n+      if (fn:not(map:contains($query-map, \"multiStructPropMultiValueMap\"))) then\n+        map:put($cached-queries, $query-map => map:get(\"matchRulesetId\"), $queries)\n+      else\n+        ()\n+      ,\n       $queries\n     )\n \n };\n \n+declare function match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity as xs:string?)\n+  as cts:query*\n+{\n+  let $multi-struct-prop-multi-value-map := map:get($query-map, \"multiStructPropMultiValueMap\")\n+  return\n+    if (fn:empty($multi-struct-prop-multi-value-map) || fn:empty($target-entity)) then\n+      ()\n+    else\n+      let $is-json := (xdmp:node-kind($document) = \"object\" or fn:exists($document/(object-node()|array-node())))\n+      let $count := fn:count(map:get($query-map, \"matchQueries\"))\n+      let $count := if ($count eq 0) then 1 else $count\n+      let $weight := map:get($query-map, \"weight\") div $count\n+\n+      let $rev-map := -$multi-struct-prop-multi-value-map\n+\n+      let $prop-info-map := map:map()\n+      let $_ :=\n+        for $prop in (map:keys($rev-map), map:keys($rev-map) ! map:get($rev-map, .))\n+        return map:put($prop-info-map, $prop, es-helper:get-entity-property-info($target-entity, $prop))\n+\n+      for $prop in map:keys($rev-map)\n+      let $parent-info := map:get($prop-info-map, $prop)\n+      let $parent-xpath := $parent-info => map:get(\"pathExpression\")\n+      let $parent-namespaces := $parent-info => map:get(\"namespaces\")\n+      let $parent-objects := xdmp:unpath($parent-xpath, $parent-namespaces, $document)\n+      let $parent-xpath-length := fn:string-length($parent-xpath)\n+\n+      let $parent-query-fn := helper-impl:get-struct-prop-parent-scope-query-fn($parent-info, $prop)\n+\n+      let $query :=\n+        cts:or-query((\n+          for $parent-object in $parent-objects\n+\n+          let $child-props := map:get($rev-map, $prop)\n+          let $child-props-count := fn:count($child-props)\n+\n+          let $child-queries :=\n+            for $child-prop in $child-props\n+            let $child-info := map:get($prop-info-map, $child-prop)\n+            let $child-xpath := $child-info => map:get(\"pathExpression\")\n+            let $child-namespaces := $child-info => map:get(\"namespaces\")\n+            let $child-xpath-from-parent := \".\" || fn:substring($child-xpath, $parent-xpath-length + 1)\n+            let $child-prop-vals := xdmp:unpath($child-xpath-from-parent, $child-namespaces, $parent-object)\n+            let $child-query-fn := helper-impl:get-value-query-fn($child-info, $child-prop, $is-json)", "originalCommit": "c80a0408b663db523ad1ada675ca2d55fd6ccffe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4NjYwNw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r545886607", "bodyText": "I think each time we add a new chunk of logic like this in the SM code, we should strongly consider a new private function to both reduce the size of the existing functions and to document each little process.\nOf course the challenge here is that we'd have 4 args (property-defs, return-all-properties, entity-property-info, and rules). And XQuery doesn't given us any option for simplifying that other than a map. But perhaps there's value in some sort of \"context\" map that is passed around?\nAnother thought - I don't know what \"entity-property-info\" is unless I run this code and log it to figure out what \"info\" actually means. I am guessing it is more than just the entity property definitions from an entity model. What's a better name to use here? (which would affect the \"get-entity-property-info\" function too)", "author": "rjrudin", "createdAt": "2020-12-18T14:55:35Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/impl/util.xqy", "diffHunk": "@@ -115,37 +119,46 @@ declare function util-impl:properties-to-values-functions(\n       es-helper:get-entity-property-info($entity-type-iri)\n     else\n       map:map()\n-  let $distinct-properties := fn:distinct-values((\n-    $property-definitions/*:property/(@name|name) ! fn:string(.),\n-    if ($return-all-properties) then\n-      map:keys($entity-property-info)\n-    else (\n-      $rules/(@property-name|propertyName),\n-      $rules/entityPropertyPath\n-    ),\n-    $rules/documentXPath\n-  ))\n+  let $_ := xdmp:log(\"entity-type-iri: \" || $entity-type-iri)\n+  let $distinct-properties :=", "originalCommit": "b55d4f56eb5c31e506db297bd358cbb146784570", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4NzgxOA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r545887818", "bodyText": "I would find this easier to read if the 4 args were on one line. I think one line per arg is really helpful when building up a cts.query, but I think it decreases readability here, along with make the function a lot \"taller\".", "author": "rjrudin", "createdAt": "2020-12-18T14:57:04Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/matcher-impl/helper-impl.xqy", "diffHunk": "@@ -221,4 +223,43 @@ declare function helper-impl:NCName-compatible($title as xs:string) {\n     $title\n   else\n     xdmp:encode-for-NCName($title)\n-};\n\\ No newline at end of file\n+};\n+\n+\n+declare function helper-impl:get-value-query-fn($property-info, $full-property-name as xs:string, $is-json as xs:boolean)\n+{\n+  let $namespace := fn:string($property-info => map:get(\"namespace\"))\n+  let $qname := fn:QName($namespace, helper-impl:NCName-compatible($property-info => map:get(\"propertyTitle\")))\n+  return\n+    function($val, $weight) {\n+      if (fn:empty($val)) then\n+        ()\n+      else if ($is-json) then\n+        cts:json-property-value-query(", "originalCommit": "b55d4f56eb5c31e506db297bd358cbb146784570", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4ODM5Mg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r545888392", "bodyText": "Let's use \"target-entity-type\" here, as to me, \"target-entity\" sounds like it's either the entity model or an entity instance (I know it's not an instance based on the context, so I'm guessing it's the model - but it's not, it's just a string).", "author": "rjrudin", "createdAt": "2020-12-18T14:57:55Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/matcher-impl/matcher-impl.xqy", "diffHunk": "@@ -132,6 +134,7 @@ declare function match-impl:find-document-matches-by-options(\n     let $is-json := (xdmp:node-kind($document) = \"object\" or fn:exists($document/(object-node()|array-node())))\n     let $_trace := xdmp:trace($const:TRACE-MATCH-RESULTS, \" is-json: \" || $is-json)\n     let $compiled-options := opt-impl:compile-match-options($options, $minimum-threshold)\n+    let $target-entity := map:get($compiled-options, \"targetEntityType\")", "originalCommit": "b55d4f56eb5c31e506db297bd358cbb146784570", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkwMDI5MA==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r545900290", "bodyText": "When I have an empty if or else, I like to do a where/return to make it a little easier to read - e.g.\nlet ...\nwhere fn:exists(the map) and fn:exists(target-entity-type)\nreturn", "author": "rjrudin", "createdAt": "2020-12-18T15:14:28Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/matcher-impl/matcher-impl.xqy", "diffHunk": "@@ -355,20 +373,84 @@ declare function match-impl:query-map-to-query(\n       return (\n         if (fn:exists($query-prov)) then\n           for $query-hash in document {$query}//schema-element(cts:query) ! xdmp:md5(document{.})\n-          where fn:not(map:contains($query-prov,$query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n+          where fn:not(map:contains($query-prov, $query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n           return map:put($query-prov, $query-hash, $sub-query-map)\n         else (),\n         $query\n+      ),\n+\n+      match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity)\n       )\n     (: We want to be certain that didn't lose any queries in the match ruleset, since we don't call the function if no values exist :)\n-    where fn:exists($queries) and fn:count($queries) eq fn:count($sub-query-maps)\n+    (: FSnow: need to remove the count check since we are returning one query for multiple properties in the structured property case :)\n+    where fn:exists($queries) (: and fn:count($queries) eq fn:count($sub-query-maps) :)\n     return (\n-      map:put($cached-queries, $query-map => map:get(\"matchRulesetId\"), $queries),\n+      (: no caching in the structured properties case (yet) :)\n+      if (fn:not(map:contains($query-map, \"multiStructPropMultiValueMap\"))) then\n+        map:put($cached-queries, $query-map => map:get(\"matchRulesetId\"), $queries)\n+      else\n+        ()\n+      ,\n       $queries\n     )\n \n };\n \n+declare function match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity as xs:string?)\n+  as cts:query*\n+{\n+  let $multi-struct-prop-multi-value-map := map:get($query-map, \"multiStructPropMultiValueMap\")\n+  return\n+    if (fn:empty($multi-struct-prop-multi-value-map) or fn:empty($target-entity)) then", "originalCommit": "b55d4f56eb5c31e506db297bd358cbb146784570", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkwMTAxNw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r545901017", "bodyText": "Could the body of this for loop go into a new private function - e.g. \"build(or make)-query-for-child-property\"?", "author": "rjrudin", "createdAt": "2020-12-18T15:15:42Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/matcher-impl/matcher-impl.xqy", "diffHunk": "@@ -355,20 +373,84 @@ declare function match-impl:query-map-to-query(\n       return (\n         if (fn:exists($query-prov)) then\n           for $query-hash in document {$query}//schema-element(cts:query) ! xdmp:md5(document{.})\n-          where fn:not(map:contains($query-prov,$query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n+          where fn:not(map:contains($query-prov, $query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n           return map:put($query-prov, $query-hash, $sub-query-map)\n         else (),\n         $query\n+      ),\n+\n+      match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity)\n       )\n     (: We want to be certain that didn't lose any queries in the match ruleset, since we don't call the function if no values exist :)\n-    where fn:exists($queries) and fn:count($queries) eq fn:count($sub-query-maps)\n+    (: FSnow: need to remove the count check since we are returning one query for multiple properties in the structured property case :)\n+    where fn:exists($queries) (: and fn:count($queries) eq fn:count($sub-query-maps) :)\n     return (\n-      map:put($cached-queries, $query-map => map:get(\"matchRulesetId\"), $queries),\n+      (: no caching in the structured properties case (yet) :)\n+      if (fn:not(map:contains($query-map, \"multiStructPropMultiValueMap\"))) then\n+        map:put($cached-queries, $query-map => map:get(\"matchRulesetId\"), $queries)\n+      else\n+        ()\n+      ,\n       $queries\n     )\n \n };\n \n+declare function match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity as xs:string?)\n+  as cts:query*\n+{\n+  let $multi-struct-prop-multi-value-map := map:get($query-map, \"multiStructPropMultiValueMap\")\n+  return\n+    if (fn:empty($multi-struct-prop-multi-value-map) or fn:empty($target-entity)) then\n+      ()\n+    else\n+      let $is-json := (xdmp:node-kind($document) = \"object\" or fn:exists($document/(object-node()|array-node())))\n+      let $count := fn:count(map:get($query-map, \"matchQueries\"))\n+      let $count := if ($count eq 0) then 1 else $count\n+      let $weight := map:get($query-map, \"weight\") div $count\n+\n+      let $rev-map := -$multi-struct-prop-multi-value-map\n+\n+      let $prop-info-map := map:map()\n+      let $_ :=\n+        for $prop in (map:keys($rev-map), map:keys($rev-map) ! map:get($rev-map, .))\n+        return map:put($prop-info-map, $prop, es-helper:get-entity-property-info($target-entity, $prop))\n+\n+      for $prop in map:keys($rev-map)\n+      let $parent-info := map:get($prop-info-map, $prop)\n+      let $parent-xpath := $parent-info => map:get(\"pathExpression\")\n+      let $parent-namespaces := $parent-info => map:get(\"namespaces\")\n+      let $parent-objects := xdmp:unpath($parent-xpath, $parent-namespaces, $document)\n+      let $parent-xpath-length := fn:string-length($parent-xpath)\n+\n+      let $parent-query-fn := helper-impl:get-struct-prop-parent-scope-query-fn($parent-info, $prop)\n+\n+      let $query :=\n+        cts:or-query((\n+          for $parent-object in $parent-objects\n+\n+          let $child-props := map:get($rev-map, $prop)\n+          let $child-props-count := fn:count($child-props)\n+\n+          let $child-queries :=\n+            for $child-prop in $child-props", "originalCommit": "b55d4f56eb5c31e506db297bd358cbb146784570", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkwMTU5Mw==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r545901593", "bodyText": "At first glance, I don't know what the values of the map are, so I don't know what the keys of this map will be. I think it needs a name that defines what it's a map of.", "author": "rjrudin", "createdAt": "2020-12-18T15:16:39Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/matcher-impl/matcher-impl.xqy", "diffHunk": "@@ -355,20 +373,84 @@ declare function match-impl:query-map-to-query(\n       return (\n         if (fn:exists($query-prov)) then\n           for $query-hash in document {$query}//schema-element(cts:query) ! xdmp:md5(document{.})\n-          where fn:not(map:contains($query-prov,$query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n+          where fn:not(map:contains($query-prov, $query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n           return map:put($query-prov, $query-hash, $sub-query-map)\n         else (),\n         $query\n+      ),\n+\n+      match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity)\n       )\n     (: We want to be certain that didn't lose any queries in the match ruleset, since we don't call the function if no values exist :)\n-    where fn:exists($queries) and fn:count($queries) eq fn:count($sub-query-maps)\n+    (: FSnow: need to remove the count check since we are returning one query for multiple properties in the structured property case :)\n+    where fn:exists($queries) (: and fn:count($queries) eq fn:count($sub-query-maps) :)\n     return (\n-      map:put($cached-queries, $query-map => map:get(\"matchRulesetId\"), $queries),\n+      (: no caching in the structured properties case (yet) :)\n+      if (fn:not(map:contains($query-map, \"multiStructPropMultiValueMap\"))) then\n+        map:put($cached-queries, $query-map => map:get(\"matchRulesetId\"), $queries)\n+      else\n+        ()\n+      ,\n       $queries\n     )\n \n };\n \n+declare function match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity as xs:string?)\n+  as cts:query*\n+{\n+  let $multi-struct-prop-multi-value-map := map:get($query-map, \"multiStructPropMultiValueMap\")\n+  return\n+    if (fn:empty($multi-struct-prop-multi-value-map) or fn:empty($target-entity)) then\n+      ()\n+    else\n+      let $is-json := (xdmp:node-kind($document) = \"object\" or fn:exists($document/(object-node()|array-node())))\n+      let $count := fn:count(map:get($query-map, \"matchQueries\"))\n+      let $count := if ($count eq 0) then 1 else $count\n+      let $weight := map:get($query-map, \"weight\") div $count\n+\n+      let $rev-map := -$multi-struct-prop-multi-value-map", "originalCommit": "b55d4f56eb5c31e506db297bd358cbb146784570", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkwMjIxNQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r545902215", "bodyText": "Could everything in the body of this for loop go into a separate function? Looks like it might be named \"build-query-for-parent-property\"?", "author": "rjrudin", "createdAt": "2020-12-18T15:17:40Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/matcher-impl/matcher-impl.xqy", "diffHunk": "@@ -355,20 +373,84 @@ declare function match-impl:query-map-to-query(\n       return (\n         if (fn:exists($query-prov)) then\n           for $query-hash in document {$query}//schema-element(cts:query) ! xdmp:md5(document{.})\n-          where fn:not(map:contains($query-prov,$query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n+          where fn:not(map:contains($query-prov, $query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n           return map:put($query-prov, $query-hash, $sub-query-map)\n         else (),\n         $query\n+      ),\n+\n+      match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity)\n       )\n     (: We want to be certain that didn't lose any queries in the match ruleset, since we don't call the function if no values exist :)\n-    where fn:exists($queries) and fn:count($queries) eq fn:count($sub-query-maps)\n+    (: FSnow: need to remove the count check since we are returning one query for multiple properties in the structured property case :)\n+    where fn:exists($queries) (: and fn:count($queries) eq fn:count($sub-query-maps) :)\n     return (\n-      map:put($cached-queries, $query-map => map:get(\"matchRulesetId\"), $queries),\n+      (: no caching in the structured properties case (yet) :)\n+      if (fn:not(map:contains($query-map, \"multiStructPropMultiValueMap\"))) then\n+        map:put($cached-queries, $query-map => map:get(\"matchRulesetId\"), $queries)\n+      else\n+        ()\n+      ,\n       $queries\n     )\n \n };\n \n+declare function match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity as xs:string?)\n+  as cts:query*\n+{\n+  let $multi-struct-prop-multi-value-map := map:get($query-map, \"multiStructPropMultiValueMap\")\n+  return\n+    if (fn:empty($multi-struct-prop-multi-value-map) or fn:empty($target-entity)) then\n+      ()\n+    else\n+      let $is-json := (xdmp:node-kind($document) = \"object\" or fn:exists($document/(object-node()|array-node())))\n+      let $count := fn:count(map:get($query-map, \"matchQueries\"))\n+      let $count := if ($count eq 0) then 1 else $count\n+      let $weight := map:get($query-map, \"weight\") div $count\n+\n+      let $rev-map := -$multi-struct-prop-multi-value-map\n+\n+      let $prop-info-map := map:map()\n+      let $_ :=\n+        for $prop in (map:keys($rev-map), map:keys($rev-map) ! map:get($rev-map, .))\n+        return map:put($prop-info-map, $prop, es-helper:get-entity-property-info($target-entity, $prop))\n+\n+      for $prop in map:keys($rev-map)\n+      let $parent-info := map:get($prop-info-map, $prop)", "originalCommit": "b55d4f56eb5c31e506db297bd358cbb146784570", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4NzAxMQ==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r547487011", "bodyText": "It seems simpler if all of these comments are removed here, and the commented-out code. My understanding from this is based on the introduction of queries on structured properties, all that matters is that we have at least one query. Thus,  no need for any comments.", "author": "rjrudin", "createdAt": "2020-12-22T20:14:10Z", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/com.marklogic.smart-mastering/matcher-impl/matcher-impl.xqy", "diffHunk": "@@ -355,20 +372,84 @@ declare function match-impl:query-map-to-query(\n       return (\n         if (fn:exists($query-prov)) then\n           for $query-hash in document {$query}//schema-element(cts:query) ! xdmp:md5(document{.})\n-          where fn:not(map:contains($query-prov,$query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n+          where fn:not(map:contains($query-prov, $query-hash)) or ((map:get($query-prov, $query-hash) => map:get(\"type\")) = \"reduce\")\n           return map:put($query-prov, $query-hash, $sub-query-map)\n         else (),\n         $query\n+      ),\n+\n+      match-impl:multi-struct-prop-multi-value-queries($query-map, $document, $target-entity)\n       )\n     (: We want to be certain that didn't lose any queries in the match ruleset, since we don't call the function if no values exist :)\n-    where fn:exists($queries) and fn:count($queries) eq fn:count($sub-query-maps)\n+    (: FSnow: need to remove the count check since we are returning one query for multiple properties in the structured property case :)", "originalCommit": "697336fd2f26a131244106f734bf9d7e799fad93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxMDIwMg==", "url": "https://github.com/marklogic/marklogic-data-hub/pull/5019#discussion_r547510202", "bodyText": "I can remove that now. I put that in so that Ryan would see it since I was not sure of the ramifications of taking out that count check in the where.", "author": "fsnow", "createdAt": "2020-12-22T21:14:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4NzAxMQ=="}], "type": "inlineReview"}, {"oid": "8de9121dbf6ddf21f2f3330e8612a733fd266bd4", "url": "https://github.com/marklogic/marklogic-data-hub/commit/8de9121dbf6ddf21f2f3330e8612a733fd266bd4", "message": "DHFPROD-5236: Make multi value properties work for the match step from a gradle interface", "committedDate": "2020-12-22T22:04:52Z", "type": "commit"}]}