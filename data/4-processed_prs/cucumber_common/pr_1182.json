{"pr_number": 1182, "pr_title": "datatable/java: Support for Optional<T>", "pr_createdAt": "2020-09-13T14:14:30Z", "pr_url": "https://github.com/cucumber/common/pull/1182", "timeline": [{"oid": "b0798f348c245398df086f0c11526c059fd4924f", "url": "https://github.com/cucumber/common/commit/b0798f348c245398df086f0c11526c059fd4924f", "message": "Support for Optional", "committedDate": "2020-09-13T14:04:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NDY4NQ==", "url": "https://github.com/cucumber/common/pull/1182#discussion_r487564685", "bodyText": "The pattern s == null || s.isEmpty() ? Optional.empty() : Optional.of(do-something-transformer-specific) is very repetitive. Have a look at the way applyIfPresent is used to see if you can remove this repetition.", "author": "mpkorstanje", "createdAt": "2020-09-13T19:00:31Z", "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -57,6 +58,44 @@ public DataTableTypeRegistry(Locale locale) {\n         TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n         defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n         defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n+\n+        TableCellTransformer<Optional<Object>> optionalTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(s);", "originalCommit": "b0798f348c245398df086f0c11526c059fd4924f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTA1OQ==", "url": "https://github.com/cucumber/common/pull/1182#discussion_r487565059", "bodyText": "The transformer specific function (e.g. numberParser.parseFloat) for both the optional and non-optional transformer should be the same. However it is very hard to verify that this is the case. By moving the definition of the optional and non-optional transformer closer together you can resolve this.\nAdditionally, in combination with my previous comment you can possibly also make it easier to verify that the transformer specific part is indeed the same.", "author": "mpkorstanje", "createdAt": "2020-09-13T19:03:27Z", "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -57,6 +58,44 @@ public DataTableTypeRegistry(Locale locale) {\n         TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n         defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n         defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n+\n+        TableCellTransformer<Optional<Object>> optionalTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(s);\n+        defineDataTableType(new DataTableType(Optional.class, optionalTableCellTransformer));\n+\n+        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n+        defineDataTableType(new DataTableType(optionalString, optionalTableCellTransformer));\n+\n+        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n+        TableCellTransformer<Optional<Double>> optionalDoubleTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(numberParser.parseDouble(s));\n+        defineDataTableType(new DataTableType(optionalDouble, optionalDoubleTableCellTransformer));\n+\n+        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n+        TableCellTransformer<Optional<Float>> optionalFloatTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(numberParser.parseFloat(s));", "originalCommit": "b0798f348c245398df086f0c11526c059fd4924f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTE1MA==", "url": "https://github.com/cucumber/common/pull/1182#discussion_r487565150", "bodyText": "optionalBigInt -> optionalBigInteger. It's  okay to spell things out.", "author": "mpkorstanje", "createdAt": "2020-09-13T19:04:24Z", "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -57,6 +58,44 @@ public DataTableTypeRegistry(Locale locale) {\n         TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n         defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n         defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n+\n+        TableCellTransformer<Optional<Object>> optionalTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(s);\n+        defineDataTableType(new DataTableType(Optional.class, optionalTableCellTransformer));\n+\n+        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n+        defineDataTableType(new DataTableType(optionalString, optionalTableCellTransformer));\n+\n+        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n+        TableCellTransformer<Optional<Double>> optionalDoubleTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(numberParser.parseDouble(s));\n+        defineDataTableType(new DataTableType(optionalDouble, optionalDoubleTableCellTransformer));\n+\n+        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n+        TableCellTransformer<Optional<Float>> optionalFloatTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(numberParser.parseFloat(s));\n+        defineDataTableType(new DataTableType(optionalFloat, optionalFloatTableCellTransformer));\n+\n+        Type optionalLong = new TypeReference<Optional<Long>>() { }.getType();\n+        TableCellTransformer<Optional<Long>> optionalLongTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(Long.decode(s));\n+        defineDataTableType(new DataTableType(optionalLong, optionalLongTableCellTransformer));\n+\n+        Type optionalByte = new TypeReference<Optional<Byte>>() { }.getType();\n+        TableCellTransformer<Optional<Byte>> optionalByteTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(Byte.decode(s));\n+        defineDataTableType(new DataTableType(optionalByte, optionalByteTableCellTransformer));\n+\n+        Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() { }.getType();\n+        TableCellTransformer<Optional<BigDecimal>> optionalBigDecimalTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(numberParser.parseBigDecimal(s));\n+        defineDataTableType(new DataTableType(optionalBigDecimal, optionalBigDecimalTableCellTransformer));\n+\n+\n+        Type optionalBigInt = new TypeReference<Optional<BigInteger>>() { }.getType();", "originalCommit": "b0798f348c245398df086f0c11526c059fd4924f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6ffecd5d9f49b5cff462431dd5e5b963c8957b6d", "url": "https://github.com/cucumber/common/commit/6ffecd5d9f49b5cff462431dd5e5b963c8957b6d", "message": "Merge branch 'master' into datatable-java-optional-type", "committedDate": "2020-09-13T19:45:07Z", "type": "commit"}, {"oid": "ea24c2ebeda482bf9cc70d8bf7f172a436c8f09e", "url": "https://github.com/cucumber/common/commit/ea24c2ebeda482bf9cc70d8bf7f172a436c8f09e", "message": "Review fixes:\n  - Removed duplicate code\n  - Optional trasnformers now use same functions as regular\n  transformers", "committedDate": "2020-09-20T15:57:41Z", "type": "commit"}, {"oid": "1fa58df8ce11379c8bd5a0e8911428a12428a1ac", "url": "https://github.com/cucumber/common/commit/1fa58df8ce11379c8bd5a0e8911428a12428a1ac", "message": "Merge branch 'datatable-java-optional-type' of github.com:cucumber/cucumber into datatable-java-optional-type", "committedDate": "2020-09-20T15:59:33Z", "type": "commit"}, {"oid": "cf1a84a65d29181aa5852f970d3a248da0a0919a", "url": "https://github.com/cucumber/common/commit/cf1a84a65d29181aa5852f970d3a248da0a0919a", "message": "Merge remote-tracking branch 'origin/master' into datatable-java-optional-type", "committedDate": "2020-09-20T16:00:36Z", "type": "commit"}, {"oid": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c", "url": "https://github.com/cucumber/common/commit/55bcd793d074fd7559a9df4a1b079fa3c6c13a8c", "message": "More review fixes", "committedDate": "2020-09-20T19:13:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDEzMg==", "url": "https://github.com/cucumber/common/pull/1182#discussion_r491724132", "bodyText": "While it would be unexpected the function returned by applyIfPresent will return null when f.appy returns null. So ofNullable should be used here.", "author": "mpkorstanje", "createdAt": "2020-09-20T19:16:52Z", "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -26,69 +26,79 @@\n     public DataTableTypeRegistry(Locale locale) {\n         final NumberParser numberParser = new NumberParser(locale);\n \n-        TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n-        defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n-        defineDataTableType(new DataTableType(String.class, objectTableCellTransformer, true));\n-\n-        TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n-        defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n-\n-        TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n-        defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n-        TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n-        defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n-        defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n-\n-        TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n-        defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n-        defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n-\n-        TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n-        defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n-        defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n-\n-        TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n-        defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n-        defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n-\n-        TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n-        defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n-        defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n-\n-        TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n-        defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n-        defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n-\n-        defineDataTableType(new DataTableType(Optional.class, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalString, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalDouble, transformAsOptional(doubleTableCellTransformer)));\n-\n-        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalFloat, transformAsOptional(floatTableCellTransformer)));\n-\n-        Type optionalLong = new TypeReference<Optional<Long>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalLong, transformAsOptional(longTableCellTransformer)));\n-\n-        Type optionalByte = new TypeReference<Optional<Byte>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalByte, transformAsOptional(byteTableCellTransformer)));\n-\n-        Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigDecimal, transformAsOptional(bigDecimalTableCellTransformer)));\n-\n-        Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigInteger, transformAsOptional(bigIntegerTableCellTransformer)));\n+        {\n+            TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n+            defineDataTableType(new DataTableType(Optional.class, optionalIfAbsent(objectTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<Object> stringTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(String.class, stringTableCellTransformer, true));\n+            Type optionalString = new TypeReference<Optional<String>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalString, optionalIfAbsent(stringTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n+            defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n+            Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalBigInteger, optionalIfAbsent(bigIntegerTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n+            defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n+            Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalBigDecimal, optionalIfAbsent(bigDecimalTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n+            defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n+            defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n+            Type optionalByte = new TypeReference<Optional<Byte>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalByte, optionalIfAbsent(byteTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n+            defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n+            defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n+            Type optionalShort = new TypeReference<Optional<Short>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalShort, optionalIfAbsent(shortTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n+            defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n+            defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n+            Type optionalInteger = new TypeReference<Optional<Integer>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalInteger, optionalIfAbsent(integerTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n+            defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n+            defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n+            Type optionalLong = new TypeReference<Optional<Long>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalLong, optionalIfAbsent(longTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n+            defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n+            defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n+            Type optionalFloat = new TypeReference<Optional<Float>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalFloat, optionalIfAbsent(floatTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n+            defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n+            defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n+            Type optionalDouble = new TypeReference<Optional<Double>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalDouble, optionalIfAbsent(doubleTableCellTransformer)));\n+        }\n     }\n \n     private static <R> TableCellTransformer<R> applyIfPresent(Function<String, R> f) {\n         return s -> s == null ? null : f.apply(s);\n     }\n \n-    private static <T> TableCellTransformer<Optional<T>> transformAsOptional(TableCellTransformer<T> tableCellTransformer) {\n-        return s -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(tableCellTransformer.transform(s));\n+    private static <R> TableCellTransformer<Optional<R>> optionalIfAbsent(TableCellTransformer<R> t) {\n+        return s -> s == null || s.isEmpty() ? Optional.empty() : Optional.ofNullable(t.transform(s));", "originalCommit": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDE3OA==", "url": "https://github.com/cucumber/common/pull/1182#discussion_r491724178", "bodyText": "I've moved the optional transformers next to their non-optional counter parts. This allowed me to see that the transformer for integer was missing.", "author": "mpkorstanje", "createdAt": "2020-09-20T19:17:32Z", "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -26,69 +26,79 @@\n     public DataTableTypeRegistry(Locale locale) {\n         final NumberParser numberParser = new NumberParser(locale);\n \n-        TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n-        defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n-        defineDataTableType(new DataTableType(String.class, objectTableCellTransformer, true));\n-\n-        TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n-        defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n-\n-        TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n-        defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n-        TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n-        defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n-        defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n-\n-        TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n-        defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n-        defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n-\n-        TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n-        defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n-        defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n-\n-        TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n-        defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n-        defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n-\n-        TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n-        defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n-        defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n-\n-        TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n-        defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n-        defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n-\n-        defineDataTableType(new DataTableType(Optional.class, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalString, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalDouble, transformAsOptional(doubleTableCellTransformer)));\n-\n-        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalFloat, transformAsOptional(floatTableCellTransformer)));\n-\n-        Type optionalLong = new TypeReference<Optional<Long>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalLong, transformAsOptional(longTableCellTransformer)));\n-\n-        Type optionalByte = new TypeReference<Optional<Byte>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalByte, transformAsOptional(byteTableCellTransformer)));\n-\n-        Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigDecimal, transformAsOptional(bigDecimalTableCellTransformer)));\n-\n-        Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigInteger, transformAsOptional(bigIntegerTableCellTransformer)));\n+        {\n+            TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n+            defineDataTableType(new DataTableType(Optional.class, optionalIfAbsent(objectTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<Object> stringTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(String.class, stringTableCellTransformer, true));\n+            Type optionalString = new TypeReference<Optional<String>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalString, optionalIfAbsent(stringTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n+            defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n+            Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalBigInteger, optionalIfAbsent(bigIntegerTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n+            defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n+            Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalBigDecimal, optionalIfAbsent(bigDecimalTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n+            defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n+            defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n+            Type optionalByte = new TypeReference<Optional<Byte>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalByte, optionalIfAbsent(byteTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n+            defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n+            defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n+            Type optionalShort = new TypeReference<Optional<Short>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalShort, optionalIfAbsent(shortTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);", "originalCommit": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDIyOQ==", "url": "https://github.com/cucumber/common/pull/1182#discussion_r491724229", "bodyText": "For consistency I've split Object and String.", "author": "mpkorstanje", "createdAt": "2020-09-20T19:18:11Z", "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -26,69 +26,79 @@\n     public DataTableTypeRegistry(Locale locale) {\n         final NumberParser numberParser = new NumberParser(locale);\n \n-        TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n-        defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n-        defineDataTableType(new DataTableType(String.class, objectTableCellTransformer, true));\n-\n-        TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n-        defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n-\n-        TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n-        defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n-        TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n-        defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n-        defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n-\n-        TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n-        defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n-        defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n-\n-        TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n-        defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n-        defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n-\n-        TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n-        defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n-        defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n-\n-        TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n-        defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n-        defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n-\n-        TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n-        defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n-        defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n-\n-        defineDataTableType(new DataTableType(Optional.class, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalString, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalDouble, transformAsOptional(doubleTableCellTransformer)));\n-\n-        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalFloat, transformAsOptional(floatTableCellTransformer)));\n-\n-        Type optionalLong = new TypeReference<Optional<Long>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalLong, transformAsOptional(longTableCellTransformer)));\n-\n-        Type optionalByte = new TypeReference<Optional<Byte>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalByte, transformAsOptional(byteTableCellTransformer)));\n-\n-        Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigDecimal, transformAsOptional(bigDecimalTableCellTransformer)));\n-\n-        Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigInteger, transformAsOptional(bigIntegerTableCellTransformer)));\n+        {\n+            TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n+            defineDataTableType(new DataTableType(Optional.class, optionalIfAbsent(objectTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<Object> stringTableCellTransformer = applyIfPresent(s -> s);", "originalCommit": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDI2MA==", "url": "https://github.com/cucumber/common/pull/1182#discussion_r491724260", "bodyText": "I'm wondering why we're not checking for the empty string here.", "author": "mpkorstanje", "createdAt": "2020-09-20T19:18:36Z", "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -26,69 +26,79 @@\n     public DataTableTypeRegistry(Locale locale) {\n         final NumberParser numberParser = new NumberParser(locale);\n \n-        TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n-        defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n-        defineDataTableType(new DataTableType(String.class, objectTableCellTransformer, true));\n-\n-        TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n-        defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n-\n-        TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n-        defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n-        TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n-        defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n-        defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n-\n-        TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n-        defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n-        defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n-\n-        TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n-        defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n-        defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n-\n-        TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n-        defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n-        defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n-\n-        TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n-        defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n-        defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n-\n-        TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n-        defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n-        defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n-\n-        defineDataTableType(new DataTableType(Optional.class, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalString, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalDouble, transformAsOptional(doubleTableCellTransformer)));\n-\n-        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalFloat, transformAsOptional(floatTableCellTransformer)));\n-\n-        Type optionalLong = new TypeReference<Optional<Long>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalLong, transformAsOptional(longTableCellTransformer)));\n-\n-        Type optionalByte = new TypeReference<Optional<Byte>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalByte, transformAsOptional(byteTableCellTransformer)));\n-\n-        Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigDecimal, transformAsOptional(bigDecimalTableCellTransformer)));\n-\n-        Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigInteger, transformAsOptional(bigIntegerTableCellTransformer)));\n+        {\n+            TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n+            defineDataTableType(new DataTableType(Optional.class, optionalIfAbsent(objectTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<Object> stringTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(String.class, stringTableCellTransformer, true));\n+            Type optionalString = new TypeReference<Optional<String>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalString, optionalIfAbsent(stringTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n+            defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n+            Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalBigInteger, optionalIfAbsent(bigIntegerTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n+            defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n+            Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalBigDecimal, optionalIfAbsent(bigDecimalTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n+            defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n+            defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n+            Type optionalByte = new TypeReference<Optional<Byte>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalByte, optionalIfAbsent(byteTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n+            defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n+            defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n+            Type optionalShort = new TypeReference<Optional<Short>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalShort, optionalIfAbsent(shortTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n+            defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n+            defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n+            Type optionalInteger = new TypeReference<Optional<Integer>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalInteger, optionalIfAbsent(integerTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n+            defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n+            defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n+            Type optionalLong = new TypeReference<Optional<Long>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalLong, optionalIfAbsent(longTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n+            defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n+            defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n+            Type optionalFloat = new TypeReference<Optional<Float>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalFloat, optionalIfAbsent(floatTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n+            defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n+            defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n+            Type optionalDouble = new TypeReference<Optional<Double>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalDouble, optionalIfAbsent(doubleTableCellTransformer)));\n+        }\n     }\n \n     private static <R> TableCellTransformer<R> applyIfPresent(Function<String, R> f) {\n         return s -> s == null ? null : f.apply(s);", "originalCommit": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTczMTIyNA==", "url": "https://github.com/cucumber/common/pull/1182#discussion_r491731224", "bodyText": "I think empty string is completely fine for stringTableCellTransformer, but it is not fine for others.\nNow we throw exception for this case:\nDataTable table = parse(\"\",\n                \"| header1   | header2   |\",\n                \"| 1              |                 |\"\n        );\nconverter.toMaps(table, String.class, byte.class);\n\n>> io.cucumber.datatable.CucumberDataTableException: 'java.util.List<java.util.List<byte>>' could not transform\n      | 1 | [empty] |\n\nI think we can safely change this to null if the string is empty.", "author": "rasklaad", "createdAt": "2020-09-20T20:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDk3Mw==", "url": "https://github.com/cucumber/common/pull/1182#discussion_r491724973", "bodyText": "true here marks the DataTableType as replaceable. This means that it's possible to register a new transformer that replaces this one. However this means that the optional transformer is not replaced. This seems somewhat inconsistent.\nI would expect that when I replace the objectTableCellTransformer for Object, the Optional<Objec> transformer is used.  And with that in mind would also expect that by registering a transformer for X I would have also registered one for Optional<X>.", "author": "mpkorstanje", "createdAt": "2020-09-20T19:25:46Z", "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -26,69 +26,79 @@\n     public DataTableTypeRegistry(Locale locale) {\n         final NumberParser numberParser = new NumberParser(locale);\n \n-        TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n-        defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n-        defineDataTableType(new DataTableType(String.class, objectTableCellTransformer, true));\n-\n-        TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n-        defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n-\n-        TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n-        defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n-        TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n-        defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n-        defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n-\n-        TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n-        defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n-        defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n-\n-        TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n-        defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n-        defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n-\n-        TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n-        defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n-        defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n-\n-        TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n-        defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n-        defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n-\n-        TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n-        defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n-        defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n-\n-        defineDataTableType(new DataTableType(Optional.class, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalString, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalDouble, transformAsOptional(doubleTableCellTransformer)));\n-\n-        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalFloat, transformAsOptional(floatTableCellTransformer)));\n-\n-        Type optionalLong = new TypeReference<Optional<Long>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalLong, transformAsOptional(longTableCellTransformer)));\n-\n-        Type optionalByte = new TypeReference<Optional<Byte>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalByte, transformAsOptional(byteTableCellTransformer)));\n-\n-        Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigDecimal, transformAsOptional(bigDecimalTableCellTransformer)));\n-\n-        Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigInteger, transformAsOptional(bigIntegerTableCellTransformer)));\n+        {\n+            TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n+            defineDataTableType(new DataTableType(Optional.class, optionalIfAbsent(objectTableCellTransformer), true));", "originalCommit": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTczMTc3Mg==", "url": "https://github.com/cucumber/common/pull/1182#discussion_r491731772", "bodyText": "So looks like we have to remove Optional transformers from constructor, and just define Optional for any type in io.cucumber.datatable.DataTableTypeRegistry#defineDataTableType\nWill that work?", "author": "rasklaad", "createdAt": "2020-09-20T20:37:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxMjIzNw==", "url": "https://github.com/cucumber/common/pull/1182#discussion_r494812237", "bodyText": "I don't know yet. This solution has the advantage of being conceptually consistent.\nMy suggestion isn't.", "author": "mpkorstanje", "createdAt": "2020-09-25T07:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDk3Mw=="}], "type": "inlineReview"}, {"oid": "6c619ef9b56a1908ec323ecfd04b1a395ed7b9f5", "url": "https://github.com/cucumber/common/commit/6c619ef9b56a1908ec323ecfd04b1a395ed7b9f5", "message": "Naming things.", "committedDate": "2020-09-20T19:25:57Z", "type": "commit"}, {"oid": "181f86854a2bf55fa0fcae8332e51b759f35ccd3", "url": "https://github.com/cucumber/common/commit/181f86854a2bf55fa0fcae8332e51b759f35ccd3", "message": "Optional integer tests", "committedDate": "2020-09-20T20:16:15Z", "type": "commit"}, {"oid": "360a793a0e198bca446d42c378f960d8cc1ea725", "url": "https://github.com/cucumber/common/commit/360a793a0e198bca446d42c378f960d8cc1ea725", "message": "Try some replacement", "committedDate": "2020-09-20T20:50:08Z", "type": "commit"}, {"oid": "cd018dab6ee514160cf217c5dfcc9363631a9303", "url": "https://github.com/cucumber/common/commit/cd018dab6ee514160cf217c5dfcc9363631a9303", "message": "Narrow scope to table cell transformers", "committedDate": "2020-09-20T21:08:08Z", "type": "commit"}, {"oid": "5c1504ca2a00f1474a6dccf3a5e2c2858295972f", "url": "https://github.com/cucumber/common/commit/5c1504ca2a00f1474a6dccf3a5e2c2858295972f", "message": "Narrow scope to table cell transformers", "committedDate": "2020-09-20T21:11:22Z", "type": "commit"}, {"oid": "49a9625b85573e9f72ac55fa1cf23b6974bced9f", "url": "https://github.com/cucumber/common/commit/49a9625b85573e9f72ac55fa1cf23b6974bced9f", "message": "Use a smart look up to handle with optional", "committedDate": "2020-09-25T17:54:27Z", "type": "commit"}, {"oid": "cb1e5b0f3f4ce807e18871ba4cce54d3d800b7ef", "url": "https://github.com/cucumber/common/commit/cb1e5b0f3f4ce807e18871ba4cce54d3d800b7ef", "message": "Use sensible error message for optional singletons", "committedDate": "2020-09-25T18:31:01Z", "type": "commit"}, {"oid": "379e6c536f12faf76f658239d99eb281ab499030", "url": "https://github.com/cucumber/common/commit/379e6c536f12faf76f658239d99eb281ab499030", "message": "Better singleton handling", "committedDate": "2020-09-25T18:39:22Z", "type": "commit"}, {"oid": "2313389397740c0ced8a8ff487b97fb1a150d7e6", "url": "https://github.com/cucumber/common/commit/2313389397740c0ced8a8ff487b97fb1a150d7e6", "message": "Merge branch 'master' into datatable-java-optional-type", "committedDate": "2020-09-25T18:41:22Z", "type": "commit"}, {"oid": "1a8a61a0722549151ccf16f20ead79616b2bc7e8", "url": "https://github.com/cucumber/common/commit/1a8a61a0722549151ccf16f20ead79616b2bc7e8", "message": "Naming stuff", "committedDate": "2020-09-26T17:28:16Z", "type": "commit"}, {"oid": "d4d65b053ca9d6464111096c5a194a1aa045be66", "url": "https://github.com/cucumber/common/commit/d4d65b053ca9d6464111096c5a194a1aa045be66", "message": "Add tests", "committedDate": "2020-09-26T17:53:31Z", "type": "commit"}, {"oid": "50ed3c391f23b53be330a1a80813f51bb8cc9a8b", "url": "https://github.com/cucumber/common/commit/50ed3c391f23b53be330a1a80813f51bb8cc9a8b", "message": "Update docs; improve tests", "committedDate": "2020-09-26T18:39:13Z", "type": "commit"}, {"oid": "88b43b4b5e56bba89c822470508f6d9ebe51f4e7", "url": "https://github.com/cucumber/common/commit/88b43b4b5e56bba89c822470508f6d9ebe51f4e7", "message": "Update docs; improve tests", "committedDate": "2020-09-26T19:20:12Z", "type": "commit"}]}