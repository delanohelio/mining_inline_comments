{"pr_number": 489, "pr_title": "SSLEngine - PostHandshake Authentication / Renegotation", "pr_createdAt": "2020-04-14T15:29:21Z", "pr_url": "https://github.com/dogtagpki/jss/pull/489", "timeline": [{"oid": "9330d153aace36f808d08b6a67bbe5b696efded9", "url": "https://github.com/dogtagpki/jss/commit/9330d153aace36f808d08b6a67bbe5b696efded9", "message": "Add Post-Handshake/rehandshake SSLEngine tests\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-14T15:29:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNTY4MA==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r408315680", "bodyText": "Need to add the SSL option here.", "author": "cipherboy", "createdAt": "2020-04-14T17:36:24Z", "path": "org/mozilla/jss/ssl/javax/JSSEngine.java", "diffHunk": "@@ -804,6 +825,31 @@ public boolean isOutboundDone() {\n      */\n     public abstract SecurityStatusResult getStatus();\n \n+    /**\n+     * Gets the default configuration.\n+     */\n+    public HashMap<Integer, Integer> getDefaultConfiguration() {\n+        HashMap<Integer, Integer> result = new HashMap<Integer, Integer>();\n+        result.put(SSL.ENABLE_RENEGOTIATION, SSL.RENEGOTIATE_REQUIRES_XTN);\n+        result.put(SSL.REQUIRE_SAFE_NEGOTIATION, 1);\n+        result.put(28, 1);", "originalCommit": "9330d153aace36f808d08b6a67bbe5b696efded9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNjMxMQ==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r408316311", "bodyText": "Need to include these values as well in nss.SSL.", "author": "cipherboy", "createdAt": "2020-04-14T17:37:31Z", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -267,11 +276,17 @@ private void initServer() {\n             throw new RuntimeException(\"Unable to configure SSL_REQUEST_CERTIFICATE option: \" + errorText(PR.GetError()));\n         }\n \n-        if (SSL.OptionSet(ssl_fd, SSL.REQUIRE_CERTIFICATE, need_client_auth ? 1 : 0) == SSL.SECFailure) {\n+        if (SSL.OptionSet(ssl_fd, SSL.REQUIRE_CERTIFICATE, need_client_auth ? 3 : 0) == SSL.SECFailure) {", "originalCommit": "9330d153aace36f808d08b6a67bbe5b696efded9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNzQ1OQ==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r408317459", "bodyText": "Needs a comment about what we're doing here.", "author": "cipherboy", "createdAt": "2020-04-14T17:39:20Z", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -395,15 +422,48 @@ public void beginHandshake() {\n         // beginHandshake(...) if ssl_fd == null.\n \n         // ssl_fd == null <-> we've not initialized anything yet.\n+\n+        boolean unwrap = as_server;\n         if (ssl_fd == null) {\n             init();\n+\n+            // Reset the handshake status, using the new socket and\n+            // configuration which was just created.\n+            if (SSL.ResetHandshake(ssl_fd, as_server) == SSL.SECFailure) {\n+                throw new RuntimeException(\"Unable to begin handshake: \" + errorText(PR.GetError()));\n+            }\n+        } else {\n+            unwrap = !unwrap;\n+\n+            if (session.getSSLVersion() == SSLVersion.TLS_1_3) {", "originalCommit": "9330d153aace36f808d08b6a67bbe5b696efded9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNzU5MQ==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r408317591", "bodyText": "These comments need to be updated.", "author": "cipherboy", "createdAt": "2020-04-14T17:39:32Z", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -395,15 +422,48 @@ public void beginHandshake() {\n         // beginHandshake(...) if ssl_fd == null.\n \n         // ssl_fd == null <-> we've not initialized anything yet.\n+\n+        boolean unwrap = as_server;\n         if (ssl_fd == null) {\n             init();\n+\n+            // Reset the handshake status, using the new socket and\n+            // configuration which was just created.\n+            if (SSL.ResetHandshake(ssl_fd, as_server) == SSL.SECFailure) {\n+                throw new RuntimeException(\"Unable to begin handshake: \" + errorText(PR.GetError()));\n+            }\n+        } else {\n+            unwrap = !unwrap;\n+\n+            if (session.getSSLVersion() == SSLVersion.TLS_1_3) {\n+                if (as_server) {\n+                    if (SSL.SendCertificateRequest(ssl_fd) == SSL.SECFailure) {\n+                        throw new RuntimeException(\"Unable to rehandshake on TLSv1.3: \" + errorText(PR.GetError()));\n+                    }\n+                }\n+            } else {\n+                if (SSL.ReHandshake(ssl_fd, true) == SSL.SECFailure) {\n+                    throw new RuntimeException(\"Unable to rehandshake: \" + errorText(PR.GetError()));\n+                }\n+            }\n+\n+            SSL.ForceHandshake(ssl_fd);\n         }\n \n-        // Always, reset the handshake status, using the existing\n-        // socket and configuration (which might've been just created).\n-        if (SSL.ResetHandshake(ssl_fd, as_server) == SSL.SECFailure) {\n-            throw new RuntimeException(\"Unable to begin handshake: \" + errorText(PR.GetError()));\n+        if (unwrap) {\n+            // Update handshake status; client initiates connection, so wait", "originalCommit": "9330d153aace36f808d08b6a67bbe5b696efded9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxODA0NA==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r408318044", "bodyText": "Could probably drop these calls.", "author": "cipherboy", "createdAt": "2020-04-14T17:40:18Z", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -619,8 +679,7 @@ private void updateHandshakeState() {\n         // currently on, update our handshake status. This happens even if\n         // we later exit before calling SSL.ForceHandshake() so that we can\n         // see what the session data contains.\n-        SecurityStatusResult preHandshakeStatus = getStatus();", "originalCommit": "9330d153aace36f808d08b6a67bbe5b696efded9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxODIzMw==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r408318233", "bodyText": "Needs null check as well.", "author": "cipherboy", "createdAt": "2020-04-14T17:40:37Z", "path": "org/mozilla/jss/ssl/javax/JSSSession.java", "diffHunk": "@@ -50,8 +51,9 @@ public JSSEngine getEngine() {\n     }\n \n     public SSLChannelInfo getChannelInfo() {\n-        if (parent.getSSLFDProxy() != null) {\n-            return SSL.GetChannelInfo(parent.getSSLFDProxy());\n+        SSLFDProxy ssl_fd = parent.getSSLFDProxy();\n+        if (ssl_fd.handshakeComplete) {", "originalCommit": "9330d153aace36f808d08b6a67bbe5b696efded9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxODU1Mg==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r408318552", "bodyText": "Remove this since they're unused currently.", "author": "cipherboy", "createdAt": "2020-04-14T17:41:09Z", "path": "org/mozilla/jss/ssl/javax/JSSSession.java", "diffHunk": "@@ -184,6 +193,8 @@ protected void setPeerCertificates(Certificate[] new_certs) {\n     }\n \n     public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {\n+        refreshData();", "originalCommit": "9330d153aace36f808d08b6a67bbe5b696efded9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "222774254861785341b990ca4621df585000d70e", "url": "https://github.com/dogtagpki/jss/commit/222774254861785341b990ca4621df585000d70e", "message": "Add Post-Handshake/rehandshake SSLEngine tests\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-14T19:33:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM4NTkzNQ==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r408385935", "bodyText": "Spare space.", "author": "cipherboy", "createdAt": "2020-04-14T19:35:37Z", "path": "org/mozilla/jss/nss/SSL.c", "diffHunk": "@@ -598,6 +599,23 @@ Java_org_mozilla_jss_nss_SSL_ResetHandshake(JNIEnv *env, jclass clazz,\n     return SSL_ResetHandshake(real_fd, asServer);\n }\n \n+JNIEXPORT int JNICALL\n+Java_org_mozilla_jss_nss_SSL_ReHandshake(JNIEnv *env, jclass clazz,\n+    jobject fd, jboolean flushCache)\n+{\n+    PRFileDesc *real_fd = NULL;\n+\n+    PR_ASSERT(env != NULL && fd != NULL);\n+    PR_SetError(0, 0);\n+\n+    if (JSS_PR_getPRFileDesc(env, fd, &real_fd) != PR_SUCCESS) {\n+        return SECFailure;\n+    }\n+\n+    return SSL_ReHandshake(real_fd, flushCache);\n+}\n+", "originalCommit": "222774254861785341b990ca4621df585000d70e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM4NjI2NA==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r408386264", "bodyText": "getSSLRequireNoError()", "author": "cipherboy", "createdAt": "2020-04-14T19:36:14Z", "path": "org/mozilla/jss/nss/SSL.java", "diffHunk": "@@ -52,6 +52,107 @@\n      */\n     public static final int SECWouldBlock = getSSLSECWouldBlock();\n \n+    /**\n+     * Enable post-handshake authentication extension. Value for use with\n+     * OptionGet.\n+     *\n+     * See also: SSL_ENABLE_POST_HANDSHAKE_AUTH in /usr/include/nss3/ssl.h\n+     */\n+    public static final int ENABLE_POST_HANDSHAKE_AUTH = getSSLEnablePostHandshakeAuth();\n+\n+    /**\n+     * Option for configuring renegotiation after initial handshake. Value for\n+     * use with OptionGet and OptionSet.\n+     *\n+     * See also: SSL_ENABLE_RENEGOTIATION in /usr/include/nss3/ssl.h\n+     */\n+    public static final int ENABLE_RENEGOTIATION = getSSLEnableRenegotiation();\n+\n+    /**\n+     * Option for requiring safe negotiation. Value for use with OptionGet and\n+     * OptionSet.\n+     *\n+     * See also: SSL_REQUIRE_SAFE_NEGOTIATION in /usr/include/nss3/ssl.h\n+     */\n+    public static final int REQUIRE_SAFE_NEGOTIATION = getSSLRequireSafeNegotiation();\n+\n+    /**\n+     * Value for never allowing renegotiation after initial handshake. Value\n+     * for use with ENABLE_RENEGOTIATION with OptionGet and OptionSet.\n+     *\n+     * See also: SSL_RENEGOTIATE_NEVER in /usr/include/nss3/ssl.h\n+     */\n+    public static final int RENEGOTIATE_NEVER = getSSLRenegotiateNever();\n+\n+    /**\n+     * Value for always allowing renegotiation after initial handshake,\n+     * regardless of whether or not the peer's client hellow bears the\n+     * renegotiation info extension; unsafe. Value for use with\n+     * ENABLE_RENEGOTIATION with OptionGet and OptionSet.\n+     *\n+     * See also: SSL_RENEGOTIATE_UNRESTRICTED in /usr/include/nss3/ssl.h\n+     */\n+    public static final int RENEGOTIATE_UNRESTRICTED = getSSLRenegotiateUnrestricted();\n+\n+    /**\n+     * Value for allowing renegotiation after initial handshake with the TLS\n+     * renegotiation_info extension; safe. Value for use with\n+     * ENABLE_RENEGOTIATION with OptionGet and OptionSet.\n+     *\n+     * See also: SSL_RENEGOTIATE_REQUIRES_XTN in /usr/include/nss3/ssl.h\n+     */\n+    public static final int RENEGOTIATE_REQUIRES_XTN = getSSLRenegotiateRequiresXtn();\n+\n+    /**\n+     * Value for disallowing unsafe renegotiation in server sockets only, but\n+     * allows clients to continue to renegotiate with vulnerable servers.\n+     * Value for use with ENABLE_RENEGOTIATION with OptionGet and OptionSet.\n+     *\n+     * See also: SSL_RENEGOTIATE_TRANSITIONAL in /usr/include/nss3/ssl.h\n+     */\n+    public static final int RENEGOTIATE_TRANSITIONAL = getSSLRenegotiateTransitional();\n+\n+    /**\n+     * Option for sending SCSV in handshakes. Value for use with OptionGet and\n+     * OptionSet.\n+     *\n+     * See also: SSL_ENABLE_FALLBACK_SCSV in /usr/include/nss3/ssl.h\n+     */\n+    public static final int ENABLE_FALLBACK_SCSV = getSSLEnableFallbackSCSV();\n+\n+    /**\n+     * Value for never requiring a certificate. Value for use with\n+     * SSL_REQUIRE_CERTIFICATE with OptionGet and OptionSet.\n+     *\n+     * See also: SSL_REQUIRE_NEVER in /usr/include/nss3/ssl.h\n+     */\n+    public static final int REQUIRE_NEVER = getSSLRequireNever();\n+\n+    /**\n+     * Value for always requiring a certificate. Value for use with\n+     * SSL_REQUIRE_CERTIFICATE with OptionGet and OptionSet.\n+     *\n+     * See also: SSL_REQUIRE_ALWAYS in /usr/include/nss3/ssl.h\n+     */\n+    public static final int REQUIRE_ALWAYS = getSSLRequireAlways();\n+\n+    /**\n+     * Value for requiring a certificate only on the first handshake. Value\n+     * for use with SSL_REQUIRE_CERTIFICATE with OptionGet and OptionSet.\n+     *\n+     * See also: SSL_REQUIRE_FIRST_HANDSHAKE in /usr/include/nss3/ssl.h\n+     */\n+    public static final int REQUIRE_FIRST_HANDSHAKE = getSSLRequireFirstHandshake();\n+\n+    /**\n+     * Value for requiring a certificate but not erring if the peer doesn't\n+     * provide one. Value for use with SSL_REQUIRE_CERTIFICATE with OptionGet\n+     * and OptionSet.\n+     *\n+     * See also: SSL_REQUIRE_NO_ERROR in /usr/include/nss3/ssl.h\n+     */\n+    public static final int REQUIRE_NO_ERROR = getSSLRequireNever();", "originalCommit": "222774254861785341b990ca4621df585000d70e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b4108151837dfd8be112e481bf8173078c389b40", "url": "https://github.com/dogtagpki/jss/commit/b4108151837dfd8be112e481bf8173078c389b40", "message": "Add Post-Handshake/rehandshake SSLEngine tests\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-14T19:51:59Z", "type": "forcePushed"}, {"oid": "eda99b27a5d11e23adb16fa125fbfe0ed9d18502", "url": "https://github.com/dogtagpki/jss/commit/eda99b27a5d11e23adb16fa125fbfe0ed9d18502", "message": "Add Post-Handshake/rehandshake SSLEngine tests\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-16T14:38:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczODY2OA==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r411738668", "bodyText": "Should we call it setConfiguration() instead?", "author": "edewata", "createdAt": "2020-04-20T22:38:45Z", "path": "org/mozilla/jss/ssl/javax/JSSEngine.java", "diffHunk": "@@ -804,6 +825,31 @@ public boolean isOutboundDone() {\n      */\n     public abstract SecurityStatusResult getStatus();\n \n+    /**\n+     * Gets the default configuration.\n+     */\n+    public HashMap<Integer, Integer> getDefaultConfiguration() {\n+        HashMap<Integer, Integer> result = new HashMap<Integer, Integer>();\n+        result.put(SSL.ENABLE_RENEGOTIATION, SSL.RENEGOTIATE_REQUIRES_XTN);\n+        result.put(SSL.REQUIRE_SAFE_NEGOTIATION, 1);\n+        result.put(SSL.ENABLE_FALLBACK_SCSV, 1);\n+        return result;\n+    }\n+\n+    /**\n+     * Updates the configuration with the given value.\n+     */\n+    public void addConfiguration(int key, int value) {", "originalCommit": "eda99b27a5d11e23adb16fa125fbfe0ed9d18502", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NDM0Nw==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r411754347", "bodyText": "Ah I was going to add a setConfiguration(HashMap<...> config) function, thanks!", "author": "cipherboy", "createdAt": "2020-04-20T23:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczODY2OA=="}], "type": "inlineReview"}, {"oid": "18396b8552f86a6f6e1d1df5004ffa11eff717e3", "url": "https://github.com/dogtagpki/jss/commit/18396b8552f86a6f6e1d1df5004ffa11eff717e3", "message": "Add Post-Handshake/rehandshake SSLEngine tests\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-21T15:08:48Z", "type": "forcePushed"}, {"oid": "79a0b2f31759a3fa47f82641db6dad9119588946", "url": "https://github.com/dogtagpki/jss/commit/79a0b2f31759a3fa47f82641db6dad9119588946", "message": "Add Post-Handshake/rehandshake SSLEngine tests\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-21T15:14:34Z", "type": "forcePushed"}, {"oid": "670d421203e7ed739c5a819155864572f92760ea", "url": "https://github.com/dogtagpki/jss/commit/670d421203e7ed739c5a819155864572f92760ea", "message": "Expose SSL_ENABLE_POST_HANDSHAKE_AUTH\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-23T18:14:16Z", "type": "commit"}, {"oid": "888175e5096d8eb70cee5cac3e44445c38027d5c", "url": "https://github.com/dogtagpki/jss/commit/888175e5096d8eb70cee5cac3e44445c38027d5c", "message": "Expose SSL renegotiation related options\n\nIncludes:\n - SSL_ENABLE_RENEGOTIATION and its four values:\n    - SSL_RENEGOTIATE_NEVER\n    - SSL_RENEGOTIATE_UNRESTRICTED\n    - SSL_RENEGOTIATE_REQUIRES_XTN\n    - SSL_RENEGOTIATE_TRANSITIONAL\n - SSL_REQUIRE_SAFE_NEGOTIATION\n - SSL_ENABLE_FALLBACK_SCSV\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-23T18:14:16Z", "type": "commit"}, {"oid": "9dd17f76ea9fce84e3dd9d3469379cbed812e37a", "url": "https://github.com/dogtagpki/jss/commit/9dd17f76ea9fce84e3dd9d3469379cbed812e37a", "message": "Expose SSL_ReHandshake\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-23T18:14:16Z", "type": "commit"}, {"oid": "db9e97b479e4e4eac8c74afaa7bbc00dc3884b7d", "url": "https://github.com/dogtagpki/jss/commit/db9e97b479e4e4eac8c74afaa7bbc00dc3884b7d", "message": "Track handshake completion in SSLFDProxy\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-23T18:14:17Z", "type": "commit"}, {"oid": "08c654cdbde62dd215921b2161c3853475c56b41", "url": "https://github.com/dogtagpki/jss/commit/08c654cdbde62dd215921b2161c3853475c56b41", "message": "Implement SSL_SendCertificateRequest\n\nThis method is experimental for TLS v1.3 support and replaces\nSSL_ReHandshake(...) for proper Post-Handshake Authentication\nsupport.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-23T18:14:17Z", "type": "commit"}, {"oid": "742ab10180727bf59a92522c3dba1b05e3dc4382", "url": "https://github.com/dogtagpki/jss/commit/742ab10180727bf59a92522c3dba1b05e3dc4382", "message": "Add SSL_REQUIRE_CERTIFICATE Values\n\nThis adds the following values for use with SSL_REQUIRE_CERTIFICATE:\n\n - SSL_REQUIRE_NEVER\n - SSL_REQUIRE_ALWAYS\n - SSL_REQUIRE_FIRST_HANDSHAKE\n - SSL_REQUIRE_NO_ERROR\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-23T18:14:17Z", "type": "commit"}, {"oid": "e85619e5d568a6513d878535fc50a817ec2be8d6", "url": "https://github.com/dogtagpki/jss/commit/e85619e5d568a6513d878535fc50a817ec2be8d6", "message": "Implement SSL_KeyUpdate\n\nThis method is experimental for TLS v1.3 support and issues a key update\nrequest, similar to a reduced handshake.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-23T18:14:17Z", "type": "commit"}, {"oid": "c04a05e21e92e8e650c0a71c54dc7a30135422c6", "url": "https://github.com/dogtagpki/jss/commit/c04a05e21e92e8e650c0a71c54dc7a30135422c6", "message": "Introduce JSSEngine configuration, PHA support\n\nNSS (and TomcatJSS) claim post-handshake authentication (PHA) support.\nIn order to support this, we need two features in JSSEngine:\n\n - Expose configuration options from NSS, including PHA options,\n - Adding ability to notify JSSEngine implementations about\n   certain configuration changes.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-23T18:14:17Z", "type": "commit"}, {"oid": "e812ca1df8a95f70200dd51f1837642bcf0bdb74", "url": "https://github.com/dogtagpki/jss/commit/e812ca1df8a95f70200dd51f1837642bcf0bdb74", "message": "Add Post-Handshake/rehandshake SSLEngine tests\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-23T18:14:18Z", "type": "commit"}, {"oid": "e812ca1df8a95f70200dd51f1837642bcf0bdb74", "url": "https://github.com/dogtagpki/jss/commit/e812ca1df8a95f70200dd51f1837642bcf0bdb74", "message": "Add Post-Handshake/rehandshake SSLEngine tests\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-23T18:14:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI1NDMxNQ==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r416254315", "bodyText": "Question, since this block of code seems to happen in a bunch of methods, would having a convenience method be of use?", "author": "jmagne", "createdAt": "2020-04-28T01:08:07Z", "path": "org/mozilla/jss/nss/SSL.c", "diffHunk": "@@ -842,6 +891,27 @@ Java_org_mozilla_jss_nss_SSL_RemoveCallbacks(JNIEnv *env, jclass clazz,\n     SSL_AuthCertificateHook(real_fd, NULL, NULL);\n }\n \n+JNIEXPORT jint JNICALL\n+Java_org_mozilla_jss_nss_SSL_EnableHandshakeCallback(JNIEnv *env, jclass clazz,\n+    jobject fd)\n+{\n+    PRFileDesc *real_fd = NULL;\n+    jobject fd_ref = NULL;\n+\n+    PR_ASSERT(env != NULL && fd != NULL);", "originalCommit": "e812ca1df8a95f70200dd51f1837642bcf0bdb74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5NTEyOQ==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r416295129", "bodyText": "A lot of code uses this pattern. I don't think you can use a convenience method because in debug mode, it aborts. It'd be a candidate for a macro in the future (because we need to return from this method), but a lot of existing code also needs to be replaced. I think we need to replace it with a macro that checks these for NULL and returns NullPointerException.", "author": "cipherboy", "createdAt": "2020-04-28T03:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI1NDMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUwOTczNw==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r416509737", "bodyText": "They could also be removed, as the JNI contract should guarantee env should be non-NULL. If env is NULL, we have no safe way of handling it other than aborting. So env != NULL should probably be removed from all functions and we can accept the segfault that occurs in the unlikely scenario that env is ever NULL. We're essentially doing that now as PR_ASSERT only executes in debug mode.\nThat leaves fd != NULL. This (and a bunch of other cases where it is used) should be replaced by a macro that fails with NPE if/when this is NULL. It is up to the caller to ensure non-NULL of fd in this scenario.", "author": "cipherboy", "createdAt": "2020-04-28T10:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI1NDMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI1NjU5Ng==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r416256596", "bodyText": "Just a question here. I see this callback just sets some boolean when the handshake it complete. Would there be any case to have a java method receive this callback as well?", "author": "jmagne", "createdAt": "2020-04-28T01:15:18Z", "path": "org/mozilla/jss/nss/SSLFDProxy.c", "diffHunk": "@@ -240,3 +240,33 @@ JSSL_SSLFDCertSelectionCallback(void *arg,\n     *pRetKey = privkey;\n     return SECSuccess;\n }\n+\n+void\n+JSSL_SSLFDHandshakeComplete(PRFileDesc *fd, void *client_data)\n+{\n+    JNIEnv *env = NULL;\n+    jobject sslfd_proxy = (jobject)client_data;\n+    jclass sslfdProxyClass;\n+    jfieldID handshakeCompleteField;\n+\n+    if (fd == NULL || client_data == NULL || JSS_javaVM == NULL) {\n+        return;\n+    }\n+\n+    if ((*JSS_javaVM)->AttachCurrentThread(JSS_javaVM, (void**)&env, NULL) != JNI_OK || env == NULL) {\n+        return;\n+    }\n+\n+    sslfdProxyClass = (*env)->GetObjectClass(env, sslfd_proxy);\n+    if (sslfdProxyClass == NULL) {\n+        return;\n+    }\n+\n+    handshakeCompleteField = (*env)->GetFieldID(env, sslfdProxyClass,\n+                                                \"handshakeComplete\", \"Z\");\n+    if (handshakeCompleteField == NULL) {\n+        return;\n+    }\n+\n+    (*env)->SetBooleanField(env, sslfd_proxy, handshakeCompleteField, JNI_TRUE);\n+}", "originalCommit": "e812ca1df8a95f70200dd51f1837642bcf0bdb74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5MTU2NA==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r416291564", "bodyText": "For one, there's no callback in the SSLEngine specification, so adding it would be surprising. I don't think there's value in adding it because...\nSSLEngine is non-blocking. At each step of the initial handshake, there's a handshake status. It flips back and forth between Wrap and Unwrap as necessary. When the handshake is finished (i.e., this callback fires), it returns Finished. After that, it returns Not Handshaking. So the caller who would be expecting a handshake complete callback execution could alternatively wait for Finished and execute it then. That's the beauty of non-blocking SSLEngine over a SSLengine: it needs fewer callbacks. :-)", "author": "cipherboy", "createdAt": "2020-04-28T03:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI1NjU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjMxNw==", "url": "https://github.com/dogtagpki/jss/pull/489#discussion_r416552317", "bodyText": "And, SSL_SecurityStatus() reports on > 0 even when the handshake itself hasn't completed. This is most commonly when the FINISHED message hasn't yet been sent but the server has approved a particular protocol version / cipher suite pair. I believe the HandshakeCallback delays firing until the FINISHED message is on the wire, making it better than SecurityStatus.on > 0 (which is what we've replaced in this PR) for our purposes of knowing when to report the handshake as FINISHED.\nSince our call graph looks like:\n\nSSLEngine.wrap or SSLEngine.unwrap\n\nJSSEngine.updateHandshakeState()\n\nSSL_ForceHandshake()\n\n... NSS stuff ...\n\nThis handshake complete handler\n\n\n\n\n\n\n\n\n\nWe'd prefer to set a boolean and unwind back to JSSEngine.UpdateHandshakeState rather than nesting further; the next thing we need to do is in UpdateHandshakeState once SSL_ForceHandshake returns.\n\nAnd, with a user-specified callback, it'd look like:\n\n... user code ...\n\nSSLEngine.wrap or SSLEngine.unwrap\n\nJSSEngine.updateHandshakeState()\n\nSSL_ForceHandshake()\n\n... NSS stuff ...\n\nThis handshake complete handler\n\n... user callback ...\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhen we can let this operation finish and unwind back to user code and they can execute their callback directly.", "author": "cipherboy", "createdAt": "2020-04-28T11:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI1NjU5Ng=="}], "type": "inlineReview"}]}