{"pr_number": 428, "pr_title": "Add documentation about JSSEngine usage and design", "pr_createdAt": "2020-03-13T16:56:01Z", "pr_url": "https://github.com/dogtagpki/jss/pull/428", "timeline": [{"oid": "a89e441fad5e2e4e0fe20745e9958df520d928bb", "url": "https://github.com/dogtagpki/jss/commit/a89e441fad5e2e4e0fe20745e9958df520d928bb", "message": "Add documentation about JSSEngine usage and design\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-03-13T19:23:39Z", "type": "forcePushed"}, {"oid": "9ba3e64120d7cf314e5ff895561b34aa4f694066", "url": "https://github.com/dogtagpki/jss/commit/9ba3e64120d7cf314e5ff895561b34aa4f694066", "message": "Add documentation about JSSEngine usage and design\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-03-16T20:27:39Z", "type": "forcePushed"}, {"oid": "4e2432c2f0ccf6ea2471e78fc5dca5c70be31a38", "url": "https://github.com/dogtagpki/jss/commit/4e2432c2f0ccf6ea2471e78fc5dca5c70be31a38", "message": "Add documentation about JSSEngine usage and design\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-03-24T14:42:55Z", "type": "forcePushed"}, {"oid": "439e13b9f2f55670e1223efe20303b06ce93536e", "url": "https://github.com/dogtagpki/jss/commit/439e13b9f2f55670e1223efe20303b06ce93536e", "message": "Add documentation about JSSEngine usage and design\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-03-24T16:39:01Z", "type": "forcePushed"}, {"oid": "066ab91ba9f35d161dd46bb3a123293b998e585f", "url": "https://github.com/dogtagpki/jss/commit/066ab91ba9f35d161dd46bb3a123293b998e585f", "message": "Add documentation about JSSEngine usage and design\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-03-24T20:30:41Z", "type": "forcePushed"}, {"oid": "c9aa58b9fdb7b5b04b20657e7bc9917658884e60", "url": "https://github.com/dogtagpki/jss/commit/c9aa58b9fdb7b5b04b20657e7bc9917658884e60", "message": "Add documentation on PHA/renegotation\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-04-27T20:38:07Z", "type": "forcePushed"}, {"oid": "bd7e49289c6784a5425142f49674592904d43ed0", "url": "https://github.com/dogtagpki/jss/commit/bd7e49289c6784a5425142f49674592904d43ed0", "message": "Further document JSSParameters\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-18T15:18:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MjA3Nw==", "url": "https://github.com/dogtagpki/jss/pull/428#discussion_r437742077", "bodyText": "This is great so far, but below it talks about the various ways to create an SSLEngine and configure it. Would it make any sense, in your opinion to put a little more up top as to why one would create one of these things to do what? Maybe a skeleton example cllient / server program. Of course to be fair, if someone wants to use this thing, they may possibly know already... Right now it just briefly describes that it is implements the contract for non-blocking TLS. Just a thought.", "author": "jmagne", "createdAt": "2020-06-09T21:49:30Z", "path": "docs/usage/jssengine.md", "diffHunk": "@@ -0,0 +1,521 @@\n+# `JSSEngine` - Documentation\n+\n+## About `JSSEngine`\n+\n+`JSSEngine` is JSS's implementation of the [`SSLEngine`][javax.ssl-engine]\n+contract for non-blocking TLS. Unlike the `SunJSSE` provider's `SSLEngine`\n+(when using the `SunPKCS11-NSS` provider for primitives), this is built\n+directly on NSS's high-level SSL module. This is better for FIPS compliance\n+and HSM support (as keys never leave the NSS cryptographic module) and also\n+means that we don't need to reimplement the underlying state machine. This\n+approach is consistent with our [JSS `SSLSocket`][jss.ssl-socket].\n+\n+\n+## Using `JSSEngine`\n+", "originalCommit": "02542ff300efc099840b17cd24350f7aa46b8206", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0Njg2Ng==", "url": "https://github.com/dogtagpki/jss/pull/428#discussion_r437746866", "bodyText": "An interesting idea, yes. Outside of test cases, I'm not sure most people will use a SSLEngine directly for client/server handshakes. There's a number of higher-level APIs (Tomcat, Apache products, and some internal to the JDK) that take a SSLEngine instance and use it to do, say, TLS for HTTPS or LDAPS. In my opinion, most people probably won't be using SSLEngine directly to do client/server ops and just need to \"configure\" it to pass it to the relevant library/...\nShould I just provide a link to the test cases where this is done? Otherwise, there is an excellent Oracle example that explains this as well.", "author": "cipherboy", "createdAt": "2020-06-09T22:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MjA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1MzI2NQ==", "url": "https://github.com/dogtagpki/jss/pull/428#discussion_r437753265", "bodyText": "Yeah, the links sound good, but maybe just put a blurb or two explaining what this thing is for and how mostly it will be associated with higher level API's, just like you said and that should do it. Otherwise I\"m just about finishing reading it and it looks great so far.", "author": "jmagne", "createdAt": "2020-06-09T22:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MjA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1NTM3Mw==", "url": "https://github.com/dogtagpki/jss/pull/428#discussion_r437755373", "bodyText": "This section might be a little confusing to those initiated. Here is just says it's mostly like SSLParameters but with added properties. Would one know how and when to use these instead of the SSLParameters? Also not those are mentioned indirectly when talking about  \"SSLContext.getDefaultSSLParameters() and SSLContext.getSupportedSSLParameters()\".  Only asking...", "author": "jmagne", "createdAt": "2020-06-09T22:22:55Z", "path": "docs/usage/jssengine.md", "diffHunk": "@@ -0,0 +1,521 @@\n+# `JSSEngine` - Documentation\n+\n+## About `JSSEngine`\n+\n+`JSSEngine` is JSS's implementation of the [`SSLEngine`][javax.ssl-engine]\n+contract for non-blocking TLS. Unlike the `SunJSSE` provider's `SSLEngine`\n+(when using the `SunPKCS11-NSS` provider for primitives), this is built\n+directly on NSS's high-level SSL module. This is better for FIPS compliance\n+and HSM support (as keys never leave the NSS cryptographic module) and also\n+means that we don't need to reimplement the underlying state machine. This\n+approach is consistent with our [JSS `SSLSocket`][jss.ssl-socket].\n+\n+\n+## Using `JSSEngine`\n+\n+There are two ways to use the `JSSEngine`: via the JCA Provider interface,\n+or constructing a `JSSEngine` instance directly. The former method is\n+preferred out of the two.\n+\n+\n+### Via the JSSProvider\n+\n+This is the preferred way of using the `JSSEngine`. To construct a new\n+[`SSLEngine`][javax.ssl-engine] instance, first get `Mozilla-JSS`'s\n+[`SSLContext`][javax.ssl-context]:\n+\n+```java\n+// First get the necessary KeyManagers and TrustManagers. Note that\n+// selecting KeyManagers and TrustManagers is discussed more below.\n+KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"NssX509\", \"Mozilla-JSS\");\n+KeyManager[] kms = kmf.getKeyManagers();\n+\n+TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"NssX509\", \"Mozilla-JSS\");\n+TrustManager[] tms = tmf.getTrustManagers();\n+\n+// Then, initialize the SSLContext with the above information. Note that\n+// we don't utilize the SecureRandom parameter, as NSS internally handles\n+// generating random numbers for us.\n+SSLContext ctx = SSLContext.getInstance(\"TLS\", \"Mozilla-JSS\");\n+ctx.init(kms, tms, null);\n+\n+// If we don't have any peer host/port information, use this form:\n+SSLEngine engine = ctx.createSSLEngine();\n+\n+// Otherwise, use this form:\n+SSLEngine engine = ctx.createSSLEngine(peerHost, peerPort);\n+```\n+\n+The [`SSLContext`][javax.ssl-context] also provides methods helpful for\n+configuring the [`SSLEngine`][javax.ssl-engine]. These are\n+`SSLContext.getDefaultSSLParameters()` and\n+`SSLContext.getSupportedSSLParameters()`. These provide the default parameters\n+used by the SSLEngine and all supported SSLParameters, respectively.\n+\n+For more information about configuring the `JSSEngine`, see the section below.\n+\n+Note that the `Mozilla-JSS` provider's `SSLContext` instance also provides\n+methods for creating `SSLSocket` factories which conform to the same\n+`javax.net.ssl` interfaces. These sockets utilize the `JSSEngine` internally\n+and expose many of the same configuration methods under the `JSSSocket` class\n+namespace. The results of these factories can be directly cast to `JSSSocket`\n+or `JSSServerSocket` as appropriate.\n+\n+\n+### Direct Utilization\n+\n+This is the less preferred way of using the `JSSEngine`. This requires\n+understanding the class layout of `JSSEngine`. See the section below for more\n+information.\n+\n+First, get an instance of `JSSEngine`:\n+\n+```java\n+/* If no session resumption hints are provided: */\n+// JSSEngine engine = new JSSEngine<$Impl>();\n+\n+/* If we already know the peer's host and port: */\n+// String peerHost;\n+// int peerPort;\n+// JSSEngine engine = new JSSEngine<$Impl>(peerHost, peerPort);\n+\n+/* Or laastly, if we know the peer's host and port, and want to set\n+ * a certificate and key to use for our side of the connection: */\n+// X509Certificate localCert;\n+// PrivateKey localKey;\n+JSSEngine engine = new JSSEngine<$Impl>(peerHost, peerPort, localCert, localKey);\n+```\n+\n+Replace `JSSEngine<$Impl>` with one of the implementing classes below.\n+\n+Then, continue with configuring the `JSSEngine` below.\n+\n+\n+### Configuring the `JSSEngine`\n+\n+Configuring the `JSSEngine` is a multi-step process. Below are common\n+configuration options grouped into categories.\n+\n+#### Choosing Handshake Side\n+\n+Configuring which side of the handshake this `JSSEngine` will use occurs via\n+a call to `setUseClientMode(boolean mode)`. When `mode` is `true`, this engine\n+will handshake as if it was the client. Otherwise, this engine will handshake\n+as a server. Note that calling `setUseClientMode(...)` after the handshake has\n+started (either via calling `beginHandshake(...)`, `wrap(...)`, or\n+`unwrap(...)`) isn't supported.\n+\n+Checking the current mode can be done via `getUseClientMode(...)`.\n+\n+#### Choosing Key Material\n+\n+Key material can be chosen in several ways. In every scenario, a JSSKeyManager\n+instance needs to be passed to the JSSEngine:\n+\n+```java\n+// JSSEngine inst;\n+inst.setKeyManager(new JSSKeyManager());\n+```\n+\n+For direct selection of key from an existing instance, call `setKeyMaterials`:\n+\n+```java\n+// JSSEngine inst;\n+inst.setKeyMaterials(myPK11Cert, myPK11PrivKey);\n+```\n+\n+Note that these must be instances of [`PK11Cert`][jss.pk11-cert] and\n+[`PK11PrivKey`][jss.pk11-privkey] respectively. These can be obtained from\n+the [`CryptoManager`][jss.cryptomanager] and casting `X509Certificate` to\n+`PK11Cert` and `PrivateKey` to `PK11PrivKey`.\n+\n+For selection of a key via an alias in the certificate database, call\n+`setCertFromAlias`:\n+\n+```java\n+// JSSEngine inst;\n+inst.setCertFromAlias(\"server-cert-alias\");\n+```\n+\n+Lastly, key material could've been provided when the `JSSEngine` was\n+constructed; see the section on direct utilization above.\n+\n+Note that SNI support isn't yet added so the key selection must occur prior\n+to the initial handshake.\n+\n+#### Choosing TLS protocol version\n+\n+There are two ways to choose TLS protocol version. The first is via the Java\n+Provider interface, selecting the TLS version directly. The `Mozilla-JSS`\n+provider understands the following aliases:\n+\n+ - `SSL` and `TLS`, enabling any allowed SSL and TLS protocol version,\n+ - `TLSv1.1` to enable only TLS version 1.1 by default,\n+ - `TLSv1.2` to enable only TLS version 1.2 by default, and\n+ - `TLSv1.3` to enable only TLS version 1.3 by default.\n+\n+Alternatively, the standard `SSLEngine` configuration method of passing\n+a list of protocols to `setEnabledProtocols` is also allowed. Note that this\n+will override any value passed via the Provider interface. Additionally, due\n+to restrictions in NSS, a contiguous range of protocols will be enabled. For\n+example, the following call:\n+\n+```java\n+// SSLEngine inst;\n+inst.setEnabledProtocols(new String[] { \"TLSv1.1\", \"TLSv1.3\" });\n+```\n+\n+will enable TLSv1.1, TLSv1.2, and TLSv1.3.\n+\n+Alternative methods are available that take JSS standard `SSLVersion` and\n+`SSLVersionRange` values as parameters; see the `JSSEngine` javadoc for\n+more information.\n+\n+#### Choosing Cipher Suite\n+\n+Configuring cipher suites is performed using the standard `SSLEngine`\n+configuration method of passing a list of cipher suites to\n+`setEnabledCipherSuites`. We filter the list of passed cipher suites to\n+only those allowed by local policy. For example:\n+\n+```java\n+// SSLEngine inst;\n+inst.setEnabledCipherSuites(new String[] { \"TLS_AES_128_GCM_SHA256\" });\n+```\n+\n+will enable only a single TLSv1.3 cipher suite.\n+\n+Alternative methods are available that take JSS standard `SSLCipher`\n+values as parameters; see the `JSSEngine` javadoc for more information.\n+\n+#### Using `JSSParameters`", "originalCommit": "02542ff300efc099840b17cd24350f7aa46b8206", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1NTg0OA==", "url": "https://github.com/dogtagpki/jss/pull/428#discussion_r437755848", "bodyText": "I just noticed that there is a reference to the JSSParameters separate man page.", "author": "jmagne", "createdAt": "2020-06-09T22:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1NTM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2ODA5Nw==", "url": "https://github.com/dogtagpki/jss/pull/428#discussion_r442968097", "bodyText": "OK clarified. JSSParameters inherits from SSLParameters; the latter is in the standard library and should be used by most everyone, but if you need something only JSSParameters provides (or wish to re-use existing JSS classes such as the SSLCipher enums) it is better to use JSSParameters.", "author": "cipherboy", "createdAt": "2020-06-19T17:40:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1NTM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1NjgwMQ==", "url": "https://github.com/dogtagpki/jss/pull/428#discussion_r437756801", "bodyText": "Working on the following sentence seems a bit off to me maybe just a typo.", "author": "jmagne", "createdAt": "2020-06-09T22:26:55Z", "path": "docs/usage/jssengine.md", "diffHunk": "@@ -0,0 +1,521 @@\n+# `JSSEngine` - Documentation\n+\n+## About `JSSEngine`\n+\n+`JSSEngine` is JSS's implementation of the [`SSLEngine`][javax.ssl-engine]\n+contract for non-blocking TLS. Unlike the `SunJSSE` provider's `SSLEngine`\n+(when using the `SunPKCS11-NSS` provider for primitives), this is built\n+directly on NSS's high-level SSL module. This is better for FIPS compliance\n+and HSM support (as keys never leave the NSS cryptographic module) and also\n+means that we don't need to reimplement the underlying state machine. This\n+approach is consistent with our [JSS `SSLSocket`][jss.ssl-socket].\n+\n+\n+## Using `JSSEngine`\n+\n+There are two ways to use the `JSSEngine`: via the JCA Provider interface,\n+or constructing a `JSSEngine` instance directly. The former method is\n+preferred out of the two.\n+\n+\n+### Via the JSSProvider\n+\n+This is the preferred way of using the `JSSEngine`. To construct a new\n+[`SSLEngine`][javax.ssl-engine] instance, first get `Mozilla-JSS`'s\n+[`SSLContext`][javax.ssl-context]:\n+\n+```java\n+// First get the necessary KeyManagers and TrustManagers. Note that\n+// selecting KeyManagers and TrustManagers is discussed more below.\n+KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"NssX509\", \"Mozilla-JSS\");\n+KeyManager[] kms = kmf.getKeyManagers();\n+\n+TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"NssX509\", \"Mozilla-JSS\");\n+TrustManager[] tms = tmf.getTrustManagers();\n+\n+// Then, initialize the SSLContext with the above information. Note that\n+// we don't utilize the SecureRandom parameter, as NSS internally handles\n+// generating random numbers for us.\n+SSLContext ctx = SSLContext.getInstance(\"TLS\", \"Mozilla-JSS\");\n+ctx.init(kms, tms, null);\n+\n+// If we don't have any peer host/port information, use this form:\n+SSLEngine engine = ctx.createSSLEngine();\n+\n+// Otherwise, use this form:\n+SSLEngine engine = ctx.createSSLEngine(peerHost, peerPort);\n+```\n+\n+The [`SSLContext`][javax.ssl-context] also provides methods helpful for\n+configuring the [`SSLEngine`][javax.ssl-engine]. These are\n+`SSLContext.getDefaultSSLParameters()` and\n+`SSLContext.getSupportedSSLParameters()`. These provide the default parameters\n+used by the SSLEngine and all supported SSLParameters, respectively.\n+\n+For more information about configuring the `JSSEngine`, see the section below.\n+\n+Note that the `Mozilla-JSS` provider's `SSLContext` instance also provides\n+methods for creating `SSLSocket` factories which conform to the same\n+`javax.net.ssl` interfaces. These sockets utilize the `JSSEngine` internally\n+and expose many of the same configuration methods under the `JSSSocket` class\n+namespace. The results of these factories can be directly cast to `JSSSocket`\n+or `JSSServerSocket` as appropriate.\n+\n+\n+### Direct Utilization\n+\n+This is the less preferred way of using the `JSSEngine`. This requires\n+understanding the class layout of `JSSEngine`. See the section below for more\n+information.\n+\n+First, get an instance of `JSSEngine`:\n+\n+```java\n+/* If no session resumption hints are provided: */\n+// JSSEngine engine = new JSSEngine<$Impl>();\n+\n+/* If we already know the peer's host and port: */\n+// String peerHost;\n+// int peerPort;\n+// JSSEngine engine = new JSSEngine<$Impl>(peerHost, peerPort);\n+\n+/* Or laastly, if we know the peer's host and port, and want to set\n+ * a certificate and key to use for our side of the connection: */\n+// X509Certificate localCert;\n+// PrivateKey localKey;\n+JSSEngine engine = new JSSEngine<$Impl>(peerHost, peerPort, localCert, localKey);\n+```\n+\n+Replace `JSSEngine<$Impl>` with one of the implementing classes below.\n+\n+Then, continue with configuring the `JSSEngine` below.\n+\n+\n+### Configuring the `JSSEngine`\n+\n+Configuring the `JSSEngine` is a multi-step process. Below are common\n+configuration options grouped into categories.\n+\n+#### Choosing Handshake Side\n+\n+Configuring which side of the handshake this `JSSEngine` will use occurs via\n+a call to `setUseClientMode(boolean mode)`. When `mode` is `true`, this engine\n+will handshake as if it was the client. Otherwise, this engine will handshake\n+as a server. Note that calling `setUseClientMode(...)` after the handshake has\n+started (either via calling `beginHandshake(...)`, `wrap(...)`, or\n+`unwrap(...)`) isn't supported.\n+\n+Checking the current mode can be done via `getUseClientMode(...)`.\n+\n+#### Choosing Key Material\n+\n+Key material can be chosen in several ways. In every scenario, a JSSKeyManager\n+instance needs to be passed to the JSSEngine:\n+\n+```java\n+// JSSEngine inst;\n+inst.setKeyManager(new JSSKeyManager());\n+```\n+\n+For direct selection of key from an existing instance, call `setKeyMaterials`:\n+\n+```java\n+// JSSEngine inst;\n+inst.setKeyMaterials(myPK11Cert, myPK11PrivKey);\n+```\n+\n+Note that these must be instances of [`PK11Cert`][jss.pk11-cert] and\n+[`PK11PrivKey`][jss.pk11-privkey] respectively. These can be obtained from\n+the [`CryptoManager`][jss.cryptomanager] and casting `X509Certificate` to\n+`PK11Cert` and `PrivateKey` to `PK11PrivKey`.\n+\n+For selection of a key via an alias in the certificate database, call\n+`setCertFromAlias`:\n+\n+```java\n+// JSSEngine inst;\n+inst.setCertFromAlias(\"server-cert-alias\");\n+```\n+\n+Lastly, key material could've been provided when the `JSSEngine` was\n+constructed; see the section on direct utilization above.\n+\n+Note that SNI support isn't yet added so the key selection must occur prior\n+to the initial handshake.\n+\n+#### Choosing TLS protocol version\n+\n+There are two ways to choose TLS protocol version. The first is via the Java\n+Provider interface, selecting the TLS version directly. The `Mozilla-JSS`\n+provider understands the following aliases:\n+\n+ - `SSL` and `TLS`, enabling any allowed SSL and TLS protocol version,\n+ - `TLSv1.1` to enable only TLS version 1.1 by default,\n+ - `TLSv1.2` to enable only TLS version 1.2 by default, and\n+ - `TLSv1.3` to enable only TLS version 1.3 by default.\n+\n+Alternatively, the standard `SSLEngine` configuration method of passing\n+a list of protocols to `setEnabledProtocols` is also allowed. Note that this\n+will override any value passed via the Provider interface. Additionally, due\n+to restrictions in NSS, a contiguous range of protocols will be enabled. For\n+example, the following call:\n+\n+```java\n+// SSLEngine inst;\n+inst.setEnabledProtocols(new String[] { \"TLSv1.1\", \"TLSv1.3\" });\n+```\n+\n+will enable TLSv1.1, TLSv1.2, and TLSv1.3.\n+\n+Alternative methods are available that take JSS standard `SSLVersion` and\n+`SSLVersionRange` values as parameters; see the `JSSEngine` javadoc for\n+more information.\n+\n+#### Choosing Cipher Suite\n+\n+Configuring cipher suites is performed using the standard `SSLEngine`\n+configuration method of passing a list of cipher suites to\n+`setEnabledCipherSuites`. We filter the list of passed cipher suites to\n+only those allowed by local policy. For example:\n+\n+```java\n+// SSLEngine inst;\n+inst.setEnabledCipherSuites(new String[] { \"TLS_AES_128_GCM_SHA256\" });\n+```\n+\n+will enable only a single TLSv1.3 cipher suite.\n+\n+Alternative methods are available that take JSS standard `SSLCipher`\n+values as parameters; see the `JSSEngine` javadoc for more information.\n+\n+#### Using `JSSParameters`\n+\n+`JSSParameters` largely aligns with `SSLParameters` except that it allows\n+two important introductions:\n+\n+ 1. Selection of key material, like above. See the javadocs on `JSSParameters`\n+    for more information.\n+ 2. Setting the peer's hostname, for use with validation of certificates. This\n+    allows us to tie into NSS's hostname verification directly, instead of\n+    responding after the fact by closing the connection.\n+\n+#### Session Control\n+\n+The `JSSEngine` lacks many of the session control functions other `SSLEngine`\n+implementations might have. In particular, we:\n+\n+ - Always enable session resumption; this cannot be disabled.\n+ - Allow forced expiration of a session as long as the `SSLEngine`'s\n+   connection isn't yet closed.\n+ - Report accurate creation/expiration/last accessed times.\n+\n+However, other features of sessions (such as configuring location and size of\n+the session cache) aren't yet configurable.\n+\n+\n+## Design of the `JSSEngine`\n+\n+### Class Structuring\n+\n+The below is a digram showing the structure of `JSSEngine` classes:\n+\n+                           -----------\n+                          | JSSEngine |-------------------------\n+                           -----------                          \\\n+                            /       \\                            \\\n+     ------------------------       ------------------------     ------\n+    | JSSEngineReferenceImpl |     | JSSEngineOptimizedImpl |   | .... |\n+     ------------------------       ------------------------     ------\n+\n+`JSSEngine` is an abstract class extending [`SSLEngine`][javax.ssl-engine].\n+This class implements some of the boilerplate required for implementing a\n+`SSLEngine`, including handling cipher and protocol version configuration.\n+Individual implementations implement `wrap`, `unwrap`, and whatever specifics\n+are necessary to initialize and release the SSL-backed `PRFileDesc`.\n+\n+We expect two primary implementations:\n+\n+ - `JSSEngineReferenceImpl`, a reference implementation with more logging\n+   and debugging statements. This also includes port-based debugging, so", "originalCommit": "02542ff300efc099840b17cd24350f7aa46b8206", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1NjkzNg==", "url": "https://github.com/dogtagpki/jss/pull/428#discussion_r437756936", "bodyText": "\"is without writing to the network\"", "author": "jmagne", "createdAt": "2020-06-09T22:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1NjgwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2ODM3OA==", "url": "https://github.com/dogtagpki/jss/pull/428#discussion_r442968378", "bodyText": "Yeah, good catch. Thanks. :)", "author": "cipherboy", "createdAt": "2020-06-19T17:40:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1NjgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1OTk3OQ==", "url": "https://github.com/dogtagpki/jss/pull/428#discussion_r437759979", "bodyText": "I found it interesting when looking at the code that the NSPR sockets were being used to wrap or  unwrap locally and then handing the data off to wrap or unwrap. Would a simple statement to that at a high level make the whole thing a bit clearer to the reader? I know that all that gets explained below at the nitty gritty level.", "author": "jmagne", "createdAt": "2020-06-09T22:36:03Z", "path": "docs/usage/jssengine.md", "diffHunk": "@@ -0,0 +1,521 @@\n+# `JSSEngine` - Documentation\n+\n+## About `JSSEngine`\n+\n+`JSSEngine` is JSS's implementation of the [`SSLEngine`][javax.ssl-engine]\n+contract for non-blocking TLS. Unlike the `SunJSSE` provider's `SSLEngine`\n+(when using the `SunPKCS11-NSS` provider for primitives), this is built\n+directly on NSS's high-level SSL module. This is better for FIPS compliance\n+and HSM support (as keys never leave the NSS cryptographic module) and also\n+means that we don't need to reimplement the underlying state machine. This\n+approach is consistent with our [JSS `SSLSocket`][jss.ssl-socket].\n+\n+\n+## Using `JSSEngine`\n+\n+There are two ways to use the `JSSEngine`: via the JCA Provider interface,\n+or constructing a `JSSEngine` instance directly. The former method is\n+preferred out of the two.\n+\n+\n+### Via the JSSProvider\n+\n+This is the preferred way of using the `JSSEngine`. To construct a new\n+[`SSLEngine`][javax.ssl-engine] instance, first get `Mozilla-JSS`'s\n+[`SSLContext`][javax.ssl-context]:\n+\n+```java\n+// First get the necessary KeyManagers and TrustManagers. Note that\n+// selecting KeyManagers and TrustManagers is discussed more below.\n+KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"NssX509\", \"Mozilla-JSS\");\n+KeyManager[] kms = kmf.getKeyManagers();\n+\n+TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"NssX509\", \"Mozilla-JSS\");\n+TrustManager[] tms = tmf.getTrustManagers();\n+\n+// Then, initialize the SSLContext with the above information. Note that\n+// we don't utilize the SecureRandom parameter, as NSS internally handles\n+// generating random numbers for us.\n+SSLContext ctx = SSLContext.getInstance(\"TLS\", \"Mozilla-JSS\");\n+ctx.init(kms, tms, null);\n+\n+// If we don't have any peer host/port information, use this form:\n+SSLEngine engine = ctx.createSSLEngine();\n+\n+// Otherwise, use this form:\n+SSLEngine engine = ctx.createSSLEngine(peerHost, peerPort);\n+```\n+\n+The [`SSLContext`][javax.ssl-context] also provides methods helpful for\n+configuring the [`SSLEngine`][javax.ssl-engine]. These are\n+`SSLContext.getDefaultSSLParameters()` and\n+`SSLContext.getSupportedSSLParameters()`. These provide the default parameters\n+used by the SSLEngine and all supported SSLParameters, respectively.\n+\n+For more information about configuring the `JSSEngine`, see the section below.\n+\n+Note that the `Mozilla-JSS` provider's `SSLContext` instance also provides\n+methods for creating `SSLSocket` factories which conform to the same\n+`javax.net.ssl` interfaces. These sockets utilize the `JSSEngine` internally\n+and expose many of the same configuration methods under the `JSSSocket` class\n+namespace. The results of these factories can be directly cast to `JSSSocket`\n+or `JSSServerSocket` as appropriate.\n+\n+\n+### Direct Utilization\n+\n+This is the less preferred way of using the `JSSEngine`. This requires\n+understanding the class layout of `JSSEngine`. See the section below for more\n+information.\n+\n+First, get an instance of `JSSEngine`:\n+\n+```java\n+/* If no session resumption hints are provided: */\n+// JSSEngine engine = new JSSEngine<$Impl>();\n+\n+/* If we already know the peer's host and port: */\n+// String peerHost;\n+// int peerPort;\n+// JSSEngine engine = new JSSEngine<$Impl>(peerHost, peerPort);\n+\n+/* Or laastly, if we know the peer's host and port, and want to set\n+ * a certificate and key to use for our side of the connection: */\n+// X509Certificate localCert;\n+// PrivateKey localKey;\n+JSSEngine engine = new JSSEngine<$Impl>(peerHost, peerPort, localCert, localKey);\n+```\n+\n+Replace `JSSEngine<$Impl>` with one of the implementing classes below.\n+\n+Then, continue with configuring the `JSSEngine` below.\n+\n+\n+### Configuring the `JSSEngine`\n+\n+Configuring the `JSSEngine` is a multi-step process. Below are common\n+configuration options grouped into categories.\n+\n+#### Choosing Handshake Side\n+\n+Configuring which side of the handshake this `JSSEngine` will use occurs via\n+a call to `setUseClientMode(boolean mode)`. When `mode` is `true`, this engine\n+will handshake as if it was the client. Otherwise, this engine will handshake\n+as a server. Note that calling `setUseClientMode(...)` after the handshake has\n+started (either via calling `beginHandshake(...)`, `wrap(...)`, or\n+`unwrap(...)`) isn't supported.\n+\n+Checking the current mode can be done via `getUseClientMode(...)`.\n+\n+#### Choosing Key Material\n+\n+Key material can be chosen in several ways. In every scenario, a JSSKeyManager\n+instance needs to be passed to the JSSEngine:\n+\n+```java\n+// JSSEngine inst;\n+inst.setKeyManager(new JSSKeyManager());\n+```\n+\n+For direct selection of key from an existing instance, call `setKeyMaterials`:\n+\n+```java\n+// JSSEngine inst;\n+inst.setKeyMaterials(myPK11Cert, myPK11PrivKey);\n+```\n+\n+Note that these must be instances of [`PK11Cert`][jss.pk11-cert] and\n+[`PK11PrivKey`][jss.pk11-privkey] respectively. These can be obtained from\n+the [`CryptoManager`][jss.cryptomanager] and casting `X509Certificate` to\n+`PK11Cert` and `PrivateKey` to `PK11PrivKey`.\n+\n+For selection of a key via an alias in the certificate database, call\n+`setCertFromAlias`:\n+\n+```java\n+// JSSEngine inst;\n+inst.setCertFromAlias(\"server-cert-alias\");\n+```\n+\n+Lastly, key material could've been provided when the `JSSEngine` was\n+constructed; see the section on direct utilization above.\n+\n+Note that SNI support isn't yet added so the key selection must occur prior\n+to the initial handshake.\n+\n+#### Choosing TLS protocol version\n+\n+There are two ways to choose TLS protocol version. The first is via the Java\n+Provider interface, selecting the TLS version directly. The `Mozilla-JSS`\n+provider understands the following aliases:\n+\n+ - `SSL` and `TLS`, enabling any allowed SSL and TLS protocol version,\n+ - `TLSv1.1` to enable only TLS version 1.1 by default,\n+ - `TLSv1.2` to enable only TLS version 1.2 by default, and\n+ - `TLSv1.3` to enable only TLS version 1.3 by default.\n+\n+Alternatively, the standard `SSLEngine` configuration method of passing\n+a list of protocols to `setEnabledProtocols` is also allowed. Note that this\n+will override any value passed via the Provider interface. Additionally, due\n+to restrictions in NSS, a contiguous range of protocols will be enabled. For\n+example, the following call:\n+\n+```java\n+// SSLEngine inst;\n+inst.setEnabledProtocols(new String[] { \"TLSv1.1\", \"TLSv1.3\" });\n+```\n+\n+will enable TLSv1.1, TLSv1.2, and TLSv1.3.\n+\n+Alternative methods are available that take JSS standard `SSLVersion` and\n+`SSLVersionRange` values as parameters; see the `JSSEngine` javadoc for\n+more information.\n+\n+#### Choosing Cipher Suite\n+\n+Configuring cipher suites is performed using the standard `SSLEngine`\n+configuration method of passing a list of cipher suites to\n+`setEnabledCipherSuites`. We filter the list of passed cipher suites to\n+only those allowed by local policy. For example:\n+\n+```java\n+// SSLEngine inst;\n+inst.setEnabledCipherSuites(new String[] { \"TLS_AES_128_GCM_SHA256\" });\n+```\n+\n+will enable only a single TLSv1.3 cipher suite.\n+\n+Alternative methods are available that take JSS standard `SSLCipher`\n+values as parameters; see the `JSSEngine` javadoc for more information.\n+\n+#### Using `JSSParameters`\n+\n+`JSSParameters` largely aligns with `SSLParameters` except that it allows\n+two important introductions:\n+\n+ 1. Selection of key material, like above. See the javadocs on `JSSParameters`\n+    for more information.\n+ 2. Setting the peer's hostname, for use with validation of certificates. This\n+    allows us to tie into NSS's hostname verification directly, instead of\n+    responding after the fact by closing the connection.\n+\n+#### Session Control\n+\n+The `JSSEngine` lacks many of the session control functions other `SSLEngine`\n+implementations might have. In particular, we:\n+\n+ - Always enable session resumption; this cannot be disabled.\n+ - Allow forced expiration of a session as long as the `SSLEngine`'s\n+   connection isn't yet closed.\n+ - Report accurate creation/expiration/last accessed times.\n+\n+However, other features of sessions (such as configuring location and size of\n+the session cache) aren't yet configurable.\n+\n+\n+## Design of the `JSSEngine`\n+\n+### Class Structuring\n+\n+The below is a digram showing the structure of `JSSEngine` classes:\n+\n+                           -----------\n+                          | JSSEngine |-------------------------\n+                           -----------                          \\\n+                            /       \\                            \\\n+     ------------------------       ------------------------     ------\n+    | JSSEngineReferenceImpl |     | JSSEngineOptimizedImpl |   | .... |\n+     ------------------------       ------------------------     ------\n+\n+`JSSEngine` is an abstract class extending [`SSLEngine`][javax.ssl-engine].\n+This class implements some of the boilerplate required for implementing a\n+`SSLEngine`, including handling cipher and protocol version configuration.\n+Individual implementations implement `wrap`, `unwrap`, and whatever specifics\n+are necessary to initialize and release the SSL-backed `PRFileDesc`.\n+\n+We expect two primary implementations:\n+\n+ - `JSSEngineReferenceImpl`, a reference implementation with more logging\n+   and debugging statements. This also includes port-based debugging, so\n+   situations where a `SSLEngine` is without writing to the network can\n+   still be tracked and analyzed in Wireshark. Each call to `wrap` or `unwrap`\n+   makes several JNI calls, incurring lots of overhead.\n+ - `JSSEngineOptimizedImpl`, an optimized, production-ready implementation.\n+   This one is harder to debug due to fewer logging statements, but does\n+   improve performance significantly with fewer JNI calls.\n+\n+\n+### Non-Blocking IO\n+\n+NSPR introduces a platform-independent abstraction over C's file descriptors\n+(usually an `int`) in the form of the `PRFileDesc` structure. This is\n+layer-able, allowing us to write our own and then have it be accepted by\n+NSS's SSL `PRFileDesc` implementation as the underlying transport.\n+\n+Our `PRFileDesc` is called `BufferPRFD` and lives next to the `JSSEngine`\n+implementation in `org/mozilla/jss/ssl/javax`. Each `BufferPRFD` is backed\n+by two `j_buffer` instances (located adjacent). A `j_buffer` is a circular\n+ring buffer optimized to allow efficient access to the underlying data. One\n+`j_buffer` is dedicated to the read end of this `BufferPRFD` (the data that\n+is returned when `recv(...)` is called); the other is dedicated to the write\n+end of this `BufferPRFD` (the data that is waiting to get sent on the wire).\n+Note that the `j_buffer` instances exist independently from the `BufferPRFD`:\n+the `JSSEngine` itself creates the `j_buffer`s and hands them to the\n+`BufferPRFD` to use, because it too needs to be able to read from them.\n+", "originalCommit": "02542ff300efc099840b17cd24350f7aa46b8206", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2OTgxMg==", "url": "https://github.com/dogtagpki/jss/pull/428#discussion_r442969812", "bodyText": "OK, I think I've added a clarifying section at the beginning of all this nitty-gritty stuff. :)", "author": "cipherboy", "createdAt": "2020-06-19T17:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1OTk3OQ=="}], "type": "inlineReview"}, {"oid": "bffb0ca337520a3961c0b7a96c41d60ce91dba0e", "url": "https://github.com/dogtagpki/jss/commit/bffb0ca337520a3961c0b7a96c41d60ce91dba0e", "message": "Add documentation about JSSEngine usage and design\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-06-19T17:23:07Z", "type": "commit"}, {"oid": "d2f20fdb86bd680ccf78da618232fe20c0303cb8", "url": "https://github.com/dogtagpki/jss/commit/d2f20fdb86bd680ccf78da618232fe20c0303cb8", "message": "Add documentation on PHA/renegotation\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-06-19T17:23:07Z", "type": "commit"}, {"oid": "58cc72bf5b042173554a358a75dc06b89f3930bb", "url": "https://github.com/dogtagpki/jss/commit/58cc72bf5b042173554a358a75dc06b89f3930bb", "message": "Document key selection in JSSEngine\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-06-19T17:23:07Z", "type": "commit"}, {"oid": "69dc934ac17992524a779c90939195f17fc7344d", "url": "https://github.com/dogtagpki/jss/commit/69dc934ac17992524a779c90939195f17fc7344d", "message": "Document cipher, protocol selection, sessions\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-06-19T17:23:07Z", "type": "commit"}, {"oid": "cb573821ec30ddd25e4f83c5f48e22a0341cdfa7", "url": "https://github.com/dogtagpki/jss/commit/cb573821ec30ddd25e4f83c5f48e22a0341cdfa7", "message": "Document large wrap/unwrap theory\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-06-19T17:23:08Z", "type": "commit"}, {"oid": "0ad52b772e86f2996e8e517cad47aef6d67bf51f", "url": "https://github.com/dogtagpki/jss/commit/0ad52b772e86f2996e8e517cad47aef6d67bf51f", "message": "Further document JSSParameters\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-06-19T17:23:08Z", "type": "commit"}, {"oid": "db843d2e4507a2ed3ecd03ed4f3caec1e4acc475", "url": "https://github.com/dogtagpki/jss/commit/db843d2e4507a2ed3ecd03ed4f3caec1e4acc475", "message": "Mention JSSSocket, clarify performance issues\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-06-19T17:23:08Z", "type": "commit"}, {"oid": "69864eecb77a776c02e552a17cf38b319bddae39", "url": "https://github.com/dogtagpki/jss/commit/69864eecb77a776c02e552a17cf38b319bddae39", "message": "Minor improvements to SSLEngine documentation\n\nAddresses feedback by jmagne.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-06-19T17:44:08Z", "type": "commit"}, {"oid": "69864eecb77a776c02e552a17cf38b319bddae39", "url": "https://github.com/dogtagpki/jss/commit/69864eecb77a776c02e552a17cf38b319bddae39", "message": "Minor improvements to SSLEngine documentation\n\nAddresses feedback by jmagne.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-06-19T17:44:08Z", "type": "forcePushed"}]}