{"pr_number": 532, "pr_title": "SSLSocket from SSLEngine", "pr_createdAt": "2020-04-30T20:59:19Z", "pr_url": "https://github.com/dogtagpki/jss/pull/532", "timeline": [{"oid": "385c7d09cc10285847fc03559ad88501bba84f0e", "url": "https://github.com/dogtagpki/jss/commit/385c7d09cc10285847fc03559ad88501bba84f0e", "message": "FIXUP JSSSocketChannel.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-01T00:05:02Z", "type": "forcePushed"}, {"oid": "2203730211840cc3cf2d35ff09722c496debf08b", "url": "https://github.com/dogtagpki/jss/commit/2203730211840cc3cf2d35ff09722c496debf08b", "message": "FIXUP ../org/mozilla/jss/ssl/javax/JSSSocketFactory.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-01T08:58:50Z", "type": "forcePushed"}, {"oid": "34dfcb730433af05c6368572d4ed4a6d8da842ce", "url": "https://github.com/dogtagpki/jss/commit/34dfcb730433af05c6368572d4ed4a6d8da842ce", "message": "FIXUP org/mozilla/jss/provider/javax/net/JSSContextSpi.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-04T14:07:38Z", "type": "forcePushed"}, {"oid": "3d37f279000c29a5f5b890d372fe0598b9a85c98", "url": "https://github.com/dogtagpki/jss/commit/3d37f279000c29a5f5b890d372fe0598b9a85c98", "message": "FIXUP org/mozilla/jss/provider/javax/net/JSSContextSpi.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-04T14:09:40Z", "type": "forcePushed"}, {"oid": "e8860b31031b4c3a9c2f5413d760967a6e988a6e", "url": "https://github.com/dogtagpki/jss/commit/e8860b31031b4c3a9c2f5413d760967a6e988a6e", "message": "Switch to JSS-provided SSL SocketFactories\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-04T16:40:59Z", "type": "forcePushed"}, {"oid": "ed35cf52b0de78a1a52139f9d0455b33913e3bba", "url": "https://github.com/dogtagpki/jss/commit/ed35cf52b0de78a1a52139f9d0455b33913e3bba", "message": "Switch to JSS-provided SSL SocketFactories\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-04T18:16:12Z", "type": "forcePushed"}, {"oid": "82cbc0d7ae3093b76592f8deb910362fe44c4089", "url": "https://github.com/dogtagpki/jss/commit/82cbc0d7ae3093b76592f8deb910362fe44c4089", "message": "Switch to JSS-provided SSL SocketFactories\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-04T19:46:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE4MzA5Ng==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420183096", "bodyText": "Should be Math.min.", "author": "cipherboy", "createdAt": "2020-05-05T15:07:09Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        this.consumed = consumed;\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        if (parent != null && !parent.isBlocking()) {\n+            // If there is a channel, it could be blocking or non-blocking; in\n+            // the non-blocking case, we can safely return the suggested\n+            // amount, but in the blocking case, we still need to bound our\n+            // read.\n+            return suggested;\n+        }\n+\n+        // In both remaining case (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+\n+        int available = parentSocket.getInputStream().available();\n+        return Math.max(suggested, available);", "originalCommit": "82cbc0d7ae3093b76592f8deb910362fe44c4089", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE4MzI0Mw==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420183243", "bodyText": "Again, Math.min", "author": "cipherboy", "createdAt": "2020-05-05T15:07:20Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        this.consumed = consumed;\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        if (parent != null && !parent.isBlocking()) {\n+            // If there is a channel, it could be blocking or non-blocking; in\n+            // the non-blocking case, we can safely return the suggested\n+            // amount, but in the blocking case, we still need to bound our\n+            // read.\n+            return suggested;\n+        }\n+\n+        // In both remaining case (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+\n+        int available = parentSocket.getInputStream().available();\n+        return Math.max(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        // Attempt to handshake with the remote peer.\n+        try {\n+            do {\n+                SSLEngineResult ret;\n+                if (state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                    ByteBuffer src = null;\n+                    ByteBuffer dst = ByteBuffer.allocate(engine.BUFFER_SIZE);\n+\n+                    long sent = 0;\n+                    long encrypted = 0;\n+\n+                    do {\n+                        ret = engine.wrap(src, dst);\n+                        if (ret.getStatus() != SSLEngineResult.Status.OK && ret.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                            throw new IOException(\"Unexpected status from wrap: \" + ret);\n+                        }\n+\n+                        encrypted += ret.bytesProduced();\n+\n+                        int this_write = writeChannel.write(dst);\n+                        sent += this_write;\n+\n+                        if (sent < encrypted && ret.bytesProduced() == 0 && this_write == 0) {\n+                            String msg = \"Error attempting to write to remote \";\n+                            msg += \"peer: calls to wrap or write stalled, \";\n+                            msg += \"consuming and producing no data: sent \";\n+                            msg += sent + \" bytes of \" + encrypted + \" bytes \";\n+                            msg += \"encrypted to remote peer\";\n+                            throw new IOException(msg);\n+                        }\n+                    } while (sent < encrypted);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                    int buffer_size = boundRead(engine.BUFFER_SIZE);\n+                    ByteBuffer src = ByteBuffer.allocate(buffer_size);\n+                    ByteBuffer dst = null;\n+\n+                    int remoteRead = readChannel.read(src);\n+                    if (remoteRead == 0) {\n+                        // Nothing to do; use this to step the unknown state\n+                        // counter and continue.\n+                        state = engine.getHandshakeStatus();\n+                        continue;\n+                    }\n+\n+                    int unwrapped = 0;\n+                    do {\n+                        ret = engine.unwrap(src, dst);\n+                        if (ret.getStatus() != SSLEngineResult.Status.OK && ret.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                            throw new IOException(\"Unexpected status from unwrap: \" + ret);\n+                        }\n+\n+                        unwrapped += ret.bytesConsumed();\n+                        if (unwrapped < remoteRead && ret.bytesConsumed() == 0) {\n+                            String msg = \"Error during handshake: unable to \";\n+                            msg += \"consume some bytes of this handshake \";\n+                            msg += \"message. Consumed: \" + unwrapped;\n+                            msg += \" Total available: \" + remoteRead;\n+                            throw new IOException(msg);\n+                        }\n+                    } while (unwrapped < remoteRead);\n+                } else {\n+                    String msg = \"Error attempting to handshake: unknown \";\n+                    msg += \"handshake status code `\" + state + \"`\";\n+                    throw new IOException(msg);\n+                }\n+\n+                if (ret.getStatus() != SSLEngineResult.Status.OK) {\n+                    String msg = \"Error attempting to handshake: unexpected\";\n+                    msg += \"SSLEngineResult status code: \" + ret.getStatus();\n+                    msg += \" -- \" + ret;\n+                    throw new IOException(msg);\n+                }\n+\n+                state = engine.getHandshakeStatus();\n+            } while (state != SSLEngineResult.HandshakeStatus.FINISHED);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to handshake with remote peer: \";\n+            msg += \"got unexpected exception: \" + ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Compute the total size of a list of buffers from the specified offest\n+     * and length.\n+     */\n+    private static long computeSize(ByteBuffer[] buffers, int offset, int length) throws IOException {\n+        long result = 0;\n+\n+        if (buffers == null || buffers.length == 0) {\n+            return result;\n+        }\n+\n+        for (int rel_index = 0; rel_index < length; rel_index++) {\n+            int index = offset + rel_index;\n+            if (index >= buffers.length) {\n+                String msg = \"Offset (\" + offset + \" or length (\" + length;\n+                msg += \") exceeds contract based on number of buffers \";\n+                msg += \"given (\" + buffers.length + \")\";\n+                throw new IOException(msg);\n+            }\n+\n+            if (buffers[index] != null) {\n+                result += buffers[index].remaining();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public int read(ByteBuffer dst) throws IOException {\n+        return (int) read(new ByteBuffer[] { dst });\n+    }\n+\n+    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (!finishConnect()) {\n+            throw new IOException(\"Unable to finish handshake for an unknown reason.\");\n+        }\n+\n+        long capacity = computeSize(dsts, offset, length);\n+        int buffer_size = boundRead((int) Math.max(capacity, Integer.MAX_VALUE));", "originalCommit": "82cbc0d7ae3093b76592f8deb910362fe44c4089", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE4MzM4NQ==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420183385", "bodyText": "Math.min here as well.", "author": "cipherboy", "createdAt": "2020-05-05T15:07:32Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        this.consumed = consumed;\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        if (parent != null && !parent.isBlocking()) {\n+            // If there is a channel, it could be blocking or non-blocking; in\n+            // the non-blocking case, we can safely return the suggested\n+            // amount, but in the blocking case, we still need to bound our\n+            // read.\n+            return suggested;\n+        }\n+\n+        // In both remaining case (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+\n+        int available = parentSocket.getInputStream().available();\n+        return Math.max(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        // Attempt to handshake with the remote peer.\n+        try {\n+            do {\n+                SSLEngineResult ret;\n+                if (state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                    ByteBuffer src = null;\n+                    ByteBuffer dst = ByteBuffer.allocate(engine.BUFFER_SIZE);\n+\n+                    long sent = 0;\n+                    long encrypted = 0;\n+\n+                    do {\n+                        ret = engine.wrap(src, dst);\n+                        if (ret.getStatus() != SSLEngineResult.Status.OK && ret.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                            throw new IOException(\"Unexpected status from wrap: \" + ret);\n+                        }\n+\n+                        encrypted += ret.bytesProduced();\n+\n+                        int this_write = writeChannel.write(dst);\n+                        sent += this_write;\n+\n+                        if (sent < encrypted && ret.bytesProduced() == 0 && this_write == 0) {\n+                            String msg = \"Error attempting to write to remote \";\n+                            msg += \"peer: calls to wrap or write stalled, \";\n+                            msg += \"consuming and producing no data: sent \";\n+                            msg += sent + \" bytes of \" + encrypted + \" bytes \";\n+                            msg += \"encrypted to remote peer\";\n+                            throw new IOException(msg);\n+                        }\n+                    } while (sent < encrypted);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                    int buffer_size = boundRead(engine.BUFFER_SIZE);\n+                    ByteBuffer src = ByteBuffer.allocate(buffer_size);\n+                    ByteBuffer dst = null;\n+\n+                    int remoteRead = readChannel.read(src);\n+                    if (remoteRead == 0) {\n+                        // Nothing to do; use this to step the unknown state\n+                        // counter and continue.\n+                        state = engine.getHandshakeStatus();\n+                        continue;\n+                    }\n+\n+                    int unwrapped = 0;\n+                    do {\n+                        ret = engine.unwrap(src, dst);\n+                        if (ret.getStatus() != SSLEngineResult.Status.OK && ret.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                            throw new IOException(\"Unexpected status from unwrap: \" + ret);\n+                        }\n+\n+                        unwrapped += ret.bytesConsumed();\n+                        if (unwrapped < remoteRead && ret.bytesConsumed() == 0) {\n+                            String msg = \"Error during handshake: unable to \";\n+                            msg += \"consume some bytes of this handshake \";\n+                            msg += \"message. Consumed: \" + unwrapped;\n+                            msg += \" Total available: \" + remoteRead;\n+                            throw new IOException(msg);\n+                        }\n+                    } while (unwrapped < remoteRead);\n+                } else {\n+                    String msg = \"Error attempting to handshake: unknown \";\n+                    msg += \"handshake status code `\" + state + \"`\";\n+                    throw new IOException(msg);\n+                }\n+\n+                if (ret.getStatus() != SSLEngineResult.Status.OK) {\n+                    String msg = \"Error attempting to handshake: unexpected\";\n+                    msg += \"SSLEngineResult status code: \" + ret.getStatus();\n+                    msg += \" -- \" + ret;\n+                    throw new IOException(msg);\n+                }\n+\n+                state = engine.getHandshakeStatus();\n+            } while (state != SSLEngineResult.HandshakeStatus.FINISHED);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to handshake with remote peer: \";\n+            msg += \"got unexpected exception: \" + ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Compute the total size of a list of buffers from the specified offest\n+     * and length.\n+     */\n+    private static long computeSize(ByteBuffer[] buffers, int offset, int length) throws IOException {\n+        long result = 0;\n+\n+        if (buffers == null || buffers.length == 0) {\n+            return result;\n+        }\n+\n+        for (int rel_index = 0; rel_index < length; rel_index++) {\n+            int index = offset + rel_index;\n+            if (index >= buffers.length) {\n+                String msg = \"Offset (\" + offset + \" or length (\" + length;\n+                msg += \") exceeds contract based on number of buffers \";\n+                msg += \"given (\" + buffers.length + \")\";\n+                throw new IOException(msg);\n+            }\n+\n+            if (buffers[index] != null) {\n+                result += buffers[index].remaining();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public int read(ByteBuffer dst) throws IOException {\n+        return (int) read(new ByteBuffer[] { dst });\n+    }\n+\n+    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (!finishConnect()) {\n+            throw new IOException(\"Unable to finish handshake for an unknown reason.\");\n+        }\n+\n+        long capacity = computeSize(dsts, offset, length);\n+        int buffer_size = boundRead((int) Math.max(capacity, Integer.MAX_VALUE));\n+        ByteBuffer src = ByteBuffer.allocate(buffer_size);\n+\n+        long remoteRead = readChannel.read(src);\n+        if (remoteRead == 0) {\n+            return 0;\n+        }\n+\n+        long unwrapped = 0;\n+        long decrypted = 0;\n+\n+        try {\n+            do {\n+                SSLEngineResult result = engine.unwrap(src, dsts, offset, length);\n+                if (result.getStatus() != SSLEngineResult.Status.OK && result.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                    throw new IOException(\"Unexpected status from unwrap: \" + result);\n+                }\n+\n+                unwrapped += result.bytesConsumed();\n+                decrypted += result.bytesProduced();\n+\n+                if (unwrapped < remoteRead && result.bytesConsumed() == 0 && result.bytesProduced() == 0) {\n+                    String msg = \"Error attempting to read from remote peer: \";\n+                    msg += \"calls to unwrap stalled, consuming and producing \";\n+                    msg += \"no data: unwrapped \" + unwrapped + \" bytes of \";\n+                    msg += remoteRead + \" bytes read from remote peer; got a \";\n+                    msg += \"decrypted size of \" + decrypted + \" bytes.\";\n+                    throw new IOException(msg);\n+                }\n+            } while (unwrapped < remoteRead);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to read from remote peer: \";\n+            msg += \"got unexpected exception during unwrap call: \";\n+            msg += ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        return decrypted;\n+    }\n+\n+    public int write(ByteBuffer src) throws IOException {\n+        return (int) write(new ByteBuffer[] { src });\n+    }\n+\n+    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n+        if (!finishConnect()) {\n+            throw new IOException(\"Unable to finish handshake for an unknown reason.\");\n+        }\n+\n+        long capacity = computeSize(srcs, offset, length);\n+        int buffer_size = boundRead((int) Math.max(capacity, Integer.MAX_VALUE));", "originalCommit": "82cbc0d7ae3093b76592f8deb910362fe44c4089", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3c41f064781ba207a0008323cbc8ad710260eb23", "url": "https://github.com/dogtagpki/jss/commit/3c41f064781ba207a0008323cbc8ad710260eb23", "message": "Allow null src[index] in JSSEngine\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-05T23:05:23Z", "type": "forcePushed"}, {"oid": "7ac6fe7fb45341b9e036dcff2de94ec602c8ae58", "url": "https://github.com/dogtagpki/jss/commit/7ac6fe7fb45341b9e036dcff2de94ec602c8ae58", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-06T12:47:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4MjA2NA==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420782064", "bodyText": "need to call configureBlocking(); otherwise this and the parent channel become out of sync.", "author": "cipherboy", "createdAt": "2020-05-06T13:17:58Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,462 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;", "originalCommit": "7ac6fe7fb45341b9e036dcff2de94ec602c8ae58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f871da0653b989298d521bbf7a377e9f6c75fe4", "url": "https://github.com/dogtagpki/jss/commit/3f871da0653b989298d521bbf7a377e9f6c75fe4", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-06T13:19:42Z", "type": "forcePushed"}, {"oid": "7ee2f29f56f394434ca65cc8f85aa2cc1ffed3fd", "url": "https://github.com/dogtagpki/jss/commit/7ee2f29f56f394434ca65cc8f85aa2cc1ffed3fd", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-06T13:23:10Z", "type": "forcePushed"}, {"oid": "72a7ebd72a8fc7f07a491b36bed6747dc911e14c", "url": "https://github.com/dogtagpki/jss/commit/72a7ebd72a8fc7f07a491b36bed6747dc911e14c", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-06T13:31:00Z", "type": "forcePushed"}, {"oid": "9bb24402c211d609d0f0007fef4b21272be7f4ea", "url": "https://github.com/dogtagpki/jss/commit/9bb24402c211d609d0f0007fef4b21272be7f4ea", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-06T13:40:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyODczMw==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420928733", "bodyText": "Move byte buffers here and make them sized based on engine.getSession().getApplicationBufferSize() rather than the internal constant value. This will reduce the number of allocations we have to do, at the risk of needing to make read/write synchronized around it.", "author": "cipherboy", "createdAt": "2020-05-06T16:32:24Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,465 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+", "originalCommit": "9bb24402c211d609d0f0007fef4b21272be7f4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzMDAyNg==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420930026", "bodyText": "Could also move empty here.", "author": "cipherboy", "createdAt": "2020-05-06T16:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyODczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzMzkwNg==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420933906", "bodyText": "If we switch to per-instance buffers, we can change this call to:\nread_buffer.clear();\nByteBuffer.wrap(read_buffer.array(), 0, buffer_size);", "author": "cipherboy", "createdAt": "2020-05-06T16:40:04Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,465 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;\n+\n+        // Copy the blocking mode from the parent channel.\n+        configureBlocking(parent.isBlocking());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+\n+        // When there is no parent channel, this channel must be in\n+        // blocking mode.\n+        configureBlocking(true);\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        this.consumed = consumed;\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        if (!isBlocking()) {\n+            return suggested;\n+        }\n+\n+        // In both remaining case (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+\n+        int available = parentSocket.getInputStream().available();\n+        return Math.min(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        ByteBuffer empty = ByteBuffer.allocate(0);\n+\n+        int handshakeAttempts = 0;\n+        int maxHandshakeAttempts = 100;\n+\n+        if (!isBlocking()) {\n+            // When we're a non-blocking socket/channel, we'd farther rather\n+            // return false than take too much time in this method.\n+            maxHandshakeAttempts = 10;\n+        }\n+\n+        // Attempt to handshake with the remote peer.\n+        try {\n+            do {\n+                if (state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                    // Write from an empty buffer to wrap.\n+                    write(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                    // Read into an empty buffer to unwrap.\n+                    read(empty);\n+                } else {\n+                    String msg = \"Error attempting to handshake: unknown \";\n+                    msg += \"handshake status code `\" + state + \"`\";\n+                    throw new IOException(msg);\n+                }\n+\n+                SSLEngineResult.HandshakeStatus last_state = state;\n+                state = engine.getHandshakeStatus();\n+                handshakeAttempts += 1;\n+\n+                if (state == last_state) {\n+                    try {\n+                        // This sleep is necessary in order to wait for\n+                        // incoming data. If it turns out our\n+                        // NEED_UNWRAP is premature (and we're stuck in\n+                        // a blocking read() call because we issued a\n+                        // non-zero read!), we might cause the remote\n+                        // peer to timeout and send a CLOSE_NOTIFY\n+                        // alert. This wouldn't be good, so sleep\n+                        // instead. Use an exponential backoff in case\n+                        // the remote server is really slow.\n+                        Thread.sleep(handshakeAttempts * 10);\n+                    } catch (Exception e) {}\n+                }\n+\n+                if (handshakeAttempts > maxHandshakeAttempts) {\n+                    if (!isBlocking()) {\n+                        // In the event we failed to connect under a\n+                        // non-blocking socket, return false rather than fail\n+                        // here. It could just be that we don't have enough\n+                        // data to continue. In that case, doHandshake() in\n+                        // JSSSocket will re-try until the connection succeeds.\n+                        return false;\n+                    }\n+\n+                    String msg = \"Error attempting to handshake: unable to \";\n+                    msg += \"complete handshake successfully in \";\n+                    msg += maxHandshakeAttempts + \" calls to wrap or unwrap. \";\n+                    msg += \"Connection stalled.\";\n+                    throw new IOException(msg);\n+                }\n+            } while (state != SSLEngineResult.HandshakeStatus.FINISHED && state != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to handshake with remote peer: \";\n+            msg += \"got unexpected exception: \" + ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        sslSocket.notifyHandshakeCompletedListeners();\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Compute the total size of a list of buffers from the specified offest\n+     * and length.\n+     */\n+    private static long computeSize(ByteBuffer[] buffers, int offset, int length) throws IOException {\n+        long result = 0;\n+\n+        if (buffers == null || buffers.length == 0) {\n+            return result;\n+        }\n+\n+        for (int rel_index = 0; rel_index < length; rel_index++) {\n+            int index = offset + rel_index;\n+            if (index >= buffers.length) {\n+                String msg = \"Offset (\" + offset + \" or length (\" + length;\n+                msg += \") exceeds contract based on number of buffers \";\n+                msg += \"given (\" + buffers.length + \")\";\n+                throw new IOException(msg);\n+            }\n+\n+            if (buffers[index] != null) {\n+                result += buffers[index].remaining();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public int read(ByteBuffer dst) throws IOException {\n+        return (int) read(new ByteBuffer[] { dst });\n+    }\n+\n+    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (inboundClosed) {\n+            return -1;\n+        }\n+\n+        int buffer_size = boundRead(JSSEngine.BUFFER_SIZE);\n+        ByteBuffer src = ByteBuffer.allocate(buffer_size);", "originalCommit": "9bb24402c211d609d0f0007fef4b21272be7f4ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODU3NA==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420938574", "bodyText": "@edewata Should we move this inside the loop below? In particular, if we read a non-zero amount and then unwrap it all, we could retry the read and potentially get more data. Thoughts?\nNote that we'd have to handle the case where the consumed has data left, but we don't currently handle that either way.\nIt'd make the read() code look more like write() though.\nThoughts?", "author": "cipherboy", "createdAt": "2020-05-06T16:47:17Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,465 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;\n+\n+        // Copy the blocking mode from the parent channel.\n+        configureBlocking(parent.isBlocking());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+\n+        // When there is no parent channel, this channel must be in\n+        // blocking mode.\n+        configureBlocking(true);\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        this.consumed = consumed;\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        if (!isBlocking()) {\n+            return suggested;\n+        }\n+\n+        // In both remaining case (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+\n+        int available = parentSocket.getInputStream().available();\n+        return Math.min(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        ByteBuffer empty = ByteBuffer.allocate(0);\n+\n+        int handshakeAttempts = 0;\n+        int maxHandshakeAttempts = 100;\n+\n+        if (!isBlocking()) {\n+            // When we're a non-blocking socket/channel, we'd farther rather\n+            // return false than take too much time in this method.\n+            maxHandshakeAttempts = 10;\n+        }\n+\n+        // Attempt to handshake with the remote peer.\n+        try {\n+            do {\n+                if (state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                    // Write from an empty buffer to wrap.\n+                    write(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                    // Read into an empty buffer to unwrap.\n+                    read(empty);\n+                } else {\n+                    String msg = \"Error attempting to handshake: unknown \";\n+                    msg += \"handshake status code `\" + state + \"`\";\n+                    throw new IOException(msg);\n+                }\n+\n+                SSLEngineResult.HandshakeStatus last_state = state;\n+                state = engine.getHandshakeStatus();\n+                handshakeAttempts += 1;\n+\n+                if (state == last_state) {\n+                    try {\n+                        // This sleep is necessary in order to wait for\n+                        // incoming data. If it turns out our\n+                        // NEED_UNWRAP is premature (and we're stuck in\n+                        // a blocking read() call because we issued a\n+                        // non-zero read!), we might cause the remote\n+                        // peer to timeout and send a CLOSE_NOTIFY\n+                        // alert. This wouldn't be good, so sleep\n+                        // instead. Use an exponential backoff in case\n+                        // the remote server is really slow.\n+                        Thread.sleep(handshakeAttempts * 10);\n+                    } catch (Exception e) {}\n+                }\n+\n+                if (handshakeAttempts > maxHandshakeAttempts) {\n+                    if (!isBlocking()) {\n+                        // In the event we failed to connect under a\n+                        // non-blocking socket, return false rather than fail\n+                        // here. It could just be that we don't have enough\n+                        // data to continue. In that case, doHandshake() in\n+                        // JSSSocket will re-try until the connection succeeds.\n+                        return false;\n+                    }\n+\n+                    String msg = \"Error attempting to handshake: unable to \";\n+                    msg += \"complete handshake successfully in \";\n+                    msg += maxHandshakeAttempts + \" calls to wrap or unwrap. \";\n+                    msg += \"Connection stalled.\";\n+                    throw new IOException(msg);\n+                }\n+            } while (state != SSLEngineResult.HandshakeStatus.FINISHED && state != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to handshake with remote peer: \";\n+            msg += \"got unexpected exception: \" + ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        sslSocket.notifyHandshakeCompletedListeners();\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Compute the total size of a list of buffers from the specified offest\n+     * and length.\n+     */\n+    private static long computeSize(ByteBuffer[] buffers, int offset, int length) throws IOException {\n+        long result = 0;\n+\n+        if (buffers == null || buffers.length == 0) {\n+            return result;\n+        }\n+\n+        for (int rel_index = 0; rel_index < length; rel_index++) {\n+            int index = offset + rel_index;\n+            if (index >= buffers.length) {\n+                String msg = \"Offset (\" + offset + \" or length (\" + length;\n+                msg += \") exceeds contract based on number of buffers \";\n+                msg += \"given (\" + buffers.length + \")\";\n+                throw new IOException(msg);\n+            }\n+\n+            if (buffers[index] != null) {\n+                result += buffers[index].remaining();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public int read(ByteBuffer dst) throws IOException {\n+        return (int) read(new ByteBuffer[] { dst });\n+    }\n+\n+    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (inboundClosed) {\n+            return -1;\n+        }\n+\n+        int buffer_size = boundRead(JSSEngine.BUFFER_SIZE);\n+        ByteBuffer src = ByteBuffer.allocate(buffer_size);\n+\n+        long remoteRead = readChannel.read(src);", "originalCommit": "9bb24402c211d609d0f0007fef4b21272be7f4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0NjA1Mw==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420946053", "bodyText": "In particular, to get consumed to work, we replace readChannel with  Channels.newChannel(consumed) and that'll give us something we can .read(src) into -- we just need to make sure to check consumed.available and limit the size of buffer_size above appropriately.", "author": "cipherboy", "createdAt": "2020-05-06T16:58:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMzIxMg==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421003212", "bodyText": "I've gotten consumed to work but I haven't moved the read inside the thing as it'd involve resizing the src buffer afterwards.", "author": "cipherboy", "createdAt": "2020-05-06T18:29:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODU3NA=="}], "type": "inlineReview"}, {"oid": "defd123758ba3b850d09b5bf095f70c586f48a39", "url": "https://github.com/dogtagpki/jss/commit/defd123758ba3b850d09b5bf095f70c586f48a39", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-06T18:27:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4MTM4OQ==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r419781389", "bodyText": "How is long boundRead(long) going to be used? So far I only see int boundRead(int) in line 248.", "author": "edewata", "createdAt": "2020-05-04T23:11:10Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        this.consumed = consumed;\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {", "originalCommit": "cb1f6bb0e94acecd3c025a263f43a13fb1351fa6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU1NTc3OA==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421555778", "bodyText": "Ah sorry. This is where I dislike SSLEngine vs SSLSocket vs SocketChannel semantics here: SSLEngine takes an int of ByteBuffers (each with a size in int) -- which means the total size would only fit in a long, not int -- but is only allowed to return an int worth of write data.\nSocketChannel, on the other hand, recognizes this and allows the result to fit in a long.\nI was going back and forth over how this was implemented (and where all I'd place this call), and I think I can remove the long version.", "author": "cipherboy", "createdAt": "2020-05-07T14:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4MTM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzMjkxMg==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420932912", "bodyText": "This code will catch generic exceptions, so probably the exception message should be a bit more generic as well, for example:\nString msg = \"Unable to create JSSContext: \" + e.getMessage()", "author": "edewata", "createdAt": "2020-05-06T16:38:39Z", "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -0,0 +1,869 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+import org.mozilla.jss.pkcs11.PK11Cert;\n+import org.mozilla.jss.pkcs11.PK11PrivKey;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSTrustManager;\n+\n+/**\n+ * SSL-enabled socket following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * Most users will want to use the JSSSocketFactory provided by the Java\n+ * Provider interface instead of using this class directly.\n+ *\n+ * This SSLSocket implementation is a wrapped implementation. In particular, we\n+ * need to consume an existing Socket (via the consumeSocket(...) call) which\n+ * we actually send data over. When called from a socket factory, this\n+ * additional socket will be automatically created for the caller. This\n+ * is necessary because SSLSocketFactory includes a mode which wraps an\n+ * existing socket.\n+ *\n+ * All JSSSocket instances have a underlying SocketChannel, of type\n+ * JSSSocketChannel. Notably lacking is a javax.net.ssl.SSLSocketChannel type,\n+ * so JSSSocketChannel includes no additional SSL-specific options. However,\n+ * the core of the SSLEngine wrapping logic exists there.\n+ *\n+ * In order to interoperate with JSSEngine, many of the adjacent methods have\n+ * been included in this class as well.\n+ *\n+ * This socket can either be a client or a server, depending on how it was\n+ * created. For more information, see the javax.net.ssl.SSLSocket\n+ * documentation.\n+ *\n+ * To construct a (useful) new instance, the following calls must be made:\n+ *\n+ * - new JSSSocket();\n+ * - consumeSocket(inst);\n+ * - initSSLEngine(...);\n+ * - setKeyManagers(...);\n+ * - setTrustManagers(...);\n+ *\n+ * Optionally, setSSLContext(...) could be called to provide the SSLContext\n+ * from which the SSLEngine should be constructed. This should be called prior\n+ * to initSSLEngine(...) being called.\n+ */\n+public class JSSSocket extends SSLSocket {\n+    /**\n+     * Name of the SSLEngine protocol to use.\n+     */\n+    private String engineProviderProtocol = \"TLS\";\n+\n+    /**\n+     * Name of the SSLEngine provider to use.\n+     */\n+    private String engineProvider = \"Mozilla-JSS\";\n+\n+    /**\n+     * SSLContext to use to create the JSSEngine. Note that JSSSocket will fail\n+     * if the context doesn't create JSSEngine instances.\n+     */\n+    private SSLContext jssContext;\n+\n+    /**\n+     * JSSEngine instance to utilize for SSLEngine operations.\n+     */\n+    private JSSEngine engine;\n+\n+    /**\n+     * All registered handshake callbacks.\n+     */\n+    private ArrayList<HandshakeCompletedListener> handshakeCallbacks = new ArrayList<HandshakeCompletedListener>();\n+\n+    /**\n+     * The socket this JSSSocket was created over; all read/write operations\n+     * go through this socket and all information exposed via Socket members\n+     * go through here.\n+     */\n+    private Socket parent;\n+\n+    /**\n+     * Previously consumed data, if any; utilized for certain SSLSocketFactory\n+     * calls.\n+     */\n+    private InputStream consumedData;\n+\n+    /**\n+     * Underlying SocketChannel for this socket; always exists.\n+     */\n+    private JSSSocketChannel channel;\n+\n+    /**\n+     * Whether or not to automatically close the underlying Socket when this\n+     * socket has been closed; defaults to true.\n+     */\n+    private boolean autoClose = true;\n+\n+    /**\n+     * Start building a new JSSSocket.\n+     *\n+     * We specifically avoid creating any other constructors as we wish to\n+     * consume an existing socket rather than creating a new one.\n+     */\n+    public JSSSocket() {}\n+\n+    /**\n+     * Consume a parent socket, utilizing it for all read/write operations.\n+     *\n+     * This JSSSocket instance will inherit all information about the\n+     * connection from this underlying socket. When utilized in a JSSSocket,\n+     * callers should refrain from interacting with the underlying socket\n+     * directly until the TLS connection is closed. Otherwise, messages may\n+     * get dropped.\n+     */\n+    public void consumeSocket(Socket parent) throws IOException {\n+        if (parent == null) {\n+            String msg = \"Unable to consume and utilize null parent socket!\";\n+            throw new IOException(msg);\n+        }\n+\n+        this.parent = parent;\n+    }\n+\n+    /**\n+     * Get the SSLContext if one exists or create a new instance.\n+     *\n+     * This is used by initSSLEngine(..) to create the underlying SSLEngine.\n+     */\n+    protected SSLContext getSSLContext() throws IOException {\n+        if (jssContext == null) {\n+            try {\n+                jssContext = SSLContext.getInstance(engineProviderProtocol, engineProvider);\n+            } catch (Exception e) {\n+                String msg = \"Unable to create JSSSocket prior to Mozilla-JSS \";\n+                msg += \"initialization! \" + e.getMessage();", "originalCommit": "9bb24402c211d609d0f0007fef4b21272be7f4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU2MDM0Ng==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421560346", "bodyText": "I ended up not really using this part of this method. There's two issues with it:\n\nWe have no real way of initializing a JSSContext is one doesn't exist,\nWe have no other way of creating SSLEngine's.\n\nThe problem is that, if we don't pass an explicit SSLContext instance (backed by our JSSContextSpi), we need to initialize it somehow. That means divining KeyManagers and TrustManagers to use.\nSince we have a split JSSEngine interface/implementation (and JSSContextSpi currently controls which implementation gets selected -- where currently JSSEngineReferenceImpl is the only one available), we need some context to use here.\nWhen we construct a JSSSocketFactory from within JSSContextSpi we additionally don't have a way of accessing the parent SSLContext of this JSSContextSpi either! So we end up creating a new one! We could perhaps use the SSLContext(SSLContextSpi, String, String) constructor though... but we'd need to divine the protocol parameter still....\nThoughts for avoiding this problem definitely appreciated. :-)\n\n(To clarify, by not using, I mean, getContext() is still called of course, but I always explicitly call setContext within SSLSocketFactory).", "author": "cipherboy", "createdAt": "2020-05-07T14:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzMjkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwNzYzNQ==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421107635", "bodyText": "IIUC the current code uses a linear backoff with a maximum sleep of 2.5 seconds and total wait time of 32.5 seconds. Is that the intention, or should we use something like this?\nint connectAttempts = 1;\nwhile (!status) {\n    connectAttempts *= 2;\n}", "author": "edewata", "createdAt": "2020-05-06T21:37:22Z", "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -0,0 +1,869 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+import org.mozilla.jss.pkcs11.PK11Cert;\n+import org.mozilla.jss.pkcs11.PK11PrivKey;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSTrustManager;\n+\n+/**\n+ * SSL-enabled socket following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * Most users will want to use the JSSSocketFactory provided by the Java\n+ * Provider interface instead of using this class directly.\n+ *\n+ * This SSLSocket implementation is a wrapped implementation. In particular, we\n+ * need to consume an existing Socket (via the consumeSocket(...) call) which\n+ * we actually send data over. When called from a socket factory, this\n+ * additional socket will be automatically created for the caller. This\n+ * is necessary because SSLSocketFactory includes a mode which wraps an\n+ * existing socket.\n+ *\n+ * All JSSSocket instances have a underlying SocketChannel, of type\n+ * JSSSocketChannel. Notably lacking is a javax.net.ssl.SSLSocketChannel type,\n+ * so JSSSocketChannel includes no additional SSL-specific options. However,\n+ * the core of the SSLEngine wrapping logic exists there.\n+ *\n+ * In order to interoperate with JSSEngine, many of the adjacent methods have\n+ * been included in this class as well.\n+ *\n+ * This socket can either be a client or a server, depending on how it was\n+ * created. For more information, see the javax.net.ssl.SSLSocket\n+ * documentation.\n+ *\n+ * To construct a (useful) new instance, the following calls must be made:\n+ *\n+ * - new JSSSocket();\n+ * - consumeSocket(inst);\n+ * - initSSLEngine(...);\n+ * - setKeyManagers(...);\n+ * - setTrustManagers(...);\n+ *\n+ * Optionally, setSSLContext(...) could be called to provide the SSLContext\n+ * from which the SSLEngine should be constructed. This should be called prior\n+ * to initSSLEngine(...) being called.\n+ */\n+public class JSSSocket extends SSLSocket {\n+    /**\n+     * Name of the SSLEngine protocol to use.\n+     */\n+    private String engineProviderProtocol = \"TLS\";\n+\n+    /**\n+     * Name of the SSLEngine provider to use.\n+     */\n+    private String engineProvider = \"Mozilla-JSS\";\n+\n+    /**\n+     * SSLContext to use to create the JSSEngine. Note that JSSSocket will fail\n+     * if the context doesn't create JSSEngine instances.\n+     */\n+    private SSLContext jssContext;\n+\n+    /**\n+     * JSSEngine instance to utilize for SSLEngine operations.\n+     */\n+    private JSSEngine engine;\n+\n+    /**\n+     * All registered handshake callbacks.\n+     */\n+    private ArrayList<HandshakeCompletedListener> handshakeCallbacks = new ArrayList<HandshakeCompletedListener>();\n+\n+    /**\n+     * The socket this JSSSocket was created over; all read/write operations\n+     * go through this socket and all information exposed via Socket members\n+     * go through here.\n+     */\n+    private Socket parent;\n+\n+    /**\n+     * Previously consumed data, if any; utilized for certain SSLSocketFactory\n+     * calls.\n+     */\n+    private InputStream consumedData;\n+\n+    /**\n+     * Underlying SocketChannel for this socket; always exists.\n+     */\n+    private JSSSocketChannel channel;\n+\n+    /**\n+     * Whether or not to automatically close the underlying Socket when this\n+     * socket has been closed; defaults to true.\n+     */\n+    private boolean autoClose = true;\n+\n+    /**\n+     * Start building a new JSSSocket.\n+     *\n+     * We specifically avoid creating any other constructors as we wish to\n+     * consume an existing socket rather than creating a new one.\n+     */\n+    public JSSSocket() {}\n+\n+    /**\n+     * Consume a parent socket, utilizing it for all read/write operations.\n+     *\n+     * This JSSSocket instance will inherit all information about the\n+     * connection from this underlying socket. When utilized in a JSSSocket,\n+     * callers should refrain from interacting with the underlying socket\n+     * directly until the TLS connection is closed. Otherwise, messages may\n+     * get dropped.\n+     */\n+    public void consumeSocket(Socket parent) throws IOException {\n+        if (parent == null) {\n+            String msg = \"Unable to consume and utilize null parent socket!\";\n+            throw new IOException(msg);\n+        }\n+\n+        this.parent = parent;\n+    }\n+\n+    /**\n+     * Get the SSLContext if one exists or create a new instance.\n+     *\n+     * This is used by initSSLEngine(..) to create the underlying SSLEngine.\n+     */\n+    protected SSLContext getSSLContext() throws IOException {\n+        if (jssContext == null) {\n+            try {\n+                jssContext = SSLContext.getInstance(engineProviderProtocol, engineProvider);\n+            } catch (Exception e) {\n+                String msg = \"Unable to create JSSSocket prior to Mozilla-JSS \";\n+                msg += \"initialization! \" + e.getMessage();\n+                throw new IOException(msg, e);\n+            }\n+        }\n+\n+        return jssContext;\n+    }\n+\n+    /**\n+     * Explicitly set the SSLContext utilized by this JSSSocket instance.\n+     *\n+     * This enables JSSServerSocket to copy its SSLContext over to the accepted\n+     * JSSSocket.\n+     */\n+    public void setSSLContext(SSLContext ctx) throws IOException {\n+        jssContext = ctx;\n+    }\n+\n+    /**\n+     * Initialize the underlying SocketChannel.\n+     */\n+    private void init() throws IOException {\n+        if (engine == null) {\n+            initEngine();\n+        }\n+\n+        SocketChannel parentChannel = parent.getChannel();\n+\n+        if (parentChannel == null) {\n+            ReadableByteChannel read = Channels.newChannel(parent.getInputStream());\n+            WritableByteChannel write = Channels.newChannel(parent.getOutputStream());\n+\n+            channel = new JSSSocketChannel(this, parent, read, write, engine);\n+        } else {\n+            channel = new JSSSocketChannel(this, parentChannel, engine);\n+        }\n+\n+        channel.setConsumedData(consumedData);\n+        channel.setAutoClose(autoClose);\n+    }\n+\n+    /**\n+     * Explicitly initialize the SSLEngine with no session resumption\n+     * information.\n+     */\n+    public void initEngine() throws IOException {\n+        engine = (JSSEngine) getSSLContext().createSSLEngine();\n+    }\n+\n+    /**\n+     * Explicitly initialize the SSLEngine with information for session\n+     * resumption, including peer's hostname and port.\n+     */\n+    public void initEngine(String host, int port) throws IOException {\n+        engine = (JSSEngine) getSSLContext().createSSLEngine(host, port);\n+    }\n+\n+    /**\n+     * Get the underlying JSSEngine instance.\n+     *\n+     * Note that, just like accessing the underlying Socket instance while the\n+     * JSSSocket instance is still open is dangerous, performing other TLS\n+     * operations directly via JSSEngine is also dangerous. This is mostly\n+     * exposed to enable advanced configuration of the JSSEngine that isn't\n+     * otherwise allowed by JSSSocket, and to facilitate the accept() method\n+     * on JSSServerSocket.\n+     */\n+    public JSSEngine getEngine() {\n+        return engine;\n+    }\n+\n+    /**\n+     * Get the underlying SocketChannel for this Socket.\n+     *\n+     * @see java.net.Socket#getChannel()\n+     */\n+    public JSSSocketChannel getChannel() {\n+        if (channel == null) {\n+            try {\n+                init();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Unexpected error trying to construct channel: \" + e.getMessage(), e);\n+            }\n+        }\n+\n+        return channel;\n+    }\n+\n+    /**\n+     * Get a copy of an input stream for this Socket.\n+     *\n+     * @see java.net.Socket#getInputStream()\n+     */\n+    public InputStream getInputStream() throws IOException {\n+        if (channel == null) {\n+            init();\n+        }\n+\n+        return Channels.newInputStream(channel);\n+    }\n+\n+    /**\n+     * Get a copy of an output stream for this Socket.\n+     *\n+     * @see java.net.Socket#getOutputStream()\n+     */\n+    public OutputStream getOutputStream() throws IOException {\n+        if (channel == null) {\n+            init();\n+        }\n+\n+        return Channels.newOutputStream(channel);\n+    }\n+\n+    /**\n+     * Internal helper to perform the handshake operation, blocking.\n+     *\n+     * Note that JSSSocket doesn't invoke JSSEngine.wrap/unwrap directly;\n+     * instead everything is contained within JSSSocketChannel.\n+     */\n+    private void doHandshake() throws IOException {\n+        if (channel == null) {\n+            init();\n+        }\n+\n+        boolean status = channel.finishConnect();\n+        if (!channel.isBlocking()) {\n+            // SSLSocket semantics explicitly say:\n+            //     > This method is synchronous for the initial handshake on\n+            //     > a connection and returns when the negotiated handshake is\n+            //     > complete.\n+            // so we have to block until the connection is complete. But use an\n+            // exponential backoff so we have a chance of catching any peer\n+            // data.", "originalCommit": "defd123758ba3b850d09b5bf095f70c586f48a39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU2MTQyMA==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421561420", "bodyText": "Sorry, linear was the intention.", "author": "cipherboy", "createdAt": "2020-05-07T14:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwNzYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwOTQzNw==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421109437", "bodyText": "The event seems to be generally read-only, so we might be able to reuse a single event object for all callbacks.", "author": "edewata", "createdAt": "2020-05-06T21:41:25Z", "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -0,0 +1,869 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+import org.mozilla.jss.pkcs11.PK11Cert;\n+import org.mozilla.jss.pkcs11.PK11PrivKey;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSTrustManager;\n+\n+/**\n+ * SSL-enabled socket following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * Most users will want to use the JSSSocketFactory provided by the Java\n+ * Provider interface instead of using this class directly.\n+ *\n+ * This SSLSocket implementation is a wrapped implementation. In particular, we\n+ * need to consume an existing Socket (via the consumeSocket(...) call) which\n+ * we actually send data over. When called from a socket factory, this\n+ * additional socket will be automatically created for the caller. This\n+ * is necessary because SSLSocketFactory includes a mode which wraps an\n+ * existing socket.\n+ *\n+ * All JSSSocket instances have a underlying SocketChannel, of type\n+ * JSSSocketChannel. Notably lacking is a javax.net.ssl.SSLSocketChannel type,\n+ * so JSSSocketChannel includes no additional SSL-specific options. However,\n+ * the core of the SSLEngine wrapping logic exists there.\n+ *\n+ * In order to interoperate with JSSEngine, many of the adjacent methods have\n+ * been included in this class as well.\n+ *\n+ * This socket can either be a client or a server, depending on how it was\n+ * created. For more information, see the javax.net.ssl.SSLSocket\n+ * documentation.\n+ *\n+ * To construct a (useful) new instance, the following calls must be made:\n+ *\n+ * - new JSSSocket();\n+ * - consumeSocket(inst);\n+ * - initSSLEngine(...);\n+ * - setKeyManagers(...);\n+ * - setTrustManagers(...);\n+ *\n+ * Optionally, setSSLContext(...) could be called to provide the SSLContext\n+ * from which the SSLEngine should be constructed. This should be called prior\n+ * to initSSLEngine(...) being called.\n+ */\n+public class JSSSocket extends SSLSocket {\n+    /**\n+     * Name of the SSLEngine protocol to use.\n+     */\n+    private String engineProviderProtocol = \"TLS\";\n+\n+    /**\n+     * Name of the SSLEngine provider to use.\n+     */\n+    private String engineProvider = \"Mozilla-JSS\";\n+\n+    /**\n+     * SSLContext to use to create the JSSEngine. Note that JSSSocket will fail\n+     * if the context doesn't create JSSEngine instances.\n+     */\n+    private SSLContext jssContext;\n+\n+    /**\n+     * JSSEngine instance to utilize for SSLEngine operations.\n+     */\n+    private JSSEngine engine;\n+\n+    /**\n+     * All registered handshake callbacks.\n+     */\n+    private ArrayList<HandshakeCompletedListener> handshakeCallbacks = new ArrayList<HandshakeCompletedListener>();\n+\n+    /**\n+     * The socket this JSSSocket was created over; all read/write operations\n+     * go through this socket and all information exposed via Socket members\n+     * go through here.\n+     */\n+    private Socket parent;\n+\n+    /**\n+     * Previously consumed data, if any; utilized for certain SSLSocketFactory\n+     * calls.\n+     */\n+    private InputStream consumedData;\n+\n+    /**\n+     * Underlying SocketChannel for this socket; always exists.\n+     */\n+    private JSSSocketChannel channel;\n+\n+    /**\n+     * Whether or not to automatically close the underlying Socket when this\n+     * socket has been closed; defaults to true.\n+     */\n+    private boolean autoClose = true;\n+\n+    /**\n+     * Start building a new JSSSocket.\n+     *\n+     * We specifically avoid creating any other constructors as we wish to\n+     * consume an existing socket rather than creating a new one.\n+     */\n+    public JSSSocket() {}\n+\n+    /**\n+     * Consume a parent socket, utilizing it for all read/write operations.\n+     *\n+     * This JSSSocket instance will inherit all information about the\n+     * connection from this underlying socket. When utilized in a JSSSocket,\n+     * callers should refrain from interacting with the underlying socket\n+     * directly until the TLS connection is closed. Otherwise, messages may\n+     * get dropped.\n+     */\n+    public void consumeSocket(Socket parent) throws IOException {\n+        if (parent == null) {\n+            String msg = \"Unable to consume and utilize null parent socket!\";\n+            throw new IOException(msg);\n+        }\n+\n+        this.parent = parent;\n+    }\n+\n+    /**\n+     * Get the SSLContext if one exists or create a new instance.\n+     *\n+     * This is used by initSSLEngine(..) to create the underlying SSLEngine.\n+     */\n+    protected SSLContext getSSLContext() throws IOException {\n+        if (jssContext == null) {\n+            try {\n+                jssContext = SSLContext.getInstance(engineProviderProtocol, engineProvider);\n+            } catch (Exception e) {\n+                String msg = \"Unable to create JSSSocket prior to Mozilla-JSS \";\n+                msg += \"initialization! \" + e.getMessage();\n+                throw new IOException(msg, e);\n+            }\n+        }\n+\n+        return jssContext;\n+    }\n+\n+    /**\n+     * Explicitly set the SSLContext utilized by this JSSSocket instance.\n+     *\n+     * This enables JSSServerSocket to copy its SSLContext over to the accepted\n+     * JSSSocket.\n+     */\n+    public void setSSLContext(SSLContext ctx) throws IOException {\n+        jssContext = ctx;\n+    }\n+\n+    /**\n+     * Initialize the underlying SocketChannel.\n+     */\n+    private void init() throws IOException {\n+        if (engine == null) {\n+            initEngine();\n+        }\n+\n+        SocketChannel parentChannel = parent.getChannel();\n+\n+        if (parentChannel == null) {\n+            ReadableByteChannel read = Channels.newChannel(parent.getInputStream());\n+            WritableByteChannel write = Channels.newChannel(parent.getOutputStream());\n+\n+            channel = new JSSSocketChannel(this, parent, read, write, engine);\n+        } else {\n+            channel = new JSSSocketChannel(this, parentChannel, engine);\n+        }\n+\n+        channel.setConsumedData(consumedData);\n+        channel.setAutoClose(autoClose);\n+    }\n+\n+    /**\n+     * Explicitly initialize the SSLEngine with no session resumption\n+     * information.\n+     */\n+    public void initEngine() throws IOException {\n+        engine = (JSSEngine) getSSLContext().createSSLEngine();\n+    }\n+\n+    /**\n+     * Explicitly initialize the SSLEngine with information for session\n+     * resumption, including peer's hostname and port.\n+     */\n+    public void initEngine(String host, int port) throws IOException {\n+        engine = (JSSEngine) getSSLContext().createSSLEngine(host, port);\n+    }\n+\n+    /**\n+     * Get the underlying JSSEngine instance.\n+     *\n+     * Note that, just like accessing the underlying Socket instance while the\n+     * JSSSocket instance is still open is dangerous, performing other TLS\n+     * operations directly via JSSEngine is also dangerous. This is mostly\n+     * exposed to enable advanced configuration of the JSSEngine that isn't\n+     * otherwise allowed by JSSSocket, and to facilitate the accept() method\n+     * on JSSServerSocket.\n+     */\n+    public JSSEngine getEngine() {\n+        return engine;\n+    }\n+\n+    /**\n+     * Get the underlying SocketChannel for this Socket.\n+     *\n+     * @see java.net.Socket#getChannel()\n+     */\n+    public JSSSocketChannel getChannel() {\n+        if (channel == null) {\n+            try {\n+                init();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Unexpected error trying to construct channel: \" + e.getMessage(), e);\n+            }\n+        }\n+\n+        return channel;\n+    }\n+\n+    /**\n+     * Get a copy of an input stream for this Socket.\n+     *\n+     * @see java.net.Socket#getInputStream()\n+     */\n+    public InputStream getInputStream() throws IOException {\n+        if (channel == null) {\n+            init();\n+        }\n+\n+        return Channels.newInputStream(channel);\n+    }\n+\n+    /**\n+     * Get a copy of an output stream for this Socket.\n+     *\n+     * @see java.net.Socket#getOutputStream()\n+     */\n+    public OutputStream getOutputStream() throws IOException {\n+        if (channel == null) {\n+            init();\n+        }\n+\n+        return Channels.newOutputStream(channel);\n+    }\n+\n+    /**\n+     * Internal helper to perform the handshake operation, blocking.\n+     *\n+     * Note that JSSSocket doesn't invoke JSSEngine.wrap/unwrap directly;\n+     * instead everything is contained within JSSSocketChannel.\n+     */\n+    private void doHandshake() throws IOException {\n+        if (channel == null) {\n+            init();\n+        }\n+\n+        boolean status = channel.finishConnect();\n+        if (!channel.isBlocking()) {\n+            // SSLSocket semantics explicitly say:\n+            //     > This method is synchronous for the initial handshake on\n+            //     > a connection and returns when the negotiated handshake is\n+            //     > complete.\n+            // so we have to block until the connection is complete. But use an\n+            // exponential backoff so we have a chance of catching any peer\n+            // data.\n+            int connectAttempts = 0;\n+            while (!status) {\n+                status = channel.finishConnect();\n+\n+                try {\n+                    Thread.sleep(connectAttempts * 100);\n+                } catch (Exception e) {}\n+\n+                connectAttempts += 1;\n+                if (connectAttempts > 25) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (!status) {\n+            throw new IOException(\"Unable to finish handshake for an unknown reason.\");\n+        }\n+    }\n+\n+    /**\n+     * Helper to inform this socket of data already consumed from the wrapped\n+     * socket.\n+     *\n+     * This is provided to facilitate a SSLSocketFactory call which allows\n+     * construction of SSLSocket instances from a non-SSL ServerSocket,\n+     * allowing the application to check SNI information directly.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        consumedData = consumed;\n+    }\n+\n+    /**\n+     * Get the autoClose status of this socket, that is, whether or not its\n+     * parent socket will be automatically closed.\n+     */\n+    public boolean getAutoClose() {\n+        return autoClose;\n+    }\n+\n+    /**\n+     * Set the autoClose status of this socket, that is, whether or not its\n+     * parent socket will be automatically closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+\n+        // When the channel already exists, we need to propagate the status\n+        // to the channel as that actually handles closing this socket.\n+        if (channel != null) {\n+            channel.setAutoClose(on);\n+        }\n+    }\n+\n+    /* == stubs over JSSEngine == */\n+\n+    /**\n+     * Set the hostname this client socket is connecting to, for HTTPS TLS\n+     * certificate validation purposes.\n+     *\n+     * @see JSSEngine#setHostname(String)\n+     */\n+    public void setHostname(String name) {\n+        engine.setHostname(name);\n+    }\n+\n+    /**\n+     * Set the certificate this SSLSocket will utilize from an alias in the\n+     * NSS DB.\n+     *\n+     * @see JSSEngine#setCertFromAlias(String)\n+     */\n+    public void setCertFromAlias(String alias) throws IllegalArgumentException {\n+        engine.setCertFromAlias(alias);\n+    }\n+\n+    /**\n+     * Set the certificate this SSLSocket will utilize from a certificate and\n+     * its matching private key.\n+     *\n+     * @see JSSEngine#setKeyMaterials(PK11Cert, PK11PrivKey)\n+     */\n+    public void setKeyMaterials(PK11Cert our_cert, PK11PrivKey our_key) throws IllegalArgumentException {\n+        engine.setKeyMaterials(our_cert, our_key);\n+    }\n+\n+    /**\n+     * Set the KeyManager this SSLSocket will utilize to select a key.\n+     *\n+     * @see JSSEngine#setKeyManager(X509KeyManager)\n+     */\n+    public void setKeyManager(X509KeyManager km) {\n+        engine.setKeyManager(km);\n+    }\n+\n+    /**\n+     * Set the key managers this SSLSocket will utilize to select a key.\n+     *\n+     * @see JSSEngine#setKeyManagers(X509KeyManager[])\n+     */\n+    public void setKeyManagers(X509KeyManager[] xkms) {\n+        engine.setKeyManagers(xkms);\n+    }\n+\n+    /**\n+     * Set the trust manager this SSLSocket will utilize to validate a peer's\n+     * certificate.\n+     *\n+     * @see JSSEngine#setTrustManager(JSSTrustManager)\n+     */\n+    public void setTrustManager(JSSTrustManager tm) {\n+        engine.setTrustManager(tm);\n+    }\n+\n+    /**\n+     * Set the trust managers this SSLSocket will utilize to validate a peer's\n+     * certificate.\n+     *\n+     * @see JSSEngine#setTrustManagers(X509TrustManager[])\n+     */\n+    public void setTrustManagers(X509TrustManager[] xtms) {\n+        engine.setTrustManagers(xtms);\n+    }\n+\n+    /* == stubs over SSLSocket == */\n+\n+    /**\n+     * Begin a handshake, blocking to completion; this will begin a new\n+     * handshake when one has already been issued.\n+     *\n+     * @see JSSEngine#beginHandshake()\n+     * @see javax.net.ssl.SSLSocket#startHandshake()\n+     */\n+    @Override\n+    public void startHandshake() throws IOException {\n+        engine.beginHandshake();\n+\n+        if (channel == null) {\n+            // Only be blocking on the first handshake call.\n+            doHandshake();\n+        }\n+    }\n+\n+    /**\n+     * Add a callback to fire on handshake completion.\n+     *\n+     * @see javax.net.ssl.SSLSocket#addHandshakeCompletedListener(HandshakeCompletedListener)\n+     */\n+    @Override\n+    public void addHandshakeCompletedListener(HandshakeCompletedListener callback) throws IllegalArgumentException {\n+        if (callback == null) {\n+            throw new IllegalArgumentException(\"Expected non-null HandshakeCompletedListener instance.\");\n+        }\n+\n+        handshakeCallbacks.add(callback);\n+    }\n+\n+    /**\n+     * Internal helper to fire callbacks on handshake completion.\n+     */\n+    protected void notifyHandshakeCompletedListeners() {\n+        for (HandshakeCompletedListener callback : handshakeCallbacks) {\n+            HandshakeCompletedEvent event = new HandshakeCompletedEvent(this, getSession());", "originalCommit": "defd123758ba3b850d09b5bf095f70c586f48a39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MjI2NQ==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421152265", "bodyText": "According to Socket.getChannel():\n\nA socket will have a channel if, and only if, the channel itself was created via the SocketChannel.open or ServerSocketChannel.accept methods.\n\nand according to SocketChannel.open():\n\nOpens a socket channel. The new channel is created by invoking the openSocketChannel method of the system-wide default SelectorProvider object.\n\nso should we create a JSSSelectorProvider and register it as a default selector provider?", "author": "edewata", "createdAt": "2020-05-06T23:34:46Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.", "originalCommit": "defd123758ba3b850d09b5bf095f70c586f48a39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0NjkyMA==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421546920", "bodyText": "So we're not creating a SocketChannel here with JSSSocketChannel, just like we're not creating a Socket in the JSSSocket -- we're creating what would be a SSLSocketChannel implementation. But such a thing doesn't (apparently) exist in the standard library.\nWe're upgrading/\"consuming\" an existing SocketChannel and Socket, wrapping it in JSSSocketChannel and JSSSocket, and making the result do TLS over this wrapped Socket/SocketChannel.\nWe don't want to provide a SelectorProvider because it creates \"raw\" sockets; we want to create TLS-wrapped sockets. If we make it default, then all socket channels would become TLS-wrapped, which would be unexpected in most cases.\nPerhaps overriding the static open methods would suffice?\n\nPart of the problem here is we need to blend two worlds: the blocking world of SSLSocket and the non-blocking world of SSLEngine. I chose to take the consumed Socket and convert the InputStream/OutputStreams into Channels so that we can more easily utilize them with SSLEngine. Otherwise we'd have to put byte[] buffers directly inside JSSSocket and .wrap them to ByteBuffers for use with SSLEngine.\nWe're not trying to directly mimic what the SunJSSE SSLSocketImpl does here either. It has very restrictive usages that the original org.mozilla.jss.ssl.SSLSocket doesn't have and we don't need either:\n\nIf your socket isn't connected, SunJSSE's SocketFactory won't consume it via createSocket(Socket, <host>, <port>, <auto close>) -- it'll fail saying that Socket should've been connected first. We instead create an unconnected socket and leave it to the caller to call connect the new socket.\nIf your socket is non-blocking, it'll fail to work. startHandshake() will fail with an invalid blocking mode exception. This is because they internally didn't implement any channel semantics.\n... probably other failures once those have been worked around.\n\nSince we can use the JSSSocketChannel to provide both blocking and non-blocking semantics, I think we should. It lets people use a non-blocking channel without manually maintaining a SSLEngine instance. It just requires them to go through a SSLSocketFactory in order to do it, which I think is fine.\n\nWhat I think I'll do is:\n\nMake getChannel() only return our internal channel if the parent has a channel.\nImplement a SSLSocketChannelFactory and equivalent server channel class.", "author": "cipherboy", "createdAt": "2020-05-07T14:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MjI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NTg0MA==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421755840", "bodyText": "@edewata  Do you think #2 makes sense? Should I also create a generic SSLSocketChannel that brings some of the methods from SSLSocket onto a SSLSocketChannel?", "author": "cipherboy", "createdAt": "2020-05-07T19:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MjI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1MDM4MA==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421850380", "bodyText": "These are tough questions! :)\nI'd say go ahead and implement anything that we need to get it working,\nand feel free to implement anything extra that will make JSS more usable\nin general.", "author": "edewata", "createdAt": "2020-05-07T23:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MjI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MzA3Mw==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421153073", "bodyText": "It looks like we're supposed to create a JSSSocketChannel first using SocketChannel.open(), then get the socket associated with the channel instead of creating a JSSSocket that has a channel in it.", "author": "edewata", "createdAt": "2020-05-06T23:37:25Z", "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -0,0 +1,869 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+import org.mozilla.jss.pkcs11.PK11Cert;\n+import org.mozilla.jss.pkcs11.PK11PrivKey;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSTrustManager;\n+\n+/**\n+ * SSL-enabled socket following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * Most users will want to use the JSSSocketFactory provided by the Java\n+ * Provider interface instead of using this class directly.\n+ *\n+ * This SSLSocket implementation is a wrapped implementation. In particular, we\n+ * need to consume an existing Socket (via the consumeSocket(...) call) which\n+ * we actually send data over. When called from a socket factory, this\n+ * additional socket will be automatically created for the caller. This\n+ * is necessary because SSLSocketFactory includes a mode which wraps an\n+ * existing socket.\n+ *\n+ * All JSSSocket instances have a underlying SocketChannel, of type\n+ * JSSSocketChannel. Notably lacking is a javax.net.ssl.SSLSocketChannel type,\n+ * so JSSSocketChannel includes no additional SSL-specific options. However,\n+ * the core of the SSLEngine wrapping logic exists there.\n+ *\n+ * In order to interoperate with JSSEngine, many of the adjacent methods have\n+ * been included in this class as well.\n+ *\n+ * This socket can either be a client or a server, depending on how it was\n+ * created. For more information, see the javax.net.ssl.SSLSocket\n+ * documentation.\n+ *\n+ * To construct a (useful) new instance, the following calls must be made:\n+ *\n+ * - new JSSSocket();\n+ * - consumeSocket(inst);\n+ * - initSSLEngine(...);\n+ * - setKeyManagers(...);\n+ * - setTrustManagers(...);\n+ *\n+ * Optionally, setSSLContext(...) could be called to provide the SSLContext\n+ * from which the SSLEngine should be constructed. This should be called prior\n+ * to initSSLEngine(...) being called.\n+ */\n+public class JSSSocket extends SSLSocket {\n+    /**\n+     * Name of the SSLEngine protocol to use.\n+     */\n+    private String engineProviderProtocol = \"TLS\";\n+\n+    /**\n+     * Name of the SSLEngine provider to use.\n+     */\n+    private String engineProvider = \"Mozilla-JSS\";\n+\n+    /**\n+     * SSLContext to use to create the JSSEngine. Note that JSSSocket will fail\n+     * if the context doesn't create JSSEngine instances.\n+     */\n+    private SSLContext jssContext;\n+\n+    /**\n+     * JSSEngine instance to utilize for SSLEngine operations.\n+     */\n+    private JSSEngine engine;\n+\n+    /**\n+     * All registered handshake callbacks.\n+     */\n+    private ArrayList<HandshakeCompletedListener> handshakeCallbacks = new ArrayList<HandshakeCompletedListener>();\n+\n+    /**\n+     * The socket this JSSSocket was created over; all read/write operations\n+     * go through this socket and all information exposed via Socket members\n+     * go through here.\n+     */\n+    private Socket parent;\n+\n+    /**\n+     * Previously consumed data, if any; utilized for certain SSLSocketFactory\n+     * calls.\n+     */\n+    private InputStream consumedData;\n+\n+    /**\n+     * Underlying SocketChannel for this socket; always exists.\n+     */\n+    private JSSSocketChannel channel;\n+\n+    /**\n+     * Whether or not to automatically close the underlying Socket when this\n+     * socket has been closed; defaults to true.\n+     */\n+    private boolean autoClose = true;\n+\n+    /**\n+     * Start building a new JSSSocket.\n+     *\n+     * We specifically avoid creating any other constructors as we wish to\n+     * consume an existing socket rather than creating a new one.\n+     */\n+    public JSSSocket() {}\n+\n+    /**\n+     * Consume a parent socket, utilizing it for all read/write operations.\n+     *\n+     * This JSSSocket instance will inherit all information about the\n+     * connection from this underlying socket. When utilized in a JSSSocket,\n+     * callers should refrain from interacting with the underlying socket\n+     * directly until the TLS connection is closed. Otherwise, messages may\n+     * get dropped.\n+     */\n+    public void consumeSocket(Socket parent) throws IOException {\n+        if (parent == null) {\n+            String msg = \"Unable to consume and utilize null parent socket!\";\n+            throw new IOException(msg);\n+        }\n+\n+        this.parent = parent;\n+    }\n+\n+    /**\n+     * Get the SSLContext if one exists or create a new instance.\n+     *\n+     * This is used by initSSLEngine(..) to create the underlying SSLEngine.\n+     */\n+    protected SSLContext getSSLContext() throws IOException {\n+        if (jssContext == null) {\n+            try {\n+                jssContext = SSLContext.getInstance(engineProviderProtocol, engineProvider);\n+            } catch (Exception e) {\n+                String msg = \"Unable to create JSSSocket prior to Mozilla-JSS \";\n+                msg += \"initialization! \" + e.getMessage();\n+                throw new IOException(msg, e);\n+            }\n+        }\n+\n+        return jssContext;\n+    }\n+\n+    /**\n+     * Explicitly set the SSLContext utilized by this JSSSocket instance.\n+     *\n+     * This enables JSSServerSocket to copy its SSLContext over to the accepted\n+     * JSSSocket.\n+     */\n+    public void setSSLContext(SSLContext ctx) throws IOException {\n+        jssContext = ctx;\n+    }\n+\n+    /**\n+     * Initialize the underlying SocketChannel.\n+     */\n+    private void init() throws IOException {\n+        if (engine == null) {\n+            initEngine();\n+        }\n+\n+        SocketChannel parentChannel = parent.getChannel();\n+\n+        if (parentChannel == null) {\n+            ReadableByteChannel read = Channels.newChannel(parent.getInputStream());\n+            WritableByteChannel write = Channels.newChannel(parent.getOutputStream());\n+\n+            channel = new JSSSocketChannel(this, parent, read, write, engine);\n+        } else {\n+            channel = new JSSSocketChannel(this, parentChannel, engine);\n+        }", "originalCommit": "defd123758ba3b850d09b5bf095f70c586f48a39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU1MjQwNw==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421552407", "bodyText": "See above: we're using this for convenience of implementation. I'll change getChannel() to return null if parent.getChannel() returns null. But no, we're not opening a new socket channel here -- we're wrapping an existing one.", "author": "cipherboy", "createdAt": "2020-05-07T14:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MzA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2NTkzMQ==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421165931", "bodyText": "The exception message probably can be shortened like \"Unable to unwrap SSL data:\".", "author": "edewata", "createdAt": "2020-05-07T00:19:03Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private ReadableByteChannel consumedChannel;\n+\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+\n+    private ByteBuffer empty = ByteBuffer.allocate(0);\n+    private ByteBuffer readBuffer;\n+    private ByteBuffer writeBuffer;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+\n+        this.readBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n+        this.writeBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) throws IOException {\n+        this(sslSocket, parent, parent.socket(), parent, parent, engine);\n+\n+        // Copy the blocking mode from the parent channel.\n+        configureBlocking(parent.isBlocking());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        this(sslSocket, null, parentSocket, readChannel, writeChannel, engine);\n+\n+        // When there is no parent channel, this channel must be in\n+        // blocking mode.\n+        configureBlocking(true);\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) throws IOException {\n+        if (consumed != null && consumed.available() > 0) {\n+            this.consumed = consumed;\n+            consumedChannel = Channels.newChannel(consumed);\n+        }\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        // When there's consumed data left to read, ensure we bound by the\n+        // amount available there before continuing.\n+        if (consumed != null && consumed.available() > 0) {\n+            return Math.min(consumed.available(), suggested);\n+        }\n+\n+        // By setting consumed = null when consumed no longer has bytes\n+        // available, we provide an easy check for which channel to read\n+        // from.\n+        consumed = null;\n+        consumedChannel = null;\n+\n+        // If its a non-blocking underlying socket, then return suggested;\n+        // it'll read as much as currently available.\n+        if (!isBlocking()) {\n+            return suggested;\n+        }\n+\n+        // In both remaining cases (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+        int available = parentSocket.getInputStream().available();\n+        return Math.min(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        int handshakeAttempts = 0;\n+        int maxHandshakeAttempts = 100;\n+\n+        if (!isBlocking()) {\n+            // When we're a non-blocking socket/channel, we'd farther rather\n+            // return false than take too much time in this method.\n+            maxHandshakeAttempts = 10;\n+        }\n+\n+        // Attempt to handshake with the remote peer.\n+        try {\n+            do {\n+                if (state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                    // Write from an empty buffer to wrap.\n+                    write(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                    // Read into an empty buffer to unwrap.\n+                    read(empty);\n+                } else {\n+                    String msg = \"Error attempting to handshake: unknown \";\n+                    msg += \"handshake status code `\" + state + \"`\";\n+                    throw new IOException(msg);\n+                }\n+\n+                SSLEngineResult.HandshakeStatus last_state = state;\n+                state = engine.getHandshakeStatus();\n+                handshakeAttempts += 1;\n+\n+                if (state == last_state) {\n+                    try {\n+                        // This sleep is necessary in order to wait for\n+                        // incoming data. If it turns out our\n+                        // NEED_UNWRAP is premature (and we're stuck in\n+                        // a blocking read() call because we issued a\n+                        // non-zero read!), we might cause the remote\n+                        // peer to timeout and send a CLOSE_NOTIFY\n+                        // alert. This wouldn't be good, so sleep\n+                        // instead. Use an exponential backoff in case\n+                        // the remote server is really slow.\n+                        Thread.sleep(handshakeAttempts * 10);\n+                    } catch (Exception e) {}\n+                }\n+\n+                if (handshakeAttempts > maxHandshakeAttempts) {\n+                    if (!isBlocking()) {\n+                        // In the event we failed to connect under a\n+                        // non-blocking socket, return false rather than fail\n+                        // here. It could just be that we don't have enough\n+                        // data to continue. In that case, doHandshake() in\n+                        // JSSSocket will re-try until the connection succeeds.\n+                        return false;\n+                    }\n+\n+                    String msg = \"Error attempting to handshake: unable to \";\n+                    msg += \"complete handshake successfully in \";\n+                    msg += maxHandshakeAttempts + \" calls to wrap or unwrap. \";\n+                    msg += \"Connection stalled.\";\n+                    throw new IOException(msg);\n+                }\n+            } while (state != SSLEngineResult.HandshakeStatus.FINISHED && state != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to handshake with remote peer: \";\n+            msg += \"got unexpected exception: \" + ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        sslSocket.notifyHandshakeCompletedListeners();\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Compute the total size of a list of buffers from the specified offest\n+     * and length.\n+     */\n+    private static long computeSize(ByteBuffer[] buffers, int offset, int length) throws IOException {\n+        long result = 0;\n+\n+        if (buffers == null || buffers.length == 0) {\n+            return result;\n+        }\n+\n+        for (int rel_index = 0; rel_index < length; rel_index++) {\n+            int index = offset + rel_index;\n+            if (index >= buffers.length) {\n+                String msg = \"Offset (\" + offset + \" or length (\" + length;\n+                msg += \") exceeds contract based on number of buffers \";\n+                msg += \"given (\" + buffers.length + \")\";\n+                throw new IOException(msg);\n+            }\n+\n+            if (buffers[index] != null) {\n+                result += buffers[index].remaining();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public int read(ByteBuffer dst) throws IOException {\n+        return (int) read(new ByteBuffer[] { dst });\n+    }\n+\n+    public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (inboundClosed) {\n+            return -1;\n+        }\n+\n+        readBuffer.clear();\n+\n+        int buffer_size = boundRead(readBuffer.capacity());\n+        ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), 0, buffer_size);\n+\n+        long remoteRead = 0;\n+        if (consumed != null) {\n+            remoteRead = consumedChannel.read(src);\n+        } else {\n+            remoteRead = readChannel.read(src);\n+        }\n+\n+        if (remoteRead == 0) {\n+            return 0;\n+        }\n+\n+        src.flip();\n+\n+        long unwrapped = 0;\n+        long decrypted = 0;\n+\n+        try {\n+            do {\n+                SSLEngineResult result = engine.unwrap(src, dsts, offset, length);\n+                if (result.getStatus() != SSLEngineResult.Status.OK && result.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                    throw new IOException(\"Unexpected status from unwrap: \" + result);\n+                }\n+\n+                unwrapped += result.bytesConsumed();\n+                decrypted += result.bytesProduced();\n+\n+                if (unwrapped < remoteRead && result.bytesConsumed() == 0 && result.bytesProduced() == 0) {\n+                    String msg = \"Error attempting to read from remote peer: \";\n+                    msg += \"calls to unwrap stalled, consuming and producing \";\n+                    msg += \"no data: unwrapped \" + unwrapped + \" bytes of \";\n+                    msg += remoteRead + \" bytes read from remote peer; got a \";\n+                    msg += \"decrypted size of \" + decrypted + \" bytes.\";\n+                    throw new IOException(msg);\n+                }\n+            } while (unwrapped < remoteRead);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to read from remote peer: \";\n+            msg += \"got unexpected exception during unwrap call: \";", "originalCommit": "defd123758ba3b850d09b5bf095f70c586f48a39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2NzIxMA==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421167210", "bodyText": "This is a bit long as an exception message. I'm not sure the actual numbers would be useful for debugging. Should we just say something like \"Incomplete SSL unwrap\" instead?", "author": "edewata", "createdAt": "2020-05-07T00:22:52Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private ReadableByteChannel consumedChannel;\n+\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+\n+    private ByteBuffer empty = ByteBuffer.allocate(0);\n+    private ByteBuffer readBuffer;\n+    private ByteBuffer writeBuffer;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+\n+        this.readBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n+        this.writeBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) throws IOException {\n+        this(sslSocket, parent, parent.socket(), parent, parent, engine);\n+\n+        // Copy the blocking mode from the parent channel.\n+        configureBlocking(parent.isBlocking());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        this(sslSocket, null, parentSocket, readChannel, writeChannel, engine);\n+\n+        // When there is no parent channel, this channel must be in\n+        // blocking mode.\n+        configureBlocking(true);\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) throws IOException {\n+        if (consumed != null && consumed.available() > 0) {\n+            this.consumed = consumed;\n+            consumedChannel = Channels.newChannel(consumed);\n+        }\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        // When there's consumed data left to read, ensure we bound by the\n+        // amount available there before continuing.\n+        if (consumed != null && consumed.available() > 0) {\n+            return Math.min(consumed.available(), suggested);\n+        }\n+\n+        // By setting consumed = null when consumed no longer has bytes\n+        // available, we provide an easy check for which channel to read\n+        // from.\n+        consumed = null;\n+        consumedChannel = null;\n+\n+        // If its a non-blocking underlying socket, then return suggested;\n+        // it'll read as much as currently available.\n+        if (!isBlocking()) {\n+            return suggested;\n+        }\n+\n+        // In both remaining cases (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+        int available = parentSocket.getInputStream().available();\n+        return Math.min(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        int handshakeAttempts = 0;\n+        int maxHandshakeAttempts = 100;\n+\n+        if (!isBlocking()) {\n+            // When we're a non-blocking socket/channel, we'd farther rather\n+            // return false than take too much time in this method.\n+            maxHandshakeAttempts = 10;\n+        }\n+\n+        // Attempt to handshake with the remote peer.\n+        try {\n+            do {\n+                if (state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                    // Write from an empty buffer to wrap.\n+                    write(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                    // Read into an empty buffer to unwrap.\n+                    read(empty);\n+                } else {\n+                    String msg = \"Error attempting to handshake: unknown \";\n+                    msg += \"handshake status code `\" + state + \"`\";\n+                    throw new IOException(msg);\n+                }\n+\n+                SSLEngineResult.HandshakeStatus last_state = state;\n+                state = engine.getHandshakeStatus();\n+                handshakeAttempts += 1;\n+\n+                if (state == last_state) {\n+                    try {\n+                        // This sleep is necessary in order to wait for\n+                        // incoming data. If it turns out our\n+                        // NEED_UNWRAP is premature (and we're stuck in\n+                        // a blocking read() call because we issued a\n+                        // non-zero read!), we might cause the remote\n+                        // peer to timeout and send a CLOSE_NOTIFY\n+                        // alert. This wouldn't be good, so sleep\n+                        // instead. Use an exponential backoff in case\n+                        // the remote server is really slow.\n+                        Thread.sleep(handshakeAttempts * 10);\n+                    } catch (Exception e) {}\n+                }\n+\n+                if (handshakeAttempts > maxHandshakeAttempts) {\n+                    if (!isBlocking()) {\n+                        // In the event we failed to connect under a\n+                        // non-blocking socket, return false rather than fail\n+                        // here. It could just be that we don't have enough\n+                        // data to continue. In that case, doHandshake() in\n+                        // JSSSocket will re-try until the connection succeeds.\n+                        return false;\n+                    }\n+\n+                    String msg = \"Error attempting to handshake: unable to \";\n+                    msg += \"complete handshake successfully in \";\n+                    msg += maxHandshakeAttempts + \" calls to wrap or unwrap. \";\n+                    msg += \"Connection stalled.\";\n+                    throw new IOException(msg);\n+                }\n+            } while (state != SSLEngineResult.HandshakeStatus.FINISHED && state != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to handshake with remote peer: \";\n+            msg += \"got unexpected exception: \" + ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        sslSocket.notifyHandshakeCompletedListeners();\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Compute the total size of a list of buffers from the specified offest\n+     * and length.\n+     */\n+    private static long computeSize(ByteBuffer[] buffers, int offset, int length) throws IOException {\n+        long result = 0;\n+\n+        if (buffers == null || buffers.length == 0) {\n+            return result;\n+        }\n+\n+        for (int rel_index = 0; rel_index < length; rel_index++) {\n+            int index = offset + rel_index;\n+            if (index >= buffers.length) {\n+                String msg = \"Offset (\" + offset + \" or length (\" + length;\n+                msg += \") exceeds contract based on number of buffers \";\n+                msg += \"given (\" + buffers.length + \")\";\n+                throw new IOException(msg);\n+            }\n+\n+            if (buffers[index] != null) {\n+                result += buffers[index].remaining();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public int read(ByteBuffer dst) throws IOException {\n+        return (int) read(new ByteBuffer[] { dst });\n+    }\n+\n+    public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (inboundClosed) {\n+            return -1;\n+        }\n+\n+        readBuffer.clear();\n+\n+        int buffer_size = boundRead(readBuffer.capacity());\n+        ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), 0, buffer_size);\n+\n+        long remoteRead = 0;\n+        if (consumed != null) {\n+            remoteRead = consumedChannel.read(src);\n+        } else {\n+            remoteRead = readChannel.read(src);\n+        }\n+\n+        if (remoteRead == 0) {\n+            return 0;\n+        }\n+\n+        src.flip();\n+\n+        long unwrapped = 0;\n+        long decrypted = 0;\n+\n+        try {\n+            do {\n+                SSLEngineResult result = engine.unwrap(src, dsts, offset, length);\n+                if (result.getStatus() != SSLEngineResult.Status.OK && result.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                    throw new IOException(\"Unexpected status from unwrap: \" + result);\n+                }\n+\n+                unwrapped += result.bytesConsumed();\n+                decrypted += result.bytesProduced();\n+\n+                if (unwrapped < remoteRead && result.bytesConsumed() == 0 && result.bytesProduced() == 0) {\n+                    String msg = \"Error attempting to read from remote peer: \";\n+                    msg += \"calls to unwrap stalled, consuming and producing \";\n+                    msg += \"no data: unwrapped \" + unwrapped + \" bytes of \";\n+                    msg += remoteRead + \" bytes read from remote peer; got a \";\n+                    msg += \"decrypted size of \" + decrypted + \" bytes.\";", "originalCommit": "defd123758ba3b850d09b5bf095f70c586f48a39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NjcxMA==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421666710", "bodyText": "The biggest concern was if unwrapped was 0 and remoteRead was non-zero; it'd indicate that the SSLEngine implementation was flawed.", "author": "cipherboy", "createdAt": "2020-05-07T17:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2NzIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2Njc3Mw==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421666773", "bodyText": "I've shortened this message though.", "author": "cipherboy", "createdAt": "2020-05-07T17:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2NzIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2ODI3MQ==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421168271", "bodyText": "In the future we probably could change org.mozilla.jss.ssl.SSLSocket to extend JSSSocket, and eventually merge it into JSSSocket.", "author": "edewata", "createdAt": "2020-05-07T00:26:17Z", "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -0,0 +1,869 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+import org.mozilla.jss.pkcs11.PK11Cert;\n+import org.mozilla.jss.pkcs11.PK11PrivKey;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSTrustManager;\n+\n+/**\n+ * SSL-enabled socket following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * Most users will want to use the JSSSocketFactory provided by the Java\n+ * Provider interface instead of using this class directly.\n+ *\n+ * This SSLSocket implementation is a wrapped implementation. In particular, we\n+ * need to consume an existing Socket (via the consumeSocket(...) call) which\n+ * we actually send data over. When called from a socket factory, this\n+ * additional socket will be automatically created for the caller. This\n+ * is necessary because SSLSocketFactory includes a mode which wraps an\n+ * existing socket.\n+ *\n+ * All JSSSocket instances have a underlying SocketChannel, of type\n+ * JSSSocketChannel. Notably lacking is a javax.net.ssl.SSLSocketChannel type,\n+ * so JSSSocketChannel includes no additional SSL-specific options. However,\n+ * the core of the SSLEngine wrapping logic exists there.\n+ *\n+ * In order to interoperate with JSSEngine, many of the adjacent methods have\n+ * been included in this class as well.\n+ *\n+ * This socket can either be a client or a server, depending on how it was\n+ * created. For more information, see the javax.net.ssl.SSLSocket\n+ * documentation.\n+ *\n+ * To construct a (useful) new instance, the following calls must be made:\n+ *\n+ * - new JSSSocket();\n+ * - consumeSocket(inst);\n+ * - initSSLEngine(...);\n+ * - setKeyManagers(...);\n+ * - setTrustManagers(...);\n+ *\n+ * Optionally, setSSLContext(...) could be called to provide the SSLContext\n+ * from which the SSLEngine should be constructed. This should be called prior\n+ * to initSSLEngine(...) being called.\n+ */\n+public class JSSSocket extends SSLSocket {", "originalCommit": "defd123758ba3b850d09b5bf095f70c586f48a39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU2NDg1OA==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421564858", "bodyText": "org.mozilla.jss.ssl.SSLSocket doesn't respect many of the semantics around the javax.net.ssl suite:\n\nKeyManager for key selection,\nTrustManager for cert validation,\nConverting between SSLCipher and JDK-standard names is easier.\n\nWe could fix the latter, but the former would be more invasive changes. Ideally we'd like our javax.net.ssl.SSLSocket implementation to behave as similarly to our javax.net.ssl.SSLEngine as possible. For people not expecting a javax.net.ssl.SSLSocket and who want a generic Socket (that happens to do TLS under the covers), we're fine keeping org.mozilla.jss.ssl.SSLSocket. I guess that's LDAP JDK and some Dogtag PKI helpers. But for any third-party library, I think JSSSocket is fine? I dunno. At any rate, not a problem to solve in this PR :-)", "author": "cipherboy", "createdAt": "2020-05-07T14:48:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2ODI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE3MDE0MA==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421170140", "bodyText": "Is this phrase correct?", "author": "edewata", "createdAt": "2020-05-07T00:32:09Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private ReadableByteChannel consumedChannel;\n+\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+\n+    private ByteBuffer empty = ByteBuffer.allocate(0);\n+    private ByteBuffer readBuffer;\n+    private ByteBuffer writeBuffer;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+\n+        this.readBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n+        this.writeBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) throws IOException {\n+        this(sslSocket, parent, parent.socket(), parent, parent, engine);\n+\n+        // Copy the blocking mode from the parent channel.\n+        configureBlocking(parent.isBlocking());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        this(sslSocket, null, parentSocket, readChannel, writeChannel, engine);\n+\n+        // When there is no parent channel, this channel must be in\n+        // blocking mode.\n+        configureBlocking(true);\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) throws IOException {\n+        if (consumed != null && consumed.available() > 0) {\n+            this.consumed = consumed;\n+            consumedChannel = Channels.newChannel(consumed);\n+        }\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        // When there's consumed data left to read, ensure we bound by the\n+        // amount available there before continuing.\n+        if (consumed != null && consumed.available() > 0) {\n+            return Math.min(consumed.available(), suggested);\n+        }\n+\n+        // By setting consumed = null when consumed no longer has bytes\n+        // available, we provide an easy check for which channel to read\n+        // from.\n+        consumed = null;\n+        consumedChannel = null;\n+\n+        // If its a non-blocking underlying socket, then return suggested;\n+        // it'll read as much as currently available.\n+        if (!isBlocking()) {\n+            return suggested;\n+        }\n+\n+        // In both remaining cases (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+        int available = parentSocket.getInputStream().available();\n+        return Math.min(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        int handshakeAttempts = 0;\n+        int maxHandshakeAttempts = 100;\n+\n+        if (!isBlocking()) {\n+            // When we're a non-blocking socket/channel, we'd farther rather", "originalCommit": "defd123758ba3b850d09b5bf095f70c586f48a39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0Nzc0Ng==", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421547746", "bodyText": "farther rather \ud83d\ude06 Nah, it isn't. I'll update this.", "author": "cipherboy", "createdAt": "2020-05-07T14:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE3MDE0MA=="}], "type": "inlineReview"}, {"oid": "fe387f6c7febebfa788892a8852666f024f42f74", "url": "https://github.com/dogtagpki/jss/commit/fe387f6c7febebfa788892a8852666f024f42f74", "message": "Provide JSSSocket for JSSContextSpi\n\nJSSSocket provides a way of utilizing JSSEngine over an existing Socket,\nthus utilizing NSS to provide TLS capabilities for this socket. Unlike\nthe existing org.mozilla.jss.ssl.SSLSocket, JSS socket complies with\nthe standard javax.net.ssl.SSLSocket interface, making it compatible\nwith existing applications and libraries expecting the SSLSocketFactory\nfrom SSLContext to provide SSLSocket instances. This is necessary as\nmany applications don't handle when SSLContext returns null from the\ngetSocketFactory() call.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-07T17:34:28Z", "type": "commit"}, {"oid": "7d1e10e85abcc12558975f008f7e54caf4780ecf", "url": "https://github.com/dogtagpki/jss/commit/7d1e10e85abcc12558975f008f7e54caf4780ecf", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-07T17:34:28Z", "type": "forcePushed"}, {"oid": "c662aae47a82f4e54ce322cfff24903f436727a0", "url": "https://github.com/dogtagpki/jss/commit/c662aae47a82f4e54ce322cfff24903f436727a0", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-07T18:00:56Z", "type": "commit"}, {"oid": "c662aae47a82f4e54ce322cfff24903f436727a0", "url": "https://github.com/dogtagpki/jss/commit/c662aae47a82f4e54ce322cfff24903f436727a0", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-07T18:00:56Z", "type": "forcePushed"}]}