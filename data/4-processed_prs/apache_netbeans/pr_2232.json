{"pr_number": 2232, "pr_title": "[NETBEANS-4699] Make it easy to create dynamically updated ProxyLookup instances without subclassing", "pr_createdAt": "2020-07-05T06:38:16Z", "pr_url": "https://github.com/apache/netbeans/pull/2232", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg4ODkyNw==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r449888927", "bodyText": "There is no chicken and egg problem, because this should be a JIRA ticket.  AFAIK this will currently get linked to https://issues.apache.org/jira/browse/NETBEANS-2232", "author": "neilcsmith-net", "createdAt": "2020-07-05T15:20:00Z", "path": "platform/openide.util.lookup/apichanges.xml", "diffHunk": "@@ -53,7 +53,7 @@\n             </p>\n         </description>\n         <class name=\"ProxyLookup\" package=\"org.openide.util.lookup\"/>\n-        <issue number=\"pending\"/>\n+        <issue number=\"NETBEANS-2232\"/>", "originalCommit": "e7fe91924944784f57f33748974115e7b1d10657", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU2NjI1Nw==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r467566257", "bodyText": "Fixed in 87a3727", "author": "JaroslavTulach", "createdAt": "2020-08-09T10:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg4ODkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NDgyMA==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r453354820", "bodyText": "Rather than describing usage of grep, I suggest to make the changes in the overall NetBeans sources, once we agree on the API.", "author": "JaroslavTulach", "createdAt": "2020-07-12T19:36:15Z", "path": "platform/openide.util.lookup/apichanges.xml", "diffHunk": "@@ -25,6 +25,33 @@\n     <apidef name=\"lookup\">Lookup API</apidef>\n </apidefs>\n <changes>\n+    <change id=\"ProxyLookupController\">\n+        <api name=\"lookup\"/>\n+        <summary>Add ProxyLookup.Controller to set lookups dynamically without \n+            subclassing</summary>\n+        <version major=\"8\" minor=\"43\"/>\n+        <date year=\"2020\" month=\"7\" day=\"4\"/>\n+        <author login=\"tboudreau\"/>\n+        <compatibility addition=\"yes\" source=\"compatible\" semantic=\"compatible\" binary=\"compatible\"/>\n+        <description>\n+            <p>\n+                One of the most common uses of ProxyLookup is to dynamically \n+                change the set of lookups being delegated to.  The objection\n+                to exposing the <code>setLookups()</code> method is straightforward -\n+                it would be inviting <i>clients</i> of such a Lookup to call it.\n+            </p><p>\n+                A cursory grep of NetBeans' own sources finds <b>53 such subclasses</b>", "originalCommit": "6924123f2e503403d7ac410f6f34fb87dea4dc4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NDkyMw==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r453354923", "bodyText": "The passed in Consumer is no longer called back. It can:\n\"be used later to change the set of lookups the ProxyLookup delegates to via Controller.setLookups method\"", "author": "JaroslavTulach", "createdAt": "2020-07-12T19:37:32Z", "path": "platform/openide.util.lookup/src/org/openide/util/lookup/ProxyLookup.java", "diffHunk": "@@ -57,6 +58,26 @@\n     public ProxyLookup(Lookup... lookups) {\n         data = ImmutableInternalData.EMPTY.setLookupsNoFire(lookups, true);\n     }\n+    /**\n+     * Create a ProxyLookup whose contents can be set dynamically without\n+     * exposing the setter to consumers of the lookup; the passed", "originalCommit": "6924123f2e503403d7ac410f6f34fb87dea4dc4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTA1MQ==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r453355051", "bodyText": "I really want this change to not rely on JDK8 APIs.\nI suggest to change this field to ProxyLookup.", "author": "JaroslavTulach", "createdAt": "2020-07-12T19:38:22Z", "path": "platform/openide.util.lookup/src/org/openide/util/lookup/ProxyLookup.java", "diffHunk": "@@ -89,7 +110,96 @@ public synchronized String toString() {\n         }\n         return map.keySet();\n     }\n-    \n+\n+    /**\n+     * A controller which allows the set of lookups being proxied to be\n+     * set dynamically.\n+     *\n+     * @since 8.43\n+     */\n+    public static final class Controller {\n+\n+        private BiConsumer<? super Executor, ? super Lookup[]> consumer;", "originalCommit": "6924123f2e503403d7ac410f6f34fb87dea4dc4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTA4Nw==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r453355087", "bodyText": "I don't see a value in this constructor. I suggest to remove it.", "author": "JaroslavTulach", "createdAt": "2020-07-12T19:38:48Z", "path": "platform/openide.util.lookup/src/org/openide/util/lookup/ProxyLookup.java", "diffHunk": "@@ -89,7 +110,96 @@ public synchronized String toString() {\n         }\n         return map.keySet();\n     }\n-    \n+\n+    /**\n+     * A controller which allows the set of lookups being proxied to be\n+     * set dynamically.\n+     *\n+     * @since 8.43\n+     */\n+    public static final class Controller {\n+\n+        private BiConsumer<? super Executor, ? super Lookup[]> consumer;\n+\n+        /**\n+         * Create a controller with an initial set of lookups that will be\n+         * proxied by a {@link ProxyLookup} this controller is passed to the\n+         * constructor of.\n+         * @param lookups An array of lookups\n+         */\n+        public Controller(Lookup... lookups) {", "originalCommit": "6924123f2e503403d7ac410f6f34fb87dea4dc4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTE2MA==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r453355160", "bodyText": "if (this.consumer != null) {\n  throw ISE();\n}\nthis.consumer = lkp;\n\nis all you need, in my opinion.", "author": "JaroslavTulach", "createdAt": "2020-07-12T19:39:36Z", "path": "platform/openide.util.lookup/src/org/openide/util/lookup/ProxyLookup.java", "diffHunk": "@@ -89,7 +110,96 @@ public synchronized String toString() {\n         }\n         return map.keySet();\n     }\n-    \n+\n+    /**\n+     * A controller which allows the set of lookups being proxied to be\n+     * set dynamically.\n+     *\n+     * @since 8.43\n+     */\n+    public static final class Controller {\n+\n+        private BiConsumer<? super Executor, ? super Lookup[]> consumer;\n+\n+        /**\n+         * Create a controller with an initial set of lookups that will be\n+         * proxied by a {@link ProxyLookup} this controller is passed to the\n+         * constructor of.\n+         * @param lookups An array of lookups\n+         */\n+        public Controller(Lookup... lookups) {\n+            consumer = new InitialConsumer(lookups);\n+        }\n+\n+        /**\n+         * Create a controller with an initially empty set of lookups to\n+         * proxy to.\n+         */\n+        public Controller() {\n+            consumer = new InitialConsumer();\n+        }\n+\n+        /**\n+         * Set the lookups on the {@link ProxyLookup} this controller controls;\n+         * if called before that ProxyLookup has been created, the lookup\n+         * contents will be set during that ProxyLookup's constructor as if you\n+         * had passed them to the constructor directly, but the executor\n+         * parameter will be ignored (nothing will be listening to it while it's\n+         * in its constructor anyway).\n+         *\n+         * @param exe An executor to notify in\n+         * @param lookups An array of Lookups to be proxied\n+         */\n+        public synchronized void setLookups(Executor exe, Lookup... lookups) {\n+            consumer.accept(exe, lookups);\n+        }\n+\n+        /**\n+         * Set the lookups on the {@link ProxyLookup} this controller controls;\n+         * if called before that ProxyLookup has been created, the lookup\n+         * contents will be set during that ProxyLookup's constructor as if you\n+         * had passed them to the constructor directly.\n+         *\n+         * @param exe An executor to notify in\n+         * @param lookups An array of Lookups to be proxied\n+         */\n+        public void setLookups(Lookup... lookups) {\n+            setLookups(null, lookups);\n+        }\n+\n+        synchronized Lookup[] setProxyLookup(ProxyLookup lkp) {\n+            if (!(this.consumer instanceof InitialConsumer)) {\n+                throw new IllegalStateException(\"Attempting to use \"\n+                        + \"ProxyLookup.Controller for more than one \"\n+                        + \"ProxyLookup is illegal\");\n+            }\n+            Lookup[] result = ((InitialConsumer) consumer).lookups();\n+            this.consumer = lkp::setLookups;", "originalCommit": "6924123f2e503403d7ac410f6f34fb87dea4dc4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTE5Nw==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r453355197", "bodyText": "Remove this class.", "author": "JaroslavTulach", "createdAt": "2020-07-12T19:39:52Z", "path": "platform/openide.util.lookup/src/org/openide/util/lookup/ProxyLookup.java", "diffHunk": "@@ -89,7 +110,96 @@ public synchronized String toString() {\n         }\n         return map.keySet();\n     }\n-    \n+\n+    /**\n+     * A controller which allows the set of lookups being proxied to be\n+     * set dynamically.\n+     *\n+     * @since 8.43\n+     */\n+    public static final class Controller {\n+\n+        private BiConsumer<? super Executor, ? super Lookup[]> consumer;\n+\n+        /**\n+         * Create a controller with an initial set of lookups that will be\n+         * proxied by a {@link ProxyLookup} this controller is passed to the\n+         * constructor of.\n+         * @param lookups An array of lookups\n+         */\n+        public Controller(Lookup... lookups) {\n+            consumer = new InitialConsumer(lookups);\n+        }\n+\n+        /**\n+         * Create a controller with an initially empty set of lookups to\n+         * proxy to.\n+         */\n+        public Controller() {\n+            consumer = new InitialConsumer();\n+        }\n+\n+        /**\n+         * Set the lookups on the {@link ProxyLookup} this controller controls;\n+         * if called before that ProxyLookup has been created, the lookup\n+         * contents will be set during that ProxyLookup's constructor as if you\n+         * had passed them to the constructor directly, but the executor\n+         * parameter will be ignored (nothing will be listening to it while it's\n+         * in its constructor anyway).\n+         *\n+         * @param exe An executor to notify in\n+         * @param lookups An array of Lookups to be proxied\n+         */\n+        public synchronized void setLookups(Executor exe, Lookup... lookups) {\n+            consumer.accept(exe, lookups);\n+        }\n+\n+        /**\n+         * Set the lookups on the {@link ProxyLookup} this controller controls;\n+         * if called before that ProxyLookup has been created, the lookup\n+         * contents will be set during that ProxyLookup's constructor as if you\n+         * had passed them to the constructor directly.\n+         *\n+         * @param exe An executor to notify in\n+         * @param lookups An array of Lookups to be proxied\n+         */\n+        public void setLookups(Lookup... lookups) {\n+            setLookups(null, lookups);\n+        }\n+\n+        synchronized Lookup[] setProxyLookup(ProxyLookup lkp) {\n+            if (!(this.consumer instanceof InitialConsumer)) {\n+                throw new IllegalStateException(\"Attempting to use \"\n+                        + \"ProxyLookup.Controller for more than one \"\n+                        + \"ProxyLookup is illegal\");\n+            }\n+            Lookup[] result = ((InitialConsumer) consumer).lookups();\n+            this.consumer = lkp::setLookups;\n+            return result;\n+        }\n+\n+        private static class InitialConsumer implements BiConsumer<Executor, Lookup[]> {", "originalCommit": "6924123f2e503403d7ac410f6f34fb87dea4dc4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTI4Nw==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r453355287", "bodyText": "Throw NullPointerException if the consumer field isn't yet set and document that as expected behavior. That's what I'd suggest.", "author": "JaroslavTulach", "createdAt": "2020-07-12T19:40:38Z", "path": "platform/openide.util.lookup/src/org/openide/util/lookup/ProxyLookup.java", "diffHunk": "@@ -89,7 +110,96 @@ public synchronized String toString() {\n         }\n         return map.keySet();\n     }\n-    \n+\n+    /**\n+     * A controller which allows the set of lookups being proxied to be\n+     * set dynamically.\n+     *\n+     * @since 8.43\n+     */\n+    public static final class Controller {\n+\n+        private BiConsumer<? super Executor, ? super Lookup[]> consumer;\n+\n+        /**\n+         * Create a controller with an initial set of lookups that will be\n+         * proxied by a {@link ProxyLookup} this controller is passed to the\n+         * constructor of.\n+         * @param lookups An array of lookups\n+         */\n+        public Controller(Lookup... lookups) {\n+            consumer = new InitialConsumer(lookups);\n+        }\n+\n+        /**\n+         * Create a controller with an initially empty set of lookups to\n+         * proxy to.\n+         */\n+        public Controller() {\n+            consumer = new InitialConsumer();\n+        }\n+\n+        /**\n+         * Set the lookups on the {@link ProxyLookup} this controller controls;\n+         * if called before that ProxyLookup has been created, the lookup\n+         * contents will be set during that ProxyLookup's constructor as if you\n+         * had passed them to the constructor directly, but the executor\n+         * parameter will be ignored (nothing will be listening to it while it's\n+         * in its constructor anyway).\n+         *\n+         * @param exe An executor to notify in\n+         * @param lookups An array of Lookups to be proxied\n+         */\n+        public synchronized void setLookups(Executor exe, Lookup... lookups) {\n+            consumer.accept(exe, lookups);", "originalCommit": "6924123f2e503403d7ac410f6f34fb87dea4dc4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA4NTc3OQ==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r462085779", "bodyText": "Throw IllegalArgumentException, maybe.  It is a bad habit to abuse NullPointerException for argument checking - when you see a NullPointerException, that should mean the JVM threw it because it was asked to do something that is impossible with a null.  One case is a bad argument that was checked (bug in the caller), the other is a bug in the callee (at least, failure to check the input) - if you use NullPointerException for both cases, you lose the ability to assume IllegalArgumentException means my code is probably wrong, look at that first and NullPointerException means library code may have a problem, maybe look at that first - and that makes debugging things faster.", "author": "timboudreau", "createdAt": "2020-07-29T07:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTI4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNjQ1Mg==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r463406452", "bodyText": "Throw whatever you prefer.", "author": "jtulach", "createdAt": "2020-07-31T05:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTUxMg==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r453355512", "bodyText": "This would be replaced with:\nProxyLookup.Controller controller = new ProxyLookup.Controller();\nProxyLookup l = new ProxyLookup(controller);\nl.setLookups(lookups);\nreturn l;\nI suggest to remove BiConsumer altogether as the test should mimic the API usage - e.g. directly use the Controller.", "author": "JaroslavTulach", "createdAt": "2020-07-12T19:42:56Z", "path": "platform/openide.util.lookup/test/unit/src/org/openide/util/lookup/ProxyLookupFactoryMethodsTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.openide.util.lookup;\n+\n+import java.util.Arrays;\n+import static java.util.Arrays.asList;\n+import java.util.HashSet;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+import org.openide.util.Lookup;\n+import org.openide.util.LookupEvent;\n+import org.openide.util.LookupListener;\n+import org.openide.util.lookup.ProxyLookupFactoryMethodsTest.TThreadFactory.TThread;\n+\n+/**\n+ *\n+ * @author Tim Boudreau\n+ */\n+public class ProxyLookupFactoryMethodsTest {\n+\n+    private Consumer<Lookup[]> lookupConsumer;\n+    private BiConsumer<Executor, Lookup[]> lookupBiConsumer;\n+\n+    private Lookup createWithSingleConsumer(Lookup... lookups) {\n+        ProxyLookup.Controller controller = new ProxyLookup.Controller(lookups);\n+        lookupConsumer = controller::setLookups;\n+        return new ProxyLookup(controller);", "originalCommit": "6924123f2e503403d7ac410f6f34fb87dea4dc4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA4Nzc5Mw==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r462087793", "bodyText": "Are you sure you would not me to make this code compatible with JDK 1.3 while we're at it?  Or perhaps 1.2?\nYou have something against functional interfaces?  (I am rather a fan of them)\nAs I sit here with Netbeans running on JDK 14, I wonder, why does Jarda want JDK 7 compatibility?", "author": "timboudreau", "createdAt": "2020-07-29T07:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNjA2MA==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r463406060", "bodyText": "I believe the test should show the expected usage of the API which is now without BiConsumer & co. Keeping such interface in the implementation or test is a relic of an API which disappeared.\nI am running Lookup & co. in restricted environments (see for example #2226). Increased usage of JDK8 APIs complicates that.", "author": "jtulach", "createdAt": "2020-07-31T05:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUyNjkzNg==", "url": "https://github.com/apache/netbeans/pull/2232#discussion_r467526936", "bodyText": "Ok, see if the latest update satisfies your requirements.", "author": "timboudreau", "createdAt": "2020-08-09T02:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM1NTUxMg=="}], "type": "inlineReview"}, {"oid": "2a4a18a201fec8b66c167eef012004e2c4be21f3", "url": "https://github.com/apache/netbeans/commit/2a4a18a201fec8b66c167eef012004e2c4be21f3", "message": "Make it easy to create dynamically updated ProxyLookup instances without subclassing", "committedDate": "2020-08-10T09:06:50Z", "type": "commit"}, {"oid": "2a4a18a201fec8b66c167eef012004e2c4be21f3", "url": "https://github.com/apache/netbeans/commit/2a4a18a201fec8b66c167eef012004e2c4be21f3", "message": "Make it easy to create dynamically updated ProxyLookup instances without subclassing", "committedDate": "2020-08-10T09:06:50Z", "type": "forcePushed"}]}