{"pr_number": 2575, "pr_title": "Open GraalVM sources out of the box", "pr_createdAt": "2020-12-03T08:41:55Z", "pr_url": "https://github.com/apache/netbeans/pull/2575", "timeline": [{"oid": "34339d45f3e7f4d9fb84524e1de0bdd8768b019e", "url": "https://github.com/apache/netbeans/commit/34339d45f3e7f4d9fb84524e1de0bdd8768b019e", "message": "Support for mx based projects", "committedDate": "2020-11-26T17:48:47Z", "type": "commit"}, {"oid": "dd51e1d98a089fcaecf940d42a74fa9824ee3a0c", "url": "https://github.com/apache/netbeans/commit/dd51e1d98a089fcaecf940d42a74fa9824ee3a0c", "message": "Include the java.mx.project module in the tests", "committedDate": "2020-12-05T18:24:20Z", "type": "commit"}, {"oid": "548a1bfb088fcfe6bbac655aab32f5ce7cb1e13a", "url": "https://github.com/apache/netbeans/commit/548a1bfb088fcfe6bbac655aab32f5ce7cb1e13a", "message": "Parsing is tested by the integration tests extensively", "committedDate": "2020-12-05T18:25:20Z", "type": "commit"}, {"oid": "977d1ebe416b5fa144d72319268ddec157617f89", "url": "https://github.com/apache/netbeans/commit/977d1ebe416b5fa144d72319268ddec157617f89", "message": "Integration test to verify behavior on vm-20.3.0 snapshot", "committedDate": "2020-12-05T18:27:13Z", "type": "commit"}, {"oid": "929536e7925b3b0ca97c44c33b710ff9718f0b54", "url": "https://github.com/apache/netbeans/commit/929536e7925b3b0ca97c44c33b710ff9718f0b54", "message": "More detailed project description", "committedDate": "2020-12-06T04:25:42Z", "type": "commit"}, {"oid": "352681f5080ae66bd0b82e63536aeb0473ba04fa", "url": "https://github.com/apache/netbeans/commit/352681f5080ae66bd0b82e63536aeb0473ba04fa", "message": "Adding header to the formatting setting", "committedDate": "2020-12-06T04:27:26Z", "type": "commit"}, {"oid": "f1fadbb07f51c560f2e47f4846e15eee1704a260", "url": "https://github.com/apache/netbeans/commit/f1fadbb07f51c560f2e47f4846e15eee1704a260", "message": "Reconstructing the core libraries with factory methods", "committedDate": "2020-12-06T05:40:14Z", "type": "commit"}, {"oid": "e91f719a198fcf451a3251ca8c58d998638faae0", "url": "https://github.com/apache/netbeans/commit/e91f719a198fcf451a3251ca8c58d998638faae0", "message": "Support for mx.*/suite.py pattern in ergonomics", "committedDate": "2020-12-06T06:32:33Z", "type": "commit"}, {"oid": "9987cbff8bb7a1244aa03bfb9624e378f92e8036", "url": "https://github.com/apache/netbeans/commit/9987cbff8bb7a1244aa03bfb9624e378f92e8036", "message": "Disabling check of Truffle suite due to frequent out of memory erros from javac", "committedDate": "2020-12-06T08:15:12Z", "type": "commit"}, {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "url": "https://github.com/apache/netbeans/commit/21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "message": "Up-to-date with current master", "committedDate": "2020-12-06T08:15:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzAzNDQzNQ==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r537034435", "bodyText": "I wonder - can we parse this at runtime from something? Like, maybe, mx/suite.py? It feels weird to have this information hardcoded.", "author": "jlahoda", "createdAt": "2020-12-06T13:02:00Z", "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/CoreSuite.java", "diffHunk": "@@ -0,0 +1,732 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary.Arch;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+\n+final class CoreSuite {\n+    private static final class MapOf<K,V> {\n+        private final Map<K,V> map = new HashMap<>();\n+\n+        MapOf<K, V> of(K k, V v) {\n+            map.put(k, v);\n+            return this;\n+        }\n+\n+\n+        Map<K,V> build() {\n+            return map;\n+        }\n+    }\n+\n+    private static <K,V> MapOf<K,V> mapOf(Class<K> keyClass, Class<V> valueClass) {\n+        return new MapOf<>();\n+    }\n+\n+    private static MxSuite createMxSuite(\n+        String defaultLicense,\n+        Map<String, MxDistribution> distributions,\n+        MxImports imports,\n+        Map<String, MxLibrary> jdkLibraries,\n+        Map<String, MxLibrary> libraries,\n+        String mxversion,\n+        String name,\n+        Map<String, MxProject> projects\n+    ) {\n+        return new MxSuite() {\n+            @Override\n+            public String mxversion() {\n+                return mxversion;\n+            }\n+\n+            @Override\n+            public String name() {\n+                return name;\n+            }\n+\n+            @Override\n+            public String defaultLicense() {\n+                return defaultLicense;\n+            }\n+\n+            @Override\n+            public Map<String, MxLibrary> libraries() {\n+                return libraries;\n+            }\n+\n+            @Override\n+            public Map<String, MxLibrary> jdklibraries() {\n+                return jdkLibraries;\n+            }\n+\n+            @Override\n+            public MxImports imports() {\n+                return imports;\n+            }\n+\n+            @Override\n+            public Map<String, MxProject> projects() {\n+                return projects;\n+            }\n+\n+            @Override\n+            public Map<String, MxDistribution> distributions() {\n+                return distributions;\n+            }\n+        };\n+    }\n+\n+    private static MxDistribution createMxDistribution(\n+        List<String> dependencies,\n+        List<String> distDependencies,\n+        List<String> exclude,\n+        List<String> strip\n+    ) {\n+        return new MxDistribution() {\n+            @Override\n+            public List<String> dependencies() {\n+                return dependencies;\n+            }\n+\n+            @Override\n+            public List<String> distDependencies() {\n+                return distDependencies;\n+            }\n+\n+            @Override\n+            public List<String> exclude() {\n+                return exclude;\n+            }\n+\n+            @Override\n+            public List<String> strip() {\n+                return strip;\n+            }\n+        };\n+    }\n+\n+    private static MxProject createMxProject(\n+        List<String> annotationProcessors,\n+        List<String> dependencies,\n+        String dir,\n+        String javaCompliance,\n+        List<String> sourceDirs,\n+        String subDir\n+    ) {\n+        return new MxProject() {\n+            @Override\n+            public String dir() {\n+                return dir;\n+            }\n+\n+            @Override\n+            public String subDir() {\n+                return subDir;\n+            }\n+\n+            @Override\n+            public List<String> sourceDirs() {\n+                return sourceDirs;\n+            }\n+\n+            @Override\n+            public List<String> dependencies() {\n+                return dependencies;\n+            }\n+\n+            @Override\n+            public List<String> annotationProcessors() {\n+                return annotationProcessors;\n+            }\n+\n+            @Override\n+            public String javaCompliance() {\n+                return javaCompliance;\n+            }\n+        };\n+    }\n+\n+    private static MxLibrary createMxLibrary(\n+        List<String> dependencies,\n+        Map<String, MxLibrary.Arch> osArch,\n+        String path,\n+        String sha1,\n+        List<String> urls\n+    ) {\n+        return new MxLibrary() {\n+            @Override\n+            public String sha1() {\n+                return sha1;\n+            }\n+\n+            @Override\n+            public List<String> urls() {\n+                return urls;\n+            }\n+\n+            @Override\n+            public Map<String, MxLibrary.Arch> os_arch() {\n+                return osArch;\n+            }\n+\n+            @Override\n+            public List<String> dependencies() {\n+                return dependencies;\n+            }\n+\n+            @Override\n+            public String path() {\n+                return path;\n+            }\n+\n+        };\n+    }\n+\n+    private static MxLibrary.Arch createArch(MxLibrary amd64) {\n+        return new MxLibrary.Arch() {\n+            @Override\n+            public MxLibrary amd64() {\n+                return amd64;\n+            }\n+        };\n+    }\n+\n+    static final MxSuite CORE_5_279_0;\n+    static {", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA1ODQxOQ==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r537058419", "bodyText": "That would require mx.mx/suite.py being around. While mx is needed for execution/debugging of tests, it is not needed for opening the projects and navigating the sources right now. However, to properly resolve \"standard mx libraries\" we need to have information about them. That is what this file provides.\nHaving the information here improves out of box experience. One can git clone https://github.com/oracle/graal and immediately open and inspect the sources.\nOf course, when new version of mx introduces new \"standard libraries\", we might need to release an update to this CoreSuite data. Possibly we could use this as default/fallback. Once mx is found/specified we could switch to its mx.mx/suite.py definitions.", "author": "JaroslavTulach", "createdAt": "2020-12-06T15:16:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzAzNDQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzAzNDk0OA==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r537034948", "bodyText": "What is the specific use of this file? Is it better to have it hardcoded, or read the version from mx?", "author": "jlahoda", "createdAt": "2020-12-06T13:04:38Z", "path": "java/java.mx.project/release/org.eclipse.jdt.core.prefs", "diffHunk": "@@ -0,0 +1,442 @@\n+# Licensed to the Apache Software Foundation (ASF) under one", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA3NzYyMQ==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538077621", "bodyText": "This file was added by @dbalek to support Eclipse Formatter by Benno.", "author": "JaroslavTulach", "createdAt": "2020-12-08T06:51:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzAzNDk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTQwNg==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538171406", "bodyText": "This seems to assume mx is on the IDE process'  PATH. Shouldn't it be configurable in Tools | Options, similar to maven/ant, especially when NB does not distribute mx ? If reasonable, I recommend to track it as JIRA enhancement.", "author": "sdedic", "createdAt": "2020-12-08T09:23:29Z", "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteActionProvider.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.awt.Toolkit;\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import org.netbeans.api.actions.Openable;\n+import org.netbeans.api.debugger.*;\n+import org.netbeans.api.debugger.jpda.ListeningDICookie;\n+import org.netbeans.api.extexecution.ExecutionDescriptor;\n+import org.netbeans.api.extexecution.ExecutionService;\n+import org.netbeans.api.extexecution.base.ProcessBuilder;\n+import org.netbeans.api.extexecution.print.ConvertedLine;\n+import org.netbeans.spi.project.ActionProvider;\n+import org.netbeans.spi.project.SingleMethod;\n+import org.openide.LifecycleManager;\n+import org.openide.cookies.LineCookie;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.text.Line;\n+import org.openide.util.Lookup;\n+import org.openide.util.NbBundle;\n+import org.openide.util.RequestProcessor;\n+import org.openide.windows.OutputEvent;\n+import org.openide.windows.OutputListener;\n+\n+final class SuiteActionProvider implements ActionProvider {\n+    private final SuiteProject prj;\n+\n+    SuiteActionProvider(SuiteProject prj) {\n+        this.prj = prj;\n+    }\n+\n+    @Override\n+    public String[] getSupportedActions() {\n+        return new String[] {\n+            ActionProvider.COMMAND_CLEAN,\n+            ActionProvider.COMMAND_BUILD,\n+            ActionProvider.COMMAND_COMPILE_SINGLE,\n+            ActionProvider.COMMAND_REBUILD,\n+            ActionProvider.COMMAND_TEST_SINGLE,\n+            ActionProvider.COMMAND_RUN_SINGLE,\n+            ActionProvider.COMMAND_DEBUG_TEST_SINGLE,\n+            ActionProvider.COMMAND_DEBUG_SINGLE,\n+            SingleMethod.COMMAND_DEBUG_SINGLE_METHOD,\n+            SingleMethod.COMMAND_RUN_SINGLE_METHOD,\n+        };\n+    }\n+\n+    @NbBundle.Messages({\n+        \"MSG_Clean=mx clean {0}\",\n+        \"MSG_Build=mx build {0}\",\n+        \"MSG_BuildOnly=mx build {0} --only {1}\",\n+        \"MSG_Rebuild=mx rebuild {0}\",\n+        \"MSG_Unittest=mx unittest {0}\",\n+    })\n+    @Override\n+    public void invokeAction(String action, Lookup context) throws IllegalArgumentException {\n+        FileObject fo = context.lookup(FileObject.class);\n+        String testSuffix = \"\";\n+        switch (action) {\n+            case ActionProvider.COMMAND_CLEAN:\n+                runMx(Bundle.MSG_Clean(prj.getName()), \"clean\"); // NOI18N\n+                break;\n+            case ActionProvider.COMMAND_BUILD:\n+                runMx(Bundle.MSG_Build(prj.getName()), \"build\"); // NOI18N\n+                break;\n+            case ActionProvider.COMMAND_REBUILD:\n+                runMx(Bundle.MSG_Rebuild(prj.getName()), \"build\"); // NOI18N\n+                break;\n+            case ActionProvider.COMMAND_COMPILE_SINGLE: {\n+                SuiteSources.Group grp = prj.getSources().findGroup(fo);\n+                if (grp == null) {\n+                    Toolkit.getDefaultToolkit().beep();\n+                    return;\n+                }\n+                final String name = grp.getDisplayName();\n+                runMx(Bundle.MSG_BuildOnly(prj.getName(), name), \"build\", \"--only\", name); // NOI18N\n+                break;\n+            }\n+            case SingleMethod.COMMAND_RUN_SINGLE_METHOD: {\n+                SingleMethod m = context.lookup(SingleMethod.class);\n+                if (m != null && fo == null) {\n+                    fo = m.getFile();\n+                    testSuffix = \"#\" + m.getMethodName();\n+                }\n+                // fallthrough\n+            }\n+            case ActionProvider.COMMAND_TEST_SINGLE:\n+            case ActionProvider.COMMAND_RUN_SINGLE:\n+                if (fo == null) {\n+                    Toolkit.getDefaultToolkit().beep();\n+                    return;\n+                }\n+                runMx(Bundle.MSG_Unittest(fo.getName()), \"unittest\", fo.getName() + testSuffix); // NOI18N\n+                break;\n+            case SingleMethod.COMMAND_DEBUG_SINGLE_METHOD: {\n+                SingleMethod m = context.lookup(SingleMethod.class);\n+                if (m != null && fo == null) {\n+                    fo = m.getFile();\n+                    testSuffix = \"#\" + m.getMethodName();\n+                }\n+                // fallthrough\n+            }\n+            case ActionProvider.COMMAND_DEBUG_TEST_SINGLE:\n+            case ActionProvider.COMMAND_DEBUG_SINGLE:\n+                if (fo == null) {\n+                    Toolkit.getDefaultToolkit().beep();\n+                    return;\n+                }\n+                ListeningDICookie ldic = ListeningDICookie.create(-1);\n+                Object obj = ldic.getArgs().get(\"port\"); // NOI18N\n+                DebuggerInfo di = DebuggerInfo.create(ListeningDICookie.ID, ldic);\n+                DebuggerEngine[] engines = { null };\n+                RequestProcessor.getDefault().post(() -> {\n+                    DebuggerEngine[] engs = DebuggerManager.getDebuggerManager().startDebugging(di);\n+                    engines[0] = engs[0];\n+                });\n+                int port = ldic.getPortNumber();\n+                runMx(Bundle.MSG_Unittest(fo.getName()), \"--attach\", \"\" + port, \"unittest\", fo.getName() + testSuffix); // NOI18N\n+                break;\n+            default:\n+                throw new UnsupportedOperationException(action);\n+        }\n+    }\n+\n+    private boolean runMx(String taskName, String... args) {\n+        final File suiteDir = FileUtil.toFile(prj.getProjectDirectory());\n+        if (!suiteDir.isDirectory()) {\n+            Toolkit.getDefaultToolkit().beep();\n+            return true;\n+        }\n+        LifecycleManager.getDefault().saveAll();\n+        ExecutionDescriptor descriptor = new ExecutionDescriptor()\n+                .frontWindow(true).controllable(true)\n+                .errConvertorFactory(() -> {\n+                    return (String line) -> {\n+                        String[] segments = line.split(\":\");\n+                        if (segments.length > 2) {\n+                            File src = new File(segments[0]);\n+                            if (src.exists()) {\n+                                int lineNumber = parseLineNumber(segments) - 1;\n+                                return Collections.singletonList(ConvertedLine.forText(line, new OutputListener() {\n+                                    @Override\n+                                    public void outputLineSelected(OutputEvent ev) {\n+                                        openLine(Line.ShowOpenType.NONE, Line.ShowVisibilityType.FRONT);\n+                                    }\n+\n+                                    @Override\n+                                    public void outputLineAction(OutputEvent ev) {\n+                                        openLine(Line.ShowOpenType.OPEN, Line.ShowVisibilityType.FOCUS);\n+                                    }\n+\n+                                    private boolean openLine(final Line.ShowOpenType openType, final Line.ShowVisibilityType visibilityType) throws IndexOutOfBoundsException {\n+                                        FileObject fo = FileUtil.toFileObject(src);\n+                                        if (fo != null) {\n+                                            Lookup lkp = fo.getLookup();\n+                                            final LineCookie lines = lkp.lookup(LineCookie.class);\n+                                            if (lines != null) {\n+                                                Line open = lines.getLineSet().getOriginal(lineNumber);\n+                                                if (open != null) {\n+                                                    open.show(openType, visibilityType);\n+                                                    return true;\n+                                                }\n+                                            }\n+                                            Openable open = lkp.lookup(Openable.class);\n+                                            if (open != null) {\n+                                                open.open();\n+                                            } else {\n+                                                Toolkit.getDefaultToolkit().beep();\n+                                            }\n+                                        }\n+                                        return false;\n+                                    }\n+\n+                                    @Override\n+                                    public void outputLineCleared(OutputEvent ev) {\n+                                    }\n+                                }));\n+                            }\n+                        }\n+                        return null;\n+                    };\n+                });\n+        ProcessBuilder processBuilder = ProcessBuilder.getLocal();\n+        processBuilder.setWorkingDirectory(suiteDir.getPath());\n+        processBuilder.setExecutable(\"mx\"); // NOI18N", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3NTA0Mg==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544075042", "bodyText": "True, the UI should be improved in the future. Recorded as NETBEANS-5158.", "author": "JaroslavTulach", "createdAt": "2020-12-16T07:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTUzMA==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538171530", "bodyText": "Maybe this exclusion is worth a comment in source; why the exclusion is needed.", "author": "sdedic", "createdAt": "2020-12-08T09:23:39Z", "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteClassPathProvider.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.classpath.GlobalPathRegistry;\n+import org.netbeans.api.java.classpath.JavaClassPathConstants;\n+import org.netbeans.api.java.platform.JavaPlatformManager;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery.Result;\n+import org.netbeans.spi.java.classpath.ClassPathProvider;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.AnnotationProcessingQueryImplementation;\n+import org.netbeans.spi.project.ui.ProjectOpenedHook;\n+import org.openide.filesystems.FileObject;\n+\n+final class SuiteClassPathProvider extends ProjectOpenedHook implements ClassPathProvider, AnnotationProcessingQueryImplementation {\n+    private final SuiteProject project;\n+    private final ClassPath bootCP;\n+\n+    public SuiteClassPathProvider(SuiteProject project) {\n+        this.project = project;\n+        List<ClassPath.Entry> entries = JavaPlatformManager.getDefault().getDefaultPlatform().getBootstrapLibraries().entries();\n+        List<URL> roots = new ArrayList<>();\n+        for (ClassPath.Entry entry : entries) {\n+            URL root = entry.getURL();\n+            if (root.getPath().contains(\"/graal-sdk.jar\")) {", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3NjM4OQ==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544076389", "bodyText": "Unless I am mistaken this is because GraalVM (based on JDK8) contains these JARs on boot class path and we want to avoid them and rather use JARs built from the project sources.", "author": "JaroslavTulach", "createdAt": "2020-12-16T07:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTU3OQ==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538171579", "bodyText": "I am not sure about this fixed bootclasspath, as there may be different JAVA_HOME defined in ~/.mx/env or mx.{projectname}/env", "author": "sdedic", "createdAt": "2020-12-08T09:23:42Z", "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteClassPathProvider.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.classpath.GlobalPathRegistry;\n+import org.netbeans.api.java.classpath.JavaClassPathConstants;\n+import org.netbeans.api.java.platform.JavaPlatformManager;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery.Result;\n+import org.netbeans.spi.java.classpath.ClassPathProvider;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.AnnotationProcessingQueryImplementation;\n+import org.netbeans.spi.project.ui.ProjectOpenedHook;\n+import org.openide.filesystems.FileObject;\n+\n+final class SuiteClassPathProvider extends ProjectOpenedHook implements ClassPathProvider, AnnotationProcessingQueryImplementation {\n+    private final SuiteProject project;\n+    private final ClassPath bootCP;\n+\n+    public SuiteClassPathProvider(SuiteProject project) {\n+        this.project = project;\n+        List<ClassPath.Entry> entries = JavaPlatformManager.getDefault().getDefaultPlatform().getBootstrapLibraries().entries();\n+        List<URL> roots = new ArrayList<>();\n+        for (ClassPath.Entry entry : entries) {\n+            URL root = entry.getURL();\n+            if (root.getPath().contains(\"/graal-sdk.jar\")) {\n+                continue;\n+            }\n+            if (root.getPath().contains(\"/graaljs-scriptengine.jar\")) {\n+                continue;\n+            }\n+            if (root.getPath().contains(\"/graal-sdk.src.zip\")) {\n+                continue;\n+            }\n+            roots.add(entry.getURL());\n+        }\n+        this.bootCP = ClassPathSupport.createClassPath(roots.toArray(new URL[0]));\n+    }\n+\n+    @Override\n+    public ClassPath findClassPath(FileObject file, String type) {\n+        SuiteSources.Group g = project.getSources().findGroup(file);\n+        if (g == null) {\n+            return null;\n+        }\n+        if (ClassPath.BOOT.equals(type)) {\n+            return bootCP;", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3ODgyOA==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544078828", "bodyText": "Let's put this on TODO list: NETBEANS-5159. If you face a buggy behavior, please describe reproducer there and turn that issue into bug.", "author": "JaroslavTulach", "createdAt": "2020-12-16T07:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTc5Mg==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538171792", "bodyText": "Silly question, but why just the 1st group ?", "author": "sdedic", "createdAt": "2020-12-08T09:23:59Z", "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMTMxMw==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544101313", "bodyText": "Running the tests I haven't seen a case where there was more groups than firstGroup. But I don't want to replace it with assert now.", "author": "JaroslavTulach", "createdAt": "2020-12-16T08:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTgzNw==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538171837", "bodyText": "Is the 2-level parent limit hardocded in mx as well ?", "author": "sdedic", "createdAt": "2020-12-08T09:24:03Z", "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4MTg0NA==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544081844", "bodyText": "The existing sources that I am aware of are find with 2-level limit. I am not sure if the 2-level parent limit is in the {{mx}} itself or not. Scanning more deeply might have negative effect on performance. Let's leave it as it is unless\n@gilles-duboscq wants to comment.", "author": "JaroslavTulach", "createdAt": "2020-12-16T07:50:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwNzU2MQ==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544107561", "bodyText": "There is indeed a 2-level limit in mx: starting from the directory in which the various repositories are checked out, the \"importer\" specifies if the imported suite is found at depth 1 or 2, no other depth can be specified (default is depth 1 and a \"subdir\" : True attribute switches the depth to 2).", "author": "gilles-duboscq", "createdAt": "2020-12-16T08:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTk0Ng==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538171946", "bodyText": "no unit tests reported ?", "author": "sdedic", "createdAt": "2020-12-08T09:24:12Z", "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject root, String name) throws IllegalArgumentException {\n+        FileObject impDir = root.getFileObject(name);\n+        if (impDir != null) {\n+            try {\n+                Project impPrj = ProjectManager.getDefault().findProject(impDir);\n+                return impPrj == null ? null : impPrj.getLookup().lookup(SuiteSources.class);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceGroup[] getSourceGroups(String string) {\n+        return groups();\n+    }\n+\n+    Group[] groups() {\n+        return groups.toArray(new Group[0]);\n+    }\n+\n+    Group findGroup(FileObject fo) {\n+        for (Group g : groups) {\n+            if (g.contains(fo)) {\n+                return g;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void addChangeListener(ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public void removeChangeListener(ChangeListener cl) {\n+    }\n+\n+    private static FileObject findPrjDir(FileObject dir, String prjName, MxProject prj) {\n+        if (dir == null) {\n+            return null;\n+        }\n+        if (prj.dir() != null) {\n+            return dir.getFileObject(prj.dir());\n+        }\n+        if (prj.subDir() != null) {\n+            dir = dir.getFileObject(prj.subDir());\n+            if (dir == null) {\n+                return null;\n+            }\n+        }\n+        return dir.getFileObject(prjName);\n+    }\n+\n+    private Collection<Dep> transitiveDeps(Dep current, Map<String, Dep> fill) {\n+        current.owner().computeTransitiveDeps();\n+        final Collection<Dep> currentAllDeps = current.allDeps();\n+        if (currentAllDeps == Collections.<Dep>emptySet()) {\n+            throw new IllegalStateException(\"Cyclic dep on \" + current.getName());\n+        } else if (currentAllDeps != null) {\n+            return currentAllDeps;\n+        }\n+        current.setAllDeps(Collections.emptySet());\n+        TreeSet<Dep> computing = new TreeSet<>();\n+        computing.add(current);\n+        for (String depName : current.depNames()) {\n+            Dep dep = fill.get(depName);\n+            if (dep == null) {\n+                int colon = depName.lastIndexOf(':');\n+                dep = fill.get(depName.substring(colon + 1));\n+                if (dep == null) {\n+                    LOG.log(Level.INFO, \"dep not found: {0}\", depName);\n+                    continue;\n+                }\n+            }\n+            Collection<Dep> allDeps = transitiveDeps(dep, fill);\n+            computing.addAll(allDeps);\n+        }\n+        current.setAllDeps(computing);\n+        return computing;\n+    }\n+\n+    private static void registerLibs(Map<String, MxLibrary> collect, String prefix, Map<String, MxLibrary> libraries) {\n+        for (Map.Entry<String, MxLibrary> entry : libraries.entrySet()) {\n+            String key = entry.getKey();\n+            MxLibrary lib = entry.getValue();\n+            if (prefix == null) {\n+                collect.put(key, lib);\n+            } else {\n+                collect.put(prefix + \":\" + key, lib);\n+            }\n+        }\n+    }\n+\n+    private void registerDeps(String prefix, Map<String, Dep> fillDeps) {\n+        for (Library library : libraries) {\n+            fillDeps.put(prefix + \":\" + library.getName(), library);\n+        }\n+        for (Dist d : distributions) {\n+            fillDeps.put(prefix + \":\" + d.getName(), d);\n+        }\n+        for (Map.Entry<String, SuiteSources> s : imported.entrySet()) {\n+            s.getValue().registerDeps(s.getKey(), fillDeps);\n+        }\n+    }\n+\n+    @Override\n+    public Group findBinaryRoots2(URL url) {\n+        final FileObject srcFo = URLMapper.findFileObject(url);\n+        for (Group group : this.groups) {\n+            if (group.contains(srcFo)) {\n+                return group;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public URL[] computeRoots(Group group) {\n+        if (group.binDir != null) {\n+            return new URL[] { group.binDir.toURL() };\n+        } else {\n+            return new URL[0];\n+        }\n+    }\n+\n+    @Override\n+    public boolean computePreferBinaries(Group result) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void computeChangeListener(Group result, boolean bln, ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public SourceForBinaryQueryImplementation2.Result findSourceRoots2(URL url) {\n+        this.computeTransitiveDeps();\n+        for (Dist dist : this.distributions) {\n+            URL jar;\n+            try {\n+                jar = dist.getJarRoot();\n+                if (jar == null) {\n+                    continue;\n+                }\n+            } catch (MalformedURLException ok) {\n+                continue;\n+            }\n+            if (jar.equals(url)) {\n+                List<FileObject> roots = new ArrayList<>();\n+                for (Group d : dist.getContributingGroups()) {\n+                    roots.add(d.srcDir);\n+                    roots.add(d.srcGenDir);\n+                }\n+                return new ImmutableResult(roots.toArray(new FileObject[roots.size()]));\n+            }\n+        }\n+        for (Group group : this.groups) {\n+            if (group.binDir != null && group.binDir.toURL().equals(url)) {\n+                return new ImmutableResult(group.srcDir, group.srcGenDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceForBinaryQuery.Result findSourceRoots(URL url) {\n+        return findSourceRoots2(url);\n+    }\n+\n+    final Iterable<File> jdks() {\n+        Set<File> jdks = new LinkedHashSet<>();\n+        String home = System.getProperty(\"user.home\");\n+        if (home != null) {\n+            File userEnv = new File(new File(new File(home), \".mx\"), \"env\");\n+            findJdksInEnv(jdks, userEnv);\n+        }\n+        FileObject suiteEnv = dir.getFileObject(\"mx.\" + dir.getNameExt() + \"/env\");\n+        if (suiteEnv != null) {\n+            findJdksInEnv(jdks, FileUtil.toFile(suiteEnv));\n+        }\n+\n+        String javaHomeEnv = System.getenv(\"JAVA_HOME\");\n+        if (javaHomeEnv != null) {\n+            jdks.add(new File(javaHomeEnv));\n+        }\n+        String javaHomeProp = System.getProperty(\"java.home\");\n+        if (javaHomeProp != null) {\n+            jdks.add(new File(javaHomeProp));\n+        }\n+        return jdks;\n+    }\n+\n+    private void findJdksInEnv(Set<File> jdks, File env) {\n+        if (env == null || !env.isFile()) {\n+            return;\n+        }\n+        try (final FileInputStream is = new FileInputStream(env)) {\n+            Properties p = new Properties();\n+            p.load(is);\n+\n+            String javaHome = p.getProperty(\"JAVA_HOME\");\n+            if (javaHome != null) {\n+                jdks.add(new File(javaHome));\n+            }\n+\n+            String extraJavaHomes = p.getProperty(\"EXTRA_JAVA_HOMES\");\n+            if (extraJavaHomes != null) {\n+                for (String extraHome : extraJavaHomes.split(File.pathSeparator)) {\n+                    jdks.add(new File(extraHome));\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    @Override\n+    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject fo) {\n+        Group g = findGroup(fo);\n+        if (g == null) {\n+            return null;\n+        }\n+        return new SourceLevelQueryImplementation2.Result2() {\n+            @Override\n+            public SourceLevelQuery.Profile getProfile() {\n+                return SourceLevelQuery.Profile.DEFAULT;\n+            }\n+\n+            @Override\n+            public String getSourceLevel() {\n+                return g.getCompliance().getSourceLevel();\n+            }\n+\n+            @Override\n+            public void addChangeListener(ChangeListener cl) {\n+            }\n+\n+            @Override\n+            public void removeChangeListener(ChangeListener cl) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Set<? extends Project> getSubprojects() {\n+        Set<Project> prjs = new HashSet<>();\n+        for (SuiteSources imp : imported.values()) {\n+            prjs.add(imp.prj);\n+        }\n+        return prjs;\n+    }\n+\n+    @Override\n+    public URL[] findUnitTests(FileObject fo) {\n+        return new URL[0];", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA5NDQzOA==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544094438", "bodyText": "This is one of the reasons why special mx support is desirable. Typical NetBeans projects assume two kinds of directories - main and test. This is not true for mx there is no association of main code and test code. Tests are regular source roots with classes annotated by @Test. As such this code returns new URL[0].\nFeel free to improve it, if you know how.", "author": "JaroslavTulach", "createdAt": "2020-12-16T08:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjA4Nw==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538172087", "bodyText": "Maybe an useless parameter", "author": "sdedic", "createdAt": "2020-12-08T09:24:22Z", "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject root, String name) throws IllegalArgumentException {\n+        FileObject impDir = root.getFileObject(name);\n+        if (impDir != null) {\n+            try {\n+                Project impPrj = ProjectManager.getDefault().findProject(impDir);\n+                return impPrj == null ? null : impPrj.getLookup().lookup(SuiteSources.class);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceGroup[] getSourceGroups(String string) {\n+        return groups();\n+    }\n+\n+    Group[] groups() {\n+        return groups.toArray(new Group[0]);\n+    }\n+\n+    Group findGroup(FileObject fo) {\n+        for (Group g : groups) {\n+            if (g.contains(fo)) {\n+                return g;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void addChangeListener(ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public void removeChangeListener(ChangeListener cl) {\n+    }\n+\n+    private static FileObject findPrjDir(FileObject dir, String prjName, MxProject prj) {\n+        if (dir == null) {\n+            return null;\n+        }\n+        if (prj.dir() != null) {\n+            return dir.getFileObject(prj.dir());\n+        }\n+        if (prj.subDir() != null) {\n+            dir = dir.getFileObject(prj.subDir());\n+            if (dir == null) {\n+                return null;\n+            }\n+        }\n+        return dir.getFileObject(prjName);\n+    }\n+\n+    private Collection<Dep> transitiveDeps(Dep current, Map<String, Dep> fill) {\n+        current.owner().computeTransitiveDeps();\n+        final Collection<Dep> currentAllDeps = current.allDeps();\n+        if (currentAllDeps == Collections.<Dep>emptySet()) {\n+            throw new IllegalStateException(\"Cyclic dep on \" + current.getName());\n+        } else if (currentAllDeps != null) {\n+            return currentAllDeps;\n+        }\n+        current.setAllDeps(Collections.emptySet());\n+        TreeSet<Dep> computing = new TreeSet<>();\n+        computing.add(current);\n+        for (String depName : current.depNames()) {\n+            Dep dep = fill.get(depName);\n+            if (dep == null) {\n+                int colon = depName.lastIndexOf(':');\n+                dep = fill.get(depName.substring(colon + 1));\n+                if (dep == null) {\n+                    LOG.log(Level.INFO, \"dep not found: {0}\", depName);\n+                    continue;\n+                }\n+            }\n+            Collection<Dep> allDeps = transitiveDeps(dep, fill);\n+            computing.addAll(allDeps);\n+        }\n+        current.setAllDeps(computing);\n+        return computing;\n+    }\n+\n+    private static void registerLibs(Map<String, MxLibrary> collect, String prefix, Map<String, MxLibrary> libraries) {\n+        for (Map.Entry<String, MxLibrary> entry : libraries.entrySet()) {\n+            String key = entry.getKey();\n+            MxLibrary lib = entry.getValue();\n+            if (prefix == null) {\n+                collect.put(key, lib);\n+            } else {\n+                collect.put(prefix + \":\" + key, lib);\n+            }\n+        }\n+    }\n+\n+    private void registerDeps(String prefix, Map<String, Dep> fillDeps) {\n+        for (Library library : libraries) {\n+            fillDeps.put(prefix + \":\" + library.getName(), library);\n+        }\n+        for (Dist d : distributions) {\n+            fillDeps.put(prefix + \":\" + d.getName(), d);\n+        }\n+        for (Map.Entry<String, SuiteSources> s : imported.entrySet()) {\n+            s.getValue().registerDeps(s.getKey(), fillDeps);\n+        }\n+    }\n+\n+    @Override\n+    public Group findBinaryRoots2(URL url) {\n+        final FileObject srcFo = URLMapper.findFileObject(url);\n+        for (Group group : this.groups) {\n+            if (group.contains(srcFo)) {\n+                return group;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public URL[] computeRoots(Group group) {\n+        if (group.binDir != null) {\n+            return new URL[] { group.binDir.toURL() };\n+        } else {\n+            return new URL[0];\n+        }\n+    }\n+\n+    @Override\n+    public boolean computePreferBinaries(Group result) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void computeChangeListener(Group result, boolean bln, ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public SourceForBinaryQueryImplementation2.Result findSourceRoots2(URL url) {\n+        this.computeTransitiveDeps();\n+        for (Dist dist : this.distributions) {\n+            URL jar;\n+            try {\n+                jar = dist.getJarRoot();\n+                if (jar == null) {\n+                    continue;\n+                }\n+            } catch (MalformedURLException ok) {\n+                continue;\n+            }\n+            if (jar.equals(url)) {\n+                List<FileObject> roots = new ArrayList<>();\n+                for (Group d : dist.getContributingGroups()) {\n+                    roots.add(d.srcDir);\n+                    roots.add(d.srcGenDir);\n+                }\n+                return new ImmutableResult(roots.toArray(new FileObject[roots.size()]));\n+            }\n+        }\n+        for (Group group : this.groups) {\n+            if (group.binDir != null && group.binDir.toURL().equals(url)) {\n+                return new ImmutableResult(group.srcDir, group.srcGenDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceForBinaryQuery.Result findSourceRoots(URL url) {\n+        return findSourceRoots2(url);\n+    }\n+\n+    final Iterable<File> jdks() {\n+        Set<File> jdks = new LinkedHashSet<>();\n+        String home = System.getProperty(\"user.home\");\n+        if (home != null) {\n+            File userEnv = new File(new File(new File(home), \".mx\"), \"env\");\n+            findJdksInEnv(jdks, userEnv);\n+        }\n+        FileObject suiteEnv = dir.getFileObject(\"mx.\" + dir.getNameExt() + \"/env\");\n+        if (suiteEnv != null) {\n+            findJdksInEnv(jdks, FileUtil.toFile(suiteEnv));\n+        }\n+\n+        String javaHomeEnv = System.getenv(\"JAVA_HOME\");\n+        if (javaHomeEnv != null) {\n+            jdks.add(new File(javaHomeEnv));\n+        }\n+        String javaHomeProp = System.getProperty(\"java.home\");\n+        if (javaHomeProp != null) {\n+            jdks.add(new File(javaHomeProp));\n+        }\n+        return jdks;\n+    }\n+\n+    private void findJdksInEnv(Set<File> jdks, File env) {\n+        if (env == null || !env.isFile()) {\n+            return;\n+        }\n+        try (final FileInputStream is = new FileInputStream(env)) {\n+            Properties p = new Properties();\n+            p.load(is);\n+\n+            String javaHome = p.getProperty(\"JAVA_HOME\");\n+            if (javaHome != null) {\n+                jdks.add(new File(javaHome));\n+            }\n+\n+            String extraJavaHomes = p.getProperty(\"EXTRA_JAVA_HOMES\");\n+            if (extraJavaHomes != null) {\n+                for (String extraHome : extraJavaHomes.split(File.pathSeparator)) {\n+                    jdks.add(new File(extraHome));\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    @Override\n+    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject fo) {\n+        Group g = findGroup(fo);\n+        if (g == null) {\n+            return null;\n+        }\n+        return new SourceLevelQueryImplementation2.Result2() {\n+            @Override\n+            public SourceLevelQuery.Profile getProfile() {\n+                return SourceLevelQuery.Profile.DEFAULT;\n+            }\n+\n+            @Override\n+            public String getSourceLevel() {\n+                return g.getCompliance().getSourceLevel();\n+            }\n+\n+            @Override\n+            public void addChangeListener(ChangeListener cl) {\n+            }\n+\n+            @Override\n+            public void removeChangeListener(ChangeListener cl) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Set<? extends Project> getSubprojects() {\n+        Set<Project> prjs = new HashSet<>();\n+        for (SuiteSources imp : imported.values()) {\n+            prjs.add(imp.prj);\n+        }\n+        return prjs;\n+    }\n+\n+    @Override\n+    public URL[] findUnitTests(FileObject fo) {\n+        return new URL[0];\n+    }\n+\n+    @Override\n+    public URL[] findSources(FileObject fo) {\n+        Group g = findGroup(fo);\n+        return g == null ? new URL[0] : new URL[] { g.getRootFolder().toURL() };\n+    }\n+\n+    static interface Dep extends Comparable<Dep> {\n+        String getName();\n+\n+        Collection<String> depNames();\n+\n+        Collection<Dep> allDeps();\n+\n+        void setAllDeps(Collection<Dep> set);\n+\n+        @Override\n+        public default int compareTo(Dep o) {\n+            return getName().compareTo(o.getName());\n+        }\n+\n+        SuiteSources owner();\n+    }\n+\n+    final class Dist implements Dep, FlaggedClassPathImplementation {\n+        final String name;\n+        final MxDistribution dist;\n+        Collection<Dep> allDeps;\n+        private final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        private Boolean exists;\n+        private Collection<Group> groups;\n+\n+        public Dist(String name, MxDistribution dist) {\n+            this.name = name;\n+            this.dist = dist;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            Set<String> deps = new TreeSet<>();\n+            deps.addAll(dist.distDependencies());\n+            deps.addAll(dist.exclude());\n+            return deps;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return this.allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return this.name;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        private FileObject getJar(boolean ignore) {", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA5MTMzOQ==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544091339", "bodyText": "Done in 3933d30", "author": "JaroslavTulach", "createdAt": "2020-12-16T08:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjE2Mg==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538172162", "bodyText": "processTransDeps computes transitive deps on d.owner(), isn't it computed 2nd time here for all deps not just those used in classpath construction ?", "author": "sdedic", "createdAt": "2020-12-08T09:24:29Z", "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject root, String name) throws IllegalArgumentException {\n+        FileObject impDir = root.getFileObject(name);\n+        if (impDir != null) {\n+            try {\n+                Project impPrj = ProjectManager.getDefault().findProject(impDir);\n+                return impPrj == null ? null : impPrj.getLookup().lookup(SuiteSources.class);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceGroup[] getSourceGroups(String string) {\n+        return groups();\n+    }\n+\n+    Group[] groups() {\n+        return groups.toArray(new Group[0]);\n+    }\n+\n+    Group findGroup(FileObject fo) {\n+        for (Group g : groups) {\n+            if (g.contains(fo)) {\n+                return g;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void addChangeListener(ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public void removeChangeListener(ChangeListener cl) {\n+    }\n+\n+    private static FileObject findPrjDir(FileObject dir, String prjName, MxProject prj) {\n+        if (dir == null) {\n+            return null;\n+        }\n+        if (prj.dir() != null) {\n+            return dir.getFileObject(prj.dir());\n+        }\n+        if (prj.subDir() != null) {\n+            dir = dir.getFileObject(prj.subDir());\n+            if (dir == null) {\n+                return null;\n+            }\n+        }\n+        return dir.getFileObject(prjName);\n+    }\n+\n+    private Collection<Dep> transitiveDeps(Dep current, Map<String, Dep> fill) {\n+        current.owner().computeTransitiveDeps();\n+        final Collection<Dep> currentAllDeps = current.allDeps();\n+        if (currentAllDeps == Collections.<Dep>emptySet()) {\n+            throw new IllegalStateException(\"Cyclic dep on \" + current.getName());\n+        } else if (currentAllDeps != null) {\n+            return currentAllDeps;\n+        }\n+        current.setAllDeps(Collections.emptySet());\n+        TreeSet<Dep> computing = new TreeSet<>();\n+        computing.add(current);\n+        for (String depName : current.depNames()) {\n+            Dep dep = fill.get(depName);\n+            if (dep == null) {\n+                int colon = depName.lastIndexOf(':');\n+                dep = fill.get(depName.substring(colon + 1));\n+                if (dep == null) {\n+                    LOG.log(Level.INFO, \"dep not found: {0}\", depName);\n+                    continue;\n+                }\n+            }\n+            Collection<Dep> allDeps = transitiveDeps(dep, fill);\n+            computing.addAll(allDeps);\n+        }\n+        current.setAllDeps(computing);\n+        return computing;\n+    }\n+\n+    private static void registerLibs(Map<String, MxLibrary> collect, String prefix, Map<String, MxLibrary> libraries) {\n+        for (Map.Entry<String, MxLibrary> entry : libraries.entrySet()) {\n+            String key = entry.getKey();\n+            MxLibrary lib = entry.getValue();\n+            if (prefix == null) {\n+                collect.put(key, lib);\n+            } else {\n+                collect.put(prefix + \":\" + key, lib);\n+            }\n+        }\n+    }\n+\n+    private void registerDeps(String prefix, Map<String, Dep> fillDeps) {\n+        for (Library library : libraries) {\n+            fillDeps.put(prefix + \":\" + library.getName(), library);\n+        }\n+        for (Dist d : distributions) {\n+            fillDeps.put(prefix + \":\" + d.getName(), d);\n+        }\n+        for (Map.Entry<String, SuiteSources> s : imported.entrySet()) {\n+            s.getValue().registerDeps(s.getKey(), fillDeps);\n+        }\n+    }\n+\n+    @Override\n+    public Group findBinaryRoots2(URL url) {\n+        final FileObject srcFo = URLMapper.findFileObject(url);\n+        for (Group group : this.groups) {\n+            if (group.contains(srcFo)) {\n+                return group;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public URL[] computeRoots(Group group) {\n+        if (group.binDir != null) {\n+            return new URL[] { group.binDir.toURL() };\n+        } else {\n+            return new URL[0];\n+        }\n+    }\n+\n+    @Override\n+    public boolean computePreferBinaries(Group result) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void computeChangeListener(Group result, boolean bln, ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public SourceForBinaryQueryImplementation2.Result findSourceRoots2(URL url) {\n+        this.computeTransitiveDeps();\n+        for (Dist dist : this.distributions) {\n+            URL jar;\n+            try {\n+                jar = dist.getJarRoot();\n+                if (jar == null) {\n+                    continue;\n+                }\n+            } catch (MalformedURLException ok) {\n+                continue;\n+            }\n+            if (jar.equals(url)) {\n+                List<FileObject> roots = new ArrayList<>();\n+                for (Group d : dist.getContributingGroups()) {\n+                    roots.add(d.srcDir);\n+                    roots.add(d.srcGenDir);\n+                }\n+                return new ImmutableResult(roots.toArray(new FileObject[roots.size()]));\n+            }\n+        }\n+        for (Group group : this.groups) {\n+            if (group.binDir != null && group.binDir.toURL().equals(url)) {\n+                return new ImmutableResult(group.srcDir, group.srcGenDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceForBinaryQuery.Result findSourceRoots(URL url) {\n+        return findSourceRoots2(url);\n+    }\n+\n+    final Iterable<File> jdks() {\n+        Set<File> jdks = new LinkedHashSet<>();\n+        String home = System.getProperty(\"user.home\");\n+        if (home != null) {\n+            File userEnv = new File(new File(new File(home), \".mx\"), \"env\");\n+            findJdksInEnv(jdks, userEnv);\n+        }\n+        FileObject suiteEnv = dir.getFileObject(\"mx.\" + dir.getNameExt() + \"/env\");\n+        if (suiteEnv != null) {\n+            findJdksInEnv(jdks, FileUtil.toFile(suiteEnv));\n+        }\n+\n+        String javaHomeEnv = System.getenv(\"JAVA_HOME\");\n+        if (javaHomeEnv != null) {\n+            jdks.add(new File(javaHomeEnv));\n+        }\n+        String javaHomeProp = System.getProperty(\"java.home\");\n+        if (javaHomeProp != null) {\n+            jdks.add(new File(javaHomeProp));\n+        }\n+        return jdks;\n+    }\n+\n+    private void findJdksInEnv(Set<File> jdks, File env) {\n+        if (env == null || !env.isFile()) {\n+            return;\n+        }\n+        try (final FileInputStream is = new FileInputStream(env)) {\n+            Properties p = new Properties();\n+            p.load(is);\n+\n+            String javaHome = p.getProperty(\"JAVA_HOME\");\n+            if (javaHome != null) {\n+                jdks.add(new File(javaHome));\n+            }\n+\n+            String extraJavaHomes = p.getProperty(\"EXTRA_JAVA_HOMES\");\n+            if (extraJavaHomes != null) {\n+                for (String extraHome : extraJavaHomes.split(File.pathSeparator)) {\n+                    jdks.add(new File(extraHome));\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    @Override\n+    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject fo) {\n+        Group g = findGroup(fo);\n+        if (g == null) {\n+            return null;\n+        }\n+        return new SourceLevelQueryImplementation2.Result2() {\n+            @Override\n+            public SourceLevelQuery.Profile getProfile() {\n+                return SourceLevelQuery.Profile.DEFAULT;\n+            }\n+\n+            @Override\n+            public String getSourceLevel() {\n+                return g.getCompliance().getSourceLevel();\n+            }\n+\n+            @Override\n+            public void addChangeListener(ChangeListener cl) {\n+            }\n+\n+            @Override\n+            public void removeChangeListener(ChangeListener cl) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Set<? extends Project> getSubprojects() {\n+        Set<Project> prjs = new HashSet<>();\n+        for (SuiteSources imp : imported.values()) {\n+            prjs.add(imp.prj);\n+        }\n+        return prjs;\n+    }\n+\n+    @Override\n+    public URL[] findUnitTests(FileObject fo) {\n+        return new URL[0];\n+    }\n+\n+    @Override\n+    public URL[] findSources(FileObject fo) {\n+        Group g = findGroup(fo);\n+        return g == null ? new URL[0] : new URL[] { g.getRootFolder().toURL() };\n+    }\n+\n+    static interface Dep extends Comparable<Dep> {\n+        String getName();\n+\n+        Collection<String> depNames();\n+\n+        Collection<Dep> allDeps();\n+\n+        void setAllDeps(Collection<Dep> set);\n+\n+        @Override\n+        public default int compareTo(Dep o) {\n+            return getName().compareTo(o.getName());\n+        }\n+\n+        SuiteSources owner();\n+    }\n+\n+    final class Dist implements Dep, FlaggedClassPathImplementation {\n+        final String name;\n+        final MxDistribution dist;\n+        Collection<Dep> allDeps;\n+        private final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        private Boolean exists;\n+        private Collection<Group> groups;\n+\n+        public Dist(String name, MxDistribution dist) {\n+            this.name = name;\n+            this.dist = dist;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            Set<String> deps = new TreeSet<>();\n+            deps.addAll(dist.distDependencies());\n+            deps.addAll(dist.exclude());\n+            return deps;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return this.allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return this.name;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        private FileObject getJar(boolean ignore) {\n+            if (SuiteSources.this.dir == null) {\n+                return null;\n+            }\n+            FileObject dists = SuiteSources.this.dir.getFileObject(\"mxbuild/dists\");\n+            if (dists == null) {\n+                return null;\n+            }\n+            List<FileObject> dist = Arrays.stream(dists.getChildren()).filter((fo) -> fo.isFolder() && fo.getName().startsWith(\"jdk\")).collect(Collectors.toList());\n+            dist.sort((fo1, fo2) -> fo2.getName().compareTo(fo1.getName()));\n+            for (FileObject jdkDir : dist) {\n+                FileObject jar = jdkDir.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+                if (jar != null) {\n+                    return jar;\n+                }\n+            }\n+            FileObject jar = dists.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+            if (jar != null) {\n+                return jar;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public List<? extends PathResourceImplementation> getResources() {\n+            computeTransitiveDeps();\n+            FileObject jar = getJar(exists == null);\n+            final boolean existsNow = jar != null && jar.isData();\n+            if (exists == null) {\n+                exists = existsNow;\n+            } else {\n+                if (exists != existsNow) {\n+                    exists = existsNow;\n+                    support.firePropertyChange(PROP_FLAGS, !exists, (boolean) exists);\n+                }\n+            }\n+            if (jar != null) {\n+                PathResourceImplementation res;\n+                try {\n+                    res = ClassPathSupport.createResource(getJarRoot());\n+                    return Collections.singletonList(res);\n+                } catch (MalformedURLException ex) {\n+                    // OK\n+                }\n+            }\n+            return Collections.emptyList();\n+        }\n+\n+        private URL getJarRoot() throws MalformedURLException {\n+            FileObject jar = getJar(true);\n+            if (jar != null) {\n+                return new URL(\"jar:\" + jar.toURL() + \"!/\");\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener pl) {\n+            support.addPropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener pl) {\n+            support.removePropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+\n+        private void computeSourceRoots(Map<String, Dep> collectedDeps) {\n+            if (groups != null) {\n+                return;\n+            }\n+            Set<Group> contributingGroups = new LinkedHashSet<>();\n+            for (String d : this.dist.dependencies()) {\n+                Dep dep = collectedDeps.get(d);\n+                if (dep == null || dep.allDeps() == null) {\n+                    continue;\n+                }\n+                for (Dep d2 : dep.allDeps()) {\n+                    if (d2 instanceof Group) {\n+                        contributingGroups.add((Group) d2);\n+                    }\n+                }\n+            }\n+            for (String d : this.dist.distDependencies()) {\n+                final Dep anyDep = collectedDeps.get(d);\n+                if (anyDep instanceof Dist) {\n+                    Dist dep = (Dist) anyDep;\n+                    dep.computeSourceRoots(collectedDeps);\n+                    contributingGroups.removeAll(dep.getContributingGroups());\n+                }\n+            }\n+            groups = contributingGroups;\n+        }\n+\n+        public Collection<Group> getContributingGroups() {\n+            return groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Dist[name=\" + name + \"]\";\n+        }\n+    }\n+\n+    final class Group implements SourceGroup, Dep, AnnotationProcessingQuery.Result,\n+            Compliance.Provider {\n+        private final String mxName;\n+        private final MxProject mxPrj;\n+        private final FileObject srcDir;\n+        private final FileObject srcGenDir;\n+        private final FileObject binDir;\n+        private final String name;\n+        private final String displayName;\n+        private final Compliance compliance;\n+        private ClassPath sourceCP;\n+        private ClassPath cp;\n+        private ClassPath processorPath;\n+        private Collection<Dep> allDeps;\n+\n+        Group(String mxName, MxProject mxPrj, FileObject srcDir, FileObject srcGenDir, FileObject binDir, String name, String displayName) {\n+            this.mxName = mxName;\n+            this.mxPrj = mxPrj;\n+            this.srcDir = srcDir;\n+            this.srcGenDir = srcGenDir;\n+            this.binDir = binDir;\n+            this.name = name;\n+            this.displayName = displayName;\n+            this.compliance = Compliance.parse(mxPrj.javaCompliance());\n+        }\n+\n+        @Override\n+        public FileObject getRootFolder() {\n+            return srcDir;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public String getDisplayName() {\n+            return displayName;\n+        }\n+\n+        @Override\n+        public Icon getIcon(boolean opened) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Compliance getCompliance() {\n+            return compliance;\n+        }\n+\n+        @Override\n+        public boolean contains(FileObject file) {\n+            if (file == srcDir || file == srcGenDir || FileUtil.isParentOf(srcDir, file) || (srcGenDir != null && FileUtil.isParentOf(srcGenDir, file))) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SuiteSources.Group[name=\" + name + \",rootFolder=\" + srcDir + \"]\"; // NOI18N\n+        }\n+\n+        ClassPath getSourceCP() {\n+            computeTransitiveDeps();\n+            return sourceCP;\n+        }\n+\n+        ClassPath getCP() {\n+            computeTransitiveDeps();\n+            return cp;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return mxPrj.dependencies();\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            allDeps = set;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        private void computeClassPath(Map<String, Dep> transDeps) {\n+            for (Dep d : transDeps.values()) {\n+                d.owner().computeTransitiveDeps();", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwNzYwMQ==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544107601", "bodyText": "The transitive deps are processed just once. Let's make it clearer by better naming 5b589ee", "author": "JaroslavTulach", "createdAt": "2020-12-16T08:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjI1MQ==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538172251", "bodyText": "Uh :) I meant mx already supports aarch64, maybe even i386 ?", "author": "sdedic", "createdAt": "2020-12-08T09:24:35Z", "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject root, String name) throws IllegalArgumentException {\n+        FileObject impDir = root.getFileObject(name);\n+        if (impDir != null) {\n+            try {\n+                Project impPrj = ProjectManager.getDefault().findProject(impDir);\n+                return impPrj == null ? null : impPrj.getLookup().lookup(SuiteSources.class);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceGroup[] getSourceGroups(String string) {\n+        return groups();\n+    }\n+\n+    Group[] groups() {\n+        return groups.toArray(new Group[0]);\n+    }\n+\n+    Group findGroup(FileObject fo) {\n+        for (Group g : groups) {\n+            if (g.contains(fo)) {\n+                return g;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void addChangeListener(ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public void removeChangeListener(ChangeListener cl) {\n+    }\n+\n+    private static FileObject findPrjDir(FileObject dir, String prjName, MxProject prj) {\n+        if (dir == null) {\n+            return null;\n+        }\n+        if (prj.dir() != null) {\n+            return dir.getFileObject(prj.dir());\n+        }\n+        if (prj.subDir() != null) {\n+            dir = dir.getFileObject(prj.subDir());\n+            if (dir == null) {\n+                return null;\n+            }\n+        }\n+        return dir.getFileObject(prjName);\n+    }\n+\n+    private Collection<Dep> transitiveDeps(Dep current, Map<String, Dep> fill) {\n+        current.owner().computeTransitiveDeps();\n+        final Collection<Dep> currentAllDeps = current.allDeps();\n+        if (currentAllDeps == Collections.<Dep>emptySet()) {\n+            throw new IllegalStateException(\"Cyclic dep on \" + current.getName());\n+        } else if (currentAllDeps != null) {\n+            return currentAllDeps;\n+        }\n+        current.setAllDeps(Collections.emptySet());\n+        TreeSet<Dep> computing = new TreeSet<>();\n+        computing.add(current);\n+        for (String depName : current.depNames()) {\n+            Dep dep = fill.get(depName);\n+            if (dep == null) {\n+                int colon = depName.lastIndexOf(':');\n+                dep = fill.get(depName.substring(colon + 1));\n+                if (dep == null) {\n+                    LOG.log(Level.INFO, \"dep not found: {0}\", depName);\n+                    continue;\n+                }\n+            }\n+            Collection<Dep> allDeps = transitiveDeps(dep, fill);\n+            computing.addAll(allDeps);\n+        }\n+        current.setAllDeps(computing);\n+        return computing;\n+    }\n+\n+    private static void registerLibs(Map<String, MxLibrary> collect, String prefix, Map<String, MxLibrary> libraries) {\n+        for (Map.Entry<String, MxLibrary> entry : libraries.entrySet()) {\n+            String key = entry.getKey();\n+            MxLibrary lib = entry.getValue();\n+            if (prefix == null) {\n+                collect.put(key, lib);\n+            } else {\n+                collect.put(prefix + \":\" + key, lib);\n+            }\n+        }\n+    }\n+\n+    private void registerDeps(String prefix, Map<String, Dep> fillDeps) {\n+        for (Library library : libraries) {\n+            fillDeps.put(prefix + \":\" + library.getName(), library);\n+        }\n+        for (Dist d : distributions) {\n+            fillDeps.put(prefix + \":\" + d.getName(), d);\n+        }\n+        for (Map.Entry<String, SuiteSources> s : imported.entrySet()) {\n+            s.getValue().registerDeps(s.getKey(), fillDeps);\n+        }\n+    }\n+\n+    @Override\n+    public Group findBinaryRoots2(URL url) {\n+        final FileObject srcFo = URLMapper.findFileObject(url);\n+        for (Group group : this.groups) {\n+            if (group.contains(srcFo)) {\n+                return group;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public URL[] computeRoots(Group group) {\n+        if (group.binDir != null) {\n+            return new URL[] { group.binDir.toURL() };\n+        } else {\n+            return new URL[0];\n+        }\n+    }\n+\n+    @Override\n+    public boolean computePreferBinaries(Group result) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void computeChangeListener(Group result, boolean bln, ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public SourceForBinaryQueryImplementation2.Result findSourceRoots2(URL url) {\n+        this.computeTransitiveDeps();\n+        for (Dist dist : this.distributions) {\n+            URL jar;\n+            try {\n+                jar = dist.getJarRoot();\n+                if (jar == null) {\n+                    continue;\n+                }\n+            } catch (MalformedURLException ok) {\n+                continue;\n+            }\n+            if (jar.equals(url)) {\n+                List<FileObject> roots = new ArrayList<>();\n+                for (Group d : dist.getContributingGroups()) {\n+                    roots.add(d.srcDir);\n+                    roots.add(d.srcGenDir);\n+                }\n+                return new ImmutableResult(roots.toArray(new FileObject[roots.size()]));\n+            }\n+        }\n+        for (Group group : this.groups) {\n+            if (group.binDir != null && group.binDir.toURL().equals(url)) {\n+                return new ImmutableResult(group.srcDir, group.srcGenDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceForBinaryQuery.Result findSourceRoots(URL url) {\n+        return findSourceRoots2(url);\n+    }\n+\n+    final Iterable<File> jdks() {\n+        Set<File> jdks = new LinkedHashSet<>();\n+        String home = System.getProperty(\"user.home\");\n+        if (home != null) {\n+            File userEnv = new File(new File(new File(home), \".mx\"), \"env\");\n+            findJdksInEnv(jdks, userEnv);\n+        }\n+        FileObject suiteEnv = dir.getFileObject(\"mx.\" + dir.getNameExt() + \"/env\");\n+        if (suiteEnv != null) {\n+            findJdksInEnv(jdks, FileUtil.toFile(suiteEnv));\n+        }\n+\n+        String javaHomeEnv = System.getenv(\"JAVA_HOME\");\n+        if (javaHomeEnv != null) {\n+            jdks.add(new File(javaHomeEnv));\n+        }\n+        String javaHomeProp = System.getProperty(\"java.home\");\n+        if (javaHomeProp != null) {\n+            jdks.add(new File(javaHomeProp));\n+        }\n+        return jdks;\n+    }\n+\n+    private void findJdksInEnv(Set<File> jdks, File env) {\n+        if (env == null || !env.isFile()) {\n+            return;\n+        }\n+        try (final FileInputStream is = new FileInputStream(env)) {\n+            Properties p = new Properties();\n+            p.load(is);\n+\n+            String javaHome = p.getProperty(\"JAVA_HOME\");\n+            if (javaHome != null) {\n+                jdks.add(new File(javaHome));\n+            }\n+\n+            String extraJavaHomes = p.getProperty(\"EXTRA_JAVA_HOMES\");\n+            if (extraJavaHomes != null) {\n+                for (String extraHome : extraJavaHomes.split(File.pathSeparator)) {\n+                    jdks.add(new File(extraHome));\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    @Override\n+    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject fo) {\n+        Group g = findGroup(fo);\n+        if (g == null) {\n+            return null;\n+        }\n+        return new SourceLevelQueryImplementation2.Result2() {\n+            @Override\n+            public SourceLevelQuery.Profile getProfile() {\n+                return SourceLevelQuery.Profile.DEFAULT;\n+            }\n+\n+            @Override\n+            public String getSourceLevel() {\n+                return g.getCompliance().getSourceLevel();\n+            }\n+\n+            @Override\n+            public void addChangeListener(ChangeListener cl) {\n+            }\n+\n+            @Override\n+            public void removeChangeListener(ChangeListener cl) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Set<? extends Project> getSubprojects() {\n+        Set<Project> prjs = new HashSet<>();\n+        for (SuiteSources imp : imported.values()) {\n+            prjs.add(imp.prj);\n+        }\n+        return prjs;\n+    }\n+\n+    @Override\n+    public URL[] findUnitTests(FileObject fo) {\n+        return new URL[0];\n+    }\n+\n+    @Override\n+    public URL[] findSources(FileObject fo) {\n+        Group g = findGroup(fo);\n+        return g == null ? new URL[0] : new URL[] { g.getRootFolder().toURL() };\n+    }\n+\n+    static interface Dep extends Comparable<Dep> {\n+        String getName();\n+\n+        Collection<String> depNames();\n+\n+        Collection<Dep> allDeps();\n+\n+        void setAllDeps(Collection<Dep> set);\n+\n+        @Override\n+        public default int compareTo(Dep o) {\n+            return getName().compareTo(o.getName());\n+        }\n+\n+        SuiteSources owner();\n+    }\n+\n+    final class Dist implements Dep, FlaggedClassPathImplementation {\n+        final String name;\n+        final MxDistribution dist;\n+        Collection<Dep> allDeps;\n+        private final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        private Boolean exists;\n+        private Collection<Group> groups;\n+\n+        public Dist(String name, MxDistribution dist) {\n+            this.name = name;\n+            this.dist = dist;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            Set<String> deps = new TreeSet<>();\n+            deps.addAll(dist.distDependencies());\n+            deps.addAll(dist.exclude());\n+            return deps;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return this.allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return this.name;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        private FileObject getJar(boolean ignore) {\n+            if (SuiteSources.this.dir == null) {\n+                return null;\n+            }\n+            FileObject dists = SuiteSources.this.dir.getFileObject(\"mxbuild/dists\");\n+            if (dists == null) {\n+                return null;\n+            }\n+            List<FileObject> dist = Arrays.stream(dists.getChildren()).filter((fo) -> fo.isFolder() && fo.getName().startsWith(\"jdk\")).collect(Collectors.toList());\n+            dist.sort((fo1, fo2) -> fo2.getName().compareTo(fo1.getName()));\n+            for (FileObject jdkDir : dist) {\n+                FileObject jar = jdkDir.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+                if (jar != null) {\n+                    return jar;\n+                }\n+            }\n+            FileObject jar = dists.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+            if (jar != null) {\n+                return jar;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public List<? extends PathResourceImplementation> getResources() {\n+            computeTransitiveDeps();\n+            FileObject jar = getJar(exists == null);\n+            final boolean existsNow = jar != null && jar.isData();\n+            if (exists == null) {\n+                exists = existsNow;\n+            } else {\n+                if (exists != existsNow) {\n+                    exists = existsNow;\n+                    support.firePropertyChange(PROP_FLAGS, !exists, (boolean) exists);\n+                }\n+            }\n+            if (jar != null) {\n+                PathResourceImplementation res;\n+                try {\n+                    res = ClassPathSupport.createResource(getJarRoot());\n+                    return Collections.singletonList(res);\n+                } catch (MalformedURLException ex) {\n+                    // OK\n+                }\n+            }\n+            return Collections.emptyList();\n+        }\n+\n+        private URL getJarRoot() throws MalformedURLException {\n+            FileObject jar = getJar(true);\n+            if (jar != null) {\n+                return new URL(\"jar:\" + jar.toURL() + \"!/\");\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener pl) {\n+            support.addPropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener pl) {\n+            support.removePropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+\n+        private void computeSourceRoots(Map<String, Dep> collectedDeps) {\n+            if (groups != null) {\n+                return;\n+            }\n+            Set<Group> contributingGroups = new LinkedHashSet<>();\n+            for (String d : this.dist.dependencies()) {\n+                Dep dep = collectedDeps.get(d);\n+                if (dep == null || dep.allDeps() == null) {\n+                    continue;\n+                }\n+                for (Dep d2 : dep.allDeps()) {\n+                    if (d2 instanceof Group) {\n+                        contributingGroups.add((Group) d2);\n+                    }\n+                }\n+            }\n+            for (String d : this.dist.distDependencies()) {\n+                final Dep anyDep = collectedDeps.get(d);\n+                if (anyDep instanceof Dist) {\n+                    Dist dep = (Dist) anyDep;\n+                    dep.computeSourceRoots(collectedDeps);\n+                    contributingGroups.removeAll(dep.getContributingGroups());\n+                }\n+            }\n+            groups = contributingGroups;\n+        }\n+\n+        public Collection<Group> getContributingGroups() {\n+            return groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Dist[name=\" + name + \"]\";\n+        }\n+    }\n+\n+    final class Group implements SourceGroup, Dep, AnnotationProcessingQuery.Result,\n+            Compliance.Provider {\n+        private final String mxName;\n+        private final MxProject mxPrj;\n+        private final FileObject srcDir;\n+        private final FileObject srcGenDir;\n+        private final FileObject binDir;\n+        private final String name;\n+        private final String displayName;\n+        private final Compliance compliance;\n+        private ClassPath sourceCP;\n+        private ClassPath cp;\n+        private ClassPath processorPath;\n+        private Collection<Dep> allDeps;\n+\n+        Group(String mxName, MxProject mxPrj, FileObject srcDir, FileObject srcGenDir, FileObject binDir, String name, String displayName) {\n+            this.mxName = mxName;\n+            this.mxPrj = mxPrj;\n+            this.srcDir = srcDir;\n+            this.srcGenDir = srcGenDir;\n+            this.binDir = binDir;\n+            this.name = name;\n+            this.displayName = displayName;\n+            this.compliance = Compliance.parse(mxPrj.javaCompliance());\n+        }\n+\n+        @Override\n+        public FileObject getRootFolder() {\n+            return srcDir;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public String getDisplayName() {\n+            return displayName;\n+        }\n+\n+        @Override\n+        public Icon getIcon(boolean opened) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Compliance getCompliance() {\n+            return compliance;\n+        }\n+\n+        @Override\n+        public boolean contains(FileObject file) {\n+            if (file == srcDir || file == srcGenDir || FileUtil.isParentOf(srcDir, file) || (srcGenDir != null && FileUtil.isParentOf(srcGenDir, file))) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SuiteSources.Group[name=\" + name + \",rootFolder=\" + srcDir + \"]\"; // NOI18N\n+        }\n+\n+        ClassPath getSourceCP() {\n+            computeTransitiveDeps();\n+            return sourceCP;\n+        }\n+\n+        ClassPath getCP() {\n+            computeTransitiveDeps();\n+            return cp;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return mxPrj.dependencies();\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            allDeps = set;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        private void computeClassPath(Map<String, Dep> transDeps) {\n+            for (Dep d : transDeps.values()) {\n+                d.owner().computeTransitiveDeps();\n+            }\n+\n+            List<Group> arr = new ArrayList<>();\n+            List<ClassPathImplementation> libs = new ArrayList<>();\n+            processTransDep(transDeps.get(mxName), arr, libs);\n+            cp = composeClassPath(arr, libs);\n+            List<FileObject> roots = new ArrayList<>();\n+            if (srcDir != null) {\n+                roots.add(srcDir);\n+            }\n+            if (srcGenDir != null) {\n+                roots.add(srcGenDir);\n+            }\n+            sourceCP = ClassPathSupport.createClassPath(roots.toArray(new FileObject[roots.size()]));\n+\n+            if (mxPrj.annotationProcessors().isEmpty()) {\n+                processorPath = null;\n+            } else {\n+                List<Group> groups = new ArrayList<>();\n+                List<ClassPathImplementation> jars = new ArrayList<>();\n+                for (String dep : mxPrj.annotationProcessors()) {\n+                    processTransDep(transDeps.get(dep), groups, jars);\n+                }\n+                processorPath = composeClassPath(groups, jars);\n+            }\n+        }\n+\n+        private void processTransDep(Dep dep, List<Group> addGroups, List<ClassPathImplementation> addJars) {\n+            if (dep != null) {\n+                dep.owner().computeTransitiveDeps();\n+                for (Dep d : dep.allDeps()) {\n+                    if (d == this) {\n+                        continue;\n+                    }\n+                    d.owner().computeTransitiveDeps();\n+                    if (d instanceof Group) {\n+                        addGroups.add((Group) d);\n+                    } else if (d instanceof ClassPathImplementation) {\n+                        addJars.add((ClassPathImplementation) d);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ClassPath composeClassPath(List<Group> arr, List<ClassPathImplementation> libs) {\n+            Set<FileObject> roots = new LinkedHashSet<>();\n+            final int depsCount = arr.size();\n+            for (int i = 0; i < depsCount; i++) {\n+                final Group g = arr.get(i);\n+                if (g.binDir != null) {\n+                    roots.add(g.binDir);\n+                }\n+            }\n+            ClassPath prjCp = ClassPathSupport.createClassPath(roots.toArray(new FileObject[0]));\n+            if (!libs.isEmpty()) {\n+                if (libs.size() == 1) {\n+                    prjCp = ClassPathSupport.createProxyClassPath(prjCp,\n+                                                                  ClassPathFactory.createClassPath(libs.get(0))\n+                    );\n+                } else {\n+                    prjCp = ClassPathSupport.createProxyClassPath(prjCp,\n+                                                                  ClassPathFactory.createClassPath(\n+                                                                                  ClassPathSupport.createProxyClassPathImplementation(\n+                                                                                                  libs.toArray(new ClassPathImplementation[0])\n+                                                                                  )\n+                                                                  )\n+                    );\n+                }\n+            }\n+            return prjCp;\n+        }\n+\n+        ClassPath getProcessorCP() {\n+            computeTransitiveDeps();\n+            return processorPath;\n+        }\n+\n+        @Override\n+        public Set<? extends AnnotationProcessingQuery.Trigger> annotationProcessingEnabled() {\n+            return EnumSet.of(AnnotationProcessingQuery.Trigger.ON_SCAN, AnnotationProcessingQuery.Trigger.IN_EDITOR);\n+        }\n+\n+        @Override\n+        public Iterable<? extends String> annotationProcessorsToRun() {\n+            return null;\n+        }\n+\n+        @Override\n+        public URL sourceOutputDirectory() {\n+            return srcGenDir == null ? null : srcGenDir.toURL();\n+        }\n+\n+        @Override\n+        public Map<? extends String, ? extends String> processorOptions() {\n+            return Collections.emptyMap();\n+        }\n+\n+        @Override\n+        public void addChangeListener(ChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removeChangeListener(ChangeListener l) {\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+    }\n+\n+    private class Library implements FlaggedClassPathImplementation, Dep {\n+        final MxLibrary lib;\n+        final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        final String libName;\n+        Collection<Dep> allDeps;\n+        Boolean exists;\n+\n+        Library(String libName, MxLibrary lib) {\n+            this.libName = libName;\n+            this.lib = getOSSLibrary(lib);\n+        }\n+\n+        final MxLibrary getOSSLibrary(MxLibrary lib) {\n+            if (lib.sha1() == null && !lib.os_arch().isEmpty()) {\n+                Map<String, MxLibrary.Arch> os_dep_libs = lib.os_arch();\n+                String os = System.getProperty(\"os.name\").toLowerCase();\n+                for (Map.Entry<String, MxLibrary.Arch> entry : os_dep_libs.entrySet()) {\n+                    if (os.contains(entry.getKey())) {\n+                        return entry.getValue().amd64();", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA5ODc2MQ==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544098761", "bodyText": "This silently assumes all developer laptops and workstations are AMD64. True for now, until Apple own processor becomes popular among devs. I guess it is going to take a bit of time and it will need deeper fixes in mx itself then.", "author": "JaroslavTulach", "createdAt": "2020-12-16T08:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjMyMw==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538172323", "bodyText": "better check exists != null as well", "author": "sdedic", "createdAt": "2020-12-08T09:24:40Z", "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject root, String name) throws IllegalArgumentException {\n+        FileObject impDir = root.getFileObject(name);\n+        if (impDir != null) {\n+            try {\n+                Project impPrj = ProjectManager.getDefault().findProject(impDir);\n+                return impPrj == null ? null : impPrj.getLookup().lookup(SuiteSources.class);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceGroup[] getSourceGroups(String string) {\n+        return groups();\n+    }\n+\n+    Group[] groups() {\n+        return groups.toArray(new Group[0]);\n+    }\n+\n+    Group findGroup(FileObject fo) {\n+        for (Group g : groups) {\n+            if (g.contains(fo)) {\n+                return g;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void addChangeListener(ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public void removeChangeListener(ChangeListener cl) {\n+    }\n+\n+    private static FileObject findPrjDir(FileObject dir, String prjName, MxProject prj) {\n+        if (dir == null) {\n+            return null;\n+        }\n+        if (prj.dir() != null) {\n+            return dir.getFileObject(prj.dir());\n+        }\n+        if (prj.subDir() != null) {\n+            dir = dir.getFileObject(prj.subDir());\n+            if (dir == null) {\n+                return null;\n+            }\n+        }\n+        return dir.getFileObject(prjName);\n+    }\n+\n+    private Collection<Dep> transitiveDeps(Dep current, Map<String, Dep> fill) {\n+        current.owner().computeTransitiveDeps();\n+        final Collection<Dep> currentAllDeps = current.allDeps();\n+        if (currentAllDeps == Collections.<Dep>emptySet()) {\n+            throw new IllegalStateException(\"Cyclic dep on \" + current.getName());\n+        } else if (currentAllDeps != null) {\n+            return currentAllDeps;\n+        }\n+        current.setAllDeps(Collections.emptySet());\n+        TreeSet<Dep> computing = new TreeSet<>();\n+        computing.add(current);\n+        for (String depName : current.depNames()) {\n+            Dep dep = fill.get(depName);\n+            if (dep == null) {\n+                int colon = depName.lastIndexOf(':');\n+                dep = fill.get(depName.substring(colon + 1));\n+                if (dep == null) {\n+                    LOG.log(Level.INFO, \"dep not found: {0}\", depName);\n+                    continue;\n+                }\n+            }\n+            Collection<Dep> allDeps = transitiveDeps(dep, fill);\n+            computing.addAll(allDeps);\n+        }\n+        current.setAllDeps(computing);\n+        return computing;\n+    }\n+\n+    private static void registerLibs(Map<String, MxLibrary> collect, String prefix, Map<String, MxLibrary> libraries) {\n+        for (Map.Entry<String, MxLibrary> entry : libraries.entrySet()) {\n+            String key = entry.getKey();\n+            MxLibrary lib = entry.getValue();\n+            if (prefix == null) {\n+                collect.put(key, lib);\n+            } else {\n+                collect.put(prefix + \":\" + key, lib);\n+            }\n+        }\n+    }\n+\n+    private void registerDeps(String prefix, Map<String, Dep> fillDeps) {\n+        for (Library library : libraries) {\n+            fillDeps.put(prefix + \":\" + library.getName(), library);\n+        }\n+        for (Dist d : distributions) {\n+            fillDeps.put(prefix + \":\" + d.getName(), d);\n+        }\n+        for (Map.Entry<String, SuiteSources> s : imported.entrySet()) {\n+            s.getValue().registerDeps(s.getKey(), fillDeps);\n+        }\n+    }\n+\n+    @Override\n+    public Group findBinaryRoots2(URL url) {\n+        final FileObject srcFo = URLMapper.findFileObject(url);\n+        for (Group group : this.groups) {\n+            if (group.contains(srcFo)) {\n+                return group;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public URL[] computeRoots(Group group) {\n+        if (group.binDir != null) {\n+            return new URL[] { group.binDir.toURL() };\n+        } else {\n+            return new URL[0];\n+        }\n+    }\n+\n+    @Override\n+    public boolean computePreferBinaries(Group result) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void computeChangeListener(Group result, boolean bln, ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public SourceForBinaryQueryImplementation2.Result findSourceRoots2(URL url) {\n+        this.computeTransitiveDeps();\n+        for (Dist dist : this.distributions) {\n+            URL jar;\n+            try {\n+                jar = dist.getJarRoot();\n+                if (jar == null) {\n+                    continue;\n+                }\n+            } catch (MalformedURLException ok) {\n+                continue;\n+            }\n+            if (jar.equals(url)) {\n+                List<FileObject> roots = new ArrayList<>();\n+                for (Group d : dist.getContributingGroups()) {\n+                    roots.add(d.srcDir);\n+                    roots.add(d.srcGenDir);\n+                }\n+                return new ImmutableResult(roots.toArray(new FileObject[roots.size()]));\n+            }\n+        }\n+        for (Group group : this.groups) {\n+            if (group.binDir != null && group.binDir.toURL().equals(url)) {\n+                return new ImmutableResult(group.srcDir, group.srcGenDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceForBinaryQuery.Result findSourceRoots(URL url) {\n+        return findSourceRoots2(url);\n+    }\n+\n+    final Iterable<File> jdks() {\n+        Set<File> jdks = new LinkedHashSet<>();\n+        String home = System.getProperty(\"user.home\");\n+        if (home != null) {\n+            File userEnv = new File(new File(new File(home), \".mx\"), \"env\");\n+            findJdksInEnv(jdks, userEnv);\n+        }\n+        FileObject suiteEnv = dir.getFileObject(\"mx.\" + dir.getNameExt() + \"/env\");\n+        if (suiteEnv != null) {\n+            findJdksInEnv(jdks, FileUtil.toFile(suiteEnv));\n+        }\n+\n+        String javaHomeEnv = System.getenv(\"JAVA_HOME\");\n+        if (javaHomeEnv != null) {\n+            jdks.add(new File(javaHomeEnv));\n+        }\n+        String javaHomeProp = System.getProperty(\"java.home\");\n+        if (javaHomeProp != null) {\n+            jdks.add(new File(javaHomeProp));\n+        }\n+        return jdks;\n+    }\n+\n+    private void findJdksInEnv(Set<File> jdks, File env) {\n+        if (env == null || !env.isFile()) {\n+            return;\n+        }\n+        try (final FileInputStream is = new FileInputStream(env)) {\n+            Properties p = new Properties();\n+            p.load(is);\n+\n+            String javaHome = p.getProperty(\"JAVA_HOME\");\n+            if (javaHome != null) {\n+                jdks.add(new File(javaHome));\n+            }\n+\n+            String extraJavaHomes = p.getProperty(\"EXTRA_JAVA_HOMES\");\n+            if (extraJavaHomes != null) {\n+                for (String extraHome : extraJavaHomes.split(File.pathSeparator)) {\n+                    jdks.add(new File(extraHome));\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    @Override\n+    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject fo) {\n+        Group g = findGroup(fo);\n+        if (g == null) {\n+            return null;\n+        }\n+        return new SourceLevelQueryImplementation2.Result2() {\n+            @Override\n+            public SourceLevelQuery.Profile getProfile() {\n+                return SourceLevelQuery.Profile.DEFAULT;\n+            }\n+\n+            @Override\n+            public String getSourceLevel() {\n+                return g.getCompliance().getSourceLevel();\n+            }\n+\n+            @Override\n+            public void addChangeListener(ChangeListener cl) {\n+            }\n+\n+            @Override\n+            public void removeChangeListener(ChangeListener cl) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Set<? extends Project> getSubprojects() {\n+        Set<Project> prjs = new HashSet<>();\n+        for (SuiteSources imp : imported.values()) {\n+            prjs.add(imp.prj);\n+        }\n+        return prjs;\n+    }\n+\n+    @Override\n+    public URL[] findUnitTests(FileObject fo) {\n+        return new URL[0];\n+    }\n+\n+    @Override\n+    public URL[] findSources(FileObject fo) {\n+        Group g = findGroup(fo);\n+        return g == null ? new URL[0] : new URL[] { g.getRootFolder().toURL() };\n+    }\n+\n+    static interface Dep extends Comparable<Dep> {\n+        String getName();\n+\n+        Collection<String> depNames();\n+\n+        Collection<Dep> allDeps();\n+\n+        void setAllDeps(Collection<Dep> set);\n+\n+        @Override\n+        public default int compareTo(Dep o) {\n+            return getName().compareTo(o.getName());\n+        }\n+\n+        SuiteSources owner();\n+    }\n+\n+    final class Dist implements Dep, FlaggedClassPathImplementation {\n+        final String name;\n+        final MxDistribution dist;\n+        Collection<Dep> allDeps;\n+        private final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        private Boolean exists;\n+        private Collection<Group> groups;\n+\n+        public Dist(String name, MxDistribution dist) {\n+            this.name = name;\n+            this.dist = dist;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            Set<String> deps = new TreeSet<>();\n+            deps.addAll(dist.distDependencies());\n+            deps.addAll(dist.exclude());\n+            return deps;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return this.allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return this.name;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        private FileObject getJar(boolean ignore) {\n+            if (SuiteSources.this.dir == null) {\n+                return null;\n+            }\n+            FileObject dists = SuiteSources.this.dir.getFileObject(\"mxbuild/dists\");\n+            if (dists == null) {\n+                return null;\n+            }\n+            List<FileObject> dist = Arrays.stream(dists.getChildren()).filter((fo) -> fo.isFolder() && fo.getName().startsWith(\"jdk\")).collect(Collectors.toList());\n+            dist.sort((fo1, fo2) -> fo2.getName().compareTo(fo1.getName()));\n+            for (FileObject jdkDir : dist) {\n+                FileObject jar = jdkDir.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+                if (jar != null) {\n+                    return jar;\n+                }\n+            }\n+            FileObject jar = dists.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+            if (jar != null) {\n+                return jar;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public List<? extends PathResourceImplementation> getResources() {\n+            computeTransitiveDeps();\n+            FileObject jar = getJar(exists == null);\n+            final boolean existsNow = jar != null && jar.isData();\n+            if (exists == null) {\n+                exists = existsNow;\n+            } else {\n+                if (exists != existsNow) {\n+                    exists = existsNow;\n+                    support.firePropertyChange(PROP_FLAGS, !exists, (boolean) exists);\n+                }\n+            }\n+            if (jar != null) {\n+                PathResourceImplementation res;\n+                try {\n+                    res = ClassPathSupport.createResource(getJarRoot());\n+                    return Collections.singletonList(res);\n+                } catch (MalformedURLException ex) {\n+                    // OK\n+                }\n+            }\n+            return Collections.emptyList();\n+        }\n+\n+        private URL getJarRoot() throws MalformedURLException {\n+            FileObject jar = getJar(true);\n+            if (jar != null) {\n+                return new URL(\"jar:\" + jar.toURL() + \"!/\");\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener pl) {\n+            support.addPropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener pl) {\n+            support.removePropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+\n+        private void computeSourceRoots(Map<String, Dep> collectedDeps) {\n+            if (groups != null) {\n+                return;\n+            }\n+            Set<Group> contributingGroups = new LinkedHashSet<>();\n+            for (String d : this.dist.dependencies()) {\n+                Dep dep = collectedDeps.get(d);\n+                if (dep == null || dep.allDeps() == null) {\n+                    continue;\n+                }\n+                for (Dep d2 : dep.allDeps()) {\n+                    if (d2 instanceof Group) {\n+                        contributingGroups.add((Group) d2);\n+                    }\n+                }\n+            }\n+            for (String d : this.dist.distDependencies()) {\n+                final Dep anyDep = collectedDeps.get(d);\n+                if (anyDep instanceof Dist) {\n+                    Dist dep = (Dist) anyDep;\n+                    dep.computeSourceRoots(collectedDeps);\n+                    contributingGroups.removeAll(dep.getContributingGroups());\n+                }\n+            }\n+            groups = contributingGroups;\n+        }\n+\n+        public Collection<Group> getContributingGroups() {\n+            return groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Dist[name=\" + name + \"]\";\n+        }\n+    }\n+\n+    final class Group implements SourceGroup, Dep, AnnotationProcessingQuery.Result,\n+            Compliance.Provider {\n+        private final String mxName;\n+        private final MxProject mxPrj;\n+        private final FileObject srcDir;\n+        private final FileObject srcGenDir;\n+        private final FileObject binDir;\n+        private final String name;\n+        private final String displayName;\n+        private final Compliance compliance;\n+        private ClassPath sourceCP;\n+        private ClassPath cp;\n+        private ClassPath processorPath;\n+        private Collection<Dep> allDeps;\n+\n+        Group(String mxName, MxProject mxPrj, FileObject srcDir, FileObject srcGenDir, FileObject binDir, String name, String displayName) {\n+            this.mxName = mxName;\n+            this.mxPrj = mxPrj;\n+            this.srcDir = srcDir;\n+            this.srcGenDir = srcGenDir;\n+            this.binDir = binDir;\n+            this.name = name;\n+            this.displayName = displayName;\n+            this.compliance = Compliance.parse(mxPrj.javaCompliance());\n+        }\n+\n+        @Override\n+        public FileObject getRootFolder() {\n+            return srcDir;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public String getDisplayName() {\n+            return displayName;\n+        }\n+\n+        @Override\n+        public Icon getIcon(boolean opened) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Compliance getCompliance() {\n+            return compliance;\n+        }\n+\n+        @Override\n+        public boolean contains(FileObject file) {\n+            if (file == srcDir || file == srcGenDir || FileUtil.isParentOf(srcDir, file) || (srcGenDir != null && FileUtil.isParentOf(srcGenDir, file))) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SuiteSources.Group[name=\" + name + \",rootFolder=\" + srcDir + \"]\"; // NOI18N\n+        }\n+\n+        ClassPath getSourceCP() {\n+            computeTransitiveDeps();\n+            return sourceCP;\n+        }\n+\n+        ClassPath getCP() {\n+            computeTransitiveDeps();\n+            return cp;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return mxPrj.dependencies();\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            allDeps = set;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        private void computeClassPath(Map<String, Dep> transDeps) {\n+            for (Dep d : transDeps.values()) {\n+                d.owner().computeTransitiveDeps();\n+            }\n+\n+            List<Group> arr = new ArrayList<>();\n+            List<ClassPathImplementation> libs = new ArrayList<>();\n+            processTransDep(transDeps.get(mxName), arr, libs);\n+            cp = composeClassPath(arr, libs);\n+            List<FileObject> roots = new ArrayList<>();\n+            if (srcDir != null) {\n+                roots.add(srcDir);\n+            }\n+            if (srcGenDir != null) {\n+                roots.add(srcGenDir);\n+            }\n+            sourceCP = ClassPathSupport.createClassPath(roots.toArray(new FileObject[roots.size()]));\n+\n+            if (mxPrj.annotationProcessors().isEmpty()) {\n+                processorPath = null;\n+            } else {\n+                List<Group> groups = new ArrayList<>();\n+                List<ClassPathImplementation> jars = new ArrayList<>();\n+                for (String dep : mxPrj.annotationProcessors()) {\n+                    processTransDep(transDeps.get(dep), groups, jars);\n+                }\n+                processorPath = composeClassPath(groups, jars);\n+            }\n+        }\n+\n+        private void processTransDep(Dep dep, List<Group> addGroups, List<ClassPathImplementation> addJars) {\n+            if (dep != null) {\n+                dep.owner().computeTransitiveDeps();\n+                for (Dep d : dep.allDeps()) {\n+                    if (d == this) {\n+                        continue;\n+                    }\n+                    d.owner().computeTransitiveDeps();\n+                    if (d instanceof Group) {\n+                        addGroups.add((Group) d);\n+                    } else if (d instanceof ClassPathImplementation) {\n+                        addJars.add((ClassPathImplementation) d);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ClassPath composeClassPath(List<Group> arr, List<ClassPathImplementation> libs) {\n+            Set<FileObject> roots = new LinkedHashSet<>();\n+            final int depsCount = arr.size();\n+            for (int i = 0; i < depsCount; i++) {\n+                final Group g = arr.get(i);\n+                if (g.binDir != null) {\n+                    roots.add(g.binDir);\n+                }\n+            }\n+            ClassPath prjCp = ClassPathSupport.createClassPath(roots.toArray(new FileObject[0]));\n+            if (!libs.isEmpty()) {\n+                if (libs.size() == 1) {\n+                    prjCp = ClassPathSupport.createProxyClassPath(prjCp,\n+                                                                  ClassPathFactory.createClassPath(libs.get(0))\n+                    );\n+                } else {\n+                    prjCp = ClassPathSupport.createProxyClassPath(prjCp,\n+                                                                  ClassPathFactory.createClassPath(\n+                                                                                  ClassPathSupport.createProxyClassPathImplementation(\n+                                                                                                  libs.toArray(new ClassPathImplementation[0])\n+                                                                                  )\n+                                                                  )\n+                    );\n+                }\n+            }\n+            return prjCp;\n+        }\n+\n+        ClassPath getProcessorCP() {\n+            computeTransitiveDeps();\n+            return processorPath;\n+        }\n+\n+        @Override\n+        public Set<? extends AnnotationProcessingQuery.Trigger> annotationProcessingEnabled() {\n+            return EnumSet.of(AnnotationProcessingQuery.Trigger.ON_SCAN, AnnotationProcessingQuery.Trigger.IN_EDITOR);\n+        }\n+\n+        @Override\n+        public Iterable<? extends String> annotationProcessorsToRun() {\n+            return null;\n+        }\n+\n+        @Override\n+        public URL sourceOutputDirectory() {\n+            return srcGenDir == null ? null : srcGenDir.toURL();\n+        }\n+\n+        @Override\n+        public Map<? extends String, ? extends String> processorOptions() {\n+            return Collections.emptyMap();\n+        }\n+\n+        @Override\n+        public void addChangeListener(ChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removeChangeListener(ChangeListener l) {\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+    }\n+\n+    private class Library implements FlaggedClassPathImplementation, Dep {\n+        final MxLibrary lib;\n+        final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        final String libName;\n+        Collection<Dep> allDeps;\n+        Boolean exists;\n+\n+        Library(String libName, MxLibrary lib) {\n+            this.libName = libName;\n+            this.lib = getOSSLibrary(lib);\n+        }\n+\n+        final MxLibrary getOSSLibrary(MxLibrary lib) {\n+            if (lib.sha1() == null && !lib.os_arch().isEmpty()) {\n+                Map<String, MxLibrary.Arch> os_dep_libs = lib.os_arch();\n+                String os = System.getProperty(\"os.name\").toLowerCase();\n+                for (Map.Entry<String, MxLibrary.Arch> entry : os_dep_libs.entrySet()) {\n+                    if (os.contains(entry.getKey())) {\n+                        return entry.getValue().amd64();\n+                    }\n+                }\n+            }\n+            return lib;\n+        }\n+\n+        File getJar(boolean dumpIfMissing) {\n+            File mxCache;\n+            String cache = System.getenv(\"MX_CACHE_DIR\");\n+            if (cache != null) {\n+                mxCache = new File(cache);\n+            } else {\n+                mxCache = new File(new File(new File(System.getProperty(\"user.home\")), \".mx\"), \"cache\");\n+            }\n+            int prefix = libName.indexOf(':');\n+            final String simpleName = libName.substring(prefix + 1);\n+\n+            File simpleJar = new File(mxCache, simpleName + \"_\" + lib.sha1() + \".jar\");\n+            if (simpleJar.exists()) {\n+                return simpleJar;\n+            }\n+            File dir = new File(mxCache, simpleName + \"_\" + lib.sha1());\n+            File jar = new File(dir, simpleName.replace('_', '-').toLowerCase(Locale.ENGLISH) + \".jar\");\n+\n+            if (dumpIfMissing && !jar.exists()) {\n+                for (File f = jar;; f = f.getParentFile()) {\n+                    if (!f.exists()) {\n+                        LOG.log(Level.WARNING, \"{0} does not exist\", f);\n+                    } else {\n+                        StringBuilder sb = new StringBuilder();\n+                        sb.append(f).append(\" exists:\\n\");\n+                        String[] kids = f.list();\n+                        if (kids != null) {\n+                            for (String n : kids) {\n+                                sb.append(\"  \").append(n).append(\"\\n\");\n+                            }\n+                        }\n+                        LOG.log(Level.INFO, sb.toString());\n+                        break;\n+                    }\n+                }\n+            }\n+            return jar;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return libName;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return lib.dependencies();\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMjg0Nw==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544102847", "bodyText": "Good catch: 9e9567e", "author": "JaroslavTulach", "createdAt": "2020-12-16T08:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjM3Nw==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538172377", "bodyText": "Can be somehow shared with Library implementation ?", "author": "sdedic", "createdAt": "2020-12-08T09:24:44Z", "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject root, String name) throws IllegalArgumentException {\n+        FileObject impDir = root.getFileObject(name);\n+        if (impDir != null) {\n+            try {\n+                Project impPrj = ProjectManager.getDefault().findProject(impDir);\n+                return impPrj == null ? null : impPrj.getLookup().lookup(SuiteSources.class);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceGroup[] getSourceGroups(String string) {\n+        return groups();\n+    }\n+\n+    Group[] groups() {\n+        return groups.toArray(new Group[0]);\n+    }\n+\n+    Group findGroup(FileObject fo) {\n+        for (Group g : groups) {\n+            if (g.contains(fo)) {\n+                return g;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void addChangeListener(ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public void removeChangeListener(ChangeListener cl) {\n+    }\n+\n+    private static FileObject findPrjDir(FileObject dir, String prjName, MxProject prj) {\n+        if (dir == null) {\n+            return null;\n+        }\n+        if (prj.dir() != null) {\n+            return dir.getFileObject(prj.dir());\n+        }\n+        if (prj.subDir() != null) {\n+            dir = dir.getFileObject(prj.subDir());\n+            if (dir == null) {\n+                return null;\n+            }\n+        }\n+        return dir.getFileObject(prjName);\n+    }\n+\n+    private Collection<Dep> transitiveDeps(Dep current, Map<String, Dep> fill) {\n+        current.owner().computeTransitiveDeps();\n+        final Collection<Dep> currentAllDeps = current.allDeps();\n+        if (currentAllDeps == Collections.<Dep>emptySet()) {\n+            throw new IllegalStateException(\"Cyclic dep on \" + current.getName());\n+        } else if (currentAllDeps != null) {\n+            return currentAllDeps;\n+        }\n+        current.setAllDeps(Collections.emptySet());\n+        TreeSet<Dep> computing = new TreeSet<>();\n+        computing.add(current);\n+        for (String depName : current.depNames()) {\n+            Dep dep = fill.get(depName);\n+            if (dep == null) {\n+                int colon = depName.lastIndexOf(':');\n+                dep = fill.get(depName.substring(colon + 1));\n+                if (dep == null) {\n+                    LOG.log(Level.INFO, \"dep not found: {0}\", depName);\n+                    continue;\n+                }\n+            }\n+            Collection<Dep> allDeps = transitiveDeps(dep, fill);\n+            computing.addAll(allDeps);\n+        }\n+        current.setAllDeps(computing);\n+        return computing;\n+    }\n+\n+    private static void registerLibs(Map<String, MxLibrary> collect, String prefix, Map<String, MxLibrary> libraries) {\n+        for (Map.Entry<String, MxLibrary> entry : libraries.entrySet()) {\n+            String key = entry.getKey();\n+            MxLibrary lib = entry.getValue();\n+            if (prefix == null) {\n+                collect.put(key, lib);\n+            } else {\n+                collect.put(prefix + \":\" + key, lib);\n+            }\n+        }\n+    }\n+\n+    private void registerDeps(String prefix, Map<String, Dep> fillDeps) {\n+        for (Library library : libraries) {\n+            fillDeps.put(prefix + \":\" + library.getName(), library);\n+        }\n+        for (Dist d : distributions) {\n+            fillDeps.put(prefix + \":\" + d.getName(), d);\n+        }\n+        for (Map.Entry<String, SuiteSources> s : imported.entrySet()) {\n+            s.getValue().registerDeps(s.getKey(), fillDeps);\n+        }\n+    }\n+\n+    @Override\n+    public Group findBinaryRoots2(URL url) {\n+        final FileObject srcFo = URLMapper.findFileObject(url);\n+        for (Group group : this.groups) {\n+            if (group.contains(srcFo)) {\n+                return group;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public URL[] computeRoots(Group group) {\n+        if (group.binDir != null) {\n+            return new URL[] { group.binDir.toURL() };\n+        } else {\n+            return new URL[0];\n+        }\n+    }\n+\n+    @Override\n+    public boolean computePreferBinaries(Group result) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void computeChangeListener(Group result, boolean bln, ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public SourceForBinaryQueryImplementation2.Result findSourceRoots2(URL url) {\n+        this.computeTransitiveDeps();\n+        for (Dist dist : this.distributions) {\n+            URL jar;\n+            try {\n+                jar = dist.getJarRoot();\n+                if (jar == null) {\n+                    continue;\n+                }\n+            } catch (MalformedURLException ok) {\n+                continue;\n+            }\n+            if (jar.equals(url)) {\n+                List<FileObject> roots = new ArrayList<>();\n+                for (Group d : dist.getContributingGroups()) {\n+                    roots.add(d.srcDir);\n+                    roots.add(d.srcGenDir);\n+                }\n+                return new ImmutableResult(roots.toArray(new FileObject[roots.size()]));\n+            }\n+        }\n+        for (Group group : this.groups) {\n+            if (group.binDir != null && group.binDir.toURL().equals(url)) {\n+                return new ImmutableResult(group.srcDir, group.srcGenDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceForBinaryQuery.Result findSourceRoots(URL url) {\n+        return findSourceRoots2(url);\n+    }\n+\n+    final Iterable<File> jdks() {\n+        Set<File> jdks = new LinkedHashSet<>();\n+        String home = System.getProperty(\"user.home\");\n+        if (home != null) {\n+            File userEnv = new File(new File(new File(home), \".mx\"), \"env\");\n+            findJdksInEnv(jdks, userEnv);\n+        }\n+        FileObject suiteEnv = dir.getFileObject(\"mx.\" + dir.getNameExt() + \"/env\");\n+        if (suiteEnv != null) {\n+            findJdksInEnv(jdks, FileUtil.toFile(suiteEnv));\n+        }\n+\n+        String javaHomeEnv = System.getenv(\"JAVA_HOME\");\n+        if (javaHomeEnv != null) {\n+            jdks.add(new File(javaHomeEnv));\n+        }\n+        String javaHomeProp = System.getProperty(\"java.home\");\n+        if (javaHomeProp != null) {\n+            jdks.add(new File(javaHomeProp));\n+        }\n+        return jdks;\n+    }\n+\n+    private void findJdksInEnv(Set<File> jdks, File env) {\n+        if (env == null || !env.isFile()) {\n+            return;\n+        }\n+        try (final FileInputStream is = new FileInputStream(env)) {\n+            Properties p = new Properties();\n+            p.load(is);\n+\n+            String javaHome = p.getProperty(\"JAVA_HOME\");\n+            if (javaHome != null) {\n+                jdks.add(new File(javaHome));\n+            }\n+\n+            String extraJavaHomes = p.getProperty(\"EXTRA_JAVA_HOMES\");\n+            if (extraJavaHomes != null) {\n+                for (String extraHome : extraJavaHomes.split(File.pathSeparator)) {\n+                    jdks.add(new File(extraHome));\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    @Override\n+    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject fo) {\n+        Group g = findGroup(fo);\n+        if (g == null) {\n+            return null;\n+        }\n+        return new SourceLevelQueryImplementation2.Result2() {\n+            @Override\n+            public SourceLevelQuery.Profile getProfile() {\n+                return SourceLevelQuery.Profile.DEFAULT;\n+            }\n+\n+            @Override\n+            public String getSourceLevel() {\n+                return g.getCompliance().getSourceLevel();\n+            }\n+\n+            @Override\n+            public void addChangeListener(ChangeListener cl) {\n+            }\n+\n+            @Override\n+            public void removeChangeListener(ChangeListener cl) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Set<? extends Project> getSubprojects() {\n+        Set<Project> prjs = new HashSet<>();\n+        for (SuiteSources imp : imported.values()) {\n+            prjs.add(imp.prj);\n+        }\n+        return prjs;\n+    }\n+\n+    @Override\n+    public URL[] findUnitTests(FileObject fo) {\n+        return new URL[0];\n+    }\n+\n+    @Override\n+    public URL[] findSources(FileObject fo) {\n+        Group g = findGroup(fo);\n+        return g == null ? new URL[0] : new URL[] { g.getRootFolder().toURL() };\n+    }\n+\n+    static interface Dep extends Comparable<Dep> {\n+        String getName();\n+\n+        Collection<String> depNames();\n+\n+        Collection<Dep> allDeps();\n+\n+        void setAllDeps(Collection<Dep> set);\n+\n+        @Override\n+        public default int compareTo(Dep o) {\n+            return getName().compareTo(o.getName());\n+        }\n+\n+        SuiteSources owner();\n+    }\n+\n+    final class Dist implements Dep, FlaggedClassPathImplementation {\n+        final String name;\n+        final MxDistribution dist;\n+        Collection<Dep> allDeps;\n+        private final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        private Boolean exists;\n+        private Collection<Group> groups;\n+\n+        public Dist(String name, MxDistribution dist) {\n+            this.name = name;\n+            this.dist = dist;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            Set<String> deps = new TreeSet<>();\n+            deps.addAll(dist.distDependencies());\n+            deps.addAll(dist.exclude());\n+            return deps;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return this.allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return this.name;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        private FileObject getJar(boolean ignore) {\n+            if (SuiteSources.this.dir == null) {\n+                return null;\n+            }\n+            FileObject dists = SuiteSources.this.dir.getFileObject(\"mxbuild/dists\");\n+            if (dists == null) {\n+                return null;\n+            }\n+            List<FileObject> dist = Arrays.stream(dists.getChildren()).filter((fo) -> fo.isFolder() && fo.getName().startsWith(\"jdk\")).collect(Collectors.toList());\n+            dist.sort((fo1, fo2) -> fo2.getName().compareTo(fo1.getName()));\n+            for (FileObject jdkDir : dist) {\n+                FileObject jar = jdkDir.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+                if (jar != null) {\n+                    return jar;\n+                }\n+            }\n+            FileObject jar = dists.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+            if (jar != null) {\n+                return jar;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public List<? extends PathResourceImplementation> getResources() {\n+            computeTransitiveDeps();\n+            FileObject jar = getJar(exists == null);\n+            final boolean existsNow = jar != null && jar.isData();\n+            if (exists == null) {\n+                exists = existsNow;\n+            } else {\n+                if (exists != existsNow) {\n+                    exists = existsNow;\n+                    support.firePropertyChange(PROP_FLAGS, !exists, (boolean) exists);\n+                }\n+            }\n+            if (jar != null) {\n+                PathResourceImplementation res;\n+                try {\n+                    res = ClassPathSupport.createResource(getJarRoot());\n+                    return Collections.singletonList(res);\n+                } catch (MalformedURLException ex) {\n+                    // OK\n+                }\n+            }\n+            return Collections.emptyList();\n+        }\n+\n+        private URL getJarRoot() throws MalformedURLException {\n+            FileObject jar = getJar(true);\n+            if (jar != null) {\n+                return new URL(\"jar:\" + jar.toURL() + \"!/\");\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener pl) {\n+            support.addPropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener pl) {\n+            support.removePropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+\n+        private void computeSourceRoots(Map<String, Dep> collectedDeps) {\n+            if (groups != null) {\n+                return;\n+            }\n+            Set<Group> contributingGroups = new LinkedHashSet<>();\n+            for (String d : this.dist.dependencies()) {\n+                Dep dep = collectedDeps.get(d);\n+                if (dep == null || dep.allDeps() == null) {\n+                    continue;\n+                }\n+                for (Dep d2 : dep.allDeps()) {\n+                    if (d2 instanceof Group) {\n+                        contributingGroups.add((Group) d2);\n+                    }\n+                }\n+            }\n+            for (String d : this.dist.distDependencies()) {\n+                final Dep anyDep = collectedDeps.get(d);\n+                if (anyDep instanceof Dist) {\n+                    Dist dep = (Dist) anyDep;\n+                    dep.computeSourceRoots(collectedDeps);\n+                    contributingGroups.removeAll(dep.getContributingGroups());\n+                }\n+            }\n+            groups = contributingGroups;\n+        }\n+\n+        public Collection<Group> getContributingGroups() {\n+            return groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Dist[name=\" + name + \"]\";\n+        }\n+    }\n+\n+    final class Group implements SourceGroup, Dep, AnnotationProcessingQuery.Result,\n+            Compliance.Provider {\n+        private final String mxName;\n+        private final MxProject mxPrj;\n+        private final FileObject srcDir;\n+        private final FileObject srcGenDir;\n+        private final FileObject binDir;\n+        private final String name;\n+        private final String displayName;\n+        private final Compliance compliance;\n+        private ClassPath sourceCP;\n+        private ClassPath cp;\n+        private ClassPath processorPath;\n+        private Collection<Dep> allDeps;\n+\n+        Group(String mxName, MxProject mxPrj, FileObject srcDir, FileObject srcGenDir, FileObject binDir, String name, String displayName) {\n+            this.mxName = mxName;\n+            this.mxPrj = mxPrj;\n+            this.srcDir = srcDir;\n+            this.srcGenDir = srcGenDir;\n+            this.binDir = binDir;\n+            this.name = name;\n+            this.displayName = displayName;\n+            this.compliance = Compliance.parse(mxPrj.javaCompliance());\n+        }\n+\n+        @Override\n+        public FileObject getRootFolder() {\n+            return srcDir;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public String getDisplayName() {\n+            return displayName;\n+        }\n+\n+        @Override\n+        public Icon getIcon(boolean opened) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Compliance getCompliance() {\n+            return compliance;\n+        }\n+\n+        @Override\n+        public boolean contains(FileObject file) {\n+            if (file == srcDir || file == srcGenDir || FileUtil.isParentOf(srcDir, file) || (srcGenDir != null && FileUtil.isParentOf(srcGenDir, file))) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SuiteSources.Group[name=\" + name + \",rootFolder=\" + srcDir + \"]\"; // NOI18N\n+        }\n+\n+        ClassPath getSourceCP() {\n+            computeTransitiveDeps();\n+            return sourceCP;\n+        }\n+\n+        ClassPath getCP() {\n+            computeTransitiveDeps();\n+            return cp;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return mxPrj.dependencies();\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            allDeps = set;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        private void computeClassPath(Map<String, Dep> transDeps) {\n+            for (Dep d : transDeps.values()) {\n+                d.owner().computeTransitiveDeps();\n+            }\n+\n+            List<Group> arr = new ArrayList<>();\n+            List<ClassPathImplementation> libs = new ArrayList<>();\n+            processTransDep(transDeps.get(mxName), arr, libs);\n+            cp = composeClassPath(arr, libs);\n+            List<FileObject> roots = new ArrayList<>();\n+            if (srcDir != null) {\n+                roots.add(srcDir);\n+            }\n+            if (srcGenDir != null) {\n+                roots.add(srcGenDir);\n+            }\n+            sourceCP = ClassPathSupport.createClassPath(roots.toArray(new FileObject[roots.size()]));\n+\n+            if (mxPrj.annotationProcessors().isEmpty()) {\n+                processorPath = null;\n+            } else {\n+                List<Group> groups = new ArrayList<>();\n+                List<ClassPathImplementation> jars = new ArrayList<>();\n+                for (String dep : mxPrj.annotationProcessors()) {\n+                    processTransDep(transDeps.get(dep), groups, jars);\n+                }\n+                processorPath = composeClassPath(groups, jars);\n+            }\n+        }\n+\n+        private void processTransDep(Dep dep, List<Group> addGroups, List<ClassPathImplementation> addJars) {\n+            if (dep != null) {\n+                dep.owner().computeTransitiveDeps();\n+                for (Dep d : dep.allDeps()) {\n+                    if (d == this) {\n+                        continue;\n+                    }\n+                    d.owner().computeTransitiveDeps();\n+                    if (d instanceof Group) {\n+                        addGroups.add((Group) d);\n+                    } else if (d instanceof ClassPathImplementation) {\n+                        addJars.add((ClassPathImplementation) d);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ClassPath composeClassPath(List<Group> arr, List<ClassPathImplementation> libs) {\n+            Set<FileObject> roots = new LinkedHashSet<>();\n+            final int depsCount = arr.size();\n+            for (int i = 0; i < depsCount; i++) {\n+                final Group g = arr.get(i);\n+                if (g.binDir != null) {\n+                    roots.add(g.binDir);\n+                }\n+            }\n+            ClassPath prjCp = ClassPathSupport.createClassPath(roots.toArray(new FileObject[0]));\n+            if (!libs.isEmpty()) {\n+                if (libs.size() == 1) {\n+                    prjCp = ClassPathSupport.createProxyClassPath(prjCp,\n+                                                                  ClassPathFactory.createClassPath(libs.get(0))\n+                    );\n+                } else {\n+                    prjCp = ClassPathSupport.createProxyClassPath(prjCp,\n+                                                                  ClassPathFactory.createClassPath(\n+                                                                                  ClassPathSupport.createProxyClassPathImplementation(\n+                                                                                                  libs.toArray(new ClassPathImplementation[0])\n+                                                                                  )\n+                                                                  )\n+                    );\n+                }\n+            }\n+            return prjCp;\n+        }\n+\n+        ClassPath getProcessorCP() {\n+            computeTransitiveDeps();\n+            return processorPath;\n+        }\n+\n+        @Override\n+        public Set<? extends AnnotationProcessingQuery.Trigger> annotationProcessingEnabled() {\n+            return EnumSet.of(AnnotationProcessingQuery.Trigger.ON_SCAN, AnnotationProcessingQuery.Trigger.IN_EDITOR);\n+        }\n+\n+        @Override\n+        public Iterable<? extends String> annotationProcessorsToRun() {\n+            return null;\n+        }\n+\n+        @Override\n+        public URL sourceOutputDirectory() {\n+            return srcGenDir == null ? null : srcGenDir.toURL();\n+        }\n+\n+        @Override\n+        public Map<? extends String, ? extends String> processorOptions() {\n+            return Collections.emptyMap();\n+        }\n+\n+        @Override\n+        public void addChangeListener(ChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removeChangeListener(ChangeListener l) {\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+    }\n+\n+    private class Library implements FlaggedClassPathImplementation, Dep {\n+        final MxLibrary lib;\n+        final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        final String libName;\n+        Collection<Dep> allDeps;\n+        Boolean exists;\n+\n+        Library(String libName, MxLibrary lib) {\n+            this.libName = libName;\n+            this.lib = getOSSLibrary(lib);\n+        }\n+\n+        final MxLibrary getOSSLibrary(MxLibrary lib) {\n+            if (lib.sha1() == null && !lib.os_arch().isEmpty()) {\n+                Map<String, MxLibrary.Arch> os_dep_libs = lib.os_arch();\n+                String os = System.getProperty(\"os.name\").toLowerCase();\n+                for (Map.Entry<String, MxLibrary.Arch> entry : os_dep_libs.entrySet()) {\n+                    if (os.contains(entry.getKey())) {\n+                        return entry.getValue().amd64();\n+                    }\n+                }\n+            }\n+            return lib;\n+        }\n+\n+        File getJar(boolean dumpIfMissing) {\n+            File mxCache;\n+            String cache = System.getenv(\"MX_CACHE_DIR\");\n+            if (cache != null) {\n+                mxCache = new File(cache);\n+            } else {\n+                mxCache = new File(new File(new File(System.getProperty(\"user.home\")), \".mx\"), \"cache\");\n+            }\n+            int prefix = libName.indexOf(':');\n+            final String simpleName = libName.substring(prefix + 1);\n+\n+            File simpleJar = new File(mxCache, simpleName + \"_\" + lib.sha1() + \".jar\");\n+            if (simpleJar.exists()) {\n+                return simpleJar;\n+            }\n+            File dir = new File(mxCache, simpleName + \"_\" + lib.sha1());\n+            File jar = new File(dir, simpleName.replace('_', '-').toLowerCase(Locale.ENGLISH) + \".jar\");\n+\n+            if (dumpIfMissing && !jar.exists()) {\n+                for (File f = jar;; f = f.getParentFile()) {\n+                    if (!f.exists()) {\n+                        LOG.log(Level.WARNING, \"{0} does not exist\", f);\n+                    } else {\n+                        StringBuilder sb = new StringBuilder();\n+                        sb.append(f).append(\" exists:\\n\");\n+                        String[] kids = f.list();\n+                        if (kids != null) {\n+                            for (String n : kids) {\n+                                sb.append(\"  \").append(n).append(\"\\n\");\n+                            }\n+                        }\n+                        LOG.log(Level.INFO, sb.toString());\n+                        break;\n+                    }\n+                }\n+            }\n+            return jar;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return libName;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return lib.dependencies();\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        @Override\n+        public List<? extends PathResourceImplementation> getResources() {\n+            File jar = getJar(exists == null);\n+            if (exists == null) {\n+                exists = jar.exists();\n+            } else {\n+                if (exists != jar.exists()) {\n+                    exists = jar.exists();\n+                    support.firePropertyChange(PROP_FLAGS, !exists, (boolean) exists);\n+                }\n+            }\n+            PathResourceImplementation res;\n+            try {\n+                res = ClassPathSupport.createResource(new URL(\"jar:\" + Utilities.toURI(jar).toURL() + \"!/\"));\n+                return Collections.singletonList(res);\n+            } catch (MalformedURLException ex) {\n+                return Collections.emptyList();\n+            }\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener pl) {\n+            support.addPropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener pl) {\n+            support.removePropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+    }\n+\n+    private class JdkLibrary extends Library {\n+        JdkLibrary(String libName, MxLibrary lib) {\n+            super(libName, lib);\n+        }\n+\n+        @Override\n+        File getJar(boolean dumpIfMissing) {\n+            File first = null;\n+            for (File jdk : jdks()) {\n+                File jre = new File(jdk, \"jre\");\n+                File jrePath = new File(jre, lib.path().replace('/', File.separatorChar));\n+                if (jrePath.exists()) {\n+                    return jrePath;\n+                }\n+\n+                if (first == null) {\n+                    first = jrePath;\n+                }\n+\n+                File jdkPath = new File(jdk, lib.path().replace('/', File.separatorChar));\n+\n+                if (jdkPath.exists()) {\n+                    return jdkPath;\n+                }\n+\n+            }\n+\n+            if (dumpIfMissing) {\n+                for (File jdk : jdks()) {\n+                    File libPath = new File(jdk, lib.path().replace('/', File.separatorChar));\n+                    if (!libPath.exists()) {\n+                        LOG.log(Level.WARNING, \"{0} does not exist\", libPath);\n+                    } else {\n+                        StringBuilder sb = new StringBuilder();\n+                        sb.append(libPath).append(\" exists:\\n\");\n+                        String[] kids = libPath.list();\n+                        if (kids != null) {\n+                            for (String n : kids) {\n+                                sb.append(\"  \").append(n).append(\"\\n\");\n+                            }\n+                        }\n+                        LOG.log(Level.INFO, sb.toString());\n+                        break;\n+                    }\n+                }\n+            }\n+            return first;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return libName;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return lib.dependencies();\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        @Override\n+        public List<? extends PathResourceImplementation> getResources() {", "originalCommit": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyMTg2Nw==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544121867", "bodyText": "Excellent idea: af12108", "author": "JaroslavTulach", "createdAt": "2020-12-16T08:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjM3Nw=="}], "type": "inlineReview"}, {"oid": "de87e99441f604bec03c35a18f0f84f4c2b008e7", "url": "https://github.com/apache/netbeans/commit/de87e99441f604bec03c35a18f0f84f4c2b008e7", "message": "Merge origin/master' into EatingOwnFoodInitialPhase", "committedDate": "2020-12-09T16:44:44Z", "type": "commit"}, {"oid": "3933d300360c5990a08131d529269e52e719146c", "url": "https://github.com/apache/netbeans/commit/3933d300360c5990a08131d529269e52e719146c", "message": "Removing unused argument and treating warnings as errors", "committedDate": "2020-12-16T08:07:39Z", "type": "commit"}, {"oid": "b69f4669e34f7790c956f290fbd4bb10bbb6c10d", "url": "https://github.com/apache/netbeans/commit/b69f4669e34f7790c956f290fbd4bb10bbb6c10d", "message": "Up to date with master", "committedDate": "2020-12-16T08:08:07Z", "type": "commit"}, {"oid": "9e9567e47292c114f32c804e06fef4cc47c43e44", "url": "https://github.com/apache/netbeans/commit/9e9567e47292c114f32c804e06fef4cc47c43e44", "message": "exists could be null", "committedDate": "2020-12-16T08:27:01Z", "type": "commit"}, {"oid": "5b589ee5930f13d86dd1bc66e8f326eb8c64f396", "url": "https://github.com/apache/netbeans/commit/5b589ee5930f13d86dd1bc66e8f326eb8c64f396", "message": "Naming to indicate transitiveDeps are always processed just once", "committedDate": "2020-12-16T08:34:41Z", "type": "commit"}, {"oid": "af12108a52897ee2d793f3ac57ac4c3fcf71a9cd", "url": "https://github.com/apache/netbeans/commit/af12108a52897ee2d793f3ac57ac4c3fcf71a9cd", "message": "Sharing the FLAGS implementation between all three element types", "committedDate": "2020-12-16T08:56:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NTM5Mw==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544175393", "bodyText": "Alas, this test seems to randomly fail.", "author": "JaroslavTulach", "createdAt": "2020-12-16T10:15:08Z", "path": "java/java.mx.project/test/unit/src/org/netbeans/modules/java/mx/project/SuiteCheck.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.Locale;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogManager;\n+import java.util.logging.Logger;\n+import javax.tools.Diagnostic;\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertNotNull;\n+import static junit.framework.TestCase.assertSame;\n+import static junit.framework.TestCase.assertTrue;\n+import static junit.framework.TestCase.fail;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.junit.Assume;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.classpath.JavaClassPathConstants;\n+import org.netbeans.api.java.queries.BinaryForSourceQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.java.source.CompilationController;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.project.FileOwnerQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.ProjectUtils;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.api.project.ui.OpenProjects;\n+import org.netbeans.junit.NbTestCase;\n+import org.netbeans.modules.parsing.api.indexing.IndexingManager;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.util.Utilities;\n+\n+abstract class SuiteCheck extends NbTestCase {\n+    SuiteCheck(String name) {\n+        super(name);\n+        log(Level.INFO, \"Test created by %s classloader\", getClass().getClassLoader());\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        log(Level.INFO, \"setUp - init\");\n+        super.setUp();\n+        final Logger tooVerboseLogger = Logger.getLogger(\"org.netbeans.core.startup.InstalledFileLocatorImpl\");\n+        tooVerboseLogger.setUseParentHandlers(false);\n+        try {\n+            MxSuite.parse(null);\n+        } catch (LinkageError err) {\n+            Assume.assumeNoException(\"Cannot initialize Polyglot API, are you using GraalVM?\", err);\n+        }\n+        log(Level.INFO, \"setUp - exit\");\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        Enumeration<String> en = LogManager.getLogManager().getLoggerNames();\n+        while (en.hasMoreElements()) {\n+            String n = en.nextElement();\n+            Logger l = LogManager.getLogManager().getLogger(n);\n+            boolean first = true;\n+            if (l == null || l.getHandlers() == null) {\n+                continue;\n+            }\n+            for (Handler h : l.getHandlers()) {\n+                if (first) {\n+                    System.err.println(\"cleaning logger '\" + n + \"'\");\n+                    first = false;\n+                }\n+                System.err.println(\"  removing handler: \" + h);\n+                l.removeHandler(h);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected int timeOut() {\n+        return 1_200_000;\n+    }\n+\n+    protected final void verifyNoErrorsInSuite(final String suiteName, String... onlySourceGroups) throws IllegalArgumentException, IOException, URISyntaxException {\n+        long begin = System.currentTimeMillis();\n+        File sibling = findSuite(suiteName);\n+\n+        FileObject fo = FileUtil.toFileObject(sibling);\n+        assertNotNull(\"project directory found\", fo);\n+\n+        log(Level.INFO, \"Recognizing project %s\", fo);\n+        long now = System.currentTimeMillis();\n+        Project p = ProjectManager.getDefault().findProject(fo);\n+        long took = System.currentTimeMillis() - now;\n+        assertNotNull(\"project found\", p);\n+        log(Level.INFO, \"Project found %s in %d ms\", p, took);\n+        assertEquals(\"It is suite project: \" + p, \"SuiteProject\", p.getClass().getSimpleName());\n+        OpenProjects.getDefault().open(new Project[]{p}, false);\n+\n+        StringBuilder errors = new StringBuilder();\n+        FileObject[] errornous = { null };\n+        Sources src = ProjectUtils.getSources(p);\n+        int cnt = 0;\n+        for (SourceGroup sourceGroup : src.getSourceGroups(\"java\")) {\n+            if (sourceGroup instanceof Compliance.Provider) {\n+                Compliance c = ((Compliance.Provider) sourceGroup).getCompliance();\n+                if (!c.includes(8)) {\n+                    log(Level.INFO, \"Skipping check of %s with compliance %s\", sourceGroup, c);\n+                    continue;\n+                }\n+            }\n+            FOUND: if (onlySourceGroups.length > 0) {\n+                for (String gName : onlySourceGroups) {\n+                    if (sourceGroup.getDisplayName().equals(gName)) {\n+                        cnt++;\n+                        break FOUND;\n+                    }\n+                }\n+                // not found\n+                continue;\n+            }\n+            assertSourcesNoError(p, errornous, errors, sourceGroup.getRootFolder(), begin);\n+        }\n+        assertCompilationErrors(errors, errornous);\n+\n+        assertEquals(\"Exactly as many source groups tested as requested\", onlySourceGroups.length, cnt);\n+    }\n+\n+    protected final File findSuite(String suite) throws URISyntaxException {\n+        File location = getDataDir();\n+        while (location != null) {\n+            File graal = new File(location, \"graal\");\n+            File suiteDir = new File(graal, suite);\n+            if (suiteDir.isDirectory()) {\n+                return suiteDir;\n+            }\n+            location = location.getParentFile();\n+        }\n+        fail(\"Cannot find truffle next to \" + getDataDir());\n+        return null;\n+    }\n+\n+    private void assertSourcesNoError(Project project, FileObject[] errornous, StringBuilder errors, FileObject dir, long begin) throws IOException {\n+        long now = System.currentTimeMillis();\n+        log(Level.INFO, \"assertSourcesNoError for %s\", dir);\n+        IndexingManager.getDefault().refreshIndexAndWait(dir.toURL(), null, false);\n+        log(Level.INFO, \"      refresh done       %s\", dir);\n+        Enumeration<? extends FileObject> en = dir.getChildren(true);\n+        int nonJavaCount = 0;\n+        int javaCount = 0;\n+        while (en.hasMoreElements()) {\n+            FileObject fo = en.nextElement();\n+            if (fo.isFolder()) {\n+                continue;\n+            }\n+            Project prj = FileOwnerQuery.getOwner(fo);\n+            assertSame(\"FileOwnerQuery returns the right project\", project, prj);\n+            if (!fo.hasExt(\"java\")) {\n+                nonJavaCount++;\n+                continue;\n+            }\n+            JavaSource source = JavaSource.forFileObject(fo);", "originalCommit": "af12108a52897ee2d793f3ac57ac4c3fcf71a9cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI4NDM3Mg==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544284372", "bodyText": "Hopefully it fails only if the .mx/cache doesn't contain necessary JAR libraries (locally I have them). Let's see whether this gets fixed after 4cbe7aa", "author": "JaroslavTulach", "createdAt": "2020-12-16T13:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NTM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NjA2MA==", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544176060", "bodyText": "Is there a better way to verify project sources are fine from a NetBeans Java Source support perspective?", "author": "JaroslavTulach", "createdAt": "2020-12-16T10:16:07Z", "path": "java/java.mx.project/test/unit/src/org/netbeans/modules/java/mx/project/SuiteCheck.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.Locale;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogManager;\n+import java.util.logging.Logger;\n+import javax.tools.Diagnostic;\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertNotNull;\n+import static junit.framework.TestCase.assertSame;\n+import static junit.framework.TestCase.assertTrue;\n+import static junit.framework.TestCase.fail;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.junit.Assume;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.classpath.JavaClassPathConstants;\n+import org.netbeans.api.java.queries.BinaryForSourceQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.java.source.CompilationController;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.project.FileOwnerQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.ProjectUtils;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.api.project.ui.OpenProjects;\n+import org.netbeans.junit.NbTestCase;\n+import org.netbeans.modules.parsing.api.indexing.IndexingManager;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.util.Utilities;\n+\n+abstract class SuiteCheck extends NbTestCase {\n+    SuiteCheck(String name) {\n+        super(name);\n+        log(Level.INFO, \"Test created by %s classloader\", getClass().getClassLoader());\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        log(Level.INFO, \"setUp - init\");\n+        super.setUp();\n+        final Logger tooVerboseLogger = Logger.getLogger(\"org.netbeans.core.startup.InstalledFileLocatorImpl\");\n+        tooVerboseLogger.setUseParentHandlers(false);\n+        try {\n+            MxSuite.parse(null);\n+        } catch (LinkageError err) {\n+            Assume.assumeNoException(\"Cannot initialize Polyglot API, are you using GraalVM?\", err);\n+        }\n+        log(Level.INFO, \"setUp - exit\");\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        Enumeration<String> en = LogManager.getLogManager().getLoggerNames();\n+        while (en.hasMoreElements()) {\n+            String n = en.nextElement();\n+            Logger l = LogManager.getLogManager().getLogger(n);\n+            boolean first = true;\n+            if (l == null || l.getHandlers() == null) {\n+                continue;\n+            }\n+            for (Handler h : l.getHandlers()) {\n+                if (first) {\n+                    System.err.println(\"cleaning logger '\" + n + \"'\");\n+                    first = false;\n+                }\n+                System.err.println(\"  removing handler: \" + h);\n+                l.removeHandler(h);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected int timeOut() {\n+        return 1_200_000;\n+    }\n+\n+    protected final void verifyNoErrorsInSuite(final String suiteName, String... onlySourceGroups) throws IllegalArgumentException, IOException, URISyntaxException {\n+        long begin = System.currentTimeMillis();\n+        File sibling = findSuite(suiteName);\n+\n+        FileObject fo = FileUtil.toFileObject(sibling);\n+        assertNotNull(\"project directory found\", fo);\n+\n+        log(Level.INFO, \"Recognizing project %s\", fo);\n+        long now = System.currentTimeMillis();\n+        Project p = ProjectManager.getDefault().findProject(fo);\n+        long took = System.currentTimeMillis() - now;\n+        assertNotNull(\"project found\", p);\n+        log(Level.INFO, \"Project found %s in %d ms\", p, took);\n+        assertEquals(\"It is suite project: \" + p, \"SuiteProject\", p.getClass().getSimpleName());\n+        OpenProjects.getDefault().open(new Project[]{p}, false);\n+\n+        StringBuilder errors = new StringBuilder();\n+        FileObject[] errornous = { null };\n+        Sources src = ProjectUtils.getSources(p);\n+        int cnt = 0;\n+        for (SourceGroup sourceGroup : src.getSourceGroups(\"java\")) {\n+            if (sourceGroup instanceof Compliance.Provider) {\n+                Compliance c = ((Compliance.Provider) sourceGroup).getCompliance();\n+                if (!c.includes(8)) {\n+                    log(Level.INFO, \"Skipping check of %s with compliance %s\", sourceGroup, c);\n+                    continue;\n+                }\n+            }\n+            FOUND: if (onlySourceGroups.length > 0) {\n+                for (String gName : onlySourceGroups) {\n+                    if (sourceGroup.getDisplayName().equals(gName)) {\n+                        cnt++;\n+                        break FOUND;\n+                    }\n+                }\n+                // not found\n+                continue;\n+            }\n+            assertSourcesNoError(p, errornous, errors, sourceGroup.getRootFolder(), begin);\n+        }\n+        assertCompilationErrors(errors, errornous);\n+\n+        assertEquals(\"Exactly as many source groups tested as requested\", onlySourceGroups.length, cnt);\n+    }\n+\n+    protected final File findSuite(String suite) throws URISyntaxException {\n+        File location = getDataDir();\n+        while (location != null) {\n+            File graal = new File(location, \"graal\");\n+            File suiteDir = new File(graal, suite);\n+            if (suiteDir.isDirectory()) {\n+                return suiteDir;\n+            }\n+            location = location.getParentFile();\n+        }\n+        fail(\"Cannot find truffle next to \" + getDataDir());\n+        return null;\n+    }\n+\n+    private void assertSourcesNoError(Project project, FileObject[] errornous, StringBuilder errors, FileObject dir, long begin) throws IOException {\n+        long now = System.currentTimeMillis();\n+        log(Level.INFO, \"assertSourcesNoError for %s\", dir);\n+        IndexingManager.getDefault().refreshIndexAndWait(dir.toURL(), null, false);\n+        log(Level.INFO, \"      refresh done       %s\", dir);\n+        Enumeration<? extends FileObject> en = dir.getChildren(true);\n+        int nonJavaCount = 0;\n+        int javaCount = 0;\n+        while (en.hasMoreElements()) {\n+            FileObject fo = en.nextElement();\n+            if (fo.isFolder()) {\n+                continue;\n+            }\n+            Project prj = FileOwnerQuery.getOwner(fo);\n+            assertSame(\"FileOwnerQuery returns the right project\", project, prj);\n+            if (!fo.hasExt(\"java\")) {\n+                nonJavaCount++;\n+                continue;\n+            }\n+            JavaSource source = JavaSource.forFileObject(fo);\n+            if (source == null) {\n+                fail(\"No source for \" + fo);\n+            }\n+            javaCount++;\n+            BinaryForSourceQuery.Result res = BinaryForSourceQuery.findBinaryRoots(dir.toURL());\n+            assertEquals(\"There is one binary root: \" + Arrays.toString(res.getRoots()), 1, res.getRoots().length);\n+            OK: for (URL root : res.getRoots()) {\n+                SourceForBinaryQuery.Result2 res2 = SourceForBinaryQuery.findSourceRoots2(root);\n+                assertTrue(\"Has to prefer sources\", res2.preferSources());\n+                for (FileObject src : res2.getRoots()) {\n+                    if (src.equals(dir)) {\n+                        break OK;\n+                    }\n+                }\n+                fail(\"Expecting to find \" + dir + \" among:\\n\" + Arrays.toString(res2.getRoots()));\n+            }\n+            source.runUserActionTask((CompilationController p) -> {", "originalCommit": "af12108a52897ee2d793f3ac57ac4c3fcf71a9cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4cbe7aa0ff86c37ed162dae14072c26ec25bd100", "url": "https://github.com/apache/netbeans/commit/4cbe7aa0ff86c37ed162dae14072c26ec25bd100", "message": "Download essential libraries into ~/.mx/cache", "committedDate": "2020-12-16T13:05:33Z", "type": "forcePushed"}, {"oid": "80e5ea1e884a34df23062095cf60624600cb14d7", "url": "https://github.com/apache/netbeans/commit/80e5ea1e884a34df23062095cf60624600cb14d7", "message": "Download essential libraries into ~/.mx/cache", "committedDate": "2020-12-16T15:21:09Z", "type": "commit"}, {"oid": "80e5ea1e884a34df23062095cf60624600cb14d7", "url": "https://github.com/apache/netbeans/commit/80e5ea1e884a34df23062095cf60624600cb14d7", "message": "Download essential libraries into ~/.mx/cache", "committedDate": "2020-12-16T15:21:09Z", "type": "forcePushed"}]}