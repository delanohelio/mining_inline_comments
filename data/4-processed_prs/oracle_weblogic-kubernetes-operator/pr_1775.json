{"pr_number": 1775, "pr_title": "Default resources java options", "pr_createdAt": "2020-06-30T13:10:08Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775", "timeline": [{"oid": "ede68e17d0637ddaa2671c72c4f9d6396b7ae034", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ede68e17d0637ddaa2671c72c4f9d6396b7ae034", "message": "Changes for OWLS-80384 - Verify that operator deployment and WebLogic pods have good default cpu/memory resources", "committedDate": "2020-06-30T12:59:01Z", "type": "commit"}, {"oid": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a23d465d277d44c2f5b22ee39ff66f06948acfa1", "message": "changes for OWLS-80384 - Verify that operator deployment and WebLogic pods have good default cpu/memory resources", "committedDate": "2020-06-30T13:02:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3MjMxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447772318", "bodyText": "Replace every \".s\" in this document with \"'s\".", "author": "tbarnes-us", "createdAt": "2020-06-30T15:25:49Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3MzYzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447773635", "bodyText": "rouge -> rogue (took me a bit to figure that one out - interesting autocorrect :-) )", "author": "tbarnes-us", "createdAt": "2020-06-30T15:27:34Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3Njg3OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447776879", "bodyText": "Additionally, pod.s ... --> Additionally, a pod's priority and Quality of Service (QoS) is affected by whether or not it specifies resource requests and limits.", "author": "tbarnes-us", "createdAt": "2020-06-30T15:31:43Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY5MzMyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447693322", "bodyText": "Considerations for Pod Resource (Memory and CPU) Requests and Limits -> Considerations for Pod resource (memory and CPU) requests and limits  (we use sentence capitalization instead of title capitalization; appears more user friendly)", "author": "rosemarymarano", "createdAt": "2020-06-30T13:43:52Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY5NDc1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447694759", "bodyText": "pod -> Pod (globally, if you are referring to a Kubernetes resource)\nIt.s -> It's (typo)", "author": "rosemarymarano", "createdAt": "2020-06-30T13:45:53Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY5NjQxNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447696415", "bodyText": "node -> Node (globally, if you are referring to a Kubernetes resource)\nIt.s -> It's (typo, globally)\nrouge -> rogue\nhas memory leak -> has a memory leak", "author": "rosemarymarano", "createdAt": "2020-06-30T13:48:10Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY5OTk0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447699944", "bodyText": "pod.s -> pod's (typo, globally; your apostrophes are periods)\nof resource -> of resources\nIt also allows users to plan -> Also, it lets you plan\npod.s priority and the Quality of Service (QoS) that pod receives -> the pod's priority and Quality of Service (QoS) that the pod receives\nare specified or not. -> are specified.", "author": "rosemarymarano", "createdAt": "2020-06-30T13:52:50Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwMDQ0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447700444", "bodyText": "Prioritization -> prioritization", "author": "rosemarymarano", "createdAt": "2020-06-30T13:53:31Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwMjMxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447702318", "bodyText": "Pod.s Quality of Service (QoS) -> A Pod's QoS (you don't have to repeat the spelled out acronym more than once)\nwhether pod.s resource -> whether the pod's resource\nare configured or not -> are configured", "author": "rosemarymarano", "createdAt": "2020-06-30T13:55:52Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwMzg0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447703846", "bodyText": "Best Effort QoS -> Best-Effort QoS (IF you hyphenate it in the description, you must hyphenate it in the title)\nlimits, pod receives .best-effort. QoS -> limits, then the pod receives \"best-effort\" QoS\nwhere node -> where a Node", "author": "rosemarymarano", "createdAt": "2020-06-30T13:57:57Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcxNDA4Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447714087", "bodyText": "values, pod will have .Guranteed. -> values, then the Pod will have \"guaranteed\"\nand pod will be considered as of the top -> and it will be considered as the top\nsettings indicates ->  settings indicate\nresources, Kubernetes -> resources, then Kubernetes", "author": "rosemarymarano", "createdAt": "2020-06-30T14:11:21Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcxNzIxMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447717212", "bodyText": "limit, pod.s QoS -> limit, then the pod's QoS\n.Burstable. -> \"burstable\" (does not need to be capitalized in the paragraph; the choice is to capitalize best-effort, burstable, and guaranteed consistently in the paras) or to keep them all lower case.)", "author": "rosemarymarano", "createdAt": "2020-06-30T14:15:16Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcyMjU2NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447722565", "bodyText": "to set correct heap -> to set the correct heap\nIf available memory on node or memory allocated to container -> If the available memory on a Node or the memory allocated to a container\nfor specified JVM heap arguments -> for the specified JVM heap arguments\nWL process  -> WebLogic processes\nthat configured heap sizes -> that the configured heap sizes", "author": "rosemarymarano", "createdAt": "2020-06-30T14:22:14Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3OTQ4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447779489", "bodyText": "heap sizes (-Xms and -Xmx), JVM will -> heap sizes (-Xms and -Xmx), then the JVM will\nof container memory limit -> of the container memory limit\nof limit value -> of the limit value", "author": "rosemarymarano", "createdAt": "2020-06-30T15:35:25Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MDc0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447780746", "bodyText": "configure default -> configure the default\nWebLogic server java process -> WebLogic Server Java processes\nusing USER_MEM_ARG -> using the USER_MEM_ARG", "author": "rosemarymarano", "createdAt": "2020-06-30T15:37:12Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MTY0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447781643", "bodyText": "for node-manager process -> for the node-manager process\nusing NODEMGR_MEM_ARGS -> using the NODEMGR_MEM_ARGS", "author": "rosemarymarano", "createdAt": "2020-06-30T15:38:29Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MjM0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447782346", "bodyText": "and default CPU request -> and the default CPU request\nThe requests values -> The request values\nin resources section. -> in the resources section.", "author": "rosemarymarano", "createdAt": "2020-06-30T15:39:31Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4NDA5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447784093", "bodyText": "by default in samples and default -> by default in the samples and the default\nWebLogic server pod -> WebLogic Server pods (always capitalize WebLogic Server, both words; please fix globally)\ndetermine optimal -> determine the optimal", "author": "rosemarymarano", "createdAt": "2020-06-30T15:41:58Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.\n+```\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+```\n+\n+There.s no memory or CPU limit configured by default in samples and default QoS for WebLogic server pod is Burstable. If your use-case and workload requires higher QoS and priority, this can be achieved by setting memory and CPU limits. You.ll need to run tests and experiment with different memory/CPU limits to determine optimal limit values.", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4NjkwNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447786907", "bodyText": "specify pod memory limit, it's  -> specify a pod memory limit, then it's\nrecommended to configure heap size -> recommended that you configure the heap size\nnote . they -> note that they\n\"Thanks to it changing container memory settings will not break anything.\" I cannot figure out what it is that you want to say in this sentence, so I can't figure out how to help you clarify it, but whatever it is, it is not clear.", "author": "rosemarymarano", "createdAt": "2020-06-30T15:46:02Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.\n+```\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+```\n+\n+There.s no memory or CPU limit configured by default in samples and default QoS for WebLogic server pod is Burstable. If your use-case and workload requires higher QoS and priority, this can be achieved by setting memory and CPU limits. You.ll need to run tests and experiment with different memory/CPU limits to determine optimal limit values.\n+```\n+      limits:\n+        cpu: 2\n+        memory: \"2048Mi\"\n+```\n+\n+### Configure min/max heap size in percentages using \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\"\n+If you specify pod memory limit, it's recommended to configure heap size as a percentage of the total RAM (memory) specified in the pod memory limit. These parameters allow you to fine-tune the heap size. Please note . they set the percentage, not the fixed values. Thanks to it changing container memory settings will not break anything. ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5Mjk5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447792998", "bodyText": "the limit is sufficiently big -> the limit is big enough\nbut it's not too big to waste memory resource. -> but not too big, which would waste memory resource.\nSince pod memory -> Because pod memory\nif JVM's memory -> if the JVM's memory\nsum of heap -> sum of the heap\nlimit, JVM process -> limit, the JVM process\nto out-of-memory error -> to an out-of-memory error\nand WebLogic container -> and the WebLogic container\ndue to liveness probe -> due to a liveness probe\nrunning in same container -> running in the same container\nnode manager -> Node Manager\nusing .NODEMGR_JAVA_OPTIONS.  -> using the NODEMGR_JAVA_OPTIONS", "author": "rosemarymarano", "createdAt": "2020-06-30T15:53:43Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.\n+```\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+```\n+\n+There.s no memory or CPU limit configured by default in samples and default QoS for WebLogic server pod is Burstable. If your use-case and workload requires higher QoS and priority, this can be achieved by setting memory and CPU limits. You.ll need to run tests and experiment with different memory/CPU limits to determine optimal limit values.\n+```\n+      limits:\n+        cpu: 2\n+        memory: \"2048Mi\"\n+```\n+\n+### Configure min/max heap size in percentages using \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\"\n+If you specify pod memory limit, it's recommended to configure heap size as a percentage of the total RAM (memory) specified in the pod memory limit. These parameters allow you to fine-tune the heap size. Please note . they set the percentage, not the fixed values. Thanks to it changing container memory settings will not break anything. \n+```\n+    resources:\n+      env:\n+      - name: JAVA_OPTIONS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Dweblogic.StdoutDebugEnabled=false\"\n+```\n+When configuring memory limits, it.s important to make sure that the limit is sufficiently big to accommodate the configured heap (and off-heap) requirements, but it's not too big to waste memory resource. Since pod memory will never go above the limit, if JVM's memory usage (sum of heap and native memory) goes above the limit, JVM process will be killed due to out-of-memory error and WebLogic container will be restarted due to liveness probe failure.   Additionally there's also a node-manager process that.s running in same container and it has it's own heap and off-heap requirements. You can also fine tune the node manager heap size in percentages by setting \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\" using .NODEMGR_JAVA_OPTIONS. environment variable. ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NDg1OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447794858", "bodyText": "can use traditional approach -> can use the traditional approach", "author": "rosemarymarano", "createdAt": "2020-06-30T15:56:15Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.\n+```\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+```\n+\n+There.s no memory or CPU limit configured by default in samples and default QoS for WebLogic server pod is Burstable. If your use-case and workload requires higher QoS and priority, this can be achieved by setting memory and CPU limits. You.ll need to run tests and experiment with different memory/CPU limits to determine optimal limit values.\n+```\n+      limits:\n+        cpu: 2\n+        memory: \"2048Mi\"\n+```\n+\n+### Configure min/max heap size in percentages using \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\"\n+If you specify pod memory limit, it's recommended to configure heap size as a percentage of the total RAM (memory) specified in the pod memory limit. These parameters allow you to fine-tune the heap size. Please note . they set the percentage, not the fixed values. Thanks to it changing container memory settings will not break anything. \n+```\n+    resources:\n+      env:\n+      - name: JAVA_OPTIONS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Dweblogic.StdoutDebugEnabled=false\"\n+```\n+When configuring memory limits, it.s important to make sure that the limit is sufficiently big to accommodate the configured heap (and off-heap) requirements, but it's not too big to waste memory resource. Since pod memory will never go above the limit, if JVM's memory usage (sum of heap and native memory) goes above the limit, JVM process will be killed due to out-of-memory error and WebLogic container will be restarted due to liveness probe failure.   Additionally there's also a node-manager process that.s running in same container and it has it's own heap and off-heap requirements. You can also fine tune the node manager heap size in percentages by setting \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\" using .NODEMGR_JAVA_OPTIONS. environment variable. \n+\n+### Using \"-Xms\" and \"-Xmx\" parameters when not configuring limits \n+In some cases, it.s difficult to come up with a hard limit for the container and you might only want to configure memory requests but not configure memory limits. In such scenarios, you can use traditional approach to set min/max heap size using .-Xms. and .-Xmx..", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5ODk2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447798962", "bodyText": "applications performance -> application performance\nYou also don't want to set CPU requests -> Also you don't want to set the CPU requests\napplication don't need -> application doesn't need\nSince CPU -> Because CPU\nall CPU resources -> all the CPU resources\non node -> on the node", "author": "rosemarymarano", "createdAt": "2020-06-30T16:02:07Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.\n+```\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+```\n+\n+There.s no memory or CPU limit configured by default in samples and default QoS for WebLogic server pod is Burstable. If your use-case and workload requires higher QoS and priority, this can be achieved by setting memory and CPU limits. You.ll need to run tests and experiment with different memory/CPU limits to determine optimal limit values.\n+```\n+      limits:\n+        cpu: 2\n+        memory: \"2048Mi\"\n+```\n+\n+### Configure min/max heap size in percentages using \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\"\n+If you specify pod memory limit, it's recommended to configure heap size as a percentage of the total RAM (memory) specified in the pod memory limit. These parameters allow you to fine-tune the heap size. Please note . they set the percentage, not the fixed values. Thanks to it changing container memory settings will not break anything. \n+```\n+    resources:\n+      env:\n+      - name: JAVA_OPTIONS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Dweblogic.StdoutDebugEnabled=false\"\n+```\n+When configuring memory limits, it.s important to make sure that the limit is sufficiently big to accommodate the configured heap (and off-heap) requirements, but it's not too big to waste memory resource. Since pod memory will never go above the limit, if JVM's memory usage (sum of heap and native memory) goes above the limit, JVM process will be killed due to out-of-memory error and WebLogic container will be restarted due to liveness probe failure.   Additionally there's also a node-manager process that.s running in same container and it has it's own heap and off-heap requirements. You can also fine tune the node manager heap size in percentages by setting \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\" using .NODEMGR_JAVA_OPTIONS. environment variable. \n+\n+### Using \"-Xms\" and \"-Xmx\" parameters when not configuring limits \n+In some cases, it.s difficult to come up with a hard limit for the container and you might only want to configure memory requests but not configure memory limits. In such scenarios, you can use traditional approach to set min/max heap size using .-Xms. and .-Xmx..\n+\n+### CPU requests and limits \n+It.s important that the containers running WebLogic applications have enough CPU resources, otherwise applications performance can suffer. You also don't want to set CPU requests and limit too high if your application don't need or use allocated CPU resources. Since CPU is a shared resource, if the amount of CPU that you reserve is more than required by your application, the CPU cycles will go unused and be wasted. If no CPU request and limit is configured, it can end up using all CPU resources available on node. This can starve other containers from using shareable CPU cycles. ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5OTg4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447799886", "bodyText": "if pod CPU limit -> if the pod CPU limit\nspecify container -> specify the container\nto incorrect number -> to an incorrect number", "author": "rosemarymarano", "createdAt": "2020-06-30T16:03:30Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.\n+```\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+```\n+\n+There.s no memory or CPU limit configured by default in samples and default QoS for WebLogic server pod is Burstable. If your use-case and workload requires higher QoS and priority, this can be achieved by setting memory and CPU limits. You.ll need to run tests and experiment with different memory/CPU limits to determine optimal limit values.\n+```\n+      limits:\n+        cpu: 2\n+        memory: \"2048Mi\"\n+```\n+\n+### Configure min/max heap size in percentages using \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\"\n+If you specify pod memory limit, it's recommended to configure heap size as a percentage of the total RAM (memory) specified in the pod memory limit. These parameters allow you to fine-tune the heap size. Please note . they set the percentage, not the fixed values. Thanks to it changing container memory settings will not break anything. \n+```\n+    resources:\n+      env:\n+      - name: JAVA_OPTIONS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Dweblogic.StdoutDebugEnabled=false\"\n+```\n+When configuring memory limits, it.s important to make sure that the limit is sufficiently big to accommodate the configured heap (and off-heap) requirements, but it's not too big to waste memory resource. Since pod memory will never go above the limit, if JVM's memory usage (sum of heap and native memory) goes above the limit, JVM process will be killed due to out-of-memory error and WebLogic container will be restarted due to liveness probe failure.   Additionally there's also a node-manager process that.s running in same container and it has it's own heap and off-heap requirements. You can also fine tune the node manager heap size in percentages by setting \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\" using .NODEMGR_JAVA_OPTIONS. environment variable. \n+\n+### Using \"-Xms\" and \"-Xmx\" parameters when not configuring limits \n+In some cases, it.s difficult to come up with a hard limit for the container and you might only want to configure memory requests but not configure memory limits. In such scenarios, you can use traditional approach to set min/max heap size using .-Xms. and .-Xmx..\n+\n+### CPU requests and limits \n+It.s important that the containers running WebLogic applications have enough CPU resources, otherwise applications performance can suffer. You also don't want to set CPU requests and limit too high if your application don't need or use allocated CPU resources. Since CPU is a shared resource, if the amount of CPU that you reserve is more than required by your application, the CPU cycles will go unused and be wasted. If no CPU request and limit is configured, it can end up using all CPU resources available on node. This can starve other containers from using shareable CPU cycles. \n+\n+One other thing to keep in mind is that if pod CPU limit is not configured, it might lead to incorrect garbage collection (GC) strategy selection. WebLogic self-tuning work-manager uses pod CPU limit to configure the  number of threads in a default thread pool. If you don.t specify container CPU limit, the performance might be affected due to incorrect number of GC threads or wrong WebLogic server thread pool size. ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjQ2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447802469", "bodyText": "than core count -> than the core count\nkubernetes -> Kubernetes (always capitalized; please fix globally)\nare normally designed -> are typically designed\nconsidered as a -> considered a\napps  -> applications (globally)", "author": "rosemarymarano", "createdAt": "2020-06-30T16:07:31Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.\n+```\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+```\n+\n+There.s no memory or CPU limit configured by default in samples and default QoS for WebLogic server pod is Burstable. If your use-case and workload requires higher QoS and priority, this can be achieved by setting memory and CPU limits. You.ll need to run tests and experiment with different memory/CPU limits to determine optimal limit values.\n+```\n+      limits:\n+        cpu: 2\n+        memory: \"2048Mi\"\n+```\n+\n+### Configure min/max heap size in percentages using \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\"\n+If you specify pod memory limit, it's recommended to configure heap size as a percentage of the total RAM (memory) specified in the pod memory limit. These parameters allow you to fine-tune the heap size. Please note . they set the percentage, not the fixed values. Thanks to it changing container memory settings will not break anything. \n+```\n+    resources:\n+      env:\n+      - name: JAVA_OPTIONS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Dweblogic.StdoutDebugEnabled=false\"\n+```\n+When configuring memory limits, it.s important to make sure that the limit is sufficiently big to accommodate the configured heap (and off-heap) requirements, but it's not too big to waste memory resource. Since pod memory will never go above the limit, if JVM's memory usage (sum of heap and native memory) goes above the limit, JVM process will be killed due to out-of-memory error and WebLogic container will be restarted due to liveness probe failure.   Additionally there's also a node-manager process that.s running in same container and it has it's own heap and off-heap requirements. You can also fine tune the node manager heap size in percentages by setting \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\" using .NODEMGR_JAVA_OPTIONS. environment variable. \n+\n+### Using \"-Xms\" and \"-Xmx\" parameters when not configuring limits \n+In some cases, it.s difficult to come up with a hard limit for the container and you might only want to configure memory requests but not configure memory limits. In such scenarios, you can use traditional approach to set min/max heap size using .-Xms. and .-Xmx..\n+\n+### CPU requests and limits \n+It.s important that the containers running WebLogic applications have enough CPU resources, otherwise applications performance can suffer. You also don't want to set CPU requests and limit too high if your application don't need or use allocated CPU resources. Since CPU is a shared resource, if the amount of CPU that you reserve is more than required by your application, the CPU cycles will go unused and be wasted. If no CPU request and limit is configured, it can end up using all CPU resources available on node. This can starve other containers from using shareable CPU cycles. \n+\n+One other thing to keep in mind is that if pod CPU limit is not configured, it might lead to incorrect garbage collection (GC) strategy selection. WebLogic self-tuning work-manager uses pod CPU limit to configure the  number of threads in a default thread pool. If you don.t specify container CPU limit, the performance might be affected due to incorrect number of GC threads or wrong WebLogic server thread pool size. \n+\n+## Beware of setting resource limits too high\n+It.s important to keep in mind that if you set a value of CPU core count that.s larger than core count of the biggest node, then the pod will never be scheduled. Let.s say you have a pod that needs 4 cores but you have a kubernetes cluster that.s comprised of 2 core VMs. In this case, your pod will never be scheduled.  WebLogic applications are normally designed to take advantage of multiple cores and should be given CPU requests as such. CPUs are considered as a compressible resource. If your apps are hitting CPU limits, kubernetes will start to throttle your container. This means your CPU will be artificially restricted, giving your app potentially worse performance. However it won.t be terminated or evicted. ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjc4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447802781", "bodyText": "than amount -> than he amount", "author": "rosemarymarano", "createdAt": "2020-06-30T16:07:58Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.\n+```\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+```\n+\n+There.s no memory or CPU limit configured by default in samples and default QoS for WebLogic server pod is Burstable. If your use-case and workload requires higher QoS and priority, this can be achieved by setting memory and CPU limits. You.ll need to run tests and experiment with different memory/CPU limits to determine optimal limit values.\n+```\n+      limits:\n+        cpu: 2\n+        memory: \"2048Mi\"\n+```\n+\n+### Configure min/max heap size in percentages using \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\"\n+If you specify pod memory limit, it's recommended to configure heap size as a percentage of the total RAM (memory) specified in the pod memory limit. These parameters allow you to fine-tune the heap size. Please note . they set the percentage, not the fixed values. Thanks to it changing container memory settings will not break anything. \n+```\n+    resources:\n+      env:\n+      - name: JAVA_OPTIONS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Dweblogic.StdoutDebugEnabled=false\"\n+```\n+When configuring memory limits, it.s important to make sure that the limit is sufficiently big to accommodate the configured heap (and off-heap) requirements, but it's not too big to waste memory resource. Since pod memory will never go above the limit, if JVM's memory usage (sum of heap and native memory) goes above the limit, JVM process will be killed due to out-of-memory error and WebLogic container will be restarted due to liveness probe failure.   Additionally there's also a node-manager process that.s running in same container and it has it's own heap and off-heap requirements. You can also fine tune the node manager heap size in percentages by setting \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\" using .NODEMGR_JAVA_OPTIONS. environment variable. \n+\n+### Using \"-Xms\" and \"-Xmx\" parameters when not configuring limits \n+In some cases, it.s difficult to come up with a hard limit for the container and you might only want to configure memory requests but not configure memory limits. In such scenarios, you can use traditional approach to set min/max heap size using .-Xms. and .-Xmx..\n+\n+### CPU requests and limits \n+It.s important that the containers running WebLogic applications have enough CPU resources, otherwise applications performance can suffer. You also don't want to set CPU requests and limit too high if your application don't need or use allocated CPU resources. Since CPU is a shared resource, if the amount of CPU that you reserve is more than required by your application, the CPU cycles will go unused and be wasted. If no CPU request and limit is configured, it can end up using all CPU resources available on node. This can starve other containers from using shareable CPU cycles. \n+\n+One other thing to keep in mind is that if pod CPU limit is not configured, it might lead to incorrect garbage collection (GC) strategy selection. WebLogic self-tuning work-manager uses pod CPU limit to configure the  number of threads in a default thread pool. If you don.t specify container CPU limit, the performance might be affected due to incorrect number of GC threads or wrong WebLogic server thread pool size. \n+\n+## Beware of setting resource limits too high\n+It.s important to keep in mind that if you set a value of CPU core count that.s larger than core count of the biggest node, then the pod will never be scheduled. Let.s say you have a pod that needs 4 cores but you have a kubernetes cluster that.s comprised of 2 core VMs. In this case, your pod will never be scheduled.  WebLogic applications are normally designed to take advantage of multiple cores and should be given CPU requests as such. CPUs are considered as a compressible resource. If your apps are hitting CPU limits, kubernetes will start to throttle your container. This means your CPU will be artificially restricted, giving your app potentially worse performance. However it won.t be terminated or evicted. \n+Just like CPU, if you put a memory request that.s larger than amount of memory on your nodes, the pod will never be scheduled.", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMzM1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447803355", "bodyText": "Affinity  -> affinity\nk8s -> Kubernetes (globally)", "author": "rosemarymarano", "createdAt": "2020-06-30T16:08:49Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.\n+```\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+```\n+\n+There.s no memory or CPU limit configured by default in samples and default QoS for WebLogic server pod is Burstable. If your use-case and workload requires higher QoS and priority, this can be achieved by setting memory and CPU limits. You.ll need to run tests and experiment with different memory/CPU limits to determine optimal limit values.\n+```\n+      limits:\n+        cpu: 2\n+        memory: \"2048Mi\"\n+```\n+\n+### Configure min/max heap size in percentages using \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\"\n+If you specify pod memory limit, it's recommended to configure heap size as a percentage of the total RAM (memory) specified in the pod memory limit. These parameters allow you to fine-tune the heap size. Please note . they set the percentage, not the fixed values. Thanks to it changing container memory settings will not break anything. \n+```\n+    resources:\n+      env:\n+      - name: JAVA_OPTIONS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Dweblogic.StdoutDebugEnabled=false\"\n+```\n+When configuring memory limits, it.s important to make sure that the limit is sufficiently big to accommodate the configured heap (and off-heap) requirements, but it's not too big to waste memory resource. Since pod memory will never go above the limit, if JVM's memory usage (sum of heap and native memory) goes above the limit, JVM process will be killed due to out-of-memory error and WebLogic container will be restarted due to liveness probe failure.   Additionally there's also a node-manager process that.s running in same container and it has it's own heap and off-heap requirements. You can also fine tune the node manager heap size in percentages by setting \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\" using .NODEMGR_JAVA_OPTIONS. environment variable. \n+\n+### Using \"-Xms\" and \"-Xmx\" parameters when not configuring limits \n+In some cases, it.s difficult to come up with a hard limit for the container and you might only want to configure memory requests but not configure memory limits. In such scenarios, you can use traditional approach to set min/max heap size using .-Xms. and .-Xmx..\n+\n+### CPU requests and limits \n+It.s important that the containers running WebLogic applications have enough CPU resources, otherwise applications performance can suffer. You also don't want to set CPU requests and limit too high if your application don't need or use allocated CPU resources. Since CPU is a shared resource, if the amount of CPU that you reserve is more than required by your application, the CPU cycles will go unused and be wasted. If no CPU request and limit is configured, it can end up using all CPU resources available on node. This can starve other containers from using shareable CPU cycles. \n+\n+One other thing to keep in mind is that if pod CPU limit is not configured, it might lead to incorrect garbage collection (GC) strategy selection. WebLogic self-tuning work-manager uses pod CPU limit to configure the  number of threads in a default thread pool. If you don.t specify container CPU limit, the performance might be affected due to incorrect number of GC threads or wrong WebLogic server thread pool size. \n+\n+## Beware of setting resource limits too high\n+It.s important to keep in mind that if you set a value of CPU core count that.s larger than core count of the biggest node, then the pod will never be scheduled. Let.s say you have a pod that needs 4 cores but you have a kubernetes cluster that.s comprised of 2 core VMs. In this case, your pod will never be scheduled.  WebLogic applications are normally designed to take advantage of multiple cores and should be given CPU requests as such. CPUs are considered as a compressible resource. If your apps are hitting CPU limits, kubernetes will start to throttle your container. This means your CPU will be artificially restricted, giving your app potentially worse performance. However it won.t be terminated or evicted. \n+Just like CPU, if you put a memory request that.s larger than amount of memory on your nodes, the pod will never be scheduled.\n+## CPU Affinity and lock contention in k8s", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNDIzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447804235", "bodyText": "env -> environment (globally)\nseem -> seems", "author": "rosemarymarano", "createdAt": "2020-06-30T16:10:09Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.\n+```\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+```\n+\n+There.s no memory or CPU limit configured by default in samples and default QoS for WebLogic server pod is Burstable. If your use-case and workload requires higher QoS and priority, this can be achieved by setting memory and CPU limits. You.ll need to run tests and experiment with different memory/CPU limits to determine optimal limit values.\n+```\n+      limits:\n+        cpu: 2\n+        memory: \"2048Mi\"\n+```\n+\n+### Configure min/max heap size in percentages using \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\"\n+If you specify pod memory limit, it's recommended to configure heap size as a percentage of the total RAM (memory) specified in the pod memory limit. These parameters allow you to fine-tune the heap size. Please note . they set the percentage, not the fixed values. Thanks to it changing container memory settings will not break anything. \n+```\n+    resources:\n+      env:\n+      - name: JAVA_OPTIONS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Dweblogic.StdoutDebugEnabled=false\"\n+```\n+When configuring memory limits, it.s important to make sure that the limit is sufficiently big to accommodate the configured heap (and off-heap) requirements, but it's not too big to waste memory resource. Since pod memory will never go above the limit, if JVM's memory usage (sum of heap and native memory) goes above the limit, JVM process will be killed due to out-of-memory error and WebLogic container will be restarted due to liveness probe failure.   Additionally there's also a node-manager process that.s running in same container and it has it's own heap and off-heap requirements. You can also fine tune the node manager heap size in percentages by setting \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\" using .NODEMGR_JAVA_OPTIONS. environment variable. \n+\n+### Using \"-Xms\" and \"-Xmx\" parameters when not configuring limits \n+In some cases, it.s difficult to come up with a hard limit for the container and you might only want to configure memory requests but not configure memory limits. In such scenarios, you can use traditional approach to set min/max heap size using .-Xms. and .-Xmx..\n+\n+### CPU requests and limits \n+It.s important that the containers running WebLogic applications have enough CPU resources, otherwise applications performance can suffer. You also don't want to set CPU requests and limit too high if your application don't need or use allocated CPU resources. Since CPU is a shared resource, if the amount of CPU that you reserve is more than required by your application, the CPU cycles will go unused and be wasted. If no CPU request and limit is configured, it can end up using all CPU resources available on node. This can starve other containers from using shareable CPU cycles. \n+\n+One other thing to keep in mind is that if pod CPU limit is not configured, it might lead to incorrect garbage collection (GC) strategy selection. WebLogic self-tuning work-manager uses pod CPU limit to configure the  number of threads in a default thread pool. If you don.t specify container CPU limit, the performance might be affected due to incorrect number of GC threads or wrong WebLogic server thread pool size. \n+\n+## Beware of setting resource limits too high\n+It.s important to keep in mind that if you set a value of CPU core count that.s larger than core count of the biggest node, then the pod will never be scheduled. Let.s say you have a pod that needs 4 cores but you have a kubernetes cluster that.s comprised of 2 core VMs. In this case, your pod will never be scheduled.  WebLogic applications are normally designed to take advantage of multiple cores and should be given CPU requests as such. CPUs are considered as a compressible resource. If your apps are hitting CPU limits, kubernetes will start to throttle your container. This means your CPU will be artificially restricted, giving your app potentially worse performance. However it won.t be terminated or evicted. \n+Just like CPU, if you put a memory request that.s larger than amount of memory on your nodes, the pod will never be scheduled.\n+## CPU Affinity and lock contention in k8s\n+We observed much higher lock contention in k8s env when running some workloads in kubernetes as compared to traditional env. The lock contention seem to be caused by the lack of CPU cache affinity and/or scheduling latency when the workload moves to different CPU cores.  ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNTQ0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447805446", "bodyText": "environment -> environments\njava -> Java (always capitalized)\nusing taskset -> using the taskset", "author": "rosemarymarano", "createdAt": "2020-06-30T16:11:47Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.\n+```\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+```\n+\n+There.s no memory or CPU limit configured by default in samples and default QoS for WebLogic server pod is Burstable. If your use-case and workload requires higher QoS and priority, this can be achieved by setting memory and CPU limits. You.ll need to run tests and experiment with different memory/CPU limits to determine optimal limit values.\n+```\n+      limits:\n+        cpu: 2\n+        memory: \"2048Mi\"\n+```\n+\n+### Configure min/max heap size in percentages using \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\"\n+If you specify pod memory limit, it's recommended to configure heap size as a percentage of the total RAM (memory) specified in the pod memory limit. These parameters allow you to fine-tune the heap size. Please note . they set the percentage, not the fixed values. Thanks to it changing container memory settings will not break anything. \n+```\n+    resources:\n+      env:\n+      - name: JAVA_OPTIONS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Dweblogic.StdoutDebugEnabled=false\"\n+```\n+When configuring memory limits, it.s important to make sure that the limit is sufficiently big to accommodate the configured heap (and off-heap) requirements, but it's not too big to waste memory resource. Since pod memory will never go above the limit, if JVM's memory usage (sum of heap and native memory) goes above the limit, JVM process will be killed due to out-of-memory error and WebLogic container will be restarted due to liveness probe failure.   Additionally there's also a node-manager process that.s running in same container and it has it's own heap and off-heap requirements. You can also fine tune the node manager heap size in percentages by setting \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\" using .NODEMGR_JAVA_OPTIONS. environment variable. \n+\n+### Using \"-Xms\" and \"-Xmx\" parameters when not configuring limits \n+In some cases, it.s difficult to come up with a hard limit for the container and you might only want to configure memory requests but not configure memory limits. In such scenarios, you can use traditional approach to set min/max heap size using .-Xms. and .-Xmx..\n+\n+### CPU requests and limits \n+It.s important that the containers running WebLogic applications have enough CPU resources, otherwise applications performance can suffer. You also don't want to set CPU requests and limit too high if your application don't need or use allocated CPU resources. Since CPU is a shared resource, if the amount of CPU that you reserve is more than required by your application, the CPU cycles will go unused and be wasted. If no CPU request and limit is configured, it can end up using all CPU resources available on node. This can starve other containers from using shareable CPU cycles. \n+\n+One other thing to keep in mind is that if pod CPU limit is not configured, it might lead to incorrect garbage collection (GC) strategy selection. WebLogic self-tuning work-manager uses pod CPU limit to configure the  number of threads in a default thread pool. If you don.t specify container CPU limit, the performance might be affected due to incorrect number of GC threads or wrong WebLogic server thread pool size. \n+\n+## Beware of setting resource limits too high\n+It.s important to keep in mind that if you set a value of CPU core count that.s larger than core count of the biggest node, then the pod will never be scheduled. Let.s say you have a pod that needs 4 cores but you have a kubernetes cluster that.s comprised of 2 core VMs. In this case, your pod will never be scheduled.  WebLogic applications are normally designed to take advantage of multiple cores and should be given CPU requests as such. CPUs are considered as a compressible resource. If your apps are hitting CPU limits, kubernetes will start to throttle your container. This means your CPU will be artificially restricted, giving your app potentially worse performance. However it won.t be terminated or evicted. \n+Just like CPU, if you put a memory request that.s larger than amount of memory on your nodes, the pod will never be scheduled.\n+## CPU Affinity and lock contention in k8s\n+We observed much higher lock contention in k8s env when running some workloads in kubernetes as compared to traditional env. The lock contention seem to be caused by the lack of CPU cache affinity and/or scheduling latency when the workload moves to different CPU cores.  \n+\n+In traditional (non-k8s) environment, often tests are run with CPU affinity achieved by binding WLS java process to particular CPU core(s) (using taskset command). This results in reduced lock contention and better performance. ", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNjEwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r447806101", "bodyText": "when CPU manager policy -> when the CPU manager policy\nQOS -> QoS", "author": "rosemarymarano", "createdAt": "2020-06-30T16:12:34Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,84 @@\n+---\n+title: \"Considerations for Pod Resource (Memory and CPU) Requests and Limits\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: true\n+weight: 40\n+---\n+The operator creates a pod for each running WebLogic Server instance and each pod will have a container. It.s important that containers have enough resources in order for applications to run efficiently and expeditiously. \n+\n+If a pod is scheduled on a node with limited resources, it.s possible for the node to run out of memory or CPU resources, and for applications to stop working properly or have degraded performance. It.s also possible for a rouge application to use all available memory and/or CPU, which makes other containers running on the same system unresponsive. The same problem can happen if an application has memory leak or bad configuration. \n+\n+A pod.s resource requests and limit parameters can be used to solve these problems. Setting resource limits prevents an application from using more than it.s share of resource. Thus, limiting resources improves reliability and stability of applications.  It also allows users to plan for the hardware capacity. Additionally, pod.s priority and the Quality of Service (QoS) that pod receives is affected by whether resource requests and limits are specified or not.\n+\n+## Pod Quality Of Service (QoS) and Prioritization\n+Pod.s Quality of Service (QoS) and priority is determined based on whether pod.s resource requests and limits are configured or not and how they.re configured.\n+\n+**Best Effort QoS**: If you don.t configure requests and limits, pod receives .best-effort. QoS and pod has the **lowest priority**. In cases where node runs out of non-shareable resources, kubelet.s out-of-resource eviction policy evicts/kills the pods with best-effort QoS first.\n+\n+**Burstable QoS**: If you configure both resource requests and limits, and set the requests to be less than the limit, pod.s QoS will be .Burstable.. Similarly when you only configure the resource requests (without limits), the pod QoS is .Burstable.. When the node runs out of non-shareable resources, kubelet will kill .Burstable. Pods only when there are no more .best-effort. pods running. The Burstable pod receives **medium priority**.\n+\n+**Guaranteed QoS**:  If you set the requests and the limits to equal values, pod will have .Guranteed. QoS and pod will be considered as of the top most priority. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, Kubernetes will kill the best-effort and the burstable Pods first before terminating these Guaranteed QoS Pods. These are the **highest priority** pods.\n+\n+## Java heap size and pod memory request/limit considerations\n+It.s extremely important to set correct heap size for JVM-based applications.  If available memory on node or memory allocated to container is not sufficient for specified JVM heap arguments (and additional off-heap memory), it is possible for WL process to run out of memory. In order to avoid this, you will need to make sure that configured heap sizes are not too big and that the pod is scheduled on the node with sufficient memory.\n+With the latest Java version, it.s possible to rely on the default JVM heap settings which are safe but quite conservative. If you configure the memory limit for a container but don.t configure heap sizes (-Xms and -Xmx), JVM will configure max heap size to 25% (1/4th) of container memory limit by default. The minimum heap size is configured to 1.56% (1/64th) of limit value.\n+\n+**Default heap sizes and resource request values for sample WebLogic Server Pods**:\n+The WLS samples configure default min and max heap size for WebLogic server java process to 256MB and 512MB respectively. This can be changed using USER_MEM_ARGS environment variable. \n+```\n+    resources:\n+      env:\n+      - name: \"USER_MEM_ARGS\"\n+        value: \"-Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom\"\n+```        \n+\n+The default min and max heap size for node-manager process is 64MB and 100MB. This can be changed by using NODEMGR_MEM_ARGS environment variable. \n+\n+The default pod memory request in WLS samples is 768MB and default CPU request is 250m. The requests values can be changed in resources section.\n+```\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+```\n+\n+There.s no memory or CPU limit configured by default in samples and default QoS for WebLogic server pod is Burstable. If your use-case and workload requires higher QoS and priority, this can be achieved by setting memory and CPU limits. You.ll need to run tests and experiment with different memory/CPU limits to determine optimal limit values.\n+```\n+      limits:\n+        cpu: 2\n+        memory: \"2048Mi\"\n+```\n+\n+### Configure min/max heap size in percentages using \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\"\n+If you specify pod memory limit, it's recommended to configure heap size as a percentage of the total RAM (memory) specified in the pod memory limit. These parameters allow you to fine-tune the heap size. Please note . they set the percentage, not the fixed values. Thanks to it changing container memory settings will not break anything. \n+```\n+    resources:\n+      env:\n+      - name: JAVA_OPTIONS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Dweblogic.StdoutDebugEnabled=false\"\n+```\n+When configuring memory limits, it.s important to make sure that the limit is sufficiently big to accommodate the configured heap (and off-heap) requirements, but it's not too big to waste memory resource. Since pod memory will never go above the limit, if JVM's memory usage (sum of heap and native memory) goes above the limit, JVM process will be killed due to out-of-memory error and WebLogic container will be restarted due to liveness probe failure.   Additionally there's also a node-manager process that.s running in same container and it has it's own heap and off-heap requirements. You can also fine tune the node manager heap size in percentages by setting \"-XX:MinRAMPercentage\" and \"-XX:MaxRAMPercentage\" using .NODEMGR_JAVA_OPTIONS. environment variable. \n+\n+### Using \"-Xms\" and \"-Xmx\" parameters when not configuring limits \n+In some cases, it.s difficult to come up with a hard limit for the container and you might only want to configure memory requests but not configure memory limits. In such scenarios, you can use traditional approach to set min/max heap size using .-Xms. and .-Xmx..\n+\n+### CPU requests and limits \n+It.s important that the containers running WebLogic applications have enough CPU resources, otherwise applications performance can suffer. You also don't want to set CPU requests and limit too high if your application don't need or use allocated CPU resources. Since CPU is a shared resource, if the amount of CPU that you reserve is more than required by your application, the CPU cycles will go unused and be wasted. If no CPU request and limit is configured, it can end up using all CPU resources available on node. This can starve other containers from using shareable CPU cycles. \n+\n+One other thing to keep in mind is that if pod CPU limit is not configured, it might lead to incorrect garbage collection (GC) strategy selection. WebLogic self-tuning work-manager uses pod CPU limit to configure the  number of threads in a default thread pool. If you don.t specify container CPU limit, the performance might be affected due to incorrect number of GC threads or wrong WebLogic server thread pool size. \n+\n+## Beware of setting resource limits too high\n+It.s important to keep in mind that if you set a value of CPU core count that.s larger than core count of the biggest node, then the pod will never be scheduled. Let.s say you have a pod that needs 4 cores but you have a kubernetes cluster that.s comprised of 2 core VMs. In this case, your pod will never be scheduled.  WebLogic applications are normally designed to take advantage of multiple cores and should be given CPU requests as such. CPUs are considered as a compressible resource. If your apps are hitting CPU limits, kubernetes will start to throttle your container. This means your CPU will be artificially restricted, giving your app potentially worse performance. However it won.t be terminated or evicted. \n+Just like CPU, if you put a memory request that.s larger than amount of memory on your nodes, the pod will never be scheduled.\n+## CPU Affinity and lock contention in k8s\n+We observed much higher lock contention in k8s env when running some workloads in kubernetes as compared to traditional env. The lock contention seem to be caused by the lack of CPU cache affinity and/or scheduling latency when the workload moves to different CPU cores.  \n+\n+In traditional (non-k8s) environment, often tests are run with CPU affinity achieved by binding WLS java process to particular CPU core(s) (using taskset command). This results in reduced lock contention and better performance. \n+\n+In k8s environment. when CPU manager policy is configured to be \"static\" and QOS is \"Guaranteed\" for WLS pods, we see reduced lock contention and better performance. The default CPU manager policy is \"none\" (default). Please refer to controlling CPU management policies for more details.", "originalCommit": "a23d465d277d44c2f5b22ee39ff66f06948acfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0477ff166bc9e02dd33e555ab283d981f0eafeef", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0477ff166bc9e02dd33e555ab283d981f0eafeef", "message": "resource settings FAQ updates", "committedDate": "2020-06-30T22:03:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMzUwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448023502", "bodyText": "The phrasing, \"It's also possible for a rogue application...\" sounds scarier than I think we need. Customers understand that application and server usage of resources need to be controlled and limited. We might borrow phrases from the current WebLogic sizing guide.", "author": "rjeberhard", "createdAt": "2020-06-30T22:54:41Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,162 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Overview](#overview)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. It's important that the container has enough resources in order for WebLogic to run efficiently.\n+\n+If a pod is scheduled on a node with limited resources, then it's possible for node to run out of memory or CPU resources, and for the pod's applications to stop working properly or have degraded performance. It's also possible for a rogue application to use all of a node's available memory and/or CPU, which makes other containers running on the same node unresponsive. The same problem can happen if an application has a memory leak.", "originalCommit": "0477ff166bc9e02dd33e555ab283d981f0eafeef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2MjI5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448562298", "bodyText": "We have rephrased the introduction section and removed the phrasing about \"rogue application using up all available resources\".", "author": "ankedia", "createdAt": "2020-07-01T19:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMzUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDE1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448024157", "bodyText": "This is good. Let's also link to the standard Kubernetes doc. topics https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/ and https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource/.", "author": "rjeberhard", "createdAt": "2020-06-30T22:56:38Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,162 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Overview](#overview)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. It's important that the container has enough resources in order for WebLogic to run efficiently.\n+\n+If a pod is scheduled on a node with limited resources, then it's possible for node to run out of memory or CPU resources, and for the pod's applications to stop working properly or have degraded performance. It's also possible for a rogue application to use all of a node's available memory and/or CPU, which makes other containers running on the same node unresponsive. The same problem can happen if an application has a memory leak.\n+\n+You can solve these problems by configuring resource requests and limits for your pods. A resource limit prevents a pod from using more than its share of a resource. Thus, it improves reliability, stability, and helps with hardware capacity planning. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: ", "originalCommit": "0477ff166bc9e02dd33e555ab283d981f0eafeef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2MjgyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448562820", "bodyText": "Included above additional links for Kubernetes doc.", "author": "ankedia", "createdAt": "2020-07-01T19:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDg5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448024895", "bodyText": "Yes, we have serverPod.priorityClassName.", "author": "rjeberhard", "createdAt": "2020-06-30T22:59:01Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,162 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Overview](#overview)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. It's important that the container has enough resources in order for WebLogic to run efficiently.\n+\n+If a pod is scheduled on a node with limited resources, then it's possible for node to run out of memory or CPU resources, and for the pod's applications to stop working properly or have degraded performance. It's also possible for a rogue application to use all of a node's available memory and/or CPU, which makes other containers running on the same node unresponsive. The same problem can happen if an application has a memory leak.\n+\n+You can solve these problems by configuring resource requests and limits for your pods. A resource limit prevents a pod from using more than its share of a resource. Thus, it improves reliability, stability, and helps with hardware capacity planning. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) in the Kubernetes documentation.\n+\n+### Determining pod Quality Of Service\n+\n+A pod's Quality of Service (QoS) is based on whether it's configured with resource requests and limits:\n+\n+- **Best Effort QoS** (lowest priority): If you don't configure requests and limits for a pod, then the pod is given a `best-effort` QoS. In cases where a node runs out of non-shareable resources, a Kubernetes `kubelet` default out-of-resource eviction policy evicts running pods with the `best-effort` QoS first.\n+\n+- **Burstable QoS** (medium priority): If you configure both resource requests and limits for a pod, and set the requests to be less than their respective limits, then the pod will be given a `burstable` QoS. Similarly, if you only configure resource requests (without limits) for a pod, then the pod QoS is also `burstable`. If a node runs out of non-shareable resources, the node's `kubelet` will evict `burstable` pods only when there are no more running `best-effort` pods.\n+\n+- **Guaranteed QoS** (highest priority): If you set a pod's requests and the limits to equal values, then the pod will have a `guaranteed` QoS. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, then a Kubernetes node's `kubelet` will evict `best-effort` and `burstable` QoS pods before terminating `guaranteed` QoS pods.\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring WebLogic pods with memory and CPU requests and limits, and furthermore setting requests equal to their respective limits in order to ensure a `guaranteed` QoS.\n+{{% /notice %}}\n+\n+In newer version of Kubernetes, it is possible to fine tune scheduling and eviction policies using [Pod Priority Preemption](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/). TBD Ryan - is it possible to change the priority class of a pod?", "originalCommit": "0477ff166bc9e02dd33e555ab283d981f0eafeef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2NDE3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448564170", "bodyText": "Thanks. We have included wording about priority class tuning and two PriorityClasses shipped with Kubernetes.", "author": "ankedia", "createdAt": "2020-07-01T19:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyODcxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448028714", "bodyText": "I think the topic here is \"Importance of setting heap sizes\"", "author": "rjeberhard", "createdAt": "2020-06-30T23:10:51Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,162 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Overview](#overview)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. It's important that the container has enough resources in order for WebLogic to run efficiently.\n+\n+If a pod is scheduled on a node with limited resources, then it's possible for node to run out of memory or CPU resources, and for the pod's applications to stop working properly or have degraded performance. It's also possible for a rogue application to use all of a node's available memory and/or CPU, which makes other containers running on the same node unresponsive. The same problem can happen if an application has a memory leak.\n+\n+You can solve these problems by configuring resource requests and limits for your pods. A resource limit prevents a pod from using more than its share of a resource. Thus, it improves reliability, stability, and helps with hardware capacity planning. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) in the Kubernetes documentation.\n+\n+### Determining pod Quality Of Service\n+\n+A pod's Quality of Service (QoS) is based on whether it's configured with resource requests and limits:\n+\n+- **Best Effort QoS** (lowest priority): If you don't configure requests and limits for a pod, then the pod is given a `best-effort` QoS. In cases where a node runs out of non-shareable resources, a Kubernetes `kubelet` default out-of-resource eviction policy evicts running pods with the `best-effort` QoS first.\n+\n+- **Burstable QoS** (medium priority): If you configure both resource requests and limits for a pod, and set the requests to be less than their respective limits, then the pod will be given a `burstable` QoS. Similarly, if you only configure resource requests (without limits) for a pod, then the pod QoS is also `burstable`. If a node runs out of non-shareable resources, the node's `kubelet` will evict `burstable` pods only when there are no more running `best-effort` pods.\n+\n+- **Guaranteed QoS** (highest priority): If you set a pod's requests and the limits to equal values, then the pod will have a `guaranteed` QoS. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, then a Kubernetes node's `kubelet` will evict `best-effort` and `burstable` QoS pods before terminating `guaranteed` QoS pods.\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring WebLogic pods with memory and CPU requests and limits, and furthermore setting requests equal to their respective limits in order to ensure a `guaranteed` QoS.\n+{{% /notice %}}\n+\n+In newer version of Kubernetes, it is possible to fine tune scheduling and eviction policies using [Pod Priority Preemption](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/). TBD Ryan - is it possible to change the priority class of a pod?\n+\n+### Java heap size and memory resource considerations\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring Java heap sizes for WebLogic pods instead of relying on defaults.\n+{{% /notice %}}\n+\n+#### Overview\n+\n+It's extremely important to set correct heap sizes, memory requests, and memory limits for WebLogic JVMs and Pods. \n+\n+A WebLogic JVM heap must be sufficiently sized to run its applications and services, but should not be sized too large so as not to waste memory resources.\n+\n+A pod memory limit must be sufficiently sized to accommodate the configured heap (and off-heap) requirements, but  not too big to waste memory resources. If a JVM's memory usage (sum of heap and native memory) exceeds its pod's limit, then the JVM process will be abruptly killed due to an out-of-memory error and the WebLogic container will consequently automatically restart due to a liveness probe failure.  \n+\n+{{% notice warning %}}\n+If resource requests and resource limits are set too high, then your pods may not be scheduled due to lack of node resources, will unnecessarily use up CPU shared resources that could be used by other pods, or may prevent other pods from running.\n+{{% /notice %}}\n+\n+#### Default heap sizes", "originalCommit": "0477ff166bc9e02dd33e555ab283d981f0eafeef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyOTM5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448029393", "bodyText": "Or, put another way, we should end this section more strongly to say that customers must set the heap min and max (or the maximum heap percentage) and at least container memory request.", "author": "rjeberhard", "createdAt": "2020-06-30T23:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2NTAwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448565001", "bodyText": "Changed the title and added recommendation for setting heap min and max and container memory request.", "author": "ankedia", "createdAt": "2020-07-01T19:13:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyODcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyOTY4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448029682", "bodyText": "Will readers understand \"off-heap\" requirements? I've heard this described as native memory.", "author": "rjeberhard", "createdAt": "2020-06-30T23:14:08Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,162 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Overview](#overview)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. It's important that the container has enough resources in order for WebLogic to run efficiently.\n+\n+If a pod is scheduled on a node with limited resources, then it's possible for node to run out of memory or CPU resources, and for the pod's applications to stop working properly or have degraded performance. It's also possible for a rogue application to use all of a node's available memory and/or CPU, which makes other containers running on the same node unresponsive. The same problem can happen if an application has a memory leak.\n+\n+You can solve these problems by configuring resource requests and limits for your pods. A resource limit prevents a pod from using more than its share of a resource. Thus, it improves reliability, stability, and helps with hardware capacity planning. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) in the Kubernetes documentation.\n+\n+### Determining pod Quality Of Service\n+\n+A pod's Quality of Service (QoS) is based on whether it's configured with resource requests and limits:\n+\n+- **Best Effort QoS** (lowest priority): If you don't configure requests and limits for a pod, then the pod is given a `best-effort` QoS. In cases where a node runs out of non-shareable resources, a Kubernetes `kubelet` default out-of-resource eviction policy evicts running pods with the `best-effort` QoS first.\n+\n+- **Burstable QoS** (medium priority): If you configure both resource requests and limits for a pod, and set the requests to be less than their respective limits, then the pod will be given a `burstable` QoS. Similarly, if you only configure resource requests (without limits) for a pod, then the pod QoS is also `burstable`. If a node runs out of non-shareable resources, the node's `kubelet` will evict `burstable` pods only when there are no more running `best-effort` pods.\n+\n+- **Guaranteed QoS** (highest priority): If you set a pod's requests and the limits to equal values, then the pod will have a `guaranteed` QoS. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, then a Kubernetes node's `kubelet` will evict `best-effort` and `burstable` QoS pods before terminating `guaranteed` QoS pods.\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring WebLogic pods with memory and CPU requests and limits, and furthermore setting requests equal to their respective limits in order to ensure a `guaranteed` QoS.\n+{{% /notice %}}\n+\n+In newer version of Kubernetes, it is possible to fine tune scheduling and eviction policies using [Pod Priority Preemption](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/). TBD Ryan - is it possible to change the priority class of a pod?\n+\n+### Java heap size and memory resource considerations\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring Java heap sizes for WebLogic pods instead of relying on defaults.\n+{{% /notice %}}\n+\n+#### Overview\n+\n+It's extremely important to set correct heap sizes, memory requests, and memory limits for WebLogic JVMs and Pods. \n+\n+A WebLogic JVM heap must be sufficiently sized to run its applications and services, but should not be sized too large so as not to waste memory resources.\n+\n+A pod memory limit must be sufficiently sized to accommodate the configured heap (and off-heap) requirements, but  not too big to waste memory resources. If a JVM's memory usage (sum of heap and native memory) exceeds its pod's limit, then the JVM process will be abruptly killed due to an out-of-memory error and the WebLogic container will consequently automatically restart due to a liveness probe failure.  \n+\n+{{% notice warning %}}\n+If resource requests and resource limits are set too high, then your pods may not be scheduled due to lack of node resources, will unnecessarily use up CPU shared resources that could be used by other pods, or may prevent other pods from running.\n+{{% /notice %}}\n+\n+#### Default heap sizes\n+\n+With the latest Java versions, Java 8 update 191 and onwards or Java 11, then if you don't configure a heap size (no '-Xms' or '-Xms') the default heap size is dynamically determined:\n+- If you configure the memory limit for a container, then the JVM default maximum heap size will be 25% (1/4th) of container memory limit and the default minimum heap size will be 1.56% (1/64th) of the limit value. \n+\n+  The default JVM heap settings in this case are often too conservative because the WebLogic JVM is the only major process running in the container.\n+\n+- If no memory limit is configured, then the JVM default maximum heap size will be  25% (1/4th) of the its node's machine RAM and the default minimum heap size will be 1.56% (1/64th) of the RAM.\n+\n+  The default JVM heap settings in this case can have undesirable behavior, including using unnecessary amounts of memory to the point where it might affect other pods that run on the same node.\n+\n+#### Configuring heap size\n+\n+If you specify pod memory limits, Oracle recommends configuring WebLogic Server heap sizes as a percentage. The JVM will interpret the percentage as a fraction of the limit. This is done using the JVM `-XX:MinRAMPercentage` and `-XX:MaxRAMPercentage` options in the `USER_MEM_ARGS` [domain resource environment variable]({{< relref \"/userguide/managing-domains/domain-resource#jvm-memory-and-java-option-environment-variables\" >}}).  For example:\n+\n+```\n+  spec:\n+    resources:\n+      env:\n+      - name: USER_MEM_ARGS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Djava.security.egd=file:/dev/./urandom\"\n+```\n+\n+Additionally there's also a node-manager process that's running in the same container as the WebLogic Server which has its own heap and off-heap requirements. Its heap is tuned by using `-Xms` and `-Xmx` in the `NODEMGR_MEM_ARGS` environment variable. Oracle recommends setting the node manager heap memory to fixed sizes, instead of percentages, where [the default tuning]({{< relref \"/userguide/managing-domains/domain-resource#jvm-memory-and-java-option-environment-variables\" >}}) is usually sufficient.", "originalCommit": "0477ff166bc9e02dd33e555ab283d981f0eafeef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2NTE4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448565183", "bodyText": "Changed \"off-heap\" to \"native memory\".", "author": "ankedia", "createdAt": "2020-07-01T19:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyOTY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMTQ4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448031482", "bodyText": "Why is it only \"usually\" recommended?", "author": "rjeberhard", "createdAt": "2020-06-30T23:19:56Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,162 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Overview](#overview)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. It's important that the container has enough resources in order for WebLogic to run efficiently.\n+\n+If a pod is scheduled on a node with limited resources, then it's possible for node to run out of memory or CPU resources, and for the pod's applications to stop working properly or have degraded performance. It's also possible for a rogue application to use all of a node's available memory and/or CPU, which makes other containers running on the same node unresponsive. The same problem can happen if an application has a memory leak.\n+\n+You can solve these problems by configuring resource requests and limits for your pods. A resource limit prevents a pod from using more than its share of a resource. Thus, it improves reliability, stability, and helps with hardware capacity planning. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) in the Kubernetes documentation.\n+\n+### Determining pod Quality Of Service\n+\n+A pod's Quality of Service (QoS) is based on whether it's configured with resource requests and limits:\n+\n+- **Best Effort QoS** (lowest priority): If you don't configure requests and limits for a pod, then the pod is given a `best-effort` QoS. In cases where a node runs out of non-shareable resources, a Kubernetes `kubelet` default out-of-resource eviction policy evicts running pods with the `best-effort` QoS first.\n+\n+- **Burstable QoS** (medium priority): If you configure both resource requests and limits for a pod, and set the requests to be less than their respective limits, then the pod will be given a `burstable` QoS. Similarly, if you only configure resource requests (without limits) for a pod, then the pod QoS is also `burstable`. If a node runs out of non-shareable resources, the node's `kubelet` will evict `burstable` pods only when there are no more running `best-effort` pods.\n+\n+- **Guaranteed QoS** (highest priority): If you set a pod's requests and the limits to equal values, then the pod will have a `guaranteed` QoS. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, then a Kubernetes node's `kubelet` will evict `best-effort` and `burstable` QoS pods before terminating `guaranteed` QoS pods.\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring WebLogic pods with memory and CPU requests and limits, and furthermore setting requests equal to their respective limits in order to ensure a `guaranteed` QoS.\n+{{% /notice %}}\n+\n+In newer version of Kubernetes, it is possible to fine tune scheduling and eviction policies using [Pod Priority Preemption](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/). TBD Ryan - is it possible to change the priority class of a pod?\n+\n+### Java heap size and memory resource considerations\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring Java heap sizes for WebLogic pods instead of relying on defaults.\n+{{% /notice %}}\n+\n+#### Overview\n+\n+It's extremely important to set correct heap sizes, memory requests, and memory limits for WebLogic JVMs and Pods. \n+\n+A WebLogic JVM heap must be sufficiently sized to run its applications and services, but should not be sized too large so as not to waste memory resources.\n+\n+A pod memory limit must be sufficiently sized to accommodate the configured heap (and off-heap) requirements, but  not too big to waste memory resources. If a JVM's memory usage (sum of heap and native memory) exceeds its pod's limit, then the JVM process will be abruptly killed due to an out-of-memory error and the WebLogic container will consequently automatically restart due to a liveness probe failure.  \n+\n+{{% notice warning %}}\n+If resource requests and resource limits are set too high, then your pods may not be scheduled due to lack of node resources, will unnecessarily use up CPU shared resources that could be used by other pods, or may prevent other pods from running.\n+{{% /notice %}}\n+\n+#### Default heap sizes\n+\n+With the latest Java versions, Java 8 update 191 and onwards or Java 11, then if you don't configure a heap size (no '-Xms' or '-Xms') the default heap size is dynamically determined:\n+- If you configure the memory limit for a container, then the JVM default maximum heap size will be 25% (1/4th) of container memory limit and the default minimum heap size will be 1.56% (1/64th) of the limit value. \n+\n+  The default JVM heap settings in this case are often too conservative because the WebLogic JVM is the only major process running in the container.\n+\n+- If no memory limit is configured, then the JVM default maximum heap size will be  25% (1/4th) of the its node's machine RAM and the default minimum heap size will be 1.56% (1/64th) of the RAM.\n+\n+  The default JVM heap settings in this case can have undesirable behavior, including using unnecessary amounts of memory to the point where it might affect other pods that run on the same node.\n+\n+#### Configuring heap size\n+\n+If you specify pod memory limits, Oracle recommends configuring WebLogic Server heap sizes as a percentage. The JVM will interpret the percentage as a fraction of the limit. This is done using the JVM `-XX:MinRAMPercentage` and `-XX:MaxRAMPercentage` options in the `USER_MEM_ARGS` [domain resource environment variable]({{< relref \"/userguide/managing-domains/domain-resource#jvm-memory-and-java-option-environment-variables\" >}}).  For example:\n+\n+```\n+  spec:\n+    resources:\n+      env:\n+      - name: USER_MEM_ARGS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Djava.security.egd=file:/dev/./urandom\"\n+```\n+\n+Additionally there's also a node-manager process that's running in the same container as the WebLogic Server which has its own heap and off-heap requirements. Its heap is tuned by using `-Xms` and `-Xmx` in the `NODEMGR_MEM_ARGS` environment variable. Oracle recommends setting the node manager heap memory to fixed sizes, instead of percentages, where [the default tuning]({{< relref \"/userguide/managing-domains/domain-resource#jvm-memory-and-java-option-environment-variables\" >}}) is usually sufficient.\n+\n+{{% notice warning %}}\n+If you set `USER_MEM_ARGS` or `NODEMGR_MEM_ARGS` in your domain resource, then it is usually recommended to include `-Djava.security.egd=file:/dev/./urandom` in order to speedup boot times on systems with low entropy. This setting is included in the respective defaults for these two environment variables.", "originalCommit": "0477ff166bc9e02dd33e555ab283d981f0eafeef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2NTM1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448565359", "bodyText": "This was changed to match with other parts of Operator documentation.", "author": "ankedia", "createdAt": "2020-07-01T19:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMTQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMTk1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448031957", "bodyText": "It would be more helpful to show an example of the error when a Pod is never scheduled (it will be stuck in \"Pending\").", "author": "rjeberhard", "createdAt": "2020-06-30T23:21:32Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,162 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Overview](#overview)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. It's important that the container has enough resources in order for WebLogic to run efficiently.\n+\n+If a pod is scheduled on a node with limited resources, then it's possible for node to run out of memory or CPU resources, and for the pod's applications to stop working properly or have degraded performance. It's also possible for a rogue application to use all of a node's available memory and/or CPU, which makes other containers running on the same node unresponsive. The same problem can happen if an application has a memory leak.\n+\n+You can solve these problems by configuring resource requests and limits for your pods. A resource limit prevents a pod from using more than its share of a resource. Thus, it improves reliability, stability, and helps with hardware capacity planning. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) in the Kubernetes documentation.\n+\n+### Determining pod Quality Of Service\n+\n+A pod's Quality of Service (QoS) is based on whether it's configured with resource requests and limits:\n+\n+- **Best Effort QoS** (lowest priority): If you don't configure requests and limits for a pod, then the pod is given a `best-effort` QoS. In cases where a node runs out of non-shareable resources, a Kubernetes `kubelet` default out-of-resource eviction policy evicts running pods with the `best-effort` QoS first.\n+\n+- **Burstable QoS** (medium priority): If you configure both resource requests and limits for a pod, and set the requests to be less than their respective limits, then the pod will be given a `burstable` QoS. Similarly, if you only configure resource requests (without limits) for a pod, then the pod QoS is also `burstable`. If a node runs out of non-shareable resources, the node's `kubelet` will evict `burstable` pods only when there are no more running `best-effort` pods.\n+\n+- **Guaranteed QoS** (highest priority): If you set a pod's requests and the limits to equal values, then the pod will have a `guaranteed` QoS. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, then a Kubernetes node's `kubelet` will evict `best-effort` and `burstable` QoS pods before terminating `guaranteed` QoS pods.\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring WebLogic pods with memory and CPU requests and limits, and furthermore setting requests equal to their respective limits in order to ensure a `guaranteed` QoS.\n+{{% /notice %}}\n+\n+In newer version of Kubernetes, it is possible to fine tune scheduling and eviction policies using [Pod Priority Preemption](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/). TBD Ryan - is it possible to change the priority class of a pod?\n+\n+### Java heap size and memory resource considerations\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring Java heap sizes for WebLogic pods instead of relying on defaults.\n+{{% /notice %}}\n+\n+#### Overview\n+\n+It's extremely important to set correct heap sizes, memory requests, and memory limits for WebLogic JVMs and Pods. \n+\n+A WebLogic JVM heap must be sufficiently sized to run its applications and services, but should not be sized too large so as not to waste memory resources.\n+\n+A pod memory limit must be sufficiently sized to accommodate the configured heap (and off-heap) requirements, but  not too big to waste memory resources. If a JVM's memory usage (sum of heap and native memory) exceeds its pod's limit, then the JVM process will be abruptly killed due to an out-of-memory error and the WebLogic container will consequently automatically restart due to a liveness probe failure.  \n+\n+{{% notice warning %}}\n+If resource requests and resource limits are set too high, then your pods may not be scheduled due to lack of node resources, will unnecessarily use up CPU shared resources that could be used by other pods, or may prevent other pods from running.\n+{{% /notice %}}\n+\n+#### Default heap sizes\n+\n+With the latest Java versions, Java 8 update 191 and onwards or Java 11, then if you don't configure a heap size (no '-Xms' or '-Xms') the default heap size is dynamically determined:\n+- If you configure the memory limit for a container, then the JVM default maximum heap size will be 25% (1/4th) of container memory limit and the default minimum heap size will be 1.56% (1/64th) of the limit value. \n+\n+  The default JVM heap settings in this case are often too conservative because the WebLogic JVM is the only major process running in the container.\n+\n+- If no memory limit is configured, then the JVM default maximum heap size will be  25% (1/4th) of the its node's machine RAM and the default minimum heap size will be 1.56% (1/64th) of the RAM.\n+\n+  The default JVM heap settings in this case can have undesirable behavior, including using unnecessary amounts of memory to the point where it might affect other pods that run on the same node.\n+\n+#### Configuring heap size\n+\n+If you specify pod memory limits, Oracle recommends configuring WebLogic Server heap sizes as a percentage. The JVM will interpret the percentage as a fraction of the limit. This is done using the JVM `-XX:MinRAMPercentage` and `-XX:MaxRAMPercentage` options in the `USER_MEM_ARGS` [domain resource environment variable]({{< relref \"/userguide/managing-domains/domain-resource#jvm-memory-and-java-option-environment-variables\" >}}).  For example:\n+\n+```\n+  spec:\n+    resources:\n+      env:\n+      - name: USER_MEM_ARGS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Djava.security.egd=file:/dev/./urandom\"\n+```\n+\n+Additionally there's also a node-manager process that's running in the same container as the WebLogic Server which has its own heap and off-heap requirements. Its heap is tuned by using `-Xms` and `-Xmx` in the `NODEMGR_MEM_ARGS` environment variable. Oracle recommends setting the node manager heap memory to fixed sizes, instead of percentages, where [the default tuning]({{< relref \"/userguide/managing-domains/domain-resource#jvm-memory-and-java-option-environment-variables\" >}}) is usually sufficient.\n+\n+{{% notice warning %}}\n+If you set `USER_MEM_ARGS` or `NODEMGR_MEM_ARGS` in your domain resource, then it is usually recommended to include `-Djava.security.egd=file:/dev/./urandom` in order to speedup boot times on systems with low entropy. This setting is included in the respective defaults for these two environment variables.\n+q\n+{{% /notice %}}\n+\n+In some cases, you might only want to configure memory resource requests but not configure memory resource limits. In such scenarios, you can use the traditional fixed heap size settings (`-Xms` and `-Xmx`) in your WebLogic Server `USER_MEM_ARGS` instead of the percentage settings (`-XX:MinRAMPercentage` and `-XX:MaxRAMPercentage`).\n+\n+### CPU resource considerations\n+\n+It's important to set both a CPU request and a limit for WebLogic Server pods. This ensures that all WebLogic server pods have enough CPU resources, and, as discussed earlier, if the request and limit are set to the same value, then they get a `guaranteed` QoS. A `guaranteed` QoS ensures the pods are handled with a higher priority during scheduling and so are the least likely to be evicted.\n+\n+If a CPU request and limit are _not_ configured for a WebLogic Server pod:\n+- The pod can end up using all CPU resources available on its node and starve other containers from using shareable CPU cycles. \n+\n+- The WebLogic server JVM may choose an unsuitable garbage collection (GC) strategy.\n+\n+- A WebLogic Server self-tuning work-manager may incorrectly optimize the number of threads it allocates for the default thread pool. \n+\n+It's also important to keep in mind that if you set a value of CPU core count that's larger than core count of your biggest node, then the pod will never be scheduled. Let's say you have a pod that needs 4 cores but you have a kubernetes cluster that's comprised of 2 core VMs. In this case, your pod will never be scheduled.  ", "originalCommit": "0477ff166bc9e02dd33e555ab283d981f0eafeef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2NTU2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448565560", "bodyText": "Added an example showing pod in Pending state.", "author": "ankedia", "createdAt": "2020-07-01T19:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMjI0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448032246", "bodyText": "This is a good idea... You can also link to OKE monitoring.", "author": "rjeberhard", "createdAt": "2020-06-30T23:22:31Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,162 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Overview](#overview)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. It's important that the container has enough resources in order for WebLogic to run efficiently.\n+\n+If a pod is scheduled on a node with limited resources, then it's possible for node to run out of memory or CPU resources, and for the pod's applications to stop working properly or have degraded performance. It's also possible for a rogue application to use all of a node's available memory and/or CPU, which makes other containers running on the same node unresponsive. The same problem can happen if an application has a memory leak.\n+\n+You can solve these problems by configuring resource requests and limits for your pods. A resource limit prevents a pod from using more than its share of a resource. Thus, it improves reliability, stability, and helps with hardware capacity planning. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) in the Kubernetes documentation.\n+\n+### Determining pod Quality Of Service\n+\n+A pod's Quality of Service (QoS) is based on whether it's configured with resource requests and limits:\n+\n+- **Best Effort QoS** (lowest priority): If you don't configure requests and limits for a pod, then the pod is given a `best-effort` QoS. In cases where a node runs out of non-shareable resources, a Kubernetes `kubelet` default out-of-resource eviction policy evicts running pods with the `best-effort` QoS first.\n+\n+- **Burstable QoS** (medium priority): If you configure both resource requests and limits for a pod, and set the requests to be less than their respective limits, then the pod will be given a `burstable` QoS. Similarly, if you only configure resource requests (without limits) for a pod, then the pod QoS is also `burstable`. If a node runs out of non-shareable resources, the node's `kubelet` will evict `burstable` pods only when there are no more running `best-effort` pods.\n+\n+- **Guaranteed QoS** (highest priority): If you set a pod's requests and the limits to equal values, then the pod will have a `guaranteed` QoS. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, then a Kubernetes node's `kubelet` will evict `best-effort` and `burstable` QoS pods before terminating `guaranteed` QoS pods.\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring WebLogic pods with memory and CPU requests and limits, and furthermore setting requests equal to their respective limits in order to ensure a `guaranteed` QoS.\n+{{% /notice %}}\n+\n+In newer version of Kubernetes, it is possible to fine tune scheduling and eviction policies using [Pod Priority Preemption](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/). TBD Ryan - is it possible to change the priority class of a pod?\n+\n+### Java heap size and memory resource considerations\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring Java heap sizes for WebLogic pods instead of relying on defaults.\n+{{% /notice %}}\n+\n+#### Overview\n+\n+It's extremely important to set correct heap sizes, memory requests, and memory limits for WebLogic JVMs and Pods. \n+\n+A WebLogic JVM heap must be sufficiently sized to run its applications and services, but should not be sized too large so as not to waste memory resources.\n+\n+A pod memory limit must be sufficiently sized to accommodate the configured heap (and off-heap) requirements, but  not too big to waste memory resources. If a JVM's memory usage (sum of heap and native memory) exceeds its pod's limit, then the JVM process will be abruptly killed due to an out-of-memory error and the WebLogic container will consequently automatically restart due to a liveness probe failure.  \n+\n+{{% notice warning %}}\n+If resource requests and resource limits are set too high, then your pods may not be scheduled due to lack of node resources, will unnecessarily use up CPU shared resources that could be used by other pods, or may prevent other pods from running.\n+{{% /notice %}}\n+\n+#### Default heap sizes\n+\n+With the latest Java versions, Java 8 update 191 and onwards or Java 11, then if you don't configure a heap size (no '-Xms' or '-Xms') the default heap size is dynamically determined:\n+- If you configure the memory limit for a container, then the JVM default maximum heap size will be 25% (1/4th) of container memory limit and the default minimum heap size will be 1.56% (1/64th) of the limit value. \n+\n+  The default JVM heap settings in this case are often too conservative because the WebLogic JVM is the only major process running in the container.\n+\n+- If no memory limit is configured, then the JVM default maximum heap size will be  25% (1/4th) of the its node's machine RAM and the default minimum heap size will be 1.56% (1/64th) of the RAM.\n+\n+  The default JVM heap settings in this case can have undesirable behavior, including using unnecessary amounts of memory to the point where it might affect other pods that run on the same node.\n+\n+#### Configuring heap size\n+\n+If you specify pod memory limits, Oracle recommends configuring WebLogic Server heap sizes as a percentage. The JVM will interpret the percentage as a fraction of the limit. This is done using the JVM `-XX:MinRAMPercentage` and `-XX:MaxRAMPercentage` options in the `USER_MEM_ARGS` [domain resource environment variable]({{< relref \"/userguide/managing-domains/domain-resource#jvm-memory-and-java-option-environment-variables\" >}}).  For example:\n+\n+```\n+  spec:\n+    resources:\n+      env:\n+      - name: USER_MEM_ARGS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Djava.security.egd=file:/dev/./urandom\"\n+```\n+\n+Additionally there's also a node-manager process that's running in the same container as the WebLogic Server which has its own heap and off-heap requirements. Its heap is tuned by using `-Xms` and `-Xmx` in the `NODEMGR_MEM_ARGS` environment variable. Oracle recommends setting the node manager heap memory to fixed sizes, instead of percentages, where [the default tuning]({{< relref \"/userguide/managing-domains/domain-resource#jvm-memory-and-java-option-environment-variables\" >}}) is usually sufficient.\n+\n+{{% notice warning %}}\n+If you set `USER_MEM_ARGS` or `NODEMGR_MEM_ARGS` in your domain resource, then it is usually recommended to include `-Djava.security.egd=file:/dev/./urandom` in order to speedup boot times on systems with low entropy. This setting is included in the respective defaults for these two environment variables.\n+q\n+{{% /notice %}}\n+\n+In some cases, you might only want to configure memory resource requests but not configure memory resource limits. In such scenarios, you can use the traditional fixed heap size settings (`-Xms` and `-Xmx`) in your WebLogic Server `USER_MEM_ARGS` instead of the percentage settings (`-XX:MinRAMPercentage` and `-XX:MaxRAMPercentage`).\n+\n+### CPU resource considerations\n+\n+It's important to set both a CPU request and a limit for WebLogic Server pods. This ensures that all WebLogic server pods have enough CPU resources, and, as discussed earlier, if the request and limit are set to the same value, then they get a `guaranteed` QoS. A `guaranteed` QoS ensures the pods are handled with a higher priority during scheduling and so are the least likely to be evicted.\n+\n+If a CPU request and limit are _not_ configured for a WebLogic Server pod:\n+- The pod can end up using all CPU resources available on its node and starve other containers from using shareable CPU cycles. \n+\n+- The WebLogic server JVM may choose an unsuitable garbage collection (GC) strategy.\n+\n+- A WebLogic Server self-tuning work-manager may incorrectly optimize the number of threads it allocates for the default thread pool. \n+\n+It's also important to keep in mind that if you set a value of CPU core count that's larger than core count of your biggest node, then the pod will never be scheduled. Let's say you have a pod that needs 4 cores but you have a kubernetes cluster that's comprised of 2 core VMs. In this case, your pod will never be scheduled.  \n+\n+### Operator sample heap and resource configuration\n+\n+The operator samples configure non-default minimum and maximum heap sizes for WebLogic server JVMs of at least 256MB and 512MB respectively. You can edit a sample's template or domain resource `resources.env` `USER_MEM_ARGS` to have different values. See [Configuring heap size](#configuring-heap-size).\n+\n+Similarly, the operator samples configure CPU and memory resource requests to at least `250m` and `768Mi` respectively.\n+\n+There's no memory or CPU limit configured by default in samples and so the default QoS for sample WebLogic server pod's is `Burstable`. \n+\n+If you wish to set resource requests or limits differently on a sample domain resource or domain resource template, see [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource). Or for samples that generate their domain resource using an 'inputs' file, see the `serverPodMemoryRequest`, `serverPodMemoryLimit`, `serverPodCpuRequest`, and `serverPodCpuLimit` parameters in the sample's `create-domain.sh` input file.\n+\n+### Configuring CPU affinity\n+\n+A Kubernetes hosted WebLogic server may exhibit high lock contention in comparison to an on-premise deployment. This lock contention may be due to lack of CPU cache affinity and/or scheduling latency when workloads move between different CPU cores.  \n+\n+In an on-premise deployment, CPU cache affinity, and therefore reduced lock contention, can be achieved by binding WLS java process to particular CPU core(s) (using the `taskset` command).\n+\n+In a Kubernetes deployment, similar cache affinity can be achieved by doing the following:\n+- Ensuring a pod's CPU resource request and limit are set and equal (to ensure a `guaranteed` QoS).\n+- Configuring the `kubelet` CPU manager policy to be `static` (the default is `none`). See [Control CPU Management Policies on the Node](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies). \n+Note that some Kubernetes environments may not allow changing the CPU management policy.\n+\n+### Measuring JVM heap, pod CPU, and pod memory\n+\n+TBD Discuss/link to Grafana/Prometheus.", "originalCommit": "0477ff166bc9e02dd33e555ab283d981f0eafeef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2NjQ1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448566459", "bodyText": "We added links to \"Monitoring a SOA domain\" which provides steps for setting up Prometheus and Grafana in order to monitor pod memory and CPU resources and setting up WebLogic monitoring exporter for JVM heap monitoring.", "author": "ankedia", "createdAt": "2020-07-01T19:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMjI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU3MTE0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448571148", "bodyText": "Also, added links to \"Tools for Monitoring Resources\" in the Kubernetes documentation. We didn't find an option to monitor pod level resources in OKE monitoring. There's a section about monitoring OKE cluster and section about node level monitoring in OCI IaaS documentation.  Please let me know if we need to link a particular section in OKE documentation. Thanks.", "author": "ankedia", "createdAt": "2020-07-01T19:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMjI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMjQ1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448032456", "bodyText": "What about resource requests/limits?", "author": "rjeberhard", "createdAt": "2020-06-30T23:23:16Z", "path": "kubernetes/samples/scripts/common/domain-template.yaml", "diffHunk": "@@ -63,7 +63,7 @@ spec:\n     - name: JAVA_OPTIONS\n       value: \"%JAVA_OPTIONS%\"\n     - name: USER_MEM_ARGS\n-      value: \"-Djava.security.egd=file:/dev/./urandom \"\n+      value: \"-Djava.security.egd=file:/dev/./urandom -Xms256m -Xmx512m \"", "originalCommit": "0477ff166bc9e02dd33e555ab283d981f0eafeef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMjg4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448032885", "bodyText": "Oh, I see below... we already had those flags. You can ignore this.", "author": "rjeberhard", "createdAt": "2020-06-30T23:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5MjM4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448092385", "bodyText": "My understanding is that this template is used by domain-home-in-image and domain-on-pv samples and resource requests/limits section in domain resource is generated based on how below parameters are configured in create-domain-inputs.yaml file.\nserverPodMemoryRequest\nserverPodCpuRequest\nserverPodMemoryLimit\nserverPodCpuLimit", "author": "ankedia", "createdAt": "2020-07-01T03:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMjQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMjU4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448032583", "bodyText": "Remove extra space", "author": "rjeberhard", "createdAt": "2020-06-30T23:23:37Z", "path": "kubernetes/samples/scripts/common/jrf-domain-template.yaml", "diffHunk": "@@ -0,0 +1,124 @@\n+# Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+#\n+# This is an example of how to define a Domain resource.\n+#\n+apiVersion: \"weblogic.oracle/v8\"\n+kind: Domain\n+metadata:\n+  name: %DOMAIN_UID%\n+  namespace: %NAMESPACE%\n+  labels:\n+    weblogic.domainUID: %DOMAIN_UID%\n+spec:\n+  # The WebLogic Domain Home\n+  domainHome: %DOMAIN_HOME%\n+\n+  # The domain home source type\n+  # Set to PersistentVolume for domain-in-pv, Image for domain-in-image, or FromModel for model-in-image\n+  domainHomeSourceType: %DOMAIN_HOME_SOURCE_TYPE%\n+\n+  # The WebLogic Server Docker image that the Operator uses to start the domain\n+  image: \"%WEBLOGIC_IMAGE%\"\n+\n+  # imagePullPolicy defaults to \"Always\" if image version is :latest\n+  imagePullPolicy: \"%WEBLOGIC_IMAGE_PULL_POLICY%\"\n+\n+  # Identify which Secret contains the credentials for pulling an image\n+  %WEBLOGIC_IMAGE_PULL_SECRET_PREFIX%imagePullSecrets:\n+  %WEBLOGIC_IMAGE_PULL_SECRET_PREFIX%- name: %WEBLOGIC_IMAGE_PULL_SECRET_NAME%\n+\n+  # Identify which Secret contains the WebLogic Admin credentials (note that there is an example of\n+  # how to create that Secret at the end of this file)\n+  webLogicCredentialsSecret: \n+    name: %WEBLOGIC_CREDENTIALS_SECRET_NAME%\n+\n+  # Whether to include the server out file into the pod's stdout, default is true\n+  includeServerOutInPodLog: %INCLUDE_SERVER_OUT_IN_POD_LOG%\n+\n+  # Whether to enable log home\n+  %LOG_HOME_ON_PV_PREFIX%logHomeEnabled: %LOG_HOME_ENABLED%\n+\n+  # Whether to write HTTP access log file to log home\n+  %LOG_HOME_ON_PV_PREFIX%httpAccessLogInLogHome: %HTTP_ACCESS_LOG_IN_LOG_HOME%\n+\n+  # The in-pod location for domain log, server logs, server out, and Node Manager log files\n+  %LOG_HOME_ON_PV_PREFIX%logHome: %LOG_HOME%\n+  # An (optional) in-pod location for data storage of default and custom file stores.\n+  # If not specified or the value is either not set or empty (e.g. dataHome: \"\") then the\n+  # data storage directories are determined from the WebLogic domain home configuration.\n+  dataHome: \"%DATA_HOME%\"\n+\n+", "originalCommit": "0477ff166bc9e02dd33e555ab283d981f0eafeef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5MzQ3NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448093475", "bodyText": "Removed extra space in commit 686e19e. Thanks", "author": "ankedia", "createdAt": "2020-07-01T03:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMjU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMjcxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448032717", "bodyText": "Why does this look like a brand-new file?", "author": "rjeberhard", "createdAt": "2020-06-30T23:24:07Z", "path": "kubernetes/samples/scripts/common/jrf-domain-template.yaml", "diffHunk": "@@ -0,0 +1,124 @@\n+# Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.", "originalCommit": "0477ff166bc9e02dd33e555ab283d981f0eafeef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5MDU2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r448090560", "bodyText": "Previously same domain template was used for WLS and JRF samples for domain-home-in-image and domain-on-pv samples. Since we need to set different USER_MEM_ARGS (different heap sizes) for JRF domains, I created a new template which is used in JRF domain-home-in-image and domain-on-pv samples.", "author": "ankedia", "createdAt": "2020-07-01T03:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzMjcxNw=="}], "type": "inlineReview"}, {"oid": "686e19ec6abdcac68a063443ce3172e7411d61d4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/686e19ec6abdcac68a063443ce3172e7411d61d4", "message": "removed extra space", "committedDate": "2020-07-01T03:18:13Z", "type": "commit"}, {"oid": "748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "message": "Changes for review comments", "committedDate": "2020-07-01T18:35:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NjAzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449056034", "bodyText": "Placeholder request for @rosemarymarano to please suggest description and weight that fits in with the updates you did for other FAQ's.", "author": "rjeberhard", "createdAt": "2020-07-02T14:47:12Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false", "originalCommit": "748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2NDc0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449064748", "bodyText": "Yes. I'll provide that input on my final review of the FAQ.", "author": "rosemarymarano", "createdAt": "2020-07-02T14:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NjAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2MDkzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449060934", "bodyText": "\"An operator\" -> \"The operator\"\nI think I would say it like this, \"The operator creates a container in its own Pod for each WebLogic Server instance.\"\n\"pod container memory\" -> \"container memory\"\n\"and/or\" -> \"and\"\n\"maximum amount of resource\" -> \"maximum amount of a resource\"\nI don't think \"Quality of Service\" should be capitalized here.\nAlso, we've been matching the style in the Kubernetes doc (on their site) and capitalized the names of all resources when specifically referenced as a resource, so all \"pod\" -> \"Pod\" and \"domain resource\" -> \"Domain resource\".", "author": "rjeberhard", "createdAt": "2020-07-02T14:54:24Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Importance of setting heap size and memory resources](#importance-of-setting-heap-size-and-memory-resources)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. You can tune pod container memory and/or CPU usage by configuring Kubernetes resource requests and limits, and you can tune a WebLogic JVM heap usage using the `USER_MEM_ARGS` environment variable in your domain resource. A resource request sets the minimum amount of a resource that a container requires. A resource limit is the maximum amount of resource a container is given and prevents a container from using more than its share of a resource. Additionally, resource requests and limits determine a pod's Quality of Service.", "originalCommit": "748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3NzMwNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449177307", "bodyText": "I have made changes based on above review comments. Thanks.", "author": "ankedia", "createdAt": "2020-07-02T17:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2MDkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2MTIxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449061219", "bodyText": "WebLogic Server instances", "author": "rjeberhard", "createdAt": "2020-07-02T14:54:47Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Importance of setting heap size and memory resources](#importance-of-setting-heap-size-and-memory-resources)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. You can tune pod container memory and/or CPU usage by configuring Kubernetes resource requests and limits, and you can tune a WebLogic JVM heap usage using the `USER_MEM_ARGS` environment variable in your domain resource. A resource request sets the minimum amount of a resource that a container requires. A resource limit is the maximum amount of resource a container is given and prevents a container from using more than its share of a resource. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+This FAQ discusses tuning these parameters so WebLogic servers can run efficiently.", "originalCommit": "748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2MjYxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449062617", "bodyText": "\"in the Kubernetes documentation.\"", "author": "rjeberhard", "createdAt": "2020-07-02T14:56:47Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Importance of setting heap size and memory resources](#importance-of-setting-heap-size-and-memory-resources)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. You can tune pod container memory and/or CPU usage by configuring Kubernetes resource requests and limits, and you can tune a WebLogic JVM heap usage using the `USER_MEM_ARGS` environment variable in your domain resource. A resource request sets the minimum amount of a resource that a container requires. A resource limit is the maximum amount of resource a container is given and prevents a container from using more than its share of a resource. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+This FAQ discusses tuning these parameters so WebLogic servers can run efficiently.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/), [Assign Memory Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource) and [Assign CPU Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource) in Kubernetes documentation.", "originalCommit": "748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2MzI2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449063263", "bodyText": "\"a Kubernetes kubelet default out-of-resource\" -> \"the default\"", "author": "rjeberhard", "createdAt": "2020-07-02T14:57:45Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Importance of setting heap size and memory resources](#importance-of-setting-heap-size-and-memory-resources)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. You can tune pod container memory and/or CPU usage by configuring Kubernetes resource requests and limits, and you can tune a WebLogic JVM heap usage using the `USER_MEM_ARGS` environment variable in your domain resource. A resource request sets the minimum amount of a resource that a container requires. A resource limit is the maximum amount of resource a container is given and prevents a container from using more than its share of a resource. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+This FAQ discusses tuning these parameters so WebLogic servers can run efficiently.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/), [Assign Memory Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource) and [Assign CPU Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource) in Kubernetes documentation.\n+\n+### Determining pod Quality Of Service\n+\n+A pod's Quality of Service (QoS) is based on whether it's configured with resource requests and limits:\n+\n+- **Best Effort QoS** (lowest priority): If you don't configure requests and limits for a pod, then the pod is given a `best-effort` QoS. In cases where a node runs out of non-shareable resources, a Kubernetes `kubelet` default out-of-resource eviction policy evicts running pods with the `best-effort` QoS first.", "originalCommit": "748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwNzEzMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449207132", "bodyText": "Changed the wording to \"the default\".", "author": "ankedia", "createdAt": "2020-07-02T18:48:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2MzI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2NDgzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449064835", "bodyText": "Neither of these priority classes sound like they apply to WebLogic Server instances. Are we recommending that customers choose either of these priority classes? If not, then we don't need to mention them.", "author": "rjeberhard", "createdAt": "2020-07-02T14:59:58Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Importance of setting heap size and memory resources](#importance-of-setting-heap-size-and-memory-resources)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. You can tune pod container memory and/or CPU usage by configuring Kubernetes resource requests and limits, and you can tune a WebLogic JVM heap usage using the `USER_MEM_ARGS` environment variable in your domain resource. A resource request sets the minimum amount of a resource that a container requires. A resource limit is the maximum amount of resource a container is given and prevents a container from using more than its share of a resource. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+This FAQ discusses tuning these parameters so WebLogic servers can run efficiently.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/), [Assign Memory Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource) and [Assign CPU Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource) in Kubernetes documentation.\n+\n+### Determining pod Quality Of Service\n+\n+A pod's Quality of Service (QoS) is based on whether it's configured with resource requests and limits:\n+\n+- **Best Effort QoS** (lowest priority): If you don't configure requests and limits for a pod, then the pod is given a `best-effort` QoS. In cases where a node runs out of non-shareable resources, a Kubernetes `kubelet` default out-of-resource eviction policy evicts running pods with the `best-effort` QoS first.\n+\n+- **Burstable QoS** (medium priority): If you configure both resource requests and limits for a pod, and set the requests to be less than their respective limits, then the pod will be given a `burstable` QoS. Similarly, if you only configure resource requests (without limits) for a pod, then the pod QoS is also `burstable`. If a node runs out of non-shareable resources, the node's `kubelet` will evict `burstable` pods only when there are no more running `best-effort` pods.\n+\n+- **Guaranteed QoS** (highest priority): If you set a pod's requests and the limits to equal values, then the pod will have a `guaranteed` QoS. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, then a Kubernetes node's `kubelet` will evict `best-effort` and `burstable` QoS pods before terminating `guaranteed` QoS pods.\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring WebLogic pods with memory and CPU requests and limits, and furthermore setting requests equal to their respective limits in order to ensure a `guaranteed` QoS.\n+{{% /notice %}}\n+\n+{{% notice note %}} \n+In newer version of Kubernetes, it is possible to fine tune scheduling and eviction policies using [Pod Priority Preemption](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/) in combination with the `serverPod.priorityClassName` domain resource attribute. Note that Kubernetes already ships with two PriorityClasses: `system-cluster-critical` and `system-node-critical`. These are common classes and are used to [ensure that critical components are always scheduled first](https://kubernetes.io/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/).", "originalCommit": "748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2NzA4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449067083", "bodyText": "This text is borrowed from kubectl explain domain.spec.serverPod.priorityClassName.", "author": "tbarnes-us", "createdAt": "2020-07-02T15:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2NDgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2NTM4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449065384", "bodyText": "Does a use case exist where we wouldn't recommend this? If not, you can remove \"For most use cases,\"", "author": "rjeberhard", "createdAt": "2020-07-02T15:00:41Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Importance of setting heap size and memory resources](#importance-of-setting-heap-size-and-memory-resources)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. You can tune pod container memory and/or CPU usage by configuring Kubernetes resource requests and limits, and you can tune a WebLogic JVM heap usage using the `USER_MEM_ARGS` environment variable in your domain resource. A resource request sets the minimum amount of a resource that a container requires. A resource limit is the maximum amount of resource a container is given and prevents a container from using more than its share of a resource. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+This FAQ discusses tuning these parameters so WebLogic servers can run efficiently.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/), [Assign Memory Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource) and [Assign CPU Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource) in Kubernetes documentation.\n+\n+### Determining pod Quality Of Service\n+\n+A pod's Quality of Service (QoS) is based on whether it's configured with resource requests and limits:\n+\n+- **Best Effort QoS** (lowest priority): If you don't configure requests and limits for a pod, then the pod is given a `best-effort` QoS. In cases where a node runs out of non-shareable resources, a Kubernetes `kubelet` default out-of-resource eviction policy evicts running pods with the `best-effort` QoS first.\n+\n+- **Burstable QoS** (medium priority): If you configure both resource requests and limits for a pod, and set the requests to be less than their respective limits, then the pod will be given a `burstable` QoS. Similarly, if you only configure resource requests (without limits) for a pod, then the pod QoS is also `burstable`. If a node runs out of non-shareable resources, the node's `kubelet` will evict `burstable` pods only when there are no more running `best-effort` pods.\n+\n+- **Guaranteed QoS** (highest priority): If you set a pod's requests and the limits to equal values, then the pod will have a `guaranteed` QoS. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, then a Kubernetes node's `kubelet` will evict `best-effort` and `burstable` QoS pods before terminating `guaranteed` QoS pods.\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring WebLogic pods with memory and CPU requests and limits, and furthermore setting requests equal to their respective limits in order to ensure a `guaranteed` QoS.\n+{{% /notice %}}\n+\n+{{% notice note %}} \n+In newer version of Kubernetes, it is possible to fine tune scheduling and eviction policies using [Pod Priority Preemption](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/) in combination with the `serverPod.priorityClassName` domain resource attribute. Note that Kubernetes already ships with two PriorityClasses: `system-cluster-critical` and `system-node-critical`. These are common classes and are used to [ensure that critical components are always scheduled first](https://kubernetes.io/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/).\n+{{% /notice %}}\n+\n+### Java heap size and memory resource considerations\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring Java heap sizes for WebLogic pods instead of relying on defaults.", "originalCommit": "748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3ODkwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449178904", "bodyText": "Removed \"For most use cases,\"", "author": "ankedia", "createdAt": "2020-07-02T17:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2NTM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2NTY3Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449065672", "bodyText": "extra space after \"but\"", "author": "rjeberhard", "createdAt": "2020-07-02T15:01:08Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Importance of setting heap size and memory resources](#importance-of-setting-heap-size-and-memory-resources)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. You can tune pod container memory and/or CPU usage by configuring Kubernetes resource requests and limits, and you can tune a WebLogic JVM heap usage using the `USER_MEM_ARGS` environment variable in your domain resource. A resource request sets the minimum amount of a resource that a container requires. A resource limit is the maximum amount of resource a container is given and prevents a container from using more than its share of a resource. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+This FAQ discusses tuning these parameters so WebLogic servers can run efficiently.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/), [Assign Memory Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource) and [Assign CPU Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource) in Kubernetes documentation.\n+\n+### Determining pod Quality Of Service\n+\n+A pod's Quality of Service (QoS) is based on whether it's configured with resource requests and limits:\n+\n+- **Best Effort QoS** (lowest priority): If you don't configure requests and limits for a pod, then the pod is given a `best-effort` QoS. In cases where a node runs out of non-shareable resources, a Kubernetes `kubelet` default out-of-resource eviction policy evicts running pods with the `best-effort` QoS first.\n+\n+- **Burstable QoS** (medium priority): If you configure both resource requests and limits for a pod, and set the requests to be less than their respective limits, then the pod will be given a `burstable` QoS. Similarly, if you only configure resource requests (without limits) for a pod, then the pod QoS is also `burstable`. If a node runs out of non-shareable resources, the node's `kubelet` will evict `burstable` pods only when there are no more running `best-effort` pods.\n+\n+- **Guaranteed QoS** (highest priority): If you set a pod's requests and the limits to equal values, then the pod will have a `guaranteed` QoS. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, then a Kubernetes node's `kubelet` will evict `best-effort` and `burstable` QoS pods before terminating `guaranteed` QoS pods.\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring WebLogic pods with memory and CPU requests and limits, and furthermore setting requests equal to their respective limits in order to ensure a `guaranteed` QoS.\n+{{% /notice %}}\n+\n+{{% notice note %}} \n+In newer version of Kubernetes, it is possible to fine tune scheduling and eviction policies using [Pod Priority Preemption](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/) in combination with the `serverPod.priorityClassName` domain resource attribute. Note that Kubernetes already ships with two PriorityClasses: `system-cluster-critical` and `system-node-critical`. These are common classes and are used to [ensure that critical components are always scheduled first](https://kubernetes.io/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/).\n+{{% /notice %}}\n+\n+### Java heap size and memory resource considerations\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring Java heap sizes for WebLogic pods instead of relying on defaults.\n+{{% /notice %}}\n+\n+#### Importance of setting heap size and memory resources\n+\n+It's extremely important to set correct heap sizes, memory requests, and memory limits for WebLogic JVMs and Pods. \n+\n+A WebLogic JVM heap must be sufficiently sized to run its applications and services, but should not be sized too large so as not to waste memory resources.\n+\n+A pod memory limit must be sufficiently sized to accommodate the configured heap and native memory requirements, but  not too big to waste memory resources. If a JVM's memory usage (sum of heap and native memory) exceeds its pod's limit, then the JVM process will be abruptly killed due to an out-of-memory error and the WebLogic container will consequently automatically restart due to a liveness probe failure.  ", "originalCommit": "748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2NzA1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449067053", "bodyText": "Aren't they guaranteed to not be evicted?", "author": "rjeberhard", "createdAt": "2020-07-02T15:03:10Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Importance of setting heap size and memory resources](#importance-of-setting-heap-size-and-memory-resources)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. You can tune pod container memory and/or CPU usage by configuring Kubernetes resource requests and limits, and you can tune a WebLogic JVM heap usage using the `USER_MEM_ARGS` environment variable in your domain resource. A resource request sets the minimum amount of a resource that a container requires. A resource limit is the maximum amount of resource a container is given and prevents a container from using more than its share of a resource. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+This FAQ discusses tuning these parameters so WebLogic servers can run efficiently.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/), [Assign Memory Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource) and [Assign CPU Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource) in Kubernetes documentation.\n+\n+### Determining pod Quality Of Service\n+\n+A pod's Quality of Service (QoS) is based on whether it's configured with resource requests and limits:\n+\n+- **Best Effort QoS** (lowest priority): If you don't configure requests and limits for a pod, then the pod is given a `best-effort` QoS. In cases where a node runs out of non-shareable resources, a Kubernetes `kubelet` default out-of-resource eviction policy evicts running pods with the `best-effort` QoS first.\n+\n+- **Burstable QoS** (medium priority): If you configure both resource requests and limits for a pod, and set the requests to be less than their respective limits, then the pod will be given a `burstable` QoS. Similarly, if you only configure resource requests (without limits) for a pod, then the pod QoS is also `burstable`. If a node runs out of non-shareable resources, the node's `kubelet` will evict `burstable` pods only when there are no more running `best-effort` pods.\n+\n+- **Guaranteed QoS** (highest priority): If you set a pod's requests and the limits to equal values, then the pod will have a `guaranteed` QoS. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, then a Kubernetes node's `kubelet` will evict `best-effort` and `burstable` QoS pods before terminating `guaranteed` QoS pods.\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring WebLogic pods with memory and CPU requests and limits, and furthermore setting requests equal to their respective limits in order to ensure a `guaranteed` QoS.\n+{{% /notice %}}\n+\n+{{% notice note %}} \n+In newer version of Kubernetes, it is possible to fine tune scheduling and eviction policies using [Pod Priority Preemption](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/) in combination with the `serverPod.priorityClassName` domain resource attribute. Note that Kubernetes already ships with two PriorityClasses: `system-cluster-critical` and `system-node-critical`. These are common classes and are used to [ensure that critical components are always scheduled first](https://kubernetes.io/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/).\n+{{% /notice %}}\n+\n+### Java heap size and memory resource considerations\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring Java heap sizes for WebLogic pods instead of relying on defaults.\n+{{% /notice %}}\n+\n+#### Importance of setting heap size and memory resources\n+\n+It's extremely important to set correct heap sizes, memory requests, and memory limits for WebLogic JVMs and Pods. \n+\n+A WebLogic JVM heap must be sufficiently sized to run its applications and services, but should not be sized too large so as not to waste memory resources.\n+\n+A pod memory limit must be sufficiently sized to accommodate the configured heap and native memory requirements, but  not too big to waste memory resources. If a JVM's memory usage (sum of heap and native memory) exceeds its pod's limit, then the JVM process will be abruptly killed due to an out-of-memory error and the WebLogic container will consequently automatically restart due to a liveness probe failure.  \n+\n+Oracle recommends setting minimum and maximum heap (or heap percentages) and at least a container memory request.\n+\n+{{% notice warning %}}\n+If resource requests and resource limits are set too high, then your pods may not be scheduled due to lack of node resources, will unnecessarily use up CPU shared resources that could be used by other pods, or may prevent other pods from running.\n+{{% /notice %}}\n+\n+#### Default heap sizes\n+\n+With the latest Java versions, Java 8 update 191 and onwards or Java 11, then if you don't configure a heap size (no '-Xms' or '-Xms') the default heap size is dynamically determined:\n+- If you configure the memory limit for a container, then the JVM default maximum heap size will be 25% (1/4th) of container memory limit and the default minimum heap size will be 1.56% (1/64th) of the limit value. \n+\n+  The default JVM heap settings in this case are often too conservative because the WebLogic JVM is the only major process running in the container.\n+\n+- If no memory limit is configured, then the JVM default maximum heap size will be  25% (1/4th) of the its node's machine RAM and the default minimum heap size will be 1.56% (1/64th) of the RAM.\n+\n+  The default JVM heap settings in this case can have undesirable behavior, including using unnecessary amounts of memory to the point where it might affect other pods that run on the same node.\n+\n+#### Configuring heap size\n+\n+If you specify pod memory limits, Oracle recommends configuring WebLogic Server heap sizes as a percentage. The JVM will interpret the percentage as a fraction of the limit. This is done using the JVM `-XX:MinRAMPercentage` and `-XX:MaxRAMPercentage` options in the `USER_MEM_ARGS` [domain resource environment variable]({{< relref \"/userguide/managing-domains/domain-resource#jvm-memory-and-java-option-environment-variables\" >}}).  For example:\n+\n+```\n+  spec:\n+    resources:\n+      env:\n+      - name: USER_MEM_ARGS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Djava.security.egd=file:/dev/./urandom\"\n+```\n+\n+Additionally there's also a node-manager process that's running in the same container as the WebLogic Server which has its own heap and native memory requirements. Its heap is tuned by using `-Xms` and `-Xmx` in the `NODEMGR_MEM_ARGS` environment variable. Oracle recommends setting the node manager heap memory to fixed sizes, instead of percentages, where [the default tuning]({{< relref \"/userguide/managing-domains/domain-resource#jvm-memory-and-java-option-environment-variables\" >}}) is usually sufficient.\n+\n+{{% notice note %}}\n+Notice that the `NODEMGR_MEM_ARGS` and `USER_MEM_ARGS` environment variables both set `-Djava.security.egd=file:/dev/./urandom` by default so we have also included them in the above example for specifying a `USER_MEM_ARGS` value. This helps speed up Node Manager and WebLogic Server startup on systems with low entropy. \n+{{% /notice %}}\n+\n+In some cases, you might only want to configure memory resource requests but not configure memory resource limits. In such scenarios, you can use the traditional fixed heap size settings (`-Xms` and `-Xmx`) in your WebLogic Server `USER_MEM_ARGS` instead of the percentage settings (`-XX:MinRAMPercentage` and `-XX:MaxRAMPercentage`).\n+\n+### CPU resource considerations\n+\n+It's important to set both a CPU request and a limit for WebLogic Server pods. This ensures that all WebLogic server pods have enough CPU resources, and, as discussed earlier, if the request and limit are set to the same value, then they get a `guaranteed` QoS. A `guaranteed` QoS ensures the pods are handled with a higher priority during scheduling and so are the least likely to be evicted.", "originalCommit": "748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3OTkyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449179929", "bodyText": "It's possible for Guaranteed Pod to be evicted in some cases.", "author": "ankedia", "createdAt": "2020-07-02T17:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2NzA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2Nzc3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449067776", "bodyText": "\"and/or\" -> \"or\"", "author": "rjeberhard", "createdAt": "2020-07-02T15:04:20Z", "path": "docs-source/content/faq/resource-settings.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+title: \"Pod Memory and CPU Resources\"\n+date: 2020-06-30T08:55:00-05:00\n+draft: false\n+weight: 25\n+---\n+\n+### Contents\n+\n+ - [Introduction](#introduction)\n+ - [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource)\n+ - [Determining pod Quality Of Service](#determining-pod-quality-of-service)\n+ - [Java heap size and memory resource considerations](#java-heap-size-and-memory-resource-considerations)\n+   - [Importance of setting heap size and memory resources](#importance-of-setting-heap-size-and-memory-resources)\n+   - [Default heap sizes](#default-heap-sizes)\n+   - [Configuring heap size](#configuring-heap-size)\n+ - [CPU resource considerations](#cpu-resource-considerations)\n+ - [Operator sample heap and resource configuration](#operator-sample-heap-and-resource-configuration)\n+ - [Configuring CPU affinity](#configuring-cpu-affinity)\n+ - [Measuring JVM heap, pod CPU, and pod memory](#measuring-jvm-heap-pod-cpu-and-pod-memory)\n+ - [References](#references)\n+\n+### Introduction\n+\n+An operator creates a pod for each WebLogic Server instance and each pod will have a container. You can tune pod container memory and/or CPU usage by configuring Kubernetes resource requests and limits, and you can tune a WebLogic JVM heap usage using the `USER_MEM_ARGS` environment variable in your domain resource. A resource request sets the minimum amount of a resource that a container requires. A resource limit is the maximum amount of resource a container is given and prevents a container from using more than its share of a resource. Additionally, resource requests and limits determine a pod's Quality of Service.\n+\n+This FAQ discusses tuning these parameters so WebLogic servers can run efficiently.\n+\n+### Setting resource requests and limits in a domain resource\n+\n+You can set Kubernetes memory and CPU requests and limits in a [domain resource]({{< relref \"/userguide/managing-domains/domain-resource\" >}}) using its `spec.serverPod.resources` stanza, and you can override the setting for individual WebLogic servers or clusters using the `serverPod.resources` element in `spec.adminServer`, `spec.clusters`, and/or `spec.managedServers`. For example: \n+\n+```\n+  spec:\n+    serverPod:\n+      requests:\n+        cpu: \"250m\"\n+        memory: \"768Mi\"\n+      limits:\n+        cpu: \"2\"\n+        memory: \"2Gi\"\n+```\n+\n+Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. An `m` suffix in a CPU attribute indicates 'milli-CPU', so `250m` is 25% of a CPU. \n+\n+Memory can be expressed in various units, where one `Mi` is one IEC unit mega-byte (1024^2), and one `Gi` is one IEC unit giga-byte (1024^3).\n+\n+See also [Managing Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/), [Assign Memory Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource) and [Assign CPU Resources to Containers and Pods](https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource) in Kubernetes documentation.\n+\n+### Determining pod Quality Of Service\n+\n+A pod's Quality of Service (QoS) is based on whether it's configured with resource requests and limits:\n+\n+- **Best Effort QoS** (lowest priority): If you don't configure requests and limits for a pod, then the pod is given a `best-effort` QoS. In cases where a node runs out of non-shareable resources, a Kubernetes `kubelet` default out-of-resource eviction policy evicts running pods with the `best-effort` QoS first.\n+\n+- **Burstable QoS** (medium priority): If you configure both resource requests and limits for a pod, and set the requests to be less than their respective limits, then the pod will be given a `burstable` QoS. Similarly, if you only configure resource requests (without limits) for a pod, then the pod QoS is also `burstable`. If a node runs out of non-shareable resources, the node's `kubelet` will evict `burstable` pods only when there are no more running `best-effort` pods.\n+\n+- **Guaranteed QoS** (highest priority): If you set a pod's requests and the limits to equal values, then the pod will have a `guaranteed` QoS. These settings indicates that your pod will consume a fixed amount of memory and CPU. With this configuration, if a node runs out of shareable resources, then a Kubernetes node's `kubelet` will evict `best-effort` and `burstable` QoS pods before terminating `guaranteed` QoS pods.\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring WebLogic pods with memory and CPU requests and limits, and furthermore setting requests equal to their respective limits in order to ensure a `guaranteed` QoS.\n+{{% /notice %}}\n+\n+{{% notice note %}} \n+In newer version of Kubernetes, it is possible to fine tune scheduling and eviction policies using [Pod Priority Preemption](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/) in combination with the `serverPod.priorityClassName` domain resource attribute. Note that Kubernetes already ships with two PriorityClasses: `system-cluster-critical` and `system-node-critical`. These are common classes and are used to [ensure that critical components are always scheduled first](https://kubernetes.io/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/).\n+{{% /notice %}}\n+\n+### Java heap size and memory resource considerations\n+\n+{{% notice note %}} \n+For most use cases, Oracle recommends configuring Java heap sizes for WebLogic pods instead of relying on defaults.\n+{{% /notice %}}\n+\n+#### Importance of setting heap size and memory resources\n+\n+It's extremely important to set correct heap sizes, memory requests, and memory limits for WebLogic JVMs and Pods. \n+\n+A WebLogic JVM heap must be sufficiently sized to run its applications and services, but should not be sized too large so as not to waste memory resources.\n+\n+A pod memory limit must be sufficiently sized to accommodate the configured heap and native memory requirements, but  not too big to waste memory resources. If a JVM's memory usage (sum of heap and native memory) exceeds its pod's limit, then the JVM process will be abruptly killed due to an out-of-memory error and the WebLogic container will consequently automatically restart due to a liveness probe failure.  \n+\n+Oracle recommends setting minimum and maximum heap (or heap percentages) and at least a container memory request.\n+\n+{{% notice warning %}}\n+If resource requests and resource limits are set too high, then your pods may not be scheduled due to lack of node resources, will unnecessarily use up CPU shared resources that could be used by other pods, or may prevent other pods from running.\n+{{% /notice %}}\n+\n+#### Default heap sizes\n+\n+With the latest Java versions, Java 8 update 191 and onwards or Java 11, then if you don't configure a heap size (no '-Xms' or '-Xms') the default heap size is dynamically determined:\n+- If you configure the memory limit for a container, then the JVM default maximum heap size will be 25% (1/4th) of container memory limit and the default minimum heap size will be 1.56% (1/64th) of the limit value. \n+\n+  The default JVM heap settings in this case are often too conservative because the WebLogic JVM is the only major process running in the container.\n+\n+- If no memory limit is configured, then the JVM default maximum heap size will be  25% (1/4th) of the its node's machine RAM and the default minimum heap size will be 1.56% (1/64th) of the RAM.\n+\n+  The default JVM heap settings in this case can have undesirable behavior, including using unnecessary amounts of memory to the point where it might affect other pods that run on the same node.\n+\n+#### Configuring heap size\n+\n+If you specify pod memory limits, Oracle recommends configuring WebLogic Server heap sizes as a percentage. The JVM will interpret the percentage as a fraction of the limit. This is done using the JVM `-XX:MinRAMPercentage` and `-XX:MaxRAMPercentage` options in the `USER_MEM_ARGS` [domain resource environment variable]({{< relref \"/userguide/managing-domains/domain-resource#jvm-memory-and-java-option-environment-variables\" >}}).  For example:\n+\n+```\n+  spec:\n+    resources:\n+      env:\n+      - name: USER_MEM_ARGS\n+        value: \"--XX:MinRAMPercentage=25.0 --XX:MaxRAMPercentage=50.0 -Djava.security.egd=file:/dev/./urandom\"\n+```\n+\n+Additionally there's also a node-manager process that's running in the same container as the WebLogic Server which has its own heap and native memory requirements. Its heap is tuned by using `-Xms` and `-Xmx` in the `NODEMGR_MEM_ARGS` environment variable. Oracle recommends setting the node manager heap memory to fixed sizes, instead of percentages, where [the default tuning]({{< relref \"/userguide/managing-domains/domain-resource#jvm-memory-and-java-option-environment-variables\" >}}) is usually sufficient.\n+\n+{{% notice note %}}\n+Notice that the `NODEMGR_MEM_ARGS` and `USER_MEM_ARGS` environment variables both set `-Djava.security.egd=file:/dev/./urandom` by default so we have also included them in the above example for specifying a `USER_MEM_ARGS` value. This helps speed up Node Manager and WebLogic Server startup on systems with low entropy. \n+{{% /notice %}}\n+\n+In some cases, you might only want to configure memory resource requests but not configure memory resource limits. In such scenarios, you can use the traditional fixed heap size settings (`-Xms` and `-Xmx`) in your WebLogic Server `USER_MEM_ARGS` instead of the percentage settings (`-XX:MinRAMPercentage` and `-XX:MaxRAMPercentage`).\n+\n+### CPU resource considerations\n+\n+It's important to set both a CPU request and a limit for WebLogic Server pods. This ensures that all WebLogic server pods have enough CPU resources, and, as discussed earlier, if the request and limit are set to the same value, then they get a `guaranteed` QoS. A `guaranteed` QoS ensures the pods are handled with a higher priority during scheduling and so are the least likely to be evicted.\n+\n+If a CPU request and limit are _not_ configured for a WebLogic Server pod:\n+- The pod can end up using all CPU resources available on its node and starve other containers from using shareable CPU cycles. \n+\n+- The WebLogic server JVM may choose an unsuitable garbage collection (GC) strategy.\n+\n+- A WebLogic Server self-tuning work-manager may incorrectly optimize the number of threads it allocates for the default thread pool. \n+\n+It's also important to keep in mind that if you set a value of CPU core count that's larger than core count of your biggest node, then the pod will never be scheduled. Let's say you have a pod that needs 4 cores but you have a kubernetes cluster that's comprised of 2 core VMs. In this case, your pod will never be scheduled and will have `Pending` status. For example:\n+\n+```\n+$ kubectl get pod sample-domain1-managed-server1 -n sample-domain1-ns\n+NAME                              READY   STATUS    RESTARTS   AGE\n+sample-domain1-managed-server1    0/1     Pending   0          65s\n+\n+$ kubectl describe pod sample-domain1-managed-server1 -n sample-domain1-ns\n+Events:\n+  Type     Reason            Age                From               Message\n+  ----     ------            ----               ----               -------\n+  Warning  FailedScheduling  16s (x3 over 26s)  default-scheduler  0/2 nodes are available: 2 Insufficient cpu.\n+```\n+\n+### Operator sample heap and resource configuration\n+\n+The operator samples configure non-default minimum and maximum heap sizes for WebLogic server JVMs of at least 256MB and 512MB respectively. You can edit a sample's template or domain resource `resources.env` `USER_MEM_ARGS` to have different values. See [Configuring heap size](#configuring-heap-size).\n+\n+Similarly, the operator samples configure CPU and memory resource requests to at least `250m` and `768Mi` respectively.\n+\n+There's no memory or CPU limit configured by default in samples and so the default QoS for sample WebLogic server pod's is `Burstable`. \n+\n+If you wish to set resource requests or limits differently on a sample domain resource or domain resource template, see [Setting resource requests and limits in a domain resource](#setting-resource-requests-and-limits-in-a-domain-resource). Or for samples that generate their domain resource using an 'inputs' file, see the `serverPodMemoryRequest`, `serverPodMemoryLimit`, `serverPodCpuRequest`, and `serverPodCpuLimit` parameters in the sample's `create-domain.sh` input file.\n+\n+### Configuring CPU affinity\n+\n+A Kubernetes hosted WebLogic server may exhibit high lock contention in comparison to an on-premise deployment. This lock contention may be due to lack of CPU cache affinity and/or scheduling latency when workloads move between different CPU cores.  ", "originalCommit": "748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3NzcyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449077720", "bodyText": "It looks like USER_MEM_ARGS here should have the urandom.  A long-standing error - can you please add it?", "author": "tbarnes-us", "createdAt": "2020-07-02T15:19:26Z", "path": "kubernetes/samples/scripts/create-weblogic-domain/manually-create-domain/domain.yaml", "diffHunk": "@@ -65,7 +65,10 @@ spec:\n     - name: JAVA_OPTIONS\n       value: \"-Dweblogic.StdoutDebugEnabled=false\"\n     - name: USER_MEM_ARGS\n-      value: \"-Xms64m -Xmx256m \"\n+      value: \"-Xms256m -Xmx512m \"", "originalCommit": "748fcce5ba5dfe90929d4fbc69c032e8bd398bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4MDIwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1775#discussion_r449180203", "bodyText": "Added urandom in USER_MEM_ARGS.", "author": "ankedia", "createdAt": "2020-07-02T17:52:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3NzcyMA=="}], "type": "inlineReview"}, {"oid": "956aa90eb7fcec463ed885ffb62073a257ed2dbd", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/956aa90eb7fcec463ed885ffb62073a257ed2dbd", "message": "changes for addressing PR review comments", "committedDate": "2020-07-02T17:13:02Z", "type": "commit"}, {"oid": "0354b9d1f52a700c366e7aaa53a70cb46dfabe6e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0354b9d1f52a700c366e7aaa53a70cb46dfabe6e", "message": "second pass review", "committedDate": "2020-07-02T19:42:09Z", "type": "commit"}]}