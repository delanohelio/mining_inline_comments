{"pr_number": 1563, "pr_title": "Adding test for mii end to end use case", "pr_createdAt": "2020-04-14T21:16:56Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MjczNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408442737", "bodyText": "feels like there are some assertions missing here to make sure createImage and pushImage worked as expected", "author": "markxnelson", "createdAt": "2020-04-14T21:20:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();", "originalCommit": "6a01c49b36b56e69612818706a3cd948afc0e225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MzE5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408443198", "bodyText": "and so on through the file..", "author": "markxnelson", "createdAt": "2020-04-14T21:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MjczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0NTYyNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408445624", "bodyText": "createImage is a method in the same class which has the assertions", "author": "vanajamukkara", "createdAt": "2020-04-14T21:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MjczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0NzI4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408447282", "bodyText": "same for pushImage", "author": "vanajamukkara", "createdAt": "2020-04-14T21:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MjczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNTUzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408515536", "bodyText": "yeah, this is almost ok, but not ideal -- i want to be able to read the test (and only the test) and understand what it does -- if these is shared logic, then at least make the method name more suggestive of what it does ... createImageAndVerifySucess() maybe?", "author": "markxnelson", "createdAt": "2020-04-15T00:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MjczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU0MzcyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408543727", "bodyText": "ok, will change the method name", "author": "vanajamukkara", "createdAt": "2020-04-15T02:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MjczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NTUyOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408765528", "bodyText": "i thought some more about this overnight, and i think i am actually more strongly concerned with this pattern.  this violates one of my key tenets - i want to be able to read the test and understand what it does.  i think this is repeating a mistake from the past, hiding the assertions away in some other method.  i think we want to stop and think about this before we start doing this again. @ddsharpe @rjeberhard what do you think?", "author": "markxnelson", "createdAt": "2020-04-15T11:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MjczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDQ2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408470468", "bodyText": "This method can be moved to a utility class so that every IT class can use it.", "author": "sankarpn", "createdAt": "2020-04-14T22:21:41Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      assertThat(uninstallOperator(opHelmParams))\n+          .as(\"Test uninstallOperator returns true\")\n+          .withFailMessage(\"uninstallOperator() did not return true\")\n+          .isTrue();\n+    }\n+\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertThatCode(\n+          () -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()))\n+          .as(\"Test that deleteServiceAccount doesn not throw an exception\")\n+          .withFailMessage(\"deleteServiceAccount() threw an exception\")\n+          .doesNotThrowAnyException();\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(domainNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(opNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private static String createSA(String namespace) {\n+    final String serviceAccountName = namespace + \"-sa\";\n+    serviceAccount = new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(namespace)\n+                .name(serviceAccountName));\n+\n+    try {\n+      createServiceAccount(serviceAccount);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createServiceAccount failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createServiceAccount does not throw an exception\")\n+          .withFailMessage(String.format(\"Failed to create service account %s\", serviceAccountName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return serviceAccountName;\n+  }\n+\n+  private static String createNamespace() {\n+    String namespace = null;\n+    try {\n+      namespace = createUniqueNamespace();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createUniqueNamespace failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createUniqueNamespace does not throw an exception\")\n+          .withFailMessage(\"createUniqueNamespace() threw an unexpected exception\")\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return namespace;\n+  }\n+\n+  private String createImage() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    String currentDateTime = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    final String imageName = MII_IMAGE_NAME_PREFIX + currentDateTime;\n+\n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        imageName, MII_IMAGE_TAG, MODEL_DIR);\n+    boolean result = createMIIImage(\n+        defaultWITParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(MII_IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(\"latest\")\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(result)\n+        .as(\"Check createMIIImage() returns true\")\n+        .withFailMessage(String.format(\"Failed to create the image %s using WebLogic Image Tool\", imageName))\n+        .isTrue();\n+\n+    // check image exists\n+    assertThat(dockerImageExists(imageName, MII_IMAGE_TAG))\n+        .as(\"Check dockerImageExists() returns true\")\n+        .withFailMessage(String.format(\"Image %s doesn't exist\", imageName + \":\" + MII_IMAGE_TAG))\n+        .isTrue();\n+\n+    return imageName + \":\" + MII_IMAGE_TAG;\n+  }\n+\n+  private void pushImageToOCIR(String image) {\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null) {\n+      String repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      String repoUserName = System.getenv(\"REPO_USERNAME\");\n+      String repoPassword = System.getenv(\"REPO_PASSWORD\");\n+\n+      logger.info(\"Push image {0} to OCIR\", image);\n+      assertThat(dockerLogin(repoRegistry, repoUserName, repoPassword))\n+          .as(\"Test dockerLogin returns true\")\n+          .withFailMessage(\"docker login failed\")\n+          .isTrue();\n+\n+      assertThat(dockerPush(image))\n+          .as(\"Test dockerPush returns true\")\n+          .withFailMessage(String.format(\"docker push failed for image %s\", image))\n+          .isTrue();\n+\n+      //TO Do: Create docker registry secret\n+    }\n+  }\n+\n+  private void createSecretForDomain(String secretName, String username, String password) {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    try {\n+      assertThat(createSecret(new V1Secret()\n+          .metadata(new V1ObjectMeta()\n+              .name(secretName)\n+              .namespace(domainNamespace))\n+          .stringData(secretMap)))\n+          .as(\"Test createSecret returns true\")\n+          .withFailMessage(\"createSecret failed\")\n+          .isTrue();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createSecret failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createSecret does not throw an exception\")\n+          .withFailMessage(String.format(\"Create secret %s failed while creating secret \"\n+              + \"for admin credentials\", secretName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void createDomain(Domain domain) {\n+    boolean result = false;\n+    try {\n+      result = createDomainCustomResource(domain);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createDomainCustomResource failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createDomainCustomResource does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Could not create domain custom resource for domainUID %s in namespace %s\",\n+              domainUID, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    assertThat(result)\n+        .as(\"Test createDomainCustomResource returns true\")\n+        .withFailMessage(String.format(\n+            \"Create domain custom resource failed for domainUID %s in namespace %s\",\n+            domainUID, domainNamespace))\n+        .isTrue();\n+\n+  }\n+\n+  private void checkPodCreated(String podName) {", "originalCommit": "6a01c49b36b56e69612818706a3cd948afc0e225", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDYyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408470627", "bodyText": "This method can be moved to a utility class so that every IT class can use it.", "author": "sankarpn", "createdAt": "2020-04-14T22:22:05Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      assertThat(uninstallOperator(opHelmParams))\n+          .as(\"Test uninstallOperator returns true\")\n+          .withFailMessage(\"uninstallOperator() did not return true\")\n+          .isTrue();\n+    }\n+\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertThatCode(\n+          () -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()))\n+          .as(\"Test that deleteServiceAccount doesn not throw an exception\")\n+          .withFailMessage(\"deleteServiceAccount() threw an exception\")\n+          .doesNotThrowAnyException();\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(domainNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(opNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private static String createSA(String namespace) {\n+    final String serviceAccountName = namespace + \"-sa\";\n+    serviceAccount = new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(namespace)\n+                .name(serviceAccountName));\n+\n+    try {\n+      createServiceAccount(serviceAccount);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createServiceAccount failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createServiceAccount does not throw an exception\")\n+          .withFailMessage(String.format(\"Failed to create service account %s\", serviceAccountName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return serviceAccountName;\n+  }\n+\n+  private static String createNamespace() {\n+    String namespace = null;\n+    try {\n+      namespace = createUniqueNamespace();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createUniqueNamespace failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createUniqueNamespace does not throw an exception\")\n+          .withFailMessage(\"createUniqueNamespace() threw an unexpected exception\")\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return namespace;\n+  }\n+\n+  private String createImage() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    String currentDateTime = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    final String imageName = MII_IMAGE_NAME_PREFIX + currentDateTime;\n+\n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        imageName, MII_IMAGE_TAG, MODEL_DIR);\n+    boolean result = createMIIImage(\n+        defaultWITParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(MII_IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(\"latest\")\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(result)\n+        .as(\"Check createMIIImage() returns true\")\n+        .withFailMessage(String.format(\"Failed to create the image %s using WebLogic Image Tool\", imageName))\n+        .isTrue();\n+\n+    // check image exists\n+    assertThat(dockerImageExists(imageName, MII_IMAGE_TAG))\n+        .as(\"Check dockerImageExists() returns true\")\n+        .withFailMessage(String.format(\"Image %s doesn't exist\", imageName + \":\" + MII_IMAGE_TAG))\n+        .isTrue();\n+\n+    return imageName + \":\" + MII_IMAGE_TAG;\n+  }\n+\n+  private void pushImageToOCIR(String image) {\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null) {\n+      String repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      String repoUserName = System.getenv(\"REPO_USERNAME\");\n+      String repoPassword = System.getenv(\"REPO_PASSWORD\");\n+\n+      logger.info(\"Push image {0} to OCIR\", image);\n+      assertThat(dockerLogin(repoRegistry, repoUserName, repoPassword))\n+          .as(\"Test dockerLogin returns true\")\n+          .withFailMessage(\"docker login failed\")\n+          .isTrue();\n+\n+      assertThat(dockerPush(image))\n+          .as(\"Test dockerPush returns true\")\n+          .withFailMessage(String.format(\"docker push failed for image %s\", image))\n+          .isTrue();\n+\n+      //TO Do: Create docker registry secret\n+    }\n+  }\n+\n+  private void createSecretForDomain(String secretName, String username, String password) {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    try {\n+      assertThat(createSecret(new V1Secret()\n+          .metadata(new V1ObjectMeta()\n+              .name(secretName)\n+              .namespace(domainNamespace))\n+          .stringData(secretMap)))\n+          .as(\"Test createSecret returns true\")\n+          .withFailMessage(\"createSecret failed\")\n+          .isTrue();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createSecret failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createSecret does not throw an exception\")\n+          .withFailMessage(String.format(\"Create secret %s failed while creating secret \"\n+              + \"for admin credentials\", secretName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void createDomain(Domain domain) {\n+    boolean result = false;\n+    try {\n+      result = createDomainCustomResource(domain);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createDomainCustomResource failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createDomainCustomResource does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Could not create domain custom resource for domainUID %s in namespace %s\",\n+              domainUID, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    assertThat(result)\n+        .as(\"Test createDomainCustomResource returns true\")\n+        .withFailMessage(String.format(\n+            \"Create domain custom resource failed for domainUID %s in namespace %s\",\n+            domainUID, domainNamespace))\n+        .isTrue();\n+\n+  }\n+\n+  private void checkPodCreated(String podName) {\n+    try {\n+      waitForCondition(podExists(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podExists failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podExists does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s doesn't exist in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkPodRunning(String podName) {", "originalCommit": "6a01c49b36b56e69612818706a3cd948afc0e225", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDcyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408470720", "bodyText": "This method can be moved to a utility class so that every IT class can use it.", "author": "sankarpn", "createdAt": "2020-04-14T22:22:18Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      assertThat(uninstallOperator(opHelmParams))\n+          .as(\"Test uninstallOperator returns true\")\n+          .withFailMessage(\"uninstallOperator() did not return true\")\n+          .isTrue();\n+    }\n+\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertThatCode(\n+          () -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()))\n+          .as(\"Test that deleteServiceAccount doesn not throw an exception\")\n+          .withFailMessage(\"deleteServiceAccount() threw an exception\")\n+          .doesNotThrowAnyException();\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(domainNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(opNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private static String createSA(String namespace) {\n+    final String serviceAccountName = namespace + \"-sa\";\n+    serviceAccount = new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(namespace)\n+                .name(serviceAccountName));\n+\n+    try {\n+      createServiceAccount(serviceAccount);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createServiceAccount failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createServiceAccount does not throw an exception\")\n+          .withFailMessage(String.format(\"Failed to create service account %s\", serviceAccountName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return serviceAccountName;\n+  }\n+\n+  private static String createNamespace() {\n+    String namespace = null;\n+    try {\n+      namespace = createUniqueNamespace();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createUniqueNamespace failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createUniqueNamespace does not throw an exception\")\n+          .withFailMessage(\"createUniqueNamespace() threw an unexpected exception\")\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return namespace;\n+  }\n+\n+  private String createImage() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    String currentDateTime = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    final String imageName = MII_IMAGE_NAME_PREFIX + currentDateTime;\n+\n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        imageName, MII_IMAGE_TAG, MODEL_DIR);\n+    boolean result = createMIIImage(\n+        defaultWITParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(MII_IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(\"latest\")\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(result)\n+        .as(\"Check createMIIImage() returns true\")\n+        .withFailMessage(String.format(\"Failed to create the image %s using WebLogic Image Tool\", imageName))\n+        .isTrue();\n+\n+    // check image exists\n+    assertThat(dockerImageExists(imageName, MII_IMAGE_TAG))\n+        .as(\"Check dockerImageExists() returns true\")\n+        .withFailMessage(String.format(\"Image %s doesn't exist\", imageName + \":\" + MII_IMAGE_TAG))\n+        .isTrue();\n+\n+    return imageName + \":\" + MII_IMAGE_TAG;\n+  }\n+\n+  private void pushImageToOCIR(String image) {\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null) {\n+      String repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      String repoUserName = System.getenv(\"REPO_USERNAME\");\n+      String repoPassword = System.getenv(\"REPO_PASSWORD\");\n+\n+      logger.info(\"Push image {0} to OCIR\", image);\n+      assertThat(dockerLogin(repoRegistry, repoUserName, repoPassword))\n+          .as(\"Test dockerLogin returns true\")\n+          .withFailMessage(\"docker login failed\")\n+          .isTrue();\n+\n+      assertThat(dockerPush(image))\n+          .as(\"Test dockerPush returns true\")\n+          .withFailMessage(String.format(\"docker push failed for image %s\", image))\n+          .isTrue();\n+\n+      //TO Do: Create docker registry secret\n+    }\n+  }\n+\n+  private void createSecretForDomain(String secretName, String username, String password) {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    try {\n+      assertThat(createSecret(new V1Secret()\n+          .metadata(new V1ObjectMeta()\n+              .name(secretName)\n+              .namespace(domainNamespace))\n+          .stringData(secretMap)))\n+          .as(\"Test createSecret returns true\")\n+          .withFailMessage(\"createSecret failed\")\n+          .isTrue();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createSecret failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createSecret does not throw an exception\")\n+          .withFailMessage(String.format(\"Create secret %s failed while creating secret \"\n+              + \"for admin credentials\", secretName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void createDomain(Domain domain) {\n+    boolean result = false;\n+    try {\n+      result = createDomainCustomResource(domain);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createDomainCustomResource failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createDomainCustomResource does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Could not create domain custom resource for domainUID %s in namespace %s\",\n+              domainUID, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    assertThat(result)\n+        .as(\"Test createDomainCustomResource returns true\")\n+        .withFailMessage(String.format(\n+            \"Create domain custom resource failed for domainUID %s in namespace %s\",\n+            domainUID, domainNamespace))\n+        .isTrue();\n+\n+  }\n+\n+  private void checkPodCreated(String podName) {\n+    try {\n+      waitForCondition(podExists(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podExists failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podExists does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s doesn't exist in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkPodRunning(String podName) {\n+    try {\n+      waitForCondition(podReady(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podReady failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podReady does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s is not ready in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkServiceCreated(String serviceName) {", "originalCommit": "6a01c49b36b56e69612818706a3cd948afc0e225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk4NzEwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408987103", "bodyText": "sure, we can discuss about this in the meeting today.", "author": "vanajamukkara", "createdAt": "2020-04-15T16:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDgwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408470801", "bodyText": "This method can be moved to a utility class so that every IT class can use it.", "author": "sankarpn", "createdAt": "2020-04-14T22:22:28Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      assertThat(uninstallOperator(opHelmParams))\n+          .as(\"Test uninstallOperator returns true\")\n+          .withFailMessage(\"uninstallOperator() did not return true\")\n+          .isTrue();\n+    }\n+\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertThatCode(\n+          () -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()))\n+          .as(\"Test that deleteServiceAccount doesn not throw an exception\")\n+          .withFailMessage(\"deleteServiceAccount() threw an exception\")\n+          .doesNotThrowAnyException();\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(domainNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(opNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private static String createSA(String namespace) {\n+    final String serviceAccountName = namespace + \"-sa\";\n+    serviceAccount = new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(namespace)\n+                .name(serviceAccountName));\n+\n+    try {\n+      createServiceAccount(serviceAccount);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createServiceAccount failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createServiceAccount does not throw an exception\")\n+          .withFailMessage(String.format(\"Failed to create service account %s\", serviceAccountName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return serviceAccountName;\n+  }\n+\n+  private static String createNamespace() {\n+    String namespace = null;\n+    try {\n+      namespace = createUniqueNamespace();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createUniqueNamespace failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createUniqueNamespace does not throw an exception\")\n+          .withFailMessage(\"createUniqueNamespace() threw an unexpected exception\")\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return namespace;\n+  }\n+\n+  private String createImage() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    String currentDateTime = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    final String imageName = MII_IMAGE_NAME_PREFIX + currentDateTime;\n+\n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        imageName, MII_IMAGE_TAG, MODEL_DIR);\n+    boolean result = createMIIImage(\n+        defaultWITParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(MII_IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(\"latest\")\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(result)\n+        .as(\"Check createMIIImage() returns true\")\n+        .withFailMessage(String.format(\"Failed to create the image %s using WebLogic Image Tool\", imageName))\n+        .isTrue();\n+\n+    // check image exists\n+    assertThat(dockerImageExists(imageName, MII_IMAGE_TAG))\n+        .as(\"Check dockerImageExists() returns true\")\n+        .withFailMessage(String.format(\"Image %s doesn't exist\", imageName + \":\" + MII_IMAGE_TAG))\n+        .isTrue();\n+\n+    return imageName + \":\" + MII_IMAGE_TAG;\n+  }\n+\n+  private void pushImageToOCIR(String image) {\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null) {\n+      String repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      String repoUserName = System.getenv(\"REPO_USERNAME\");\n+      String repoPassword = System.getenv(\"REPO_PASSWORD\");\n+\n+      logger.info(\"Push image {0} to OCIR\", image);\n+      assertThat(dockerLogin(repoRegistry, repoUserName, repoPassword))\n+          .as(\"Test dockerLogin returns true\")\n+          .withFailMessage(\"docker login failed\")\n+          .isTrue();\n+\n+      assertThat(dockerPush(image))\n+          .as(\"Test dockerPush returns true\")\n+          .withFailMessage(String.format(\"docker push failed for image %s\", image))\n+          .isTrue();\n+\n+      //TO Do: Create docker registry secret\n+    }\n+  }\n+\n+  private void createSecretForDomain(String secretName, String username, String password) {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    try {\n+      assertThat(createSecret(new V1Secret()\n+          .metadata(new V1ObjectMeta()\n+              .name(secretName)\n+              .namespace(domainNamespace))\n+          .stringData(secretMap)))\n+          .as(\"Test createSecret returns true\")\n+          .withFailMessage(\"createSecret failed\")\n+          .isTrue();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createSecret failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createSecret does not throw an exception\")\n+          .withFailMessage(String.format(\"Create secret %s failed while creating secret \"\n+              + \"for admin credentials\", secretName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void createDomain(Domain domain) {\n+    boolean result = false;\n+    try {\n+      result = createDomainCustomResource(domain);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createDomainCustomResource failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createDomainCustomResource does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Could not create domain custom resource for domainUID %s in namespace %s\",\n+              domainUID, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    assertThat(result)\n+        .as(\"Test createDomainCustomResource returns true\")\n+        .withFailMessage(String.format(\n+            \"Create domain custom resource failed for domainUID %s in namespace %s\",\n+            domainUID, domainNamespace))\n+        .isTrue();\n+\n+  }\n+\n+  private void checkPodCreated(String podName) {\n+    try {\n+      waitForCondition(podExists(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podExists failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podExists does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s doesn't exist in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkPodRunning(String podName) {\n+    try {\n+      waitForCondition(podReady(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podReady failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podReady does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s is not ready in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkServiceCreated(String serviceName) {\n+    try {\n+      waitForCondition(serviceReady(serviceName, null, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podExists failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podExists does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Service %s is not ready in namespace %s\", serviceName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private static void waitForCondition(Callable callable) {", "originalCommit": "6a01c49b36b56e69612818706a3cd948afc0e225", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MTMzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408471334", "bodyText": "This method can be moved to a utility class so that every IT class can use it.", "author": "sankarpn", "createdAt": "2020-04-14T22:23:45Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,557 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME_PREFIX = \"mii-image-\";\n+  private static final String MII_IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      assertThat(uninstallOperator(opHelmParams))\n+          .as(\"Test uninstallOperator returns true\")\n+          .withFailMessage(\"uninstallOperator() did not return true\")\n+          .isTrue();\n+    }\n+\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertThatCode(\n+          () -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()))\n+          .as(\"Test that deleteServiceAccount doesn not throw an exception\")\n+          .withFailMessage(\"deleteServiceAccount() threw an exception\")\n+          .doesNotThrowAnyException();\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(domainNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(opNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private static String createSA(String namespace) {\n+    final String serviceAccountName = namespace + \"-sa\";\n+    serviceAccount = new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(namespace)\n+                .name(serviceAccountName));\n+\n+    try {\n+      createServiceAccount(serviceAccount);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createServiceAccount failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createServiceAccount does not throw an exception\")\n+          .withFailMessage(String.format(\"Failed to create service account %s\", serviceAccountName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return serviceAccountName;\n+  }\n+\n+  private static String createNamespace() {\n+    String namespace = null;\n+    try {\n+      namespace = createUniqueNamespace();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createUniqueNamespace failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createUniqueNamespace does not throw an exception\")\n+          .withFailMessage(\"createUniqueNamespace() threw an unexpected exception\")\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return namespace;\n+  }\n+\n+  private String createImage() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    String currentDateTime = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    final String imageName = MII_IMAGE_NAME_PREFIX + currentDateTime;\n+\n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        imageName, MII_IMAGE_TAG, MODEL_DIR);\n+    boolean result = createMIIImage(\n+        defaultWITParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(MII_IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(\"latest\")\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(result)\n+        .as(\"Check createMIIImage() returns true\")\n+        .withFailMessage(String.format(\"Failed to create the image %s using WebLogic Image Tool\", imageName))\n+        .isTrue();\n+\n+    // check image exists\n+    assertThat(dockerImageExists(imageName, MII_IMAGE_TAG))\n+        .as(\"Check dockerImageExists() returns true\")\n+        .withFailMessage(String.format(\"Image %s doesn't exist\", imageName + \":\" + MII_IMAGE_TAG))\n+        .isTrue();\n+\n+    return imageName + \":\" + MII_IMAGE_TAG;\n+  }\n+\n+  private void pushImageToOCIR(String image) {", "originalCommit": "6a01c49b36b56e69612818706a3cd948afc0e225", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6a01c49b36b56e69612818706a3cd948afc0e225", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6a01c49b36b56e69612818706a3cd948afc0e225", "message": "adding mii end to end use case", "committedDate": "2020-04-15T05:11:41Z", "type": "commit"}, {"oid": "f2886c0368503086460034b099e08c865db10309", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f2886c0368503086460034b099e08c865db10309", "message": "same image name, different tag", "committedDate": "2020-04-15T06:25:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NDU4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408764584", "bodyText": "the description above suggests that the installation of the operator is a part of the test - so I think that either you should install the operator in the test itself -or- update the description if the installation is not actually part of the test, but the operator is just a pre-req of th test", "author": "markxnelson", "createdAt": "2020-04-15T11:15:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,555 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll", "originalCommit": "f2886c0368503086460034b099e08c865db10309", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzNTA0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408835044", "bodyText": "yes, operator is just a pre-req for the test, will change the description if per-requisites should not be mentioned there.", "author": "vanajamukkara", "createdAt": "2020-04-15T13:20:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NDU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk4Njc4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408986781", "bodyText": "done", "author": "vanajamukkara", "createdAt": "2020-04-15T16:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NDU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NjU2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408766564", "bodyText": "this should be handled by generic code in an extension, that will clean up the namespace(s) used by any test class that is finished", "author": "markxnelson", "createdAt": "2020-04-15T11:19:04Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,555 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release", "originalCommit": "f2886c0368503086460034b099e08c865db10309", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzNjk2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408836964", "bodyText": "Sankar or someone is working on clean up common class. This can be changed when that is ready, till that time don't want to leave the domain, operator, namespaces running after the test completes and hence here.", "author": "vanajamukkara", "createdAt": "2020-04-15T13:23:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NjU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NzUwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408767501", "bodyText": "this message is too generic - the person reading the output will have no idea what you are waiting for", "author": "markxnelson", "createdAt": "2020-04-15T11:20:57Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -0,0 +1,555 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.logging.Level;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.extensions.Timing;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMIIImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWITParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceReady;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.awaitility.Awaitility.with;\n+\n+// Test to install Operator, create model in image domain and verify the domain\n+// has started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@ExtendWith(Timing.class)\n+class ItMiiDomain implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private String domainUID = \"domain1\";\n+  private String miiImage = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = createNamespace();\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = createSA(opNamespace);\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertThat(installOperator(opParams))\n+        .as(\"Test installOperator returns true\")\n+        .withFailMessage(\"installOperator() did not return true\")\n+        .isTrue();\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    assertThat(helmList(opHelmParams))\n+        .as(\"Test helmList returns true\")\n+        .withFailMessage(\"helmList() did not return true\")\n+        .isTrue();\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    waitForCondition(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUID + \"-admin-server\";\n+    final String managedServerPrefix = domainUID + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImage();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageToOCIR(miiImage);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretForDomain(adminSecretName, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretForDomain(encryptionSecretName, \"weblogicenc\", \"weblogicenc\");\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUID)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUID)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUID, domainNamespace);\n+    createDomain(domain);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    waitForCondition(domainExists(domainUID, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertThatCode(\n+        () -> deleteDomainCustomResource(domainUID, domainNamespace))\n+        .as(\"Test that deleteDomainCustomResource doesn not throw an exception\")\n+        .withFailMessage(\"delete domain custom resource failed\")\n+        .doesNotThrowAnyException();\n+\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUID + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      assertThat(uninstallOperator(opHelmParams))\n+          .as(\"Test uninstallOperator returns true\")\n+          .withFailMessage(\"uninstallOperator() did not return true\")\n+          .isTrue();\n+    }\n+\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertThatCode(\n+          () -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()))\n+          .as(\"Test that deleteServiceAccount doesn not throw an exception\")\n+          .withFailMessage(\"deleteServiceAccount() threw an exception\")\n+          .doesNotThrowAnyException();\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(domainNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertThatCode(\n+          () -> deleteNamespace(opNamespace))\n+          .as(\"Test that deleteNamespace doesn not throw an exception\")\n+          .withFailMessage(\"deleteNamespace() threw an exception\")\n+          .doesNotThrowAnyException();\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private static String createSA(String namespace) {\n+    final String serviceAccountName = namespace + \"-sa\";\n+    serviceAccount = new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(namespace)\n+                .name(serviceAccountName));\n+\n+    try {\n+      createServiceAccount(serviceAccount);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createServiceAccount failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createServiceAccount does not throw an exception\")\n+          .withFailMessage(String.format(\"Failed to create service account %s\", serviceAccountName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return serviceAccountName;\n+  }\n+\n+  private static String createNamespace() {\n+    String namespace = null;\n+    try {\n+      namespace = createUniqueNamespace();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createUniqueNamespace failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createUniqueNamespace does not throw an exception\")\n+          .withFailMessage(\"createUniqueNamespace() threw an unexpected exception\")\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    return namespace;\n+  }\n+\n+  private String createImage() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+\n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        MII_IMAGE_NAME, imageTag, MODEL_DIR);\n+    boolean result = createMIIImage(\n+        defaultWITParams()\n+            .modelImageName(MII_IMAGE_NAME)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(\"latest\")\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(result)\n+        .as(\"Check createMIIImage() returns true\")\n+        .withFailMessage(String.format(\"Failed to create the image %s using WebLogic Image Tool\", MII_IMAGE_NAME))\n+        .isTrue();\n+\n+    // check image exists\n+    assertThat(dockerImageExists(MII_IMAGE_NAME, imageTag))\n+        .as(\"Check dockerImageExists() returns true\")\n+        .withFailMessage(String.format(\"Image %s doesn't exist\", MII_IMAGE_NAME + \":\" + imageTag))\n+        .isTrue();\n+\n+    return MII_IMAGE_NAME + \":\" + imageTag;\n+  }\n+\n+  private void pushImageToOCIR(String image) {\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null) {\n+      String repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      String repoUserName = System.getenv(\"REPO_USERNAME\");\n+      String repoPassword = System.getenv(\"REPO_PASSWORD\");\n+\n+      logger.info(\"Push image {0} to OCIR\", image);\n+      assertThat(dockerLogin(repoRegistry, repoUserName, repoPassword))\n+          .as(\"Test dockerLogin returns true\")\n+          .withFailMessage(\"docker login failed\")\n+          .isTrue();\n+\n+      assertThat(dockerPush(image))\n+          .as(\"Test dockerPush returns true\")\n+          .withFailMessage(String.format(\"docker push failed for image %s\", image))\n+          .isTrue();\n+\n+      //TO Do: Create docker registry secret\n+    }\n+  }\n+\n+  private void createSecretForDomain(String secretName, String username, String password) {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    try {\n+      assertThat(createSecret(new V1Secret()\n+          .metadata(new V1ObjectMeta()\n+              .name(secretName)\n+              .namespace(domainNamespace))\n+          .stringData(secretMap)))\n+          .as(\"Test createSecret returns true\")\n+          .withFailMessage(\"createSecret failed\")\n+          .isTrue();\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createSecret failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createSecret does not throw an exception\")\n+          .withFailMessage(String.format(\"Create secret %s failed while creating secret \"\n+              + \"for admin credentials\", secretName))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void createDomain(Domain domain) {\n+    boolean result = false;\n+    try {\n+      result = createDomainCustomResource(domain);\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"createDomainCustomResource failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that createDomainCustomResource does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Could not create domain custom resource for domainUID %s in namespace %s\",\n+              domainUID, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+    assertThat(result)\n+        .as(\"Test createDomainCustomResource returns true\")\n+        .withFailMessage(String.format(\n+            \"Create domain custom resource failed for domainUID %s in namespace %s\",\n+            domainUID, domainNamespace))\n+        .isTrue();\n+\n+  }\n+\n+  private void checkPodCreated(String podName) {\n+    try {\n+      waitForCondition(podExists(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podExists failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podExists does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s doesn't exist in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkPodRunning(String podName) {\n+    try {\n+      waitForCondition(podReady(podName, domainUID, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podReady failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podReady does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"pod %s is not ready in namespace %s\", podName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private void checkServiceCreated(String serviceName) {\n+    try {\n+      waitForCondition(serviceReady(serviceName, null, domainNamespace));\n+    } catch (ApiException e) {\n+      logger.log(Level.INFO, \"podExists failed with \", e);\n+      assertThat(e)\n+          .as(\"Test that podExists does not throw an exception\")\n+          .withFailMessage(String.format(\n+              \"Service %s is not ready in namespace %s\", serviceName, domainNamespace))\n+          .isNotInstanceOf(ApiException.class);\n+    }\n+  }\n+\n+  private static void waitForCondition(Callable callable) {\n+    with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for a condition to be met (elapsed time {0}ms, remaining time {1}ms)\",", "originalCommit": "f2886c0368503086460034b099e08c865db10309", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg0MzY3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408843670", "bodyText": "this is how the messages look like ....it first logs what's its checking for and then the wait\n04-14-2020 23:09:36> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain testCreateMiiDomain> <Check for domain custom resouce in namespace ns-ttsf>\n<04-14-2020 23:09:38> <INFO> <oracle.weblogic.kubernetes.assertions.impl.Domain lambda$doesDomainExist$0> <Domain Object exists : true>\n<04-14-2020 23:09:38> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 2,095ms, remaining time 297,905ms)>\n<04-14-2020 23:09:38> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain testCreateMiiDomain> <Check for admin server pod domain1-admin-server existence in namespace ns-ttsf>\n<04-14-2020 23:09:40> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 2,029ms, remaining time 297,971ms)>\n<04-14-2020 23:09:50> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 12,041ms, remaining time 287,959ms)>\n<04-14-2020 23:10:00> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 22,062ms, remaining time 277,938ms)>\n<04-14-2020 23:10:10> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 32,096ms, remaining time 267,904ms)>\n<04-14-2020 23:10:20> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 42,197ms, remaining time 257,803ms)>\n<04-14-2020 23:10:30> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 52,230ms, remaining time 247,770ms)>\n<04-14-2020 23:10:40> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 62,260ms, remaining time 237,740ms)>\n<04-14-2020 23:10:51> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 72,409ms, remaining time 227,591ms)>\n<04-14-2020 23:11:01> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 82,486ms, remaining time 217,514ms)>\n<04-14-2020 23:11:11> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 92,497ms, remaining time 207,503ms)>\n<04-14-2020 23:11:21> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 102,505ms, remaining time 197,495ms)>\n<04-14-2020 23:11:31> <INFO> <oracle.weblogic.kubernetes.assertions.impl.Kubernetes getPod> <Pod Name :domain1-admin-server>\n<04-14-2020 23:11:31> <INFO> <oracle.weblogic.kubernetes.assertions.impl.Kubernetes getPod> <Pod Namespace :ns-ttsf>\n<04-14-2020 23:11:31> <INFO> <oracle.weblogic.kubernetes.assertions.impl.Kubernetes getPod> <Pod UID :86cc48e9-d7cf-4cd2-8ebf-a739a2059454>\n<04-14-2020 23:11:31> <INFO> <oracle.weblogic.kubernetes.assertions.impl.Kubernetes getPod> <Pod Status :Running>\n<04-14-2020 23:11:31> <INFO> <oracle.weblogic.kubernetes.ItMiiDomain lambda$waitForCondition$4> <Waiting for a condition to be met (elapsed time 112,523ms, remaining time 187,477ms)>\n\nI have the wait as common code, if the wait message is not clear here I can change to have wait for each condition. @rjeberhard @ddsharpe your thoughts please", "author": "vanajamukkara", "createdAt": "2020-04-15T13:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg0ODU4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408848582", "bodyText": "yes but remember that the tests run in parallel, and these will be intermingled with all sorts of other messages, and it seems like a trivial change here to make this much easier for the person reading the output", "author": "markxnelson", "createdAt": "2020-04-15T13:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg1OTE5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408859190", "bodyText": "we should not be seeing the intermingled output when tests run in parallel, every test should write to a individual file and that's what we should see to understand what that test is doing. Intermingled output is very confusing and gives wrong impression when looking for a particular test.\nComing to the change, need suggestions. Currently I have this method which is getting called 5 times in this test. I was thinking to add arguments for poll delay, interval, max time to wait. Add one more for logMessage or move this code itself to all 5 places?\n  private static void waitForCondition(Callable callable) {\n    with().pollDelay(2, SECONDS)\n        .and().with().pollInterval(10, SECONDS)\n        .conditionEvaluationListener(\n            condition -> logger.info(\n                \"Waiting for a condition to be met (elapsed time {0}ms, remaining time {1}ms)\",\n                condition.getElapsedTimeInMS(),\n                condition.getRemainingTimeInMS()))\n        // and here we can set the maximum time we are prepared to wait\n        .await().atMost(5, MINUTES)\n        .until(callable);\n  }", "author": "vanajamukkara", "createdAt": "2020-04-15T13:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2NDk0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408864945", "bodyText": "you can create a reusable set of conditions, i have an example, see https://github.com/oracle/weblogic-kubernetes-operator/blob/mark/junit5/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleDomainValidation.java", "author": "markxnelson", "createdAt": "2020-04-15T14:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2NjM0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408866343", "bodyText": "i am talking about when we run the full suite on jenkins - all the output is intermingled.  i don't really want to dig through 100 different test's output files to work out which one is stuck.\n\nIntermingled output is very confusing and gives wrong impression when looking for a particular test.\n\nas you said - that is exactly why i am asking you to make this simple change", "author": "markxnelson", "createdAt": "2020-04-15T14:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg3NzMyNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408877325", "bodyText": "I will make the change. You will never be able to find out correctly what's going on with a test by looking at just the intermingled output.", "author": "vanajamukkara", "createdAt": "2020-04-15T14:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk4NjYxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408986614", "bodyText": "done", "author": "vanajamukkara", "createdAt": "2020-04-15T16:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NzUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NzcxNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408767716", "bodyText": "fix javadoc", "author": "markxnelson", "createdAt": "2020-04-15T11:21:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -438,6 +439,37 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  // ------------------------ Docker --------------------------------------\n+\n+  /**\n+   * Log in to a Docker registry.\n+   * @param registryName registry name\n+   * @param username user\n+   * @param password password\n+   * @return true if successfull\n+   */\n+  public static boolean dockerLogin(String registryName, String username, String password) {\n+    return Docker.login(registryName, username, password);\n+  }\n+\n+  /**\n+   * Push an image to a registry", "originalCommit": "f2886c0368503086460034b099e08c865db10309", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk4NjE1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408986156", "bodyText": "fixed", "author": "vanajamukkara", "createdAt": "2020-04-15T16:46:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NzcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2ODExMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408768113", "bodyText": "no imports?", "author": "markxnelson", "createdAt": "2020-04-15T11:22:18Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Docker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl.primitive;\n+", "originalCommit": "f2886c0368503086460034b099e08c865db10309", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg0OTM2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408849363", "bodyText": "yes, no imports. The methods in the class executes certain commands, it uses other classes(Command, CommandParams) in the same package.", "author": "vanajamukkara", "createdAt": "2020-04-15T13:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2ODExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2ODY5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408768697", "bodyText": "what does image mean? is the fully qualified docker image name, including the repository and the tag?", "author": "markxnelson", "createdAt": "2020-04-15T11:23:23Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Docker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl.primitive;\n+\n+\n+public class Docker {\n+\n+  /**\n+   * Log in to a Docker registry.\n+   * @param registryName registry name\n+   * @param username user\n+   * @param password password\n+   * @return true if successfull\n+   */\n+  public static boolean login(String registryName, String username, String password) {\n+    String cmdToExecute = String.format(\"docker login %s -u %s -p \\\"%s\\\"\",\n+        registryName, username, password);\n+    return new Command()\n+        .withParams(new CommandParams()\n+            .command(cmdToExecute))\n+        .execute();\n+  }\n+\n+  /**\n+   * Push an image to a registry\n+   * @param image image", "originalCommit": "f2886c0368503086460034b099e08c865db10309", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg0ODA3Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408848073", "bodyText": "yes, changing the param description to fully qualified docker image, image name:image tag", "author": "vanajamukkara", "createdAt": "2020-04-15T13:38:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2ODY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2OTQ2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408769469", "bodyText": "a service can't be \"ready\" - what are you really checking for? that it exists? that is has endpoints?", "author": "markxnelson", "createdAt": "2020-04-15T11:24:50Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -98,17 +98,19 @@\n    * Check is a service exists in given namespace.\n    *\n    * @param serviceName the name of the service to check for\n-   * @param label a Map of key value pairs the service is decorated with\n-   * @param namespace in which the service is running\n+   * @param label       a Map of key value pairs the service is decorated with\n+   * @param namespace   in which the service is running\n    * @return true if the service exists otherwise false\n    * @throws ApiException when query fails\n    */\n-  public static boolean serviceReady(\n+  public static Callable<Boolean> serviceReady(", "originalCommit": "f2886c0368503086460034b099e08c865db10309", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg2MjE2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408862163", "bodyText": "I think its checking for existence. @sankarpn can you please confirm.", "author": "vanajamukkara", "createdAt": "2020-04-15T13:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2OTQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk4NDU4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r408984589", "bodyText": "The assertion only checks if a service exists. I guess @vanajamukkara is checking for whether the service exists, not ready.", "author": "sankarpn", "createdAt": "2020-04-15T16:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2OTQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1MTEzMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r409051133", "bodyText": "I will change the assertion method name to serviceExists to avoid confusion", "author": "vanajamukkara", "createdAt": "2020-04-15T18:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2OTQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1MTUzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1563#discussion_r409051536", "bodyText": "@markxnelson let me know if we should be checking for more than service existence.", "author": "vanajamukkara", "createdAt": "2020-04-15T18:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2OTQ2OQ=="}], "type": "inlineReview"}, {"oid": "aa25ced8965e9bd1324648bc69801d9e02bced9d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/aa25ced8965e9bd1324648bc69801d9e02bced9d", "message": "addressing review comments", "committedDate": "2020-04-16T00:22:38Z", "type": "commit"}, {"oid": "7557f8cc938081795845f55239e98be558b96f03", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7557f8cc938081795845f55239e98be558b96f03", "message": "modified exception handling and creating docker registry secret", "committedDate": "2020-04-16T06:14:18Z", "type": "commit"}]}