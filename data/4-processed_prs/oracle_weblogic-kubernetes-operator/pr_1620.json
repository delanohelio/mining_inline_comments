{"pr_number": 1620, "pr_title": "Consolidate happy path sample tests", "pr_createdAt": "2020-05-05T05:14:51Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620", "timeline": [{"oid": "bb208fa49c8460b81efb1af109f8177d114735ce", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/bb208fa49c8460b81efb1af109f8177d114735ce", "message": "Consolidate the ItSimpleDomainValidation.java\nItSimpleOperatorValidation.java and ItWitValidation.java\ninto a single file", "committedDate": "2020-05-05T04:28:20Z", "type": "commit"}, {"oid": "4f9ad7bbc0acd471c0bee1968e4998bb4188a265", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4f9ad7bbc0acd471c0bee1968e4998bb4188a265", "message": "order the tests", "committedDate": "2020-05-05T07:17:07Z", "type": "commit"}, {"oid": "c5596763bb66871402e4dc1e7217f0c56dde1e4b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c5596763bb66871402e4dc1e7217f0c56dde1e4b", "message": "fix operator ready assertion", "committedDate": "2020-05-05T08:22:19Z", "type": "commit"}, {"oid": "9db9614c24b297b01e5116cd167de8b3485d6e56", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9db9614c24b297b01e5116cd167de8b3485d6e56", "message": "Revert \"fix operator ready assertion\"\n\nThis reverts commit c5596763bb66871402e4dc1e7217f0c56dde1e4b.", "committedDate": "2020-05-05T08:33:11Z", "type": "commit"}, {"oid": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "message": "use the new operatorReady api", "committedDate": "2020-05-05T08:34:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMzQzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420033437", "bodyText": "JUnit - the U is capital", "author": "markxnelson", "createdAt": "2020-05-05T11:16:50Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMzc5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420033797", "bodyText": "this comment and log message are wrong now, since we are injecting namespaces", "author": "markxnelson", "createdAt": "2020-05-05T11:17:35Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNDM4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420034386", "bodyText": "you have to create the pv before the pvc", "author": "markxnelson", "createdAt": "2020-05-05T11:18:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM1Mzg1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420353855", "bodyText": "Fixed it.", "author": "sankarpn", "createdAt": "2020-05-05T19:28:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNDM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNTE0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420035147", "bodyText": "this will need to be refactored out to a pv handler that takes the type as a parameter, we will need to support multiple types of storage providers", "author": "markxnelson", "createdAt": "2020-05-05T11:20:35Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNTgzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420035836", "bodyText": "in general, all of these comments should be log messages, so we can look at the output and easily understand what it is doing", "author": "markxnelson", "createdAt": "2020-05-05T11:22:10Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(TestConstants.PV_ROOT + \"/\" + domainUid + \"-persistentVolume\")))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create a MII image\")\n+  public void testCreatingMiiImage() {\n+\n+    logger.info(\"WDT model directory is {0}\", MODEL_DIR);\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjA5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420036099", "bodyText": "Docker has a capital D", "author": "markxnelson", "createdAt": "2020-05-05T11:22:48Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(TestConstants.PV_ROOT + \"/\" + domainUid + \"-persistentVolume\")))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create a MII image\")\n+  public void testCreatingMiiImage() {\n+\n+    logger.info(\"WDT model directory is {0}\", MODEL_DIR);\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    boolean success = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(IMAGE_NAME)\n+            .modelImageTag(IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(success)\n+        .as(\"Test the Docker image creation\")\n+        .withFailMessage(\"Failed to create the image using WebLogic Image Tool\")\n+        .isTrue();\n+\n+    dockerImageExists(IMAGE_NAME, IMAGE_TAG);\n+  }\n+\n+  /**\n+   * Install Operator and verify Operator is running.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Install the operator\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testInstallingOperator() {\n+\n+    String image = getOperatorImageName();\n+    assertFalse(image.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", image);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjM4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420036381", "bodyText": "Either spell Docker right, or use docker-registry which is the secret type", "author": "markxnelson", "createdAt": "2020-05-05T11:23:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(TestConstants.PV_ROOT + \"/\" + domainUid + \"-persistentVolume\")))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create a MII image\")\n+  public void testCreatingMiiImage() {\n+\n+    logger.info(\"WDT model directory is {0}\", MODEL_DIR);\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    boolean success = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(IMAGE_NAME)\n+            .modelImageTag(IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(success)\n+        .as(\"Test the Docker image creation\")\n+        .withFailMessage(\"Failed to create the image using WebLogic Image Tool\")\n+        .isTrue();\n+\n+    dockerImageExists(IMAGE_NAME, IMAGE_TAG);\n+  }\n+\n+  /**\n+   * Install Operator and verify Operator is running.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Install the operator\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testInstallingOperator() {\n+\n+    String image = getOperatorImageName();\n+    assertFalse(image.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", image);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjgwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420036806", "bodyText": "operator does not have capital o", "author": "markxnelson", "createdAt": "2020-05-05T11:24:18Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(TestConstants.PV_ROOT + \"/\" + domainUid + \"-persistentVolume\")))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create a MII image\")\n+  public void testCreatingMiiImage() {\n+\n+    logger.info(\"WDT model directory is {0}\", MODEL_DIR);\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    boolean success = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(IMAGE_NAME)\n+            .modelImageTag(IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(success)\n+        .as(\"Test the Docker image creation\")\n+        .withFailMessage(\"Failed to create the image using WebLogic Image Tool\")\n+        .isTrue();\n+\n+    dockerImageExists(IMAGE_NAME, IMAGE_TAG);\n+  }\n+\n+  /**\n+   * Install Operator and verify Operator is running.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Install the operator\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testInstallingOperator() {\n+\n+    String image = getOperatorImageName();\n+    assertFalse(image.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", image);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(image)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace1))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjk2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420036968", "bodyText": "operator", "author": "markxnelson", "createdAt": "2020-05-05T11:24:37Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(TestConstants.PV_ROOT + \"/\" + domainUid + \"-persistentVolume\")))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create a MII image\")\n+  public void testCreatingMiiImage() {\n+\n+    logger.info(\"WDT model directory is {0}\", MODEL_DIR);\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    boolean success = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(IMAGE_NAME)\n+            .modelImageTag(IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(success)\n+        .as(\"Test the Docker image creation\")\n+        .withFailMessage(\"Failed to create the image using WebLogic Image Tool\")\n+        .isTrue();\n+\n+    dockerImageExists(IMAGE_NAME, IMAGE_TAG);\n+  }\n+\n+  /**\n+   * Install Operator and verify Operator is running.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Install the operator\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testInstallingOperator() {\n+\n+    String image = getOperatorImageName();\n+    assertFalse(image.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", image);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(image)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace1))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNzE0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420037149", "bodyText": "operator", "author": "markxnelson", "createdAt": "2020-05-05T11:24:59Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(TestConstants.PV_ROOT + \"/\" + domainUid + \"-persistentVolume\")))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create a MII image\")\n+  public void testCreatingMiiImage() {\n+\n+    logger.info(\"WDT model directory is {0}\", MODEL_DIR);\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    boolean success = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(IMAGE_NAME)\n+            .modelImageTag(IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(success)\n+        .as(\"Test the Docker image creation\")\n+        .withFailMessage(\"Failed to create the image using WebLogic Image Tool\")\n+        .isTrue();\n+\n+    dockerImageExists(IMAGE_NAME, IMAGE_TAG);\n+  }\n+\n+  /**\n+   * Install Operator and verify Operator is running.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Install the operator\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testInstallingOperator() {\n+\n+    String image = getOperatorImageName();\n+    assertFalse(image.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", image);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(image)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace1))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+        OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNzMyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420037329", "bodyText": "add some kind of \"done\"/\"success\" log message??", "author": "markxnelson", "createdAt": "2020-05-05T11:25:26Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(TestConstants.PV_ROOT + \"/\" + domainUid + \"-persistentVolume\")))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create a MII image\")\n+  public void testCreatingMiiImage() {\n+\n+    logger.info(\"WDT model directory is {0}\", MODEL_DIR);\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    boolean success = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(IMAGE_NAME)\n+            .modelImageTag(IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(success)\n+        .as(\"Test the Docker image creation\")\n+        .withFailMessage(\"Failed to create the image using WebLogic Image Tool\")\n+        .isTrue();\n+\n+    dockerImageExists(IMAGE_NAME, IMAGE_TAG);\n+  }\n+\n+  /**\n+   * Install Operator and verify Operator is running.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Install the operator\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testInstallingOperator() {\n+\n+    String image = getOperatorImageName();\n+    assertFalse(image.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", image);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(image)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace1))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+        OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await()\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5Njk3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420396976", "bodyText": "Added.", "author": "sankarpn", "createdAt": "2020-05-05T20:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNzMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNzUyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420037522", "bodyText": "check, not checks\ncome, not are coming", "author": "markxnelson", "createdAt": "2020-05-05T11:25:51Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(TestConstants.PV_ROOT + \"/\" + domainUid + \"-persistentVolume\")))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create a MII image\")\n+  public void testCreatingMiiImage() {\n+\n+    logger.info(\"WDT model directory is {0}\", MODEL_DIR);\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    boolean success = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(IMAGE_NAME)\n+            .modelImageTag(IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(success)\n+        .as(\"Test the Docker image creation\")\n+        .withFailMessage(\"Failed to create the image using WebLogic Image Tool\")\n+        .isTrue();\n+\n+    dockerImageExists(IMAGE_NAME, IMAGE_TAG);\n+  }\n+\n+  /**\n+   * Install Operator and verify Operator is running.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Install the operator\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testInstallingOperator() {\n+\n+    String image = getOperatorImageName();\n+    assertFalse(image.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", image);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(image)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace1))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+        OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await()\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Create a simple domain and checks if pods are coming up.", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNzY2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420037663", "bodyText": "does not match the javadoc, which is it?", "author": "markxnelson", "createdAt": "2020-05-05T11:26:09Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(TestConstants.PV_ROOT + \"/\" + domainUid + \"-persistentVolume\")))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create a MII image\")\n+  public void testCreatingMiiImage() {\n+\n+    logger.info(\"WDT model directory is {0}\", MODEL_DIR);\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    boolean success = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(IMAGE_NAME)\n+            .modelImageTag(IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(success)\n+        .as(\"Test the Docker image creation\")\n+        .withFailMessage(\"Failed to create the image using WebLogic Image Tool\")\n+        .isTrue();\n+\n+    dockerImageExists(IMAGE_NAME, IMAGE_TAG);\n+  }\n+\n+  /**\n+   * Install Operator and verify Operator is running.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Install the operator\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testInstallingOperator() {\n+\n+    String image = getOperatorImageName();\n+    assertFalse(image.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", image);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(image)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace1))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+        OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await()\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Create a simple domain and checks if pods are coming up.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Create a domain\")", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5ODIxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420398210", "bodyText": "Corrected it.", "author": "sankarpn", "createdAt": "2020-05-05T20:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNzY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNzg5MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420037891", "bodyText": "ideally, do not hard code tests to a particular version of WebLogic", "author": "markxnelson", "createdAt": "2020-05-05T11:26:38Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(TestConstants.PV_ROOT + \"/\" + domainUid + \"-persistentVolume\")))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create a MII image\")\n+  public void testCreatingMiiImage() {\n+\n+    logger.info(\"WDT model directory is {0}\", MODEL_DIR);\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    boolean success = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(IMAGE_NAME)\n+            .modelImageTag(IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(success)\n+        .as(\"Test the Docker image creation\")\n+        .withFailMessage(\"Failed to create the image using WebLogic Image Tool\")\n+        .isTrue();\n+\n+    dockerImageExists(IMAGE_NAME, IMAGE_TAG);\n+  }\n+\n+  /**\n+   * Install Operator and verify Operator is running.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Install the operator\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testInstallingOperator() {\n+\n+    String image = getOperatorImageName();\n+    assertFalse(image.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", image);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(image)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace1))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+        OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await()\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Create a simple domain and checks if pods are coming up.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Create a domain\")\n+  @Slow\n+  public void testCreatingDomain() {\n+\n+    // create the domain CR\n+    V1ObjectMeta metadata = new V1ObjectMetaBuilder()\n+        .withName(domainUid)\n+        .withNamespace(domainNamespace1)\n+        .build();\n+    DomainSpec domainSpec = new DomainSpec()\n+        .domainHome(\"/shared/domains/sample-domain1\")\n+        .domainHomeInImage(false)\n+        .image(\"store/oracle/weblogic:12.2.1.3\")", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5OTE1OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420399158", "bodyText": "we will fix it when the test suite evolves, for now we use hard coded version.", "author": "sankarpn", "createdAt": "2020-05-05T20:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNzg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzODEwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420038102", "bodyText": "Failed to create domain", "author": "markxnelson", "createdAt": "2020-05-05T11:27:04Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(TestConstants.PV_ROOT + \"/\" + domainUid + \"-persistentVolume\")))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create a MII image\")\n+  public void testCreatingMiiImage() {\n+\n+    logger.info(\"WDT model directory is {0}\", MODEL_DIR);\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    boolean archiveBuilt = buildAppArchive(\n+        defaultAppParams()\n+            .srcDir(APP_NAME));\n+\n+    assertThat(archiveBuilt)\n+        .as(\"Create an app archive\")\n+        .withFailMessage(\"Failed to create app archive for \" + APP_NAME)\n+        .isTrue();\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    boolean success = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(IMAGE_NAME)\n+            .modelImageTag(IMAGE_TAG)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertThat(success)\n+        .as(\"Test the Docker image creation\")\n+        .withFailMessage(\"Failed to create the image using WebLogic Image Tool\")\n+        .isTrue();\n+\n+    dockerImageExists(IMAGE_NAME, IMAGE_TAG);\n+  }\n+\n+  /**\n+   * Install Operator and verify Operator is running.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Install the operator\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testInstallingOperator() {\n+\n+    String image = getOperatorImageName();\n+    assertFalse(image.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", image);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(image)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace1))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+        OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await()\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Create a simple domain and checks if pods are coming up.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Create a domain\")\n+  @Slow\n+  public void testCreatingDomain() {\n+\n+    // create the domain CR\n+    V1ObjectMeta metadata = new V1ObjectMetaBuilder()\n+        .withName(domainUid)\n+        .withNamespace(domainNamespace1)\n+        .build();\n+    DomainSpec domainSpec = new DomainSpec()\n+        .domainHome(\"/shared/domains/sample-domain1\")\n+        .domainHomeInImage(false)\n+        .image(\"store/oracle/weblogic:12.2.1.3\")\n+        .imagePullPolicy(\"IfNotPresent\");\n+    Domain domain = new Domain()\n+        .apiVersion(\"weblogic.oracle/v7\")\n+        .kind(\"Domain\")\n+        .metadata(metadata)\n+        .spec(domainSpec);\n+    boolean success = assertDoesNotThrow(\n+        () -> createDomainCustomResource(domain),\n+        \"Domain failed to be created, \"", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDExNjQ5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420116495", "bodyText": "FYI  - I am removing ItWitValidation.java in my PR #1616 because the content of the class (and this method) has been moved into ItMiiDomain.java for the first end-to-end test case. So I don't think we need this test method here.", "author": "doxiao", "createdAt": "2020-05-05T13:39:50Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleValidation.java", "diffHunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Simple validation of integration tests\")\n+// Every test class needs to tagged with this annotation for log collection, diagnostic messages logging\n+// and namespace creation.\n+@IntegrationTest\n+class ItSimpleValidation implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String IMAGE_NAME = \"test-mii-image-2\";\n+  private static final String IMAGE_TAG = \"v1\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  private String opNamespace = null;\n+  private String domainNamespace1 = null;\n+\n+  final String domainUid = \"domain1\";\n+  String serviceAccountName;\n+\n+  /**\n+   * Setup for test suite. Creates service account, namespace, and persistent volumes.\n+   * @param namespaces injected by Junit extension\n+   */\n+  @BeforeAll\n+  public void setup(@Namespaces(2) List<String> namespaces) {\n+\n+    // get a new unique namespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+\n+    // Create a service account for the unique namespace\n+    serviceAccountName = opNamespace + \"-sa\";\n+    V1ServiceAccount serviceAccount = assertDoesNotThrow(\n+        () -> Kubernetes.createServiceAccount(new V1ServiceAccount()\n+            .metadata(new V1ObjectMeta().namespace(opNamespace).name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccount.getMetadata().getName());\n+\n+    // create persistent volume and persistent volume claim\n+    String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+    String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvcName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolumeClaim(v1pvc),\n+        \"Persistent volume claim creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(domainUid + \"-weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(TestConstants.PV_ROOT + \"/\" + domainUid + \"-persistentVolume\")))\n+        .metadata(new V1ObjectMetaBuilder()\n+            .withName(pvName)\n+            .withNamespace(domainNamespace1)\n+            .build()\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    success = assertDoesNotThrow(\n+        () -> TestActions.createPersistentVolume(v1pv),\n+        \"Persistent volume creation failed, \"\n+        + \"look at the above console log messages for failure reason in ApiException responsebody\"\n+    );\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create a MII image\")\n+  public void testCreatingMiiImage() {", "originalCommit": "2042b50d12ceeee25e8ff932c8b1dcb9be93dc58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEyOTIzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420129237", "bodyText": "Actually, everything in this new test class are covered in ItMiiDomain.java. We could just remove ItSimpleDomainValidation.java and ItSimpleOperatorValidation.java as well, and don't need to do the consolidation.", "author": "doxiao", "createdAt": "2020-05-05T13:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDExNjQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5NjgyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1620#discussion_r420396827", "bodyText": "As we discussed in the meeting I will remove the ItWitValidation test and keep the operator and domain tests", "author": "sankarpn", "createdAt": "2020-05-05T20:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDExNjQ5NQ=="}], "type": "inlineReview"}, {"oid": "1bea8950b0dd2806b87f6446f5ebdcea56ca6635", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1bea8950b0dd2806b87f6446f5ebdcea56ca6635", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into consolidate-miitests", "committedDate": "2020-05-05T18:06:32Z", "type": "commit"}, {"oid": "2b6a094fda3f19e20a3d966475cfbced5d9be152", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2b6a094fda3f19e20a3d966475cfbced5d9be152", "message": "Address review comments", "committedDate": "2020-05-05T18:23:18Z", "type": "commit"}, {"oid": "855a23ef0c4ea56feca213dd2057dcf528796b1b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/855a23ef0c4ea56feca213dd2057dcf528796b1b", "message": "fix comment", "committedDate": "2020-05-05T18:27:18Z", "type": "commit"}, {"oid": "6e2f8ac700de5000f493a88003c4aaea5cb03a3a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6e2f8ac700de5000f493a88003c4aaea5cb03a3a", "message": "Remove ItWitValidation test", "committedDate": "2020-05-05T20:53:49Z", "type": "commit"}, {"oid": "0bf3628f1c3f877559a653f06396148c22fc5da4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0bf3628f1c3f877559a653f06396148c22fc5da4", "message": "Adding the domainNamespace1 to the list of domains under operator", "committedDate": "2020-05-06T15:22:44Z", "type": "commit"}, {"oid": "28dc8b05a44849a8a5039c1e04d8e647ad39e5d5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/28dc8b05a44849a8a5039c1e04d8e647ad39e5d5", "message": "added secret name in op params", "committedDate": "2020-05-06T15:52:39Z", "type": "commit"}]}