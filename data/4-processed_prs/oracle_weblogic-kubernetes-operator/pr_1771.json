{"pr_number": 1771, "pr_title": "Istiocdxaction", "pr_createdAt": "2020-06-26T15:36:16Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771", "timeline": [{"oid": "18bcd494dbbc35852c9e319afc305829ba7a7444", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/18bcd494dbbc35852c9e319afc305829ba7a7444", "message": "istio cross domain transaction test", "committedDate": "2020-06-24T22:00:46Z", "type": "commit"}, {"oid": "9212825124d7730e88d338a7a3671afd586a029f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9212825124d7730e88d338a7a3671afd586a029f", "message": "fix the image name for jenkins runs", "committedDate": "2020-06-25T13:58:40Z", "type": "commit"}, {"oid": "267fccd754fa3cdda1f721e30e809cadb76bf745", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/267fccd754fa3cdda1f721e30e809cadb76bf745", "message": "Fix failure when copying the app out of pod", "committedDate": "2020-06-25T22:21:54Z", "type": "commit"}, {"oid": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/37ac71b24e7146ee5c876e22fc58f98d4013a86b", "message": "sync with develop", "committedDate": "2020-06-26T15:28:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI3OTE4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446279184", "bodyText": "no more implements LoggedTest\nPlease see PR #1765\nNow you need to get logger here and initialize it in initAll method.\nprivate static LoggingFacade logger = null;", "author": "sankarpn", "createdAt": "2020-06-26T16:14:27Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction implements LoggedTest {", "originalCommit": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyNzcxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446327714", "bodyText": "yeah, sync'd a few minutes ago and was working on changing this.\ndone.", "author": "bhavaniravichandran", "createdAt": "2020-06-26T17:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI3OTE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMDUzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446310535", "bodyText": "now a simple description is good enough I guess\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               *     JUnit engine parameter resolution mechanism\n          \n          \n            \n               @param namespaces injected by JUnit", "author": "sankarpn", "createdAt": "2020-06-26T17:16:22Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *     JUnit engine parameter resolution mechanism", "originalCommit": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyNzgxMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446327812", "bodyText": "done", "author": "bhavaniravichandran", "createdAt": "2020-06-26T17:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMDUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMDgyNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446310825", "bodyText": "Need logger initialized here\nlogger = getLogger();", "author": "sankarpn", "createdAt": "2020-06-26T17:17:01Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *     JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy", "originalCommit": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyNzkxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446327910", "bodyText": "done.", "author": "bhavaniravichandran", "createdAt": "2020-06-26T17:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMDgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMTM0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446311340", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                logger.info(\"Creating unique namespace for Operator\");\n          \n          \n            \n                logger.info(\"Assigning a unique namespace for Operator\");", "author": "sankarpn", "createdAt": "2020-06-26T17:18:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *     JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    installIstio();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");", "originalCommit": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyODM2NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446328365", "bodyText": "done.", "author": "bhavaniravichandran", "createdAt": "2020-06-26T17:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMTM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMTQ3NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446311475", "bodyText": "same as above comment", "author": "sankarpn", "createdAt": "2020-06-26T17:18:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *     JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    installIstio();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");", "originalCommit": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyODQyNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446328424", "bodyText": "done", "author": "bhavaniravichandran", "createdAt": "2020-06-26T17:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMTQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMTUxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446311514", "bodyText": "same as above comment", "author": "sankarpn", "createdAt": "2020-06-26T17:18:30Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *     JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    installIstio();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain\");", "originalCommit": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyODUwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446328504", "bodyText": "done.", "author": "bhavaniravichandran", "createdAt": "2020-06-26T17:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMTUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMTYxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446311617", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Now that we got the namespaces for both the domains,w e need to update the model properties\n          \n          \n            \n                // Now that we got the namespaces for both the domains, we need to update the model properties", "author": "sankarpn", "createdAt": "2020-06-26T17:18:43Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *     JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    installIstio();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // Now that we got the namespaces for both the domains,w e need to update the model properties", "originalCommit": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyODcxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446328719", "bodyText": "fixed", "author": "bhavaniravichandran", "createdAt": "2020-06-26T17:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMTYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxNTgxMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446315811", "bodyText": "Do we need these 2 tags?", "author": "sankarpn", "createdAt": "2020-06-26T17:27:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *     JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    installIstio();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // Now that we got the namespaces for both the domains,w e need to update the model properties\n+    // file with the namespaces. for cross domain transaction to work, we need to have the externalDNSName\n+    // set in the config file. Cannot set this after the domain is up since a server restart is\n+    // required for this to take effect. So, copying the property file to RESULT_ROOT and updating the\n+    // property file\n+    updatePropertyFile();\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain1Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain2Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace, domain2Namespace);\n+\n+  }\n+\n+  private static void updatePropertyFile() {\n+    //create a temporary directory to copy and update the properties file\n+    Path target = Paths.get(PROPS_TEMP_DIR);\n+    Path source1 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN1_PROPS);\n+    Path source2 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN2_PROPS);\n+    logger.info(\"Copy the properties file to the above area so that we can add namespace property\");\n+    assertDoesNotThrow(() -> {\n+      Files.createDirectories(target);\n+      Files.copy(source1, target.resolve(source1.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+      Files.copy(source2, target.resolve(source2.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+    });\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+    });\n+\n+  }\n+\n+  private static void addNamespaceToPropertyFile(String propFileName, String domainNamespace) throws IOException {\n+    FileInputStream in = new FileInputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    Properties props = new Properties();\n+    props.load(in);\n+    in.close();\n+\n+    FileOutputStream out = new FileOutputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    props.setProperty(\"NAMESPACE\", domainNamespace);\n+    props.store(out, null);\n+    out.close();\n+  }\n+\n+  /*\n+   * This test verifies cross domain transaction is successful. domain in image using wdt is used\n+   * to create 2 domains in different namespaces. An app is deployed to both the domains and the servlet\n+   * is invoked which starts a transaction that spans both domains.\n+   */\n+  @Test\n+  @DisplayName(\"Check cross domain transaction with istio works\")\n+  @Slow\n+  @MustNotRunInParallel", "originalCommit": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMzMjgwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446332802", "bodyText": "I am going to keep it there for now. There is an issue with the istio service port number which might cause a problem if the istio tests are run in parallel. Will remove it later after that issue is resolved..", "author": "bhavaniravichandran", "createdAt": "2020-06-26T18:03:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxNTgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzY1Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r448053652", "bodyText": "@MustNotRunInParallel  tag may not help. We need find other solution such as adding host name to the istio service to provide host information in http header.", "author": "anpanigr", "createdAt": "2020-07-01T00:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxNTgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxOTg4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446319886", "bodyText": "Do you want to use java based http client?\nString url= String.format(\"\n\"http://%s:%s/TxForward/TxForward?urls=t3://%s.%s:7001,t3://%s1.%s:8001,t3://%s1.%s:8001,\"\n+ \"t3://%s2.%s:8001\",\nK8S_NODEPORT_HOST, istioIngressPort, domain1AdminServerPodName, domain1Namespace,\ndomain1ManagedServerPrefix, domain1Namespace, domain2ManagedServerPrefix,domain2Namespace,\ndomain2ManagedServerPrefix,domain2Namespace);\nHttpResponse response = assertDoesNotThrow(() -> OracleHttpClient.get(url, true));\nassertEquals(200, response.statusCode(), \"Status code not equals to 200\");\nassertTrue(response.body().contains(\"\"Status=Committed\"), \"crossDomainTransaction failed\");", "author": "sankarpn", "createdAt": "2020-06-26T17:35:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *     JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    installIstio();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // Now that we got the namespaces for both the domains,w e need to update the model properties\n+    // file with the namespaces. for cross domain transaction to work, we need to have the externalDNSName\n+    // set in the config file. Cannot set this after the domain is up since a server restart is\n+    // required for this to take effect. So, copying the property file to RESULT_ROOT and updating the\n+    // property file\n+    updatePropertyFile();\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain1Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain2Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace, domain2Namespace);\n+\n+  }\n+\n+  private static void updatePropertyFile() {\n+    //create a temporary directory to copy and update the properties file\n+    Path target = Paths.get(PROPS_TEMP_DIR);\n+    Path source1 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN1_PROPS);\n+    Path source2 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN2_PROPS);\n+    logger.info(\"Copy the properties file to the above area so that we can add namespace property\");\n+    assertDoesNotThrow(() -> {\n+      Files.createDirectories(target);\n+      Files.copy(source1, target.resolve(source1.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+      Files.copy(source2, target.resolve(source2.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+    });\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+    });\n+\n+  }\n+\n+  private static void addNamespaceToPropertyFile(String propFileName, String domainNamespace) throws IOException {\n+    FileInputStream in = new FileInputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    Properties props = new Properties();\n+    props.load(in);\n+    in.close();\n+\n+    FileOutputStream out = new FileOutputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    props.setProperty(\"NAMESPACE\", domainNamespace);\n+    props.store(out, null);\n+    out.close();\n+  }\n+\n+  /*\n+   * This test verifies cross domain transaction is successful. domain in image using wdt is used\n+   * to create 2 domains in different namespaces. An app is deployed to both the domains and the servlet\n+   * is invoked which starts a transaction that spans both domains.\n+   */\n+  @Test\n+  @DisplayName(\"Check cross domain transaction with istio works\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCrossDomainTransaction() {\n+\n+    //build application archive\n+    Path distDir = BuildApplication.buildApplication(Paths.get(APP_DIR, \"txforward\"), null, null,\n+        \"build\", domain1Namespace);\n+    logger.info(\"distDir is {0}\", distDir.toString());\n+    assertTrue(Paths.get(distDir.toString(),\n+        \"txforward.ear\").toFile().exists(),\n+        \"Application archive is not available\");\n+    String appSource = distDir.toString() + \"/txforward.ear\";\n+    logger.info(\"Application is in {0}\", appSource);\n+\n+    // create admin credential secret for domain1\n+    logger.info(\"Create admin credential secret for domain1\");\n+    String domain1AdminSecretName = domainUid1 + \"-weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        domain1AdminSecretName, domain1Namespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        String.format(\"createSecret %s failed for %s\", domain1AdminSecretName, domainUid1));\n+\n+    // create admin credential secret for domain2\n+    logger.info(\"Create admin credential secret for domain2\");\n+    String domain2AdminSecretName = domainUid2 + \"-weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        domain2AdminSecretName, domain2Namespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        String.format(\"createSecret %s failed for %s\", domain2AdminSecretName, domainUid2));\n+ \n+    logger.info(\"Creating image with model file and verify\");\n+    String domain1Image = createImageAndVerify(\n+        WDT_IMAGE_NAME1, WDT_MODEL_FILE_DOMAIN1, appSource, WDT_MODEL_DOMAIN1_PROPS, PROPS_TEMP_DIR, domainUid1);\n+    logger.info(\"Created {0} image\", domain1Image);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(domain1Image);\n+\n+    logger.info(\"Creating image with model file and verify\");\n+    String domain2Image = createImageAndVerify(\n+        WDT_IMAGE_NAME2, WDT_MODEL_FILE_DOMAIN2, appSource, WDT_MODEL_DOMAIN2_PROPS, PROPS_TEMP_DIR, domainUid2);\n+    logger.info(\"Created {0} image\", domain2Image);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(domain2Image);\n+\n+    //create domain1\n+    createDomain(domainUid1, domain1Namespace, domain1AdminSecretName, domain1Image);\n+    //create domain2\n+    createDomain(domainUid2, domain2Namespace, domain2AdminSecretName, domain2Image);\n+\n+    String clusterService = domainUid1 + \"-cluster-\" + clusterName + \".\" + domain1Namespace + \".svc.cluster.local\";\n+\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domain1Namespace);\n+    templateMap.put(\"ADMIN_SERVICE\",domain1AdminServerPodName);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService);\n+\n+    Path svcYamlSrc = Paths.get(RESOURCE_DIR, \"istio\", \"istio-cdt-http-template-service.yaml\");\n+    Path svcYmlTarget = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(svcYamlSrc.toString(),\n+            \"istiocrossdomaintransactiontemp/istio-cdt-http-service.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0}\", svcYmlTarget);\n+\n+    boolean deployRes = deployHttpIstioGatewayAndVirtualservice(svcYmlTarget);\n+    assertTrue(deployRes, \"Could not deploy Http Istio Gateway/VirtualService\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return adminNodePortAccessible(istioIngressPort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+\n+\n+    String curlRequest = String.format(\"curl -v --show-error --noproxy '*' \"\n+            + \"http://%s:%s/TxForward/TxForward?urls=t3://%s.%s:7001,t3://%s1.%s:8001,t3://%s1.%s:8001,\"\n+            + \"t3://%s2.%s:8001\",\n+             K8S_NODEPORT_HOST, istioIngressPort, domain1AdminServerPodName, domain1Namespace,\n+             domain1ManagedServerPrefix, domain1Namespace, domain2ManagedServerPrefix,domain2Namespace,\n+             domain2ManagedServerPrefix,domain2Namespace);\n+\n+    ExecResult result = null;\n+    logger.info(\"curl command {0}\", curlRequest);\n+    result = assertDoesNotThrow(\n+        () -> exec(curlRequest, true));\n+    if (result.exitValue() == 0) {\n+      logger.info(\"\\n HTTP response is \\n \" + result.stdout());\n+      logger.info(\"curl command returned {0}\", result.toString());\n+      assertTrue(result.stdout().contains(\"Status=Committed\"), \"crossDomainTransaction failed\");\n+    }", "originalCommit": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMzNjEzMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446336132", "bodyText": "changed to use the http client", "author": "bhavaniravichandran", "createdAt": "2020-06-26T18:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxOTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyMDMzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446320334", "bodyText": "we don't need the podExists checks because podReady will do both", "author": "sankarpn", "createdAt": "2020-06-26T17:36:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *     JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    installIstio();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // Now that we got the namespaces for both the domains,w e need to update the model properties\n+    // file with the namespaces. for cross domain transaction to work, we need to have the externalDNSName\n+    // set in the config file. Cannot set this after the domain is up since a server restart is\n+    // required for this to take effect. So, copying the property file to RESULT_ROOT and updating the\n+    // property file\n+    updatePropertyFile();\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain1Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain2Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace, domain2Namespace);\n+\n+  }\n+\n+  private static void updatePropertyFile() {\n+    //create a temporary directory to copy and update the properties file\n+    Path target = Paths.get(PROPS_TEMP_DIR);\n+    Path source1 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN1_PROPS);\n+    Path source2 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN2_PROPS);\n+    logger.info(\"Copy the properties file to the above area so that we can add namespace property\");\n+    assertDoesNotThrow(() -> {\n+      Files.createDirectories(target);\n+      Files.copy(source1, target.resolve(source1.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+      Files.copy(source2, target.resolve(source2.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+    });\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+    });\n+\n+  }\n+\n+  private static void addNamespaceToPropertyFile(String propFileName, String domainNamespace) throws IOException {\n+    FileInputStream in = new FileInputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    Properties props = new Properties();\n+    props.load(in);\n+    in.close();\n+\n+    FileOutputStream out = new FileOutputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    props.setProperty(\"NAMESPACE\", domainNamespace);\n+    props.store(out, null);\n+    out.close();\n+  }\n+\n+  /*\n+   * This test verifies cross domain transaction is successful. domain in image using wdt is used\n+   * to create 2 domains in different namespaces. An app is deployed to both the domains and the servlet\n+   * is invoked which starts a transaction that spans both domains.\n+   */\n+  @Test\n+  @DisplayName(\"Check cross domain transaction with istio works\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCrossDomainTransaction() {\n+\n+    //build application archive\n+    Path distDir = BuildApplication.buildApplication(Paths.get(APP_DIR, \"txforward\"), null, null,\n+        \"build\", domain1Namespace);\n+    logger.info(\"distDir is {0}\", distDir.toString());\n+    assertTrue(Paths.get(distDir.toString(),\n+        \"txforward.ear\").toFile().exists(),\n+        \"Application archive is not available\");\n+    String appSource = distDir.toString() + \"/txforward.ear\";\n+    logger.info(\"Application is in {0}\", appSource);\n+\n+    // create admin credential secret for domain1\n+    logger.info(\"Create admin credential secret for domain1\");\n+    String domain1AdminSecretName = domainUid1 + \"-weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        domain1AdminSecretName, domain1Namespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        String.format(\"createSecret %s failed for %s\", domain1AdminSecretName, domainUid1));\n+\n+    // create admin credential secret for domain2\n+    logger.info(\"Create admin credential secret for domain2\");\n+    String domain2AdminSecretName = domainUid2 + \"-weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        domain2AdminSecretName, domain2Namespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        String.format(\"createSecret %s failed for %s\", domain2AdminSecretName, domainUid2));\n+ \n+    logger.info(\"Creating image with model file and verify\");\n+    String domain1Image = createImageAndVerify(\n+        WDT_IMAGE_NAME1, WDT_MODEL_FILE_DOMAIN1, appSource, WDT_MODEL_DOMAIN1_PROPS, PROPS_TEMP_DIR, domainUid1);\n+    logger.info(\"Created {0} image\", domain1Image);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(domain1Image);\n+\n+    logger.info(\"Creating image with model file and verify\");\n+    String domain2Image = createImageAndVerify(\n+        WDT_IMAGE_NAME2, WDT_MODEL_FILE_DOMAIN2, appSource, WDT_MODEL_DOMAIN2_PROPS, PROPS_TEMP_DIR, domainUid2);\n+    logger.info(\"Created {0} image\", domain2Image);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(domain2Image);\n+\n+    //create domain1\n+    createDomain(domainUid1, domain1Namespace, domain1AdminSecretName, domain1Image);\n+    //create domain2\n+    createDomain(domainUid2, domain2Namespace, domain2AdminSecretName, domain2Image);\n+\n+    String clusterService = domainUid1 + \"-cluster-\" + clusterName + \".\" + domain1Namespace + \".svc.cluster.local\";\n+\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domain1Namespace);\n+    templateMap.put(\"ADMIN_SERVICE\",domain1AdminServerPodName);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService);\n+\n+    Path svcYamlSrc = Paths.get(RESOURCE_DIR, \"istio\", \"istio-cdt-http-template-service.yaml\");\n+    Path svcYmlTarget = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(svcYamlSrc.toString(),\n+            \"istiocrossdomaintransactiontemp/istio-cdt-http-service.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0}\", svcYmlTarget);\n+\n+    boolean deployRes = deployHttpIstioGatewayAndVirtualservice(svcYmlTarget);\n+    assertTrue(deployRes, \"Could not deploy Http Istio Gateway/VirtualService\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return adminNodePortAccessible(istioIngressPort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+\n+\n+    String curlRequest = String.format(\"curl -v --show-error --noproxy '*' \"\n+            + \"http://%s:%s/TxForward/TxForward?urls=t3://%s.%s:7001,t3://%s1.%s:8001,t3://%s1.%s:8001,\"\n+            + \"t3://%s2.%s:8001\",\n+             K8S_NODEPORT_HOST, istioIngressPort, domain1AdminServerPodName, domain1Namespace,\n+             domain1ManagedServerPrefix, domain1Namespace, domain2ManagedServerPrefix,domain2Namespace,\n+             domain2ManagedServerPrefix,domain2Namespace);\n+\n+    ExecResult result = null;\n+    logger.info(\"curl command {0}\", curlRequest);\n+    result = assertDoesNotThrow(\n+        () -> exec(curlRequest, true));\n+    if (result.exitValue() == 0) {\n+      logger.info(\"\\n HTTP response is \\n \" + result.stdout());\n+      logger.info(\"curl command returned {0}\", result.toString());\n+      assertTrue(result.stdout().contains(\"Status=Committed\"), \"crossDomainTransaction failed\");\n+    }\n+\n+  }\n+\n+  private void createDomain(String domainUid, String domainNamespace, String adminSecretName,\n+                            String domainImage) {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace);\n+\n+    // create the domain CR\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, REPO_SECRET_NAME,\n+        replicaCount, domainImage);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }", "originalCommit": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMzNjczMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446336731", "bodyText": "removed.", "author": "bhavaniravichandran", "createdAt": "2020-06-26T18:11:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyMDMzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTE0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446439149", "bodyText": "It has to be in this order.\n\nadmin service check\nadmin pod ready check\nms service check\nms pod ready check", "author": "sankarpn", "createdAt": "2020-06-26T22:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyMDMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyMDUyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446320520", "bodyText": "checkServiceExists should be done before checkPodReady", "author": "sankarpn", "createdAt": "2020-06-26T17:37:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *     JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    installIstio();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // Now that we got the namespaces for both the domains,w e need to update the model properties\n+    // file with the namespaces. for cross domain transaction to work, we need to have the externalDNSName\n+    // set in the config file. Cannot set this after the domain is up since a server restart is\n+    // required for this to take effect. So, copying the property file to RESULT_ROOT and updating the\n+    // property file\n+    updatePropertyFile();\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain1Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain2Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace, domain2Namespace);\n+\n+  }\n+\n+  private static void updatePropertyFile() {\n+    //create a temporary directory to copy and update the properties file\n+    Path target = Paths.get(PROPS_TEMP_DIR);\n+    Path source1 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN1_PROPS);\n+    Path source2 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN2_PROPS);\n+    logger.info(\"Copy the properties file to the above area so that we can add namespace property\");\n+    assertDoesNotThrow(() -> {\n+      Files.createDirectories(target);\n+      Files.copy(source1, target.resolve(source1.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+      Files.copy(source2, target.resolve(source2.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+    });\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+    });\n+\n+  }\n+\n+  private static void addNamespaceToPropertyFile(String propFileName, String domainNamespace) throws IOException {\n+    FileInputStream in = new FileInputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    Properties props = new Properties();\n+    props.load(in);\n+    in.close();\n+\n+    FileOutputStream out = new FileOutputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    props.setProperty(\"NAMESPACE\", domainNamespace);\n+    props.store(out, null);\n+    out.close();\n+  }\n+\n+  /*\n+   * This test verifies cross domain transaction is successful. domain in image using wdt is used\n+   * to create 2 domains in different namespaces. An app is deployed to both the domains and the servlet\n+   * is invoked which starts a transaction that spans both domains.\n+   */\n+  @Test\n+  @DisplayName(\"Check cross domain transaction with istio works\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCrossDomainTransaction() {\n+\n+    //build application archive\n+    Path distDir = BuildApplication.buildApplication(Paths.get(APP_DIR, \"txforward\"), null, null,\n+        \"build\", domain1Namespace);\n+    logger.info(\"distDir is {0}\", distDir.toString());\n+    assertTrue(Paths.get(distDir.toString(),\n+        \"txforward.ear\").toFile().exists(),\n+        \"Application archive is not available\");\n+    String appSource = distDir.toString() + \"/txforward.ear\";\n+    logger.info(\"Application is in {0}\", appSource);\n+\n+    // create admin credential secret for domain1\n+    logger.info(\"Create admin credential secret for domain1\");\n+    String domain1AdminSecretName = domainUid1 + \"-weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        domain1AdminSecretName, domain1Namespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        String.format(\"createSecret %s failed for %s\", domain1AdminSecretName, domainUid1));\n+\n+    // create admin credential secret for domain2\n+    logger.info(\"Create admin credential secret for domain2\");\n+    String domain2AdminSecretName = domainUid2 + \"-weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        domain2AdminSecretName, domain2Namespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        String.format(\"createSecret %s failed for %s\", domain2AdminSecretName, domainUid2));\n+ \n+    logger.info(\"Creating image with model file and verify\");\n+    String domain1Image = createImageAndVerify(\n+        WDT_IMAGE_NAME1, WDT_MODEL_FILE_DOMAIN1, appSource, WDT_MODEL_DOMAIN1_PROPS, PROPS_TEMP_DIR, domainUid1);\n+    logger.info(\"Created {0} image\", domain1Image);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(domain1Image);\n+\n+    logger.info(\"Creating image with model file and verify\");\n+    String domain2Image = createImageAndVerify(\n+        WDT_IMAGE_NAME2, WDT_MODEL_FILE_DOMAIN2, appSource, WDT_MODEL_DOMAIN2_PROPS, PROPS_TEMP_DIR, domainUid2);\n+    logger.info(\"Created {0} image\", domain2Image);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(domain2Image);\n+\n+    //create domain1\n+    createDomain(domainUid1, domain1Namespace, domain1AdminSecretName, domain1Image);\n+    //create domain2\n+    createDomain(domainUid2, domain2Namespace, domain2AdminSecretName, domain2Image);\n+\n+    String clusterService = domainUid1 + \"-cluster-\" + clusterName + \".\" + domain1Namespace + \".svc.cluster.local\";\n+\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domain1Namespace);\n+    templateMap.put(\"ADMIN_SERVICE\",domain1AdminServerPodName);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService);\n+\n+    Path svcYamlSrc = Paths.get(RESOURCE_DIR, \"istio\", \"istio-cdt-http-template-service.yaml\");\n+    Path svcYmlTarget = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(svcYamlSrc.toString(),\n+            \"istiocrossdomaintransactiontemp/istio-cdt-http-service.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0}\", svcYmlTarget);\n+\n+    boolean deployRes = deployHttpIstioGatewayAndVirtualservice(svcYmlTarget);\n+    assertTrue(deployRes, \"Could not deploy Http Istio Gateway/VirtualService\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return adminNodePortAccessible(istioIngressPort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+\n+\n+    String curlRequest = String.format(\"curl -v --show-error --noproxy '*' \"\n+            + \"http://%s:%s/TxForward/TxForward?urls=t3://%s.%s:7001,t3://%s1.%s:8001,t3://%s1.%s:8001,\"\n+            + \"t3://%s2.%s:8001\",\n+             K8S_NODEPORT_HOST, istioIngressPort, domain1AdminServerPodName, domain1Namespace,\n+             domain1ManagedServerPrefix, domain1Namespace, domain2ManagedServerPrefix,domain2Namespace,\n+             domain2ManagedServerPrefix,domain2Namespace);\n+\n+    ExecResult result = null;\n+    logger.info(\"curl command {0}\", curlRequest);\n+    result = assertDoesNotThrow(\n+        () -> exec(curlRequest, true));\n+    if (result.exitValue() == 0) {\n+      logger.info(\"\\n HTTP response is \\n \" + result.stdout());\n+      logger.info(\"curl command returned {0}\", result.toString());\n+      assertTrue(result.stdout().contains(\"Status=Committed\"), \"crossDomainTransaction failed\");\n+    }\n+\n+  }\n+\n+  private void createDomain(String domainUid, String domainNamespace, String adminSecretName,\n+                            String domainImage) {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace);\n+\n+    // create the domain CR\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, REPO_SECRET_NAME,\n+        replicaCount, domainImage);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }", "originalCommit": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMzNjg1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446336854", "bodyText": "moved it up.", "author": "bhavaniravichandran", "createdAt": "2020-06-26T18:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyMDUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyMDY2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446320660", "bodyText": "remove commented code", "author": "sankarpn", "createdAt": "2020-06-26T17:37:33Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,426 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction implements LoggedTest {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *     JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    installIstio();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // Now that we got the namespaces for both the domains,w e need to update the model properties\n+    // file with the namespaces. for cross domain transaction to work, we need to have the externalDNSName\n+    // set in the config file. Cannot set this after the domain is up since a server restart is\n+    // required for this to take effect. So, copying the property file to RESULT_ROOT and updating the\n+    // property file\n+    updatePropertyFile();\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain1Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain2Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace, domain2Namespace);\n+\n+  }\n+\n+  private static void updatePropertyFile() {\n+    //create a temporary directory to copy and update the properties file\n+    Path target = Paths.get(PROPS_TEMP_DIR);\n+    Path source1 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN1_PROPS);\n+    Path source2 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN2_PROPS);\n+    logger.info(\"Copy the properties file to the above area so that we can add namespace property\");\n+    assertDoesNotThrow(() -> {\n+      Files.createDirectories(target);\n+      Files.copy(source1, target.resolve(source1.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+      Files.copy(source2, target.resolve(source2.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+    });\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+    });\n+\n+  }\n+\n+  private static void addNamespaceToPropertyFile(String propFileName, String domainNamespace) throws IOException {\n+    FileInputStream in = new FileInputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    Properties props = new Properties();\n+    props.load(in);\n+    in.close();\n+\n+    FileOutputStream out = new FileOutputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    props.setProperty(\"NAMESPACE\", domainNamespace);\n+    props.store(out, null);\n+    out.close();\n+  }\n+\n+  /*\n+   * This test verifies cross domain transaction is successful. domain in image using wdt is used\n+   * to create 2 domains in different namespaces. An app is deployed to both the domains and the servlet\n+   * is invoked which starts a transaction that spans both domains.\n+   */\n+  @Test\n+  @DisplayName(\"Check cross domain transaction with istio works\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCrossDomainTransaction() {\n+\n+    //build application archive\n+    Path distDir = BuildApplication.buildApplication(Paths.get(APP_DIR, \"txforward\"), null, null,\n+        \"build\", domain1Namespace);\n+    logger.info(\"distDir is {0}\", distDir.toString());\n+    assertTrue(Paths.get(distDir.toString(),\n+        \"txforward.ear\").toFile().exists(),\n+        \"Application archive is not available\");\n+    String appSource = distDir.toString() + \"/txforward.ear\";\n+    logger.info(\"Application is in {0}\", appSource);\n+\n+    // create admin credential secret for domain1\n+    logger.info(\"Create admin credential secret for domain1\");\n+    String domain1AdminSecretName = domainUid1 + \"-weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        domain1AdminSecretName, domain1Namespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        String.format(\"createSecret %s failed for %s\", domain1AdminSecretName, domainUid1));\n+\n+    // create admin credential secret for domain2\n+    logger.info(\"Create admin credential secret for domain2\");\n+    String domain2AdminSecretName = domainUid2 + \"-weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        domain2AdminSecretName, domain2Namespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        String.format(\"createSecret %s failed for %s\", domain2AdminSecretName, domainUid2));\n+ \n+    logger.info(\"Creating image with model file and verify\");\n+    String domain1Image = createImageAndVerify(\n+        WDT_IMAGE_NAME1, WDT_MODEL_FILE_DOMAIN1, appSource, WDT_MODEL_DOMAIN1_PROPS, PROPS_TEMP_DIR, domainUid1);\n+    logger.info(\"Created {0} image\", domain1Image);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(domain1Image);\n+\n+    logger.info(\"Creating image with model file and verify\");\n+    String domain2Image = createImageAndVerify(\n+        WDT_IMAGE_NAME2, WDT_MODEL_FILE_DOMAIN2, appSource, WDT_MODEL_DOMAIN2_PROPS, PROPS_TEMP_DIR, domainUid2);\n+    logger.info(\"Created {0} image\", domain2Image);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(domain2Image);\n+\n+    //create domain1\n+    createDomain(domainUid1, domain1Namespace, domain1AdminSecretName, domain1Image);\n+    //create domain2\n+    createDomain(domainUid2, domain2Namespace, domain2AdminSecretName, domain2Image);\n+\n+    String clusterService = domainUid1 + \"-cluster-\" + clusterName + \".\" + domain1Namespace + \".svc.cluster.local\";\n+\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domain1Namespace);\n+    templateMap.put(\"ADMIN_SERVICE\",domain1AdminServerPodName);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService);\n+\n+    Path svcYamlSrc = Paths.get(RESOURCE_DIR, \"istio\", \"istio-cdt-http-template-service.yaml\");\n+    Path svcYmlTarget = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(svcYamlSrc.toString(),\n+            \"istiocrossdomaintransactiontemp/istio-cdt-http-service.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0}\", svcYmlTarget);\n+\n+    boolean deployRes = deployHttpIstioGatewayAndVirtualservice(svcYmlTarget);\n+    assertTrue(deployRes, \"Could not deploy Http Istio Gateway/VirtualService\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return adminNodePortAccessible(istioIngressPort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+\n+\n+    String curlRequest = String.format(\"curl -v --show-error --noproxy '*' \"\n+            + \"http://%s:%s/TxForward/TxForward?urls=t3://%s.%s:7001,t3://%s1.%s:8001,t3://%s1.%s:8001,\"\n+            + \"t3://%s2.%s:8001\",\n+             K8S_NODEPORT_HOST, istioIngressPort, domain1AdminServerPodName, domain1Namespace,\n+             domain1ManagedServerPrefix, domain1Namespace, domain2ManagedServerPrefix,domain2Namespace,\n+             domain2ManagedServerPrefix,domain2Namespace);\n+\n+    ExecResult result = null;\n+    logger.info(\"curl command {0}\", curlRequest);\n+    result = assertDoesNotThrow(\n+        () -> exec(curlRequest, true));\n+    if (result.exitValue() == 0) {\n+      logger.info(\"\\n HTTP response is \\n \" + result.stdout());\n+      logger.info(\"curl command returned {0}\", result.toString());\n+      assertTrue(result.stdout().contains(\"Status=Committed\"), \"crossDomainTransaction failed\");\n+    }\n+\n+  }\n+\n+  private void createDomain(String domainUid, String domainNamespace, String adminSecretName,\n+                            String domainImage) {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace);\n+\n+    // create the domain CR\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, REPO_SECRET_NAME,\n+        replicaCount, domainImage);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    /*\n+    logger.info(\"Getting node port\");\n+    int serviceNodePort = assertDoesNotThrow(() -> getServiceNodePort(domainNamespace,\n+        adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+\n+     */", "originalCommit": "37ac71b24e7146ee5c876e22fc58f98d4013a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMzNjkzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r446336937", "bodyText": "deleted", "author": "bhavaniravichandran", "createdAt": "2020-06-26T18:12:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyMDY2MA=="}], "type": "inlineReview"}, {"oid": "7b25b5a0e3ab714b7bb28fd9f2d83cc3aad25753", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7b25b5a0e3ab714b7bb28fd9f2d83cc3aad25753", "message": "commenting admin console access", "committedDate": "2020-06-26T17:41:12Z", "type": "commit"}, {"oid": "21ddae82b65c4cb32d6677443e6736e5928786fc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/21ddae82b65c4cb32d6677443e6736e5928786fc", "message": "updates after sankar's review comments", "committedDate": "2020-06-26T20:28:42Z", "type": "commit"}, {"oid": "e18c9985f86753d21fbd0411b05fe6f566042449", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e18c9985f86753d21fbd0411b05fe6f566042449", "message": "one more change requested by Sankar", "committedDate": "2020-06-26T22:59:53Z", "type": "commit"}, {"oid": "4c098534cc5b4fc63780bc36f3a2c917a8facb1f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4c098534cc5b4fc63780bc36f3a2c917a8facb1f", "message": "retry console login due to failure in Kind clsuter", "committedDate": "2020-06-29T22:00:18Z", "type": "commit"}, {"oid": "eb916d494a5f798e7820d779218261c4d89e0dd1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/eb916d494a5f798e7820d779218261c4d89e0dd1", "message": "add debug", "committedDate": "2020-06-30T15:04:41Z", "type": "commit"}, {"oid": "5ff2d0f6755a9bfe1784501c172c49f938d84712", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5ff2d0f6755a9bfe1784501c172c49f938d84712", "message": "adding username/pwd to curl command", "committedDate": "2020-06-30T16:43:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAxNzkyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r448017929", "bodyText": "Remove, please.", "author": "rjeberhard", "createdAt": "2020-06-30T22:38:01Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+//import java.net.http.HttpResponse;", "originalCommit": "5ff2d0f6755a9bfe1784501c172c49f938d84712", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NDkxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r448044913", "bodyText": "removed.", "author": "bhavaniravichandran", "createdAt": "2020-07-01T00:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAxNzkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAxODczNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r448018736", "bodyText": "Please remove any unnecessary code.", "author": "rjeberhard", "createdAt": "2020-06-30T22:40:37Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,422 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+//import java.net.http.HttpResponse;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+//import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+//import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+//import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+//import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    installIstio();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // Now that we got the namespaces for both the domains, we need to update the model properties\n+    // file with the namespaces. for cross domain transaction to work, we need to have the externalDNSName\n+    // set in the config file. Cannot set this after the domain is up since a server restart is\n+    // required for this to take effect. So, copying the property file to RESULT_ROOT and updating the\n+    // property file\n+    updatePropertyFile();\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain1Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain2Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace, domain2Namespace);\n+\n+  }\n+\n+  private static void updatePropertyFile() {\n+    //create a temporary directory to copy and update the properties file\n+    Path target = Paths.get(PROPS_TEMP_DIR);\n+    Path source1 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN1_PROPS);\n+    Path source2 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN2_PROPS);\n+    logger.info(\"Copy the properties file to the above area so that we can add namespace property\");\n+    assertDoesNotThrow(() -> {\n+      Files.createDirectories(target);\n+      Files.copy(source1, target.resolve(source1.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+      Files.copy(source2, target.resolve(source2.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+    });\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+    });\n+\n+  }\n+\n+  private static void addNamespaceToPropertyFile(String propFileName, String domainNamespace) throws IOException {\n+    FileInputStream in = new FileInputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    Properties props = new Properties();\n+    props.load(in);\n+    in.close();\n+\n+    FileOutputStream out = new FileOutputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    props.setProperty(\"NAMESPACE\", domainNamespace);\n+    props.store(out, null);\n+    out.close();\n+  }\n+\n+  /*\n+   * This test verifies cross domain transaction is successful. domain in image using wdt is used\n+   * to create 2 domains in different namespaces. An app is deployed to both the domains and the servlet\n+   * is invoked which starts a transaction that spans both domains.\n+   */\n+  @Test\n+  @DisplayName(\"Check cross domain transaction with istio works\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCrossDomainTransaction() {\n+\n+    //build application archive\n+    Path distDir = BuildApplication.buildApplication(Paths.get(APP_DIR, \"txforward\"), null, null,\n+        \"build\", domain1Namespace);\n+    logger.info(\"distDir is {0}\", distDir.toString());\n+    assertTrue(Paths.get(distDir.toString(),\n+        \"txforward.ear\").toFile().exists(),\n+        \"Application archive is not available\");\n+    String appSource = distDir.toString() + \"/txforward.ear\";\n+    logger.info(\"Application is in {0}\", appSource);\n+\n+    // create admin credential secret for domain1\n+    logger.info(\"Create admin credential secret for domain1\");\n+    String domain1AdminSecretName = domainUid1 + \"-weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        domain1AdminSecretName, domain1Namespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        String.format(\"createSecret %s failed for %s\", domain1AdminSecretName, domainUid1));\n+\n+    // create admin credential secret for domain2\n+    logger.info(\"Create admin credential secret for domain2\");\n+    String domain2AdminSecretName = domainUid2 + \"-weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(\n+        domain2AdminSecretName, domain2Namespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT),\n+        String.format(\"createSecret %s failed for %s\", domain2AdminSecretName, domainUid2));\n+ \n+    logger.info(\"Creating image with model file and verify\");\n+    String domain1Image = createImageAndVerify(\n+        WDT_IMAGE_NAME1, WDT_MODEL_FILE_DOMAIN1, appSource, WDT_MODEL_DOMAIN1_PROPS, PROPS_TEMP_DIR, domainUid1);\n+    logger.info(\"Created {0} image\", domain1Image);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(domain1Image);\n+\n+    logger.info(\"Creating image with model file and verify\");\n+    String domain2Image = createImageAndVerify(\n+        WDT_IMAGE_NAME2, WDT_MODEL_FILE_DOMAIN2, appSource, WDT_MODEL_DOMAIN2_PROPS, PROPS_TEMP_DIR, domainUid2);\n+    logger.info(\"Created {0} image\", domain2Image);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(domain2Image);\n+\n+    //create domain1\n+    createDomain(domainUid1, domain1Namespace, domain1AdminSecretName, domain1Image);\n+    //create domain2\n+    createDomain(domainUid2, domain2Namespace, domain2AdminSecretName, domain2Image);\n+\n+    String clusterService = domainUid1 + \"-cluster-\" + clusterName + \".\" + domain1Namespace + \".svc.cluster.local\";\n+\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domain1Namespace);\n+    templateMap.put(\"ADMIN_SERVICE\",domain1AdminServerPodName);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService);\n+\n+    Path svcYamlSrc = Paths.get(RESOURCE_DIR, \"istio\", \"istio-cdt-http-template-service.yaml\");\n+    Path svcYmlTarget = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(svcYamlSrc.toString(),\n+            \"istiocrossdomaintransactiontemp/istio-cdt-http-service.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0}\", svcYmlTarget);\n+\n+    boolean deployRes = deployHttpIstioGatewayAndVirtualservice(svcYmlTarget);\n+    assertTrue(deployRes, \"Could not deploy Http Istio Gateway/VirtualService\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    /*", "originalCommit": "5ff2d0f6755a9bfe1784501c172c49f938d84712", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NDg3OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r448044879", "bodyText": "done.", "author": "bhavaniravichandran", "createdAt": "2020-07-01T00:05:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAxODczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAxODk1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r448018954", "bodyText": "Please remove extra spaces", "author": "rjeberhard", "createdAt": "2020-06-30T22:41:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -30,10 +33,13 @@\n import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.isPodReady;\n import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.isPodRestarted;\n import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+", "originalCommit": "5ff2d0f6755a9bfe1784501c172c49f938d84712", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NDk1MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r448044950", "bodyText": "removed", "author": "bhavaniravichandran", "createdAt": "2020-07-01T00:06:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAxODk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NTc3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r448045777", "bodyText": "I was trying to get the test to pass on Kind cluster and tried to see if retry works. Didn't want to remove the commented code till I found the solution. Finally passed in kind cluster. So, removed all commented code.", "author": "bhavaniravichandran", "createdAt": "2020-07-01T00:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAxODk1NA=="}], "type": "inlineReview"}, {"oid": "76f6a8b6ce0ed6553c462ebc18d1fde03237c3ad", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/76f6a8b6ce0ed6553c462ebc18d1fde03237c3ad", "message": "removing commented code", "committedDate": "2020-07-01T00:05:07Z", "type": "commit"}, {"oid": "198a32d6d7e29f93ef9884bf77523e7be6ef20a4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/198a32d6d7e29f93ef9884bf77523e7be6ef20a4", "message": "revisiting change to run in Kind cluster", "committedDate": "2020-07-01T18:17:31Z", "type": "commit"}, {"oid": "360b5a8d203d3d69b201fa613e2d82d2d0ebe8e0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/360b5a8d203d3d69b201fa613e2d82d2d0ebe8e0", "message": "removing commented code", "committedDate": "2020-07-02T14:49:00Z", "type": "commit"}, {"oid": "262ded60bdfcb08933ed1f768074ffa79eae6108", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/262ded60bdfcb08933ed1f768074ffa79eae6108", "message": "sync from develop", "committedDate": "2020-07-02T15:07:30Z", "type": "commit"}, {"oid": "a44f07e7010c806def976d907f4931472f199bb5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a44f07e7010c806def976d907f4931472f199bb5", "message": "sync develop after Pani's PR merge", "committedDate": "2020-07-02T16:19:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjY1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r449136659", "bodyText": "Missing Host information", "author": "anpanigr", "createdAt": "2020-07-02T16:30:59Z", "path": "new-integration-tests/src/test/resources/istio/istio-cdt-http-template-service.yaml", "diffHunk": "@@ -0,0 +1,52 @@\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+apiVersion: networking.istio.io/v1alpha3\n+kind: Gateway\n+metadata:\n+  name: istio-cdt-http-gateway\n+  namespace: NAMESPACE\n+spec:\n+  selector:\n+    istio: ingressgateway\n+  servers:\n+    - hosts:\n+        - '*'", "originalCommit": "a44f07e7010c806def976d907f4931472f199bb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1MDcxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r449150710", "bodyText": "added", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:56:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjY1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1MTM4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r449151389", "bodyText": "added", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNzgyOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r449137828", "bodyText": "Do you need this uri prefix ?  You are not using any REST API to configure domain", "author": "anpanigr", "createdAt": "2020-07-02T16:32:53Z", "path": "new-integration-tests/src/test/resources/istio/istio-cdt-http-template-service.yaml", "diffHunk": "@@ -0,0 +1,52 @@\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+apiVersion: networking.istio.io/v1alpha3\n+kind: Gateway\n+metadata:\n+  name: istio-cdt-http-gateway\n+  namespace: NAMESPACE\n+spec:\n+  selector:\n+    istio: ingressgateway\n+  servers:\n+    - hosts:\n+        - '*'\n+      port:\n+        name: http\n+        number: 80\n+        protocol: HTTP\n+---\n+apiVersion: networking.istio.io/v1alpha3\n+kind: VirtualService\n+metadata:\n+  name: istio-cdt-http-virtualservice\n+  namespace: NAMESPACE\n+spec:\n+  gateways:\n+    - istio-cdt-http-gateway\n+  hosts:\n+    - 'domain1-NAMESPACE.org'\n+  http:\n+    - match:\n+        - uri:\n+            prefix: /console\n+        - uri:", "originalCommit": "a44f07e7010c806def976d907f4931472f199bb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MzQ5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r449143490", "bodyText": "you mean the management prefix. I guess not. Will remove it.", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNzgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MDQyNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r449140424", "bodyText": "This is the only difference between this template and existing istio-http-template.yaml. We can make the application prefix as replaceable and use the same template", "author": "anpanigr", "createdAt": "2020-07-02T16:37:23Z", "path": "new-integration-tests/src/test/resources/istio/istio-cdt-http-template-service.yaml", "diffHunk": "@@ -0,0 +1,52 @@\n+# Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+apiVersion: networking.istio.io/v1alpha3\n+kind: Gateway\n+metadata:\n+  name: istio-cdt-http-gateway\n+  namespace: NAMESPACE\n+spec:\n+  selector:\n+    istio: ingressgateway\n+  servers:\n+    - hosts:\n+        - '*'\n+      port:\n+        name: http\n+        number: 80\n+        protocol: HTTP\n+---\n+apiVersion: networking.istio.io/v1alpha3\n+kind: VirtualService\n+metadata:\n+  name: istio-cdt-http-virtualservice\n+  namespace: NAMESPACE\n+spec:\n+  gateways:\n+    - istio-cdt-http-gateway\n+  hosts:\n+    - 'domain1-NAMESPACE.org'\n+  http:\n+    - match:\n+        - uri:\n+            prefix: /console\n+        - uri:\n+            prefix: /management\n+        - uri:\n+            prefix: /TxForward\n+        - port: 7001\n+      route:\n+        - destination:\n+            host: ADMIN_SERVICE\n+            port:\n+              number: 7001\n+\n+    - match:\n+        - uri:\n+            prefix: /TxForward", "originalCommit": "a44f07e7010c806def976d907f4931472f199bb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0NDQyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r449144429", "bodyText": "I also want to prefix my hostname with the domain name and namespace - not to have conflicts later - if we have 2 domains in the same namespace.", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:44:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MDQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0NjE3Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r449146172", "bodyText": "Also, I have to deploy my app to the AS as well.", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MDQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1MDg4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r449150889", "bodyText": "Keeping it separate for now.", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MDQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1NDI4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r449154285", "bodyText": "Keeping it separate for now.", "author": "bhavaniravichandran", "createdAt": "2020-07-02T17:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MDQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTU4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r449141585", "bodyText": "The testname should be modified to testIstioCrossDomainTransaction()\nThe description does not refers to ISTIO\nThe description should give more details about the transaction with description of control flow inside the application. This is the only document we refers when the test fails.\nFor example\n\nConfigure two WebLogic Domain(s) with  following transnational resources.\nStart a 2PC transaction\nEnlist a JDBC/JMS Resources from a Server on domain1\nEnlist a another transnational resource from domain2\nCommit the Transaction", "author": "anpanigr", "createdAt": "2020-07-02T16:39:36Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioCrossDomainTransaction.java", "diffHunk": "@@ -0,0 +1,398 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.BuildApplication;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify cross domain transaction with istio enabled is successful\")\n+@IntegrationTest\n+public class ItIstioCrossDomainTransaction {\n+\n+  private static final String WDT_MODEL_FILE_DOMAIN1 = \"model-crossdomaintransaction-domain1.yaml\";\n+  private static final String WDT_MODEL_FILE_DOMAIN2 = \"model-crossdomaintransaction-domain2.yaml\";\n+\n+  private static final String WDT_MODEL_DOMAIN1_PROPS = \"model-crossdomaintransaction-domain1.properties\";\n+  private static final String WDT_MODEL_DOMAIN2_PROPS = \"model-crossdomaintransaction-domain2.properties\";\n+  private static final String WDT_IMAGE_NAME1 = \"domain1-wdt-image\";\n+  private static final String WDT_IMAGE_NAME2 = \"domain2-wdt-image\";\n+  private static final String WDT_APP_NAME = \"txforward\";\n+  private static final String PROPS_TEMP_DIR = RESULTS_ROOT + \"/istiocrossdomaintransactiontemp\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid1 = \"domain1\";\n+  private String domainUid2 = \"domain2\";\n+  private static Map<String, Object> secretNameMap;\n+  private final String domain1AdminServerPodName = domainUid1 + \"-admin-server\";\n+  private final String domain1ManagedServerPrefix = domainUid1 + \"-managed-server\";\n+  private final String domain2ManagedServerPrefix = domainUid2 + \"-managed-server\";\n+  private String clusterName = \"cluster-1\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // Now that we got the namespaces for both the domains, we need to update the model properties\n+    // file with the namespaces. for cross domain transaction to work, we need to have the externalDNSName\n+    // set in the config file. Cannot set this after the domain is up since a server restart is\n+    // required for this to take effect. So, copying the property file to RESULT_ROOT and updating the\n+    // property file\n+    updatePropertyFile();\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain1Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domain2Namespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace, domain2Namespace);\n+\n+  }\n+\n+  private static void updatePropertyFile() {\n+    //create a temporary directory to copy and update the properties file\n+    Path target = Paths.get(PROPS_TEMP_DIR);\n+    Path source1 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN1_PROPS);\n+    Path source2 = Paths.get(MODEL_DIR, WDT_MODEL_DOMAIN2_PROPS);\n+    logger.info(\"Copy the properties file to the above area so that we can add namespace property\");\n+    assertDoesNotThrow(() -> {\n+      Files.createDirectories(target);\n+      Files.copy(source1, target.resolve(source1.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+      Files.copy(source2, target.resolve(source2.getFileName()), StandardCopyOption.REPLACE_EXISTING);\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN1_PROPS, domain1Namespace);\n+    });\n+    assertDoesNotThrow(() -> {\n+      addNamespaceToPropertyFile(WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+      String.format(\"Failed to update %s with namespace %s\",\n+            WDT_MODEL_DOMAIN2_PROPS, domain2Namespace);\n+    });\n+\n+  }\n+\n+  private static void addNamespaceToPropertyFile(String propFileName, String domainNamespace) throws IOException {\n+    FileInputStream in = new FileInputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    Properties props = new Properties();\n+    props.load(in);\n+    in.close();\n+\n+    FileOutputStream out = new FileOutputStream(PROPS_TEMP_DIR + \"/\" + propFileName);\n+    props.setProperty(\"NAMESPACE\", domainNamespace);\n+    props.store(out, null);\n+    out.close();\n+  }\n+\n+  /*\n+   * This test verifies cross domain transaction is successful. domain in image using wdt is used", "originalCommit": "a44f07e7010c806def976d907f4931472f199bb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1NDQ5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1771#discussion_r449154490", "bodyText": "Changed the test name and added more description", "author": "bhavaniravichandran", "createdAt": "2020-07-02T17:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTU4NQ=="}], "type": "inlineReview"}, {"oid": "02f1f670d76ec11992894d2bf5a1d3ddf59b9dac", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/02f1f670d76ec11992894d2bf5a1d3ddf59b9dac", "message": "update after review comments", "committedDate": "2020-07-02T17:02:03Z", "type": "commit"}]}