{"pr_number": 2106, "pr_title": "OWLS 86406: WKO - scaling with webhook invoked from Prometheus not working", "pr_createdAt": "2020-12-16T20:31:10Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106", "timeline": [{"oid": "812cd09562a09e4833f9319f3ef2589c9c84f3fe", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/812cd09562a09e4833f9319f3ef2589c9c84f3fe", "message": "Update scalingAction.sh to use jq command line tool, if present", "committedDate": "2020-12-11T22:04:31Z", "type": "commit"}, {"oid": "76f4993277bf1ee427898baa015f07368e422e9f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/76f4993277bf1ee427898baa015f07368e422e9f", "message": "update jq usage and use openssl to create certificate for internal REST", "committedDate": "2020-12-15T20:31:14Z", "type": "commit"}, {"oid": "cf1cfa1952998fed290570f57a216467012c33ae", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cf1cfa1952998fed290570f57a216467012c33ae", "message": "Merge remote-tracking branch 'origin/develop' into OWLS-86406\n\nMerge latest from develop", "committedDate": "2020-12-15T21:16:10Z", "type": "commit"}, {"oid": "8097361cb8cd6bb14db695cf8899471cc2a21a65", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8097361cb8cd6bb14db695cf8899471cc2a21a65", "message": "refactor scalingAction.sh script", "committedDate": "2020-12-16T05:51:42Z", "type": "commit"}, {"oid": "b575072b0e55d2876ec13c705df8fcad90c025da", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b575072b0e55d2876ec13c705df8fcad90c025da", "message": "Add comments", "committedDate": "2020-12-16T17:16:37Z", "type": "commit"}, {"oid": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/248e0bdaa28ada8e8ade9b5925ed6afedf77c44f", "message": "Add comment about openssl for OL8-slim only", "committedDate": "2020-12-16T17:25:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYxOTE5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r544619197", "bodyText": "Should this take into account 'min replicas' when minimum replicas is enabled?", "author": "tbarnes-us", "createdAt": "2020-12-16T20:59:45Z", "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -2,24 +2,272 @@\n # Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n # Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n \n-echo \"called scalingAction.sh\" >> scalingAction.log\n+currdate=`date`\n+\n+echo \"### $currdate ###\" >> scalingAction.log\n \n # script parameters\n-scaling_action=\"\"\n-wls_domain_uid=\"\"\n-wls_cluster_name=\"\"\n-wls_domain_namespace=\"default\"\n+scaling_action=\"scaleUp\"\n+wls_domain_uid=\"sample-domain1\"\n+wls_cluster_name=\"cluster-1\"\n+wls_domain_namespace=\"sample-domain1-ns\"\n operator_service_name=\"internal-weblogic-operator-svc\"\n-operator_namespace=\"weblogic-operator\"\n-operator_service_account=\"weblogic-operator\"\n+operator_namespace=\"sample-weblogic-operator-ns\"\n+operator_service_account=\"sample-weblogic-operator-sa\"\n scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  echo \"scaling_action: $scaling_action\" >> scalingAction.log\n+  echo \"wls_domain_uid: $wls_domain_uid\" >> scalingAction.log\n+  echo \"wls_cluster_name: $wls_cluster_name\" >> scalingAction.log\n+  echo \"wls_domain_namespace: $wls_domain_namespace\" >> scalingAction.log\n+  echo \"operator_service_name: $operator_service_name\" >> scalingAction.log\n+  echo \"operator_service_account: $operator_service_account\" >> scalingAction.log\n+  echo \"operator_namespace: $operator_namespace\" >> scalingAction.log\n+  echo \"scaling_size: $scaling_size\" >> scalingAction.log\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl -v --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    echo \"$currdate Failed to retrieve status of $operator_service_name in name space: $operator_namespace\" >> scalingAction.log\n+    echo \"$currdate STATUS: $STATUS\" >> scalingAction.log\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=`curl -v --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" -X GET $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle`\n+  if [ $? -ne 0 ]\n+    then\n+      echo \"$currdate Failed to retrieve Custom Resource Definition for WebLogic domain\" >> scalingAction.log\n+      echo \"$currdate CRD: $CRD\" >> scalingAction.log\n+      exit 1\n+  fi\n+\n+# Find domain version\n+  local domain_api_version\n+  if [ -x \"$(command -v jq)\" ]; then\n+    domain_api_version=$(echo \"${CRD}\" | jq -r '.spec.version')\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+print(json.load(sys.stdin)[\"spec\"][\"version\"])\n+INPUT\n+domain_api_version=`echo ${CRD} | python cmds-$$.py`\n+  fi\n+  echo \"$domain_api_version\"\n+}\n+\n+# Retrieve Custom Resource Domain\n+function get_custom_resource_domain() {\n+  local DOMAIN=`curl -v --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" $kubernetes_master/apis/weblogic.oracle/$domain_api_version/namespaces/$wls_domain_namespace/domains/$domain_uid`\n+  if [ $? -ne 0 ]; then\n+    echo \"$currdate Failed to retrieve WebLogic Domain Custom Resource Definition\" >> scalingAction.log\n+    exit 1\n+  fi\n+  echo \"$DOMAIN\"\n+}\n+\n+# Verify if cluster is defined in clusters of the Custom Resource Domain\n+# args:\n+# $1 Custom Resource Domain\n+function is_defined_in_clusters() {\n+  local DOMAIN=\"$1\"\n+  local in_cluster_startup=\"False\"\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local inClusterStartupCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\"))\"\n+    local clusterDefinedInCRD=$(echo \"${DOMAIN}\" | jq \"${inClusterStartupCmd}\")\n+    if [ \"${clusterDefinedInCRD}\" != \"\" ]; then\n+      in_cluster_startup=\"True\"\n+    fi\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+outer_loop_must_break = False\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      outer_loop_must_break = True\n+      print True\n+      break\n+if outer_loop_must_break == False:\n+  print False\n+INPUT\n+in_cluster_startup=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+  echo \"$in_cluster_startup\"\n+}\n+\n+# Gets the current replica count of the cluster\n+function get_num_ms_in_cluster() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+  local numManagedServersCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\") | .replicas)\"\n+  num_ms=$(echo \"${DOMAIN}\" | jq \"${numManagedServersCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      print j[index][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+# Gets the replica count at the Domain level\n+function get_num_ms_domain_scope() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+    num_ms=$(echo \"${DOMAIN}\" | jq -r '.items[].spec.replicas' )\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  print i[\"spec\"][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+# Get the current replica count for the WLS cluster if defined in the CRD's Cluster\n+# configuration.  If WLS cluster is not defined in the CRD then return the Domain\n+# scoped replica value, if present.  Returns replica count = 0 if no replica count found.\n+# args:\n+# $1 \"True\" if WLS cluster configuration defined in CRD, \"False\" otherwise\n+# $2 Custom Resource Domain\n+function get_replica_count() {", "originalCommit": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxODk2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r544718962", "bodyText": "Can you clarify where we should take 'min replicas' into account?  At the moment, we're just scaling up/down based on the currently configured replica count.  I see that the operator will enforce the 'min replicas' at runtime during ManagedServersUpStep.", "author": "lennyphan", "createdAt": "2020-12-17T00:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYxOTE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIwNTc1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545205756", "bodyText": "1 - If the 'true' replica count is 2, but this method returns 0, then a scale-up request will scale up to 1, and therefore it won't truly scale-up the cluster.\n2 - I haven't checked if this script already does this already, but I assume it'd be helpful if this script 'failed-fast' on an attempt to scale too low or too high, instead of indirectly relying on an administrator to figure out what went wrong.\nThe 'life cycle' scripts that Anil recently added have code for getting the min replica count (see getReplicaCount and getMinReplicas 'helper.sh').", "author": "tbarnes-us", "createdAt": "2020-12-17T16:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYxOTE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzMzExNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545333117", "bodyText": "Added verification of scaling request count against configured minimum replica count for cluster.", "author": "lennyphan", "createdAt": "2020-12-17T19:04:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYxOTE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MjM5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545342399", "bodyText": "Also, scaling above configured max cluster size is verified by the REST backend implementation and exception (HTTP status code and message) returned to client.", "author": "lennyphan", "createdAt": "2020-12-17T19:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYxOTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyMTA5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r544621096", "bodyText": "This is one of a few examples of long curl commands in this pull that is on a single line.  Can this line and the others be broken up into multiple lines in order to aid readability?", "author": "tbarnes-us", "createdAt": "2020-12-16T21:03:09Z", "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -2,24 +2,272 @@\n # Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n # Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n \n-echo \"called scalingAction.sh\" >> scalingAction.log\n+currdate=`date`\n+\n+echo \"### $currdate ###\" >> scalingAction.log\n \n # script parameters\n-scaling_action=\"\"\n-wls_domain_uid=\"\"\n-wls_cluster_name=\"\"\n-wls_domain_namespace=\"default\"\n+scaling_action=\"scaleUp\"\n+wls_domain_uid=\"sample-domain1\"\n+wls_cluster_name=\"cluster-1\"\n+wls_domain_namespace=\"sample-domain1-ns\"\n operator_service_name=\"internal-weblogic-operator-svc\"\n-operator_namespace=\"weblogic-operator\"\n-operator_service_account=\"weblogic-operator\"\n+operator_namespace=\"sample-weblogic-operator-ns\"\n+operator_service_account=\"sample-weblogic-operator-sa\"\n scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  echo \"scaling_action: $scaling_action\" >> scalingAction.log\n+  echo \"wls_domain_uid: $wls_domain_uid\" >> scalingAction.log\n+  echo \"wls_cluster_name: $wls_cluster_name\" >> scalingAction.log\n+  echo \"wls_domain_namespace: $wls_domain_namespace\" >> scalingAction.log\n+  echo \"operator_service_name: $operator_service_name\" >> scalingAction.log\n+  echo \"operator_service_account: $operator_service_account\" >> scalingAction.log\n+  echo \"operator_namespace: $operator_namespace\" >> scalingAction.log\n+  echo \"scaling_size: $scaling_size\" >> scalingAction.log\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl -v --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    echo \"$currdate Failed to retrieve status of $operator_service_name in name space: $operator_namespace\" >> scalingAction.log\n+    echo \"$currdate STATUS: $STATUS\" >> scalingAction.log\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=`curl -v --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" -X GET $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle`\n+  if [ $? -ne 0 ]\n+    then\n+      echo \"$currdate Failed to retrieve Custom Resource Definition for WebLogic domain\" >> scalingAction.log\n+      echo \"$currdate CRD: $CRD\" >> scalingAction.log\n+      exit 1\n+  fi\n+\n+# Find domain version\n+  local domain_api_version\n+  if [ -x \"$(command -v jq)\" ]; then\n+    domain_api_version=$(echo \"${CRD}\" | jq -r '.spec.version')\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+print(json.load(sys.stdin)[\"spec\"][\"version\"])\n+INPUT\n+domain_api_version=`echo ${CRD} | python cmds-$$.py`\n+  fi\n+  echo \"$domain_api_version\"\n+}\n+\n+# Retrieve Custom Resource Domain\n+function get_custom_resource_domain() {\n+  local DOMAIN=`curl -v --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" $kubernetes_master/apis/weblogic.oracle/$domain_api_version/namespaces/$wls_domain_namespace/domains/$domain_uid`", "originalCommit": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyNTU1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r544625555", "bodyText": "Nice to have: See resources/scripts/utils.sh for a timestamp bash function that generates a timestamp in a format that exactly matches the operator logs timestamp format and the timestamp format we use in startServer.sh, etc.  (It's nice to have all of our major scripts use the same timestamp format.)\nNice to have: Consider defining a 'trace' function to replace your use of echo throughout. The trace can then automatically inject the timestamp...", "author": "tbarnes-us", "createdAt": "2020-12-16T21:11:03Z", "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -2,24 +2,272 @@\n # Copyright (c) 2017, 2020, Oracle Corporation and/or its affiliates.\n # Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n \n-echo \"called scalingAction.sh\" >> scalingAction.log\n+currdate=`date`", "originalCommit": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1MDM3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r544650377", "bodyText": "Would you be ok if I just pull in the trace and timestamp functions since this is a standalone script, that's not deployed or run as part of the operator, where user's have to copy to use it either in a webhook or with WLDF to use  for scaling?", "author": "lennyphan", "createdAt": "2020-12-16T21:54:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyNTU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1OTU2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r544659562", "bodyText": "Would you be ok if I just pull in the trace and timestamp functions since this is a standalone script, that's not deployed or run as part of the operator, where user's have to copy to use it either in a webhook or with WLDF to use for scaling?\n\nSure. That's definitely better IMO.\nFeel free to copy the timestamp function.\nI have some doubt that you want to copy over the full trace function - something like the following would be fine IMO:\nfunction traceInfo() {\n   echo \"@[$(timestamp)][INFO]\" \"$@\"\n}\nfunction traceError() {\n   echo \"@[$(timestamp)][ERROR]\" \"$@\"\n}", "author": "tbarnes-us", "createdAt": "2020-12-16T22:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyNTU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NjY4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545356683", "bodyText": "LGTM", "author": "tbarnes-us", "createdAt": "2020-12-17T19:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyNTU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5MzA1MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r544693051", "bodyText": "Ha, ha... Austin, TX. (Don't bother making that change -- I just found it funny that you chose California)", "author": "rjeberhard", "createdAt": "2020-12-16T23:17:36Z", "path": "src/scripts/initialize-internal-operator-identity.sh", "diffHunk": "@@ -34,56 +34,24 @@ function generateInternalIdentity {\n   host=\"internal-weblogic-operator-svc\"\n   SANS=\"DNS:${host},DNS:${host}.${NAMESPACE},DNS:${host}.${NAMESPACE}.svc,DNS:${host}.${NAMESPACE}.svc.cluster.local\"\n   DAYS_VALID=\"3650\"\n-  TEMP_PW=\"temp_password\"\n   OP_PREFIX=\"weblogic-operator\"\n-  OP_ALIAS=\"${OP_PREFIX}-alias\"\n-  OP_JKS=\"${TEMP_DIR}/${OP_PREFIX}.jks\"\n-  OP_PKCS12=\"${TEMP_DIR}/${OP_PREFIX}.p12\"\n-  OP_CSR=\"${TEMP_DIR}/${OP_PREFIX}.csr\"\n   OP_CERT_PEM=\"${TEMP_DIR}/${OP_PREFIX}.cert.pem\"\n   OP_KEY_PEM=\"${TEMP_DIR}/${OP_PREFIX}.key.pem\"\n-  KEYTOOL=${JAVA_HOME}/bin/keytool\n-\n-  # generate a keypair for the operator's internal service, putting it in a keystore\n-  $KEYTOOL \\\n-    -genkey \\\n-    -keystore ${OP_JKS} \\\n-    -alias ${OP_ALIAS} \\\n-    -storepass ${TEMP_PW} \\\n-    -keypass ${TEMP_PW} \\\n-    -keysize 2048 \\\n-    -keyalg RSA \\\n-    -validity ${DAYS_VALID} \\\n-    -dname \"CN=weblogic-operator\" \\\n-    -ext KU=digitalSignature,nonRepudiation,keyEncipherment,dataEncipherment,keyAgreement \\\n-    -ext SAN=\"${SANS}\"\n-\n-  # extract the cert to a pem file\n-  $KEYTOOL \\\n-    -exportcert \\\n-    -keystore ${OP_JKS} \\\n-    -storepass ${TEMP_PW} \\\n-    -alias ${OP_ALIAS} \\\n-    -rfc \\\n-    > ${OP_CERT_PEM}\n-\n-  # convert the keystore to a pkcs12 file\n-  $KEYTOOL \\\n-    -importkeystore \\\n-    -srckeystore ${OP_JKS} \\\n-    -srcstorepass ${TEMP_PW} \\\n-    -destkeystore ${OP_PKCS12} \\\n-    -deststorepass ${TEMP_PW} \\\n-    -deststoretype PKCS12\n-\n-  # extract the private key from the pkcs12 file to a pem file\n+\n+  # generate a keypair for the operator's internal service\n+  # openssl v1.1.1 is the required minimum to use 'addext' option for\n+  # speciifying \"Subject Alternative Names (SANS)\" thus the following\n+  # configuration cannot be used on Oracle Linux 7-slim.\n   openssl \\\n-    pkcs12 \\\n-    -in ${OP_PKCS12} \\\n-    -passin pass:${TEMP_PW} \\\n+    req \\\n+    -newkey rsa:2048 \\\n     -nodes \\\n-    -nocerts \\\n-    -out ${OP_KEY_PEM}\n+    -keyout ${OP_KEY_PEM} \\\n+    -x509 \\\n+    -days ${DAYS_VALID} \\\n+    -out ${OP_CERT_PEM} \\\n+    -subj \"/C=US/ST=CALIFORNIA/L=REDWOOD CITY/O=WebLogic/OU=Development/CN=weblogic-operator\" \\", "originalCommit": "248e0bdaa28ada8e8ade9b5925ed6afedf77c44f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ae8487d98e1886fb1b5c0fc2707a4ca33b6d702f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ae8487d98e1886fb1b5c0fc2707a4ca33b6d702f", "message": "Update scalingAction.sh based on code review", "committedDate": "2020-12-17T00:33:56Z", "type": "commit"}, {"oid": "c4908acb65eea150724e274cfb7dcdcde169f4d4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c4908acb65eea150724e274cfb7dcdcde169f4d4", "message": "revert default scripts values", "committedDate": "2020-12-17T00:38:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIxMTg1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545211855", "bodyText": "It looks like every single trace is redirected to 'scalingAction.log', so the redirect can be centralized into this function.\nAlso, can the same log file be shared by multiple different clusters and domains?  If so, then it'd be helpful to decorate each trace with the current namespace, domain-uid, and cluster-name \"[ns=xxx][uid=xxx][cl=xxx]\".", "author": "tbarnes-us", "createdAt": "2020-12-17T16:10:57Z", "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,291 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"\n+}\n+\n+function trace() {\n+  echo \"@[$(timestamp)][INFO]\" \"$@\"", "originalCommit": "c4908acb65eea150724e274cfb7dcdcde169f4d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzMzY0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545333643", "bodyText": "Great suggestion.  Updated the trace logging to include the above suggestions", "author": "lennyphan", "createdAt": "2020-12-17T19:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIxMTg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2MTY2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545361662", "bodyText": "LGTM", "author": "tbarnes-us", "createdAt": "2020-12-17T19:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIxMTg1NQ=="}], "type": "inlineReview"}, {"oid": "d40004a546499d121a20d8ec63b2e6141e5ccbea", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d40004a546499d121a20d8ec63b2e6141e5ccbea", "message": "Updated logging and verify scaling request against configured minimum replica count", "committedDate": "2020-12-17T19:02:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0NzM3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545347370", "bodyText": "This URL path is wrong for K8s 1.16 and above as CRD's graduated from \"v1beta1\" to \"v1\". You could either determine the version of the k8s master or I have another idea. If you curl the \"$kubernetes_master/apis\" path, you get back a list of all API's supported by the server. This is equivalent to kubectl api-versions. The code could pick out the highest version of \"weblogic.oracle\" returned. For instance, on my system I get back \"weblogic.oracle/v7\" and \"weblogic.oracle/v8\".", "author": "rjeberhard", "createdAt": "2020-12-17T19:28:50Z", "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,328 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"\n+}\n+\n+function trace() {\n+  echo \"@[$(timestamp)][$wls_domain_namespace][$wls_domain_uid][$wls_cluster_name][INFO]\" \"$@\" >> scalingAction.log\n+}\n+\n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  trace \"scaling_action: $scaling_action\"\n+  trace \"wls_domain_uid: $wls_domain_uid\"\n+  trace \"wls_cluster_name: $wls_cluster_name\"\n+  trace \"wls_domain_namespace: $wls_domain_namespace\"\n+  trace \"operator_service_name: $operator_service_name\"\n+  trace \"operator_service_account: $operator_service_account\"\n+  trace \"operator_namespace: $operator_namespace\"\n+  trace \"scaling_size: $scaling_size\"\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    trace \"Failed to retrieve status of $operator_service_name in name space: $operator_namespace\"\n+    trace \"STATUS: $STATUS\"\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET \\\n+    $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle)", "originalCommit": "d40004a546499d121a20d8ec63b2e6141e5ccbea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0ODU4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545348581", "bodyText": "We need to test on k8s 1.16 -- it's likely that I'm wrong that this is broken now as 1.16 probably honors the \"v1beta1\" path. If so, that will be dropped in some k8s release -- I'll try and figure out which one.", "author": "rjeberhard", "createdAt": "2020-12-17T19:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0NzM3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1MDY2NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545350665", "bodyText": "I found the answer... Your current code will work until k8s 1.22.", "author": "rjeberhard", "createdAt": "2020-12-17T19:34:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0NzM3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1MTQzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545351430", "bodyText": "\"v1beta1\" is still honored as I'm running 1.18.12:\nbash-4.2$ kubectl version\nClient Version: version.Info{Major:\"1\", Minor:\"18\", GitVersion:\"v1.18.12\", GitCommit:\"7cd5e9086de8ae25d6a1514d0c87bac67ca4a481\", GitTreeState:\"clean\", BuildDate:\"2020-11-12T09:18:55Z\", GoVersion:\"go1.13.15\", Compiler:\"gc\", Platform:\"linux/amd64\"}\nServer Version: version.Info{Major:\"1\", Minor:\"18\", GitVersion:\"v1.18.12\", GitCommit:\"7cd5e9086de8ae25d6a1514d0c87bac67ca4a481\", GitTreeState:\"clean\", BuildDate:\"2020-11-12T09:11:15Z\", GoVersion:\"go1.13.15\", Compiler:\"gc\", Platform:\"linux/amd64\"}", "author": "lennyphan", "createdAt": "2020-12-17T19:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0NzM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1MjY3NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545352675", "bodyText": "I assume this should be \"get_min_replicas\".", "author": "tbarnes-us", "createdAt": "2020-12-17T19:37:35Z", "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,328 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"\n+}\n+\n+function trace() {\n+  echo \"@[$(timestamp)][$wls_domain_namespace][$wls_domain_uid][$wls_cluster_name][INFO]\" \"$@\" >> scalingAction.log\n+}\n+\n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  trace \"scaling_action: $scaling_action\"\n+  trace \"wls_domain_uid: $wls_domain_uid\"\n+  trace \"wls_cluster_name: $wls_cluster_name\"\n+  trace \"wls_domain_namespace: $wls_domain_namespace\"\n+  trace \"operator_service_name: $operator_service_name\"\n+  trace \"operator_service_account: $operator_service_account\"\n+  trace \"operator_namespace: $operator_namespace\"\n+  trace \"scaling_size: $scaling_size\"\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    trace \"Failed to retrieve status of $operator_service_name in name space: $operator_namespace\"\n+    trace \"STATUS: $STATUS\"\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET \\\n+    $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle)\n+  if [ $? -ne 0 ]\n+    then\n+      trace \"Failed to retrieve Custom Resource Definition for WebLogic domain\"\n+      trace \"CRD: $CRD\"\n+      exit 1\n+  fi\n+\n+# Find domain version\n+  local domain_api_version\n+  if [ -x \"$(command -v jq)\" ]; then\n+    domain_api_version=$(echo \"${CRD}\" | jq -r '.spec.version')\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+print(json.load(sys.stdin)[\"spec\"][\"version\"])\n+INPUT\n+domain_api_version=`echo ${CRD} | python cmds-$$.py`\n+  fi\n+  echo \"$domain_api_version\"\n+}\n+\n+# Retrieve Custom Resource Domain\n+function get_custom_resource_domain() {\n+  local DOMAIN=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    $kubernetes_master/apis/weblogic.oracle/$domain_api_version/namespaces/$wls_domain_namespace/domains/$domain_uid)\n+  if [ $? -ne 0 ]; then\n+    trace \"Failed to retrieve WebLogic Domain Custom Resource Definition\"\n+    exit 1\n+  fi\n+  echo \"$DOMAIN\"\n+}\n+\n+# Verify if cluster is defined in clusters of the Custom Resource Domain\n+# args:\n+# $1 Custom Resource Domain\n+function is_defined_in_clusters() {\n+  local DOMAIN=\"$1\"\n+  local in_cluster_startup=\"False\"\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local inClusterStartupCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\"))\"\n+    local clusterDefinedInCRD=$(echo \"${DOMAIN}\" | jq \"${inClusterStartupCmd}\")\n+    if [ \"${clusterDefinedInCRD}\" != \"\" ]; then\n+      in_cluster_startup=\"True\"\n+    fi\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+outer_loop_must_break = False\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      outer_loop_must_break = True\n+      print True\n+      break\n+if outer_loop_must_break == False:\n+  print False\n+INPUT\n+in_cluster_startup=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+  echo \"$in_cluster_startup\"\n+}\n+\n+# Gets the current replica count of the cluster\n+function get_num_ms_in_cluster() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+  local numManagedServersCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\") | .replicas)\"\n+  num_ms=$(echo \"${DOMAIN}\" | jq \"${numManagedServersCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      print j[index][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+# Gets the replica count at the Domain level\n+function get_num_ms_domain_scope() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+    num_ms=$(echo \"${DOMAIN}\" | jq -r '.items[].spec.replicas' )\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  print i[\"spec\"][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+#\n+# Function to get minimum replica count for cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of the cluster\n+# $3 - Return value containing minimum replica count\n+#\n+function get_min_replicas {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __result=$3\n+\n+  eval $__result=0\n+  minReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .minimumReplicas\"\n+  minReplicas=$(echo ${domainJson} | jq \"${minReplicaCmd}\")\n+  eval $__result=${minReplicas}\n+}\n+\n+# Get the current replica count for the WLS cluster if defined in the CRD's Cluster\n+# configuration.  If WLS cluster is not defined in the CRD then return the Domain\n+# scoped replica value, if present.  Returns replica count = 0 if no replica count found.\n+# args:\n+# $1 \"True\" if WLS cluster configuration defined in CRD, \"False\" otherwise\n+# $2 Custom Resource Domain\n+function get_replica_count() {\n+  local in_cluster_startup=\"$1\"\n+  local DOMAIN=\"$2\"\n+  local num_ms\n+  if [ \"$in_cluster_startup\" == \"True\" ]\n+  then\n+    trace \"$wls_cluster_name defined in clusters\"\n+    num_ms=$(get_num_ms_in_cluster \"$DOMAIN\")\n+  else\n+    trace \"$wls_cluster_name NOT defined in clusters\"\n+    num_ms=$(get_num_ms_domain_scope \"$DOMAIN\")\n+  fi\n+  echo \"$num_ms\"\n+}\n+\n+# Determine the nuber of managed servers to scale\n+# args:\n+# $1 scaling action (scaleUp or scaleDown)\n+# $2 current replica count\n+# $3 scaling increment value\n+function calculate_new_ms_count() {\n+  local scaling_action=\"$1\"\n+  local current_replica_count=\"$2\"\n+  local scaling_size=\"$3\"\n+  local new_ms\n+  if [ \"$scaling_action\" == \"scaleUp\" ];\n+  then\n+    # Scale up by specified scaling size\n+    # shellcheck disable=SC2004\n+    new_ms=$(($current_replica_count + $scaling_size))\n+  else\n+    # Scale down by specified scaling size\n+    new_ms=$(($current_replica_count - $scaling_size))\n+  fi\n+  echo \"$new_ms\"\n+}\n+\n+# Verify if requested managed server scaling count is less than the configured\n+# minimum replica count for the cluster.\n+# args:\n+# $1 Managed server count\n+# $2 Custom Resource Domain\n+# $3 Cluster name\n+function verify_minimum_ms_count_for_cluster() {\n+  local new_ms=\"$1\"\n+  local domainJson=\"$2\"\n+  local clusterName=\"$3\"\n+  # check if replica count is less than minimum replicas\n+  getMinReplicas \"${domainJson}\" \"${clusterName}\" minReplicas", "originalCommit": "d40004a546499d121a20d8ec63b2e6141e5ccbea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMDY5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545400697", "bodyText": "Great catch!  Thank you", "author": "lennyphan", "createdAt": "2020-12-17T21:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1MjY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NDM5MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545354391", "bodyText": "This should return 'min_replica_count' if min_replica_ count is higher than the discovered value.", "author": "tbarnes-us", "createdAt": "2020-12-17T19:40:24Z", "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,328 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"\n+}\n+\n+function trace() {\n+  echo \"@[$(timestamp)][$wls_domain_namespace][$wls_domain_uid][$wls_cluster_name][INFO]\" \"$@\" >> scalingAction.log\n+}\n+\n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  trace \"scaling_action: $scaling_action\"\n+  trace \"wls_domain_uid: $wls_domain_uid\"\n+  trace \"wls_cluster_name: $wls_cluster_name\"\n+  trace \"wls_domain_namespace: $wls_domain_namespace\"\n+  trace \"operator_service_name: $operator_service_name\"\n+  trace \"operator_service_account: $operator_service_account\"\n+  trace \"operator_namespace: $operator_namespace\"\n+  trace \"scaling_size: $scaling_size\"\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    trace \"Failed to retrieve status of $operator_service_name in name space: $operator_namespace\"\n+    trace \"STATUS: $STATUS\"\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET \\\n+    $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle)\n+  if [ $? -ne 0 ]\n+    then\n+      trace \"Failed to retrieve Custom Resource Definition for WebLogic domain\"\n+      trace \"CRD: $CRD\"\n+      exit 1\n+  fi\n+\n+# Find domain version\n+  local domain_api_version\n+  if [ -x \"$(command -v jq)\" ]; then\n+    domain_api_version=$(echo \"${CRD}\" | jq -r '.spec.version')\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+print(json.load(sys.stdin)[\"spec\"][\"version\"])\n+INPUT\n+domain_api_version=`echo ${CRD} | python cmds-$$.py`\n+  fi\n+  echo \"$domain_api_version\"\n+}\n+\n+# Retrieve Custom Resource Domain\n+function get_custom_resource_domain() {\n+  local DOMAIN=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    $kubernetes_master/apis/weblogic.oracle/$domain_api_version/namespaces/$wls_domain_namespace/domains/$domain_uid)\n+  if [ $? -ne 0 ]; then\n+    trace \"Failed to retrieve WebLogic Domain Custom Resource Definition\"\n+    exit 1\n+  fi\n+  echo \"$DOMAIN\"\n+}\n+\n+# Verify if cluster is defined in clusters of the Custom Resource Domain\n+# args:\n+# $1 Custom Resource Domain\n+function is_defined_in_clusters() {\n+  local DOMAIN=\"$1\"\n+  local in_cluster_startup=\"False\"\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local inClusterStartupCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\"))\"\n+    local clusterDefinedInCRD=$(echo \"${DOMAIN}\" | jq \"${inClusterStartupCmd}\")\n+    if [ \"${clusterDefinedInCRD}\" != \"\" ]; then\n+      in_cluster_startup=\"True\"\n+    fi\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+outer_loop_must_break = False\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      outer_loop_must_break = True\n+      print True\n+      break\n+if outer_loop_must_break == False:\n+  print False\n+INPUT\n+in_cluster_startup=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+  echo \"$in_cluster_startup\"\n+}\n+\n+# Gets the current replica count of the cluster\n+function get_num_ms_in_cluster() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+  local numManagedServersCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\") | .replicas)\"\n+  num_ms=$(echo \"${DOMAIN}\" | jq \"${numManagedServersCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      print j[index][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"", "originalCommit": "d40004a546499d121a20d8ec63b2e6141e5ccbea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMTQxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545401418", "bodyText": "This function is only called from get_replica_count() function so made the change in one place to return 'min_replica_count' if min_replica_ count is higher than the discovered value.", "author": "lennyphan", "createdAt": "2020-12-17T21:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NDM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NDY1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545354654", "bodyText": "This should return 'min_replica_count' if min_replica_ count is higher than the discovered value.", "author": "tbarnes-us", "createdAt": "2020-12-17T19:40:51Z", "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,328 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"\n+}\n+\n+function trace() {\n+  echo \"@[$(timestamp)][$wls_domain_namespace][$wls_domain_uid][$wls_cluster_name][INFO]\" \"$@\" >> scalingAction.log\n+}\n+\n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  trace \"scaling_action: $scaling_action\"\n+  trace \"wls_domain_uid: $wls_domain_uid\"\n+  trace \"wls_cluster_name: $wls_cluster_name\"\n+  trace \"wls_domain_namespace: $wls_domain_namespace\"\n+  trace \"operator_service_name: $operator_service_name\"\n+  trace \"operator_service_account: $operator_service_account\"\n+  trace \"operator_namespace: $operator_namespace\"\n+  trace \"scaling_size: $scaling_size\"\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    trace \"Failed to retrieve status of $operator_service_name in name space: $operator_namespace\"\n+    trace \"STATUS: $STATUS\"\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET \\\n+    $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle)\n+  if [ $? -ne 0 ]\n+    then\n+      trace \"Failed to retrieve Custom Resource Definition for WebLogic domain\"\n+      trace \"CRD: $CRD\"\n+      exit 1\n+  fi\n+\n+# Find domain version\n+  local domain_api_version\n+  if [ -x \"$(command -v jq)\" ]; then\n+    domain_api_version=$(echo \"${CRD}\" | jq -r '.spec.version')\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+print(json.load(sys.stdin)[\"spec\"][\"version\"])\n+INPUT\n+domain_api_version=`echo ${CRD} | python cmds-$$.py`\n+  fi\n+  echo \"$domain_api_version\"\n+}\n+\n+# Retrieve Custom Resource Domain\n+function get_custom_resource_domain() {\n+  local DOMAIN=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    $kubernetes_master/apis/weblogic.oracle/$domain_api_version/namespaces/$wls_domain_namespace/domains/$domain_uid)\n+  if [ $? -ne 0 ]; then\n+    trace \"Failed to retrieve WebLogic Domain Custom Resource Definition\"\n+    exit 1\n+  fi\n+  echo \"$DOMAIN\"\n+}\n+\n+# Verify if cluster is defined in clusters of the Custom Resource Domain\n+# args:\n+# $1 Custom Resource Domain\n+function is_defined_in_clusters() {\n+  local DOMAIN=\"$1\"\n+  local in_cluster_startup=\"False\"\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local inClusterStartupCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\"))\"\n+    local clusterDefinedInCRD=$(echo \"${DOMAIN}\" | jq \"${inClusterStartupCmd}\")\n+    if [ \"${clusterDefinedInCRD}\" != \"\" ]; then\n+      in_cluster_startup=\"True\"\n+    fi\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+outer_loop_must_break = False\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      outer_loop_must_break = True\n+      print True\n+      break\n+if outer_loop_must_break == False:\n+  print False\n+INPUT\n+in_cluster_startup=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+  echo \"$in_cluster_startup\"\n+}\n+\n+# Gets the current replica count of the cluster\n+function get_num_ms_in_cluster() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+  local numManagedServersCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\") | .replicas)\"\n+  num_ms=$(echo \"${DOMAIN}\" | jq \"${numManagedServersCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      print j[index][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+# Gets the replica count at the Domain level\n+function get_num_ms_domain_scope() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+    num_ms=$(echo \"${DOMAIN}\" | jq -r '.items[].spec.replicas' )\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  print i[\"spec\"][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+", "originalCommit": "d40004a546499d121a20d8ec63b2e6141e5ccbea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMTU5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545401597", "bodyText": "This function is only called from get_replica_count() function so made the change in one place to return 'min_replica_count' if min_replica_ count is higher than the discovered value.", "author": "lennyphan", "createdAt": "2020-12-17T21:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NDY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NTI0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545355248", "bodyText": "This should return min_replica_count if discovered value is less than the min", "author": "tbarnes-us", "createdAt": "2020-12-17T19:41:51Z", "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,328 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"\n+}\n+\n+function trace() {\n+  echo \"@[$(timestamp)][$wls_domain_namespace][$wls_domain_uid][$wls_cluster_name][INFO]\" \"$@\" >> scalingAction.log\n+}\n+\n+function print_usage() {\n+  echo \"Usage: scalingAction.sh --action=[scaleUp | scaleDown] --domain_uid=<domain uid> --cluster_name=<cluster name> [--kubernetes_master=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}] [--access_token=<access_token>] [--wls_domain_namespace=default] [--operator_namespace=weblogic-operator] [--operator_service_name=weblogic-operator] [--scaling_size=1]\"\n+  echo \"  where\"\n+  echo \"    action - scaleUp or scaleDown\"\n+  echo \"    domain_uid - WebLogic Domain Unique Identifier\"\n+  echo \"    cluster_name - WebLogic Cluster Name\"\n+  echo \"    kubernetes_master - Kubernetes master URL, default=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n+  echo \"    access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\"\n+  echo \"    wls_domain_namespace - Kubernetes name space WebLogic Domain is defined in, default=default\"\n+  echo \"    operator_service_name - WebLogic Operator Service name, default=internal-weblogic-operator-svc\"\n+  echo \"    operator_service_account - Kubernetes Service Account for WebLogic Operator, default=weblogic-operator\"\n+  echo \"    operator_namespace - WebLogic Operator Namespace, default=weblogic-operator\"\n+  echo \"    scaling_size - number of WebLogic server instances by which to scale up or down, default=1\"\n+  exit 1\n+}\n+\n+# Retrieve WebLogic Operator Service Account Token for Authorization\n+function initialize_access_token() {\n+  if [ -z \"$access_token\" ]\n+  then\n+    access_token=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`\n+  fi\n+}\n+\n+function logScalingParameters() {\n+  trace \"scaling_action: $scaling_action\"\n+  trace \"wls_domain_uid: $wls_domain_uid\"\n+  trace \"wls_cluster_name: $wls_cluster_name\"\n+  trace \"wls_domain_namespace: $wls_domain_namespace\"\n+  trace \"operator_service_name: $operator_service_name\"\n+  trace \"operator_service_account: $operator_service_account\"\n+  trace \"operator_namespace: $operator_namespace\"\n+  trace \"scaling_size: $scaling_size\"\n+}\n+\n+# Query WebLogic Operator Service Port\n+function get_operator_internal_rest_port() {\n+  local STATUS=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET $kubernetes_master/api/v1/namespaces/$operator_namespace/services/$operator_service_name/status)\n+  if [ $? -ne 0 ]\n+  then\n+    trace \"Failed to retrieve status of $operator_service_name in name space: $operator_namespace\"\n+    trace \"STATUS: $STATUS\"\n+    exit 1\n+  fi\n+\n+  local port\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local extractPortCmd=\"(.spec.ports[] | select (.name == \\\"rest\\\") | .port)\"\n+    port=$(echo \"${STATUS}\" | jq \"${extractPortCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"spec\"][\"ports\"]:\n+  if i[\"name\"] == \"rest\":\n+    print(i[\"port\"])\n+INPUT\n+port=$(echo \"${STATUS}\" | python cmds-$$.py)\n+  fi\n+  echo \"$port\"\n+}\n+\n+# Retrieve the api version of the deployed Custom Resource Domain\n+function get_domain_api_version() {\n+  # Retrieve Custom Resource Definition for WebLogic domain\n+  local CRD=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    -X GET \\\n+    $kubernetes_master/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/domains.weblogic.oracle)\n+  if [ $? -ne 0 ]\n+    then\n+      trace \"Failed to retrieve Custom Resource Definition for WebLogic domain\"\n+      trace \"CRD: $CRD\"\n+      exit 1\n+  fi\n+\n+# Find domain version\n+  local domain_api_version\n+  if [ -x \"$(command -v jq)\" ]; then\n+    domain_api_version=$(echo \"${CRD}\" | jq -r '.spec.version')\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+print(json.load(sys.stdin)[\"spec\"][\"version\"])\n+INPUT\n+domain_api_version=`echo ${CRD} | python cmds-$$.py`\n+  fi\n+  echo \"$domain_api_version\"\n+}\n+\n+# Retrieve Custom Resource Domain\n+function get_custom_resource_domain() {\n+  local DOMAIN=$(curl \\\n+    -v \\\n+    --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n+    -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\\n+    $kubernetes_master/apis/weblogic.oracle/$domain_api_version/namespaces/$wls_domain_namespace/domains/$domain_uid)\n+  if [ $? -ne 0 ]; then\n+    trace \"Failed to retrieve WebLogic Domain Custom Resource Definition\"\n+    exit 1\n+  fi\n+  echo \"$DOMAIN\"\n+}\n+\n+# Verify if cluster is defined in clusters of the Custom Resource Domain\n+# args:\n+# $1 Custom Resource Domain\n+function is_defined_in_clusters() {\n+  local DOMAIN=\"$1\"\n+  local in_cluster_startup=\"False\"\n+  if [ -x \"$(command -v jq)\" ]; then\n+    local inClusterStartupCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\"))\"\n+    local clusterDefinedInCRD=$(echo \"${DOMAIN}\" | jq \"${inClusterStartupCmd}\")\n+    if [ \"${clusterDefinedInCRD}\" != \"\" ]; then\n+      in_cluster_startup=\"True\"\n+    fi\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+outer_loop_must_break = False\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      outer_loop_must_break = True\n+      print True\n+      break\n+if outer_loop_must_break == False:\n+  print False\n+INPUT\n+in_cluster_startup=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+  echo \"$in_cluster_startup\"\n+}\n+\n+# Gets the current replica count of the cluster\n+function get_num_ms_in_cluster() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+  local numManagedServersCmd=\"(.items[].spec.clusters[] | select (.clusterName == \\\"${wls_cluster_name}\\\") | .replicas)\"\n+  num_ms=$(echo \"${DOMAIN}\" | jq \"${numManagedServersCmd}\")\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  j = i[\"spec\"][\"clusters\"]\n+  for index, cs in enumerate(j):\n+    if j[index][\"clusterName\"] == \"$wls_cluster_name\":\n+      print j[index][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+# Gets the replica count at the Domain level\n+function get_num_ms_domain_scope() {\n+  local num_ms\n+  if [ -x \"$(command -v jq)\" ]; then\n+    num_ms=$(echo \"${DOMAIN}\" | jq -r '.items[].spec.replicas' )\n+  else\n+cat > cmds-$$.py << INPUT\n+import sys, json\n+for i in json.load(sys.stdin)[\"items\"]:\n+  print i[\"spec\"][\"replicas\"]\n+INPUT\n+  num_ms=`echo ${DOMAIN} | python cmds-$$.py`\n+  fi\n+\n+  if [ \"${num_ms}\" == \"null\" ]; then\n+    num_ms=0\n+  fi\n+\n+  echo \"$num_ms\"\n+}\n+\n+#\n+# Function to get minimum replica count for cluster\n+# $1 - Domain resource in json format\n+# $2 - Name of the cluster\n+# $3 - Return value containing minimum replica count\n+#\n+function get_min_replicas {\n+  local domainJson=$1\n+  local clusterName=$2\n+  local __result=$3\n+\n+  eval $__result=0\n+  minReplicaCmd=\"(.status.clusters[] | select (.clusterName == \\\"${clusterName}\\\")) \\\n+    | .minimumReplicas\"\n+  minReplicas=$(echo ${domainJson} | jq \"${minReplicaCmd}\")\n+  eval $__result=${minReplicas}\n+}\n+\n+# Get the current replica count for the WLS cluster if defined in the CRD's Cluster\n+# configuration.  If WLS cluster is not defined in the CRD then return the Domain\n+# scoped replica value, if present.  Returns replica count = 0 if no replica count found.\n+# args:\n+# $1 \"True\" if WLS cluster configuration defined in CRD, \"False\" otherwise\n+# $2 Custom Resource Domain\n+function get_replica_count() {\n+  local in_cluster_startup=\"$1\"\n+  local DOMAIN=\"$2\"\n+  local num_ms\n+  if [ \"$in_cluster_startup\" == \"True\" ]\n+  then\n+    trace \"$wls_cluster_name defined in clusters\"\n+    num_ms=$(get_num_ms_in_cluster \"$DOMAIN\")\n+  else\n+    trace \"$wls_cluster_name NOT defined in clusters\"\n+    num_ms=$(get_num_ms_domain_scope \"$DOMAIN\")\n+  fi\n+  echo \"$num_ms\"", "originalCommit": "d40004a546499d121a20d8ec63b2e6141e5ccbea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMTg2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545401861", "bodyText": "Added code to return 'min_replica_count' if min_replica_ count is higher than the discovered value.", "author": "lennyphan", "createdAt": "2020-12-17T21:02:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NTI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2MDYyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545360621", "bodyText": "Minor:  It looks like secs_since_epoch & millis_since_epoch are unused - leftover from an older iteration of the function.  They can be removed from here and from the same function in 'utils.sh'.", "author": "tbarnes-us", "createdAt": "2020-12-17T19:50:39Z", "path": "src/scripts/scaling/scalingAction.sh", "diffHunk": "@@ -16,10 +14,328 @@ scaling_size=1\n access_token=\"\"\n kubernetes_master=\"https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}\"\n \n+# timestamp\n+#   purpose:  echo timestamp in the form yyyymmddThh:mm:ss.mmm ZZZ\n+#   example:  20181001T14:00:00.001 UTC\n+function timestamp() {\n+  local timestamp=\"`date --utc '+%Y-%m-%dT%H:%M:%S %N %s %Z' 2>&1`\"\n+  if [ ! \"${timestamp/illegal/xyz}\" = \"${timestamp}\" ]; then\n+    # old shell versions don't support %N or --utc\n+    timestamp=\"`date -u '+%Y-%m-%dT%H:%M:%S 000000 %s %Z' 2>&1`\"\n+  fi\n+  local ymdhms=\"`echo $timestamp | awk '{ print $1 }'`\"\n+  # convert nano to milli\n+  local milli=\"`echo $timestamp | awk '{ print $2 }' | sed 's/\\(^...\\).*/\\1/'`\"\n+  local secs_since_epoch=\"`echo $timestamp | awk '{ print $3 }'`\"\n+  local millis_since_opoch=\"${secs_since_epoch}${milli}\"\n+  local timezone=\"`echo $timestamp | awk '{ print $4 }'`\"\n+  echo \"${ymdhms}.${milli} ${timezone}\"", "originalCommit": "d40004a546499d121a20d8ec63b2e6141e5ccbea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMjIwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2106#discussion_r545402200", "bodyText": "Removed the unused local vars.", "author": "lennyphan", "createdAt": "2020-12-17T21:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2MDYyMQ=="}], "type": "inlineReview"}, {"oid": "2102331990e95f6fa101a7ca30edc6d1e4f18035", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2102331990e95f6fa101a7ca30edc6d1e4f18035", "message": "return min replica count if greater than discovered value", "committedDate": "2020-12-17T20:59:28Z", "type": "commit"}, {"oid": "1572fe0b73b1be107d53dd44544692c7f492e6e2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1572fe0b73b1be107d53dd44544692c7f492e6e2", "message": "remove unused vars from timestamp function", "committedDate": "2020-12-17T21:07:46Z", "type": "commit"}]}