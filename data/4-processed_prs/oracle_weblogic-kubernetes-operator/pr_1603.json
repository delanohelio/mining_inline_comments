{"pr_number": 1603, "pr_title": "Cleanup artifacts in Kubernetes cluster", "pr_createdAt": "2020-04-27T22:43:41Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603", "timeline": [{"oid": "797326ca0d3a5e2e54ddf809a987ff4471a5ee12", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/797326ca0d3a5e2e54ddf809a987ff4471a5ee12", "message": "Adding cleanup methods to cleanup all the Kubernetyes artifacts left\nbehind by the test class.", "committedDate": "2020-04-27T22:30:30Z", "type": "commit"}, {"oid": "47eab4498b7adc51c85e47bd445a266a1cd5dcb8", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/47eab4498b7adc51c85e47bd445a266a1cd5dcb8", "message": "Leave the cluster artifacts untouched", "committedDate": "2020-04-27T22:35:49Z", "type": "commit"}, {"oid": "7626b31eef19bfc1c295474977873486b0e740dc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7626b31eef19bfc1c295474977873486b0e740dc", "message": "correct the typo", "committedDate": "2020-04-27T23:28:42Z", "type": "commit"}, {"oid": "a79e3de9f45c17067beacf341227d814a500cc51", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a79e3de9f45c17067beacf341227d814a500cc51", "message": "cleanup javadoc", "committedDate": "2020-04-28T05:35:54Z", "type": "commit"}, {"oid": "a80b6289f74705c05595bd3a1e513a45393b8205", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a80b6289f74705c05595bd3a1e513a45393b8205", "message": "add logs for pods", "committedDate": "2020-04-28T05:41:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r416659698", "bodyText": "This is still synchronous by namespace, correct?  It will be curious to see how long clean-up takes.  Perhaps because clean-up happens for each test suite as that suite finishes, maybe this is parallel enough.", "author": "rjeberhard", "createdAt": "2020-04-28T14:28:44Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2NjIyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r416766227", "bodyText": "Yes this is synchronous. But the delete operation on the artifacts in all namespaces(from single test class) is already called (line # 74) hopefully further iteration of the namespace won't wait long.", "author": "sankarpn", "createdAt": "2020-04-28T16:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzU1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023557", "bodyText": "i think it is worth delaying at least 5 seconds to give the apiserver a chance to process the requests...", "author": "markxnelson", "createdAt": "2020-04-29T01:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzcwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023703", "bodyText": "and i am not sure if 3 mins in too long or too short - need to work out exactly what it would be deleting at this point", "author": "markxnelson", "createdAt": "2020-04-29T01:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3Mzg1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417473857", "bodyText": "i think it is worth delaying at least 5 seconds to give the apiserver a chance to process the requests...\n\nThere is already a 30 second wait(Thread.sleep)  before this right ? The pollDelay is for the initial delay to start polling every pollInterval seconds which is 10 seconds.", "author": "sankarpn", "createdAt": "2020-04-29T17:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3NDA2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417474063", "bodyText": "and i am not sure if 3 mins in too long or too short - need to work out exactly what it would be deleting at this point\n\nI changed it to 10 minutes", "author": "sankarpn", "createdAt": "2020-04-29T17:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1OTY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDM4Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417020387", "bodyText": "the -> a", "author": "markxnelson", "createdAt": "2020-04-29T01:31:52Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -242,18 +260,61 @@ public static boolean createDeployment(String deploymentYaml) {\n   }\n \n   /**\n-   * List all deployments in a given namespace.\n-   * @param namespace Namespace in which to list the deployments\n-   * @return V1DeploymentList of deployments in the Kubernetes cluster\n+   * List deployments in the given namespace.\n+   *\n+   * @param namespace namespace in which to list the deployments\n+   * @return list of deployment objects as {@link V1DeploymentList}\n+   * @throws ApiException when listing fails\n    */\n-  public static V1DeploymentList listDeployments(String namespace) {\n-    KubernetesApiResponse<V1DeploymentList> list = deploymentClient.list(namespace);\n-    if (list.isSuccess()) {\n-      return list.getObject();\n-    } else {\n-      logger.warning(\"Failed to list deployments, status code {0}\", list.getHttpStatusCode());\n-      return null;\n+  public static V1DeploymentList listDeployments(String namespace) throws ApiException {\n+    V1DeploymentList deployments;\n+    try {\n+      AppsV1Api apiInstance = new AppsV1Api(apiClient);\n+      deployments = apiInstance.listNamespacedDeployment(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n     }\n+    return deployments;\n+  }\n+\n+  /**\n+   * Delete the deployment.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxOTExOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417519118", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:20:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDU2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417020562", "bodyText": "do we need to instantiate a class, can we not implement this as a static method?", "author": "markxnelson", "createdAt": "2020-04-29T01:32:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -359,6 +439,20 @@ public static V1PodList listPods(String namespace, String labelSelectors) throws\n     return v1PodList;\n   }\n \n+  /**\n+   * Copy a directory from Kubernetes pod to local destination path.\n+   * @param pod V1Pod object\n+   * @param srcPath source directory location\n+   * @param destination destination directory path\n+   * @throws IOException when copy fails\n+   * @throws ApiException when pod interaction fails\n+   */\n+  public static void copyDirectoryFromPod(V1Pod pod, String srcPath, Path destination)\n+      throws IOException, ApiException {\n+    Copy copy = new Copy();", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1OTE2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417459162", "bodyText": "This is from the kubernetes client-java API library, we are not implementing this.", "author": "sankarpn", "createdAt": "2020-04-29T16:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDU2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwMjEwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r418402102", "bodyText": "ok, that's a shame :(", "author": "markxnelson", "createdAt": "2020-05-01T03:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDk0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417020948", "bodyText": "does this work? does it actually wait for the delete to complete and then return this?\nalso - this needs to be wrapped in a thread and run with a timeout -- you can create a JIRA to add that later, if you want to do it in a separate PR.\nas written, this will fail if a finalizer prevents the ns deletion from completing", "author": "markxnelson", "createdAt": "2020-04-29T01:34:30Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -485,9 +580,16 @@ public static boolean deleteNamespace(String name) {\n     KubernetesApiResponse<V1Namespace> response = namespaceClient.delete(name);\n \n     if (!response.isSuccess()) {", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MzEzMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417463131", "bodyText": "This is not synchronous . As seen from the log message in the method.\n\"Received after-deletion status of the requested object, will be deleting namespace in background!\"\nWe issue the delete request and wait for it be deleted in the calling method.", "author": "sankarpn", "createdAt": "2020-04-29T16:50:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMDk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTA1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021055", "bodyText": "finalizer can also prevent this from working - also needs to be run in a thread with a timeout", "author": "markxnelson", "createdAt": "2020-04-29T01:35:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -565,7 +667,7 @@ private static JsonElement convertToJson(Object obj) {\n    */\n   public static boolean deleteDomainCustomResource(String domainUid, String namespace) {\n \n-    KubernetesApiResponse<Domain> response = crdClient.delete(namespace, domainUid);\n+    KubernetesApiResponse<Domain> response = crdClient.delete(namespace, domainUid, deleteOptions);", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDQzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417464437", "bodyText": "Again, this is not synchronous. Will be deleting the domain the background.\nThe calling method waits for it to be deleted.", "author": "sankarpn", "createdAt": "2020-04-29T16:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTA5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021096", "bodyText": "thread/timeout", "author": "markxnelson", "createdAt": "2020-04-29T01:35:19Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -989,7 +1091,7 @@ public static boolean createPvc(V1PersistentVolumeClaim persistentVolumeClaim) t\n    */\n   public static boolean deletePv(String name) {\n \n-    KubernetesApiResponse<V1PersistentVolume> response = pvClient.delete(name);\n+    KubernetesApiResponse<V1PersistentVolume> response = pvClient.delete(name, deleteOptions);", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDkzMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417464932", "bodyText": "please see my similar comment.", "author": "sankarpn", "createdAt": "2020-04-29T16:53:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTIwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021203", "bodyText": "include the ns in the message", "author": "markxnelson", "createdAt": "2020-04-29T01:35:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxOTMyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417519322", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTI1MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021250", "bodyText": "delete a job", "author": "markxnelson", "createdAt": "2020-04-29T01:36:03Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxOTQwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417519400", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTM2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021366", "bodyText": "...deletion of job fails", "author": "markxnelson", "createdAt": "2020-04-29T01:36:26Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the job\n+   * @return true if delete is successful\n+   * @throws ApiException when delete job fails", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxOTQ3Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417519473", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:21:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTQ2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021464", "bodyText": "delete a replica set", "author": "markxnelson", "createdAt": "2020-04-29T01:36:49Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1245,37 +1347,141 @@ public static boolean deleteService(String name, String namespace) {\n     return true;\n   }\n \n-  // --------------------------- jobs ---------------------------\n   /**\n-   * Get a list of all jobs in the given namespace.\n+   * List services in a given namespace.\n    *\n-   * @param namespace in which to list the jobs\n-   * @return V1JobList of jobs from Kubernetes cluster\n+   * @param namespace name of the namespace\n+   * @return V1ServiceList list of {@link V1Service} objects\n    */\n-  public static V1JobList listJobs(String namespace) {\n-    KubernetesApiResponse<V1JobList> list = jobClient.list(namespace);\n+  public static V1ServiceList listServices(String namespace) {\n+\n+    KubernetesApiResponse<V1ServiceList> list = serviceClient.list(namespace);\n     if (list.isSuccess()) {\n       return list.getObject();\n     } else {\n-      logger.warning(\"Failed to list jobs, status code {0}\", list.getHttpStatusCode());\n+      logger.warning(\"Failed to list services, status code {0}\", list.getHttpStatusCode());\n       return null;\n     }\n   }\n \n+  // --------------------------- jobs ---------------------------\n+\n+\n+  /**\n+   * Delete job.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the job\n+   * @return true if delete is successful\n+   * @throws ApiException when delete job fails\n+   */\n+  public static boolean deleteJob(String namespace, String name) throws ApiException {\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      apiInstance.deleteNamespacedJob(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List jobs in the given namespace.\n+   *\n+   * @param namespace in which to list the jobs\n+   * @return V1JobList list of {@link V1Job} from Kubernetes cluster\n+   * @throws ApiException when list fails\n+   */\n+  public static V1JobList listJobs(String namespace) throws ApiException {\n+    V1JobList list;\n+    try {\n+      BatchV1Api apiInstance = new BatchV1Api(apiClient);\n+      list = apiInstance.listNamespacedJob(\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return list;\n+  }\n+\n   // --------------------------- replica sets ---------------------------\n+\n+\n+  /**\n+   * Delete replica set.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTU1Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021552", "bodyText": "curious as to where we need this - i don't think we use any rs's?", "author": "markxnelson", "createdAt": "2020-04-29T01:37:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxOTcwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417519700", "bodyText": "[speriyat@speriyat-1 weblogic-kubernetes-operator]$ k get rs --all-namespaces | grep opns\ntwooptwodomain-opns-1   weblogic-operator-69fd5c765    1         1         1       54m\ntwooptwodomain-opns-3   weblogic-operator-6dbccd7b95   1         1         1       51m", "author": "sankarpn", "createdAt": "2020-04-29T18:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTYzMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021631", "bodyText": "delete a role", "author": "markxnelson", "createdAt": "2020-04-29T01:37:41Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMDI5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417520294", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTcyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021722", "bodyText": "role or rolebinding? javadoc and code don't match", "author": "markxnelson", "createdAt": "2020-04-29T01:38:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NTE3OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417465178", "bodyText": "fixed it", "author": "sankarpn", "createdAt": "2020-04-29T16:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTc4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021789", "bodyText": "namespace is one word", "author": "markxnelson", "createdAt": "2020-04-29T01:38:23Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMDc2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417520768", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTg4MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021880", "bodyText": "a role\nrole or clusterrole? javadoc and code don't match", "author": "markxnelson", "createdAt": "2020-04-29T01:38:49Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMDg2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417520867", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTkzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417021936", "bodyText": "was successful", "author": "markxnelson", "createdAt": "2020-04-29T01:38:58Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMDkzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417520934", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMTkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjAwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022004", "bodyText": "cluster roles", "author": "markxnelson", "createdAt": "2020-04-29T01:39:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMTI3NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417521274", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjA1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022053", "bodyText": "was", "author": "markxnelson", "createdAt": "2020-04-29T01:39:31Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMTM2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417521360", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjE1OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022158", "bodyText": "listNamespacesRoles plural", "author": "markxnelson", "createdAt": "2020-04-29T01:39:56Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMTU4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417521589", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjIxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022218", "bodyText": "list ingresses in the given namespace", "author": "markxnelson", "createdAt": "2020-04-29T01:40:11Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMTY2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417521661", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjI2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022269", "bodyText": "listNamespacedIngresses", "author": "markxnelson", "createdAt": "2020-04-29T01:40:27Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjAxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522017", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjI5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022299", "bodyText": "get ingress in the ....", "author": "markxnelson", "createdAt": "2020-04-29T01:40:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjEzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522130", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjM2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022363", "bodyText": "name of the ingress - no such thing as an \"ingress extension\"", "author": "markxnelson", "createdAt": "2020-04-29T01:40:57Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the Ingress extension", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjE5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522196", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:25:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjQxNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022415", "bodyText": "Ingress object", "author": "markxnelson", "createdAt": "2020-04-29T01:41:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the Ingress extension\n+   * @return ExtensionsV1beta1Ingress Ingress extension object when found, otherwise null", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjUxNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522515", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjQ1MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022450", "bodyText": "getNamespacedIngress", "author": "markxnelson", "createdAt": "2020-04-29T01:41:15Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1327,5 +1536,255 @@ public static boolean deleteClusterRoleBinding(String name) {\n     return true;\n   }\n \n+  /**\n+   * List cluster role bindings.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listClusterRoleBindings(String labelSelector) throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listRoleBindingForAllNamespaces(\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          PRETTY, // String | If true, then the output is pretty printed.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+  /**\n+   * Delete role in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role\n+   * @return return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRoleBinding(String namespace, String name)\n+      throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRoleBinding(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List role bindings in a given name space.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleBindingList list of {@link V1RoleBinding} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleBindingList listNamespacedRoleBinding(String namespace)\n+      throws ApiException {\n+    V1RoleBindingList roleBindings;\n+    try {\n+      roleBindings = rbacAuthApi.listNamespacedRoleBinding(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roleBindings;\n+  }\n+\n+\n+  /**\n+   * Delete role in the Kubernetes cluster.\n+   *\n+   * @param name name of the cluster role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteClusterRole(String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteClusterRole(\n+          name, // String | name of the role.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * List roles in the Kubernetes cluster.\n+   *\n+   * @param labelSelector labels to narrow the list\n+   * @return V1ClusterRoleList list of {@link V1ClusterRole} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1ClusterRoleList listClusterRoles(String labelSelector) throws ApiException {\n+    V1ClusterRoleList roles;\n+    try {\n+      roles = rbacAuthApi.listClusterRole(\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          labelSelector, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * Delete role in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the role to delete\n+   * @return true if deletion is successful\n+   * @throws ApiException when delete fails\n+   */\n+  public static boolean deleteNamespacedRole(String namespace, String name) throws ApiException {\n+    try {\n+      rbacAuthApi.deleteNamespacedRole(\n+          name, // String | name of the job.\n+          namespace, // String | name of the namespace.\n+          PRETTY, // String | pretty print output.\n+          null, // String | When present, indicates that modifications should not be persisted.\n+          GRACE_PERIOD, // Integer | The duration in seconds before the object should be deleted.\n+          null, // Boolean | Deprecated: use the PropagationPolicy.\n+          FOREGROUND, // String | Whether and how garbage collection will be performed.\n+          null // V1DeleteOptions.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List roles in a given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return V1RoleList list of {@link V1Role} object\n+   * @throws ApiException when listing fails\n+   */\n+  public static V1RoleList listNamespacedRole(String namespace) throws ApiException {\n+    V1RoleList roles;\n+    try {\n+      roles = rbacAuthApi.listNamespacedRole(\n+          namespace, // String | namespace.\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list call.\n+          Boolean.FALSE // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return roles;\n+  }\n+\n+  /**\n+   * List Ingress extensions in the given namespace.\n+   *\n+   * @param namespace name of the namespace\n+   * @return ExtensionsV1beta1IngressList list of {@link ExtensionsV1beta1Ingress} objects\n+   * @throws ApiException when listing fails\n+   */\n+  public static ExtensionsV1beta1IngressList listIngressExtensions(String namespace) throws ApiException {\n+    ExtensionsV1beta1IngressList ingressList;\n+    try {\n+      ExtensionsV1beta1Api apiInstance = new ExtensionsV1beta1Api(apiClient);\n+      ingressList = apiInstance.listNamespacedIngress(\n+          namespace, // namespace\n+          PRETTY, // String | If 'true', then the output is pretty printed.\n+          ALLOW_WATCH_BOOKMARKS, // Boolean | allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+          null, // String | The continue option should be set when retrieving more results from the server.\n+          null, // String | A selector to restrict the list of returned objects by their fields.\n+          null, // String | A selector to restrict the list of returned objects by their labels.\n+          null, // Integer | limit is a maximum number of responses to return for a list call.\n+          RESOURCE_VERSION, // String | Shows changes that occur after that particular version of a resource.\n+          TIMEOUT_SECONDS, // Integer | Timeout for the list/watch call.\n+          ALLOW_WATCH_BOOKMARKS // Boolean | Watch for changes to the described resources.\n+      );\n+    } catch (ApiException apex) {\n+      logger.warning(apex.getResponseBody());\n+      throw apex;\n+    }\n+    return ingressList;\n+  }\n+\n+  /**\n+   * Get Ingress extension in the given namespace by name.\n+   *\n+   * @param namespace name of the namespace\n+   * @param name name of the Ingress extension\n+   * @return ExtensionsV1beta1Ingress Ingress extension object when found, otherwise null\n+   * @throws ApiException when get fails\n+   */\n+  public static ExtensionsV1beta1Ingress getIngressExtension(String namespace, String name)", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjU5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522596", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjcxMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022711", "bodyText": "this is just for a single test right -- so this comment is wrong", "author": "markxnelson", "createdAt": "2020-04-29T01:42:07Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjgwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522804", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjgxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022817", "bodyText": "for up to three minutes\n3 min is not long enough -these things can take longer,  try 10", "author": "markxnelson", "createdAt": "2020-04-29T01:42:35Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMjk0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417522948", "bodyText": "changed to 10 minutes", "author": "sankarpn", "createdAt": "2020-04-29T18:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjkyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417022927", "bodyText": "there could be a domain in the operator namespace", "author": "markxnelson", "createdAt": "2020-04-29T01:43:09Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NzA0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417467043", "bodyText": "Removed the namespace check to figure out if it is operator or domain anmespace and trying to delete domain and operator in all namespaces.", "author": "sankarpn", "createdAt": "2020-04-29T16:56:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMjkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzA0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023045", "bodyText": "there could be an operator in any of these namespaces -- i don't think you need this isOperatorNamespace business", "author": "markxnelson", "createdAt": "2020-04-29T01:43:41Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3MTA5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417471094", "bodyText": "see my above comment", "author": "sankarpn", "createdAt": "2020-04-29T17:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzI5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023295", "bodyText": "try { \n  Thread.sleep(30 *1000);\n} catch (InterruptedException e) { \n  //ignore \n}", "author": "markxnelson", "createdAt": "2020-04-29T01:44:41Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzQwNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023407", "bodyText": "also, why? :)", "author": "markxnelson", "createdAt": "2020-04-29T01:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTA1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417525053", "bodyText": "Otherwise I need to put this wait in the pollDelay which will make it wait for every namespace. Since the delete on the namespaces was already called a one time wait is good enough.\nConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n.and().with().pollInterval(10, SECONDS)\n.atMost(10, MINUTES).await();", "author": "sankarpn", "createdAt": "2020-04-29T18:30:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzkxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023919", "bodyText": "what artifacts?  rename this to something like nothingFoundInNamespace", "author": "markxnelson", "createdAt": "2020-04-29T01:47:15Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTE4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417525186", "bodyText": "renamed it.", "author": "sankarpn", "createdAt": "2020-04-29T18:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzk4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417023989", "bodyText": "delete all domains in the given namespace, if any exist", "author": "markxnelson", "createdAt": "2020-04-29T01:47:41Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTI2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417525267", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyMzk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDA0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024048", "bodyText": "uninstall the operator", "author": "markxnelson", "createdAt": "2020-04-29T01:47:59Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDE2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024161", "bodyText": "feels the the release name should be a param, or you should call this uninstallWebLogicOperators (plural)", "author": "markxnelson", "createdAt": "2020-04-29T01:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDA0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTUyNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417525526", "bodyText": "changed the method name", "author": "sankarpn", "createdAt": "2020-04-29T18:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDA0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTYyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417525629", "bodyText": "uninstall the operator\n\nfixed it", "author": "sankarpn", "createdAt": "2020-04-29T18:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDIzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024230", "bodyText": "this assumes (possibly incorrectly) that there is only one and that you know what its name is", "author": "markxnelson", "createdAt": "2020-04-29T01:48:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MjkzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r418092936", "bodyText": "changed the method name to uninstallWebLogicOperator.  It will uninstall whatever the TestConstants.OPERATOR_RELEASE_NAME set.", "author": "sankarpn", "createdAt": "2020-04-30T15:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDQxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024417", "bodyText": "unreliable and possibly useless anyway\nwould give wrong results if the pod was not running", "author": "markxnelson", "createdAt": "2020-04-29T01:49:28Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwODgyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417508823", "bodyText": "removed it.", "author": "sankarpn", "createdAt": "2020-04-29T18:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDUwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024500", "bodyText": "noArtifactsFound or something like that -- see earlier comment", "author": "markxnelson", "createdAt": "2020-04-29T01:49:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNTg5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417525897", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDU0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024545", "bodyText": ".. if no artifacts exist in ..", "author": "markxnelson", "createdAt": "2020-04-29T01:50:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNzMzMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417527333", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDU5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024595", "bodyText": "doesNotExist", "author": "markxnelson", "createdAt": "2020-04-29T01:50:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNzQ1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417527457", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDY0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024648", "bodyText": "probably should list which artifacts...", "author": "markxnelson", "createdAt": "2020-04-29T01:50:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNzYxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417527614", "bodyText": "added list in the log message", "author": "sankarpn", "createdAt": "2020-04-29T18:34:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDcxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024719", "bodyText": "check if any domains exist", "author": "markxnelson", "createdAt": "2020-04-29T01:50:59Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNzY3Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417527673", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDgzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417024838", "bodyText": "check if any replica sets exist (and so on through the rest of this method)", "author": "markxnelson", "createdAt": "2020-04-29T01:51:20Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyNzgyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417527820", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNDgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTA2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417025064", "bodyText": "this won't work - the fact that you are looking through the namespace means it must exist", "author": "markxnelson", "createdAt": "2020-04-29T01:52:07Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMDQ1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417510459", "bodyText": "The intention of the method is to check if all the artifacts in the namespace was deleted and namespace itself deleted.\nWhen this check is made , the delete on the namespace was already called. So it is working, to tell whether the namespace exists or not.\nSince you asked to rename this method to nothingFoundInNamespace I cannot have this check for namespace here.\nMoved the namespace and namespace delete to separate methods.", "author": "sankarpn", "createdAt": "2020-04-29T18:05:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTE3NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417025174", "bodyText": "i'd be stunned if this never threw an exception or failed", "author": "markxnelson", "createdAt": "2020-04-29T01:52:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMjY3NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417512675", "bodyText": "I am catching the exceptions in each delete operation. If I don't catch it inside this method then this method will end prematurely if there is uncaught exceptions and the delete will be only partial.", "author": "sankarpn", "createdAt": "2020-04-29T18:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTIzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417025234", "bodyText": ".. in the given ..", "author": "markxnelson", "createdAt": "2020-04-29T01:52:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {\n+    logger.info(\"Deleting artifacts in namespace {0}\", namespace);\n+\n+    // Delete all Domain objects in given namespace", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyODI1OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417528258", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-29T18:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTM3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417025376", "bodyText": "probably should do deployments before pvcs, config maps, secrets, rs's, otherwise those could fail", "author": "markxnelson", "createdAt": "2020-04-29T01:53:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CleanupUtil.java", "diffHunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1ReplicaSet;\n+import io.kubernetes.client.openapi.models.V1Role;\n+import io.kubernetes.client.openapi.models.V1RoleBinding;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.TestConstants;\n+import oracle.weblogic.kubernetes.actions.TestActions;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+\n+/**\n+ * CleanupUtil is used for cleaning up all the Kubernetes artifacts left behind by the integration tests.\n+ *\n+ */\n+public class CleanupUtil {\n+\n+  /**\n+   * Cleanup all artifacts in the Kubernetes cluster.\n+   *\n+   * <p>Tries to gracefully delete the WebLogic domains and WebLogic Operator in the namespaces, if found.\n+   * Then deletes everything in the namespaces.\n+   *\n+   * <p>Waits for the deletion task to be completed until up to 3 minutes.\n+   *\n+   * @param namespaces list of namespaces\n+   */\n+  public static void cleanup(List<String> namespaces) {\n+    try {\n+      // If namespace list is empty or null return\n+      if (namespaces == null || namespaces.isEmpty()) {\n+        return;\n+      }\n+      // iterate through the namespaces and delete domain as a\n+      // first entity if its not operator namespace\n+      for (var namespace : namespaces) {\n+        if (!isOperatorNamespace(namespace)) {\n+          deleteDomains(namespace);\n+        }\n+      }\n+      // iterate through the namespaces and delete operator if\n+      // its operator namespace.\n+      for (var namespace : namespaces) {\n+        if (isOperatorNamespace(namespace)) {\n+          uninstallOperator(namespace);\n+        }\n+      }\n+\n+      // Delete artifacts in namespace used by the test class\n+      for (var namespace : namespaces) {\n+        deleteNamespacedArtifacts(namespace);\n+      }\n+\n+      Thread.sleep(30 * 1000); // Using Thread.sleep for a one time 30 sec sleep.\n+      // If pollDelay is set to 30 seconds below, its going to sleep 30 seconds for every namespace.\n+\n+      // wait for the artifacts to be deleted, waiting for a maximum of 3 minutes\n+      ConditionFactory withStandardRetryPolicy = with().pollDelay(0, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(3, MINUTES).await();\n+\n+      for (var namespace : namespaces) {\n+        logger.info(\"Check for artifacts in namespace {0}\", namespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for artifacts to be deleted in namespace {0}, \"\n+                    + \"(elapsed time {1} , remaining time {2}\",\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(artifactsDoesntExist(namespace));\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Cleanup failed\");\n+    }\n+  }\n+\n+  /**\n+   * Delete domains in the given namespace, if exists.\n+   *\n+   * @param namespace name\n+   */\n+  private static void deleteDomains(String namespace) {\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        String domainUid = item.getMetadata().getName();\n+        Kubernetes.deleteDomainCustomResource(domainUid, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.severe(ex.getMessage());\n+      logger.severe(\"Failed to delete domain or the {0} is not a domain namespace\", namespace);\n+    }\n+  }\n+\n+  /**\n+   * Uninstalls the operator.\n+   *\n+   * @param namespace name\n+   */\n+  private static void uninstallOperator(String namespace) {\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(TestConstants.OPERATOR_RELEASE_NAME)\n+        .namespace(namespace);\n+    TestActions.uninstallOperator(opHelmParams);\n+  }\n+\n+  /**\n+   * Returns true if the namespace is operator namespace, otherwise false.\n+   *\n+   * @param namespace name\n+   * @return true if the namespace is operator namespace, otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  public static boolean isOperatorNamespace(String namespace) throws ApiException {\n+    return !Kubernetes.listPods(namespace, \"weblogic.operatorName\").getItems().isEmpty();\n+  }\n+\n+  /**\n+   * Returns true if artifacts doesn't exists in the Kubernetes cluster.\n+   *\n+   * @param namespace name\n+   * @return true if no artifacts exists otherwise false\n+   */\n+  public static Callable<Boolean> artifactsDoesntExist(String namespace) {\n+    return () -> {\n+      boolean doesnotExist = true;\n+      logger.info(\"Checking for artifacts in namespace {0}\\n\", namespace);\n+\n+      // Check if domain exists\n+      try {\n+        if (!Kubernetes.listDomains(namespace).getItems().isEmpty()) {\n+          logger.info(\"Domain still exists !!!\");\n+          List<Domain> items = Kubernetes.listDomains(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list domains\");\n+      }\n+\n+      // Check if the replica sets exist\n+      try {\n+        if (!Kubernetes.listReplicaSets(namespace).getItems().isEmpty()) {\n+          logger.info(\"ReplicaSets still exists!!!\");\n+          List<V1ReplicaSet> items = Kubernetes.listReplicaSets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list replica sets\");\n+      }\n+\n+      // check if the jobs exist\n+      try {\n+        if (!Kubernetes.listJobs(namespace).getItems().isEmpty()) {\n+          logger.info(\"Jobs still exists!!!\");\n+          List<V1Job> items = Kubernetes.listJobs(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list jobs\");\n+      }\n+\n+      // check if the configmaps exist\n+      try {\n+        if (!Kubernetes.listConfigMaps(namespace).getItems().isEmpty()) {\n+          logger.info(\"Config Maps still exists!!!\");\n+          List<V1ConfigMap> items = Kubernetes.listConfigMaps(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list config maps\");\n+      }\n+\n+      // check if the secrets exist\n+      try {\n+        if (!Kubernetes.listSecrets(namespace).getItems().isEmpty()) {\n+          logger.info(\"Secrets still exists!!!\");\n+          List<V1Secret> items = Kubernetes.listSecrets(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list secrets\");\n+      }\n+\n+      // get pvc\n+      try {\n+        if (!Kubernetes.listPersistentVolumeClaims(namespace).getItems().isEmpty()) {\n+          logger.info(\"Persistent Volumes Claims still exists!!!\");\n+          List<V1PersistentVolumeClaim> items = Kubernetes.listPersistentVolumeClaims(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volume claims\");\n+      }\n+\n+      // check if persistent volume exist\n+      try {\n+        for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+          String label = Optional.ofNullable(item)\n+              .map(pvc -> pvc.getMetadata())\n+              .map(metadata -> metadata.getLabels())\n+              .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+\n+          if (!Kubernetes.listPersistentVolumes(\n+              String.format(\"weblogic.domainUid = %s\", label))\n+              .getItems().isEmpty()) {\n+            logger.info(\"Persistent Volumes still exists!!!\");\n+            List<V1PersistentVolume> pvs = Kubernetes.listPersistentVolumes(\n+                String.format(\"weblogic.domainUid = %s\", label))\n+                .getItems();\n+            for (var pv : pvs) {\n+              logger.info(pv.getMetadata().getName());\n+            }\n+            doesnotExist = false;\n+          }\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list persistent volumes\");\n+      }\n+\n+      // check if deployments exist\n+      try {\n+        if (!Kubernetes.listDeployments(namespace).getItems().isEmpty()) {\n+          logger.info(\"Deployments still exists!!!\");\n+          List<V1Deployment> items = Kubernetes.listDeployments(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list deployments\");\n+      }\n+\n+      // check if services exist\n+      try {\n+        if (!Kubernetes.listServices(namespace).getItems().isEmpty()) {\n+          logger.info(\"Services still exists!!!\");\n+          List<V1Service> items = Kubernetes.listServices(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list services\");\n+      }\n+\n+      // check if service accounts exist\n+      try {\n+        if (!Kubernetes.listServiceAccounts(namespace).getItems().isEmpty()) {\n+          logger.info(\"Service Accounts still exists!!!\");\n+          List<V1ServiceAccount> items = Kubernetes.listServiceAccounts(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list service accounts\");\n+      }\n+\n+      // check if ingress exist\n+      try {\n+        if (!Kubernetes.listIngressExtensions(namespace).getItems().isEmpty()) {\n+          logger.info(\"Ingress Extensions still exists!!!\");\n+          List<ExtensionsV1beta1Ingress> items = Kubernetes.listIngressExtensions(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list Ingress Extensions\");\n+      }\n+\n+      // check if namespaced roles exist\n+      try {\n+        if (!Kubernetes.listNamespacedRole(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced roles still exists!!!\");\n+          List<V1Role> items = Kubernetes.listNamespacedRole(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced roles\");\n+      }\n+\n+      // check if namespaced role bindings exist\n+      try {\n+        if (!Kubernetes.listNamespacedRoleBinding(namespace).getItems().isEmpty()) {\n+          logger.info(\"Namespaced role bindings still exists!!!\");\n+          List<V1RoleBinding> items = Kubernetes.listNamespacedRoleBinding(namespace).getItems();\n+          for (var item : items) {\n+            logger.info(item.getMetadata().getName());\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaced role bindings\");\n+      }\n+\n+      // get namespaces\n+      try {\n+        if (Kubernetes.listNamespaces().contains(namespace)) {\n+          logger.info(\"Namespace still exists!!!\");\n+          List<String> items = Kubernetes.listNamespaces();\n+          for (var item : items) {\n+            logger.info(item);\n+          }\n+          doesnotExist = false;\n+        }\n+      } catch (Exception ex) {\n+        logger.warning(ex.getMessage());\n+        logger.warning(\"Failed to list namespaces\");\n+      }\n+\n+      return doesnotExist;\n+    };\n+\n+  }\n+\n+  /**\n+   * Deletes artifacts in the Kubernetes cluster in the given namespace.\n+   *\n+   * @param namespace name\n+   */\n+  public static void deleteNamespacedArtifacts(String namespace) {\n+    logger.info(\"Deleting artifacts in namespace {0}\", namespace);\n+\n+    // Delete all Domain objects in given namespace\n+    try {\n+      for (var item : Kubernetes.listDomains(namespace).getItems()) {\n+        Kubernetes.deleteDomainCustomResource(item.getMetadata().getName(), namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete domains\");\n+    }\n+\n+    // Delete replicasets\n+    try {\n+      for (var item : Kubernetes.listReplicaSets(namespace).getItems()) {\n+        Kubernetes.deleteReplicaSet(namespace, item.getMetadata().getName());\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete replica sets\");\n+    }\n+\n+    // Delete jobs\n+    try {\n+      for (var item : Kubernetes.listJobs(namespace).getItems()) {\n+        Kubernetes.deleteJob(namespace, item.getMetadata().getName());\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete jobs\");\n+    }\n+\n+    // Delete configmaps\n+    try {\n+      for (var item : Kubernetes.listConfigMaps(namespace).getItems()) {\n+        Kubernetes.deleteConfigMap(item.getMetadata().getName(), namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete config maps\");\n+    }\n+\n+    // Delete secrets\n+    try {\n+      for (var item : Kubernetes.listSecrets(namespace).getItems()) {\n+        Kubernetes.deleteSecret(item.getMetadata().getName(), namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete secrets\");\n+    }\n+\n+    // Delete pv\n+    try {\n+      for (var item : Kubernetes.listPersistentVolumeClaims(namespace).getItems()) {\n+        String label = Optional.ofNullable(item)\n+            .map(pvc -> pvc.getMetadata())\n+            .map(metadata -> metadata.getLabels())\n+            .map(labels -> labels.get(\"weblogic.domainUid\")).get();\n+        for (var pv : Kubernetes.listPersistentVolumes(\n+            String.format(\"weblogic.domainUid = %s\", label)).getItems()) {\n+          Kubernetes.deletePv(pv.getMetadata().getName());\n+        }\n+      }\n+    } catch (ApiException ex) {\n+      logger.warning(ex.getResponseBody());\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete persistent volumes\");\n+    }\n+\n+    // Delete deployments", "originalCommit": "a80b6289f74705c05595bd3a1e513a45393b8205", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyODY0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1603#discussion_r417528644", "bodyText": "moved the deployments delete above  pvcs, config maps, secrets, rs's,", "author": "sankarpn", "createdAt": "2020-04-29T18:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyNTM3Ng=="}], "type": "inlineReview"}, {"oid": "37365e01f726fc9578ef5368e18f26b56ab61f66", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/37365e01f726fc9578ef5368e18f26b56ab61f66", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into itmiiests-cleanup", "committedDate": "2020-04-29T15:24:50Z", "type": "commit"}, {"oid": "87ef1a862ba9a5d96074b16f022657cab7c76492", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/87ef1a862ba9a5d96074b16f022657cab7c76492", "message": "Addressing review comments", "committedDate": "2020-04-29T16:39:30Z", "type": "commit"}, {"oid": "716e5e6b37794ee915c94675e217a26d351af8b2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/716e5e6b37794ee915c94675e217a26d351af8b2", "message": "Refactor the methods", "committedDate": "2020-04-29T18:10:41Z", "type": "commit"}, {"oid": "a23da218815c4087bb8f0d0def887e387c6fe007", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a23da218815c4087bb8f0d0def887e387c6fe007", "message": "javadoc fix", "committedDate": "2020-04-29T18:45:21Z", "type": "commit"}, {"oid": "8da0ef56096af5bba413768b2bb264ed5d3b8394", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8da0ef56096af5bba413768b2bb264ed5d3b8394", "message": "Fix javadoc", "committedDate": "2020-04-30T15:26:21Z", "type": "commit"}, {"oid": "6de10a2552079156a0819ac8b9c07dcd382ed304", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6de10a2552079156a0819ac8b9c07dcd382ed304", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into itmiiests-cleanup", "committedDate": "2020-05-01T16:16:59Z", "type": "commit"}]}