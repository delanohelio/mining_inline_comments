{"pr_number": 1955, "pr_title": "OWLS-84562 - added tests for Namespace management enhancements", "pr_createdAt": "2020-09-28T16:32:55Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955", "timeline": [{"oid": "140d2b96b02e737627cb4b6940c24ef2b8f1bc5d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/140d2b96b02e737627cb4b6940c24ef2b8f1bc5d", "message": "added tests", "committedDate": "2020-09-22T14:58:51Z", "type": "commit"}, {"oid": "a641085a7dbb7d33f586ffe41409219ea574ef79", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a641085a7dbb7d33f586ffe41409219ea574ef79", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens", "committedDate": "2020-09-22T14:59:30Z", "type": "commit"}, {"oid": "106db1547aa2087e8aa0edd31f4723c7e85bf06d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/106db1547aa2087e8aa0edd31f4723c7e85bf06d", "message": "updated test loc", "committedDate": "2020-09-22T15:09:06Z", "type": "commit"}, {"oid": "6ce5b1e907d00dd7f2c6fa4ee1677377a4eb074b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6ce5b1e907d00dd7f2c6fa4ee1677377a4eb074b", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens", "committedDate": "2020-09-22T17:17:19Z", "type": "commit"}, {"oid": "c75e53f1e83d6df31a8a411a9b0e8de496d0f41e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c75e53f1e83d6df31a8a411a9b0e8de496d0f41e", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens", "committedDate": "2020-09-22T18:50:26Z", "type": "commit"}, {"oid": "4a64a661ab14b9af43b7ecfd6444c7f385af2a19", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4a64a661ab14b9af43b7ecfd6444c7f385af2a19", "message": "more tests", "committedDate": "2020-09-24T16:55:31Z", "type": "commit"}, {"oid": "2b30234afdddf271de6f56ba7113843e8d1d8033", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2b30234afdddf271de6f56ba7113843e8d1d8033", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens", "committedDate": "2020-09-24T16:55:44Z", "type": "commit"}, {"oid": "c5811c9115a07f804b693238e025fd8dda364f5f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c5811c9115a07f804b693238e025fd8dda364f5f", "message": "fixed default secrests management", "committedDate": "2020-09-24T18:00:47Z", "type": "commit"}, {"oid": "9eeec3cd88f8d970e5a4f593d67ab5994f77be1f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9eeec3cd88f8d970e5a4f593d67ab5994f77be1f", "message": "fixed test logic", "committedDate": "2020-09-24T18:08:49Z", "type": "commit"}, {"oid": "e72063524c0ed00c324f809d0938460420d7f566", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e72063524c0ed00c324f809d0938460420d7f566", "message": " corrected java docs", "committedDate": "2020-09-25T21:11:37Z", "type": "commit"}, {"oid": "5471cd4b007ab6ad1d18fb9fb588b4e4149ee54c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5471cd4b007ab6ad1d18fb9fb588b4e4149ee54c", "message": "fixed domainns", "committedDate": "2020-09-26T15:23:57Z", "type": "commit"}, {"oid": "f87ed1c756d7ab13857594d319d50f223ea6dbd1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f87ed1c756d7ab13857594d319d50f223ea6dbd1", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens", "committedDate": "2020-09-26T17:46:20Z", "type": "commit"}, {"oid": "ae34821a7a98dcecbb7718e1d7ebd9a149786230", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ae34821a7a98dcecbb7718e1d7ebd9a149786230", "message": "fixed secret creation", "committedDate": "2020-09-27T15:43:41Z", "type": "commit"}, {"oid": "141fec060b1432c2f9b141aae1dad39e515dd823", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/141fec060b1432c2f9b141aae1dad39e515dd823", "message": "fixed secret dependencies", "committedDate": "2020-09-28T16:00:45Z", "type": "commit"}, {"oid": "e6de215c5dd50e54cb61c58f26a69926d832be98", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e6de215c5dd50e54cb61c58f26a69926d832be98", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens", "committedDate": "2020-09-28T16:01:21Z", "type": "commit"}, {"oid": "504769d961f4eade6c06e75d4d102a7b763191cc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/504769d961f4eade6c06e75d4d102a7b763191cc", "message": "fixed default domain crd dependencies", "committedDate": "2020-09-28T17:03:19Z", "type": "commit"}, {"oid": "4371dc02289a36bb4018e0861ce6dc7e0d03d0f9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4371dc02289a36bb4018e0861ce6dc7e0d03d0f9", "message": "fixed check pod creation", "committedDate": "2020-09-30T19:14:45Z", "type": "commit"}, {"oid": "03995b8e37d3efd21554a1ef40278c78f35d6059", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/03995b8e37d3efd21554a1ef40278c78f35d6059", "message": "style", "committedDate": "2020-09-30T19:23:06Z", "type": "commit"}, {"oid": "65739531a71c1d18e48d8bbd88520f896dc8f99c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/65739531a71c1d18e48d8bbd88520f896dc8f99c", "message": "added rbac test", "committedDate": "2020-09-30T23:12:47Z", "type": "commit"}, {"oid": "b1bd13437830539e3356da4f154e9bfa2ea319ed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b1bd13437830539e3356da4f154e9bfa2ea319ed", "message": "added rbac test, corrected ns label", "committedDate": "2020-09-30T23:47:05Z", "type": "commit"}, {"oid": "ce3511363ac30d7d102bc5efb65a2012d81da2bc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ce3511363ac30d7d102bc5efb65a2012d81da2bc", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens", "committedDate": "2020-09-30T23:47:19Z", "type": "commit"}, {"oid": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens", "committedDate": "2020-10-01T22:58:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NDc1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498964757", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static String opNamespace = null;\n          \n          \n            \n              private static String op1Namespace = null;", "author": "sankarpn", "createdAt": "2020-10-02T17:50:29Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MjIzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500342230", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NDc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NTE5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498965190", "bodyText": "can you use an array instead of defining so many variables of same type?", "author": "sankarpn", "createdAt": "2020-10-02T17:51:30Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NTYyNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498965625", "bodyText": "please use an array and loop to assign ns", "author": "sankarpn", "createdAt": "2020-10-02T17:52:29Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MjQxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500342410", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NTYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NTkyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498965921", "bodyText": "isn't this already available in the registry?", "author": "sankarpn", "createdAt": "2020-10-02T17:53:07Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MjYyNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500342624", "bodyText": "removed", "author": "marinakog", "createdAt": "2020-10-06T14:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NTkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NjQ5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498966490", "bodyText": "use arrays and loops", "author": "sankarpn", "createdAt": "2020-10-02T17:54:13Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MjUwOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500342509", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NjQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NjczNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498966737", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Deploy two custom domain resources in the two different namespaces with names starting with test\n          \n          \n            \n               * Deploy two custom domain resources in two different namespaces with names starting with test", "author": "sankarpn", "createdAt": "2020-10-02T17:54:46Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2ODI0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498968244", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n          \n          \n            \n                createSecretWithUsernamePassword(adminSecretName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);", "author": "sankarpn", "createdAt": "2020-10-02T17:58:01Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2ODg1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498968859", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n          \n          \n            \n               * Install WebLogic operator and wait up to two minutes for the operator pod to be ready.", "author": "sankarpn", "createdAt": "2020-10-02T17:59:15Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+  }\n+\n+  private static void deleteSecrets(String domainNamespace) {\n+    logger.info(\"Deleting docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      deleteSecret(OCR_SECRET_NAME, domainNamespace);\n+    }\n+\n+    // delete secret for admin credentials\n+    logger.info(\"Deleting secret for admin credentials\");\n+    deleteSecret(adminSecretName, domainNamespace);\n+\n+    // delete encryption secret\n+    logger.info(\"Deleting encryption secret\");\n+    deleteSecret(encryptionSecretName, domainNamespace);\n+  }\n+\n+  private void createVerifyDomain(String domainNamespace, String domainUid, String miiImage, Domain domain) {\n+    // create domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+    String adminServerPodName = domainUid + adminServerPrefix;\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domainUid + managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2OTA1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498969057", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param operNamespace the operator namespace in which the operator will be installed\n          \n          \n            \n               * @param operNamespace the namespace in which the operator is installed", "author": "sankarpn", "createdAt": "2020-10-02T17:59:42Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+  }\n+\n+  private static void deleteSecrets(String domainNamespace) {\n+    logger.info(\"Deleting docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      deleteSecret(OCR_SECRET_NAME, domainNamespace);\n+    }\n+\n+    // delete secret for admin credentials\n+    logger.info(\"Deleting secret for admin credentials\");\n+    deleteSecret(adminSecretName, domainNamespace);\n+\n+    // delete encryption secret\n+    logger.info(\"Deleting encryption secret\");\n+    deleteSecret(encryptionSecretName, domainNamespace);\n+  }\n+\n+  private void createVerifyDomain(String domainNamespace, String domainUid, String miiImage, Domain domain) {\n+    // create domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+    String adminServerPodName = domainUid + adminServerPrefix;\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domainUid + managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2OTMyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498969320", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n          \n          \n            \n               * @param domainNamespace the list of the domain namespaces managed by the operator", "author": "sankarpn", "createdAt": "2020-10-02T18:00:15Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+  }\n+\n+  private static void deleteSecrets(String domainNamespace) {\n+    logger.info(\"Deleting docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      deleteSecret(OCR_SECRET_NAME, domainNamespace);\n+    }\n+\n+    // delete secret for admin credentials\n+    logger.info(\"Deleting secret for admin credentials\");\n+    deleteSecret(adminSecretName, domainNamespace);\n+\n+    // delete encryption secret\n+    logger.info(\"Deleting encryption secret\");\n+    deleteSecret(encryptionSecretName, domainNamespace);\n+  }\n+\n+  private void createVerifyDomain(String domainNamespace, String domainUid, String miiImage, Domain domain) {\n+    // create domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+    String adminServerPodName = domainUid + adminServerPrefix;\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domainUid + managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed\n+   * @param opReleaseName the operator release name\n+   * @param enableClusterRoleBinding operator cluster role binding\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2OTYwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498969602", "bodyText": "You can define a class level logger and use it in all the methods", "author": "sankarpn", "createdAt": "2020-10-02T18:00:51Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+  }\n+\n+  private static void deleteSecrets(String domainNamespace) {\n+    logger.info(\"Deleting docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      deleteSecret(OCR_SECRET_NAME, domainNamespace);\n+    }\n+\n+    // delete secret for admin credentials\n+    logger.info(\"Deleting secret for admin credentials\");\n+    deleteSecret(adminSecretName, domainNamespace);\n+\n+    // delete encryption secret\n+    logger.info(\"Deleting encryption secret\");\n+    deleteSecret(encryptionSecretName, domainNamespace);\n+  }\n+\n+  private void createVerifyDomain(String domainNamespace, String domainUid, String miiImage, Domain domain) {\n+    // create domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+    String adminServerPodName = domainUid + adminServerPrefix;\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domainUid + managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed\n+   * @param opReleaseName the operator release name\n+   * @param enableClusterRoleBinding operator cluster role binding\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  private static HelmParams installOperatorHelmChart(String opReleaseName, String operNamespace,\n+                                                     String domainNsSelectionStrategy,\n+                                                     String domainNsSelector,\n+                                                     boolean enableClusterRoleBinding,\n+                                                     String... domainNamespace) {\n+    LoggingFacade logger = getLogger();", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0Mjc5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500342794", "bodyText": "done", "author": "marinakog", "createdAt": "2020-10-06T14:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2OTYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MDkzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498970939", "bodyText": "incomplete sentence", "author": "sankarpn", "createdAt": "2020-10-02T18:03:39Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -703,6 +704,34 @@ public static boolean createNamespace(String name) throws ApiException {\n     return true;\n   }\n \n+  // --------------------------- namespaces -----------------------------------\n+  /**\n+   * Create a Kubernetes namespace.\n+   *\n+   * @param name the name of the namespace\n+   * @param labels list of labels for the namespace\n+   * @return true on success, false otherwise\n+   * @throws ApiException if Kubernetes client API call", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MjkwOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500342909", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MDkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MTQ4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498971488", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * List namespaces in the Kubernetes cluster.\n          \n          \n            \n               * List namespaces in the Kubernetes cluster matching the label selector.", "author": "sankarpn", "createdAt": "2020-10-02T18:04:49Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -760,6 +789,15 @@ public static void replaceNamespace(V1Namespace ns) throws ApiException {\n    * @throws ApiException if Kubernetes client API call fails\n    */\n   public static List<String> listNamespaces() throws ApiException {\n+    return listNamespaces(null);\n+  }\n+\n+  /**\n+   * List namespaces in the Kubernetes cluster.", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MzA2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500343064", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MTQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MTcyOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498971728", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * return namespace by provided name in the Kubernetes cluster as V1Namespace object.\n          \n          \n            \n               * Return namespace object for the given name from the Kubernetes cluster as V1Namespace object.", "author": "sankarpn", "createdAt": "2020-10-02T18:05:17Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -813,6 +851,39 @@ public static V1NamespaceList listNamespacesAsObjects() throws ApiException {\n     return namespaceList;\n   }\n \n+  /**\n+   * return namespace by provided name in the Kubernetes cluster as V1Namespace object.", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MzE3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500343177", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MTcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MjM3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r498972377", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return V1Namespace of Namespace in the Kubernetes cluster\n          \n          \n            \n               * @return V1Namespace  Namespace object from the Kubernetes cluster", "author": "sankarpn", "createdAt": "2020-10-02T18:06:46Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -813,6 +851,39 @@ public static V1NamespaceList listNamespacesAsObjects() throws ApiException {\n     return namespaceList;\n   }\n \n+  /**\n+   * return namespace by provided name in the Kubernetes cluster as V1Namespace object.\n+   * @name name of namespace.\n+   * @return V1Namespace of Namespace in the Kubernetes cluster", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MzI3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500343276", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MjM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMDA4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499820083", "bodyText": "move this method to CommonTestUtils", "author": "vanajamukkara", "createdAt": "2020-10-05T19:24:07Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+  }\n+\n+  private static void deleteSecrets(String domainNamespace) {\n+    logger.info(\"Deleting docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      deleteSecret(OCR_SECRET_NAME, domainNamespace);\n+    }\n+\n+    // delete secret for admin credentials\n+    logger.info(\"Deleting secret for admin credentials\");\n+    deleteSecret(adminSecretName, domainNamespace);\n+\n+    // delete encryption secret\n+    logger.info(\"Deleting encryption secret\");\n+    deleteSecret(encryptionSecretName, domainNamespace);\n+  }\n+\n+  private void createVerifyDomain(String domainNamespace, String domainUid, String miiImage, Domain domain) {\n+    // create domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+    String adminServerPodName = domainUid + adminServerPrefix;\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domainUid + managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed\n+   * @param opReleaseName the operator release name\n+   * @param enableClusterRoleBinding operator cluster role binding\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  private static HelmParams installOperatorHelmChart(String opReleaseName, String operNamespace,", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3MDMyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500470320", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T17:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMDA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMTg0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499821845", "bodyText": "domainNsSelectionStrategy is not used", "author": "vanajamukkara", "createdAt": "2020-10-05T19:27:29Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MzM4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500343385", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMTg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMzU5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499823594", "bodyText": "can u call this variable something else, its confusing as there is already a variable domain3Namespace", "author": "vanajamukkara", "createdAt": "2020-10-05T19:30:53Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MzUwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500343506", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMzU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyNjk2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499826960", "bodyText": "change method name to createDomainCrAndVerifyDomainIsRunning or some such", "author": "vanajamukkara", "createdAt": "2020-10-05T19:37:17Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MzYzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500343639", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:39:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyNjk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyNzIzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499827239", "bodyText": "is catch really needed here?", "author": "vanajamukkara", "createdAt": "2020-10-05T19:37:53Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0MzczNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500343734", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:39:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyNzIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyNzg2NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499827865", "bodyText": "Update use case description for this step", "author": "vanajamukkara", "createdAt": "2020-10-05T19:39:07Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0NDA3Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500344072", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:39:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyNzg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgzMDE2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499830168", "bodyText": "this check can be moved outside of this method", "author": "vanajamukkara", "createdAt": "2020-10-05T19:43:47Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM0NDE4Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500344187", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T14:39:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgzMDE2OA=="}], "type": "inlineReview"}, {"oid": "5a5e5b8d35657aec01673ea52353950b70bd7420", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5a5e5b8d35657aec01673ea52353950b70bd7420", "message": "addressed comments from review", "committedDate": "2020-10-05T22:52:06Z", "type": "commit"}, {"oid": "a34bdad31d9f4be3aa6001827e0e2c4868082ed0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a34bdad31d9f4be3aa6001827e0e2c4868082ed0", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens", "committedDate": "2020-10-05T22:52:15Z", "type": "commit"}, {"oid": "e8094ec2c1840985cb91ad6d5881dc24b5f4bbe6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e8094ec2c1840985cb91ad6d5881dc24b5f4bbe6", "message": "addressed comments from review1", "committedDate": "2020-10-05T23:29:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxOTg4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500419882", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Return Namespace object for the given name from the Kubernetes cluster as V1Namespace object..\n          \n          \n            \n               * Return Namespace object for the given name from the Kubernetes cluster as V1Namespace object.", "author": "sankarpn", "createdAt": "2020-10-06T16:05:20Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -813,6 +851,39 @@ public static V1NamespaceList listNamespacesAsObjects() throws ApiException {\n     return namespaceList;\n   }\n \n+  /**\n+   * Return Namespace object for the given name from the Kubernetes cluster as V1Namespace object..", "originalCommit": "e8094ec2c1840985cb91ad6d5881dc24b5f4bbe6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3MTE1OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500471158", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-10-06T17:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxOTg4Mg=="}], "type": "inlineReview"}, {"oid": "d2e726750020e9256617902446f7e472b92fb972", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d2e726750020e9256617902446f7e472b92fb972", "message": "addressed comments from review2", "committedDate": "2020-10-06T17:25:02Z", "type": "commit"}, {"oid": "1586bbc49253812267c10dff605581af863931c5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1586bbc49253812267c10dff605581af863931c5", "message": "addressed comments from review3", "committedDate": "2020-10-06T18:02:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0MjE0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r499842140", "bodyText": "use checkPodDoesNotExist in CommonTestUtils", "author": "vanajamukkara", "createdAt": "2020-10-05T20:06:56Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,824 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretList;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listSecrets;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.checkHelmReleaseStatus;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorRestServiceRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createExternalRestIdentitySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String opNamespace = null;\n+  private static String op2Namespace = null;\n+  private static String op3Namespace = null;\n+  private static String op4Namespace = null;\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain3Namespace = null;\n+  private static String domain4Namespace = null;\n+\n+  // domain constants\n+  private final String domain1Uid = \"managensdomain1\";\n+  private final String domain2Uid = \"managensdomain2\";\n+  private final String domain3Uid = \"managensdomain3\";\n+  private final String domain4Uid = \"managensdomain4\";\n+\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams opHelmParams1;\n+  private HelmParams opHelmParams2;\n+  private HelmParams opHelmParams4;\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain1 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain2 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique domain3 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 3\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    domain3Namespace = namespaces.get(3);\n+\n+    // get a unique domain4 namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 4\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    domain4Namespace = namespaces.get(4);\n+\n+    // get a unique operator 2 namespace\n+    logger.info(\"Getting a unique namespace for operator 2\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    op2Namespace = namespaces.get(5);\n+\n+    // get a unique operator 3 namespace\n+    logger.info(\"Getting a unique namespace for operator 3\");\n+    assertNotNull(namespaces.get(6), \"Namespace list is null\");\n+    op3Namespace = namespaces.get(6);\n+\n+    // get a unique operator 4 namespace\n+    logger.info(\"Getting a unique namespace for operator 4\");\n+    assertNotNull(namespaces.get(7), \"Namespace list is null\");\n+    op4Namespace = namespaces.get(7);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+    createSecrets(domain3Namespace);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domain1Namespace, labels1);\n+    setLabelToNamespace(domain2Namespace, labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain1 custom resource in namespace {0}\", domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid, domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2 custom resource in namespace {0}\", domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid, domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \" from \" + domain2Namespace);\n+\n+    logger.info(\"Delete domain3 custom resource in namespace {0}\", domain3Namespace);\n+    deleteDomainCustomResource(domain3Uid, domain3Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain3Uid);\n+\n+    logger.info(\"Delete domain4 custom resource in namespace {0}\", domain4Namespace);\n+    deleteDomainCustomResource(domain4Uid, domain4Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain4Uid);\n+\n+    logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domain1Namespace);\n+    deleteDomainCustomResource(domain1Uid + \"test\", \"test-\" + domain1Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \"test from test-\" + domain1Namespace);\n+\n+    logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domain2Namespace);\n+    deleteDomainCustomResource(domain2Uid + \"test\", \"test-\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource \" + domain2Uid + \"test from test-\" + domain2Namespace);\n+\n+    logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domain2Namespace);\n+    deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domain2Namespace);\n+    logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domain2Namespace);\n+\n+    deleteSecrets(\"default\");\n+    deleteSecrets(\"atest-\" +  domain1Namespace);;\n+    deleteNamespace(\"atest-\" + domain1Namespace);\n+    //delete operator\n+    uninstallOperator(opHelmParams1);\n+    uninstallOperator(opHelmParams2);\n+    uninstallOperator(opHelmParams4);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= domain3NS.\n+   * Deploy two custom domain resources in the two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace domain3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domain1Namespace;\n+    String manageByExp2NS = \"test-\" +  domain2Namespace;\n+    String manageByExpDomain1Uid = \"test-\" + domain1Uid;\n+    String manageByExpDomain2Uid = \"test-\" + domain2Uid;\n+    String manageByLabelNS = \"weblogic1\" + domain1Namespace;\n+    String manageByLabelDomainUid = \"weblogic1\" + domain1Uid;\n+    String domain3NS = \"atest-\" +  domain1Namespace;\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(domain3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3Namespace);\n+    checkDomainNotStartedInDefaultNS(\"RegExp\");\n+    //verify that operator can't start domain if namespace does not start from test\n+    createSecrets(domain3NS);\n+    checkPodNotCreated(domain3Uid + adminServerPrefix, domain3Uid, domain3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domain1Namespace;\n+    String manageByLabelDomain2NS = domain2Namespace;\n+    String manageByExpDomainUid = \"weblogic2\" + domain2Namespace;\n+    String manageByExpDomainNS = \"weblogic2\" + domain2Namespace;\n+    String manageByLabelDomain1Uid = domain1Uid;\n+    String manageByLabelDomain2Uid = domain2Uid;\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS(\"SelectLabel\");\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domain1Namespace + \"test4\";\n+    String manageByLabelDomainUid = domain1Uid + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams4 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op4Namespace, \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(op4Namespace, \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams4);\n+\n+    assertTrue(upgradeAndVerifyOperator(op4Namespace, opParams));\n+    assertTrue(startDomain(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op4Namespace, manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespace, opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams1)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(startDomain(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespace,manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespace, manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(startDomain(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespace, domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams1 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        opNamespace, \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(startDomain(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);\n+\n+    checkOperatorCanScaleDomain(opNamespace, manageByLabelDomain1Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain4 will not start\n+    createSecrets(domain4Namespace);\n+    checkPodNotCreated(domain4Uid + adminServerPrefix, domain4Uid, domain4Namespace);\n+\n+    //verify that domain2 in namespace with no label2 will not start\n+    createSecrets(manageByLabelDomain2NS);\n+    checkPodNotCreated(manageByLabelDomain2Uid + adminServerPrefix, manageByLabelDomain2Uid, manageByLabelDomain2NS);\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    try {\n+      HelmParams opHelmParams3 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+          op3Namespace, \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams3, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS(String domainNsSelectionStrategy) {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private void switchNSManagementToLabelSelectUsingUpgradeOperator(String manageByLabelNS,\n+                                                                   String manageByExpNS,\n+                                                                   String manageByLabelDomainUid,\n+                                                                   String manageByExpDomainUid) {\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams2)\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(startDomain(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(op2Namespace,manageByLabelDomainUid);\n+    //check operator can't manage anymore manageByExpNS\n+    assertTrue(isOperatorFailedToScaleDomain(op2Namespace, manageByExpDomainUid,\n+        manageByExpNS), \"Operator can still manage domain \"\n+        + manageByExpNS + \" in the namespace \" + manageByExpNS);\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByNSRegExp(String manageByExp1NS,\n+                                                                 String manageByExp2NS,\n+                                                                 String manageByExpDomain1Uid,\n+                                                                 String manageByExpDomain2Uid) {\n+    // install and verify operator with domainNsSelectStrategy=RegExp to manage domains with namespaces names,\n+    // starting from test\n+    opHelmParams2 = installOperatorHelmChart(OPERATOR_RELEASE_NAME,\n+        op2Namespace, \"RegExp\", \"^test\", true, domain3Namespace);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByExp1NS);\n+    assertTrue(startDomain(manageByExp1NS, manageByExpDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByExp1NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain1Uid);\n+\n+    logger.info(\"Installing and verifying domain2\");\n+    createSecrets(manageByExp2NS);\n+    assertTrue(startDomain(manageByExp2NS, manageByExpDomain2Uid),\n+        \"operator can start or verify domain in namespace \" + manageByExp2NS);\n+    checkOperatorCanScaleDomain(op2Namespace, manageByExpDomain2Uid);\n+  }\n+\n+\n+  private boolean startDomain(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    try {\n+      Domain domain = createDomainCRD(domainNamespace, domainUid);\n+      createVerifyDomain(domainNamespace, domainUid, miiImage, domain);\n+      return true;\n+    } catch (Exception ex) {\n+      logger.info(\"Failed to createVerifyDomain \" + ex.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {\n+\n+    // construct a list of oracle.weblogic.domain.Cluster objects to be used in the domain custom resource\n+    List<Cluster> clusters = new ArrayList<>();\n+    clusters.add(new Cluster()\n+        .clusterName(clusterName)\n+        .replicas(replicaCount)\n+        .serverStartState(\"RUNNING\"));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new oracle.weblogic.domain.AdminService()\n+                    .addChannelsItem(new oracle.weblogic.domain.Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .clusters(clusters)\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(WLS_DOMAIN_TYPE)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+    return domain;\n+  }\n+\n+  private static void createSecrets(String domainNamespace) {\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Creating docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      createDockerRegistrySecret(domainNamespace);\n+    }\n+\n+    // create secret for admin credentials\n+    logger.info(\"Creating secret for admin credentials\");\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \"weblogic\", \"welcome1\");\n+\n+    // create encryption secret\n+    logger.info(\"Creating encryption secret\");\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \"weblogicenc\", \"weblogicenc\");\n+  }\n+\n+  private static void deleteSecrets(String domainNamespace) {\n+    logger.info(\"Deleting docker registry secret in namespace {0}\", domainNamespace);\n+    if (!domainNamespace.equals(\"default\")) {\n+      deleteSecret(OCR_SECRET_NAME, domainNamespace);\n+    }\n+\n+    // delete secret for admin credentials\n+    logger.info(\"Deleting secret for admin credentials\");\n+    deleteSecret(adminSecretName, domainNamespace);\n+\n+    // delete encryption secret\n+    logger.info(\"Deleting encryption secret\");\n+    deleteSecret(encryptionSecretName, domainNamespace);\n+  }\n+\n+  private void createVerifyDomain(String domainNamespace, String domainUid, String miiImage, Domain domain) {\n+    // create domain\n+    logger.info(\"Creating model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainAndVerify(domain, domainNamespace);\n+    String adminServerPodName = domainUid + adminServerPrefix;\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = domainUid + managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPodName, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed\n+   * @param opReleaseName the operator release name\n+   * @param enableClusterRoleBinding operator cluster role binding\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  private static HelmParams installOperatorHelmChart(String opReleaseName, String operNamespace,\n+                                                     String domainNsSelectionStrategy,\n+                                                     String domainNsSelector,\n+                                                     boolean enableClusterRoleBinding,\n+                                                     String... domainNamespace) {\n+    LoggingFacade logger = getLogger();\n+\n+    HelmParams opHelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(operNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Create a service account for the unique operNamespace\n+    logger.info(\"Creating service account\");\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(operNamespace)\n+            .name(opReleaseName + \"-sa\"))));\n+    logger.info(\"Created service account: {0}\", opReleaseName + \"-sa\");\n+\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+\n+    V1SecretList listSecrets = listSecrets(operNamespace);\n+    if (null != listSecrets) {\n+      for (V1Secret item : listSecrets.getItems()) {\n+        if (item.getMetadata().getName().equals(REPO_SECRET_NAME)) {\n+          break;\n+        }\n+      }\n+      // Create Docker registry secret in the operator namespace to pull the image from repository\n+      logger.info(\"Creating Docker registry secret in namespace {0}\", operNamespace);\n+      createDockerRegistrySecret(operNamespace);\n+    }\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(java.util.Arrays.asList(domainNamespace))\n+        .enableClusterRoleBinding(enableClusterRoleBinding)\n+        .serviceAccount(opReleaseName + \"-sa\");\n+    if (domainNsSelectionStrategy != null) {\n+      opParams.domainNamespaceSelectionStrategy(domainNsSelectionStrategy);\n+      if (domainNsSelectionStrategy.equalsIgnoreCase(\"LabelSelector\")) {\n+        opParams.domainNamespaceLabelSelector(domainNsSelector);\n+      } else if (domainNsSelectionStrategy.equalsIgnoreCase(\"RegExp\")) {\n+        opParams.domainNamespaceRegExp(domainNsSelector);\n+      }\n+    }\n+\n+    // use default image in chart when repoUrl is set, otherwise use latest/current branch operator image\n+    if (opHelmParams.getRepoUrl() == null) {\n+      opParams.image(operatorImage);\n+    }\n+\n+    // create externalRestIdentitySecret\n+    assertTrue(createExternalRestIdentitySecret(operNamespace,\n+        DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME + operNamespace),\n+        \"failed to create external REST identity secret\");\n+    opParams\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(0)\n+        .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME + operNamespace);\n+\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", operNamespace);\n+\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s \", operNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", operNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        opReleaseName, operNamespace);\n+\n+    assertTrue(checkHelmReleaseStatus(opReleaseName, operNamespace, \"deployed\"),\n+        String.format(\"Operator release %s is not in %s status in namespace %s\",\n+            opReleaseName, \"deployed\", operNamespace));\n+    logger.info(\"Operator release {0} status is {1} in namespace {2}\",\n+        opReleaseName, \"deployed\", operNamespace);\n+\n+    // wait for the operator to be ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", operNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                operNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(operNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+\n+    logger.info(\"Wait for the operator external service in namespace {0}\", operNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator external service in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                operNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorRestServiceRunning(operNamespace),\n+            \"operator external service is not running\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  private void checkPodNotCreated(String podName, String domainUid, String domNamespace) {", "originalCommit": "2f7e78cece4496d7be6e42ec72deec2f2648b5d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNDM2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501204369", "bodyText": "done", "author": "marinakog", "createdAt": "2020-10-07T17:56:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0MjE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5NTI5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500495294", "bodyText": "this check is not needed, createOcirRepoSecret() takes care of that", "author": "vanajamukkara", "createdAt": "2020-10-06T18:05:22Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -453,6 +454,133 @@ public static HelmParams installAndVerifyOperator(String opNamespace,\n     return opHelmParams;\n   }\n \n+  /**\n+   * Install WebLogic operator and wait up to two minutes until the operator pod is ready.\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed\n+   * @param opReleaseName the operator release name\n+   * @param domainNsSelectionStrategy SelectLabel, RegExp or List\n+   * @param domainNsSelector the label or expression value to manage namespaces\n+   * @param enableClusterRoleBinding operator cluster role binding\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   *                        (only in case of List selector)\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opReleaseName, String operNamespace,\n+                                                     String domainNsSelectionStrategy,\n+                                                     String domainNsSelector,\n+                                                     boolean enableClusterRoleBinding,\n+                                                     String... domainNamespace) {\n+\n+    HelmParams opHelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(operNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    LoggingFacade logger = getLogger();\n+    // Create a service account for the unique operNamespace\n+    logger.info(\"Creating service account\");\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(operNamespace)\n+            .name(opReleaseName + \"-sa\"))));\n+    logger.info(\"Created service account: {0}\", opReleaseName + \"-sa\");\n+\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+\n+    V1SecretList listSecrets = oracle.weblogic.kubernetes.actions.TestActions.listSecrets(operNamespace);", "originalCommit": "d2e726750020e9256617902446f7e472b92fb972", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNDMxMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501204311", "bodyText": "done", "author": "marinakog", "createdAt": "2020-10-07T17:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5NTI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5Njg4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500496888", "bodyText": "there is lot of duplicate code in this method and the existing installAndVerifyOperator() method, refactor the methods to avoid code duplication", "author": "vanajamukkara", "createdAt": "2020-10-06T18:08:01Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -453,6 +454,133 @@ public static HelmParams installAndVerifyOperator(String opNamespace,\n     return opHelmParams;\n   }\n \n+  /**", "originalCommit": "1586bbc49253812267c10dff605581af863931c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwMzgyNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501203824", "bodyText": "done", "author": "marinakog", "createdAt": "2020-10-07T17:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5Njg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5NzgzMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500497833", "bodyText": "move this check outside of the method", "author": "vanajamukkara", "createdAt": "2020-10-06T18:09:39Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,633 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domainsUid[2] + adminServerPrefix, domainsUid[2], domainNamespaces[2]);\n+    checkDomainNotStartedInDefaultNS();\n+    //verify that operator can't start domain if namespace name does not start from test\n+    createSecrets(manageByExp3NS);\n+    checkPodNotCreated(domainsUid[2] + adminServerPrefix, domainsUid[2], manageByExp3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domainNamespaces[0];\n+    String manageByLabelDomain2NS = domainNamespaces[1];\n+    String manageByExpDomainUid = \"weblogic2\" + domainNamespaces[1];\n+    String manageByExpDomainNS = \"weblogic2\" + domainNamespaces[1];\n+    String manageByLabelDomain1Uid = domainsUid[0];\n+    String manageByLabelDomain2Uid = domainsUid[1];\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS();\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domainNamespaces[0] + \"test4\";\n+    String manageByLabelDomainUid = domainsUid[0] + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams[2] = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+        opNamespaces[3], \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[3], \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams[2]);\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[3], opParams));\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[3], manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespaces[0], opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[0], opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[0],manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[0], manageByLabelDomainUid, manageByLabelNS),", "originalCommit": "1586bbc49253812267c10dff605581af863931c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwMzc2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501203762", "bodyText": "done", "author": "marinakog", "createdAt": "2020-10-07T17:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5NzgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5ODUyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500498522", "bodyText": "leave blank line after this line for better code readability", "author": "vanajamukkara", "createdAt": "2020-10-06T18:10:38Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,633 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domainsUid[2] + adminServerPrefix, domainsUid[2], domainNamespaces[2]);\n+    checkDomainNotStartedInDefaultNS();\n+    //verify that operator can't start domain if namespace name does not start from test\n+    createSecrets(manageByExp3NS);\n+    checkPodNotCreated(domainsUid[2] + adminServerPrefix, domainsUid[2], manageByExp3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domainNamespaces[0];\n+    String manageByLabelDomain2NS = domainNamespaces[1];\n+    String manageByExpDomainUid = \"weblogic2\" + domainNamespaces[1];\n+    String manageByExpDomainNS = \"weblogic2\" + domainNamespaces[1];\n+    String manageByLabelDomain1Uid = domainsUid[0];\n+    String manageByLabelDomain2Uid = domainsUid[1];", "originalCommit": "1586bbc49253812267c10dff605581af863931c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwMzY5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501203693", "bodyText": "done", "author": "marinakog", "createdAt": "2020-10-07T17:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5ODUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5OTQwNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r500499407", "bodyText": "failed to create domain custom resource or domain is not started in namespace", "author": "vanajamukkara", "createdAt": "2020-10-06T18:12:02Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,633 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+    installAndVerifyOperatorCanManageDomainByNSRegExp(manageByExp1NS, manageByExp2NS,\n+        manageByExpDomain1Uid, manageByExpDomain2Uid);\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for specific NS and default\n+    checkPodNotCreated(domainsUid[2] + adminServerPrefix, domainsUid[2], domainNamespaces[2]);\n+    checkDomainNotStartedInDefaultNS();\n+    //verify that operator can't start domain if namespace name does not start from test\n+    createSecrets(manageByExp3NS);\n+    checkPodNotCreated(domainsUid[2] + adminServerPrefix, domainsUid[2], manageByExp3NS);\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+    switchNSManagementToLabelSelectUsingUpgradeOperator(manageByLabelNS, manageByExp1NS,\n+        manageByLabelDomainUid, manageByExpDomain1Uid);\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    String manageByLabelDomain1NS = domainNamespaces[0];\n+    String manageByLabelDomain2NS = domainNamespaces[1];\n+    String manageByExpDomainUid = \"weblogic2\" + domainNamespaces[1];\n+    String manageByExpDomainNS = \"weblogic2\" + domainNamespaces[1];\n+    String manageByLabelDomain1Uid = domainsUid[0];\n+    String manageByLabelDomain2Uid = domainsUid[1];\n+    installAndVerifyOperatorCanManageDomainByLabelSelector(manageByLabelDomain1NS, manageByLabelDomain2NS,\n+        manageByLabelDomain1Uid, manageByLabelDomain2Uid);\n+    addExtraDomainByAddingLabelToNS(labels1, manageByLabelDomain2NS, manageByLabelDomain2Uid);\n+    checkDomainNotStartedInDefaultNS();\n+    checkSecondOperatorFailedToShareSameNS(manageByLabelDomain1NS);\n+    switchNSManagementToRegExpUsingUpgradeOperator(manageByLabelDomain1NS, manageByExpDomainNS,\n+        manageByLabelDomain1Uid, manageByExpDomainUid);\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domainNamespaces[0] + \"test4\";\n+    String manageByLabelDomainUid = domainsUid[0] + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams[2] = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+        opNamespaces[3], \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[3], \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams[2]);\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[3], opParams));\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[3], manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespaces[0], opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void switchNSManagementToRegExpUsingUpgradeOperator(String manageByLabelNS,\n+                                                              String manageByExpNS,\n+                                                              String manageByLabelDomainUid,\n+                                                              String manageByExpDomainUid) {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[0], opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByExpNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[0],manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[0], manageByLabelDomainUid, manageByLabelNS),\n+        \"Operator can still manage domain \"\n+        + manageByLabelDomainUid + \" in the namespace \" + manageByLabelNS);\n+  }\n+\n+  private void addExtraDomainByAddingLabelToNS(Map<String, String> labels, String domainNS, String domainUid) {\n+    deleteDomainCrd(domainNS, domainUid);\n+\n+    //switch to the label1, managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNS, labels);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(domainNS, domainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[0], domainUid);\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private void installAndVerifyOperatorCanManageDomainByLabelSelector(String manageByLabelDomain1NS,\n+                                                                      String manageByLabelDomain2NS,\n+                                                                      String manageByLabelDomain1Uid,\n+                                                                      String manageByLabelDomain2Uid) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces set to domain4 will be ignored\n+    opHelmParams[0] = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+        opNamespaces[0], \"LabelSelector\",\n+        OPERATOR_RELEASE_NAME, true, manageByLabelDomain1NS);\n+\n+    logger.info(\"Installing and verifying domain1\");\n+    createSecrets(manageByLabelDomain1NS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelDomain1NS, manageByLabelDomain1Uid),\n+        \"can't start or verify domain in namespace \" + manageByLabelDomain1NS);", "originalCommit": "1586bbc49253812267c10dff605581af863931c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwMzA1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501203059", "bodyText": "done", "author": "marinakog", "createdAt": "2020-10-07T17:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5OTQwNw=="}], "type": "inlineReview"}, {"oid": "03007f1f0bc9107972b0bb477856aae6435c3a1c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/03007f1f0bc9107972b0bb477856aae6435c3a1c", "message": "addressed more comments", "committedDate": "2020-10-07T15:58:54Z", "type": "commit"}, {"oid": "e440194a2eaacca9c523301ec19abaffe746f117", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e440194a2eaacca9c523301ec19abaffe746f117", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into managens", "committedDate": "2020-10-07T15:59:02Z", "type": "commit"}, {"oid": "24e6cc6df8e149b5fb261a47a8525a040b78af14", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/24e6cc6df8e149b5fb261a47a8525a040b78af14", "message": "style", "committedDate": "2020-10-07T16:23:52Z", "type": "commit"}, {"oid": "38754c73d2b02ca1a5d55a8d09bd8d25652ff0d4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/38754c73d2b02ca1a5d55a8d09bd8d25652ff0d4", "message": "removed commented out methods", "committedDate": "2020-10-07T17:26:23Z", "type": "commit"}, {"oid": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4d2a2c89d138d506bd5a5a5c1d3894a09c55726f", "message": "resolve merge", "committedDate": "2020-10-07T17:50:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwNDgzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501404836", "bodyText": "Method name MUST be  self explanatory and descriptive . Modify the method name to  testNameSpaceManageByRegularExpression()", "author": "anpanigr", "createdAt": "2020-10-08T01:55:02Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,614 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {", "originalCommit": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxODkyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501818921", "bodyText": "done", "author": "marinakog", "createdAt": "2020-10-08T15:37:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwNDgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwNTQ2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501405463", "bodyText": "testNsManageByLabel --> testNameSpaceManagedByLabelSelector", "author": "anpanigr", "createdAt": "2020-10-08T01:57:16Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,614 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+\n+    Map<String,String> managedByExpDomains = new HashMap<>();\n+    managedByExpDomains.put(manageByExp1NS,manageByExpDomain1Uid);\n+    managedByExpDomains.put(manageByExp2NS,manageByExpDomain2Uid);\n+    Map<String,String> unmanagedByExpDomains = new HashMap<>();\n+    unmanagedByExpDomains.put(manageByExp3NS,manageByExp3NS);\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+\n+    opHelmParams[1] = installAndVerifyOperatorCanManageDomainBySelector(managedByExpDomains,unmanagedByExpDomains,\n+        \"RegExp\",\"^test\",\n+        opNamespaces[1], null);\n+\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for default\n+    checkDomainNotStartedInDefaultNS();\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[1], \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[1])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[1], opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[1],manageByLabelDomainUid);\n+\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {", "originalCommit": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxOTA4Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501819087", "bodyText": "done", "author": "marinakog", "createdAt": "2020-10-08T15:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwNTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwNTk4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501405981", "bodyText": "testSwitchRbac--> TestNameSpaceWithEnableRac", "author": "anpanigr", "createdAt": "2020-10-08T01:59:25Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,614 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+\n+    Map<String,String> managedByExpDomains = new HashMap<>();\n+    managedByExpDomains.put(manageByExp1NS,manageByExpDomain1Uid);\n+    managedByExpDomains.put(manageByExp2NS,manageByExpDomain2Uid);\n+    Map<String,String> unmanagedByExpDomains = new HashMap<>();\n+    unmanagedByExpDomains.put(manageByExp3NS,manageByExp3NS);\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+\n+    opHelmParams[1] = installAndVerifyOperatorCanManageDomainBySelector(managedByExpDomains,unmanagedByExpDomains,\n+        \"RegExp\",\"^test\",\n+        opNamespaces[1], null);\n+\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for default\n+    checkDomainNotStartedInDefaultNS();\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[1], \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[1])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[1], opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[1],manageByLabelDomainUid);\n+\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    Map<String, String> managedByLabelDomains = new HashMap<>();\n+    managedByLabelDomains.put(domainNamespaces[0], domainsUid[0]);\n+    Map<String, String> unmanagedByLabelDomains = new HashMap<>();\n+    unmanagedByLabelDomains.put(domainNamespaces[1], domainsUid[1]);\n+    opHelmParams[0] = installAndVerifyOperatorCanManageDomainBySelector(managedByLabelDomains,unmanagedByLabelDomains,\n+        \"LabelSelector\",OPERATOR_RELEASE_NAME,\n+        opNamespaces[0], domainNamespaces[3]);\n+    assertNotNull(opHelmParams[0], \"Can't install or verify operator with SelectLabel namespace management\");\n+\n+    String manageByExpDomainUid = \"weblogic2\" + domainNamespaces[1];\n+    String manageByExpDomainNS = \"weblogic2\" + domainNamespaces[1];\n+\n+\n+    //switch namespace domainsNamespaces[1] to the label1,\n+    // managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNamespaces[1], labels1);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(domainNamespaces[1], domainsUid[1]),\n+        \"Failed to create domain CRD or \"\n+        + \"verify that domain \" + domainsUid[1]\n+        + \" is running in namespace \" + domainNamespaces[1]);\n+    checkOperatorCanScaleDomain(opNamespaces[0], domainsUid[1]);\n+\n+    //check that with specific Selector default namespace is not under operator management\n+    checkDomainNotStartedInDefaultNS();\n+\n+    //check that another operator with selector=List matching domain namespace,\n+    // managed by first operator fails to install\n+    checkSecondOperatorFailedToShareSameNS(domainNamespaces[0]);\n+\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpDomainNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[0], opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpDomainNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByExpDomainNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[0],manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[0], domainsUid[0], domainNamespaces[0]),\n+        \"Operator can still manage domain \"\n+            + domainsUid[0] + \" in the namespace \" + domainNamespaces[0]);\n+\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {", "originalCommit": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxOTAyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501819022", "bodyText": "done", "author": "marinakog", "createdAt": "2020-10-08T15:37:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwNTk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwNzU3Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501407572", "bodyText": "Here we are not deleting Domain CRD which is a global resource created by Operator. Actually we are deleting Domain Resource ( domain ).  Modify the method name to  deleteDomainResource()", "author": "anpanigr", "createdAt": "2020-10-08T02:06:25Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,614 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+\n+    Map<String,String> managedByExpDomains = new HashMap<>();\n+    managedByExpDomains.put(manageByExp1NS,manageByExpDomain1Uid);\n+    managedByExpDomains.put(manageByExp2NS,manageByExpDomain2Uid);\n+    Map<String,String> unmanagedByExpDomains = new HashMap<>();\n+    unmanagedByExpDomains.put(manageByExp3NS,manageByExp3NS);\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+\n+    opHelmParams[1] = installAndVerifyOperatorCanManageDomainBySelector(managedByExpDomains,unmanagedByExpDomains,\n+        \"RegExp\",\"^test\",\n+        opNamespaces[1], null);\n+\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for default\n+    checkDomainNotStartedInDefaultNS();\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[1], \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[1])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[1], opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[1],manageByLabelDomainUid);\n+\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    Map<String, String> managedByLabelDomains = new HashMap<>();\n+    managedByLabelDomains.put(domainNamespaces[0], domainsUid[0]);\n+    Map<String, String> unmanagedByLabelDomains = new HashMap<>();\n+    unmanagedByLabelDomains.put(domainNamespaces[1], domainsUid[1]);\n+    opHelmParams[0] = installAndVerifyOperatorCanManageDomainBySelector(managedByLabelDomains,unmanagedByLabelDomains,\n+        \"LabelSelector\",OPERATOR_RELEASE_NAME,\n+        opNamespaces[0], domainNamespaces[3]);\n+    assertNotNull(opHelmParams[0], \"Can't install or verify operator with SelectLabel namespace management\");\n+\n+    String manageByExpDomainUid = \"weblogic2\" + domainNamespaces[1];\n+    String manageByExpDomainNS = \"weblogic2\" + domainNamespaces[1];\n+\n+\n+    //switch namespace domainsNamespaces[1] to the label1,\n+    // managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNamespaces[1], labels1);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(domainNamespaces[1], domainsUid[1]),\n+        \"Failed to create domain CRD or \"\n+        + \"verify that domain \" + domainsUid[1]\n+        + \" is running in namespace \" + domainNamespaces[1]);\n+    checkOperatorCanScaleDomain(opNamespaces[0], domainsUid[1]);\n+\n+    //check that with specific Selector default namespace is not under operator management\n+    checkDomainNotStartedInDefaultNS();\n+\n+    //check that another operator with selector=List matching domain namespace,\n+    // managed by first operator fails to install\n+    checkSecondOperatorFailedToShareSameNS(domainNamespaces[0]);\n+\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpDomainNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[0], opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpDomainNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByExpDomainNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[0],manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[0], domainsUid[0], domainNamespaces[0]),\n+        \"Operator can still manage domain \"\n+            + domainsUid[0] + \" in the namespace \" + domainNamespaces[0]);\n+\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domainNamespaces[0] + \"test4\";\n+    String manageByLabelDomainUid = domainsUid[0] + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams[2] = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+        opNamespaces[3], \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[3], \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams[2]);\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[3], opParams));\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[3], manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespaces[0], opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {", "originalCommit": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxOTMxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501819318", "bodyText": "done", "author": "marinakog", "createdAt": "2020-10-08T15:37:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwNzU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwODExMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501408111", "bodyText": "Again here we are creating Domain Resource not CRD. Modify the method name to createDomainResource()", "author": "anpanigr", "createdAt": "2020-10-08T02:08:49Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItManageNs.java", "diffHunk": "@@ -0,0 +1,614 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1Namespace;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionTimeoutException;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleClusterWithRestApi;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.scaleAndVerifyCluster;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.upgradeAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+\n+/**\n+ * Simple JUnit test file used for testing operator namespace management,\n+ * Dedicated usecase is covered by other test class.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator namespace management usability using Helm chart\")\n+@IntegrationTest\n+class ItManageNs {\n+\n+  private static String[] opNamespaces = new String[4];\n+\n+  // domain constants\n+  private static final String[] domainsUid = {\"managensdomain1\",\"managensdomain2\",\"managensdomain3\",\"managensdomain4\"};\n+  private static String[] domainNamespaces = new String[4];\n+  private final String clusterName = \"cluster-1\";\n+  private final int replicaCount = 2;\n+  private final String adminServerPrefix = \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  private HelmParams[] opHelmParams = new HelmParams[3];\n+  private static String adminSecretName = \"weblogic-credentials-itmanagens\";\n+  private static String encryptionSecretName = \"encryptionsecret-itmanagens\";\n+  private static Map<String, String> labels1;\n+  private static Map<String, String> labels2;\n+\n+  private static LoggingFacade logger = null;\n+  private static String miiImage = MII_BASIC_IMAGE_NAME + \":\" + MII_BASIC_IMAGE_TAG;\n+  private static org.awaitility.core.ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(5, SECONDS)\n+          .atMost(2, MINUTES).await();\n+\n+  /**\n+   * Get namespaces for operator, domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(8) List<String> namespaces) {\n+    logger = getLogger();\n+    for (int i = 0; i < 4; i++) {\n+      // get a unique domain namespace\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      logger.info(\"Getting a unique namespace {0} for WebLogic domain {1}\", namespaces.get(i), i);\n+      domainNamespaces[i] = namespaces.get(i);\n+    }\n+    for (int i = 4; i < 8; i++) {\n+      // get a unique operator namespace\n+      logger.info(\"Getting a unique namespace for operator {0}\", (i - 4));\n+      assertNotNull(namespaces.get(i), \"Namespace list is null\");\n+      opNamespaces[(i - 4)] = namespaces.get(i);\n+    }\n+\n+    createSecrets(domainNamespaces[2]);\n+    createSecrets(\"default\");\n+    labels1 = new java.util.HashMap<>();\n+    labels1.put(OPERATOR_RELEASE_NAME, OPERATOR_RELEASE_NAME);\n+    labels2 = new java.util.HashMap<>();\n+    labels2.put(OPERATOR_RELEASE_NAME + \"2\", OPERATOR_RELEASE_NAME);\n+    setLabelToNamespace(domainNamespaces[0], labels1);\n+    setLabelToNamespace(domainNamespaces[1], labels2);\n+  }\n+\n+  @AfterAll\n+  public void tearDownAll() {\n+    try {\n+      // Delete domain custom resource\n+      for (int i = 0; i < 4; i++) {\n+        logger.info(\"Delete domain1 custom resource in namespace {0}\", domainNamespaces[i]);\n+        deleteDomainCustomResource(domainsUid[i], domainNamespaces[i]);\n+        logger.info(\"Deleted Domain Custom Resource \" + domainsUid[i] + \" from \" + domainNamespaces[i]);\n+      }\n+      logger.info(\"Delete domain1test custom resource in namespace {0}\", \"test-\" + domainNamespaces[0]);\n+      deleteDomainCustomResource(domainsUid[0] + \"test\", \"test-\" + domainNamespaces[0]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[0] + \"test from test-\" + domainNamespaces[0]);\n+  \n+      logger.info(\"Delete domain2test custom resource in namespace {0}\", \"test-\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(domainsUid[1] + \"test\", \"test-\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource \" + domainsUid[1] + \"test from test-\" + domainNamespaces[1]);\n+  \n+      logger.info(\"Delete weblogic custom resource in namespace {0}\", \"weblogic\" + domainNamespaces[1]);\n+      deleteDomainCustomResource(\"weblogic\", \"weblogic\" + domainNamespaces[1]);\n+      logger.info(\"Deleted Domain Custom Resource weblogic from weblogic\" + domainNamespaces[1]);\n+    } finally {\n+      deleteSecrets(\"default\");\n+      deleteSecrets(\"atest-\" + domainNamespaces[0]);\n+     \n+      deleteNamespace(\"atest-\" + domainNamespaces[0]);\n+      //delete operator\n+      for (HelmParams helmParam : opHelmParams) {\n+        uninstallOperator(helmParam);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=RegExp,\n+   * and domainNamespaceRegExp=^test and domainNamespace= manageByExp3NS.\n+   * Deploy two custom domain resources in two different namespaces with names starting with test\n+   * and verify all server pods in the domains were created and ready.\n+   * Verify operator is able to manage these domains by scaling.\n+   * Try to start another domain with namespace manageByExp3NS. Verify it is not started by operator\n+   * and value of domainNamespace is ignored for both specific namespace and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade helm chart to switch to using LabelSelector, start domain and verify operator can scale it.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using expression namespace management\")\n+  public void testNsManageByExp() {\n+    //create domain namespace\n+    String manageByExp1NS = \"test-\" +  domainNamespaces[0];\n+    String manageByExp2NS = \"test-\" +  domainNamespaces[1];\n+    String manageByExpDomain1Uid = \"test-\" + domainsUid[0];\n+    String manageByExpDomain2Uid = \"test-\" + domainsUid[1];\n+    String manageByExp3NS = \"atest-\" +  domainNamespaces[0];\n+\n+    Map<String,String> managedByExpDomains = new HashMap<>();\n+    managedByExpDomains.put(manageByExp1NS,manageByExpDomain1Uid);\n+    managedByExpDomains.put(manageByExp2NS,manageByExpDomain2Uid);\n+    Map<String,String> unmanagedByExpDomains = new HashMap<>();\n+    unmanagedByExpDomains.put(manageByExp3NS,manageByExp3NS);\n+    String manageByLabelNS = \"weblogic1\" + domainNamespaces[0];\n+    String manageByLabelDomainUid = \"weblogic1\" + domainsUid[0];\n+\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp1NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp2NS));\n+    assertDoesNotThrow(() -> Kubernetes.createNamespace(manageByExp3NS));\n+\n+    opHelmParams[1] = installAndVerifyOperatorCanManageDomainBySelector(managedByExpDomains,unmanagedByExpDomains,\n+        \"RegExp\",\"^test\",\n+        opNamespaces[1], null);\n+\n+\n+    //verify that domainNamespaces field will be ignored and domain will not start for default\n+    checkDomainNotStartedInDefaultNS();\n+\n+    // install  operator sharing same domain\n+    checkSecondOperatorFailedToShareSameNS(manageByExp1NS);\n+\n+    //upgrade operator to manage domains with Labeled namespaces\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[1], \"external-weblogic-operator-svc\");\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelNS));\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest\", \"weblogic2\");\n+    setLabelToNamespace(manageByLabelNS, labels);\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[1])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceLabelSelector(\"mytest\")\n+        .domainNamespaceSelectionStrategy(\"LabelSelector\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[1], opParams));\n+\n+    //verify domain is started\n+    createSecrets(manageByLabelNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelNS,manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[1],manageByLabelDomainUid);\n+\n+    //check operator can't manage anymore manageByExp1NS\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[1], manageByExpDomain1Uid,\n+        manageByExp1NS), \"Operator can still manage domain \"\n+        + manageByExp1NS + \" in the namespace \" + manageByExp1NS);\n+\n+  }\n+\n+  /**\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1.\n+   * Deploy a custom domain resource in the namespace with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   * Verify operator can't start another domain with namespace2 with label2.\n+   * Modify namespace2 to set label1, verify that operator can manage it.\n+   * Verify that domainNamespaces field will be ignored and domain will not start for namespaces:\n+   * (domain3Namespace) and default.\n+   * Add another operator using domainNamespaces sharing same namespace and verify it fails to install.\n+   * Upgrade operator to replace namespace management using RegExp namespaces.\n+   * Verify it can manage added domain and can't manage old domain by scaling .\n+   * Verify that upgrade helm fail if try to add domain, managed by other operator.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" using label namespace management\")\n+  public void testNsManageByLabel() {\n+    Map<String, String> managedByLabelDomains = new HashMap<>();\n+    managedByLabelDomains.put(domainNamespaces[0], domainsUid[0]);\n+    Map<String, String> unmanagedByLabelDomains = new HashMap<>();\n+    unmanagedByLabelDomains.put(domainNamespaces[1], domainsUid[1]);\n+    opHelmParams[0] = installAndVerifyOperatorCanManageDomainBySelector(managedByLabelDomains,unmanagedByLabelDomains,\n+        \"LabelSelector\",OPERATOR_RELEASE_NAME,\n+        opNamespaces[0], domainNamespaces[3]);\n+    assertNotNull(opHelmParams[0], \"Can't install or verify operator with SelectLabel namespace management\");\n+\n+    String manageByExpDomainUid = \"weblogic2\" + domainNamespaces[1];\n+    String manageByExpDomainNS = \"weblogic2\" + domainNamespaces[1];\n+\n+\n+    //switch namespace domainsNamespaces[1] to the label1,\n+    // managed by operator and verify domain is started and can be managed by operator.\n+    setLabelToNamespace(domainNamespaces[1], labels1);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(domainNamespaces[1], domainsUid[1]),\n+        \"Failed to create domain CRD or \"\n+        + \"verify that domain \" + domainsUid[1]\n+        + \" is running in namespace \" + domainNamespaces[1]);\n+    checkOperatorCanScaleDomain(opNamespaces[0], domainsUid[1]);\n+\n+    //check that with specific Selector default namespace is not under operator management\n+    checkDomainNotStartedInDefaultNS();\n+\n+    //check that another operator with selector=List matching domain namespace,\n+    // managed by first operator fails to install\n+    checkSecondOperatorFailedToShareSameNS(domainNamespaces[0]);\n+\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    assertDoesNotThrow(() -> createNamespace(manageByExpDomainNS));\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic2\");\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[0], opParams));\n+\n+    //verify domain is started in namespace with name starting with weblogic* and operator can scale it.\n+    createSecrets(manageByExpDomainNS);\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByExpDomainNS,manageByExpDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[0],manageByExpDomainUid);\n+    //verify operator can't manage anymore domain running in the namespace with label\n+    assertTrue(isOperatorFailedToScaleDomain(opNamespaces[0], domainsUid[0], domainNamespaces[0]),\n+        \"Operator can still manage domain \"\n+            + domainsUid[0] + \" in the namespace \" + domainNamespaces[0]);\n+\n+    checkUpgradeFailedToAddNSManagedByAnotherOperator();\n+  }\n+\n+  /**\n+   * Create namespace ns1 with no label\n+   * Install the Operator successfully and verify it is deployed successfully\n+   * with domainNamespaceSelectionStrategy=LabelSelector,\n+   * and domainNamespaceLabelSelector=label1 and enableRbac=false.\n+   * Add label1 to ns1 and verify domain can't be started\n+   * Call upgrade operator with reuse values to enable management for ns1\n+   * Deploy a custom domain resource in the namespace ns1 with label1\n+   * and verify all server pods in the domain were created and ready.\n+   * Verify operator is able to manage this domain by scaling.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"install operator helm chart and domain, \"\n+      + \" with enableClusterRoleBinding\")\n+  public void testSwitchRbac() {\n+    String manageByLabelDomainNS = domainNamespaces[0] + \"test4\";\n+    String manageByLabelDomainUid = domainsUid[0] + \"test4\";\n+    assertDoesNotThrow(() -> createNamespace(manageByLabelDomainNS));\n+    opHelmParams[2] = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+        opNamespaces[3], \"LabelSelector\",\n+        \"mytest4\", false);\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"mytest4\", manageByLabelDomainUid);\n+    assertDoesNotThrow(() -> addLabelsToNamespace(manageByLabelDomainNS, labels));\n+    //verify domain can't be started because operator does not have permission to manage it\n+    createSecrets(manageByLabelDomainNS);\n+    checkPodNotCreated(manageByLabelDomainUid + adminServerPrefix, manageByLabelDomainUid, manageByLabelDomainNS);\n+    deleteDomainCrd(manageByLabelDomainNS, manageByLabelDomainUid);\n+    //upgrade operator and start domain\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[3], \"external-weblogic-operator-svc\");\n+\n+    OperatorParams opParams = new OperatorParams()\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .helmParams(opHelmParams[2]);\n+\n+    assertTrue(upgradeAndVerifyOperator(opNamespaces[3], opParams));\n+    assertTrue(createDomainCrdAndVerifyDomainIsRunning(manageByLabelDomainNS, manageByLabelDomainUid));\n+    checkOperatorCanScaleDomain(opNamespaces[3], manageByLabelDomainUid);\n+  }\n+\n+  private void checkUpgradeFailedToAddNSManagedByAnotherOperator() {\n+    //upgrade operator1 to replace managing domains using RegExp namespaces\n+    // for ns names starting from weblogic, there one of domains\n+    //in namespace weblogic* is managed by operator2\n+    int externalRestHttpsPort = getServiceNodePort(opNamespaces[0], \"external-weblogic-operator-svc\");\n+    //set helm params to use domainNamespaceSelectionStrategy=RegExp for namespaces names started with weblogic\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams[0])\n+        .externalRestEnabled(true)\n+        .externalRestHttpsPort(externalRestHttpsPort)\n+        .domainNamespaceSelectionStrategy(\"RegExp\")\n+        .domainNamespaceRegExp(\"^\" + \"weblogic\");\n+\n+    assertFalse(upgradeAndVerifyOperator(opNamespaces[0], opParams), \"Upgrade does not fail when adding domain,\"\n+        + \" managed by other operator\");\n+  }\n+\n+  private void deleteDomainCrd(String domainNS, String domainUid) {\n+    //clean up domain resources in namespace and set namespace to label , managed by operator\n+    logger.info(\"deleting domain custom resource {0}\", domainUid);\n+    assertTrue(deleteDomainCustomResource(domainUid, domainNS));\n+\n+    // wait until domain was deleted\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNS,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainDoesNotExist(domainUid, DOMAIN_VERSION, domainNS));\n+  }\n+\n+  private HelmParams installAndVerifyOperatorCanManageDomainBySelector(Map<String,String> managedDomains,\n+                                                                       Map<String,String> unmanagedDomains,\n+                                                                       String selector, String selectorValue,\n+                                                                       String opNamespace,\n+                                                                       String domainNamespacesValue) {\n+    // install and verify operator set to manage domains based on LabelSelector strategy,\n+    // domainNamespaces value expected to be ignored\n+    HelmParams opHelmParam = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+        opNamespace, selector,\n+        selectorValue, true, domainNamespacesValue);\n+    managedDomains.forEach((domainNS, domainUid) -> {\n+          logger.info(\"Installing and verifying domain {0} in namespace {1}\", domainUid, domainNS);\n+          createSecrets(domainNS);\n+          assertTrue(createDomainCrdAndVerifyDomainIsRunning(domainNS, domainUid),\n+              \"can't start or verify domain in namespace \" + domainNS);\n+\n+          checkOperatorCanScaleDomain(opNamespace, domainUid);\n+        }\n+    );\n+    if (domainNamespacesValue != null) {\n+      //verify that domainNamespaces field will be ignored and domain will not start\n+      createSecrets(domainNamespacesValue);\n+      checkPodNotCreated(domainNamespacesValue + adminServerPrefix, domainNamespacesValue, domainNamespacesValue);\n+    }\n+    //verify that domains in namespaces not matching selector value will not start\n+    unmanagedDomains.forEach((domainNS, domainUid) -> {\n+      createSecrets(domainNS);\n+      checkPodNotCreated(domainUid + adminServerPrefix, domainUid, domainNS);\n+      deleteDomainCrd(domainNS, domainUid);\n+    }\n+    );\n+    return opHelmParam;\n+  }\n+\n+  private boolean isOperatorFailedToScaleDomain(String opNamespace, String domainUid, String domainNamespace) {\n+    try {\n+      //check operator can't manage domainNamespace by trying to scale domain\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      String managedServerPodNamePrefix = domainUid + \"-managed-server\";\n+      String opServiceAccount = OPERATOR_RELEASE_NAME + \"-sa\";\n+      scaleAndVerifyCluster(\"cluster-1\", domainUid, domainNamespace,\n+          managedServerPodNamePrefix, 2, 1,\n+          true, externalRestHttpsPort, opNamespace, opServiceAccount,\n+          false, \"\", \"scaleDown\", 1, \"\", \"\", null, null);\n+      return false;\n+\n+    } catch (ConditionTimeoutException ex) {\n+      logger.info(\"Received expected error \" + ex.getMessage());\n+      return true;\n+    }\n+  }\n+\n+  private static void setLabelToNamespace(String domainNS, Map<String, String> labels) {\n+    //add label to domain namespace\n+    V1Namespace namespaceObject1 = assertDoesNotThrow(() -> Kubernetes.getNamespaceAsObject(domainNS));\n+    assertNotNull(namespaceObject1, \"Can't find namespace with name \" + domainNS);\n+    namespaceObject1.getMetadata().setLabels(labels);\n+    assertDoesNotThrow(() -> Kubernetes.replaceNamespace(namespaceObject1));\n+  }\n+\n+  private void checkOperatorCanScaleDomain(String opNamespace, String domainUid) {\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(scaleClusterWithRestApi(domainUid, clusterName, 3,\n+        externalRestHttpsPort, opNamespace, OPERATOR_RELEASE_NAME + \"-sa\"),\n+        \"Domain \" + domainUid + \" scaling operation failed\");\n+  }\n+\n+  private void checkSecondOperatorFailedToShareSameNS(String domainNamespace) {\n+    // try to install another operator sharing same domain namespace via different domainNsSelectionStrategy\n+    HelmParams opHelmParams = new HelmParams().releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespaces[2])\n+        .chartDir(OPERATOR_CHART_DIR);\n+    try {\n+      HelmParams opHelmParams2 = installAndVerifyOperator(OPERATOR_RELEASE_NAME,\n+          opNamespaces[2], \"List\",\n+          null, true, domainNamespace);\n+      assertNull(opHelmParams2, \"Operator helm chart sharing same NS with other operator did not fail\");\n+    } catch (org.opentest4j.AssertionFailedError ex) {\n+      //expecting to fail\n+      logger.info(\"Helm installation failed as expected \" + ex.getMessage());\n+      uninstallOperator(opHelmParams);\n+    }\n+  }\n+\n+  private void checkDomainNotStartedInDefaultNS() {\n+    //verify operator can't start domain in the default namespace when domainNsSelectionStrategy not List\n+    // and selector does not match default\n+    checkPodNotCreated(\"defaultuid\" + adminServerPrefix, \"defaultuid\", \"default\");\n+\n+    logger.info(\"Delete defaultuid custom resource in namespace {0}\", \"default\");\n+    deleteDomainCustomResource(\"defaultuid\", \"default\");\n+    logger.info(\"Deleted Domain Custom Resource \" + \"defaultuid\");\n+  }\n+\n+  private boolean createDomainCrdAndVerifyDomainIsRunning(String domainNamespace, String domainUid) {\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    Domain domain = createDomainCRD(domainNamespace, domainUid);\n+    assertDoesNotThrow(() -> createVerifyDomain(domainNamespace, domainUid, miiImage, domain));\n+    return true;\n+  }\n+\n+  /**\n+   * Create a model in image domain crd.\n+   */\n+  private Domain createDomainCRD(String domainNamespace, String domainUid) {", "originalCommit": "4d2a2c89d138d506bd5a5a5c1d3894a09c55726f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxOTE1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1955#discussion_r501819157", "bodyText": "done", "author": "marinakog", "createdAt": "2020-10-08T15:37:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQwODExMQ=="}], "type": "inlineReview"}, {"oid": "fb240205c8e3ec6cad3f831aeaa75fcb65258fab", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fb240205c8e3ec6cad3f831aeaa75fcb65258fab", "message": "addressed review comments5", "committedDate": "2020-10-08T15:35:52Z", "type": "commit"}]}