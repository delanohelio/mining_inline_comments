{"pr_number": 1527, "pr_title": "Implemented the pod and service check assertions", "pr_createdAt": "2020-04-02T18:31:49Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527", "timeline": [{"oid": "8512964df8b1315953b8180f48ed3b5ec4a35877", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8512964df8b1315953b8180f48ed3b5ec4a35877", "message": "working on the pod status", "committedDate": "2020-03-31T18:47:30Z", "type": "commit"}, {"oid": "c1d77545941855f6d6e4260b02901f88ab9a7b4f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c1d77545941855f6d6e4260b02901f88ab9a7b4f", "message": "fix", "committedDate": "2020-03-31T18:54:26Z", "type": "commit"}, {"oid": "77e57bfc2165f9b555b337fd47b9b1a16d58f767", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/77e57bfc2165f9b555b337fd47b9b1a16d58f767", "message": "fix", "committedDate": "2020-03-31T19:23:16Z", "type": "commit"}, {"oid": "1e7d45187f2ed01d85c594b024ba6e512f1c185c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1e7d45187f2ed01d85c594b024ba6e512f1c185c", "message": "implement", "committedDate": "2020-03-31T21:33:13Z", "type": "commit"}, {"oid": "ed2af97f2af984a9decd6e91a1ae1407e2fea653", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ed2af97f2af984a9decd6e91a1ae1407e2fea653", "message": "fix", "committedDate": "2020-04-01T17:03:52Z", "type": "commit"}, {"oid": "2eaf45badf99a9872bc44ffe223c7209ed7dea78", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2eaf45badf99a9872bc44ffe223c7209ed7dea78", "message": "add serviceCreated", "committedDate": "2020-04-01T17:55:46Z", "type": "commit"}, {"oid": "07f48010bf7e12b5a2a2380fe1bbdd2fcaabcf02", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/07f48010bf7e12b5a2a2380fe1bbdd2fcaabcf02", "message": "fix", "committedDate": "2020-04-01T17:59:00Z", "type": "commit"}, {"oid": "9c9b97f248c3ca49e9d2cb7b22ffcc899b5f12a2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9c9b97f248c3ca49e9d2cb7b22ffcc899b5f12a2", "message": "implemented service level assertions", "committedDate": "2020-04-02T05:39:50Z", "type": "commit"}, {"oid": "d157f2127ec5a4021c60686c0ea867be233ca086", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d157f2127ec5a4021c60686c0ea867be233ca086", "message": "fix", "committedDate": "2020-04-02T05:54:59Z", "type": "commit"}, {"oid": "603cc19a5145fef1c5a2895fcf39ddd164ed758f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/603cc19a5145fef1c5a2895fcf39ddd164ed758f", "message": "adding domain related assertions", "committedDate": "2020-04-02T16:52:42Z", "type": "commit"}, {"oid": "bcbebee3544401958eaf9fb7b149a67369695e03", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/bcbebee3544401958eaf9fb7b149a67369695e03", "message": "add domain related assertions", "committedDate": "2020-04-02T17:02:41Z", "type": "commit"}, {"oid": "2cdf4362deff24af2e963403c20fa8b2b0766da2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2cdf4362deff24af2e963403c20fa8b2b0766da2", "message": "fix", "committedDate": "2020-04-02T17:44:41Z", "type": "commit"}, {"oid": "e8fb2c493809b71a6c71c7d5f27989ed556dccce", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e8fb2c493809b71a6c71c7d5f27989ed556dccce", "message": "reverting", "committedDate": "2020-04-02T17:53:20Z", "type": "commit"}, {"oid": "78ea1c268661c702159e0f18550e25661390cbc3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/78ea1c268661c702159e0f18550e25661390cbc3", "message": "Merge branch 'mii-new-integration-tests' into sankar-junit5-1", "committedDate": "2020-04-02T17:53:48Z", "type": "commit"}, {"oid": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/46b79449efedaefca03b93f7514f88b9f8b6e2c6", "message": "Added javadoc", "committedDate": "2020-04-02T18:29:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjU2MDQ3Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r402560472", "bodyText": "Let's discuss in the meeting.  It seems that these assertions are insufficient (I know that they model exactly what was in the previous tests).  Just checking that the pod exists, is ready, or is terminating leaves off lots of possible errors.", "author": "rjeberhard", "createdAt": "2020-04-02T19:30:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -25,57 +28,84 @@\n \n   /**\n    * Check if operator Rest service is running.\n+   *\n    * @param namespace the operator rest service exists\n    * @return true if rest service is running otherwise false\n    */\n-  public static boolean operatorRestServiceRunning(String namespace) {\n-    return Operator.isRestServiceCreated(namespace);\n+  public static Callable<Boolean> operatorRestServiceRunning(String namespace) throws ApiException {\n+    return () -> {\n+      return Operator.isExternalRestServiceCreated(namespace);\n+    };\n   }\n \n   /**\n-   * Check if a WebLogic custom resource domain exists in specified namespace and all its pods are running.\n+   * Check if a WebLogic custom resource domain object exists in specified\n+   * namespace.\n+   *\n    * @param domainUID ID of the domain\n-   * @param namespace in which the domain custom resource exists\n-   * @return true if domain exists and pods running otherwise false\n+   * @param namespace in which the domain custom resource object exists\n+   * @return true if domain object exists\n    */\n   public static Callable<Boolean> domainExists(String domainUID, String namespace) {\n     return Domain.exists(domainUID, namespace);\n   }\n \n+  /**\n+   * Check if a Kubernetes pod exists in any state.\n+   *\n+   * @param podName name of the pod to check for\n+   * @param domainUID WebLogic domain uid in which the pod belongs\n+   * @param namespace in which the pod exists\n+   * @return true if the pod exists in the namespace otherwise false\n+   */\n+  public static Callable<Boolean> podExists(String podName, String domainUID, String namespace) throws ApiException {", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjU2MDg3NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r402560874", "bodyText": "HashMap -> Map<String, String>", "author": "rjeberhard", "createdAt": "2020-04-02T19:31:22Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -25,57 +28,84 @@\n \n   /**\n    * Check if operator Rest service is running.\n+   *\n    * @param namespace the operator rest service exists\n    * @return true if rest service is running otherwise false\n    */\n-  public static boolean operatorRestServiceRunning(String namespace) {\n-    return Operator.isRestServiceCreated(namespace);\n+  public static Callable<Boolean> operatorRestServiceRunning(String namespace) throws ApiException {\n+    return () -> {\n+      return Operator.isExternalRestServiceCreated(namespace);\n+    };\n   }\n \n   /**\n-   * Check if a WebLogic custom resource domain exists in specified namespace and all its pods are running.\n+   * Check if a WebLogic custom resource domain object exists in specified\n+   * namespace.\n+   *\n    * @param domainUID ID of the domain\n-   * @param namespace in which the domain custom resource exists\n-   * @return true if domain exists and pods running otherwise false\n+   * @param namespace in which the domain custom resource object exists\n+   * @return true if domain object exists\n    */\n   public static Callable<Boolean> domainExists(String domainUID, String namespace) {\n     return Domain.exists(domainUID, namespace);\n   }\n \n+  /**\n+   * Check if a Kubernetes pod exists in any state.\n+   *\n+   * @param podName name of the pod to check for\n+   * @param domainUID WebLogic domain uid in which the pod belongs\n+   * @param namespace in which the pod exists\n+   * @return true if the pod exists in the namespace otherwise false\n+   */\n+  public static Callable<Boolean> podExists(String podName, String domainUID, String namespace) throws ApiException {\n+    return () -> {\n+      return Kubernetes.isPodExists(namespace, domainUID, podName);\n+    };\n+  }\n+\n   /**\n    * Check if a Kubernetes pod is in running/ready state.\n+   *\n    * @param podName name of the pod to check for\n    * @param domainUID WebLogic domain uid in which the pod belongs\n    * @param namespace in which the pod is running\n    * @return true if the pod is running otherwise false\n    */\n-  public static Callable<Boolean> podReady(String podName, String domainUID, String namespace) {\n-    return Kubernetes.podRunning(podName, domainUID, namespace);\n+  public static Callable<Boolean> podReady(String podName, String domainUID, String namespace) throws ApiException {\n+    return () -> {\n+      return Kubernetes.isPodRunning(namespace, domainUID, podName);\n+    };\n   }\n \n   /**\n    * Check if a pod given by the podName is in Terminating state.\n+   *\n    * @param podName name of the pod to check for Terminating status\n    * @param domainUID WebLogic domain uid in which the pod belongs\n    * @param namespace in which the pod is running\n    * @return true if the pod is terminating otherwise false\n    */\n   public static Callable<Boolean> podTerminating(String podName, String domainUID, String namespace) {\n-    return Kubernetes.podTerminating(podName, domainUID, namespace);\n+    return () -> {\n+      return Kubernetes.isPodTerminating(namespace, domainUID, podName);\n+    };\n   }\n \n   /**\n    * Check is a service exists in given namespace.\n-   * @param serviceName  the name of the service to check for\n+   *\n+   * @param serviceName the name of the service to check for\n    * @param namespace in which the service is running\n    * @return true if the service exists otherwise false\n    */\n-  public static boolean serviceReady(String serviceName, String namespace) {\n-    return Kubernetes.serviceCreated(serviceName, namespace);\n+  public static boolean serviceReady(String serviceName, HashMap label, String namespace) throws ApiException {", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMDg4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403000888", "bodyText": "doesCRDExist", "author": "markxnelson", "createdAt": "2020-04-03T13:22:34Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -5,17 +5,61 @@\n \n import java.util.concurrent.Callable;\n \n-public class Domain {\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.apis.ApiextensionsV1Api;\n+import io.kubernetes.client.openapi.apis.ApiextensionsV1beta1Api;\n+import io.kubernetes.client.openapi.apis.ApisApi;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1beta1CustomResourceDefinition;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class Domain implements LoggedTest {\n+\n+  private static CustomObjectsApi customObjectsApi = new CustomObjectsApi();\n+  private static ApiextensionsV1Api apiextensionsV1Api = new ApiextensionsV1Api();\n+  private static ApiextensionsV1beta1Api apiextensionsV1beta1Api = new ApiextensionsV1beta1Api();\n+  private static ApisApi apisApi = new ApisApi();\n+\n+\n+  /**\n+   * Check if the Domain CRD exists\n+   * @return true if domains.weblogic.oracle CRD exists otherwise false\n+   * @throws Exception\n+   */\n+  public static boolean isCRDExists() throws Exception {", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxMzc2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403213760", "bodyText": "changed the method name to doesCRDExist", "author": "sankarpn", "createdAt": "2020-04-03T18:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMDg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMTQzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403001430", "bodyText": "the message is unclear - it reads like you are saying that the CRD that you expected to exist DOES exist", "author": "markxnelson", "createdAt": "2020-04-03T13:23:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -5,17 +5,61 @@\n \n import java.util.concurrent.Callable;\n \n-public class Domain {\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.apis.ApiextensionsV1Api;\n+import io.kubernetes.client.openapi.apis.ApiextensionsV1beta1Api;\n+import io.kubernetes.client.openapi.apis.ApisApi;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1beta1CustomResourceDefinition;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class Domain implements LoggedTest {\n+\n+  private static CustomObjectsApi customObjectsApi = new CustomObjectsApi();\n+  private static ApiextensionsV1Api apiextensionsV1Api = new ApiextensionsV1Api();\n+  private static ApiextensionsV1beta1Api apiextensionsV1beta1Api = new ApiextensionsV1beta1Api();\n+  private static ApisApi apisApi = new ApisApi();\n+\n+\n+  /**\n+   * Check if the Domain CRD exists\n+   * @return true if domains.weblogic.oracle CRD exists otherwise false\n+   * @throws Exception\n+   */\n+  public static boolean isCRDExists() throws Exception {\n+    try {\n+      V1beta1CustomResourceDefinition domainBetaCrd =\n+          apiextensionsV1beta1Api.readCustomResourceDefinition(\n+              \"domains.weblogic.oracle\", null, null, null);\n+      assertNotNull(domainBetaCrd);\n+      logger.info(\"domainBetaCrd is not null\");\n+      return true;\n+    } catch (ApiException aex) {\n+      if (aex.getCode() == 404) {\n+        assertTrue(false, \"Expected CRD domains.weblogic.oracle existed.\");", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxMzg0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403213843", "bodyText": "made it more clear", "author": "sankarpn", "createdAt": "2020-04-03T18:15:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMTQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMTY2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403001662", "bodyText": "is v2 right??", "author": "markxnelson", "createdAt": "2020-04-03T13:23:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -5,17 +5,61 @@\n \n import java.util.concurrent.Callable;\n \n-public class Domain {\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.apis.ApiextensionsV1Api;\n+import io.kubernetes.client.openapi.apis.ApiextensionsV1beta1Api;\n+import io.kubernetes.client.openapi.apis.ApisApi;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1beta1CustomResourceDefinition;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class Domain implements LoggedTest {\n+\n+  private static CustomObjectsApi customObjectsApi = new CustomObjectsApi();\n+  private static ApiextensionsV1Api apiextensionsV1Api = new ApiextensionsV1Api();\n+  private static ApiextensionsV1beta1Api apiextensionsV1beta1Api = new ApiextensionsV1beta1Api();\n+  private static ApisApi apisApi = new ApisApi();\n+\n+\n+  /**\n+   * Check if the Domain CRD exists\n+   * @return true if domains.weblogic.oracle CRD exists otherwise false\n+   * @throws Exception\n+   */\n+  public static boolean isCRDExists() throws Exception {\n+    try {\n+      V1beta1CustomResourceDefinition domainBetaCrd =\n+          apiextensionsV1beta1Api.readCustomResourceDefinition(\n+              \"domains.weblogic.oracle\", null, null, null);\n+      assertNotNull(domainBetaCrd);\n+      logger.info(\"domainBetaCrd is not null\");\n+      return true;\n+    } catch (ApiException aex) {\n+      if (aex.getCode() == 404) {\n+        assertTrue(false, \"Expected CRD domains.weblogic.oracle existed.\");\n+      } else {\n+        throw aex;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Checks if weblogic.oracle CRD domain object exists.\n+   * @param domainUID domain UID of the domain object\n+   * @param namespace in which the domain object exists\n+   * @return true if domain object exists otherwise false\n+   */\n   public static Callable<Boolean> exists(String domainUID, String namespace) {\n     return () -> {\n-      String[] pods = {};\n-      for (String pod : pods) {\n-        if (!Kubernetes.podRunning(pod, domainUID, namespace).call().booleanValue()) {\n-          return false;\n-        }\n-      }\n-      return true;\n+      Object domainObject =\n+          customObjectsApi.getNamespacedCustomObject(\n+              \"weblogic.oracle\", \"v2\", namespace, \"domains\", domainUID);", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEzOTg0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403139840", "bodyText": "what should be the version value ?", "author": "sankarpn", "createdAt": "2020-04-03T16:48:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0NTI4MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403145280", "bodyText": "@rjeberhard is v2 still right?", "author": "markxnelson", "createdAt": "2020-04-03T16:56:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0NzA5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403147093", "bodyText": "i see v7 i think?\nkind: Domain\nmetadata:\n  annotations:\n    kubectl.kubernetes.io/last-applied-configuration: |\n      {\"apiVersion\":\"weblogic.oracle/v6\",\"kind\":\"Domain\",\"metadata\":{\"annotations\":{},\"labels\":{\"weblogic.domainUID\":\"domain1\",\"weblogic.resourceVersion\":\"domain-v2\"},\"name\":\"domain1\",\"namespace\":\"mark\"},\"spec\":{\"adminServer\":{\"adminService\":{\"channels\":[{\"channelName\":\"default\",\"nodePort\":30751}]},\"serverStartState\":\"RUNNING\"},\"clusters\":[{\"clusterName\":\"cluster-1\",\"replicas\":2,\"serverStartState\":\"RUNNING\"}],\"dataHome\":\"\",\"domainHome\":\"/u01/oracle/user_projects/domains/domain1\",\"domainHomeInImage\":true,\"image\":\"phx.ocir.io/stevengreenberginc/mark/domain-home-in-image:12.2.1.3\",\"imagePullPolicy\":\"IfNotPresent\",\"includeServerOutInPodLog\":true,\"serverPod\":{\"env\":[{\"name\":\"JAVA_OPTIONS\",\"value\":\"-Dweblogic.StdoutDebugEnabled=false\"},{\"name\":\"USER_MEM_ARGS\",\"value\":\"-Djava.security.egd=file:/dev/./urandom \"}]},\"serverStartPolicy\":\"IF_NEEDED\",\"webLogicCredentialsSecret\":{\"name\":\"domain1-weblogic-credentials\"}}}", "author": "markxnelson", "createdAt": "2020-04-03T16:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNDMwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403214305", "bodyText": "modified the method signature to add one more parameter domainVersion", "author": "sankarpn", "createdAt": "2020-04-03T18:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMTY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMjA4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403002089", "bodyText": "dosPodExist", "author": "markxnelson", "createdAt": "2020-04-03T13:24:14Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -3,30 +3,268 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.concurrent.Callable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n \n-public class Kubernetes {\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceList;\n+import io.kubernetes.client.util.ClientBuilder;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n-  public static Callable<Boolean> podExists(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+public class Kubernetes implements LoggedTest {\n+\n+  private static final String OPERATOR_NAME = \"weblogic-operator-\";\n+\n+  private static ApiClient apiClient = null;\n+  private static CoreV1Api coreV1Api = null;\n+  private static CustomObjectsApi customObjectsApi = null;\n+  private static final String RUNNING = \"Running\";\n+  private static final String TERMINATING = \"Terminating\";\n+\n+  static {\n+    try {\n+      Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n+      apiClient = Configuration.getDefaultApiClient();\n+      coreV1Api = new CoreV1Api();\n+      customObjectsApi = new CustomObjectsApi();\n+    } catch (IOException ioex) {\n+      throw new ExceptionInInitializerError(ioex);\n+    }\n   }\n \n-  public static Callable<Boolean> podRunning(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodExists(String namespace, String domainUid, String podName) throws ApiException {", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNDYwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403214604", "bodyText": "changed to doesPodExist", "author": "sankarpn", "createdAt": "2020-04-03T18:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMjA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMjk4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403002983", "bodyText": "this is too magical. what does this mean?\ndo your comparison and assign the value to a well-named variable, then return the var", "author": "markxnelson", "createdAt": "2020-04-03T13:25:36Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -3,30 +3,268 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.concurrent.Callable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n \n-public class Kubernetes {\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceList;\n+import io.kubernetes.client.util.ClientBuilder;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n-  public static Callable<Boolean> podExists(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+public class Kubernetes implements LoggedTest {\n+\n+  private static final String OPERATOR_NAME = \"weblogic-operator-\";\n+\n+  private static ApiClient apiClient = null;\n+  private static CoreV1Api coreV1Api = null;\n+  private static CustomObjectsApi customObjectsApi = null;\n+  private static final String RUNNING = \"Running\";\n+  private static final String TERMINATING = \"Terminating\";\n+\n+  static {\n+    try {\n+      Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n+      apiClient = Configuration.getDefaultApiClient();\n+      coreV1Api = new CoreV1Api();\n+      customObjectsApi = new CustomObjectsApi();\n+    } catch (IOException ioex) {\n+      throw new ExceptionInInitializerError(ioex);\n+    }\n   }\n \n-  public static Callable<Boolean> podRunning(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodExists(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod exists in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod != null;", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNDc3MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403214771", "bodyText": "done", "author": "sankarpn", "createdAt": "2020-04-03T18:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMjk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMzQyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403003427", "bodyText": "put comments after each value to explain what they are", "author": "markxnelson", "createdAt": "2020-04-03T13:26:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -3,30 +3,268 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.concurrent.Callable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n \n-public class Kubernetes {\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceList;\n+import io.kubernetes.client.util.ClientBuilder;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n-  public static Callable<Boolean> podExists(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+public class Kubernetes implements LoggedTest {\n+\n+  private static final String OPERATOR_NAME = \"weblogic-operator-\";\n+\n+  private static ApiClient apiClient = null;\n+  private static CoreV1Api coreV1Api = null;\n+  private static CustomObjectsApi customObjectsApi = null;\n+  private static final String RUNNING = \"Running\";\n+  private static final String TERMINATING = \"Terminating\";\n+\n+  static {\n+    try {\n+      Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n+      apiClient = Configuration.getDefaultApiClient();\n+      coreV1Api = new CoreV1Api();\n+      customObjectsApi = new CustomObjectsApi();\n+    } catch (IOException ioex) {\n+      throw new ExceptionInInitializerError(ioex);\n+    }\n   }\n \n-  public static Callable<Boolean> podRunning(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodExists(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod exists in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod != null;\n   }\n \n-  public static Callable<Boolean> podTerminating(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace and in Running state.\n+   * @param namespace in which to check for the pod running\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodRunning(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod running in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(RUNNING);\n   }\n \n-  public static boolean serviceCreated(String domainUID, String namespace) {\n-    return true;\n+  /**\n+   * Checks if a pod exists in a given namespace and in Terminating state.\n+   * @param namespace in which to check for the pod\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod is in Terminating state otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodTerminating(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod terminating in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(TERMINATING);\n+  }\n+\n+  /**\n+   * Checks if a Operator pod exists in a given namespace.\n+   * The method assumes the operator name to starts with weblogic-operator-\n+   * and decorated with label weblogic.operatorName:namespace\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isOperatorPodRunning(String namespace) throws ApiException {\n+    String labelSelector = String.format(\"weblogic.operatorName in (%s)\", namespace);\n+    V1Pod pod = getPod(namespace, labelSelector, \"weblogic-operator-\");\n+    return pod.getStatus().getPhase().equals(RUNNING);\n+  }\n+\n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList v1PodList =\n+        coreV1Api.listNamespacedPod(\n+            namespace,\n+            Boolean.FALSE.toString(),\n+            Boolean.FALSE,\n+            null,", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNTA0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403215047", "bodyText": "added explanation to the params.", "author": "sankarpn", "createdAt": "2020-04-03T18:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMzQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMzY1MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403003651", "bodyText": "wasServiceCreated or doesServiceExist", "author": "markxnelson", "createdAt": "2020-04-03T13:26:41Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -3,30 +3,268 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.concurrent.Callable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n \n-public class Kubernetes {\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceList;\n+import io.kubernetes.client.util.ClientBuilder;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n-  public static Callable<Boolean> podExists(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+public class Kubernetes implements LoggedTest {\n+\n+  private static final String OPERATOR_NAME = \"weblogic-operator-\";\n+\n+  private static ApiClient apiClient = null;\n+  private static CoreV1Api coreV1Api = null;\n+  private static CustomObjectsApi customObjectsApi = null;\n+  private static final String RUNNING = \"Running\";\n+  private static final String TERMINATING = \"Terminating\";\n+\n+  static {\n+    try {\n+      Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n+      apiClient = Configuration.getDefaultApiClient();\n+      coreV1Api = new CoreV1Api();\n+      customObjectsApi = new CustomObjectsApi();\n+    } catch (IOException ioex) {\n+      throw new ExceptionInInitializerError(ioex);\n+    }\n   }\n \n-  public static Callable<Boolean> podRunning(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodExists(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod exists in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod != null;\n   }\n \n-  public static Callable<Boolean> podTerminating(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace and in Running state.\n+   * @param namespace in which to check for the pod running\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodRunning(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod running in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(RUNNING);\n   }\n \n-  public static boolean serviceCreated(String domainUID, String namespace) {\n-    return true;\n+  /**\n+   * Checks if a pod exists in a given namespace and in Terminating state.\n+   * @param namespace in which to check for the pod\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod is in Terminating state otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodTerminating(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod terminating in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(TERMINATING);\n+  }\n+\n+  /**\n+   * Checks if a Operator pod exists in a given namespace.\n+   * The method assumes the operator name to starts with weblogic-operator-\n+   * and decorated with label weblogic.operatorName:namespace\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isOperatorPodRunning(String namespace) throws ApiException {\n+    String labelSelector = String.format(\"weblogic.operatorName in (%s)\", namespace);\n+    V1Pod pod = getPod(namespace, labelSelector, \"weblogic-operator-\");\n+    return pod.getStatus().getPhase().equals(RUNNING);\n+  }\n+\n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList v1PodList =\n+        coreV1Api.listNamespacedPod(\n+            namespace,\n+            Boolean.FALSE.toString(),\n+            Boolean.FALSE,\n+            null,\n+            null,\n+            labelSelector,\n+            null,\n+            null,\n+            null,\n+            Boolean.FALSE);\n+    for (V1Pod item : v1PodList.getItems()) {\n+      if (item.getMetadata().getName().startsWith(podName.trim())) {\n+        logger.info(\"Pod Name :\" + item.getMetadata().getName());\n+        logger.info(\"Pod Namespace :\" + item.getMetadata().getNamespace());\n+        logger.info(\"Pod UID :\" + item.getMetadata().getUid());\n+        logger.info(\"Pod Status :\" + item.getStatus().getPhase());\n+        return item;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Checks if a Kubernetes service object exists in a given namespace.\n+   * @param serviceName name of the service to check for\n+   * @param label the key value pair with which the service is decorated with\n+   * @param namespace the namespace in which to check for the service\n+   * @return true if the service is found otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isServiceCreated(String serviceName, HashMap label, String namespace) throws ApiException {", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNTQ4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403215484", "bodyText": "changed the name to doesServiceExist", "author": "sankarpn", "createdAt": "2020-04-03T18:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMzY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMzgxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403003817", "bodyText": "explain params", "author": "markxnelson", "createdAt": "2020-04-03T13:26:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -3,30 +3,268 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.concurrent.Callable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n \n-public class Kubernetes {\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceList;\n+import io.kubernetes.client.util.ClientBuilder;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n-  public static Callable<Boolean> podExists(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+public class Kubernetes implements LoggedTest {\n+\n+  private static final String OPERATOR_NAME = \"weblogic-operator-\";\n+\n+  private static ApiClient apiClient = null;\n+  private static CoreV1Api coreV1Api = null;\n+  private static CustomObjectsApi customObjectsApi = null;\n+  private static final String RUNNING = \"Running\";\n+  private static final String TERMINATING = \"Terminating\";\n+\n+  static {\n+    try {\n+      Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n+      apiClient = Configuration.getDefaultApiClient();\n+      coreV1Api = new CoreV1Api();\n+      customObjectsApi = new CustomObjectsApi();\n+    } catch (IOException ioex) {\n+      throw new ExceptionInInitializerError(ioex);\n+    }\n   }\n \n-  public static Callable<Boolean> podRunning(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodExists(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod exists in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod != null;\n   }\n \n-  public static Callable<Boolean> podTerminating(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace and in Running state.\n+   * @param namespace in which to check for the pod running\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodRunning(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod running in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(RUNNING);\n   }\n \n-  public static boolean serviceCreated(String domainUID, String namespace) {\n-    return true;\n+  /**\n+   * Checks if a pod exists in a given namespace and in Terminating state.\n+   * @param namespace in which to check for the pod\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod is in Terminating state otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodTerminating(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod terminating in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(TERMINATING);\n+  }\n+\n+  /**\n+   * Checks if a Operator pod exists in a given namespace.\n+   * The method assumes the operator name to starts with weblogic-operator-\n+   * and decorated with label weblogic.operatorName:namespace\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isOperatorPodRunning(String namespace) throws ApiException {\n+    String labelSelector = String.format(\"weblogic.operatorName in (%s)\", namespace);\n+    V1Pod pod = getPod(namespace, labelSelector, \"weblogic-operator-\");\n+    return pod.getStatus().getPhase().equals(RUNNING);\n+  }\n+\n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList v1PodList =\n+        coreV1Api.listNamespacedPod(\n+            namespace,\n+            Boolean.FALSE.toString(),\n+            Boolean.FALSE,\n+            null,\n+            null,\n+            labelSelector,\n+            null,\n+            null,\n+            null,\n+            Boolean.FALSE);\n+    for (V1Pod item : v1PodList.getItems()) {\n+      if (item.getMetadata().getName().startsWith(podName.trim())) {\n+        logger.info(\"Pod Name :\" + item.getMetadata().getName());\n+        logger.info(\"Pod Namespace :\" + item.getMetadata().getNamespace());\n+        logger.info(\"Pod UID :\" + item.getMetadata().getUid());\n+        logger.info(\"Pod Status :\" + item.getStatus().getPhase());\n+        return item;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Checks if a Kubernetes service object exists in a given namespace.\n+   * @param serviceName name of the service to check for\n+   * @param label the key value pair with which the service is decorated with\n+   * @param namespace the namespace in which to check for the service\n+   * @return true if the service is found otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isServiceCreated(String serviceName, HashMap label, String namespace) throws ApiException {\n+    return getService(serviceName, label, namespace) != null;\n+  }\n+\n+  /**\n+   * Get V1Service object for the given servicename, label and namespace\n+   * @param serviceName name of the service to look for\n+   * @param label the key value pair with which the service is decorated with\n+   * @param namespace the namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(String serviceName, HashMap label, String namespace) throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE,\n+        null,", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxODkyNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403218924", "bodyText": "added explanation.", "author": "sankarpn", "createdAt": "2020-04-03T18:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMzgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwNDA2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403004061", "bodyText": "put space after colon", "author": "markxnelson", "createdAt": "2020-04-03T13:27:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -3,30 +3,268 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.concurrent.Callable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n \n-public class Kubernetes {\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceList;\n+import io.kubernetes.client.util.ClientBuilder;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n-  public static Callable<Boolean> podExists(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+public class Kubernetes implements LoggedTest {\n+\n+  private static final String OPERATOR_NAME = \"weblogic-operator-\";\n+\n+  private static ApiClient apiClient = null;\n+  private static CoreV1Api coreV1Api = null;\n+  private static CustomObjectsApi customObjectsApi = null;\n+  private static final String RUNNING = \"Running\";\n+  private static final String TERMINATING = \"Terminating\";\n+\n+  static {\n+    try {\n+      Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n+      apiClient = Configuration.getDefaultApiClient();\n+      coreV1Api = new CoreV1Api();\n+      customObjectsApi = new CustomObjectsApi();\n+    } catch (IOException ioex) {\n+      throw new ExceptionInInitializerError(ioex);\n+    }\n   }\n \n-  public static Callable<Boolean> podRunning(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodExists(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod exists in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod != null;\n   }\n \n-  public static Callable<Boolean> podTerminating(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace and in Running state.\n+   * @param namespace in which to check for the pod running\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodRunning(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod running in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(RUNNING);\n   }\n \n-  public static boolean serviceCreated(String domainUID, String namespace) {\n-    return true;\n+  /**\n+   * Checks if a pod exists in a given namespace and in Terminating state.\n+   * @param namespace in which to check for the pod\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod is in Terminating state otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodTerminating(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod terminating in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(TERMINATING);\n+  }\n+\n+  /**\n+   * Checks if a Operator pod exists in a given namespace.\n+   * The method assumes the operator name to starts with weblogic-operator-\n+   * and decorated with label weblogic.operatorName:namespace\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isOperatorPodRunning(String namespace) throws ApiException {\n+    String labelSelector = String.format(\"weblogic.operatorName in (%s)\", namespace);\n+    V1Pod pod = getPod(namespace, labelSelector, \"weblogic-operator-\");\n+    return pod.getStatus().getPhase().equals(RUNNING);\n+  }\n+\n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList v1PodList =\n+        coreV1Api.listNamespacedPod(\n+            namespace,\n+            Boolean.FALSE.toString(),\n+            Boolean.FALSE,\n+            null,\n+            null,\n+            labelSelector,\n+            null,\n+            null,\n+            null,\n+            Boolean.FALSE);\n+    for (V1Pod item : v1PodList.getItems()) {\n+      if (item.getMetadata().getName().startsWith(podName.trim())) {\n+        logger.info(\"Pod Name :\" + item.getMetadata().getName());\n+        logger.info(\"Pod Namespace :\" + item.getMetadata().getNamespace());\n+        logger.info(\"Pod UID :\" + item.getMetadata().getUid());\n+        logger.info(\"Pod Status :\" + item.getStatus().getPhase());\n+        return item;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Checks if a Kubernetes service object exists in a given namespace.\n+   * @param serviceName name of the service to check for\n+   * @param label the key value pair with which the service is decorated with\n+   * @param namespace the namespace in which to check for the service\n+   * @return true if the service is found otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isServiceCreated(String serviceName, HashMap label, String namespace) throws ApiException {\n+    return getService(serviceName, label, namespace) != null;\n+  }\n+\n+  /**\n+   * Get V1Service object for the given servicename, label and namespace\n+   * @param serviceName name of the service to look for\n+   * @param label the key value pair with which the service is decorated with\n+   * @param namespace the namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(String serviceName, HashMap label, String namespace) throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE,\n+        null,\n+        null,\n+        labelSelector,\n+        null,\n+        Boolean.FALSE.toString(),\n+        null,\n+        null,\n+        Boolean.FALSE);\n+    for (V1Service service : v1ServiceList.getItems()) {\n+      if (service.getMetadata().getName().equals(serviceName.trim())\n+          && service.getMetadata().getNamespace().equals(namespace.trim())) {\n+        logger.info(\"Service Name :\" + service.getMetadata().getName());", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxOTMyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403219321", "bodyText": "done", "author": "sankarpn", "createdAt": "2020-04-03T18:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwNDA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwNDUyNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403004526", "bodyText": "explain", "author": "markxnelson", "createdAt": "2020-04-03T13:27:57Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -3,30 +3,268 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.concurrent.Callable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n \n-public class Kubernetes {\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceList;\n+import io.kubernetes.client.util.ClientBuilder;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n-  public static Callable<Boolean> podExists(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+public class Kubernetes implements LoggedTest {\n+\n+  private static final String OPERATOR_NAME = \"weblogic-operator-\";\n+\n+  private static ApiClient apiClient = null;\n+  private static CoreV1Api coreV1Api = null;\n+  private static CustomObjectsApi customObjectsApi = null;\n+  private static final String RUNNING = \"Running\";\n+  private static final String TERMINATING = \"Terminating\";\n+\n+  static {\n+    try {\n+      Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n+      apiClient = Configuration.getDefaultApiClient();\n+      coreV1Api = new CoreV1Api();\n+      customObjectsApi = new CustomObjectsApi();\n+    } catch (IOException ioex) {\n+      throw new ExceptionInInitializerError(ioex);\n+    }\n   }\n \n-  public static Callable<Boolean> podRunning(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodExists(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod exists in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod != null;\n   }\n \n-  public static Callable<Boolean> podTerminating(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace and in Running state.\n+   * @param namespace in which to check for the pod running\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodRunning(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod running in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(RUNNING);\n   }\n \n-  public static boolean serviceCreated(String domainUID, String namespace) {\n-    return true;\n+  /**\n+   * Checks if a pod exists in a given namespace and in Terminating state.\n+   * @param namespace in which to check for the pod\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod is in Terminating state otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodTerminating(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod terminating in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(TERMINATING);\n+  }\n+\n+  /**\n+   * Checks if a Operator pod exists in a given namespace.\n+   * The method assumes the operator name to starts with weblogic-operator-\n+   * and decorated with label weblogic.operatorName:namespace\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isOperatorPodRunning(String namespace) throws ApiException {\n+    String labelSelector = String.format(\"weblogic.operatorName in (%s)\", namespace);\n+    V1Pod pod = getPod(namespace, labelSelector, \"weblogic-operator-\");\n+    return pod.getStatus().getPhase().equals(RUNNING);\n+  }\n+\n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList v1PodList =\n+        coreV1Api.listNamespacedPod(\n+            namespace,\n+            Boolean.FALSE.toString(),\n+            Boolean.FALSE,\n+            null,\n+            null,\n+            labelSelector,\n+            null,\n+            null,\n+            null,\n+            Boolean.FALSE);\n+    for (V1Pod item : v1PodList.getItems()) {\n+      if (item.getMetadata().getName().startsWith(podName.trim())) {\n+        logger.info(\"Pod Name :\" + item.getMetadata().getName());\n+        logger.info(\"Pod Namespace :\" + item.getMetadata().getNamespace());\n+        logger.info(\"Pod UID :\" + item.getMetadata().getUid());\n+        logger.info(\"Pod Status :\" + item.getStatus().getPhase());\n+        return item;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Checks if a Kubernetes service object exists in a given namespace.\n+   * @param serviceName name of the service to check for\n+   * @param label the key value pair with which the service is decorated with\n+   * @param namespace the namespace in which to check for the service\n+   * @return true if the service is found otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isServiceCreated(String serviceName, HashMap label, String namespace) throws ApiException {\n+    return getService(serviceName, label, namespace) != null;\n+  }\n+\n+  /**\n+   * Get V1Service object for the given servicename, label and namespace\n+   * @param serviceName name of the service to look for\n+   * @param label the key value pair with which the service is decorated with\n+   * @param namespace the namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(String serviceName, HashMap label, String namespace) throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE,\n+        null,\n+        null,\n+        labelSelector,\n+        null,\n+        Boolean.FALSE.toString(),\n+        null,\n+        null,\n+        Boolean.FALSE);\n+    for (V1Service service : v1ServiceList.getItems()) {\n+      if (service.getMetadata().getName().equals(serviceName.trim())\n+          && service.getMetadata().getNamespace().equals(namespace.trim())) {\n+        logger.info(\"Service Name :\" + service.getMetadata().getName());\n+        logger.info(\"Service Namespace :\" + service.getMetadata().getNamespace());\n+        Map<String, String> labels = service.getMetadata().getLabels();\n+        if (labels != null) {\n+          for (Map.Entry<String, String> entry : labels.entrySet()) {\n+            logger.log(Level.INFO, \"Label Key: {0} Label Value: {1}\",\n+                new Object[]{entry.getKey(), entry.getValue()});\n+          }\n+        }\n+        return service;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * A utility method to list all pods in given namespace and a label\n+   * This method can be used as diagnostic tool to get the details of pods.\n+   * @param namespace in which to list all pods\n+   * @param labelSelectors with which the pods are decorated\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static void listPods(String namespace, String labelSelectors) throws ApiException {\n+    V1PodList v1PodList =\n+        coreV1Api.listNamespacedPod(\n+            namespace,\n+            Boolean.FALSE.toString(),\n+            Boolean.FALSE,\n+            null,", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxOTYwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403219604", "bodyText": "added explanation", "author": "sankarpn", "createdAt": "2020-04-03T18:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwNDUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwNDU5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403004597", "bodyText": "explain", "author": "markxnelson", "createdAt": "2020-04-03T13:28:03Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -3,30 +3,268 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.concurrent.Callable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n \n-public class Kubernetes {\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceList;\n+import io.kubernetes.client.util.ClientBuilder;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n-  public static Callable<Boolean> podExists(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+public class Kubernetes implements LoggedTest {\n+\n+  private static final String OPERATOR_NAME = \"weblogic-operator-\";\n+\n+  private static ApiClient apiClient = null;\n+  private static CoreV1Api coreV1Api = null;\n+  private static CustomObjectsApi customObjectsApi = null;\n+  private static final String RUNNING = \"Running\";\n+  private static final String TERMINATING = \"Terminating\";\n+\n+  static {\n+    try {\n+      Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n+      apiClient = Configuration.getDefaultApiClient();\n+      coreV1Api = new CoreV1Api();\n+      customObjectsApi = new CustomObjectsApi();\n+    } catch (IOException ioex) {\n+      throw new ExceptionInInitializerError(ioex);\n+    }\n   }\n \n-  public static Callable<Boolean> podRunning(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodExists(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod exists in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod != null;\n   }\n \n-  public static Callable<Boolean> podTerminating(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace and in Running state.\n+   * @param namespace in which to check for the pod running\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodRunning(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod running in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(RUNNING);\n   }\n \n-  public static boolean serviceCreated(String domainUID, String namespace) {\n-    return true;\n+  /**\n+   * Checks if a pod exists in a given namespace and in Terminating state.\n+   * @param namespace in which to check for the pod\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod is in Terminating state otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodTerminating(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod terminating in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(TERMINATING);\n+  }\n+\n+  /**\n+   * Checks if a Operator pod exists in a given namespace.\n+   * The method assumes the operator name to starts with weblogic-operator-\n+   * and decorated with label weblogic.operatorName:namespace\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isOperatorPodRunning(String namespace) throws ApiException {\n+    String labelSelector = String.format(\"weblogic.operatorName in (%s)\", namespace);\n+    V1Pod pod = getPod(namespace, labelSelector, \"weblogic-operator-\");\n+    return pod.getStatus().getPhase().equals(RUNNING);\n+  }\n+\n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList v1PodList =\n+        coreV1Api.listNamespacedPod(\n+            namespace,\n+            Boolean.FALSE.toString(),\n+            Boolean.FALSE,\n+            null,\n+            null,\n+            labelSelector,\n+            null,\n+            null,\n+            null,\n+            Boolean.FALSE);\n+    for (V1Pod item : v1PodList.getItems()) {\n+      if (item.getMetadata().getName().startsWith(podName.trim())) {\n+        logger.info(\"Pod Name :\" + item.getMetadata().getName());\n+        logger.info(\"Pod Namespace :\" + item.getMetadata().getNamespace());\n+        logger.info(\"Pod UID :\" + item.getMetadata().getUid());\n+        logger.info(\"Pod Status :\" + item.getStatus().getPhase());\n+        return item;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Checks if a Kubernetes service object exists in a given namespace.\n+   * @param serviceName name of the service to check for\n+   * @param label the key value pair with which the service is decorated with\n+   * @param namespace the namespace in which to check for the service\n+   * @return true if the service is found otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isServiceCreated(String serviceName, HashMap label, String namespace) throws ApiException {\n+    return getService(serviceName, label, namespace) != null;\n+  }\n+\n+  /**\n+   * Get V1Service object for the given servicename, label and namespace\n+   * @param serviceName name of the service to look for\n+   * @param label the key value pair with which the service is decorated with\n+   * @param namespace the namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(String serviceName, HashMap label, String namespace) throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE,\n+        null,\n+        null,\n+        labelSelector,\n+        null,\n+        Boolean.FALSE.toString(),\n+        null,\n+        null,\n+        Boolean.FALSE);\n+    for (V1Service service : v1ServiceList.getItems()) {\n+      if (service.getMetadata().getName().equals(serviceName.trim())\n+          && service.getMetadata().getNamespace().equals(namespace.trim())) {\n+        logger.info(\"Service Name :\" + service.getMetadata().getName());\n+        logger.info(\"Service Namespace :\" + service.getMetadata().getNamespace());\n+        Map<String, String> labels = service.getMetadata().getLabels();\n+        if (labels != null) {\n+          for (Map.Entry<String, String> entry : labels.entrySet()) {\n+            logger.log(Level.INFO, \"Label Key: {0} Label Value: {1}\",\n+                new Object[]{entry.getKey(), entry.getValue()});\n+          }\n+        }\n+        return service;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * A utility method to list all pods in given namespace and a label\n+   * This method can be used as diagnostic tool to get the details of pods.\n+   * @param namespace in which to list all pods\n+   * @param labelSelectors with which the pods are decorated\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static void listPods(String namespace, String labelSelectors) throws ApiException {\n+    V1PodList v1PodList =\n+        coreV1Api.listNamespacedPod(\n+            namespace,\n+            Boolean.FALSE.toString(),\n+            Boolean.FALSE,\n+            null,\n+            null,\n+            labelSelectors,\n+            null,\n+            null,\n+            null,\n+            Boolean.FALSE);\n+    List<V1Pod> items = v1PodList.getItems();\n+    logger.info(Arrays.toString(items.toArray()));\n+  }\n+\n+  /**\n+   * A utillity method to list all services in a given namespace.\n+   * This method can be used as diagnostic tool to get the details of services.\n+   * @param namespace in which to list all services\n+   * @param labelSelectors  with which the services are decorated\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static void listServices(String namespace, String labelSelectors) throws ApiException {\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE,\n+        null,", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxOTg2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403219860", "bodyText": "added explanation", "author": "sankarpn", "createdAt": "2020-04-03T18:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwNDU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwNDY5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403004690", "bodyText": "space after colon", "author": "markxnelson", "createdAt": "2020-04-03T13:28:13Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -3,30 +3,268 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.concurrent.Callable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n \n-public class Kubernetes {\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServiceList;\n+import io.kubernetes.client.util.ClientBuilder;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n-  public static Callable<Boolean> podExists(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+public class Kubernetes implements LoggedTest {\n+\n+  private static final String OPERATOR_NAME = \"weblogic-operator-\";\n+\n+  private static ApiClient apiClient = null;\n+  private static CoreV1Api coreV1Api = null;\n+  private static CustomObjectsApi customObjectsApi = null;\n+  private static final String RUNNING = \"Running\";\n+  private static final String TERMINATING = \"Terminating\";\n+\n+  static {\n+    try {\n+      Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n+      apiClient = Configuration.getDefaultApiClient();\n+      coreV1Api = new CoreV1Api();\n+      customObjectsApi = new CustomObjectsApi();\n+    } catch (IOException ioex) {\n+      throw new ExceptionInInitializerError(ioex);\n+    }\n   }\n \n-  public static Callable<Boolean> podRunning(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodExists(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod exists in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod != null;\n   }\n \n-  public static Callable<Boolean> podTerminating(String podName, String domainUID, String namespace) {\n-    return () -> {\n-      return true;\n-    };\n+  /**\n+   * Checks if a pod exists in a given namespace and in Running state.\n+   * @param namespace in which to check for the pod running\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodRunning(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod running in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(RUNNING);\n   }\n \n-  public static boolean serviceCreated(String domainUID, String namespace) {\n-    return true;\n+  /**\n+   * Checks if a pod exists in a given namespace and in Terminating state.\n+   * @param namespace in which to check for the pod\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod is in Terminating state otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isPodTerminating(String namespace, String domainUid, String podName) throws ApiException {\n+    logger.info(\"Checking if the pod terminating in namespace\");\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    return pod.getStatus().getPhase().equals(TERMINATING);\n+  }\n+\n+  /**\n+   * Checks if a Operator pod exists in a given namespace.\n+   * The method assumes the operator name to starts with weblogic-operator-\n+   * and decorated with label weblogic.operatorName:namespace\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pod exists and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isOperatorPodRunning(String namespace) throws ApiException {\n+    String labelSelector = String.format(\"weblogic.operatorName in (%s)\", namespace);\n+    V1Pod pod = getPod(namespace, labelSelector, \"weblogic-operator-\");\n+    return pod.getStatus().getPhase().equals(RUNNING);\n+  }\n+\n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList v1PodList =\n+        coreV1Api.listNamespacedPod(\n+            namespace,\n+            Boolean.FALSE.toString(),\n+            Boolean.FALSE,\n+            null,\n+            null,\n+            labelSelector,\n+            null,\n+            null,\n+            null,\n+            Boolean.FALSE);\n+    for (V1Pod item : v1PodList.getItems()) {\n+      if (item.getMetadata().getName().startsWith(podName.trim())) {\n+        logger.info(\"Pod Name :\" + item.getMetadata().getName());\n+        logger.info(\"Pod Namespace :\" + item.getMetadata().getNamespace());\n+        logger.info(\"Pod UID :\" + item.getMetadata().getUid());\n+        logger.info(\"Pod Status :\" + item.getStatus().getPhase());\n+        return item;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Checks if a Kubernetes service object exists in a given namespace.\n+   * @param serviceName name of the service to check for\n+   * @param label the key value pair with which the service is decorated with\n+   * @param namespace the namespace in which to check for the service\n+   * @return true if the service is found otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isServiceCreated(String serviceName, HashMap label, String namespace) throws ApiException {\n+    return getService(serviceName, label, namespace) != null;\n+  }\n+\n+  /**\n+   * Get V1Service object for the given servicename, label and namespace\n+   * @param serviceName name of the service to look for\n+   * @param label the key value pair with which the service is decorated with\n+   * @param namespace the namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(String serviceName, HashMap label, String namespace) throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE,\n+        null,\n+        null,\n+        labelSelector,\n+        null,\n+        Boolean.FALSE.toString(),\n+        null,\n+        null,\n+        Boolean.FALSE);\n+    for (V1Service service : v1ServiceList.getItems()) {\n+      if (service.getMetadata().getName().equals(serviceName.trim())\n+          && service.getMetadata().getNamespace().equals(namespace.trim())) {\n+        logger.info(\"Service Name :\" + service.getMetadata().getName());\n+        logger.info(\"Service Namespace :\" + service.getMetadata().getNamespace());\n+        Map<String, String> labels = service.getMetadata().getLabels();\n+        if (labels != null) {\n+          for (Map.Entry<String, String> entry : labels.entrySet()) {\n+            logger.log(Level.INFO, \"Label Key: {0} Label Value: {1}\",\n+                new Object[]{entry.getKey(), entry.getValue()});\n+          }\n+        }\n+        return service;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * A utility method to list all pods in given namespace and a label\n+   * This method can be used as diagnostic tool to get the details of pods.\n+   * @param namespace in which to list all pods\n+   * @param labelSelectors with which the pods are decorated\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static void listPods(String namespace, String labelSelectors) throws ApiException {\n+    V1PodList v1PodList =\n+        coreV1Api.listNamespacedPod(\n+            namespace,\n+            Boolean.FALSE.toString(),\n+            Boolean.FALSE,\n+            null,\n+            null,\n+            labelSelectors,\n+            null,\n+            null,\n+            null,\n+            Boolean.FALSE);\n+    List<V1Pod> items = v1PodList.getItems();\n+    logger.info(Arrays.toString(items.toArray()));\n+  }\n+\n+  /**\n+   * A utillity method to list all services in a given namespace.\n+   * This method can be used as diagnostic tool to get the details of services.\n+   * @param namespace in which to list all services\n+   * @param labelSelectors  with which the services are decorated\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static void listServices(String namespace, String labelSelectors) throws ApiException {\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE,\n+        null,\n+        null,\n+        labelSelectors,\n+        null,\n+        Boolean.FALSE.toString(),\n+        null,\n+        null,\n+        Boolean.FALSE);\n+    List<V1Service> items = v1ServiceList.getItems();\n+    logger.info(Arrays.toString(items.toArray()));\n+    for (V1Service service : items) {\n+      logger.info(\"Service Name :\" + service.getMetadata().getName());", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMDA1MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403220050", "bodyText": "done", "author": "sankarpn", "createdAt": "2020-04-03T18:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwNDY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwNTI3NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403005275", "bodyText": "this is not a test -- should not implement LoggedTest\njust use a static import to get the logger (this is done in other assertion impls)", "author": "markxnelson", "createdAt": "2020-04-03T13:29:04Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Operator.java", "diffHunk": "@@ -3,30 +3,36 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.Random;\n+import java.util.HashMap;\n import java.util.concurrent.Callable;\n \n-import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import io.kubernetes.client.openapi.ApiException;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n \n-public class Operator {\n+public class Operator implements LoggedTest {", "originalCommit": "46b79449efedaefca03b93f7514f88b9f8b6e2c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMDIxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403220213", "bodyText": "added a static import", "author": "sankarpn", "createdAt": "2020-04-03T18:23:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwNTI3NQ=="}], "type": "inlineReview"}, {"oid": "3d45c41013ba80bbcfca2ea2e54222c38f59a3fe", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3d45c41013ba80bbcfca2ea2e54222c38f59a3fe", "message": "Merge branch 'mii-new-integration-tests' of https://github.com/oracle/weblogic-kubernetes-operator into sankar-junit5-1", "committedDate": "2020-04-03T16:41:38Z", "type": "commit"}, {"oid": "b11fed14f61b22affc34cd72a1fc8d46e6f59db5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b11fed14f61b22affc34cd72a1fc8d46e6f59db5", "message": "addressed the PR comments", "committedDate": "2020-04-03T18:20:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1Mjc0MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403252741", "bodyText": "fix comma and asterisk at the end", "author": "markxnelson", "createdAt": "2020-04-03T19:06:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -3,19 +3,23 @@\n \n package oracle.weblogic.kubernetes.assertions;\n \n+import java.util.Map;\n import java.util.concurrent.Callable;\n \n+import io.kubernetes.client.openapi.ApiException;\n import oracle.weblogic.kubernetes.assertions.impl.Domain;\n import oracle.weblogic.kubernetes.assertions.impl.Kubernetes;\n import oracle.weblogic.kubernetes.assertions.impl.Operator;\n \n \n-// as in the actions, it is intended tests only use these assertaions and do\n-// not go direct to the impl classes\n+/**\n+ * General assertions needed by the tests to validate CRD, Domain, Pods etc., *", "originalCommit": "b11fed14f61b22affc34cd72a1fc8d46e6f59db5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2NzAwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403267006", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-03T19:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1Mjc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2MjA1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403262057", "bodyText": "fix javadoc", "author": "markxnelson", "createdAt": "2020-04-03T19:26:10Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -5,17 +5,63 @@\n \n import java.util.concurrent.Callable;\n \n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.apis.ApiextensionsV1Api;\n+import io.kubernetes.client.openapi.apis.ApiextensionsV1beta1Api;\n+import io.kubernetes.client.openapi.apis.ApisApi;\n+import io.kubernetes.client.openapi.apis.CustomObjectsApi;\n+import io.kubernetes.client.openapi.models.V1beta1CustomResourceDefinition;\n+\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n public class Domain {\n \n-  public static Callable<Boolean> exists(String domainUID, String namespace) {\n-    return () -> {\n-      String[] pods = {};\n-      for (String pod : pods) {\n-        if (!Kubernetes.podRunning(pod, domainUID, namespace).call().booleanValue()) {\n-          return false;\n-        }\n-      }\n+  private static CustomObjectsApi customObjectsApi = new CustomObjectsApi();\n+  private static ApiextensionsV1Api apiextensionsV1Api = new ApiextensionsV1Api();\n+  private static ApiextensionsV1beta1Api apiextensionsV1beta1Api = new ApiextensionsV1beta1Api();\n+  private static ApisApi apisApi = new ApisApi();\n+\n+\n+  /**\n+   * Check if the Domain CRD exists\n+   * @return true if domains.weblogic.oracle CRD exists otherwise false\n+   * @throws Exception", "originalCommit": "b11fed14f61b22affc34cd72a1fc8d46e6f59db5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2NzA3MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1527#discussion_r403267071", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-04-03T19:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2MjA1Nw=="}], "type": "inlineReview"}, {"oid": "bb9ccf7bc1549ca1d11c76edb2e00503971cfa24", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/bb9ccf7bc1549ca1d11c76edb2e00503971cfa24", "message": "fixed more javadoc comments", "committedDate": "2020-04-03T19:30:48Z", "type": "commit"}]}