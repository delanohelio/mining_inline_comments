{"pr_number": 1888, "pr_title": "Converted Usability Tests to Junit5", "pr_createdAt": "2020-08-27T16:03:06Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888", "timeline": [{"oid": "0c20a6c55c30f88b3edd726d88499d76d22b196d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0c20a6c55c30f88b3edd726d88499d76d22b196d", "message": "added usability tests", "committedDate": "2020-08-25T16:21:11Z", "type": "commit"}, {"oid": "a406930cd9f377be5d6c549d6f02d4a4761e7bf5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a406930cd9f377be5d6c549d6f02d4a4761e7bf5", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into usabtest", "committedDate": "2020-08-25T16:21:26Z", "type": "commit"}, {"oid": "c42b8809a526b9c9d95c255ac33895c61171df1b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c42b8809a526b9c9d95c255ac33895c61171df1b", "message": "fixed some typos", "committedDate": "2020-08-25T22:10:46Z", "type": "commit"}, {"oid": "4096a611b56b590ff7fa930bd9a292018ff30e2e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4096a611b56b590ff7fa930bd9a292018ff30e2e", "message": "added cleanup", "committedDate": "2020-08-26T00:37:09Z", "type": "commit"}, {"oid": "5bae3c02d2256a569d78e53c8b34792ff0dcc745", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5bae3c02d2256a569d78e53c8b34792ff0dcc745", "message": "fixed update", "committedDate": "2020-08-26T18:38:39Z", "type": "commit"}, {"oid": "62e8277a0ba931bfbf709c399e0434b42453393e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/62e8277a0ba931bfbf709c399e0434b42453393e", "message": "fixed upgrade test", "committedDate": "2020-08-26T22:09:23Z", "type": "commit"}, {"oid": "c7abc14662fc10fb51eb7283d6ed3f0f773dc18b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c7abc14662fc10fb51eb7283d6ed3f0f773dc18b", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into usabtest", "committedDate": "2020-08-26T22:09:41Z", "type": "commit"}, {"oid": "b4fdd68cb522035fb6adbc8943a29e4cabca1dc2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b4fdd68cb522035fb6adbc8943a29e4cabca1dc2", "message": "cherrypick fix from Maggie", "committedDate": "2020-08-26T22:33:00Z", "type": "commit"}, {"oid": "71a15adbd6e67686a120630be44c869114ecc34b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/71a15adbd6e67686a120630be44c869114ecc34b", "message": "removed old class", "committedDate": "2020-08-27T17:21:35Z", "type": "commit"}, {"oid": "bb6dcba68614bb968a9f1830e03fc072c9608ec6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/bb6dcba68614bb968a9f1830e03fc072c9608ec6", "message": "merged", "committedDate": "2020-08-27T17:24:03Z", "type": "commit"}, {"oid": "82b20e67eea574546db8c793369afc31b01e6f9f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/82b20e67eea574546db8c793369afc31b01e6f9f", "message": "merge from develop", "committedDate": "2020-08-27T17:33:07Z", "type": "commit"}, {"oid": "f494e7be0afaa47dc80e5409712098226e89e995", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f494e7be0afaa47dc80e5409712098226e89e995", "message": "merge", "committedDate": "2020-08-27T17:45:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyOTczOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478729738", "bodyText": "Is adding an extra line the only change of this class? :)", "author": "maggiehe00", "createdAt": "2020-08-27T22:26:42Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/HelmParams.java", "diffHunk": "@@ -98,4 +98,5 @@ public String getFilter() {\n   public String getChartVersion() {\n     return chartVersion;\n   }\n+", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczNDI0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478734246", "bodyText": "I guess I added something and then removed it. yes looks like no changes in this class", "author": "marinakog", "createdAt": "2020-08-27T22:40:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyOTczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDQ0Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478740442", "bodyText": "Remove @slow @MustNotRunInParallel from all methods", "author": "anpanigr", "createdAt": "2020-08-27T22:58:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -199,49 +258,451 @@ public void testDeleteOperatorButNotDomain() {\n     }\n \n     logger.info(\"Checking that the admin server pod state was not changed after the operator was deleted\");\n-    assertThat(podStateNotChanged(adminServerPodName, domainUid, domainNamespace, adminPodOriginalTimestamp))\n-        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domainNamespace)\n+    assertThat(podStateNotChanged(adminServerPodName, domain1Uid,\n+        domain1Namespace, adminPodOriginalTimestamp))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domain1Namespace)\n         .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-            adminServerPodName, domainNamespace)\n+            adminServerPodName, domain1Namespace)\n         .isTrue();\n \n     // check that the states of managed server pods in the domain were not changed\n     logger.info(\"Checking that the managed server pod state was not changed after the operator was deleted\");\n     for (int i = 1; i <= replicaCount; i++) {\n       String managedServerPodName = managedServerPrefix + i;\n-      assertThat(podStateNotChanged(managedServerPodName, domainUid, domainNamespace,\n+      assertThat(podStateNotChanged(managedServerPodName, domain1Uid, domain1Namespace,\n               managedServerPodOriginalTimestampList.get(i - 1)))\n-          .as(\"Test state of pod {0} was not changed in namespace {1}\", managedServerPodName, domainNamespace)\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain1Namespace)\n           .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-              managedServerPodName, domainNamespace)\n+              managedServerPodName, domain1Namespace)\n           .isTrue();\n     }\n \n     // verify the sample app in the domain is still accessible from all managed servers through NGINX\n     logger.info(\"Checking that the sample app can be accessed from all managed servers through NGINX \"\n         + \"after the operator was deleted\");\n     verifySampleAppAccessThroughNginx();\n+\n   }\n \n   /**\n-   * TODO: remove this after Sankar's PR is merged\n-   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   * Create operator and verify it is deployed successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Verify NGINX can access the sample app from all managed servers in the domain.\n+   * Delete operator.\n+   * Verify the states of all server pods in the domain were not changed.\n+   * Verify NGINX can access the sample app from all managed servers in the domain after the operator was deleted.\n+   * Test fails if the state of any pod in the domain was changed or NGINX can not access the sample app from\n+   * all managed servers in the absence of operator.\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Test\n+  @DisplayName(\"Create operator and domain, then delete operator and\"\n+      + \" create again operator and verify it can still manage domain\")\n+  @Slow", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc3MDgyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478770821", "bodyText": "done", "author": "marinakog", "createdAt": "2020-08-28T00:48:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MjIwOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478742208", "bodyText": "Explain \"Delete operator\"  Are you deleting the Operator Pod or Changing the Replica to Zero.", "author": "anpanigr", "createdAt": "2020-08-27T23:03:46Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -199,49 +258,451 @@ public void testDeleteOperatorButNotDomain() {\n     }\n \n     logger.info(\"Checking that the admin server pod state was not changed after the operator was deleted\");\n-    assertThat(podStateNotChanged(adminServerPodName, domainUid, domainNamespace, adminPodOriginalTimestamp))\n-        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domainNamespace)\n+    assertThat(podStateNotChanged(adminServerPodName, domain1Uid,\n+        domain1Namespace, adminPodOriginalTimestamp))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domain1Namespace)\n         .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-            adminServerPodName, domainNamespace)\n+            adminServerPodName, domain1Namespace)\n         .isTrue();\n \n     // check that the states of managed server pods in the domain were not changed\n     logger.info(\"Checking that the managed server pod state was not changed after the operator was deleted\");\n     for (int i = 1; i <= replicaCount; i++) {\n       String managedServerPodName = managedServerPrefix + i;\n-      assertThat(podStateNotChanged(managedServerPodName, domainUid, domainNamespace,\n+      assertThat(podStateNotChanged(managedServerPodName, domain1Uid, domain1Namespace,\n               managedServerPodOriginalTimestampList.get(i - 1)))\n-          .as(\"Test state of pod {0} was not changed in namespace {1}\", managedServerPodName, domainNamespace)\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain1Namespace)\n           .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-              managedServerPodName, domainNamespace)\n+              managedServerPodName, domain1Namespace)\n           .isTrue();\n     }\n \n     // verify the sample app in the domain is still accessible from all managed servers through NGINX\n     logger.info(\"Checking that the sample app can be accessed from all managed servers through NGINX \"\n         + \"after the operator was deleted\");\n     verifySampleAppAccessThroughNginx();\n+\n   }\n \n   /**\n-   * TODO: remove this after Sankar's PR is merged\n-   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   * Create operator and verify it is deployed successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Verify NGINX can access the sample app from all managed servers in the domain.\n+   * Delete operator.", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc3MDc5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478770798", "bodyText": "changed to uninstall", "author": "marinakog", "createdAt": "2020-08-28T00:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MjIwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwMTIyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479501222", "bodyText": "Uninstall operator --> Uninstall operator helm chart.", "author": "anpanigr", "createdAt": "2020-08-28T19:42:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MjIwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxNzQ2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r480317462", "bodyText": "done", "author": "marinakog", "createdAt": "2020-08-31T18:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MjIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0Mjg2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478742868", "bodyText": "This is obvious from the previous \"Verify ...\"  statements.  You may remove two lines \"Test fails ...\"", "author": "anpanigr", "createdAt": "2020-08-27T23:05:42Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -199,49 +258,451 @@ public void testDeleteOperatorButNotDomain() {\n     }\n \n     logger.info(\"Checking that the admin server pod state was not changed after the operator was deleted\");\n-    assertThat(podStateNotChanged(adminServerPodName, domainUid, domainNamespace, adminPodOriginalTimestamp))\n-        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domainNamespace)\n+    assertThat(podStateNotChanged(adminServerPodName, domain1Uid,\n+        domain1Namespace, adminPodOriginalTimestamp))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domain1Namespace)\n         .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-            adminServerPodName, domainNamespace)\n+            adminServerPodName, domain1Namespace)\n         .isTrue();\n \n     // check that the states of managed server pods in the domain were not changed\n     logger.info(\"Checking that the managed server pod state was not changed after the operator was deleted\");\n     for (int i = 1; i <= replicaCount; i++) {\n       String managedServerPodName = managedServerPrefix + i;\n-      assertThat(podStateNotChanged(managedServerPodName, domainUid, domainNamespace,\n+      assertThat(podStateNotChanged(managedServerPodName, domain1Uid, domain1Namespace,\n               managedServerPodOriginalTimestampList.get(i - 1)))\n-          .as(\"Test state of pod {0} was not changed in namespace {1}\", managedServerPodName, domainNamespace)\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain1Namespace)\n           .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-              managedServerPodName, domainNamespace)\n+              managedServerPodName, domain1Namespace)\n           .isTrue();\n     }\n \n     // verify the sample app in the domain is still accessible from all managed servers through NGINX\n     logger.info(\"Checking that the sample app can be accessed from all managed servers through NGINX \"\n         + \"after the operator was deleted\");\n     verifySampleAppAccessThroughNginx();\n+\n   }\n \n   /**\n-   * TODO: remove this after Sankar's PR is merged\n-   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   * Create operator and verify it is deployed successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Verify NGINX can access the sample app from all managed servers in the domain.\n+   * Delete operator.\n+   * Verify the states of all server pods in the domain were not changed.\n+   * Verify NGINX can access the sample app from all managed servers in the domain after the operator was deleted.\n+   * Test fails if the state of any pod in the domain was changed or NGINX can not access the sample app from", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc3MDc4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478770788", "bodyText": "done", "author": "marinakog", "createdAt": "2020-08-28T00:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0Mjg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NTY4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478745682", "bodyText": "Remove commented code", "author": "anpanigr", "createdAt": "2020-08-27T23:14:33Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -199,49 +258,451 @@ public void testDeleteOperatorButNotDomain() {\n     }\n \n     logger.info(\"Checking that the admin server pod state was not changed after the operator was deleted\");\n-    assertThat(podStateNotChanged(adminServerPodName, domainUid, domainNamespace, adminPodOriginalTimestamp))\n-        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domainNamespace)\n+    assertThat(podStateNotChanged(adminServerPodName, domain1Uid,\n+        domain1Namespace, adminPodOriginalTimestamp))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domain1Namespace)\n         .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-            adminServerPodName, domainNamespace)\n+            adminServerPodName, domain1Namespace)\n         .isTrue();\n \n     // check that the states of managed server pods in the domain were not changed\n     logger.info(\"Checking that the managed server pod state was not changed after the operator was deleted\");\n     for (int i = 1; i <= replicaCount; i++) {\n       String managedServerPodName = managedServerPrefix + i;\n-      assertThat(podStateNotChanged(managedServerPodName, domainUid, domainNamespace,\n+      assertThat(podStateNotChanged(managedServerPodName, domain1Uid, domain1Namespace,\n               managedServerPodOriginalTimestampList.get(i - 1)))\n-          .as(\"Test state of pod {0} was not changed in namespace {1}\", managedServerPodName, domainNamespace)\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain1Namespace)\n           .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-              managedServerPodName, domainNamespace)\n+              managedServerPodName, domain1Namespace)\n           .isTrue();\n     }\n \n     // verify the sample app in the domain is still accessible from all managed servers through NGINX\n     logger.info(\"Checking that the sample app can be accessed from all managed servers through NGINX \"\n         + \"after the operator was deleted\");\n     verifySampleAppAccessThroughNginx();\n+\n   }\n \n   /**\n-   * TODO: remove this after Sankar's PR is merged\n-   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   * Create operator and verify it is deployed successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Verify NGINX can access the sample app from all managed servers in the domain.\n+   * Delete operator.\n+   * Verify the states of all server pods in the domain were not changed.\n+   * Verify NGINX can access the sample app from all managed servers in the domain after the operator was deleted.\n+   * Test fails if the state of any pod in the domain was changed or NGINX can not access the sample app from\n+   * all managed servers in the absence of operator.\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Test\n+  @DisplayName(\"Create operator and domain, then delete operator and\"\n+      + \" create again operator and verify it can still manage domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateDeleteCreateOperatorButNotDomain() {\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    try {\n+      // install operator\n+\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+      // delete operator\n+      logger.info(\"Uninstalling operator\");\n+      uninstallOperator(opHelmParams);\n+\n+      //install second time\n+      opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, false, true, false,\n+          null,\"deployed\", 0, opHelmParams, false, domain1Namespace);\n+\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      //check if can still manage domain1\n+      assertTrue(scaleDomain(domain1Namespace, domain1Uid,2,1,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Create operator and verify it is deployed successfully\n+   * Create domain1 and verify the domain is started\n+   * Upgrade the operator domainNamespaces to include namespace for domain2\n+   * Verify both domains are managed by the operator by making a REST API call\n+   * Call helm upgrade to remove the first domain from operator domainNamespaces\n+   * Verify it can't be managed by operator anymore.\n+   * Test fails when an operator fails to manage the domains as expected\n+   */\n+  @Test\n+  @DisplayName(\"Create domain1, managed by operator and domain2, upgrade operator for domain2,\"\n+      + \"delete domain1 , verify management for domain2 and no access to domain1\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddRemoveDomainUpdateOperatorHC() throws Exception {\n+\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    try {\n+      // install operator\n+      String opServiceAccount = opNamespace + \"-sa\";\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+\n+      // operator chart values\n+      OperatorParams opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain1Namespace, domain2Namespace));\n+\n+      // upgrade operator\n+      assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+      //assertTrue(upgradeOperator(opParams), \"Helm Upgrade failed to add domain to operator\");", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc3MDc1MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478770751", "bodyText": "done", "author": "marinakog", "createdAt": "2020-08-28T00:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NTY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NTk3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478745977", "bodyText": "What is HC ?  The method name should be self explanatory as far as possible\nHow about testAddRemoveDomainNameSpacesOnOperator()", "author": "anpanigr", "createdAt": "2020-08-27T23:15:22Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -199,49 +258,451 @@ public void testDeleteOperatorButNotDomain() {\n     }\n \n     logger.info(\"Checking that the admin server pod state was not changed after the operator was deleted\");\n-    assertThat(podStateNotChanged(adminServerPodName, domainUid, domainNamespace, adminPodOriginalTimestamp))\n-        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domainNamespace)\n+    assertThat(podStateNotChanged(adminServerPodName, domain1Uid,\n+        domain1Namespace, adminPodOriginalTimestamp))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domain1Namespace)\n         .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-            adminServerPodName, domainNamespace)\n+            adminServerPodName, domain1Namespace)\n         .isTrue();\n \n     // check that the states of managed server pods in the domain were not changed\n     logger.info(\"Checking that the managed server pod state was not changed after the operator was deleted\");\n     for (int i = 1; i <= replicaCount; i++) {\n       String managedServerPodName = managedServerPrefix + i;\n-      assertThat(podStateNotChanged(managedServerPodName, domainUid, domainNamespace,\n+      assertThat(podStateNotChanged(managedServerPodName, domain1Uid, domain1Namespace,\n               managedServerPodOriginalTimestampList.get(i - 1)))\n-          .as(\"Test state of pod {0} was not changed in namespace {1}\", managedServerPodName, domainNamespace)\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain1Namespace)\n           .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-              managedServerPodName, domainNamespace)\n+              managedServerPodName, domain1Namespace)\n           .isTrue();\n     }\n \n     // verify the sample app in the domain is still accessible from all managed servers through NGINX\n     logger.info(\"Checking that the sample app can be accessed from all managed servers through NGINX \"\n         + \"after the operator was deleted\");\n     verifySampleAppAccessThroughNginx();\n+\n   }\n \n   /**\n-   * TODO: remove this after Sankar's PR is merged\n-   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   * Create operator and verify it is deployed successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Verify NGINX can access the sample app from all managed servers in the domain.\n+   * Delete operator.\n+   * Verify the states of all server pods in the domain were not changed.\n+   * Verify NGINX can access the sample app from all managed servers in the domain after the operator was deleted.\n+   * Test fails if the state of any pod in the domain was changed or NGINX can not access the sample app from\n+   * all managed servers in the absence of operator.\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Test\n+  @DisplayName(\"Create operator and domain, then delete operator and\"\n+      + \" create again operator and verify it can still manage domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateDeleteCreateOperatorButNotDomain() {\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    try {\n+      // install operator\n+\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+      // delete operator\n+      logger.info(\"Uninstalling operator\");\n+      uninstallOperator(opHelmParams);\n+\n+      //install second time\n+      opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, false, true, false,\n+          null,\"deployed\", 0, opHelmParams, false, domain1Namespace);\n+\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      //check if can still manage domain1\n+      assertTrue(scaleDomain(domain1Namespace, domain1Uid,2,1,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Create operator and verify it is deployed successfully\n+   * Create domain1 and verify the domain is started\n+   * Upgrade the operator domainNamespaces to include namespace for domain2\n+   * Verify both domains are managed by the operator by making a REST API call\n+   * Call helm upgrade to remove the first domain from operator domainNamespaces\n+   * Verify it can't be managed by operator anymore.\n+   * Test fails when an operator fails to manage the domains as expected\n+   */\n+  @Test\n+  @DisplayName(\"Create domain1, managed by operator and domain2, upgrade operator for domain2,\"\n+      + \"delete domain1 , verify management for domain2 and no access to domain1\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddRemoveDomainUpdateOperatorHC() throws Exception {", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc3MDkxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478770914", "bodyText": "HC- helm chart :) , fixed the method name", "author": "marinakog", "createdAt": "2020-08-28T00:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NzY4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478747688", "bodyText": "The method does not throws any Exception. Remove @throws description from javadoc", "author": "anpanigr", "createdAt": "2020-08-27T23:21:12Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -199,49 +258,451 @@ public void testDeleteOperatorButNotDomain() {\n     }\n \n     logger.info(\"Checking that the admin server pod state was not changed after the operator was deleted\");\n-    assertThat(podStateNotChanged(adminServerPodName, domainUid, domainNamespace, adminPodOriginalTimestamp))\n-        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domainNamespace)\n+    assertThat(podStateNotChanged(adminServerPodName, domain1Uid,\n+        domain1Namespace, adminPodOriginalTimestamp))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domain1Namespace)\n         .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-            adminServerPodName, domainNamespace)\n+            adminServerPodName, domain1Namespace)\n         .isTrue();\n \n     // check that the states of managed server pods in the domain were not changed\n     logger.info(\"Checking that the managed server pod state was not changed after the operator was deleted\");\n     for (int i = 1; i <= replicaCount; i++) {\n       String managedServerPodName = managedServerPrefix + i;\n-      assertThat(podStateNotChanged(managedServerPodName, domainUid, domainNamespace,\n+      assertThat(podStateNotChanged(managedServerPodName, domain1Uid, domain1Namespace,\n               managedServerPodOriginalTimestampList.get(i - 1)))\n-          .as(\"Test state of pod {0} was not changed in namespace {1}\", managedServerPodName, domainNamespace)\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain1Namespace)\n           .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-              managedServerPodName, domainNamespace)\n+              managedServerPodName, domain1Namespace)\n           .isTrue();\n     }\n \n     // verify the sample app in the domain is still accessible from all managed servers through NGINX\n     logger.info(\"Checking that the sample app can be accessed from all managed servers through NGINX \"\n         + \"after the operator was deleted\");\n     verifySampleAppAccessThroughNginx();\n+\n   }\n \n   /**\n-   * TODO: remove this after Sankar's PR is merged\n-   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   * Create operator and verify it is deployed successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Verify NGINX can access the sample app from all managed servers in the domain.\n+   * Delete operator.\n+   * Verify the states of all server pods in the domain were not changed.\n+   * Verify NGINX can access the sample app from all managed servers in the domain after the operator was deleted.\n+   * Test fails if the state of any pod in the domain was changed or NGINX can not access the sample app from\n+   * all managed servers in the absence of operator.\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Test\n+  @DisplayName(\"Create operator and domain, then delete operator and\"\n+      + \" create again operator and verify it can still manage domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateDeleteCreateOperatorButNotDomain() {\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    try {\n+      // install operator\n+\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+      // delete operator\n+      logger.info(\"Uninstalling operator\");\n+      uninstallOperator(opHelmParams);\n+\n+      //install second time\n+      opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, false, true, false,\n+          null,\"deployed\", 0, opHelmParams, false, domain1Namespace);\n+\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      //check if can still manage domain1\n+      assertTrue(scaleDomain(domain1Namespace, domain1Uid,2,1,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Create operator and verify it is deployed successfully\n+   * Create domain1 and verify the domain is started\n+   * Upgrade the operator domainNamespaces to include namespace for domain2\n+   * Verify both domains are managed by the operator by making a REST API call\n+   * Call helm upgrade to remove the first domain from operator domainNamespaces\n+   * Verify it can't be managed by operator anymore.\n+   * Test fails when an operator fails to manage the domains as expected\n+   */\n+  @Test\n+  @DisplayName(\"Create domain1, managed by operator and domain2, upgrade operator for domain2,\"\n+      + \"delete domain1 , verify management for domain2 and no access to domain1\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddRemoveDomainUpdateOperatorHC() throws Exception {\n+\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    try {\n+      // install operator\n+      String opServiceAccount = opNamespace + \"-sa\";\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+\n+      // operator chart values\n+      OperatorParams opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain1Namespace, domain2Namespace));\n+\n+      // upgrade operator\n+      assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+      //assertTrue(upgradeOperator(opParams), \"Helm Upgrade failed to add domain to operator\");\n+      if (!isDomain2Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain2Namespace, domain2Uid),\n+            \"can't start or verify domain in namespace \" + domain2Namespace);\n+        isDomain2Running = true;\n+      }\n+      assertTrue(scaleDomain(domain1Namespace, domain1Uid,2,3,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+      assertTrue(scaleDomain(domain2Namespace,domain2Uid,2,3,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain2 \" + domain2Namespace + \" scaling failed\");\n+      // operator chart values\n+      opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain2Namespace));\n+      assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+      assertTrue(scaleDomain(domain2Namespace,domain2Uid,3,2,\n+          opNamespace, opServiceAccount, externalRestHttpsPort),\"Domain \" + domain2Namespace + \" scaling failed\");\n+      //verify operator can't scale domain1 anymore\n+      assertFalse(scaleDomain(domain1Namespace,domain1Uid,3,2,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"operator still can manage domain1\");\n+    } finally {\n+      cleanUpSA(opNamespace);\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+\n+  /**\n+   * Install operator1 with namespace op2Namespace.\n+   * Install operator2 with same namesapce op2Namespace.\n+   * Second operator should fail to install with following exception\n+   * Error: rendered manifests contain a resource that already exists.\n+   * Unable to continue with install: existing resource conflict: existing resource conflict: namespace\n+   *\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to install two operators sharing the same namespace\")\n+  @Slow\n+  public void testCreateSecondOperatorUsingSameOperatorNsNegativeInstall() {\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domain1Namespace);\n+    if (!isDomain1Running) {\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+          \"can't start or verify domain in namespace \" + domain1Namespace);\n+      isDomain1Running = true;\n+    }\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    String opServiceAccount = opNamespace + \"-sa2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);;\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    try {\n+      String expectedError = \"Error: rendered manifests contain a resource that already exists.\"\n+          + \" Unable to continue with install: existing resource conflict: namespace\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(opNamespace, opServiceAccount, true, false,\n+          false,expectedError,\"failed\", 0,\n+          op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2,\n+          \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install operator1 with Domain Namespace [domain2Namespace].\n+   * Install operator2 with same Domain Namespace [domain2Namespace].\n+   * Second operator should fail to install with following exception.\n+   * Error: rendered manifests contain a resource that already exists.\n+   * Unable to continue with install: existing resource conflict: namespace.\n+   * Test fails when second operator installation does not fail.\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to install two operators sharing the same domain namespace\")\n+  @Slow\n+  public void testSecondOpSharingSameDomainNamespacesNegativeInstall() {\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domain2Namespace);\n+    if (!isDomain2Running) {\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain2Namespace, domain2Uid),\n+          \"can't start or verify domain in namespace \" + domain2Namespace);\n+      isDomain2Running = true;\n+    }\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    String opServiceAccount = op2Namespace + \"-sa2\";\n+    try {\n+      String expectedError = \"Error: rendered manifests contain a resource that already exists.\"\n+          + \" Unable to continue with install: existing resource conflict: namespace\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, opServiceAccount, true, false, false,\n+          expectedError,\"failed\", 0, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      cleanUpSA(op2Namespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Intitialize two operators op1 and op2 with same ExternalRestHttpPort.\n+   * Install operator op1.\n+   * Install operator op2.\n+   * Installation of second operator should fail.\n+   *\n+   * @throws Exception when second operator installation does not fail\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to try to create the operator with not preexisted namespace\")\n+  @Slow\n+  public void testSecondOpSharingSameExternalRestPortNegativeInstall() {\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    String op2ServiceAccount = op2Namespace + \"-sa2\";\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"1\";\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    HelmParams opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, true, true,\n+        true,null,\"deployed\", 0, op1HelmParams, false, domain1Namespace);\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    String op2ReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(op2ReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // install and verify operator2\n+    logger.info(\"Installing and verifying operator2 fails\");\n+    try {\n+      String expectedError = \"Error: Service \\\"external-weblogic-operator-svc\\\" \"\n+          + \"is invalid: spec.ports[0].nodePort: Invalid value\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, op2ServiceAccount,\n+          true, true, true,\n+          expectedError,\"failed\",\n+          externalRestHttpsPort, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      cleanUpSA(opNamespace);\n+      cleanUpSA(op2Namespace);\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      deleteSecret(\"ocir-secret\",op2Namespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install the operator with non existing operator namespace.\n+   * The helm install command should fail.\n+   *\n+   * @throws Exception when helm install does not fail", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTM1OTQ3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479359476", "bodyText": "done", "author": "marinakog", "createdAt": "2020-08-28T14:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NzY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwMTk3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479501977", "bodyText": "Still not resolved see Line# 555\n/**\n\nInstall the operator with non existing operator namespace.\nThe helm install command should fail.\n\n@throws Exception when helm install does not fail\n*/\n@test\n@DisplayName(\"Negative test to try to create the operator with not preexisted namespace\")\npublic void testNotPreCreatedOpNsCreateOperatorNegativeInstall()", "author": "anpanigr", "createdAt": "2020-08-28T19:44:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NzY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0ODIxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478748218", "bodyText": "logger.info(\"Installing and verifying operator\"); is being repeated few lines below for different set of code/action.", "author": "anpanigr", "createdAt": "2020-08-27T23:23:04Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -199,49 +258,451 @@ public void testDeleteOperatorButNotDomain() {\n     }\n \n     logger.info(\"Checking that the admin server pod state was not changed after the operator was deleted\");\n-    assertThat(podStateNotChanged(adminServerPodName, domainUid, domainNamespace, adminPodOriginalTimestamp))\n-        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domainNamespace)\n+    assertThat(podStateNotChanged(adminServerPodName, domain1Uid,\n+        domain1Namespace, adminPodOriginalTimestamp))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domain1Namespace)\n         .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-            adminServerPodName, domainNamespace)\n+            adminServerPodName, domain1Namespace)\n         .isTrue();\n \n     // check that the states of managed server pods in the domain were not changed\n     logger.info(\"Checking that the managed server pod state was not changed after the operator was deleted\");\n     for (int i = 1; i <= replicaCount; i++) {\n       String managedServerPodName = managedServerPrefix + i;\n-      assertThat(podStateNotChanged(managedServerPodName, domainUid, domainNamespace,\n+      assertThat(podStateNotChanged(managedServerPodName, domain1Uid, domain1Namespace,\n               managedServerPodOriginalTimestampList.get(i - 1)))\n-          .as(\"Test state of pod {0} was not changed in namespace {1}\", managedServerPodName, domainNamespace)\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain1Namespace)\n           .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-              managedServerPodName, domainNamespace)\n+              managedServerPodName, domain1Namespace)\n           .isTrue();\n     }\n \n     // verify the sample app in the domain is still accessible from all managed servers through NGINX\n     logger.info(\"Checking that the sample app can be accessed from all managed servers through NGINX \"\n         + \"after the operator was deleted\");\n     verifySampleAppAccessThroughNginx();\n+\n   }\n \n   /**\n-   * TODO: remove this after Sankar's PR is merged\n-   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   * Create operator and verify it is deployed successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Verify NGINX can access the sample app from all managed servers in the domain.\n+   * Delete operator.\n+   * Verify the states of all server pods in the domain were not changed.\n+   * Verify NGINX can access the sample app from all managed servers in the domain after the operator was deleted.\n+   * Test fails if the state of any pod in the domain was changed or NGINX can not access the sample app from\n+   * all managed servers in the absence of operator.\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Test\n+  @DisplayName(\"Create operator and domain, then delete operator and\"\n+      + \" create again operator and verify it can still manage domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateDeleteCreateOperatorButNotDomain() {\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    try {\n+      // install operator\n+\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+      // delete operator\n+      logger.info(\"Uninstalling operator\");\n+      uninstallOperator(opHelmParams);\n+\n+      //install second time\n+      opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, false, true, false,\n+          null,\"deployed\", 0, opHelmParams, false, domain1Namespace);\n+\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      //check if can still manage domain1\n+      assertTrue(scaleDomain(domain1Namespace, domain1Uid,2,1,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Create operator and verify it is deployed successfully\n+   * Create domain1 and verify the domain is started\n+   * Upgrade the operator domainNamespaces to include namespace for domain2\n+   * Verify both domains are managed by the operator by making a REST API call\n+   * Call helm upgrade to remove the first domain from operator domainNamespaces\n+   * Verify it can't be managed by operator anymore.\n+   * Test fails when an operator fails to manage the domains as expected\n+   */\n+  @Test\n+  @DisplayName(\"Create domain1, managed by operator and domain2, upgrade operator for domain2,\"\n+      + \"delete domain1 , verify management for domain2 and no access to domain1\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddRemoveDomainUpdateOperatorHC() throws Exception {\n+\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    try {\n+      // install operator\n+      String opServiceAccount = opNamespace + \"-sa\";\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+\n+      // operator chart values\n+      OperatorParams opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain1Namespace, domain2Namespace));\n+\n+      // upgrade operator\n+      assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+      //assertTrue(upgradeOperator(opParams), \"Helm Upgrade failed to add domain to operator\");\n+      if (!isDomain2Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain2Namespace, domain2Uid),\n+            \"can't start or verify domain in namespace \" + domain2Namespace);\n+        isDomain2Running = true;\n+      }\n+      assertTrue(scaleDomain(domain1Namespace, domain1Uid,2,3,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+      assertTrue(scaleDomain(domain2Namespace,domain2Uid,2,3,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain2 \" + domain2Namespace + \" scaling failed\");\n+      // operator chart values\n+      opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain2Namespace));\n+      assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+      assertTrue(scaleDomain(domain2Namespace,domain2Uid,3,2,\n+          opNamespace, opServiceAccount, externalRestHttpsPort),\"Domain \" + domain2Namespace + \" scaling failed\");\n+      //verify operator can't scale domain1 anymore\n+      assertFalse(scaleDomain(domain1Namespace,domain1Uid,3,2,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"operator still can manage domain1\");\n+    } finally {\n+      cleanUpSA(opNamespace);\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+\n+  /**\n+   * Install operator1 with namespace op2Namespace.\n+   * Install operator2 with same namesapce op2Namespace.\n+   * Second operator should fail to install with following exception\n+   * Error: rendered manifests contain a resource that already exists.\n+   * Unable to continue with install: existing resource conflict: existing resource conflict: namespace\n+   *\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to install two operators sharing the same namespace\")\n+  @Slow\n+  public void testCreateSecondOperatorUsingSameOperatorNsNegativeInstall() {\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domain1Namespace);\n+    if (!isDomain1Running) {\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+          \"can't start or verify domain in namespace \" + domain1Namespace);\n+      isDomain1Running = true;\n+    }\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    String opServiceAccount = opNamespace + \"-sa2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);;\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    try {\n+      String expectedError = \"Error: rendered manifests contain a resource that already exists.\"\n+          + \" Unable to continue with install: existing resource conflict: namespace\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(opNamespace, opServiceAccount, true, false,\n+          false,expectedError,\"failed\", 0,\n+          op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2,\n+          \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install operator1 with Domain Namespace [domain2Namespace].\n+   * Install operator2 with same Domain Namespace [domain2Namespace].\n+   * Second operator should fail to install with following exception.\n+   * Error: rendered manifests contain a resource that already exists.\n+   * Unable to continue with install: existing resource conflict: namespace.\n+   * Test fails when second operator installation does not fail.\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to install two operators sharing the same domain namespace\")\n+  @Slow\n+  public void testSecondOpSharingSameDomainNamespacesNegativeInstall() {\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domain2Namespace);\n+    if (!isDomain2Running) {\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain2Namespace, domain2Uid),\n+          \"can't start or verify domain in namespace \" + domain2Namespace);\n+      isDomain2Running = true;\n+    }\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    String opServiceAccount = op2Namespace + \"-sa2\";\n+    try {\n+      String expectedError = \"Error: rendered manifests contain a resource that already exists.\"\n+          + \" Unable to continue with install: existing resource conflict: namespace\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, opServiceAccount, true, false, false,\n+          expectedError,\"failed\", 0, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      cleanUpSA(op2Namespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Intitialize two operators op1 and op2 with same ExternalRestHttpPort.\n+   * Install operator op1.\n+   * Install operator op2.\n+   * Installation of second operator should fail.\n+   *\n+   * @throws Exception when second operator installation does not fail\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to try to create the operator with not preexisted namespace\")\n+  @Slow\n+  public void testSecondOpSharingSameExternalRestPortNegativeInstall() {\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    String op2ServiceAccount = op2Namespace + \"-sa2\";\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"1\";\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    HelmParams opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, true, true,\n+        true,null,\"deployed\", 0, op1HelmParams, false, domain1Namespace);\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    String op2ReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(op2ReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // install and verify operator2\n+    logger.info(\"Installing and verifying operator2 fails\");\n+    try {\n+      String expectedError = \"Error: Service \\\"external-weblogic-operator-svc\\\" \"\n+          + \"is invalid: spec.ports[0].nodePort: Invalid value\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, op2ServiceAccount,\n+          true, true, true,\n+          expectedError,\"failed\",\n+          externalRestHttpsPort, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      cleanUpSA(opNamespace);\n+      cleanUpSA(op2Namespace);\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      deleteSecret(\"ocir-secret\",op2Namespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install the operator with non existing operator namespace.\n+   * The helm install command should fail.\n+   *\n+   * @throws Exception when helm install does not fail\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to try to create the operator with not preexisted namespace\")\n+  @Slow\n+  public void testNotPreCreatedOpNsCreateOperatorNegativeInstall() {\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTM1OTM5MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479359391", "bodyText": "cleaned", "author": "marinakog", "createdAt": "2020-08-28T14:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0ODIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MDY5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478750699", "bodyText": "Missing period at the end of sentence.\nCan we extend the usecase to add a domain namespace by upgrading  the helm chart and make sure the domain is up and running. This will complete the e2e steps described in Quick Start Guide.", "author": "anpanigr", "createdAt": "2020-08-27T23:31:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -199,49 +258,451 @@ public void testDeleteOperatorButNotDomain() {\n     }\n \n     logger.info(\"Checking that the admin server pod state was not changed after the operator was deleted\");\n-    assertThat(podStateNotChanged(adminServerPodName, domainUid, domainNamespace, adminPodOriginalTimestamp))\n-        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domainNamespace)\n+    assertThat(podStateNotChanged(adminServerPodName, domain1Uid,\n+        domain1Namespace, adminPodOriginalTimestamp))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domain1Namespace)\n         .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-            adminServerPodName, domainNamespace)\n+            adminServerPodName, domain1Namespace)\n         .isTrue();\n \n     // check that the states of managed server pods in the domain were not changed\n     logger.info(\"Checking that the managed server pod state was not changed after the operator was deleted\");\n     for (int i = 1; i <= replicaCount; i++) {\n       String managedServerPodName = managedServerPrefix + i;\n-      assertThat(podStateNotChanged(managedServerPodName, domainUid, domainNamespace,\n+      assertThat(podStateNotChanged(managedServerPodName, domain1Uid, domain1Namespace,\n               managedServerPodOriginalTimestampList.get(i - 1)))\n-          .as(\"Test state of pod {0} was not changed in namespace {1}\", managedServerPodName, domainNamespace)\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain1Namespace)\n           .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-              managedServerPodName, domainNamespace)\n+              managedServerPodName, domain1Namespace)\n           .isTrue();\n     }\n \n     // verify the sample app in the domain is still accessible from all managed servers through NGINX\n     logger.info(\"Checking that the sample app can be accessed from all managed servers through NGINX \"\n         + \"after the operator was deleted\");\n     verifySampleAppAccessThroughNginx();\n+\n   }\n \n   /**\n-   * TODO: remove this after Sankar's PR is merged\n-   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   * Create operator and verify it is deployed successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Verify NGINX can access the sample app from all managed servers in the domain.\n+   * Delete operator.\n+   * Verify the states of all server pods in the domain were not changed.\n+   * Verify NGINX can access the sample app from all managed servers in the domain after the operator was deleted.\n+   * Test fails if the state of any pod in the domain was changed or NGINX can not access the sample app from\n+   * all managed servers in the absence of operator.\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Test\n+  @DisplayName(\"Create operator and domain, then delete operator and\"\n+      + \" create again operator and verify it can still manage domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateDeleteCreateOperatorButNotDomain() {\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    try {\n+      // install operator\n+\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+      // delete operator\n+      logger.info(\"Uninstalling operator\");\n+      uninstallOperator(opHelmParams);\n+\n+      //install second time\n+      opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, false, true, false,\n+          null,\"deployed\", 0, opHelmParams, false, domain1Namespace);\n+\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      //check if can still manage domain1\n+      assertTrue(scaleDomain(domain1Namespace, domain1Uid,2,1,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Create operator and verify it is deployed successfully\n+   * Create domain1 and verify the domain is started\n+   * Upgrade the operator domainNamespaces to include namespace for domain2\n+   * Verify both domains are managed by the operator by making a REST API call\n+   * Call helm upgrade to remove the first domain from operator domainNamespaces\n+   * Verify it can't be managed by operator anymore.\n+   * Test fails when an operator fails to manage the domains as expected\n+   */\n+  @Test\n+  @DisplayName(\"Create domain1, managed by operator and domain2, upgrade operator for domain2,\"\n+      + \"delete domain1 , verify management for domain2 and no access to domain1\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddRemoveDomainUpdateOperatorHC() throws Exception {\n+\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    try {\n+      // install operator\n+      String opServiceAccount = opNamespace + \"-sa\";\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+\n+      // operator chart values\n+      OperatorParams opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain1Namespace, domain2Namespace));\n+\n+      // upgrade operator\n+      assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+      //assertTrue(upgradeOperator(opParams), \"Helm Upgrade failed to add domain to operator\");\n+      if (!isDomain2Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain2Namespace, domain2Uid),\n+            \"can't start or verify domain in namespace \" + domain2Namespace);\n+        isDomain2Running = true;\n+      }\n+      assertTrue(scaleDomain(domain1Namespace, domain1Uid,2,3,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+      assertTrue(scaleDomain(domain2Namespace,domain2Uid,2,3,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain2 \" + domain2Namespace + \" scaling failed\");\n+      // operator chart values\n+      opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain2Namespace));\n+      assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+      assertTrue(scaleDomain(domain2Namespace,domain2Uid,3,2,\n+          opNamespace, opServiceAccount, externalRestHttpsPort),\"Domain \" + domain2Namespace + \" scaling failed\");\n+      //verify operator can't scale domain1 anymore\n+      assertFalse(scaleDomain(domain1Namespace,domain1Uid,3,2,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"operator still can manage domain1\");\n+    } finally {\n+      cleanUpSA(opNamespace);\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+\n+  /**\n+   * Install operator1 with namespace op2Namespace.\n+   * Install operator2 with same namesapce op2Namespace.\n+   * Second operator should fail to install with following exception\n+   * Error: rendered manifests contain a resource that already exists.\n+   * Unable to continue with install: existing resource conflict: existing resource conflict: namespace\n+   *\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to install two operators sharing the same namespace\")\n+  @Slow\n+  public void testCreateSecondOperatorUsingSameOperatorNsNegativeInstall() {\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domain1Namespace);\n+    if (!isDomain1Running) {\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+          \"can't start or verify domain in namespace \" + domain1Namespace);\n+      isDomain1Running = true;\n+    }\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    String opServiceAccount = opNamespace + \"-sa2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);;\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    try {\n+      String expectedError = \"Error: rendered manifests contain a resource that already exists.\"\n+          + \" Unable to continue with install: existing resource conflict: namespace\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(opNamespace, opServiceAccount, true, false,\n+          false,expectedError,\"failed\", 0,\n+          op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2,\n+          \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install operator1 with Domain Namespace [domain2Namespace].\n+   * Install operator2 with same Domain Namespace [domain2Namespace].\n+   * Second operator should fail to install with following exception.\n+   * Error: rendered manifests contain a resource that already exists.\n+   * Unable to continue with install: existing resource conflict: namespace.\n+   * Test fails when second operator installation does not fail.\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to install two operators sharing the same domain namespace\")\n+  @Slow\n+  public void testSecondOpSharingSameDomainNamespacesNegativeInstall() {\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domain2Namespace);\n+    if (!isDomain2Running) {\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain2Namespace, domain2Uid),\n+          \"can't start or verify domain in namespace \" + domain2Namespace);\n+      isDomain2Running = true;\n+    }\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    String opServiceAccount = op2Namespace + \"-sa2\";\n+    try {\n+      String expectedError = \"Error: rendered manifests contain a resource that already exists.\"\n+          + \" Unable to continue with install: existing resource conflict: namespace\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, opServiceAccount, true, false, false,\n+          expectedError,\"failed\", 0, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      cleanUpSA(op2Namespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Intitialize two operators op1 and op2 with same ExternalRestHttpPort.\n+   * Install operator op1.\n+   * Install operator op2.\n+   * Installation of second operator should fail.\n+   *\n+   * @throws Exception when second operator installation does not fail\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to try to create the operator with not preexisted namespace\")\n+  @Slow\n+  public void testSecondOpSharingSameExternalRestPortNegativeInstall() {\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    String op2ServiceAccount = op2Namespace + \"-sa2\";\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"1\";\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    HelmParams opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, true, true,\n+        true,null,\"deployed\", 0, op1HelmParams, false, domain1Namespace);\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    String op2ReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(op2ReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // install and verify operator2\n+    logger.info(\"Installing and verifying operator2 fails\");\n+    try {\n+      String expectedError = \"Error: Service \\\"external-weblogic-operator-svc\\\" \"\n+          + \"is invalid: spec.ports[0].nodePort: Invalid value\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, op2ServiceAccount,\n+          true, true, true,\n+          expectedError,\"failed\",\n+          externalRestHttpsPort, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      cleanUpSA(opNamespace);\n+      cleanUpSA(op2Namespace);\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      deleteSecret(\"ocir-secret\",op2Namespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install the operator with non existing operator namespace.\n+   * The helm install command should fail.\n+   *\n+   * @throws Exception when helm install does not fail\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to try to create the operator with not preexisted namespace\")\n+  @Slow\n+  public void testNotPreCreatedOpNsCreateOperatorNegativeInstall() {\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(\"ns-somens\")\n+        .chartDir(OPERATOR_CHART_DIR);;\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    String opServiceAccount = op2Namespace + \"-sa2\";\n+    try {\n+      String expectedError = \"Error: create: failed to create: namespaces \\\"ns-somens\\\" not found\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(\"ns-somens\", opServiceAccount, false, false,\n+          false, expectedError,\"failed\", 0, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install the operator with empty string as domains namespaces", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTM1OTMzMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479359333", "bodyText": "done", "author": "marinakog", "createdAt": "2020-08-28T14:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MDY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwNDQwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479504404", "bodyText": "Update the javadoc description to reflect the new usecaes i.e addition of new domain namespace and make sure that the the WebLogic domain is activated by Operator.", "author": "anpanigr", "createdAt": "2020-08-28T19:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MDY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIwMjM0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r481202340", "bodyText": "I do not see the change. The description is not complete.", "author": "anpanigr", "createdAt": "2020-09-01T14:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MDY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIzNzY3OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r481237678", "bodyText": "corrected", "author": "marinakog", "createdAt": "2020-09-01T15:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MDY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MDkxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478750910", "bodyText": "Remove extra /**", "author": "anpanigr", "createdAt": "2020-08-27T23:31:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -199,49 +258,451 @@ public void testDeleteOperatorButNotDomain() {\n     }\n \n     logger.info(\"Checking that the admin server pod state was not changed after the operator was deleted\");\n-    assertThat(podStateNotChanged(adminServerPodName, domainUid, domainNamespace, adminPodOriginalTimestamp))\n-        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domainNamespace)\n+    assertThat(podStateNotChanged(adminServerPodName, domain1Uid,\n+        domain1Namespace, adminPodOriginalTimestamp))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domain1Namespace)\n         .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-            adminServerPodName, domainNamespace)\n+            adminServerPodName, domain1Namespace)\n         .isTrue();\n \n     // check that the states of managed server pods in the domain were not changed\n     logger.info(\"Checking that the managed server pod state was not changed after the operator was deleted\");\n     for (int i = 1; i <= replicaCount; i++) {\n       String managedServerPodName = managedServerPrefix + i;\n-      assertThat(podStateNotChanged(managedServerPodName, domainUid, domainNamespace,\n+      assertThat(podStateNotChanged(managedServerPodName, domain1Uid, domain1Namespace,\n               managedServerPodOriginalTimestampList.get(i - 1)))\n-          .as(\"Test state of pod {0} was not changed in namespace {1}\", managedServerPodName, domainNamespace)\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain1Namespace)\n           .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-              managedServerPodName, domainNamespace)\n+              managedServerPodName, domain1Namespace)\n           .isTrue();\n     }\n \n     // verify the sample app in the domain is still accessible from all managed servers through NGINX\n     logger.info(\"Checking that the sample app can be accessed from all managed servers through NGINX \"\n         + \"after the operator was deleted\");\n     verifySampleAppAccessThroughNginx();\n+\n   }\n \n   /**\n-   * TODO: remove this after Sankar's PR is merged\n-   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   * Create operator and verify it is deployed successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Verify NGINX can access the sample app from all managed servers in the domain.\n+   * Delete operator.\n+   * Verify the states of all server pods in the domain were not changed.\n+   * Verify NGINX can access the sample app from all managed servers in the domain after the operator was deleted.\n+   * Test fails if the state of any pod in the domain was changed or NGINX can not access the sample app from\n+   * all managed servers in the absence of operator.\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Test\n+  @DisplayName(\"Create operator and domain, then delete operator and\"\n+      + \" create again operator and verify it can still manage domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateDeleteCreateOperatorButNotDomain() {\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    try {\n+      // install operator\n+\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+      // delete operator\n+      logger.info(\"Uninstalling operator\");\n+      uninstallOperator(opHelmParams);\n+\n+      //install second time\n+      opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, false, true, false,\n+          null,\"deployed\", 0, opHelmParams, false, domain1Namespace);\n+\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      //check if can still manage domain1\n+      assertTrue(scaleDomain(domain1Namespace, domain1Uid,2,1,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Create operator and verify it is deployed successfully\n+   * Create domain1 and verify the domain is started\n+   * Upgrade the operator domainNamespaces to include namespace for domain2\n+   * Verify both domains are managed by the operator by making a REST API call\n+   * Call helm upgrade to remove the first domain from operator domainNamespaces\n+   * Verify it can't be managed by operator anymore.\n+   * Test fails when an operator fails to manage the domains as expected\n+   */\n+  @Test\n+  @DisplayName(\"Create domain1, managed by operator and domain2, upgrade operator for domain2,\"\n+      + \"delete domain1 , verify management for domain2 and no access to domain1\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddRemoveDomainUpdateOperatorHC() throws Exception {\n+\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    try {\n+      // install operator\n+      String opServiceAccount = opNamespace + \"-sa\";\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+\n+      // operator chart values\n+      OperatorParams opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain1Namespace, domain2Namespace));\n+\n+      // upgrade operator\n+      assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+      //assertTrue(upgradeOperator(opParams), \"Helm Upgrade failed to add domain to operator\");\n+      if (!isDomain2Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain2Namespace, domain2Uid),\n+            \"can't start or verify domain in namespace \" + domain2Namespace);\n+        isDomain2Running = true;\n+      }\n+      assertTrue(scaleDomain(domain1Namespace, domain1Uid,2,3,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+      assertTrue(scaleDomain(domain2Namespace,domain2Uid,2,3,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain2 \" + domain2Namespace + \" scaling failed\");\n+      // operator chart values\n+      opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain2Namespace));\n+      assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+      assertTrue(scaleDomain(domain2Namespace,domain2Uid,3,2,\n+          opNamespace, opServiceAccount, externalRestHttpsPort),\"Domain \" + domain2Namespace + \" scaling failed\");\n+      //verify operator can't scale domain1 anymore\n+      assertFalse(scaleDomain(domain1Namespace,domain1Uid,3,2,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"operator still can manage domain1\");\n+    } finally {\n+      cleanUpSA(opNamespace);\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+\n+  /**\n+   * Install operator1 with namespace op2Namespace.\n+   * Install operator2 with same namesapce op2Namespace.\n+   * Second operator should fail to install with following exception\n+   * Error: rendered manifests contain a resource that already exists.\n+   * Unable to continue with install: existing resource conflict: existing resource conflict: namespace\n+   *\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to install two operators sharing the same namespace\")\n+  @Slow\n+  public void testCreateSecondOperatorUsingSameOperatorNsNegativeInstall() {\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domain1Namespace);\n+    if (!isDomain1Running) {\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+          \"can't start or verify domain in namespace \" + domain1Namespace);\n+      isDomain1Running = true;\n+    }\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    String opServiceAccount = opNamespace + \"-sa2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);;\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    try {\n+      String expectedError = \"Error: rendered manifests contain a resource that already exists.\"\n+          + \" Unable to continue with install: existing resource conflict: namespace\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(opNamespace, opServiceAccount, true, false,\n+          false,expectedError,\"failed\", 0,\n+          op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2,\n+          \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install operator1 with Domain Namespace [domain2Namespace].\n+   * Install operator2 with same Domain Namespace [domain2Namespace].\n+   * Second operator should fail to install with following exception.\n+   * Error: rendered manifests contain a resource that already exists.\n+   * Unable to continue with install: existing resource conflict: namespace.\n+   * Test fails when second operator installation does not fail.\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to install two operators sharing the same domain namespace\")\n+  @Slow\n+  public void testSecondOpSharingSameDomainNamespacesNegativeInstall() {\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domain2Namespace);\n+    if (!isDomain2Running) {\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain2Namespace, domain2Uid),\n+          \"can't start or verify domain in namespace \" + domain2Namespace);\n+      isDomain2Running = true;\n+    }\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    String opServiceAccount = op2Namespace + \"-sa2\";\n+    try {\n+      String expectedError = \"Error: rendered manifests contain a resource that already exists.\"\n+          + \" Unable to continue with install: existing resource conflict: namespace\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, opServiceAccount, true, false, false,\n+          expectedError,\"failed\", 0, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      cleanUpSA(op2Namespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Intitialize two operators op1 and op2 with same ExternalRestHttpPort.\n+   * Install operator op1.\n+   * Install operator op2.\n+   * Installation of second operator should fail.\n+   *\n+   * @throws Exception when second operator installation does not fail\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to try to create the operator with not preexisted namespace\")\n+  @Slow\n+  public void testSecondOpSharingSameExternalRestPortNegativeInstall() {\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    String op2ServiceAccount = op2Namespace + \"-sa2\";\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"1\";\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    HelmParams opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, true, true,\n+        true,null,\"deployed\", 0, op1HelmParams, false, domain1Namespace);\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    String op2ReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(op2ReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // install and verify operator2\n+    logger.info(\"Installing and verifying operator2 fails\");\n+    try {\n+      String expectedError = \"Error: Service \\\"external-weblogic-operator-svc\\\" \"\n+          + \"is invalid: spec.ports[0].nodePort: Invalid value\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, op2ServiceAccount,\n+          true, true, true,\n+          expectedError,\"failed\",\n+          externalRestHttpsPort, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      cleanUpSA(opNamespace);\n+      cleanUpSA(op2Namespace);\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      deleteSecret(\"ocir-secret\",op2Namespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install the operator with non existing operator namespace.\n+   * The helm install command should fail.\n+   *\n+   * @throws Exception when helm install does not fail\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to try to create the operator with not preexisted namespace\")\n+  @Slow\n+  public void testNotPreCreatedOpNsCreateOperatorNegativeInstall() {\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(\"ns-somens\")\n+        .chartDir(OPERATOR_CHART_DIR);;\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    String opServiceAccount = op2Namespace + \"-sa2\";\n+    try {\n+      String expectedError = \"Error: create: failed to create: namespaces \\\"ns-somens\\\" not found\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(\"ns-somens\", opServiceAccount, false, false,\n+          false, expectedError,\"failed\", 0, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install the operator with empty string as domains namespaces\n+   * This is equivalent of QuickStart guide does when it installs the operator\n+   * with ' --set \"domainNamespaces={}\" '.\n+   *\n+   */\n+  @Test\n+  @DisplayName(\"Test to create the operator with empty string for domains namespace\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateWithEmptyDomainNamespaceInstall() {\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    String opServiceAccount = op2Namespace + \"-sa2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);;\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    try {\n+\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, opServiceAccount, true, false,\n+          true,null,\"deployed\", 0, op2HelmParams, false, \"\");\n+      assertNotNull(opHelmParam2, \"FAILURE: Helm can't installs operator with empty set for target domainnamespaces \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",op2Namespace);\n+      cleanUpSA(op2Namespace);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTM1OTI1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479359254", "bodyText": "done", "author": "marinakog", "createdAt": "2020-08-28T14:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MDkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MTA1MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478751051", "bodyText": "Remove commented code", "author": "anpanigr", "createdAt": "2020-08-27T23:32:31Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -199,49 +258,451 @@ public void testDeleteOperatorButNotDomain() {\n     }\n \n     logger.info(\"Checking that the admin server pod state was not changed after the operator was deleted\");\n-    assertThat(podStateNotChanged(adminServerPodName, domainUid, domainNamespace, adminPodOriginalTimestamp))\n-        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domainNamespace)\n+    assertThat(podStateNotChanged(adminServerPodName, domain1Uid,\n+        domain1Namespace, adminPodOriginalTimestamp))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domain1Namespace)\n         .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-            adminServerPodName, domainNamespace)\n+            adminServerPodName, domain1Namespace)\n         .isTrue();\n \n     // check that the states of managed server pods in the domain were not changed\n     logger.info(\"Checking that the managed server pod state was not changed after the operator was deleted\");\n     for (int i = 1; i <= replicaCount; i++) {\n       String managedServerPodName = managedServerPrefix + i;\n-      assertThat(podStateNotChanged(managedServerPodName, domainUid, domainNamespace,\n+      assertThat(podStateNotChanged(managedServerPodName, domain1Uid, domain1Namespace,\n               managedServerPodOriginalTimestampList.get(i - 1)))\n-          .as(\"Test state of pod {0} was not changed in namespace {1}\", managedServerPodName, domainNamespace)\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain1Namespace)\n           .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-              managedServerPodName, domainNamespace)\n+              managedServerPodName, domain1Namespace)\n           .isTrue();\n     }\n \n     // verify the sample app in the domain is still accessible from all managed servers through NGINX\n     logger.info(\"Checking that the sample app can be accessed from all managed servers through NGINX \"\n         + \"after the operator was deleted\");\n     verifySampleAppAccessThroughNginx();\n+\n   }\n \n   /**\n-   * TODO: remove this after Sankar's PR is merged\n-   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   * Create operator and verify it is deployed successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Verify NGINX can access the sample app from all managed servers in the domain.\n+   * Delete operator.\n+   * Verify the states of all server pods in the domain were not changed.\n+   * Verify NGINX can access the sample app from all managed servers in the domain after the operator was deleted.\n+   * Test fails if the state of any pod in the domain was changed or NGINX can not access the sample app from\n+   * all managed servers in the absence of operator.\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Test\n+  @DisplayName(\"Create operator and domain, then delete operator and\"\n+      + \" create again operator and verify it can still manage domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateDeleteCreateOperatorButNotDomain() {\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    try {\n+      // install operator\n+\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+      // delete operator\n+      logger.info(\"Uninstalling operator\");\n+      uninstallOperator(opHelmParams);\n+\n+      //install second time\n+      opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, false, true, false,\n+          null,\"deployed\", 0, opHelmParams, false, domain1Namespace);\n+\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      //check if can still manage domain1\n+      assertTrue(scaleDomain(domain1Namespace, domain1Uid,2,1,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Create operator and verify it is deployed successfully\n+   * Create domain1 and verify the domain is started\n+   * Upgrade the operator domainNamespaces to include namespace for domain2\n+   * Verify both domains are managed by the operator by making a REST API call\n+   * Call helm upgrade to remove the first domain from operator domainNamespaces\n+   * Verify it can't be managed by operator anymore.\n+   * Test fails when an operator fails to manage the domains as expected\n+   */\n+  @Test\n+  @DisplayName(\"Create domain1, managed by operator and domain2, upgrade operator for domain2,\"\n+      + \"delete domain1 , verify management for domain2 and no access to domain1\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddRemoveDomainUpdateOperatorHC() throws Exception {\n+\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    try {\n+      // install operator\n+      String opServiceAccount = opNamespace + \"-sa\";\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+            \"can't start or verify domain in namespace \" + domain1Namespace);\n+        isDomain1Running = true;\n+      }\n+\n+      // operator chart values\n+      OperatorParams opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain1Namespace, domain2Namespace));\n+\n+      // upgrade operator\n+      assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+      //assertTrue(upgradeOperator(opParams), \"Helm Upgrade failed to add domain to operator\");\n+      if (!isDomain2Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain2Namespace, domain2Uid),\n+            \"can't start or verify domain in namespace \" + domain2Namespace);\n+        isDomain2Running = true;\n+      }\n+      assertTrue(scaleDomain(domain1Namespace, domain1Uid,2,3,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+      assertTrue(scaleDomain(domain2Namespace,domain2Uid,2,3,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"Domain2 \" + domain2Namespace + \" scaling failed\");\n+      // operator chart values\n+      opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain2Namespace));\n+      assertTrue(upgradeAndVerifyOperator(opNamespace, opParams));\n+\n+      assertTrue(scaleDomain(domain2Namespace,domain2Uid,3,2,\n+          opNamespace, opServiceAccount, externalRestHttpsPort),\"Domain \" + domain2Namespace + \" scaling failed\");\n+      //verify operator can't scale domain1 anymore\n+      assertFalse(scaleDomain(domain1Namespace,domain1Uid,3,2,\n+          opNamespace, opServiceAccount, externalRestHttpsPort), \"operator still can manage domain1\");\n+    } finally {\n+      cleanUpSA(opNamespace);\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+\n+  /**\n+   * Install operator1 with namespace op2Namespace.\n+   * Install operator2 with same namesapce op2Namespace.\n+   * Second operator should fail to install with following exception\n+   * Error: rendered manifests contain a resource that already exists.\n+   * Unable to continue with install: existing resource conflict: existing resource conflict: namespace\n+   *\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to install two operators sharing the same namespace\")\n+  @Slow\n+  public void testCreateSecondOperatorUsingSameOperatorNsNegativeInstall() {\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domain1Namespace);\n+    if (!isDomain1Running) {\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+          \"can't start or verify domain in namespace \" + domain1Namespace);\n+      isDomain1Running = true;\n+    }\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    String opServiceAccount = opNamespace + \"-sa2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);;\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    try {\n+      String expectedError = \"Error: rendered manifests contain a resource that already exists.\"\n+          + \" Unable to continue with install: existing resource conflict: namespace\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(opNamespace, opServiceAccount, true, false,\n+          false,expectedError,\"failed\", 0,\n+          op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2,\n+          \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install operator1 with Domain Namespace [domain2Namespace].\n+   * Install operator2 with same Domain Namespace [domain2Namespace].\n+   * Second operator should fail to install with following exception.\n+   * Error: rendered manifests contain a resource that already exists.\n+   * Unable to continue with install: existing resource conflict: namespace.\n+   * Test fails when second operator installation does not fail.\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to install two operators sharing the same domain namespace\")\n+  @Slow\n+  public void testSecondOpSharingSameDomainNamespacesNegativeInstall() {\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domain2Namespace);\n+    if (!isDomain2Running) {\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain2Namespace, domain2Uid),\n+          \"can't start or verify domain in namespace \" + domain2Namespace);\n+      isDomain2Running = true;\n+    }\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    String opServiceAccount = op2Namespace + \"-sa2\";\n+    try {\n+      String expectedError = \"Error: rendered manifests contain a resource that already exists.\"\n+          + \" Unable to continue with install: existing resource conflict: namespace\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, opServiceAccount, true, false, false,\n+          expectedError,\"failed\", 0, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      cleanUpSA(op2Namespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Intitialize two operators op1 and op2 with same ExternalRestHttpPort.\n+   * Install operator op1.\n+   * Install operator op2.\n+   * Installation of second operator should fail.\n+   *\n+   * @throws Exception when second operator installation does not fail\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to try to create the operator with not preexisted namespace\")\n+  @Slow\n+  public void testSecondOpSharingSameExternalRestPortNegativeInstall() {\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    String op2ServiceAccount = op2Namespace + \"-sa2\";\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"1\";\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    HelmParams opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, true, true,\n+        true,null,\"deployed\", 0, op1HelmParams, false, domain1Namespace);\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    String op2ReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(op2ReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // install and verify operator2\n+    logger.info(\"Installing and verifying operator2 fails\");\n+    try {\n+      String expectedError = \"Error: Service \\\"external-weblogic-operator-svc\\\" \"\n+          + \"is invalid: spec.ports[0].nodePort: Invalid value\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, op2ServiceAccount,\n+          true, true, true,\n+          expectedError,\"failed\",\n+          externalRestHttpsPort, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      cleanUpSA(opNamespace);\n+      cleanUpSA(op2Namespace);\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      deleteSecret(\"ocir-secret\",op2Namespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install the operator with non existing operator namespace.\n+   * The helm install command should fail.\n+   *\n+   * @throws Exception when helm install does not fail\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to try to create the operator with not preexisted namespace\")\n+  @Slow\n+  public void testNotPreCreatedOpNsCreateOperatorNegativeInstall() {\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(\"ns-somens\")\n+        .chartDir(OPERATOR_CHART_DIR);;\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    String opServiceAccount = op2Namespace + \"-sa2\";\n+    try {\n+      String expectedError = \"Error: create: failed to create: namespaces \\\"ns-somens\\\" not found\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(\"ns-somens\", opServiceAccount, false, false,\n+          false, expectedError,\"failed\", 0, op2HelmParams, false, domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install the operator with empty string as domains namespaces\n+   * This is equivalent of QuickStart guide does when it installs the operator\n+   * with ' --set \"domainNamespaces={}\" '.\n+   *\n+   */\n+  @Test\n+  @DisplayName(\"Test to create the operator with empty string for domains namespace\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateWithEmptyDomainNamespaceInstall() {\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    String opServiceAccount = op2Namespace + \"-sa2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);;\n+\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    try {\n+\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, opServiceAccount, true, false,\n+          true,null,\"deployed\", 0, op2HelmParams, false, \"\");\n+      assertNotNull(opHelmParam2, \"FAILURE: Helm can't installs operator with empty set for target domainnamespaces \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",op2Namespace);\n+      cleanUpSA(op2Namespace);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   /**\n+   * Install the operator with non existing operator service account.\n+   * Operator installation should fail.\n+   * Create the service account.\n+   * Make sure operator pod is in ready state.\n+   *\n+   */\n+  @Test\n+  @DisplayName(\"Install operator with non existing operator service account and verify helm chart is failed, \"\n+      + \"create service account and verify the operator is running\")\n+  @Slow\n+  public void testNotPreexistedOpServiceAccountCreateOperatorNegativeInstall() {\n+    String opServiceAccount = op2Namespace + \"-sa\";\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"1\";\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator %s in namespace %s\", opReleaseName, op2Namespace);\n+    String errorMsg = null;\n+    HelmParams opHelmParams =\n+        new HelmParams().releaseName(opReleaseName)\n+            .namespace(op2Namespace)\n+            .chartDir(OPERATOR_CHART_DIR);\n+    try {\n+      try {\n+        HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, opServiceAccount, false, false,\n+            true,null,\"failed\", 0, opHelmParams, false, domain2Namespace);\n+        assertNull(opHelmParam2, \"FAILURE: Helm installs operator with not preexisted service account \");\n+      } catch (AssertionError ex) {\n+        logger.info(\" Receieved assertion error \" + ex.getMessage());\n+        errorMsg = ex.getMessage() + \" when operator service account not created\";\n+      }\n+      // Create a service account for the unique op2Namespace\n+      logger.info(\"Creating service account\");\n+      assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+          .metadata(new V1ObjectMeta()\n+              .namespace(op2Namespace)\n+              .name(opServiceAccount))));\n+      logger.info(\"Created service account: {0}\", opServiceAccount);\n+      // list Helm releases matching operator release name in operator namespace\n+      logger.info(\"Checking operator release {0} status in namespace {1}\",\n+          opReleaseName, op2Namespace);\n+      assertTrue(isHelmReleaseDeployed(opReleaseName, op2Namespace),\n+          String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+              opReleaseName, op2Namespace));\n+      logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+          opReleaseName, op2Namespace);\n+\n+      // wait for the operator to be ready\n+      logger.info(\"Wait for the operator pod is ready in namespace {0}\", op2Namespace);\n+      withStandardRetryPolicy\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                      + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                  op2Namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> operatorIsReady(op2Namespace),\n+              \"operatorIsReady failed with ApiException\"));\n+      //comment it out due OWLS-84294, helm does not report failed status\n+      //assertNull(errorMsg, errorMsg);", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTM1OTEwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479359106", "bodyText": "I left it commented due bug OWLS-84294, as soon as it fixed I will put back line 673", "author": "marinakog", "createdAt": "2020-08-28T14:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MTA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MTY4MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478751680", "bodyText": "Check if we have a common utility to scale a domain.", "author": "anpanigr", "createdAt": "2020-08-27T23:34:42Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -363,4 +823,267 @@ private void verifySampleAppAccessThroughNginx() {\n         .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n         .isTrue();\n   }\n+\n+  /**\n+   * Install WebLogic operator and wait up to five minutes until the operator pod is ready.\n+   * Method is to test positive and negative testcases for operator helm install\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed\n+   * @param opServiceAccount the service account name for operator\n+   * @param createOpSA option to create the service account for operator\n+   * @param withRestAPI whether to use REST API\n+   * @param createSecret option to create secret\n+   * @param errMsg   expected helm chart error message for negative scenario, null for positive testcases\n+   * @param helmStatus expected helm status\n+   * @param externalRestHttpsPort the node port allocated for the external operator REST HTTPS interface\n+   * @param opHelmParams the Helm parameters to install operator\n+   * @param elkIntegrationEnabled true to enable ELK Stack, false otherwise\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  private static HelmParams installOperatorHelmChart(String operNamespace,\n+                                                    String opServiceAccount,\n+                                                    boolean createOpSA,\n+                                                    boolean withRestAPI,\n+                                                    boolean createSecret,\n+                                                    String errMsg,\n+                                                    String helmStatus,\n+                                                    int externalRestHttpsPort,\n+                                                    HelmParams opHelmParams,\n+                                                    boolean elkIntegrationEnabled,\n+                                                    String... domainNamespace) {\n+    LoggingFacade logger = getLogger();\n+    String opReleaseName = opHelmParams.getReleaseName();\n+\n+    if (createOpSA) {\n+      // Create a service account for the unique operNamespace\n+      logger.info(\"Creating service account\");\n+      assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+          .metadata(new V1ObjectMeta()\n+              .namespace(operNamespace)\n+              .name(opServiceAccount))));\n+      logger.info(\"Created service account: {0}\", opServiceAccount);\n+    }\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+    if (createSecret) {\n+      boolean secretExists = false;\n+      V1SecretList listSecrets = listSecrets(operNamespace);\n+      if (null != listSecrets) {\n+        for (V1Secret item : listSecrets.getItems()) {\n+          if (item.getMetadata().getName().equals(REPO_SECRET_NAME)) {\n+            secretExists = true;\n+            break;\n+          }\n+        }\n+      }\n+      if (!secretExists) {\n+\n+        // Create Docker registry secret in the operator namespace to pull the image from repository\n+        logger.info(\"Creating Docker registry secret in namespace {0}\", operNamespace);\n+        createDockerRegistrySecret(operNamespace);\n+      }\n+    }\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(java.util.Arrays.asList(domainNamespace))\n+        .serviceAccount(opServiceAccount);\n+\n+    // use default image in chart when repoUrl is set, otherwise use latest/current branch operator image\n+    if (opHelmParams.getRepoUrl() == null) {\n+      opParams.image(operatorImage);\n+    }\n+\n+    // enable ELK Stack\n+    if (elkIntegrationEnabled) {\n+      opParams\n+          .elkIntegrationEnabled(elkIntegrationEnabled);\n+      opParams\n+          .elasticSearchHost(ELASTICSEARCH_HOST);\n+      opParams\n+          .elasticSearchPort(ELASTICSEARCH_HTTP_PORT);\n+      opParams\n+          .javaLoggingLevel(JAVA_LOGGING_LEVEL_VALUE);\n+      opParams\n+          .logStashImage(LOGSTASH_IMAGE);\n+    }\n+\n+    if (withRestAPI) {\n+      // create externalRestIdentitySecret\n+      assertTrue(createExternalRestIdentitySecret(operNamespace,\n+          DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME + operNamespace),\n+          \"failed to create external REST identity secret\");\n+      opParams\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME + operNamespace);\n+    }\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", operNamespace);\n+    if (errMsg != null) {\n+      String helmErrorMsg = installNegative(opHelmParams, opParams.getValues());\n+      assertNotNull(helmErrorMsg, \"helm chart install successful, but expected to fail\");\n+      assertTrue(helmErrorMsg.contains(errMsg),\n+          String.format(\"Operator install failed with unexpected error  :%s\", helmErrorMsg));\n+      return null;\n+    } else {\n+      assertTrue(installOperator(opParams),\n+          String.format(\"Failed to install operator in namespace %s \", operNamespace));\n+      logger.info(\"Operator installed in namespace {0}\", operNamespace);\n+    }\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        opReleaseName, operNamespace);\n+    assertTrue(checkHelmReleaseStatus(opReleaseName, operNamespace, helmStatus),\n+        String.format(\"Operator release %s is not in %s status in namespace %s\",\n+            opReleaseName, helmStatus, operNamespace));\n+    logger.info(\"Operator release {0} status is {1} in namespace {2}\",\n+        opReleaseName, helmStatus, operNamespace);\n+    if (helmStatus.equalsIgnoreCase(\"deployed\")) {\n+      // wait for the operator to be ready\n+      logger.info(\"Wait for the operator pod is ready in namespace {0}\", operNamespace);\n+      withStandardRetryPolicy\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                      + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                  operNamespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> operatorIsReady(operNamespace),\n+              \"operatorIsReady failed with ApiException\"));\n+\n+      if (withRestAPI) {\n+        logger.info(\"Wait for the operator external service in namespace {0}\", operNamespace);\n+        withStandardRetryPolicy\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for operator external service in namespace {0} \"\n+                        + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                    operNamespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(assertDoesNotThrow(() -> operatorRestServiceRunning(operNamespace),\n+                \"operator external service is not running\"));\n+      }\n+      return opHelmParams;\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Installs a Helm chart and expected to fail.\n+   * @param helmParams the parameters to Helm install command like namespace, release name,\n+   *                   repo url or chart dir, chart name\n+   * @param chartValues the values to override in a chart\n+   * @return error Message on success, null otherwise\n+   */\n+  public static String installNegative(HelmParams helmParams, Map<String, Object> chartValues) {\n+    String namespace = helmParams.getNamespace();\n+\n+    //chart reference to be used in Helm install\n+    String chartRef = helmParams.getChartDir();\n+\n+    getLogger().fine(\"Installing a chart in namespace {0} using chart reference {1}\", namespace, chartRef);\n+\n+    // build Helm install command\n+    String installCmd = String.format(\"helm install %1s %2s --namespace %3s \",\n+        helmParams.getReleaseName(), chartRef, helmParams.getNamespace());\n+\n+    // if we have chart values file\n+    String chartValuesFile = helmParams.getChartValuesFile();\n+    if (chartValuesFile != null) {\n+      installCmd = installCmd + \" --values \" + chartValuesFile;\n+    }\n+\n+    // if we have chart version\n+    String chartVersion = helmParams.getChartVersion();\n+    if (chartVersion != null) {\n+      installCmd = installCmd + \" --version \" + chartVersion;\n+    }\n+\n+    // add override chart values\n+    installCmd = installCmd + helmValuesToString(chartValues);\n+\n+    if (helmParams.getChartVersion() != null) {\n+      installCmd = installCmd + \" --version \" + helmParams.getChartVersion();\n+    }\n+\n+    // run the command\n+    return getExecError(installCmd);\n+\n+  }\n+\n+  /**\n+   * Executes the given command and return error message if command failed.\n+   * @param command the command to execute\n+   * @return Error message string for failed command or null if no failure\n+   */\n+  private static String getExecError(String command) {\n+    getLogger().info(\"Running command - \\n\" + command);\n+    ExecResult result = null;\n+    try {\n+      result = ExecCommand.exec(command, true);\n+      getLogger().info(\"The command returned exit value: \"\n+          + result.exitValue() + \" command output: \"\n+          + result.stderr() + \"\\n\" + result.stdout());\n+      if (result.exitValue() != 0) {\n+        getLogger().info(\"Command failed with errors \" + result.stderr() + \"\\n\" + result.stdout());\n+        return result.stderr();\n+      }\n+    } catch (Exception e) {\n+      getLogger().info(\"Got exception, command failed with errors \" + e.getMessage());\n+      return result.stderr();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Scale domain .\n+   */\n+  private boolean scaleDomain(String domainNS, String domainUid,", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTM1ODY5Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479358692", "bodyText": "I needed utility to be boolean, it is just a wrap around existed", "author": "marinakog", "createdAt": "2020-08-28T14:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MTY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4OTQ2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479489464", "bodyText": "This is a very commonly used action utility, you may consider creating a new override method with different signature/return type in common utility area, which can be used by other classed if needed.", "author": "anpanigr", "createdAt": "2020-08-28T19:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MTY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxNzM2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r480317369", "bodyText": "done", "author": "marinakog", "createdAt": "2020-08-31T18:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MTY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MjI1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478752256", "bodyText": "Since we are not using Elk stack here, make the local utility method simple when possible.", "author": "anpanigr", "createdAt": "2020-08-27T23:36:47Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -363,4 +823,267 @@ private void verifySampleAppAccessThroughNginx() {\n         .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n         .isTrue();\n   }\n+\n+  /**\n+   * Install WebLogic operator and wait up to five minutes until the operator pod is ready.\n+   * Method is to test positive and negative testcases for operator helm install\n+   *\n+   * @param operNamespace the operator namespace in which the operator will be installed\n+   * @param opServiceAccount the service account name for operator\n+   * @param createOpSA option to create the service account for operator\n+   * @param withRestAPI whether to use REST API\n+   * @param createSecret option to create secret\n+   * @param errMsg   expected helm chart error message for negative scenario, null for positive testcases\n+   * @param helmStatus expected helm status\n+   * @param externalRestHttpsPort the node port allocated for the external operator REST HTTPS interface\n+   * @param opHelmParams the Helm parameters to install operator\n+   * @param elkIntegrationEnabled true to enable ELK Stack, false otherwise\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  private static HelmParams installOperatorHelmChart(String operNamespace,\n+                                                    String opServiceAccount,\n+                                                    boolean createOpSA,\n+                                                    boolean withRestAPI,\n+                                                    boolean createSecret,\n+                                                    String errMsg,\n+                                                    String helmStatus,\n+                                                    int externalRestHttpsPort,\n+                                                    HelmParams opHelmParams,\n+                                                    boolean elkIntegrationEnabled,\n+                                                    String... domainNamespace) {\n+    LoggingFacade logger = getLogger();\n+    String opReleaseName = opHelmParams.getReleaseName();\n+\n+    if (createOpSA) {\n+      // Create a service account for the unique operNamespace\n+      logger.info(\"Creating service account\");\n+      assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+          .metadata(new V1ObjectMeta()\n+              .namespace(operNamespace)\n+              .name(opServiceAccount))));\n+      logger.info(\"Created service account: {0}\", opServiceAccount);\n+    }\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+    if (createSecret) {\n+      boolean secretExists = false;\n+      V1SecretList listSecrets = listSecrets(operNamespace);\n+      if (null != listSecrets) {\n+        for (V1Secret item : listSecrets.getItems()) {\n+          if (item.getMetadata().getName().equals(REPO_SECRET_NAME)) {\n+            secretExists = true;\n+            break;\n+          }\n+        }\n+      }\n+      if (!secretExists) {\n+\n+        // Create Docker registry secret in the operator namespace to pull the image from repository\n+        logger.info(\"Creating Docker registry secret in namespace {0}\", operNamespace);\n+        createDockerRegistrySecret(operNamespace);\n+      }\n+    }\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(java.util.Arrays.asList(domainNamespace))\n+        .serviceAccount(opServiceAccount);\n+\n+    // use default image in chart when repoUrl is set, otherwise use latest/current branch operator image\n+    if (opHelmParams.getRepoUrl() == null) {\n+      opParams.image(operatorImage);\n+    }\n+\n+    // enable ELK Stack", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTM1ODU3OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479358578", "bodyText": "done", "author": "marinakog", "createdAt": "2020-08-28T14:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1MjI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1NDE2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478754167", "bodyText": "Do we need to install NGIX and verify application routing in these use cases. We can simply use REST scaling to see if the operator can manage the domain.", "author": "anpanigr", "createdAt": "2020-08-27T23:43:48Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -109,12 +155,22 @@ public static void initAll(@Namespaces(3) List<String> namespaces) {\n     // get a unique domain namespace\n     logger.info(\"Getting a unique namespace for WebLogic domain\");\n     assertNotNull(namespaces.get(1), \"Namespace list is null\");\n-    domainNamespace = namespaces.get(1);\n+    domain1Namespace = namespaces.get(1);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain 2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n \n     // get a unique NGINX namespace", "originalCommit": "f494e7be0afaa47dc80e5409712098226e89e995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4NTEwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r478785100", "bodyText": "in this case we do, we want to verify domain still running after operator was uninstalled", "author": "marinakog", "createdAt": "2020-08-28T01:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1NDE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4MTMwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479481302", "bodyText": "To check if the domain is running in the absence of Operator, can we check the server Runtime MBean by making a REST API call to Admin Server.  I have an example of Server ConfigMBean check in  ItMiiUpdateDomainConfig.java.  I want to avoid another layer of 3rdparty LoadBalancer which sometime introduce  intermittent issue in curl command.  We have coverage for NGINX in other tests.", "author": "anpanigr", "createdAt": "2020-08-28T18:55:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1NDE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxNzMwOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r480317309", "bodyText": "done", "author": "marinakog", "createdAt": "2020-08-31T18:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1NDE2Nw=="}], "type": "inlineReview"}, {"oid": "2a4652547d5c55035965be17522b4f5aa733ac6b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2a4652547d5c55035965be17522b4f5aa733ac6b", "message": "addressed review comments", "committedDate": "2020-08-28T00:47:26Z", "type": "commit"}, {"oid": "60c0fed92f1f0e6f515121af4ed6ff693126827f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/60c0fed92f1f0e6f515121af4ed6ff693126827f", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into usabtest", "committedDate": "2020-08-28T00:47:32Z", "type": "commit"}, {"oid": "e6c5e3d25db934ade0ebbd9839444a8af7625340", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e6c5e3d25db934ade0ebbd9839444a8af7625340", "message": "addressed more comments", "committedDate": "2020-08-28T04:23:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4NjgyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r479486827", "bodyText": "Create Operator -->  Install the Operator successfully.\nCreate a custom domain resource and verify all server pods in the domain were created and ready ---> Deploy a custom domain resource and verify all the servers pod are ready.  Deploy a sample web application to WebLogic Cluster.\nsample app --> sample application\nUninstall -->  Uninstall the Operator Helm Chart.", "author": "anpanigr", "createdAt": "2020-08-28T19:08:34Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -126,60 +178,59 @@ public static void initAll(@Namespaces(3) List<String> namespaces) {\n     logger.info(\"NGINX http node port: {0}\", nodeportshttp);\n   }\n \n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n   /**\n    * Create operator and verify it is deployed successfully.\n    * Create a custom domain resource and verify all server pods in the domain were created and ready.\n    * Verify NGINX can access the sample app from all managed servers in the domain.\n-   * Delete operator.\n+   * Uninstall operator.", "originalCommit": "e6c5e3d25db934ade0ebbd9839444a8af7625340", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxNzIyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r480317227", "bodyText": "done", "author": "marinakog", "createdAt": "2020-08-31T18:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4NjgyNw=="}], "type": "inlineReview"}, {"oid": "9d59b2f832e1b3cd5d8699174bc1ffb8ccee9eea", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9d59b2f832e1b3cd5d8699174bc1ffb8ccee9eea", "message": "addressed comments from Pani", "committedDate": "2020-08-31T18:32:20Z", "type": "commit"}, {"oid": "743fe396dca567c9d70c05d19c359068771df332", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/743fe396dca567c9d70c05d19c359068771df332", "message": "addressed comments from Pani1", "committedDate": "2020-08-31T18:39:15Z", "type": "commit"}, {"oid": "3d293eabf8aa7f224e8aadd29366e376c2ec5e56", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3d293eabf8aa7f224e8aadd29366e376c2ec5e56", "message": "styling", "committedDate": "2020-08-31T22:17:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIwNzExNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r481207114", "bodyText": "Remove @throws annotation.", "author": "anpanigr", "createdAt": "2020-09-01T15:01:37Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -199,49 +246,507 @@ public void testDeleteOperatorButNotDomain() {\n     }\n \n     logger.info(\"Checking that the admin server pod state was not changed after the operator was deleted\");\n-    assertThat(podStateNotChanged(adminServerPodName, domainUid, domainNamespace, adminPodOriginalTimestamp))\n-        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domainNamespace)\n+    assertThat(podStateNotChanged(adminServerPodName, domain1Uid,\n+        domain1Namespace, adminPodOriginalTimestamp))\n+        .as(\"Test state of pod {0} was not changed in namespace {1}\", adminServerPodName, domain1Namespace)\n         .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-            adminServerPodName, domainNamespace)\n+            adminServerPodName, domain1Namespace)\n         .isTrue();\n \n     // check that the states of managed server pods in the domain were not changed\n     logger.info(\"Checking that the managed server pod state was not changed after the operator was deleted\");\n-    for (int i = 1; i <= replicaCount; i++) {\n+    for (int i = 1; i <= replicaCountDomain1; i++) {\n       String managedServerPodName = managedServerPrefix + i;\n-      assertThat(podStateNotChanged(managedServerPodName, domainUid, domainNamespace,\n+      assertThat(podStateNotChanged(managedServerPodName, domain1Uid, domain1Namespace,\n               managedServerPodOriginalTimestampList.get(i - 1)))\n-          .as(\"Test state of pod {0} was not changed in namespace {1}\", managedServerPodName, domainNamespace)\n+          .as(\"Test state of pod {0} was not changed in namespace {1}\",\n+              managedServerPodName, domain1Namespace)\n           .withFailMessage(\"State of pod {0} was changed in namespace {1}\",\n-              managedServerPodName, domainNamespace)\n+              managedServerPodName, domain1Namespace)\n           .isTrue();\n     }\n \n-    // verify the sample app in the domain is still accessible from all managed servers through NGINX\n-    logger.info(\"Checking that the sample app can be accessed from all managed servers through NGINX \"\n+    // verify the managed server Mbean is still accessible via rest api\n+    logger.info(\"Verify the managed server1 MBean configuration through rest API \"\n         + \"after the operator was deleted\");\n-    verifySampleAppAccessThroughNginx();\n+    assertTrue(checkManagedServerConfiguration(domain1Namespace, domain1Uid));\n+\n   }\n \n   /**\n-   * TODO: remove this after Sankar's PR is merged\n-   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   * Install the Operator helm chart successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Uninstall operator helm chart.\n+   * Verify the states of all server pods in the domain were not changed.\n+   * Verify rest api access to managed server configuration in the domain after the operator was deleted.\n+   * Install operator helm chart again reusing same helm values and scale domain to verify it can manage it\n    */\n-  @AfterAll\n-  public void tearDownAll() {\n-    // uninstall NGINX release\n-    if (nginxHelmParams != null) {\n-      assertThat(uninstallNginx(nginxHelmParams))\n-          .as(\"Test uninstallNginx returns true\")\n-          .withFailMessage(\"uninstallNginx() did not return true\")\n-          .isTrue();\n+  @Test\n+  @DisplayName(\"Install operator helm chart and domain, then uninstall operator helm chart, \"\n+      + \" install operator helm chart again and verify it can still manage domain\")\n+  public void testCreateDeleteCreateOperatorButNotDomain() {\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    try {\n+      // install operator\n+\n+      HelmParams opHelmParams = installAndVerifyOperator(opNamespace, opServiceAccount, true,\n+          0, op1HelmParams, domain1Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+\n+      if (!isDomain1Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain3Namespace, domain3Uid),\n+            \"can't start or verify domain in namespace \" + domain3Namespace);\n+        isDomain1Running = true;\n+      }\n+      // delete operator\n+      logger.info(\"Uninstalling operator\");\n+      uninstallOperator(opHelmParams);\n+\n+      //install second time\n+      opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, false, true, false,\n+          null,\"deployed\", 0, opHelmParams, domain1Namespace);\n+\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+      assertTrue(externalRestHttpsPort != -1,\n+          \"Could not get the Operator external service node port\");\n+      logger.info(\"externalRestHttpsPort {0}\", externalRestHttpsPort);\n+      //check if can still manage domain1\n+      assertTrue(scaleClusterWithRestApi(domain1Uid, clusterName,replicaCountDomain1 - 1,\n+          externalRestHttpsPort,opNamespace, opServiceAccount),\n+          \"Domain1 \" + domain1Namespace + \" scaling failed\");\n+      String managedServerPodName1 = domain1Uid + managedServerPrefix + replicaCountDomain1;\n+      logger.info(\"Checking that the managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName1, domain1Namespace);\n+      assertDoesNotThrow(() -> checkPodDoesNotExist(managedServerPodName1, domain1Uid, domain1Namespace),\n+          \"operator failed to manage domain1, scaling was not succeeded\");\n+      --replicaCountDomain1;\n+      logger.info(\"Domain1 scaled to \" + replicaCountDomain1 + \" servers\");\n+\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install the Operator successfully.\n+   * Create domain1 and verify the domain is started\n+   * Upgrade the operator helm chart domainNamespaces to include namespace for domain2\n+   * Verify both domains are managed by the operator by making a REST API call\n+   * Call helm upgrade to remove the first domain from operator domainNamespaces\n+   * Verify it can't be managed by operator anymore.\n+   * Test fails when an operator fails to manage the domains as expected\n+   */\n+  @Test\n+  @DisplayName(\"Create domain1, managed by operator and domain2, upgrade operator to add domain2,\"\n+      + \"delete domain1 , verify operator management for domain2 and no access to domain1\")\n+  public void testAddRemoveDomainNameSpacesOnOperator() {\n+\n+    String opReleaseName = OPERATOR_RELEASE_NAME;\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    try {\n+      // install operator\n+      String opServiceAccount = op2Namespace + \"-sa\";\n+      HelmParams opHelmParams = installAndVerifyOperator(op2Namespace, opServiceAccount, true,\n+          0, op1HelmParams, domain2Namespace);\n+      assertNotNull(opHelmParams, \"Can't install operator\");\n+      int externalRestHttpsPort = getServiceNodePort(op2Namespace, \"external-weblogic-operator-svc\");\n+      assertTrue(externalRestHttpsPort != -1,\n+          \"Could not get the Operator external service node port\");\n+      logger.info(\"externalRestHttpsPort {0}\", externalRestHttpsPort);\n+      if (!isDomain2Running) {\n+        logger.info(\"Installing and verifying domain\");\n+        assertTrue(createVerifyDomain(domain2Namespace, domain2Uid),\n+            \"can't start or verify domain in namespace \" + domain2Namespace);\n+        isDomain2Running = true;\n+      }\n+\n+      // operator chart values\n+      OperatorParams opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain3Namespace, domain2Namespace));\n+\n+      // upgrade operator\n+      assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain3Namespace, domain3Uid),\n+          \"can't start or verify domain in namespace \" + domain3Namespace);\n+\n+      assertTrue(scaleClusterWithRestApi(domain3Uid, clusterName,3,\n+          externalRestHttpsPort,op2Namespace, opServiceAccount),\n+          \"Domain3 \" + domain3Namespace + \" scaling operation failed\");\n+      String managedServerPodName1 = domain3Uid + managedServerPrefix + 3;\n+      logger.info(\"Checking that the managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName1, domain3Namespace);\n+      assertDoesNotThrow(() ->\n+              checkPodExists(managedServerPodName1, domain3Uid, domain3Namespace),\n+          \"operator failed to manage domain1, scaling was not succeeded\");\n+\n+      logger.info(\"Domain3 scaled to 3 servers\");\n+      assertTrue(scaleClusterWithRestApi(domain2Uid, clusterName,replicaCountDomain2 + 1,\n+          externalRestHttpsPort,op2Namespace, opServiceAccount),\n+          \"Domain2 \" + domain2Namespace + \" scaling operation failed\");\n+      String managedServerPodName2 = domain2Uid + managedServerPrefix + (replicaCountDomain2 + 1);\n+      logger.info(\"Checking that the managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName2, domain2Namespace);\n+      assertDoesNotThrow(() -> checkPodExists(managedServerPodName2, domain2Uid, domain2Namespace),\n+          \"operator failed to manage domain2, scaling was not succeeded\");\n+      ++replicaCountDomain2;\n+      logger.info(\"Domain2 scaled to \" + replicaCountDomain2 + \" servers\");\n+      // operator chart values for upgrade\n+      opParams = new OperatorParams()\n+          .helmParams(opHelmParams)\n+          .externalRestEnabled(true)\n+          .externalRestHttpsPort(externalRestHttpsPort)\n+          .serviceAccount(opServiceAccount)\n+          .externalRestIdentitySecret(DEFAULT_EXTERNAL_REST_IDENTITY_SECRET_NAME)\n+          .domainNamespaces(java.util.Arrays.asList(domain2Namespace));\n+      assertTrue(upgradeAndVerifyOperator(op2Namespace, opParams));\n+\n+      assertTrue(scaleClusterWithRestApi(domain2Uid, clusterName,replicaCountDomain2 - 1,\n+          externalRestHttpsPort,op2Namespace, opServiceAccount),\n+          \"Domain2 \" + domain2Namespace + \" scaling execution failed\");\n+      // check new managed server pod exists in the namespace\n+      logger.info(\"Checking that the managed server pod {0} does not exist in namespace {1}\",\n+          managedServerPodName2, domain2Namespace);\n+      assertDoesNotThrow(() -> checkPodDoesNotExist(managedServerPodName2, domain2Uid, domain2Namespace),\n+          \"operator failed to managed domain2, scaling was not succeeded, pod \"\n+              + managedServerPodName2 +  \" still exists\");\n+      --replicaCountDomain2;\n+      logger.info(\"Domain2 scaled to \" + replicaCountDomain2 + \" servers\");\n+\n+      //verify operator can't scale domain1 anymore\n+      assertTrue(scaleClusterWithRestApi(domain3Uid, clusterName,2,\n+          externalRestHttpsPort,op2Namespace, opServiceAccount),\n+          \"Domain1 \" + domain3Namespace + \" scaling execution failed \");\n+      // check new managed server pod exists in the namespace\n+      logger.info(\"Checking that the managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName1, domain3Namespace);\n+      assertDoesNotThrow(() -> checkPodExists(managedServerPodName1, domain3Uid, domain3Namespace),\n+          \"operator can still manage domain1, scaling was succeeded for \" + managedServerPodName1);\n+\n+    } finally {\n+      cleanUpSA(op2Namespace);\n+      deleteSecret(\"ocir-secret\",op2Namespace);\n+      uninstallOperator(op1HelmParams);\n+    }\n+  }\n+\n+\n+  /**\n+   * Install operator1 with namespace op2Namespace.\n+   * Install operator2 with same namesapce op2Namespace.\n+   * Second operator should fail to install with following exception\n+   * Error: rendered manifests contain a resource that already exists.\n+   * Unable to continue with install: existing resource conflict: existing resource conflict: namespace\n+   *\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to install two operators sharing the same namespace\")\n+  public void testCreateSecondOperatorUsingSameOperatorNsNegativeInstall() {\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domain1Namespace);\n+    if (!isDomain1Running) {\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain1Namespace, domain1Uid),\n+          \"can't start or verify domain in namespace \" + domain1Namespace);\n+      isDomain1Running = true;\n+    }\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    String opServiceAccount = opNamespace + \"-sa2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);;\n+\n+    // install and verify operator will fail with expected error message\n+    logger.info(\"Installing and verifying operator will fail with expected error message\");\n+    try {\n+      String expectedError = \"Error: rendered manifests contain a resource that already exists.\"\n+          + \" Unable to continue with install: existing resource conflict: namespace\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(opNamespace, opServiceAccount, true, false,\n+          false,expectedError,\"failed\", 0,\n+          op2HelmParams, domain2Namespace);\n+      assertNull(opHelmParam2,\n+          \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install operator1 with Domain Namespace [domain2Namespace].\n+   * Install operator2 with same Domain Namespace [domain2Namespace].\n+   * Second operator should fail to install with following exception.\n+   * Error: rendered manifests contain a resource that already exists.\n+   * Unable to continue with install: existing resource conflict: namespace.\n+   * Test fails when second operator installation does not fail.\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to install two operators sharing the same domain namespace\")\n+  public void testSecondOpSharingSameDomainNamespacesNegativeInstall() {\n+    // install and verify operator1\n+    logger.info(\"Installing and verifying operator1\");\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domain2Namespace);\n+    if (!isDomain2Running) {\n+      logger.info(\"Installing and verifying domain\");\n+      assertTrue(createVerifyDomain(domain2Namespace, domain2Uid),\n+          \"can't start or verify domain in namespace \" + domain2Namespace);\n+      isDomain2Running = true;\n+    }\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // install and verify operator2 will fail\n+    logger.info(\"Installing and verifying operator2 will fail with expected error message\");\n+    String opServiceAccount = op2Namespace + \"-sa2\";\n+    try {\n+      String expectedError = \"Error: rendered manifests contain a resource that already exists.\"\n+          + \" Unable to continue with install: existing resource conflict: namespace\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, opServiceAccount, true, false, false,\n+          expectedError,\"failed\", 0, op2HelmParams,  domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      cleanUpSA(opNamespace);\n+      cleanUpSA(op2Namespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Intitialize two operators op1 and op2 with same ExternalRestHttpPort.\n+   * Install operator op1.\n+   * Install operator op2.\n+   * Installation of second operator should fail.\n+   */\n+  @Test\n+  @DisplayName(\"Negative test to try to create the operator with not preexisted namespace\")\n+  public void testSecondOpSharingSameExternalRestPortNegativeInstall() {\n+    String opServiceAccount = opNamespace + \"-sa\";\n+    String op2ServiceAccount = op2Namespace + \"-sa2\";\n+    String opReleaseName = OPERATOR_RELEASE_NAME + \"1\";\n+    HelmParams op1HelmParams = new HelmParams().releaseName(opReleaseName)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+    HelmParams opHelmParams = installOperatorHelmChart(opNamespace, opServiceAccount, true, true,\n+        true,null,\"deployed\", 0, op1HelmParams,  domain1Namespace);\n+    int externalRestHttpsPort = getServiceNodePort(opNamespace, \"external-weblogic-operator-svc\");\n+    assertTrue(externalRestHttpsPort != -1,\n+        \"Could not get the Operator external service node port\");\n+    logger.info(\"externalRestHttpsPort {0}\", externalRestHttpsPort);\n+    String op2ReleaseName = OPERATOR_RELEASE_NAME + \"2\";\n+    HelmParams op2HelmParams = new HelmParams().releaseName(op2ReleaseName)\n+        .namespace(op2Namespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // install and verify operator2 will fail\n+    logger.info(\"Installing and verifying operator2 fails\");\n+    try {\n+      String expectedError = \"Error: Service \\\"external-weblogic-operator-svc\\\" \"\n+          + \"is invalid: spec.ports[0].nodePort: Invalid value\";\n+      HelmParams opHelmParam2 = installOperatorHelmChart(op2Namespace, op2ServiceAccount,\n+          true, true, true,\n+          expectedError,\"failed\",\n+          externalRestHttpsPort, op2HelmParams,  domain2Namespace);\n+      assertNull(opHelmParam2, \"FAILURE: Helm installs operator in the same namespace as first operator installed \");\n+    } finally {\n+      cleanUpSA(opNamespace);\n+      cleanUpSA(op2Namespace);\n+      deleteSecret(\"ocir-secret\",opNamespace);\n+      deleteSecret(\"ocir-secret\",op2Namespace);\n+      uninstallOperator(opHelmParams);\n+      uninstallOperator(op2HelmParams);\n+    }\n+  }\n+\n+  /**\n+   * Install the operator with non existing operator namespace.\n+   * The helm install command should fail.\n+   *\n+   * @throws Exception when helm install does not fail", "originalCommit": "3d293eabf8aa7f224e8aadd29366e376c2ec5e56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIzNzU0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1888#discussion_r481237546", "bodyText": "removed", "author": "marinakog", "createdAt": "2020-09-01T15:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIwNzExNA=="}], "type": "inlineReview"}, {"oid": "759ad7f1fdb75855f4f1c6cf536929aeb3c28fca", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/759ad7f1fdb75855f4f1c6cf536929aeb3c28fca", "message": "corrected java doc", "committedDate": "2020-09-01T15:13:56Z", "type": "commit"}, {"oid": "271777107c157842f8697d10cd5029c991af9eba", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/271777107c157842f8697d10cd5029c991af9eba", "message": "corrected java doc with typo", "committedDate": "2020-09-01T15:18:47Z", "type": "commit"}]}