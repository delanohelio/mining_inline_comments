{"pr_number": 1678, "pr_title": "Add test - Domain in persistent volume using WDT tool", "pr_createdAt": "2020-05-26T16:31:07Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678", "timeline": [{"oid": "deb397d22d757a2ceb8099337e9135dcf67fdfba", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/deb397d22d757a2ceb8099337e9135dcf67fdfba", "message": "Adding Domain in PV using WDT test", "committedDate": "2020-05-26T16:09:17Z", "type": "commit"}, {"oid": "71d50aa25e2451c11fa15f098ce3aac245da6453", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/71d50aa25e2451c11fa15f098ce3aac245da6453", "message": "Adding test for domain in pv using wdt tool.\nRenamed file ItDomainOnPV to ItDomainInPV", "committedDate": "2020-05-26T16:13:49Z", "type": "commit"}, {"oid": "75852765e53df948fb2ab71337238a6cec640422", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/75852765e53df948fb2ab71337238a6cec640422", "message": "Move the checkServiceExists after checkPodReady", "committedDate": "2020-05-26T19:13:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3NDk1MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431174950", "bodyText": "use the constants in TestConstants.java", "author": "vanajamukkara", "createdAt": "2020-05-27T14:27:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,797 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+  private final String adminUser = \"weblogic\";", "originalCommit": "75852765e53df948fb2ab71337238a6cec640422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MTk2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431451968", "bodyText": "Modified to use from TestConstants.java", "author": "sankarpn", "createdAt": "2020-05-27T21:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3NDk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3NjAxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431176010", "bodyText": "Should take the value from env var, if its not provided default to 1.8.1", "author": "vanajamukkara", "createdAt": "2020-05-27T14:28:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,797 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+\n+  private static final String WDT_VERSION = \"1.8.1\";", "originalCommit": "75852765e53df948fb2ab71337238a6cec640422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxNDc5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431214798", "bodyText": "see WDT_VERSION in ActionConstants.java", "author": "vanajamukkara", "createdAt": "2020-05-27T15:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3NjAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MjA3Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431452072", "bodyText": "Modified to use from ActionConstants.java", "author": "sankarpn", "createdAt": "2020-05-27T21:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3NjAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE5MDgwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431190800", "bodyText": "this can be done once for all test classes rather than in the test class, can be moved to ImageBuilders.java", "author": "vanajamukkara", "createdAt": "2020-05-27T14:41:44Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,797 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+\n+  private static final String WDT_VERSION = \"1.8.1\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //pull images using docker pull if its a Kind cluster\n+    if (KIND_REPO != null) {", "originalCommit": "75852765e53df948fb2ab71337238a6cec640422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzNDExNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431434115", "bodyText": "Moved the image pull to ImageBuilders.java", "author": "sankarpn", "createdAt": "2020-05-27T20:50:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE5MDgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE5NTY1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431195654", "bodyText": "I don't think there is any test method having throws clause so far..any reason for doing it here?", "author": "vanajamukkara", "createdAt": "2020-05-27T14:48:10Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,797 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPull;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerTag;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+  private final String adminUser = \"weblogic\";\n+  private final String adminPassword = \"welcome1\";\n+\n+  private static final String WDT_VERSION = \"1.8.1\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //pull images using docker pull if its a Kind cluster\n+    if (KIND_REPO != null) {\n+      // We can't figure out why the kind clusters can't pull images from OCR using the image pull secret. There\n+      // is some evidence it may be a containerd bug. Therefore, we are going to \"give up\" and workaround the issue.\n+      // The workaround will be to:\n+      //   1. docker login\n+      //   2. docker pull\n+      //   3. docker tag with the KIND_REPO value\n+      //   4. docker push this new image name\n+      //   5. use this image name to create the domain resource\n+      assertTrue(dockerLogin(OCR_REGISTRY, OCR_USERNAME, OCR_PASSWORD), \"docker login failed\");\n+      assertTrue(dockerPull(image), String.format(\"docker pull failed for image %s\", image));\n+\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      assertTrue(dockerTag(image, kindRepoImage),\n+          String.format(\"docker tag failed for images %s, %s\", image, kindRepoImage));\n+      assertTrue(dockerPush(kindRepoImage), String.format(\"docker push failed for image %s\", kindRepoImage));\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {", "originalCommit": "75852765e53df948fb2ab71337238a6cec640422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MjIzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431452236", "bodyText": "asserting at source", "author": "sankarpn", "createdAt": "2020-05-27T21:26:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE5NTY1NA=="}], "type": "inlineReview"}, {"oid": "438e140e6268232d6a6ac9de7d1cb3ae2dfb7c2d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/438e140e6268232d6a6ac9de7d1cb3ae2dfb7c2d", "message": "Merge branch 'develop' into testdomaininpvusingwdt", "committedDate": "2020-05-27T17:25:09Z", "type": "commit"}, {"oid": "4782fe19280dbceb40e420fc9bed030a854475d2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4782fe19280dbceb40e420fc9bed030a854475d2", "message": "Addressing Vanaja's review comments", "committedDate": "2020-05-27T18:42:00Z", "type": "commit"}, {"oid": "2ccb46fa654d0ea49a2df65207a3261a727b32d4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2ccb46fa654d0ea49a2df65207a3261a727b32d4", "message": "Fix checkstyle violations", "committedDate": "2020-05-27T18:48:58Z", "type": "commit"}, {"oid": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3e55c61fa651f187506e5adf76b25dc7d48e8f69", "message": "Change the WDT default version to 1.8.1", "committedDate": "2020-05-27T19:07:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM3ODcyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431378723", "bodyText": "It can be a static import as follows  ...\nimport static oracle.weblogic.kubernetes.utils.CommonTestUtils. createDomainAndVerify\napplicable to all occurrence(s)", "author": "anpanigr", "createdAt": "2020-05-27T19:09:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wlstDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WDT in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WDT\")\n+  public void testDomainOnPvUsingWdt() throws IOException, ApiException {\n+\n+    final String domainUid = \"wdtdomain-inpv\";\n+    final String clusterName = \"cluster-wdtdomain-inpv\";\n+    final String adminServerName = \"wdt-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wdt-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(31000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wdtDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wdtDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wdtDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file as a input for WDT model file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"ADMIN_USERNAME_DEFAULTname\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"ADMIN_PASSWORD_DEFAULT\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"domainName\", domainUid);\n+    p.setProperty(\"adminServerName\", adminServerName);\n+    p.setProperty(\"productionModeEnabled\", \"true\");\n+    p.setProperty(\"clusterName\", clusterName);\n+    p.setProperty(\"configuredManagedServerCount\", \"4\");\n+    p.setProperty(\"managedServerNameBase\", managedServerNameBase);\n+    p.setProperty(\"t3ChannelPort\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"t3PublicAddress\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"managedServerPort\", \"8001\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"WDT properties file\");\n+\n+    // shell script to download WDT and run the WDT createDomain script\n+    Path wdtScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", \"wdt-create-domain-onpv.sh\");\n+    // WDT model file containing WebLogic domain configuration\n+    Path wdtModelFile = Paths.get(RESOURCE_DIR, \"wdt-models\", \"domain-onpv-wdt-model.yaml\");\n+\n+    // create configmap and domain on persistent volume using WDT\n+    createDomainOnPVUsingWdt(wdtScript, wdtModelFile, domainPropertiesFile.toPath(),\n+        domainUid, pvName, pvcName, wdtDomainNamespace);\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(wdtDomainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wdtDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wdtDomainNamespace);", "originalCommit": "2ccb46fa654d0ea49a2df65207a3261a727b32d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0OTE5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431449197", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM3ODcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4MzQ0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431383447", "bodyText": "may be method name should be modified to createDomainJob()", "author": "anpanigr", "createdAt": "2020-05-27T19:15:04Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wlstDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WDT in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WDT\")\n+  public void testDomainOnPvUsingWdt() throws IOException, ApiException {\n+\n+    final String domainUid = \"wdtdomain-inpv\";\n+    final String clusterName = \"cluster-wdtdomain-inpv\";\n+    final String adminServerName = \"wdt-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wdt-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(31000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wdtDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wdtDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wdtDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file as a input for WDT model file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"ADMIN_USERNAME_DEFAULTname\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"ADMIN_PASSWORD_DEFAULT\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"domainName\", domainUid);\n+    p.setProperty(\"adminServerName\", adminServerName);\n+    p.setProperty(\"productionModeEnabled\", \"true\");\n+    p.setProperty(\"clusterName\", clusterName);\n+    p.setProperty(\"configuredManagedServerCount\", \"4\");\n+    p.setProperty(\"managedServerNameBase\", managedServerNameBase);\n+    p.setProperty(\"t3ChannelPort\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"t3PublicAddress\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"managedServerPort\", \"8001\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"WDT properties file\");\n+\n+    // shell script to download WDT and run the WDT createDomain script\n+    Path wdtScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", \"wdt-create-domain-onpv.sh\");\n+    // WDT model file containing WebLogic domain configuration\n+    Path wdtModelFile = Paths.get(RESOURCE_DIR, \"wdt-models\", \"domain-onpv-wdt-model.yaml\");\n+\n+    // create configmap and domain on persistent volume using WDT\n+    createDomainOnPVUsingWdt(wdtScript, wdtModelFile, domainPropertiesFile.toPath(),\n+        domainUid, pvName, pvcName, wdtDomainNamespace);\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(wdtDomainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wdtDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wdtDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wdtDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wdtDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wdtDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wdtDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wdtDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wdtDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wdtDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain on a persistent volume by doing the following.\n+   * Create a configmap containing WLST script and property file.\n+   * Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param wlstScriptFile python script to create domain\n+   * @param domainPropertiesFile properties file containing domain configuration\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  private void createDomainOnPVUsingWlst(Path wlstScriptFile, Path domainPropertiesFile,\n+      String pvName, String pvcName, String namespace) throws ApiException {\n+    logger.info(\"Preparing to run create domain job using WLST\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(wlstScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, namespace),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + wlstScriptFile.getFileName()) //wlst.sh script\n+        .addArgsItem(\"-skipWLSModuleScanning\")\n+        .addArgsItem(\"-loadProperties\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainPropertiesFile.getFileName()); //domain property file\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+\n+  }\n+\n+  /**\n+   * Create a WebLogic domain on a persistent volume by doing the following.\n+   * Create a configmap containing WDT model file, property file and shell script to download and run WDT.\n+   * Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param domainCreationScriptFile path of the shell script to download and run WDT\n+   * @param modelFile path of the WDT model file\n+   * @param domainPropertiesFile property file holding properties referenced in WDT model file\n+   * @param domainUid unique id of the WebLogic domain\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  private void createDomainOnPVUsingWdt(Path domainCreationScriptFile, Path modelFile,\n+      Path domainPropertiesFile, String domainUid, String pvName, String pvcName, String namespace)\n+      throws ApiException {\n+    logger.info(\"Preparing to run create domain job using WDT\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(domainCreationScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+    domainScriptFiles.add(modelFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, namespace),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainCreationScriptFile.getFileName()) //shell script to run WDT\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_VERSION\")\n+            .value(WDT_VERSION)) // WDT version to use\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_MODEL_FILE\")\n+            .value(\"/u01/weblogic/\" + modelFile.getFileName())) // WDT model file\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_VAR_FILE\")\n+            .value(\"/u01/weblogic/\" + domainPropertiesFile.getFileName())) // WDT model property file\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"DOMAIN_HOME_DIR\")\n+            .value(\"/shared/domains/\" + domainUid)); // domain location\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+\n+  }\n+\n+  /**\n+   * Create configmap containing domain creation scripts.\n+   *\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @param namespace name of the namespace in which to create configmap\n+   * @throws IOException when reading the domain script files fail\n+   * @throws ApiException if create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files, String namespace)\n+      throws ApiException, IOException {\n+    logger.info(\"Creating configmap {0}\", configMapName);\n+\n+    Path domainScriptsDir = Files.createDirectories(\n+          Paths.get(TestConstants.LOGS_DIR, this.getClass().getSimpleName(), namespace));\n+\n+    // add domain creation scripts and properties files to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      logger.info(\"Adding file {0} in configmap\", file);\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+      logger.info(\"Making a copy of file {0} to {1} for diagnostic purposes\", file,\n+          domainScriptsDir.resolve(file.getFileName()));\n+      Files.copy(file, domainScriptsDir.resolve(file.getFileName()));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(namespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create a job to create a domain in persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param domainScriptCM configmap holding domain creation script files\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @param jobContainer V1Container with job commands to create domain\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  private void runCreateDomainJob(String pvName,", "originalCommit": "2ccb46fa654d0ea49a2df65207a3261a727b32d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0OTcxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431449713", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4MzQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4NjE2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431386164", "bodyText": "Can we catch the IOException here and do an assert instead of throwing IOException", "author": "anpanigr", "createdAt": "2020-05-27T19:18:04Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wlstDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WDT in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WDT\")\n+  public void testDomainOnPvUsingWdt() throws IOException, ApiException {\n+\n+    final String domainUid = \"wdtdomain-inpv\";\n+    final String clusterName = \"cluster-wdtdomain-inpv\";\n+    final String adminServerName = \"wdt-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wdt-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(31000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wdtDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wdtDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wdtDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file as a input for WDT model file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"ADMIN_USERNAME_DEFAULTname\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"ADMIN_PASSWORD_DEFAULT\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"domainName\", domainUid);\n+    p.setProperty(\"adminServerName\", adminServerName);\n+    p.setProperty(\"productionModeEnabled\", \"true\");\n+    p.setProperty(\"clusterName\", clusterName);\n+    p.setProperty(\"configuredManagedServerCount\", \"4\");\n+    p.setProperty(\"managedServerNameBase\", managedServerNameBase);\n+    p.setProperty(\"t3ChannelPort\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"t3PublicAddress\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"managedServerPort\", \"8001\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"WDT properties file\");\n+\n+    // shell script to download WDT and run the WDT createDomain script\n+    Path wdtScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", \"wdt-create-domain-onpv.sh\");\n+    // WDT model file containing WebLogic domain configuration\n+    Path wdtModelFile = Paths.get(RESOURCE_DIR, \"wdt-models\", \"domain-onpv-wdt-model.yaml\");\n+\n+    // create configmap and domain on persistent volume using WDT\n+    createDomainOnPVUsingWdt(wdtScript, wdtModelFile, domainPropertiesFile.toPath(),\n+        domainUid, pvName, pvcName, wdtDomainNamespace);\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(wdtDomainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wdtDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wdtDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wdtDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wdtDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wdtDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wdtDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wdtDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wdtDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wdtDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain on a persistent volume by doing the following.\n+   * Create a configmap containing WLST script and property file.\n+   * Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param wlstScriptFile python script to create domain\n+   * @param domainPropertiesFile properties file containing domain configuration\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  private void createDomainOnPVUsingWlst(Path wlstScriptFile, Path domainPropertiesFile,\n+      String pvName, String pvcName, String namespace) throws ApiException {\n+    logger.info(\"Preparing to run create domain job using WLST\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(wlstScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, namespace),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + wlstScriptFile.getFileName()) //wlst.sh script\n+        .addArgsItem(\"-skipWLSModuleScanning\")\n+        .addArgsItem(\"-loadProperties\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainPropertiesFile.getFileName()); //domain property file\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+\n+  }\n+\n+  /**\n+   * Create a WebLogic domain on a persistent volume by doing the following.\n+   * Create a configmap containing WDT model file, property file and shell script to download and run WDT.\n+   * Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param domainCreationScriptFile path of the shell script to download and run WDT\n+   * @param modelFile path of the WDT model file\n+   * @param domainPropertiesFile property file holding properties referenced in WDT model file\n+   * @param domainUid unique id of the WebLogic domain\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  private void createDomainOnPVUsingWdt(Path domainCreationScriptFile, Path modelFile,\n+      Path domainPropertiesFile, String domainUid, String pvName, String pvcName, String namespace)\n+      throws ApiException {\n+    logger.info(\"Preparing to run create domain job using WDT\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(domainCreationScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+    domainScriptFiles.add(modelFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, namespace),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainCreationScriptFile.getFileName()) //shell script to run WDT\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_VERSION\")\n+            .value(WDT_VERSION)) // WDT version to use\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_MODEL_FILE\")\n+            .value(\"/u01/weblogic/\" + modelFile.getFileName())) // WDT model file\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_VAR_FILE\")\n+            .value(\"/u01/weblogic/\" + domainPropertiesFile.getFileName())) // WDT model property file\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"DOMAIN_HOME_DIR\")\n+            .value(\"/shared/domains/\" + domainUid)); // domain location\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+\n+  }\n+\n+  /**\n+   * Create configmap containing domain creation scripts.\n+   *\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @param namespace name of the namespace in which to create configmap\n+   * @throws IOException when reading the domain script files fail\n+   * @throws ApiException if create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files, String namespace)\n+      throws ApiException, IOException {\n+    logger.info(\"Creating configmap {0}\", configMapName);\n+\n+    Path domainScriptsDir = Files.createDirectories(\n+          Paths.get(TestConstants.LOGS_DIR, this.getClass().getSimpleName(), namespace));\n+\n+    // add domain creation scripts and properties files to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      logger.info(\"Adding file {0} in configmap\", file);\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+      logger.info(\"Making a copy of file {0} to {1} for diagnostic purposes\", file,\n+          domainScriptsDir.resolve(file.getFileName()));\n+      Files.copy(file, domainScriptsDir.resolve(file.getFileName()));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(namespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create a job to create a domain in persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param domainScriptCM configmap holding domain creation script files\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @param jobContainer V1Container with job commands to create domain\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  private void runCreateDomainJob(String pvName,\n+      String pvcName, String domainScriptCM, String namespace, V1Container jobContainer) throws ApiException {\n+    logger.info(\"Running Kubernetes job to create domain\");\n+\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job-\" + pvName) // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\") // change the ownership of the pv to opc:opc\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(jobContainer  // container containing WLST or WDT details\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .imagePullPolicy(\"Always\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))))) // mounted under /shared inside pod\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM)))) //config map containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+    String jobName = assertDoesNotThrow(()\n+        -> createNamespacedJob(jobBody), \"Failed to create Job\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+\n+    // check job status and fail test if the job failed to create domain\n+    V1Job job = getJob(jobName, namespace);\n+    if (job != null) {\n+      V1JobCondition jobCondition = job.getStatus().getConditions().stream().filter(\n+          v1JobCondition -> \"Failed\".equalsIgnoreCase(v1JobCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+      if (jobCondition != null) {\n+        logger.severe(\"Job {0} failed to create domain\", jobName);\n+        List<V1Pod> pods = listPods(namespace, \"job-name=\" + jobName).getItems();\n+        if (!pods.isEmpty()) {\n+          logger.severe(getPodLog(pods.get(0).getMetadata().getName(), namespace));\n+          fail(\"Domain create job failed\");\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create\n+   * @param domainUid domain UID\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPV(String pvName, String domainUid) throws IOException {\n+    logger.info(\"creating persistent volume\");\n+\n+    Path pvHostPath = Files.createDirectories(Paths.get(\n+        PV_ROOT, this.getClass().getSimpleName(), pvName));\n+    logger.info(\"Creating PV directory host path {0}\", pvHostPath);\n+    FileUtils.deleteDirectory(pvHostPath.toFile());", "originalCommit": "2ccb46fa654d0ea49a2df65207a3261a727b32d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MDU5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431450594", "bodyText": "Put the code in try block and failing when exception is caught", "author": "sankarpn", "createdAt": "2020-05-27T21:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4NjE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4NzY4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431387688", "bodyText": "Is there a common utility method for to create secret for docker credentials. This is a very generic method across all test class.", "author": "anpanigr", "createdAt": "2020-05-27T19:19:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wlstDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WDT in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WDT\")\n+  public void testDomainOnPvUsingWdt() throws IOException, ApiException {\n+\n+    final String domainUid = \"wdtdomain-inpv\";\n+    final String clusterName = \"cluster-wdtdomain-inpv\";\n+    final String adminServerName = \"wdt-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wdt-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(31000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wdtDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wdtDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wdtDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file as a input for WDT model file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"ADMIN_USERNAME_DEFAULTname\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"ADMIN_PASSWORD_DEFAULT\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"domainName\", domainUid);\n+    p.setProperty(\"adminServerName\", adminServerName);\n+    p.setProperty(\"productionModeEnabled\", \"true\");\n+    p.setProperty(\"clusterName\", clusterName);\n+    p.setProperty(\"configuredManagedServerCount\", \"4\");\n+    p.setProperty(\"managedServerNameBase\", managedServerNameBase);\n+    p.setProperty(\"t3ChannelPort\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"t3PublicAddress\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"managedServerPort\", \"8001\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"WDT properties file\");\n+\n+    // shell script to download WDT and run the WDT createDomain script\n+    Path wdtScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", \"wdt-create-domain-onpv.sh\");\n+    // WDT model file containing WebLogic domain configuration\n+    Path wdtModelFile = Paths.get(RESOURCE_DIR, \"wdt-models\", \"domain-onpv-wdt-model.yaml\");\n+\n+    // create configmap and domain on persistent volume using WDT\n+    createDomainOnPVUsingWdt(wdtScript, wdtModelFile, domainPropertiesFile.toPath(),\n+        domainUid, pvName, pvcName, wdtDomainNamespace);\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(wdtDomainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wdtDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wdtDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wdtDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wdtDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wdtDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wdtDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wdtDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wdtDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wdtDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain on a persistent volume by doing the following.\n+   * Create a configmap containing WLST script and property file.\n+   * Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param wlstScriptFile python script to create domain\n+   * @param domainPropertiesFile properties file containing domain configuration\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  private void createDomainOnPVUsingWlst(Path wlstScriptFile, Path domainPropertiesFile,\n+      String pvName, String pvcName, String namespace) throws ApiException {\n+    logger.info(\"Preparing to run create domain job using WLST\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(wlstScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, namespace),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/oracle/oracle_common/common/bin/wlst.sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + wlstScriptFile.getFileName()) //wlst.sh script\n+        .addArgsItem(\"-skipWLSModuleScanning\")\n+        .addArgsItem(\"-loadProperties\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainPropertiesFile.getFileName()); //domain property file\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+\n+  }\n+\n+  /**\n+   * Create a WebLogic domain on a persistent volume by doing the following.\n+   * Create a configmap containing WDT model file, property file and shell script to download and run WDT.\n+   * Create a Kubernetes job to create domain on persistent volume.\n+   *\n+   * @param domainCreationScriptFile path of the shell script to download and run WDT\n+   * @param modelFile path of the WDT model file\n+   * @param domainPropertiesFile property file holding properties referenced in WDT model file\n+   * @param domainUid unique id of the WebLogic domain\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  private void createDomainOnPVUsingWdt(Path domainCreationScriptFile, Path modelFile,\n+      Path domainPropertiesFile, String domainUid, String pvName, String pvcName, String namespace)\n+      throws ApiException {\n+    logger.info(\"Preparing to run create domain job using WDT\");\n+\n+    List<Path> domainScriptFiles = new ArrayList<>();\n+    domainScriptFiles.add(domainCreationScriptFile);\n+    domainScriptFiles.add(domainPropertiesFile);\n+    domainScriptFiles.add(modelFile);\n+\n+    logger.info(\"Creating a config map to hold domain creation scripts\");\n+    String domainScriptConfigMapName = \"create-domain-scripts-cm\";\n+    assertDoesNotThrow(\n+        () -> createConfigMapForDomainCreation(domainScriptConfigMapName, domainScriptFiles, namespace),\n+        \"Create configmap for domain creation failed\");\n+\n+    // create a V1Container with specific scripts and properties for creating domain\n+    V1Container jobCreationContainer = new V1Container()\n+        .addCommandItem(\"/bin/sh\")\n+        .addArgsItem(\"/u01/weblogic/\" + domainCreationScriptFile.getFileName()) //shell script to run WDT\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_VERSION\")\n+            .value(WDT_VERSION)) // WDT version to use\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_MODEL_FILE\")\n+            .value(\"/u01/weblogic/\" + modelFile.getFileName())) // WDT model file\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"WDT_VAR_FILE\")\n+            .value(\"/u01/weblogic/\" + domainPropertiesFile.getFileName())) // WDT model property file\n+        .addEnvItem(new V1EnvVar()\n+            .name(\"DOMAIN_HOME_DIR\")\n+            .value(\"/shared/domains/\" + domainUid)); // domain location\n+\n+    logger.info(\"Running a Kubernetes job to create the domain\");\n+    runCreateDomainJob(pvName, pvcName, domainScriptConfigMapName, namespace, jobCreationContainer);\n+\n+  }\n+\n+  /**\n+   * Create configmap containing domain creation scripts.\n+   *\n+   * @param configMapName name of the configmap to create\n+   * @param files files to add in configmap\n+   * @param namespace name of the namespace in which to create configmap\n+   * @throws IOException when reading the domain script files fail\n+   * @throws ApiException if create configmap fails\n+   */\n+  private void createConfigMapForDomainCreation(String configMapName, List<Path> files, String namespace)\n+      throws ApiException, IOException {\n+    logger.info(\"Creating configmap {0}\", configMapName);\n+\n+    Path domainScriptsDir = Files.createDirectories(\n+          Paths.get(TestConstants.LOGS_DIR, this.getClass().getSimpleName(), namespace));\n+\n+    // add domain creation scripts and properties files to the configmap\n+    Map<String, String> data = new HashMap<>();\n+    for (Path file : files) {\n+      logger.info(\"Adding file {0} in configmap\", file);\n+      data.put(file.getFileName().toString(), Files.readString(file));\n+      logger.info(\"Making a copy of file {0} to {1} for diagnostic purposes\", file,\n+          domainScriptsDir.resolve(file.getFileName()));\n+      Files.copy(file, domainScriptsDir.resolve(file.getFileName()));\n+    }\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .name(configMapName)\n+        .namespace(namespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"Failed to create configmap %s with files %s\", configMapName, files));\n+    assertTrue(cmCreated, String.format(\"Failed while creating ConfigMap %s\", configMapName));\n+  }\n+\n+  /**\n+   * Create a job to create a domain in persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create domain in\n+   * @param pvcName name of the persistent volume claim\n+   * @param domainScriptCM configmap holding domain creation script files\n+   * @param namespace name of the domain namespace in which the job is created\n+   * @param jobContainer V1Container with job commands to create domain\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  private void runCreateDomainJob(String pvName,\n+      String pvcName, String domainScriptCM, String namespace, V1Container jobContainer) throws ApiException {\n+    logger.info(\"Running Kubernetes job to create domain\");\n+\n+    V1Job jobBody = new V1Job()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .name(\"create-domain-onpv-job-\" + pvName) // name of the create domain job\n+                .namespace(namespace))\n+        .spec(new V1JobSpec()\n+            .backoffLimit(0) // try only once\n+            .template(new V1PodTemplateSpec()\n+                .spec(new V1PodSpec()\n+                    .restartPolicy(\"Never\")\n+                    .initContainers(Arrays.asList(new V1Container()\n+                        .name(\"fix-pvc-owner\") // change the ownership of the pv to opc:opc\n+                        .image(image)\n+                        .addCommandItem(\"/bin/sh\")\n+                        .addArgsItem(\"-c\")\n+                        .addArgsItem(\"chown -R 1000:1000 /shared\")\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(pvName)\n+                                .mountPath(\"/shared\")))\n+                        .securityContext(new V1SecurityContext()\n+                            .runAsGroup(0L)\n+                            .runAsUser(0L))))\n+                    .containers(Arrays.asList(jobContainer  // container containing WLST or WDT details\n+                        .name(\"create-weblogic-domain-onpv-container\")\n+                        .image(image)\n+                        .imagePullPolicy(\"Always\")\n+                        .ports(Arrays.asList(new V1ContainerPort()\n+                            .containerPort(7001)))\n+                        .volumeMounts(Arrays.asList(\n+                            new V1VolumeMount()\n+                                .name(\"create-weblogic-domain-job-cm-volume\") // domain creation scripts volume\n+                                .mountPath(\"/u01/weblogic\"), // availble under /u01/weblogic inside pod\n+                            new V1VolumeMount()\n+                                .name(pvName) // location to write domain\n+                                .mountPath(\"/shared\"))))) // mounted under /shared inside pod\n+                    .volumes(Arrays.asList(\n+                        new V1Volume()\n+                            .name(pvName)\n+                            .persistentVolumeClaim(\n+                                new V1PersistentVolumeClaimVolumeSource()\n+                                    .claimName(pvcName)),\n+                        new V1Volume()\n+                            .name(\"create-weblogic-domain-job-cm-volume\")\n+                            .configMap(\n+                                new V1ConfigMapVolumeSource()\n+                                    .name(domainScriptCM)))) //config map containing domain scripts\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+    String jobName = assertDoesNotThrow(()\n+        -> createNamespacedJob(jobBody), \"Failed to create Job\");\n+\n+    logger.info(\"Checking if the domain creation job {0} completed in namespace {1}\",\n+        jobName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for job {0} to be completed in namespace {1} \"\n+                + \"(elapsed time {2} ms, remaining time {3} ms)\",\n+                jobName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(jobCompleted(jobName, null, namespace));\n+\n+    // check job status and fail test if the job failed to create domain\n+    V1Job job = getJob(jobName, namespace);\n+    if (job != null) {\n+      V1JobCondition jobCondition = job.getStatus().getConditions().stream().filter(\n+          v1JobCondition -> \"Failed\".equalsIgnoreCase(v1JobCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+      if (jobCondition != null) {\n+        logger.severe(\"Job {0} failed to create domain\", jobName);\n+        List<V1Pod> pods = listPods(namespace, \"job-name=\" + jobName).getItems();\n+        if (!pods.isEmpty()) {\n+          logger.severe(getPodLog(pods.get(0).getMetadata().getName(), namespace));\n+          fail(\"Domain create job failed\");\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /**\n+   * Create a persistent volume.\n+   *\n+   * @param pvName name of the persistent volume to create\n+   * @param domainUid domain UID\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPV(String pvName, String domainUid) throws IOException {\n+    logger.info(\"creating persistent volume\");\n+\n+    Path pvHostPath = Files.createDirectories(Paths.get(\n+        PV_ROOT, this.getClass().getSimpleName(), pvName));\n+    logger.info(\"Creating PV directory host path {0}\", pvHostPath);\n+    FileUtils.deleteDirectory(pvHostPath.toFile());\n+    Files.createDirectories(pvHostPath);\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(\"weblogic-domain-storage-class\")\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"5Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Recycle\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMeta()\n+            .name(pvName)\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+    boolean success = assertDoesNotThrow(() -> createPersistentVolume(v1pv),\n+        \"Failed to create persistent volume\");\n+    assertTrue(success, \"PersistentVolume creation failed\");\n+  }\n+\n+  /**\n+   * Create a persistent volume claim.\n+   *\n+   * @param pvName name of the persistent volume\n+   * @param pvcName name of the persistent volume to create\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to create the persistent volume claim\n+   */\n+  private void createPVC(String pvName, String pvcName, String domainUid, String namespace) {\n+    logger.info(\"creating persistent volume claim\");\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(\"weblogic-domain-storage-class\")\n+            .volumeName(pvName)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"5Gi\"))))\n+        .metadata(new V1ObjectMeta()\n+            .name(pvcName)\n+            .namespace(namespace)\n+            .putLabelsItem(\"weblogic.resourceVersion\", \"domain-v2\")\n+            .putLabelsItem(\"weblogic.domainUid\", domainUid));\n+\n+    boolean success = assertDoesNotThrow(() -> createPersistentVolumeClaim(v1pvc),\n+        \"Failed to create persistent volume claim\");\n+    assertTrue(success, \"PersistentVolumeClaim creation failed\");\n+  }\n+\n+  /**\n+   * Create secret for docker credentials.\n+   *\n+   * @param namespace name of the namespace in which to create secret\n+   */\n+  private void createOCRRepoSecret(String namespace) {", "originalCommit": "2ccb46fa654d0ea49a2df65207a3261a727b32d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzNTc3Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431435772", "bodyText": "I created one in my PR.", "author": "xiancao", "createdAt": "2020-05-27T20:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4NzY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MDg5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431450898", "bodyText": "I have added a overloaded method in CommonTestUtils and using it inside this method.", "author": "sankarpn", "createdAt": "2020-05-27T21:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4NzY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4MzQ3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431383476", "bodyText": "why do you want to hard code the wdt.version?", "author": "xiancao", "createdAt": "2020-05-27T19:15:06Z", "path": "new-integration-tests/pom.xml", "diffHunk": "@@ -19,7 +19,7 @@\n     <properties>\n         <skipITs>false</skipITs>\n         <wit.version>latest</wit.version>\n-        <wdt.version>latest</wdt.version>\n+        <wdt.version>1.8.1</wdt.version>", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MjUxMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431452511", "bodyText": "rolled it back to latest", "author": "sankarpn", "createdAt": "2020-05-27T21:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4MzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4NzE4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431387185", "bodyText": "use static import here.", "author": "xiancao", "createdAt": "2020-05-27T19:18:58Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMzY3NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431433674", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T20:50:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4NzE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4ODA4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431388082", "bodyText": "use static import here", "author": "xiancao", "createdAt": "2020-05-27T19:20:25Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzNjA3OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431436079", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T20:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4ODA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4ODg4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431388882", "bodyText": "use static import here", "author": "xiancao", "createdAt": "2020-05-27T19:22:02Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0ODQyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431448423", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4ODg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4ODk4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431388988", "bodyText": "use static import here", "author": "xiancao", "createdAt": "2020-05-27T19:22:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0ODQ4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431448489", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4ODk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4OTA5Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431389092", "bodyText": "use static import here", "author": "xiancao", "createdAt": "2020-05-27T19:22:27Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0ODU0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431448546", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4OTA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4OTIzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431389238", "bodyText": "use static import here", "author": "xiancao", "createdAt": "2020-05-27T19:22:44Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0ODYxMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431448612", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4OTIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4OTQ0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431389448", "bodyText": "use static import here", "author": "xiancao", "createdAt": "2020-05-27T19:23:07Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wlstDomainNamespace);", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0ODY1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431448654", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4OTQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MDMwOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431390308", "bodyText": "use static import here\nit can be changed to:\nboolean loginSuccessful = assertDoesNotThrow(() -> adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT), \"Access to admin server node port failed\");", "author": "xiancao", "createdAt": "2020-05-27T19:24:50Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wlstDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0ODk1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431448959", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MDMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MTM0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431391340", "bodyText": "use static import here", "author": "xiancao", "createdAt": "2020-05-27T19:26:49Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wlstDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WDT in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WDT\")\n+  public void testDomainOnPvUsingWdt() throws IOException, ApiException {\n+\n+    final String domainUid = \"wdtdomain-inpv\";\n+    final String clusterName = \"cluster-wdtdomain-inpv\";\n+    final String adminServerName = \"wdt-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wdt-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(31000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wdtDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wdtDomainNamespace,", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0OTA5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431449094", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MTM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MjE1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431392157", "bodyText": "use static import here", "author": "xiancao", "createdAt": "2020-05-27T19:28:18Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wlstDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WDT in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WDT\")\n+  public void testDomainOnPvUsingWdt() throws IOException, ApiException {\n+\n+    final String domainUid = \"wdtdomain-inpv\";\n+    final String clusterName = \"cluster-wdtdomain-inpv\";\n+    final String adminServerName = \"wdt-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wdt-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(31000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wdtDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wdtDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wdtDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file as a input for WDT model file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"ADMIN_USERNAME_DEFAULTname\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"ADMIN_PASSWORD_DEFAULT\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"domainName\", domainUid);\n+    p.setProperty(\"adminServerName\", adminServerName);\n+    p.setProperty(\"productionModeEnabled\", \"true\");\n+    p.setProperty(\"clusterName\", clusterName);\n+    p.setProperty(\"configuredManagedServerCount\", \"4\");\n+    p.setProperty(\"managedServerNameBase\", managedServerNameBase);\n+    p.setProperty(\"t3ChannelPort\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"t3PublicAddress\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"managedServerPort\", \"8001\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"WDT properties file\");\n+\n+    // shell script to download WDT and run the WDT createDomain script\n+    Path wdtScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", \"wdt-create-domain-onpv.sh\");\n+    // WDT model file containing WebLogic domain configuration\n+    Path wdtModelFile = Paths.get(RESOURCE_DIR, \"wdt-models\", \"domain-onpv-wdt-model.yaml\");\n+\n+    // create configmap and domain on persistent volume using WDT\n+    createDomainOnPVUsingWdt(wdtScript, wdtModelFile, domainPropertiesFile.toPath(),\n+        domainUid, pvName, pvcName, wdtDomainNamespace);\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(wdtDomainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wdtDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wdtDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wdtDomainNamespace);", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0OTI2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431449264", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MjE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MjI3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431392277", "bodyText": "use static import here", "author": "xiancao", "createdAt": "2020-05-27T19:28:33Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wlstDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WDT in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WDT\")\n+  public void testDomainOnPvUsingWdt() throws IOException, ApiException {\n+\n+    final String domainUid = \"wdtdomain-inpv\";\n+    final String clusterName = \"cluster-wdtdomain-inpv\";\n+    final String adminServerName = \"wdt-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wdt-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(31000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wdtDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wdtDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wdtDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file as a input for WDT model file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"ADMIN_USERNAME_DEFAULTname\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"ADMIN_PASSWORD_DEFAULT\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"domainName\", domainUid);\n+    p.setProperty(\"adminServerName\", adminServerName);\n+    p.setProperty(\"productionModeEnabled\", \"true\");\n+    p.setProperty(\"clusterName\", clusterName);\n+    p.setProperty(\"configuredManagedServerCount\", \"4\");\n+    p.setProperty(\"managedServerNameBase\", managedServerNameBase);\n+    p.setProperty(\"t3ChannelPort\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"t3PublicAddress\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"managedServerPort\", \"8001\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"WDT properties file\");\n+\n+    // shell script to download WDT and run the WDT createDomain script\n+    Path wdtScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", \"wdt-create-domain-onpv.sh\");\n+    // WDT model file containing WebLogic domain configuration\n+    Path wdtModelFile = Paths.get(RESOURCE_DIR, \"wdt-models\", \"domain-onpv-wdt-model.yaml\");\n+\n+    // create configmap and domain on persistent volume using WDT\n+    createDomainOnPVUsingWdt(wdtScript, wdtModelFile, domainPropertiesFile.toPath(),\n+        domainUid, pvName, pvcName, wdtDomainNamespace);\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(wdtDomainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wdtDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wdtDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wdtDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wdtDomainNamespace);", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0OTMyNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431449324", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MjI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MjM5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431392390", "bodyText": "use static import here", "author": "xiancao", "createdAt": "2020-05-27T19:28:45Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wlstDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WDT in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WDT\")\n+  public void testDomainOnPvUsingWdt() throws IOException, ApiException {\n+\n+    final String domainUid = \"wdtdomain-inpv\";\n+    final String clusterName = \"cluster-wdtdomain-inpv\";\n+    final String adminServerName = \"wdt-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wdt-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(31000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wdtDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wdtDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wdtDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file as a input for WDT model file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"ADMIN_USERNAME_DEFAULTname\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"ADMIN_PASSWORD_DEFAULT\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"domainName\", domainUid);\n+    p.setProperty(\"adminServerName\", adminServerName);\n+    p.setProperty(\"productionModeEnabled\", \"true\");\n+    p.setProperty(\"clusterName\", clusterName);\n+    p.setProperty(\"configuredManagedServerCount\", \"4\");\n+    p.setProperty(\"managedServerNameBase\", managedServerNameBase);\n+    p.setProperty(\"t3ChannelPort\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"t3PublicAddress\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"managedServerPort\", \"8001\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"WDT properties file\");\n+\n+    // shell script to download WDT and run the WDT createDomain script\n+    Path wdtScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", \"wdt-create-domain-onpv.sh\");\n+    // WDT model file containing WebLogic domain configuration\n+    Path wdtModelFile = Paths.get(RESOURCE_DIR, \"wdt-models\", \"domain-onpv-wdt-model.yaml\");\n+\n+    // create configmap and domain on persistent volume using WDT\n+    createDomainOnPVUsingWdt(wdtScript, wdtModelFile, domainPropertiesFile.toPath(),\n+        domainUid, pvName, pvcName, wdtDomainNamespace);\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(wdtDomainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wdtDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wdtDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wdtDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wdtDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wdtDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wdtDomainNamespace);", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0OTM3NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431449375", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MjM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MjUxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431392514", "bodyText": "use static import here", "author": "xiancao", "createdAt": "2020-05-27T19:28:58Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wlstDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WDT in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WDT\")\n+  public void testDomainOnPvUsingWdt() throws IOException, ApiException {\n+\n+    final String domainUid = \"wdtdomain-inpv\";\n+    final String clusterName = \"cluster-wdtdomain-inpv\";\n+    final String adminServerName = \"wdt-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wdt-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(31000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wdtDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wdtDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wdtDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file as a input for WDT model file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"ADMIN_USERNAME_DEFAULTname\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"ADMIN_PASSWORD_DEFAULT\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"domainName\", domainUid);\n+    p.setProperty(\"adminServerName\", adminServerName);\n+    p.setProperty(\"productionModeEnabled\", \"true\");\n+    p.setProperty(\"clusterName\", clusterName);\n+    p.setProperty(\"configuredManagedServerCount\", \"4\");\n+    p.setProperty(\"managedServerNameBase\", managedServerNameBase);\n+    p.setProperty(\"t3ChannelPort\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"t3PublicAddress\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"managedServerPort\", \"8001\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"WDT properties file\");\n+\n+    // shell script to download WDT and run the WDT createDomain script\n+    Path wdtScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", \"wdt-create-domain-onpv.sh\");\n+    // WDT model file containing WebLogic domain configuration\n+    Path wdtModelFile = Paths.get(RESOURCE_DIR, \"wdt-models\", \"domain-onpv-wdt-model.yaml\");\n+\n+    // create configmap and domain on persistent volume using WDT\n+    createDomainOnPVUsingWdt(wdtScript, wdtModelFile, domainPropertiesFile.toPath(),\n+        domainUid, pvName, pvcName, wdtDomainNamespace);\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(wdtDomainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wdtDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wdtDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wdtDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wdtDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wdtDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wdtDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wdtDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wdtDomainNamespace);", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0OTQxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431449419", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:20:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MjUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MjcxNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431392715", "bodyText": "use static import here", "author": "xiancao", "createdAt": "2020-05-27T19:29:23Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItDomainInPV.java", "diffHunk": "@@ -0,0 +1,780 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.assertions.TestAssertions;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST and WDT.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String wlstDomainNamespace = null;\n+  private static String wdtDomainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+    logger.info(\"Assign a unique namespace for WLST WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wlstDomainNamespace = namespaces.get(1);\n+    logger.info(\"Assign a unique namespace for WDT WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    wdtDomainNamespace = namespaces.get(2);\n+\n+    // install operator and verify its running in ready state\n+    CommonTestUtils.installAndVerifyOperator(opNamespace, wdtDomainNamespace, wlstDomainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WLST script\")\n+  public void testDomainOnPvUsingWlst() throws IOException, ApiException {\n+\n+    final String domainUid = \"wlstdomain-inpv\";\n+    final String clusterName = \"cluster-wlstdomain-inpv\";\n+    final String adminServerName = \"wlst-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wlstDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wlstDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wlstDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, wlstDomainNamespace);\n+\n+    // create a domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(wlstDomainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wlstDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wlstDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wlstDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wlstDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wlstDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wlstDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wlstDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wlstDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+    }, \"Access to admin server node port failed\");\n+    assertTrue(loginSuccessful, \"Console login validation failed\");\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WDT in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   * @throws IOException when creating directories for persistent volume,\n+     creating temporary domain property file fails\n+   * @throws ApiException when Kubernetes cluster query fails\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV using WDT\")\n+  public void testDomainOnPvUsingWdt() throws IOException, ApiException {\n+\n+    final String domainUid = \"wdtdomain-inpv\";\n+    final String clusterName = \"cluster-wdtdomain-inpv\";\n+    final String adminServerName = \"wdt-admin-server\";\n+    final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+    final String managedServerNameBase = \"wdt-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(31000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(wdtDomainNamespace);\n+    }\n+\n+    // create WebLogic domain credential secret\n+    CommonTestUtils.createSecretWithUsernamePassword(wlSecretName, wdtDomainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, wdtDomainNamespace);\n+\n+    // create a temporary WebLogic domain property file as a input for WDT model file\n+    File domainPropertiesFile = File.createTempFile(\"domain\", \"properties\");\n+    Properties p = new Properties();\n+    p.setProperty(\"ADMIN_USERNAME_DEFAULTname\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"ADMIN_PASSWORD_DEFAULT\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"domainName\", domainUid);\n+    p.setProperty(\"adminServerName\", adminServerName);\n+    p.setProperty(\"productionModeEnabled\", \"true\");\n+    p.setProperty(\"clusterName\", clusterName);\n+    p.setProperty(\"configuredManagedServerCount\", \"4\");\n+    p.setProperty(\"managedServerNameBase\", managedServerNameBase);\n+    p.setProperty(\"t3ChannelPort\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"t3PublicAddress\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"managedServerPort\", \"8001\");\n+    p.store(new FileOutputStream(domainPropertiesFile), \"WDT properties file\");\n+\n+    // shell script to download WDT and run the WDT createDomain script\n+    Path wdtScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", \"wdt-create-domain-onpv.sh\");\n+    // WDT model file containing WebLogic domain configuration\n+    Path wdtModelFile = Paths.get(RESOURCE_DIR, \"wdt-models\", \"domain-onpv-wdt-model.yaml\");\n+\n+    // create configmap and domain on persistent volume using WDT\n+    createDomainOnPVUsingWdt(wdtScript, wdtModelFile, domainPropertiesFile.toPath(),\n+        domainUid, pvName, pvcName, wdtDomainNamespace);\n+\n+    // create the domain custom resource configuration object\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta() //metadata\n+            .name(domainUid)\n+            .namespace(wdtDomainNamespace))\n+        .spec(new DomainSpec() //spec\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid)  // point to domain home in pv\n+            .domainHomeSourceType(\"PersistentVolume\") // set the domain home source type as pv\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(wdtDomainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\")));\n+\n+    // verify the domain custom resource is created\n+    CommonTestUtils.createDomainAndVerify(domain, wdtDomainNamespace);\n+\n+    // verify admin server pod is ready\n+    CommonTestUtils.checkPodReady(adminServerPodName, domainUid, wdtDomainNamespace);\n+\n+    // verify the admin server service created\n+    CommonTestUtils.checkServiceExists(adminServerPodName, wdtDomainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, wdtDomainNamespace);\n+      CommonTestUtils.checkPodReady(managedServerPodNamePrefix + i, domainUid, wdtDomainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, wdtDomainNamespace);\n+      CommonTestUtils.checkServiceExists(managedServerPodNamePrefix + i, wdtDomainNamespace);\n+    }\n+\n+    logger.info(\"Getting node port for default channel\");\n+    int serviceNodePort = assertDoesNotThrow(()\n+        -> getServiceNodePort(wdtDomainNamespace, adminServerPodName + \"-external\", \"default\"),\n+        \"Getting admin server node port failed\");\n+\n+    logger.info(\"Validating WebLogic admin server access by login to console\");\n+    boolean loginSuccessful = assertDoesNotThrow(() -> {\n+      return TestAssertions.adminNodePortAccessible(serviceNodePort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0OTQ2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431449467", "bodyText": "Fixed", "author": "sankarpn", "createdAt": "2020-05-27T21:21:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MjcxNQ=="}], "type": "inlineReview"}, {"oid": "71552d429d68e35e1cc9c0755a59f7c80b2ce0bb", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/71552d429d68e35e1cc9c0755a59f7c80b2ce0bb", "message": "use latest if WDT_VERSION is not provided", "committedDate": "2020-05-27T19:49:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzNzMwOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431437308", "bodyText": "why do you need to change the wdt.version to 1.8.1 by default?", "author": "xiancao", "createdAt": "2020-05-27T20:56:59Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/ActionConstants.java", "diffHunk": "@@ -8,52 +8,52 @@\n public interface ActionConstants {\n \n   // Work directory for the integration test suite\n-  public static final String WORK_DIR \n+  public static final String WORK_DIR\n       = System.getProperty(\"java.io.tmpdir\") + \"/it-results\";\n   // Directory for resources\n-  public static final String RESOURCE_DIR \n-      = System.getProperty(\"user.dir\") + \"/src/test/resources\"; \n+  public static final String RESOURCE_DIR\n+      = System.getProperty(\"user.dir\") + \"/src/test/resources\";\n   // Directory for all applications\n-  public static final String APP_DIR = RESOURCE_DIR + \"/apps\"; \n+  public static final String APP_DIR = RESOURCE_DIR + \"/apps\";\n   // Directory for all WDT models\n-  public static final String MODEL_DIR = RESOURCE_DIR + \"/wdt-models\"; \n+  public static final String MODEL_DIR = RESOURCE_DIR + \"/wdt-models\";\n   // Directory for download items\n   public static final String DOWNLOAD_DIR = WORK_DIR + \"/download\";\n   // Directory for staging purposes\n   public static final String STAGE_DIR = WORK_DIR + \"/stage\";\n   //Directory for archiving purposes\n   public static final String ARCHIVE_DIR = STAGE_DIR + \"/archive\";\n   // Directory for WIT build\n-  public static final String WIT_BUILD_DIR = WORK_DIR + \"/wit-build\"; \n-  \n+  public static final String WIT_BUILD_DIR = WORK_DIR + \"/wit-build\";\n+\n   // ------------ WebLogicImageTool action constants -------------\n   public static final String WLS = \"WLS\";\n   public static final String JRF = \"JRF\";\n   public static final String RJRF = \"RestrictedJRF\";\n-  public static final String WLS_BASE_IMAGE_NAME \n+  public static final String WLS_BASE_IMAGE_NAME\n       = TestConstants.OCR_REGISTRY + \"/middleware/weblogic\";\n-  public static final String JRF_BASE_IMAGE_NAME \n+  public static final String JRF_BASE_IMAGE_NAME\n       = TestConstants.OCR_REGISTRY + \"/middleware/fmw-infrastructure\";\n   public static final String WLS_BASE_IMAGE_TAG = \"12.2.1.4\";\n \n   public static final String DEFAULT_MODEL_IMAGE_NAME = \"test-mii-image\";\n   public static final String DEFAULT_MODEL_IMAGE_TAG  = \"v1\";\n-  \n+\n   // ------------ WebLogic Image Tool constants----------------------------\n   public static final String WIT = \"WIT\";\n   public static final String WDT = \"WDT\";\n \n-  public static final String WIT_DOWNLOAD_URL \n+  public static final String WIT_DOWNLOAD_URL\n       = \"https://github.com/oracle/weblogic-image-tool\";\n   public static final String WIT_VERSION    = System.getProperty(\"wit.version\", \"latest\");\n   public static final String WIT_FILE_NAME  = \"imagetool.zip\";\n \n-  public static final String WDT_DOWNLOAD_URL \n+  public static final String WDT_DOWNLOAD_URL\n       = \"https://github.com/oracle/weblogic-deploy-tooling\";\n-  public static final String WDT_VERSION    = System.getProperty(\"wdt.version\", \"latest\");\n+  public static final String WDT_VERSION    = System.getProperty(\"wdt.version\", \"1.8.1\");", "originalCommit": "3e55c61fa651f187506e5adf76b25dc7d48e8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MjkxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1678#discussion_r431452913", "bodyText": "that was the latest version, but rolled it back to what was before.", "author": "sankarpn", "createdAt": "2020-05-27T21:28:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzNzMwOA=="}], "type": "inlineReview"}, {"oid": "7f254cbab933219d15518677255e63ce9a49a9e9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7f254cbab933219d15518677255e63ce9a49a9e9", "message": "Addressing review comments", "committedDate": "2020-05-27T21:31:04Z", "type": "commit"}, {"oid": "e7a30cf70222493cb5e5e9af09fb989f1b6ae2a9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e7a30cf70222493cb5e5e9af09fb989f1b6ae2a9", "message": "Fix the WDT URL", "committedDate": "2020-05-27T23:06:05Z", "type": "commit"}, {"oid": "20c4eac410b576da29aa6314e4f4e76253ea70b0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/20c4eac410b576da29aa6314e4f4e76253ea70b0", "message": "wip", "committedDate": "2020-05-27T23:42:47Z", "type": "commit"}, {"oid": "1883f256b31c94380b472d40ef7fbfe447d2e853", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1883f256b31c94380b472d40ef7fbfe447d2e853", "message": "retry the logic for WDT url", "committedDate": "2020-05-28T01:10:41Z", "type": "commit"}, {"oid": "15b610626c4da16ee500cedc382fb58daff61898", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/15b610626c4da16ee500cedc382fb58daff61898", "message": "Merge branch 'develop' into testdomaininpvusingwdt", "committedDate": "2020-05-28T14:05:47Z", "type": "commit"}]}