{"pr_number": 1778, "pr_title": "Two Domain with Single Istio Ingress Controller", "pr_createdAt": "2020-06-30T17:30:32Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778", "timeline": [{"oid": "5d4111fa99a26a3ab5f89e9b0c63e48023784ece", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5d4111fa99a26a3ab5f89e9b0c63e48023784ece", "message": "Added unique host info to istion VS/Gateway", "committedDate": "2020-06-26T23:39:16Z", "type": "commit"}, {"oid": "c212514ab7202bc6de5e645bce1151deb68af975", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c212514ab7202bc6de5e645bce1151deb68af975", "message": "Modify checkAppUsingHostHeader()", "committedDate": "2020-06-29T17:22:31Z", "type": "commit"}, {"oid": "cec30fb7028c129ef8c4102081ee315f3c471de4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cec30fb7028c129ef8c4102081ee315f3c471de4", "message": "Checking for server readiness with quick retry", "committedDate": "2020-06-29T17:45:15Z", "type": "commit"}, {"oid": "49949b794a8f8be7be1fb8cf8ae0a07206fcddf3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/49949b794a8f8be7be1fb8cf8ae0a07206fcddf3", "message": "Removed hard-coded sleep beore checking Console", "committedDate": "2020-06-29T18:57:14Z", "type": "commit"}, {"oid": "a9ff874498c2a183ea831972f13312f1e47c1c07", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a9ff874498c2a183ea831972f13312f1e47c1c07", "message": "Added two doamin test", "committedDate": "2020-06-29T23:55:32Z", "type": "commit"}, {"oid": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0", "message": "Fixed the javadoc comments", "committedDate": "2020-06-30T15:29:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg4NjQ0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447886443", "bodyText": "accessible", "author": "rjeberhard", "createdAt": "2020-06-30T18:15:28Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console on domain1 through istio ingress http \n+   * port by passing host information in HTTP header.\n+   * Deploy a web application to domain1 through istio ingress http port \n+   * using host information in HTTP header. \n+   * Access web application through istio http ingress port using host i\n+   * information in HTTP header.\n+   * Repeat the same steps for domain2.\n+   */\n+  @Test\n+  @DisplayName(\"Two WebLogic domainhome-in-image with single istio ingress\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioTwoDomainsiWithSingleIngress() {\n+    final String managedServerPrefix1 = domainUid1 + \"-managed-server\";\n+    final String managedServerPrefix2 = domainUid2 + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace1);\n+    createDockerRegistrySecret(domainNamespace2);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName1 = \"weblogic-credentials-1\";\n+    createSecretWithUsernamePassword(adminSecretName1, domainNamespace1, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    String adminSecretName2 = \"weblogic-credentials-2\";\n+    createSecretWithUsernamePassword(adminSecretName2, domainNamespace2, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR(s)\n+    createDomainResource(domainUid1, domainNamespace1, adminSecretName1, REPO_SECRET_NAME,\n+        replicaCount);\n+    createDomainResource(domainUid2, domainNamespace2, adminSecretName2, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace1);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid1,\n+                domainNamespace1,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid1, DOMAIN_VERSION, domainNamespace1));\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace2);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid2,\n+                domainNamespace2,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid2, DOMAIN_VERSION, domainNamespace2));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkPodReady(adminServerPodName1, domainUid1, domainNamespace1);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkPodReady(adminServerPodName2, domainUid2, domainNamespace2);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkPodReady(managedServerPrefix1 + i, domainUid1, domainNamespace1);\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkPodReady(managedServerPrefix2 + i, domainUid2, domainNamespace2);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkServiceExists(adminServerPodName1, domainNamespace1);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkServiceExists(adminServerPodName2, domainNamespace2);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkServiceExists(managedServerPrefix1 + i, domainNamespace1);\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkServiceExists(managedServerPrefix2 + i, domainNamespace2);\n+    }\n+\n+    String clusterService1 = domainUid1 + \"-cluster-\" + clusterName + \".\" + domainNamespace1 + \".svc.cluster.local\";\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domainNamespace1);\n+    templateMap.put(\"DUID\", domainUid1);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName1);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService1);\n+\n+    Path srcHttpFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.yaml\");\n+    Path targetHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http1.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain1\", targetHttpFile);\n+    boolean deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+\n+    Path srcDrFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-dr-template.yaml\");\n+    Path targetDrFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr1.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+    String clusterService2 = domainUid2 + \"-cluster-\" + clusterName + \".\" + domainNamespace2 + \".svc.cluster.local\";\n+    templateMap.put(\"NAMESPACE\", domainNamespace2);\n+    templateMap.put(\"DUID\", domainUid2);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName2);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService2);\n+\n+    Path targetHttpFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http2.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain2\", targetHttpFile);\n+    deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile2)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+    \n+    Path targetDrFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr2.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile2));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace1 + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console on domain1\");\n+    logger.info(\"WebLogic console on domain1 is acceesible\");", "originalCommit": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzNTgzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448035838", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-30T23:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg4NjQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NjE1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447976153", "bodyText": "accessible typo", "author": "vanajamukkara", "createdAt": "2020-06-30T21:00:36Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -216,33 +215,26 @@ public void testIstioDomainHomeInImageUsingWdt() {\n     int istioIngressPort = getIstioHttpIngressPort();\n     logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n \n-    logger.info(\"Validating WebLogic admin server access by login to console\");\n-    boolean loginSuccessful = assertDoesNotThrow(() -> {\n-      return adminNodePortAccessible(istioIngressPort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n-    }, \"Access to admin server node port failed\");\n-    assertTrue(loginSuccessful, \"Console login validation failed\");\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console\");\n+    logger.info(\"WebLogic console is acceesible\");", "originalCommit": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzNTY4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448035688", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-30T23:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NjE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzNTg3OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448035878", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-30T23:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NjE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NjI5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447976293", "bodyText": "return", "author": "vanajamukkara", "createdAt": "2020-06-30T21:00:52Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -216,33 +215,26 @@ public void testIstioDomainHomeInImageUsingWdt() {\n     int istioIngressPort = getIstioHttpIngressPort();\n     logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n \n-    logger.info(\"Validating WebLogic admin server access by login to console\");\n-    boolean loginSuccessful = assertDoesNotThrow(() -> {\n-      return adminNodePortAccessible(istioIngressPort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n-    }, \"Access to admin server node port failed\");\n-    assertTrue(loginSuccessful, \"Console login validation failed\");\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console\");\n+    logger.info(\"WebLogic console is acceesible\");\n \n     Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n     ExecResult result = null;\n     result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n         String.valueOf(istioIngressPort),\n         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n-        clusterName, archivePath);\n+        clusterName, archivePath, domainNamespace + \".org\");\n     assertNotNull(result, \"Application deployment failed\");\n     logger.info(\"Application deployment returned {0}\", result.toString());\n-    assertEquals(\"202\", result.stdout(), \"Application deployed successfully\");\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not returns HTTP status code 202\");", "originalCommit": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzNjQ4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448036485", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-30T23:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NjI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTY5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447979695", "bodyText": "Verify server pods are in ready state", "author": "vanajamukkara", "createdAt": "2020-06-30T21:07:38Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify domain pods runs in ready state and services are created.", "originalCommit": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzNzE4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448037184", "bodyText": "modified the description", "author": "anpanigr", "createdAt": "2020-06-30T23:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1Nzc2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448557766", "bodyText": "don't see the change", "author": "vanajamukkara", "createdAt": "2020-07-01T18:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NjY5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447986697", "bodyText": "Deployment did not return HTTP status code 202", "author": "vanajamukkara", "createdAt": "2020-06-30T21:21:56Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console on domain1 through istio ingress http \n+   * port by passing host information in HTTP header.\n+   * Deploy a web application to domain1 through istio ingress http port \n+   * using host information in HTTP header. \n+   * Access web application through istio http ingress port using host i\n+   * information in HTTP header.\n+   * Repeat the same steps for domain2.\n+   */\n+  @Test\n+  @DisplayName(\"Two WebLogic domainhome-in-image with single istio ingress\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioTwoDomainsiWithSingleIngress() {\n+    final String managedServerPrefix1 = domainUid1 + \"-managed-server\";\n+    final String managedServerPrefix2 = domainUid2 + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace1);\n+    createDockerRegistrySecret(domainNamespace2);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName1 = \"weblogic-credentials-1\";\n+    createSecretWithUsernamePassword(adminSecretName1, domainNamespace1, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    String adminSecretName2 = \"weblogic-credentials-2\";\n+    createSecretWithUsernamePassword(adminSecretName2, domainNamespace2, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR(s)\n+    createDomainResource(domainUid1, domainNamespace1, adminSecretName1, REPO_SECRET_NAME,\n+        replicaCount);\n+    createDomainResource(domainUid2, domainNamespace2, adminSecretName2, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace1);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid1,\n+                domainNamespace1,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid1, DOMAIN_VERSION, domainNamespace1));\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace2);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid2,\n+                domainNamespace2,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid2, DOMAIN_VERSION, domainNamespace2));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkPodReady(adminServerPodName1, domainUid1, domainNamespace1);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkPodReady(adminServerPodName2, domainUid2, domainNamespace2);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkPodReady(managedServerPrefix1 + i, domainUid1, domainNamespace1);\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkPodReady(managedServerPrefix2 + i, domainUid2, domainNamespace2);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkServiceExists(adminServerPodName1, domainNamespace1);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkServiceExists(adminServerPodName2, domainNamespace2);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkServiceExists(managedServerPrefix1 + i, domainNamespace1);\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkServiceExists(managedServerPrefix2 + i, domainNamespace2);\n+    }\n+\n+    String clusterService1 = domainUid1 + \"-cluster-\" + clusterName + \".\" + domainNamespace1 + \".svc.cluster.local\";\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domainNamespace1);\n+    templateMap.put(\"DUID\", domainUid1);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName1);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService1);\n+\n+    Path srcHttpFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.yaml\");\n+    Path targetHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http1.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain1\", targetHttpFile);\n+    boolean deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+\n+    Path srcDrFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-dr-template.yaml\");\n+    Path targetDrFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr1.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+    String clusterService2 = domainUid2 + \"-cluster-\" + clusterName + \".\" + domainNamespace2 + \".svc.cluster.local\";\n+    templateMap.put(\"NAMESPACE\", domainNamespace2);\n+    templateMap.put(\"DUID\", domainUid2);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName2);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService2);\n+\n+    Path targetHttpFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http2.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain2\", targetHttpFile);\n+    deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile2)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+    \n+    Path targetDrFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr2.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile2));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace1 + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console on domain1\");\n+    logger.info(\"WebLogic console on domain1 is acceesible\");\n+    Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n+    ExecResult result = null;\n+    result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n+        String.valueOf(istioIngressPort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n+        clusterName, archivePath, domainNamespace1 + \".org\");\n+    assertNotNull(result, \"Application deployment failed on domain1\");\n+    logger.info(\"Application deployment on domain1 returned {0}\", result.toString());\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not returns HTTP status code 202\");", "originalCommit": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMzY0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448003648", "bodyText": "yes, deployment thru curl command returns 202 ( for a new deployment ) and 400 ( if the app is already deployed)", "author": "anpanigr", "createdAt": "2020-06-30T21:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NjY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NzE3NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447987175", "bodyText": "accessible", "author": "vanajamukkara", "createdAt": "2020-06-30T21:22:56Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console on domain1 through istio ingress http \n+   * port by passing host information in HTTP header.\n+   * Deploy a web application to domain1 through istio ingress http port \n+   * using host information in HTTP header. \n+   * Access web application through istio http ingress port using host i\n+   * information in HTTP header.\n+   * Repeat the same steps for domain2.\n+   */\n+  @Test\n+  @DisplayName(\"Two WebLogic domainhome-in-image with single istio ingress\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioTwoDomainsiWithSingleIngress() {\n+    final String managedServerPrefix1 = domainUid1 + \"-managed-server\";\n+    final String managedServerPrefix2 = domainUid2 + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace1);\n+    createDockerRegistrySecret(domainNamespace2);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName1 = \"weblogic-credentials-1\";\n+    createSecretWithUsernamePassword(adminSecretName1, domainNamespace1, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    String adminSecretName2 = \"weblogic-credentials-2\";\n+    createSecretWithUsernamePassword(adminSecretName2, domainNamespace2, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR(s)\n+    createDomainResource(domainUid1, domainNamespace1, adminSecretName1, REPO_SECRET_NAME,\n+        replicaCount);\n+    createDomainResource(domainUid2, domainNamespace2, adminSecretName2, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace1);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid1,\n+                domainNamespace1,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid1, DOMAIN_VERSION, domainNamespace1));\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace2);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid2,\n+                domainNamespace2,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid2, DOMAIN_VERSION, domainNamespace2));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkPodReady(adminServerPodName1, domainUid1, domainNamespace1);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkPodReady(adminServerPodName2, domainUid2, domainNamespace2);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkPodReady(managedServerPrefix1 + i, domainUid1, domainNamespace1);\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkPodReady(managedServerPrefix2 + i, domainUid2, domainNamespace2);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkServiceExists(adminServerPodName1, domainNamespace1);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkServiceExists(adminServerPodName2, domainNamespace2);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkServiceExists(managedServerPrefix1 + i, domainNamespace1);\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkServiceExists(managedServerPrefix2 + i, domainNamespace2);\n+    }\n+\n+    String clusterService1 = domainUid1 + \"-cluster-\" + clusterName + \".\" + domainNamespace1 + \".svc.cluster.local\";\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domainNamespace1);\n+    templateMap.put(\"DUID\", domainUid1);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName1);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService1);\n+\n+    Path srcHttpFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.yaml\");\n+    Path targetHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http1.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain1\", targetHttpFile);\n+    boolean deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+\n+    Path srcDrFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-dr-template.yaml\");\n+    Path targetDrFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr1.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+    String clusterService2 = domainUid2 + \"-cluster-\" + clusterName + \".\" + domainNamespace2 + \".svc.cluster.local\";\n+    templateMap.put(\"NAMESPACE\", domainNamespace2);\n+    templateMap.put(\"DUID\", domainUid2);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName2);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService2);\n+\n+    Path targetHttpFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http2.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain2\", targetHttpFile);\n+    deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile2)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+    \n+    Path targetDrFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr2.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile2));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace1 + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console on domain1\");\n+    logger.info(\"WebLogic console on domain1 is acceesible\");\n+    Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n+    ExecResult result = null;\n+    result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n+        String.valueOf(istioIngressPort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n+        clusterName, archivePath, domainNamespace1 + \".org\");\n+    assertNotNull(result, \"Application deployment failed on domain1\");\n+    logger.info(\"Application deployment on domain1 returned {0}\", result.toString());\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not returns HTTP status code 202\");\n+\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/testwebapp/index.jsp\";\n+    logger.info(\"Application Access URL {0}\", url);\n+    boolean checkApp = checkAppUsingHostHeader(url, domainNamespace1 + \".org\");\n+    assertTrue(checkApp, \"Failed to access WebLogic application on domain1\");\n+\n+    checkConsole = checkAppUsingHostHeader(consoleUrl, domainNamespace2 + \".org\");\n+    assertTrue(checkConsole, \"Failed to access domain2 WebLogic console\");\n+    logger.info(\"WebLogic console on domain2 is acceesible\");", "originalCommit": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzNjYwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448036600", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-30T23:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NzE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NzM5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447987396", "bodyText": "same as above", "author": "vanajamukkara", "createdAt": "2020-06-30T21:23:25Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console on domain1 through istio ingress http \n+   * port by passing host information in HTTP header.\n+   * Deploy a web application to domain1 through istio ingress http port \n+   * using host information in HTTP header. \n+   * Access web application through istio http ingress port using host i\n+   * information in HTTP header.\n+   * Repeat the same steps for domain2.\n+   */\n+  @Test\n+  @DisplayName(\"Two WebLogic domainhome-in-image with single istio ingress\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioTwoDomainsiWithSingleIngress() {\n+    final String managedServerPrefix1 = domainUid1 + \"-managed-server\";\n+    final String managedServerPrefix2 = domainUid2 + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace1);\n+    createDockerRegistrySecret(domainNamespace2);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName1 = \"weblogic-credentials-1\";\n+    createSecretWithUsernamePassword(adminSecretName1, domainNamespace1, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    String adminSecretName2 = \"weblogic-credentials-2\";\n+    createSecretWithUsernamePassword(adminSecretName2, domainNamespace2, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR(s)\n+    createDomainResource(domainUid1, domainNamespace1, adminSecretName1, REPO_SECRET_NAME,\n+        replicaCount);\n+    createDomainResource(domainUid2, domainNamespace2, adminSecretName2, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace1);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid1,\n+                domainNamespace1,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid1, DOMAIN_VERSION, domainNamespace1));\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace2);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid2,\n+                domainNamespace2,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid2, DOMAIN_VERSION, domainNamespace2));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkPodReady(adminServerPodName1, domainUid1, domainNamespace1);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkPodReady(adminServerPodName2, domainUid2, domainNamespace2);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkPodReady(managedServerPrefix1 + i, domainUid1, domainNamespace1);\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkPodReady(managedServerPrefix2 + i, domainUid2, domainNamespace2);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkServiceExists(adminServerPodName1, domainNamespace1);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkServiceExists(adminServerPodName2, domainNamespace2);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkServiceExists(managedServerPrefix1 + i, domainNamespace1);\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkServiceExists(managedServerPrefix2 + i, domainNamespace2);\n+    }\n+\n+    String clusterService1 = domainUid1 + \"-cluster-\" + clusterName + \".\" + domainNamespace1 + \".svc.cluster.local\";\n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"NAMESPACE\", domainNamespace1);\n+    templateMap.put(\"DUID\", domainUid1);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName1);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService1);\n+\n+    Path srcHttpFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.yaml\");\n+    Path targetHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http1.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain1\", targetHttpFile);\n+    boolean deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+\n+    Path srcDrFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-dr-template.yaml\");\n+    Path targetDrFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr1.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+    String clusterService2 = domainUid2 + \"-cluster-\" + clusterName + \".\" + domainNamespace2 + \".svc.cluster.local\";\n+    templateMap.put(\"NAMESPACE\", domainNamespace2);\n+    templateMap.put(\"DUID\", domainUid2);\n+    templateMap.put(\"ADMIN_SERVICE\",adminServerPodName2);\n+    templateMap.put(\"CLUSTER_SERVICE\", clusterService2);\n+\n+    Path targetHttpFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcHttpFile.toString(), \"istio-http2.yaml\", templateMap));\n+    logger.info(\"Generated Http VS/Gateway file path is {0} for domain2\", targetHttpFile);\n+    deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(targetHttpFile2)); \n+    assertTrue(deployRes, \"Failed to deploy Http Istio Gateway/VirtualService\");\n+    \n+    Path targetDrFile2 = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcDrFile.toString(), \"istio-dr2.yaml\", templateMap));\n+    logger.info(\"Generated DestinationRule file path is {0}\", targetDrFile);\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(targetDrFile2));\n+    assertTrue(deployRes, \"Failed to deploy Istio DestinationRule\");\n+\n+    int istioIngressPort = getIstioHttpIngressPort();\n+    logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n+\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace1 + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console on domain1\");\n+    logger.info(\"WebLogic console on domain1 is acceesible\");\n+    Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n+    ExecResult result = null;\n+    result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n+        String.valueOf(istioIngressPort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n+        clusterName, archivePath, domainNamespace1 + \".org\");\n+    assertNotNull(result, \"Application deployment failed on domain1\");\n+    logger.info(\"Application deployment on domain1 returned {0}\", result.toString());\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not returns HTTP status code 202\");\n+\n+    String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/testwebapp/index.jsp\";\n+    logger.info(\"Application Access URL {0}\", url);\n+    boolean checkApp = checkAppUsingHostHeader(url, domainNamespace1 + \".org\");\n+    assertTrue(checkApp, \"Failed to access WebLogic application on domain1\");\n+\n+    checkConsole = checkAppUsingHostHeader(consoleUrl, domainNamespace2 + \".org\");\n+    assertTrue(checkConsole, \"Failed to access domain2 WebLogic console\");\n+    logger.info(\"WebLogic console on domain2 is acceesible\");\n+    result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n+        String.valueOf(istioIngressPort),\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n+        clusterName, archivePath, domainNamespace2 + \".org\");\n+    assertNotNull(result, \"Application deployment on domain2 failed\");\n+    logger.info(\"Application deployment on domain2 returned {0}\", result.toString());\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not returns HTTP status code 202\");", "originalCommit": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzNjYzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448036635", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-30T23:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NzM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5MTE5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r447991193", "bodyText": "should there be one more argument to the method - app name testwebapp ?", "author": "vanajamukkara", "createdAt": "2020-06-30T21:31:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DeployUtil.java", "diffHunk": "@@ -310,4 +309,46 @@ public static ExecResult deployUsingRest(String host, String port,\n     return result;\n   }\n \n+  /**\n+   * Deploy application using REST API with curl utility.\n+   * @param host name of the admin server host\n+   * @param port node port of admin server\n+   * @param userName admin server user name\n+   * @param password admin server password\n+   * @param cluster name of the cluster to deploy application\n+   * @param archivePath local path of the application archive\n+   * @param hostHeader name of the cluster to deploy application\n+   * @return ExecResult \n+   */\n+  public static ExecResult deployUsingRest(String host, String port,\n+            String userName, String password, String cluster, \n+            Path archivePath, String hostHeader) {\n+    final LoggingFacade logger = getLogger();\n+    ExecResult result = null;\n+    StringBuffer curlString = new StringBuffer(\"status=$(curl --noproxy '*' \");\n+    curlString.append(\" --user \" + userName + \":\" + password);\n+    curlString.append(\" -w %{http_code} --show-error -o /dev/null \")\n+        .append(\"-H 'host: \" + hostHeader  + \"' \")\n+        .append(\"-H X-Requested-By:MyClient \")\n+        .append(\"-H Accept:application/json  \")\n+        .append(\"-H Content-Type:multipart/form-data \")\n+        .append(\"-H Prefer:respond-async \")\n+        .append(\"-F \\\"model={ name: 'testwebapp', targets: [ { identity: [ clusters, '\")", "originalCommit": "39dbb01c25b1562f2ab9b97bd0cc9e9642a6a2b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUxOTM2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448519363", "bodyText": "Added a new parameter for the Application Name", "author": "anpanigr", "createdAt": "2020-07-01T17:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5MTE5Mw=="}], "type": "inlineReview"}, {"oid": "b61265b0f91124b07f8e62bed028f6da99518752", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b61265b0f91124b07f8e62bed028f6da99518752", "message": "addressed review comments", "committedDate": "2020-06-30T23:46:59Z", "type": "commit"}, {"oid": "3e2628fa62ccee05261b79fc027439c08e683684", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3e2628fa62ccee05261b79fc027439c08e683684", "message": "Added support for parallel run; one istio install/unistall per run", "committedDate": "2020-07-01T03:04:33Z", "type": "commit"}, {"oid": "3635ff7e16f62166152001af4c459e2ec1eab8b9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3635ff7e16f62166152001af4c459e2ec1eab8b9", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into istio-twodoms", "committedDate": "2020-07-01T03:04:55Z", "type": "commit"}, {"oid": "ab83b1b800e01fe45e0c3d1c34777f0e8b99dd8e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ab83b1b800e01fe45e0c3d1c34777f0e8b99dd8e", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into istio-twodoms", "committedDate": "2020-07-01T16:16:14Z", "type": "commit"}, {"oid": "050b8ea0763aa1281d700ec2de250f18cf0de668", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/050b8ea0763aa1281d700ec2de250f18cf0de668", "message": "Updated utility to make the http hostHeader optional, add new parameter for app name during rest deploy", "committedDate": "2020-07-01T17:39:58Z", "type": "commit"}, {"oid": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fbf834576fd097d133ef8403d0ab4ae9a3a9e18d", "message": "Minot javadoc change", "committedDate": "2020-07-01T19:22:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMTI4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448611289", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertEquals(\"202\", result.stdout(), \"Deployment does not return HTTP status code 202\");\n          \n          \n            \n                assertEquals(\"202\", result.stdout(), \"Deployment didn't return HTTP status code 202\");", "author": "sankarpn", "createdAt": "2020-07-01T20:55:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -216,33 +213,26 @@ public void testIstioDomainHomeInImageUsingWdt() {\n     int istioIngressPort = getIstioHttpIngressPort();\n     logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n \n-    logger.info(\"Validating WebLogic admin server access by login to console\");\n-    boolean loginSuccessful = assertDoesNotThrow(() -> {\n-      return adminNodePortAccessible(istioIngressPort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n-    }, \"Access to admin server node port failed\");\n-    assertTrue(loginSuccessful, \"Console login validation failed\");\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console\");\n+    logger.info(\"WebLogic console is accessible\");\n \n     Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n     ExecResult result = null;\n     result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n         String.valueOf(istioIngressPort),\n         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n-        clusterName, archivePath);\n+        clusterName, archivePath, domainNamespace + \".org\", \"testwebapp\");\n     assertNotNull(result, \"Application deployment failed\");\n     logger.info(\"Application deployment returned {0}\", result.toString());\n-    assertEquals(\"202\", result.stdout(), \"Application deployed successfully\");\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not return HTTP status code 202\");", "originalCommit": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzMDQ2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448630463", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-07-01T21:40:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMTI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMTc5MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448611791", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertTrue(checkApp, \"Failed to access WebLogic appliation\");\n          \n          \n            \n                assertTrue(checkApp, \"Failed to access WebLogic application\");", "author": "sankarpn", "createdAt": "2020-07-01T20:56:10Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -216,33 +213,26 @@ public void testIstioDomainHomeInImageUsingWdt() {\n     int istioIngressPort = getIstioHttpIngressPort();\n     logger.info(\"Istio Ingress Port is {0}\", istioIngressPort);\n \n-    logger.info(\"Validating WebLogic admin server access by login to console\");\n-    boolean loginSuccessful = assertDoesNotThrow(() -> {\n-      return adminNodePortAccessible(istioIngressPort, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n-    }, \"Access to admin server node port failed\");\n-    assertTrue(loginSuccessful, \"Console login validation failed\");\n+    String consoleUrl = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/console/login/LoginForm.jsp\";\n+    boolean checkConsole = \n+         checkAppUsingHostHeader(consoleUrl, domainNamespace + \".org\");\n+    assertTrue(checkConsole, \"Failed to access WebLogic console\");\n+    logger.info(\"WebLogic console is accessible\");\n \n     Path archivePath = Paths.get(ITTESTS_DIR, \"../src/integration-tests/apps/testwebapp.war\");\n     ExecResult result = null;\n     result = DeployUtil.deployUsingRest(K8S_NODEPORT_HOST, \n         String.valueOf(istioIngressPort),\n         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT, \n-        clusterName, archivePath);\n+        clusterName, archivePath, domainNamespace + \".org\", \"testwebapp\");\n     assertNotNull(result, \"Application deployment failed\");\n     logger.info(\"Application deployment returned {0}\", result.toString());\n-    assertEquals(\"202\", result.stdout(), \"Application deployed successfully\");\n+    assertEquals(\"202\", result.stdout(), \"Deployment does not return HTTP status code 202\");\n+\n     String url = \"http://\" + K8S_NODEPORT_HOST + \":\" + istioIngressPort + \"/testwebapp/index.jsp\";\n     logger.info(\"Application Access URL {0}\", url);\n-\n-    try {\n-      Thread.sleep(5 * 1000);\n-    } catch (InterruptedException ie) {\n-      //    \n-    }\n-    assertEquals(200,\n-        assertDoesNotThrow(() -> OracleHttpClient.get(url, true),\n-            \"Accessing sample application on admin server failed\")\n-            .statusCode(), \"Status code not equals to 200\");\n+    boolean checkApp = checkAppUsingHostHeader(url, domainNamespace + \".org\");\n+    assertTrue(checkApp, \"Failed to access WebLogic appliation\");", "originalCommit": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzMDQxMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448630411", "bodyText": "Done", "author": "anpanigr", "createdAt": "2020-07-01T21:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMTc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMjE5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448612197", "bodyText": "Update DisplayName description", "author": "sankarpn", "createdAt": "2020-07-01T20:56:59Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")", "originalCommit": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzMDM2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448630366", "bodyText": "modified\n@DisplayName(\"Test to create two WebLogic domains in domainhome-in-image model with istio configuration\")", "author": "anpanigr", "createdAt": "2020-07-01T21:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMjE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMjYxNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448612616", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                logger.info(\"Creating unique namespace for Operator\");\n          \n          \n            \n                logger.info(\"Assigning unique namespace for Operator\");", "author": "sankarpn", "createdAt": "2020-07-01T20:57:57Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");", "originalCommit": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMjc3NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448612775", "bodyText": "same for below lines", "author": "sankarpn", "createdAt": "2020-07-01T20:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMjYxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzMTI4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448631284", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-07-01T21:41:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMjYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMzMyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448613327", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n          \n          \n            \n                logger.info(\"Namespaces [{0}, {1}, {2}] labeled with istio-injection:enabled\",opNamespace, domainNamespace1, domainNamespace2);", "author": "sankarpn", "createdAt": "2020-07-01T20:59:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);", "originalCommit": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzMjA1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448632056", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-07-01T21:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMzMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNTA5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448615094", "bodyText": "These tests can be run in parallel, is there a reason why it shouldn't be?", "author": "sankarpn", "createdAt": "2020-07-01T21:03:48Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify server pods are in ready state and services are created\n+   * Verify login to WebLogic console on domain1 through istio ingress http \n+   * port by passing host information in HTTP header.\n+   * Deploy a web application to domain1 through istio ingress http port \n+   * using host information in HTTP header. \n+   * Access web application through istio http ingress port using host \n+   * information in HTTP header.\n+   * Repeat the same steps for domain2.\n+   */\n+  @Test\n+  @DisplayName(\"Two WebLogic domainhome-in-image with single istio ingress\")\n+  @Slow\n+  @MustNotRunInParallel", "originalCommit": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzMjU5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448632596", "bodyText": "Remove the tag @MustNotRunInParallel", "author": "anpanigr", "createdAt": "2020-07-01T21:45:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNTA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjAxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448616019", "bodyText": "The podReady and serviceExists should be done in this order.\n\ncheck admin service exists\ncheck admin pod ready\ncheck ms service exists\ncheck ms pod ready", "author": "sankarpn", "createdAt": "2020-07-01T21:06:03Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioTwoDomainsInImage.java", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkAppUsingHostHeader;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")\n+@IntegrationTest\n+class ItIstioTwoDomainsInImage {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace1 = null;\n+  private static String domainNamespace2 = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private final String clusterName = \"cluster-1\"; // do not modify \n+  private final String adminServerName = \"admin-server\"; // do not modify\n+  private final String domainUid1 = \"istio-dii-wdt-1\";\n+  private final String domainUid2 = \"istio-dii-wdt-2\";\n+  private final String adminServerPodName1 = domainUid1 + \"-\" + adminServerName;\n+  private final String adminServerPodName2 = domainUid2 + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace1 = namespaces.get(1);\n+\n+    logger.info(\"Creating unique namespace for Domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domainNamespace2 = namespaces.get(2);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace1,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace2,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    logger.info(\"Namespaces [{0}, {1}, {2}] Labeled \",opNamespace, domainNamespace1, domainNamespace2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace1,domainNamespace2);\n+  }\n+\n+  /**\n+   * Create two domains using domainhome-in-image model.\n+   * Add istio configuration with default readinessPort. \n+   * Deploy istio gateway and virtual service on each domain namespaces.\n+   * Add host information to gateway and virtual service configurations.\n+   * Put the namespace.org as host configuration \n+   * Verify server pods are in ready state and services are created\n+   * Verify login to WebLogic console on domain1 through istio ingress http \n+   * port by passing host information in HTTP header.\n+   * Deploy a web application to domain1 through istio ingress http port \n+   * using host information in HTTP header. \n+   * Access web application through istio http ingress port using host \n+   * information in HTTP header.\n+   * Repeat the same steps for domain2.\n+   */\n+  @Test\n+  @DisplayName(\"Two WebLogic domainhome-in-image with single istio ingress\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioTwoDomainsWithSingleIngress() {\n+    final String managedServerPrefix1 = domainUid1 + \"-managed-server\";\n+    final String managedServerPrefix2 = domainUid2 + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace1);\n+    createDockerRegistrySecret(domainNamespace2);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName1 = \"weblogic-credentials-1\";\n+    createSecretWithUsernamePassword(adminSecretName1, domainNamespace1, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    String adminSecretName2 = \"weblogic-credentials-2\";\n+    createSecretWithUsernamePassword(adminSecretName2, domainNamespace2, \n+         ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR(s)\n+    createDomainResource(domainUid1, domainNamespace1, adminSecretName1, REPO_SECRET_NAME,\n+        replicaCount);\n+    createDomainResource(domainUid2, domainNamespace2, adminSecretName2, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace1);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid1,\n+                domainNamespace1,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid1, DOMAIN_VERSION, domainNamespace1));\n+\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace2);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid2,\n+                domainNamespace2,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid2, DOMAIN_VERSION, domainNamespace2));\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkPodReady(adminServerPodName1, domainUid1, domainNamespace1);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkPodReady(adminServerPodName2, domainUid2, domainNamespace2);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkPodReady(managedServerPrefix1 + i, domainUid1, domainNamespace1);\n+      logger.info(\"Wait for managed pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkPodReady(managedServerPrefix2 + i, domainUid2, domainNamespace2);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName1, domainNamespace1);\n+    checkServiceExists(adminServerPodName1, domainNamespace1);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName2, domainNamespace2);\n+    checkServiceExists(adminServerPodName2, domainNamespace2);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix1 + i, domainNamespace1);\n+      checkServiceExists(managedServerPrefix1 + i, domainNamespace1);\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix2 + i, domainNamespace2);\n+      checkServiceExists(managedServerPrefix2 + i, domainNamespace2);", "originalCommit": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzNTQxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448635417", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-07-01T21:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYyMDU2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448620568", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Check the WebLogic application using host information in the header.\n          \n          \n            \n               * Check the application running in WebLogic server using host information in the header.", "author": "sankarpn", "createdAt": "2020-07-01T21:16:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -1821,12 +1822,51 @@ public static Path generateFileFromTemplate(\n   }\n \n   /**\n-  * Create a persistent volume.\n+   * Check the WebLogic application using host information in the header.", "originalCommit": "fbf834576fd097d133ef8403d0ab4ae9a3a9e18d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzODk2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1778#discussion_r448638969", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-07-01T22:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYyMDU2OA=="}], "type": "inlineReview"}, {"oid": "de470b6f59af2693fe05bb51fb958a192f43663b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/de470b6f59af2693fe05bb51fb958a192f43663b", "message": "Addressed more review comments", "committedDate": "2020-07-01T22:17:34Z", "type": "commit"}]}