{"pr_number": 1655, "pr_title": "convert ItUsabilityOperatorHelmChart to JUnit5", "pr_createdAt": "2020-05-16T05:59:15Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655", "timeline": [{"oid": "b3b625772e549a57874a143cf621e760d1eef107", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b3b625772e549a57874a143cf621e760d1eef107", "message": "convert ItUsabilityOperatorHelmChart to JUnit5", "committedDate": "2020-05-16T05:47:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwNzY5MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426207691", "bodyText": "does this assume all the clusters use the same port?", "author": "markxnelson", "createdAt": "2020-05-17T01:49:03Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItScaleMiiDomainNginx.java", "diffHunk": "@@ -163,82 +103,116 @@ public static void initAll(@Namespaces(3) List<String> namespaces) {\n     // get a unique NGINX namespace\n     logger.info(\"Get a unique namespace for NGINX\");\n     assertNotNull(namespaces.get(2), \"Namespace list is null\");\n-    nginxNamespace = namespaces.get(2);\n+    String nginxNamespace = namespaces.get(2);\n \n     // install and verify operator\n-    installAndVerifyOperator();\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n \n     // get a free node port for NGINX\n     nodeportshttp = getNextFreePort(30305, 30405);\n-    nodeportshttps = getNextFreePort(30443, 30543);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n \n     // install and verify NGINX\n-    installAndVerifyNginx();\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+\n+    // create model in image domain with multiple clusters\n+    createMiiDomainWithMultiClusters();\n+\n+    // create ingress using host based routing\n+    List<String> clusterNames = new ArrayList<>();\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      clusterNames.add(CLUSTER_NAME_PREFIX + i);\n+    }\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, domainNamespace);\n+    ingressHostList = createIngressForDomainAndVerify(domainUid, domainNamespace, MANAGED_SERVER_PORT, clusterNames);", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDU2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426274563", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwNzY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwNzc0MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426207741", "bodyText": "seems like this cannot be run in parallel with the previous test - we don't anyway, so just a note", "author": "markxnelson", "createdAt": "2020-05-17T01:50:05Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItScaleMiiDomainNginx.java", "diffHunk": "@@ -163,82 +103,116 @@ public static void initAll(@Namespaces(3) List<String> namespaces) {\n     // get a unique NGINX namespace\n     logger.info(\"Get a unique namespace for NGINX\");\n     assertNotNull(namespaces.get(2), \"Namespace list is null\");\n-    nginxNamespace = namespaces.get(2);\n+    String nginxNamespace = namespaces.get(2);\n \n     // install and verify operator\n-    installAndVerifyOperator();\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n \n     // get a free node port for NGINX\n     nodeportshttp = getNextFreePort(30305, 30405);\n-    nodeportshttps = getNextFreePort(30443, 30543);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n \n     // install and verify NGINX\n-    installAndVerifyNginx();\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+\n+    // create model in image domain with multiple clusters\n+    createMiiDomainWithMultiClusters();\n+\n+    // create ingress using host based routing\n+    List<String> clusterNames = new ArrayList<>();\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      clusterNames.add(CLUSTER_NAME_PREFIX + i);\n+    }\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, domainNamespace);\n+    ingressHostList = createIngressForDomainAndVerify(domainUid, domainNamespace, MANAGED_SERVER_PORT, clusterNames);\n   }\n \n   @Test\n-  @Order(1)\n-  @DisplayName(\"Create model in image domain with multiple clusters\")\n-  @Slow\n-  @MustNotRunInParallel\n-  public void testCreateMiiDomainWithMultiClusters() {\n+  @DisplayName(\"Verify the application can be accessed through NGINX for each cluster in the domain\")\n+  public void testAppAccessThroughIngressController() {\n \n-    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n-    final String adminServerPodName = domainUid + \"-admin-server\";\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n \n-    // create image with model files\n-    logger.info(\"Creating image with model file and verify\");\n-    String miiImage = createImageAndVerify();\n+      List<String> managedServerListBeforeScale =\n+          listManagedServersBeforeScale(clusterName, replicaCount);\n \n-    // docker login, if necessary\n-    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n-      logger.info(\"docker login\");\n-      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+      // check that NGINX can access the sample apps from all managed servers in the cluster of the domain\n+      curlCmd = generateCurlCmd(clusterName);\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, managedServerListBeforeScale, 50))\n+          .as(\"Verify NGINX can access the sample app from all managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n     }\n+  }\n+\n+  @Test", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwNzgwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426207801", "bodyText": "too magical, just write a simple if statement and assign the value (1 or 3) instead of this calculation. think of the person who will come and read this after you and wonder why you did this.", "author": "markxnelson", "createdAt": "2020-05-17T01:50:56Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItScaleMiiDomainNginx.java", "diffHunk": "@@ -163,82 +103,116 @@ public static void initAll(@Namespaces(3) List<String> namespaces) {\n     // get a unique NGINX namespace\n     logger.info(\"Get a unique namespace for NGINX\");\n     assertNotNull(namespaces.get(2), \"Namespace list is null\");\n-    nginxNamespace = namespaces.get(2);\n+    String nginxNamespace = namespaces.get(2);\n \n     // install and verify operator\n-    installAndVerifyOperator();\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n \n     // get a free node port for NGINX\n     nodeportshttp = getNextFreePort(30305, 30405);\n-    nodeportshttps = getNextFreePort(30443, 30543);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n \n     // install and verify NGINX\n-    installAndVerifyNginx();\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+\n+    // create model in image domain with multiple clusters\n+    createMiiDomainWithMultiClusters();\n+\n+    // create ingress using host based routing\n+    List<String> clusterNames = new ArrayList<>();\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      clusterNames.add(CLUSTER_NAME_PREFIX + i);\n+    }\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, domainNamespace);\n+    ingressHostList = createIngressForDomainAndVerify(domainUid, domainNamespace, MANAGED_SERVER_PORT, clusterNames);\n   }\n \n   @Test\n-  @Order(1)\n-  @DisplayName(\"Create model in image domain with multiple clusters\")\n-  @Slow\n-  @MustNotRunInParallel\n-  public void testCreateMiiDomainWithMultiClusters() {\n+  @DisplayName(\"Verify the application can be accessed through NGINX for each cluster in the domain\")\n+  public void testAppAccessThroughIngressController() {\n \n-    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n-    final String adminServerPodName = domainUid + \"-admin-server\";\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n \n-    // create image with model files\n-    logger.info(\"Creating image with model file and verify\");\n-    String miiImage = createImageAndVerify();\n+      List<String> managedServerListBeforeScale =\n+          listManagedServersBeforeScale(clusterName, replicaCount);\n \n-    // docker login, if necessary\n-    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n-      logger.info(\"docker login\");\n-      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+      // check that NGINX can access the sample apps from all managed servers in the cluster of the domain\n+      curlCmd = generateCurlCmd(clusterName);\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, managedServerListBeforeScale, 50))\n+          .as(\"Verify NGINX can access the sample app from all managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n     }\n+  }\n+\n+  @Test\n+  @DisplayName(\"Verify scale each cluster of the domain in domain namespace\")\n+  public void testScaleClusters() {\n+\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n \n-    // push image, if necessary\n-    if (!REPO_NAME.isEmpty()) {\n-      logger.info(\"docker push image {0} to {1}\", miiImage, REPO_NAME);\n-      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      int numberOfServers = 2 * i - 1;", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDU4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426274582", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:36:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwNzgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODAxMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208012", "bodyText": "why not just get the value you need in the for loop, so you don't need this extra call?", "author": "markxnelson", "createdAt": "2020-05-17T01:55:05Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItScaleMiiDomainNginx.java", "diffHunk": "@@ -814,8 +307,16 @@ private void scaleAndVerifyCluster(String clusterName,\n    * @return curl command string\n    */\n   private String generateCurlCmd(String clusterName) {\n+    int index = 0;\n+    for (int i = 0; i < ingressHostList.size(); i++) {\n+      if (ingressHostList.get(i).contains(clusterName)) {\n+        index = i;\n+        break;\n+      }\n+    }\n+\n     return String.format(\"curl --silent --show-error --noproxy '*' -H 'host: %s' http://%s:%s/sample-war/index.jsp\",\n-        domainUid + \".\" + clusterName + \".test\", K8S_NODEPORT_HOST, nodeportshttp);\n+        ingressHostList.get(index), K8S_NODEPORT_HOST, nodeportshttp);", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDYwNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426274607", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODI0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208249", "bodyText": "pods\ntimestamps", "author": "markxnelson", "createdAt": "2020-05-17T01:58:46Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -0,0 +1,352 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_SERVICE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.checkPodCreated;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.checkPodDeleted;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.checkServiceCreated;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.checkServiceDeleted;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Simple JUnit test file used for testing operator usability.\n+ * Use Helm chart to install operator(s)\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator usability using Helm chart installation\")\n+@IntegrationTest\n+class ItUsabilityOperatorHelmChart implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+\n+  // domain constants\n+  private final String domainUid = \"domain1\";\n+  private final String clusterName = \"cluster-1\";\n+  private final int managedServerPort = 8001;\n+  private final int replicaCount = 2;\n+  private final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  // ingress host list\n+  private List<String> ingressHostList;\n+\n+  /**\n+   * Get namespaces for operator, domain1 and NGINX.\n+   * Install and verify NGINX.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Getting a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    String nginxNamespace = namespaces.get(2);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    logger.info(\"Installing and verifying NGINX\");\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+  }\n+\n+  /**\n+   * Create operator and verify it is deployed successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Verify NGINX can access the sample app from all managed servers in the domain.\n+   * Delete operator.\n+   * Verify the states of all server pods in the domain were not changed.\n+   * Verify NGINX can access the sample app from all managed servers in the domain after the operator was deleted.\n+   * Test fails if the state of any pod in the domain was changed or NGINX can not access the sample app from\n+   * all managed servers in the absence of operator.\n+   */\n+  @Test\n+  @DisplayName(\"Create operator and domain, then delete operator and verify the domain is still running\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testDeleteOperatorButNotDomain() {\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    createAndVerifyMiiDomain();\n+\n+    // get the admin server pod original creation timestamp\n+    logger.info(\"Getting admin server pod original creation timestamp\");\n+    String adminPodOriginalTimestamp =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"getPodCreationTimestamp failed with ApiException for pod %s in namespace %s\",\n+                adminServerPodName, domainNamespace));\n+\n+    // get the managed server pod original creation timestamp", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDYyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426274621", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODI5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208295", "bodyText": "do you need a wait in here?", "author": "markxnelson", "createdAt": "2020-05-17T01:59:46Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItUsabilityOperatorHelmChart.java", "diffHunk": "@@ -0,0 +1,352 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_SERVICE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WLS_DOMAIN_TYPE;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.checkPodCreated;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.checkPodDeleted;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.checkServiceCreated;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.checkServiceDeleted;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Simple JUnit test file used for testing operator usability.\n+ * Use Helm chart to install operator(s)\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test operator usability using Helm chart installation\")\n+@IntegrationTest\n+class ItUsabilityOperatorHelmChart implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+\n+  // domain constants\n+  private final String domainUid = \"domain1\";\n+  private final String clusterName = \"cluster-1\";\n+  private final int managedServerPort = 8001;\n+  private final int replicaCount = 2;\n+  private final String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+  private final String managedServerPrefix = domainUid + \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+  // ingress host list\n+  private List<String> ingressHostList;\n+\n+  /**\n+   * Get namespaces for operator, domain1 and NGINX.\n+   * Install and verify NGINX.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+\n+    // get a unique operator namespace\n+    logger.info(\"Getting a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Getting a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Getting a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    String nginxNamespace = namespaces.get(2);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    logger.info(\"Installing and verifying NGINX\");\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+  }\n+\n+  /**\n+   * Create operator and verify it is deployed successfully.\n+   * Create a custom domain resource and verify all server pods in the domain were created and ready.\n+   * Verify NGINX can access the sample app from all managed servers in the domain.\n+   * Delete operator.\n+   * Verify the states of all server pods in the domain were not changed.\n+   * Verify NGINX can access the sample app from all managed servers in the domain after the operator was deleted.\n+   * Test fails if the state of any pod in the domain was changed or NGINX can not access the sample app from\n+   * all managed servers in the absence of operator.\n+   */\n+  @Test\n+  @DisplayName(\"Create operator and domain, then delete operator and verify the domain is still running\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testDeleteOperatorButNotDomain() {\n+    // install and verify operator\n+    logger.info(\"Installing and verifying operator\");\n+    HelmParams opHelmParams = installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // create and verify the domain\n+    logger.info(\"Creating and verifying model in image domain\");\n+    createAndVerifyMiiDomain();\n+\n+    // get the admin server pod original creation timestamp\n+    logger.info(\"Getting admin server pod original creation timestamp\");\n+    String adminPodOriginalTimestamp =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"getPodCreationTimestamp failed with ApiException for pod %s in namespace %s\",\n+                adminServerPodName, domainNamespace));\n+\n+    // get the managed server pod original creation timestamp\n+    logger.info(\"Getting managed server pods original creation timestamp\");\n+    List<String> managedServerPodOriginalTimestampList = new ArrayList<>();\n+    for (int i = 1; i <= replicaCount; i++) {\n+      final String managedServerPodName = managedServerPrefix + i;\n+      managedServerPodOriginalTimestampList.add(\n+          assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", managedServerPodName),\n+              String.format(\"getPodCreationTimestamp failed with ApiException for pod %s in namespace %s\",\n+                  managedServerPodName, domainNamespace)));\n+    }\n+\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domainUid, domainNamespace);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domainUid, domainNamespace, managedServerPort, Arrays.asList(clusterName));\n+\n+    // verify the sample apps for the domain\n+    logger.info(\"Checking that the sample app can be accessed from all managed servers through NGINX\");\n+    verifySampleAppAccessThroughNginx();\n+\n+    // delete operator\n+    logger.info(\"Uninstalling operator\");\n+    uninstallOperator(opHelmParams);\n+\n+    // verify the operator pod was deleted\n+    logger.info(\"Checking that operator pod was deleted\");\n+    checkPodDeleted(\"weblogic-operator-\", null, opNamespace);\n+\n+    // verify the operator service was deleted\n+    logger.info(\"Checking that operator service was deleted\");\n+    checkServiceDeleted(OPERATOR_SERVICE_NAME, opNamespace);\n+\n+    // check that the state of admin server pod in the domain was not changed", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3MzA1OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426273058", "bodyText": "Yes, we should add some wait time here. How long should we wait here? Maybe the operator usual response time for a domain? Any ideas?", "author": "xiancao", "createdAt": "2020-05-17T15:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI4NDkzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426284935", "bodyText": "if the operator is gone, then maybe just 10-15 seconds is ok i think -- @rjeberhard ?", "author": "markxnelson", "createdAt": "2020-05-17T17:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODQxMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208411", "bodyText": "curious - did you change this to satisfy checkstyle rules?", "author": "markxnelson", "createdAt": "2020-05-17T02:01:52Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -140,16 +127,23 @@\n    * @param label       a Map of key value pairs the service is decorated with\n    * @param namespace   in which the service is running\n    * @return true if the service exists otherwise false\n-   * @throws ApiException when query fails\n    */\n-  public static Callable<Boolean> serviceExists(\n-      String serviceName,\n-      Map<String, String> label,\n-      String namespace\n-  ) throws ApiException {\n-    return () -> {\n-      return Kubernetes.doesServiceExist(serviceName, label, namespace);\n-    };\n+  public static Callable<Boolean> serviceExists(String serviceName, Map<String, String> label, String namespace) {", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDc3Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426274773", "bodyText": "yes", "author": "xiancao", "createdAt": "2020-05-17T15:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODQ1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208459", "bodyText": "was anybody else using this?", "author": "markxnelson", "createdAt": "2020-05-17T02:02:43Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -94,62 +90,44 @@ public static boolean adminNodePortAccessible(String domainUid, String namespace\n   }\n \n   /**\n-   * Verify the original managed server pod state is not changed during scaling the cluster.\n-   * @param podName the name of the managed server pod to check\n-   * @param domainUid the domain uid of the domain in which the managed server pod exists\n+   * Verify the pod state is not changed.\n+   * @param podName the name of the pod to check\n+   * @param domainUid the domain in which the pod exists\n    * @param domainNamespace the domain namespace in which the domain exists\n-   * @param podCreationTimestampBeforeScale the managed server pod creation time stamp before the scale\n-   * @return true if the managed server pod state is not change during scaling the cluster, false otherwise\n+   * @param podOriginalCreationTimestamp the pod original creation timestamp\n+   * @return true if the pod state is not changed, false otherwise\n    */\n-  public static boolean podStateNotChangedDuringScalingCluster(String podName,\n-                                                               String domainUid,\n-                                                               String domainNamespace,\n-                                                               String podCreationTimestampBeforeScale) {\n-\n-    // check that the original managed server pod still exists\n-    logger.info(\"Checking that the managed server pod {0} still exists in namespace {1}\",\n-        podName, domainNamespace);\n-    assertTrue(assertDoesNotThrow(() -> doesPodExist(domainNamespace, domainUid, podName),\n+  public static boolean podStateNotChanged(String podName,", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDgxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426274819", "bodyText": "I think so", "author": "xiancao", "createdAt": "2020-05-17T15:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODQ4Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208487", "bodyText": "maybe call it CommonTestUtils", "author": "markxnelson", "createdAt": "2020-05-17T02:03:23Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDgzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426274834", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODQ5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208498", "bodyText": "is -> to be", "author": "markxnelson", "createdAt": "2020-05-17T02:03:52Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDg5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426274890", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODUwOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208509", "bodyText": "5 -> five", "author": "markxnelson", "createdAt": "2020-05-17T02:04:13Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDg5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426274898", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:39:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODUxNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208516", "bodyText": "5 -> five", "author": "markxnelson", "createdAt": "2020-05-17T02:04:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDkxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426274913", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODYwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208606", "bodyText": "5 -> five", "author": "markxnelson", "createdAt": "2020-05-17T02:05:50Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.\n+   *\n+   * @param nginxNamespace the namespace in which the NGINX will be installed\n+   * @param nodeportshttp the http nodeport of NGINX\n+   * @param nodeportshttps the https nodeport of NGINX\n+   * @return the NGINX Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyNginx(String nginxNamespace,\n+                                                 int nodeportshttp,\n+                                                 int nodeportshttps) {\n+\n+    // Helm install parameters\n+    HelmParams nginxHelmParams = new HelmParams()\n+        .releaseName(NGINX_RELEASE_NAME)\n+        .namespace(nginxNamespace)\n+        .repoUrl(GOOGLE_REPO_URL)\n+        .repoName(STABLE_REPO_NAME)\n+        .chartName(NGINX_CHART_NAME);\n+\n+    // NGINX chart values to override\n+    NginxParams nginxParams = new NginxParams()\n+        .helmParams(nginxHelmParams)\n+        .nodePortsHttp(nodeportshttp)\n+        .nodePortsHttps(nodeportshttps);\n+\n+    // install NGINX\n+    assertThat(installNginx(nginxParams))\n+        .as(\"Test NGINX installation succeeds\")\n+        .withFailMessage(\"NGINX installation is failed\")\n+        .isTrue();\n+\n+    // verify that NGINX is installed\n+    logger.info(\"Checking NGINX release {0} status in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+    assertTrue(isHelmReleaseDeployed(NGINX_RELEASE_NAME, nginxNamespace),\n+        String.format(\"NGINX release %s is not in deployed status in namespace %s\",\n+            NGINX_RELEASE_NAME, nginxNamespace));\n+    logger.info(\"NGINX release {0} status is deployed in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+\n+    // wait until the NGINX pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for NGINX to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                nginxNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isNginxReady(nginxNamespace), \"isNginxReady failed with ApiException\"));\n+\n+    return nginxHelmParams;\n+  }\n+\n+  /**\n+   * Create a domain in the specified namespace and wait up to 5 minutes until the domain exists.", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDkzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426274930", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:40:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODYzMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208633", "bodyText": "you assume all of the clusters have the same listen port", "author": "markxnelson", "createdAt": "2020-05-17T02:06:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.\n+   *\n+   * @param nginxNamespace the namespace in which the NGINX will be installed\n+   * @param nodeportshttp the http nodeport of NGINX\n+   * @param nodeportshttps the https nodeport of NGINX\n+   * @return the NGINX Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyNginx(String nginxNamespace,\n+                                                 int nodeportshttp,\n+                                                 int nodeportshttps) {\n+\n+    // Helm install parameters\n+    HelmParams nginxHelmParams = new HelmParams()\n+        .releaseName(NGINX_RELEASE_NAME)\n+        .namespace(nginxNamespace)\n+        .repoUrl(GOOGLE_REPO_URL)\n+        .repoName(STABLE_REPO_NAME)\n+        .chartName(NGINX_CHART_NAME);\n+\n+    // NGINX chart values to override\n+    NginxParams nginxParams = new NginxParams()\n+        .helmParams(nginxHelmParams)\n+        .nodePortsHttp(nodeportshttp)\n+        .nodePortsHttps(nodeportshttps);\n+\n+    // install NGINX\n+    assertThat(installNginx(nginxParams))\n+        .as(\"Test NGINX installation succeeds\")\n+        .withFailMessage(\"NGINX installation is failed\")\n+        .isTrue();\n+\n+    // verify that NGINX is installed\n+    logger.info(\"Checking NGINX release {0} status in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+    assertTrue(isHelmReleaseDeployed(NGINX_RELEASE_NAME, nginxNamespace),\n+        String.format(\"NGINX release %s is not in deployed status in namespace %s\",\n+            NGINX_RELEASE_NAME, nginxNamespace));\n+    logger.info(\"NGINX release {0} status is deployed in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+\n+    // wait until the NGINX pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for NGINX to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                nginxNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isNginxReady(nginxNamespace), \"isNginxReady failed with ApiException\"));\n+\n+    return nginxHelmParams;\n+  }\n+\n+  /**\n+   * Create a domain in the specified namespace and wait up to 5 minutes until the domain exists.\n+   *\n+   * @param domain the oracle.weblogic.domain.Domain object to create domain custom resource\n+   * @param domainNamespace namespace in which the domain will be created\n+   */\n+  public static void createDomainAndVerify(Domain domain, String domainNamespace) {\n+\n+    // create the domain CR\n+    assertNotNull(domain, \"domain is null\");\n+    assertNotNull(domain.getSpec(), \"domain spec is null\");\n+    String domainUid = domain.getSpec().getDomainUid();\n+\n+    logger.info(\"Creating domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Checking for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create an ingress for the domain with domainUid in the specified namespace.\n+   *\n+   * @param domainUid WebLogic domainUid which is backend to the ingress to be created\n+   * @param domainNamespace WebLogic domain namespace in which the domain exists\n+   * @param managedServerPort port number of WebLogic domain managed servers\n+   * @param clusterNames list of the WebLogic domain cluster names in the domain\n+   * @return list of ingress hosts\n+   */\n+  public static List<String> createIngressForDomainAndVerify(String domainUid,\n+                                                             String domainNamespace,\n+                                                             int managedServerPort,\n+                                                             List<String> clusterNames) {", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NTI5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426275297", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODYzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208638", "bodyText": "was", "author": "markxnelson", "createdAt": "2020-05-17T02:06:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.\n+   *\n+   * @param nginxNamespace the namespace in which the NGINX will be installed\n+   * @param nodeportshttp the http nodeport of NGINX\n+   * @param nodeportshttps the https nodeport of NGINX\n+   * @return the NGINX Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyNginx(String nginxNamespace,\n+                                                 int nodeportshttp,\n+                                                 int nodeportshttps) {\n+\n+    // Helm install parameters\n+    HelmParams nginxHelmParams = new HelmParams()\n+        .releaseName(NGINX_RELEASE_NAME)\n+        .namespace(nginxNamespace)\n+        .repoUrl(GOOGLE_REPO_URL)\n+        .repoName(STABLE_REPO_NAME)\n+        .chartName(NGINX_CHART_NAME);\n+\n+    // NGINX chart values to override\n+    NginxParams nginxParams = new NginxParams()\n+        .helmParams(nginxHelmParams)\n+        .nodePortsHttp(nodeportshttp)\n+        .nodePortsHttps(nodeportshttps);\n+\n+    // install NGINX\n+    assertThat(installNginx(nginxParams))\n+        .as(\"Test NGINX installation succeeds\")\n+        .withFailMessage(\"NGINX installation is failed\")\n+        .isTrue();\n+\n+    // verify that NGINX is installed\n+    logger.info(\"Checking NGINX release {0} status in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+    assertTrue(isHelmReleaseDeployed(NGINX_RELEASE_NAME, nginxNamespace),\n+        String.format(\"NGINX release %s is not in deployed status in namespace %s\",\n+            NGINX_RELEASE_NAME, nginxNamespace));\n+    logger.info(\"NGINX release {0} status is deployed in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+\n+    // wait until the NGINX pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for NGINX to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                nginxNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isNginxReady(nginxNamespace), \"isNginxReady failed with ApiException\"));\n+\n+    return nginxHelmParams;\n+  }\n+\n+  /**\n+   * Create a domain in the specified namespace and wait up to 5 minutes until the domain exists.\n+   *\n+   * @param domain the oracle.weblogic.domain.Domain object to create domain custom resource\n+   * @param domainNamespace namespace in which the domain will be created\n+   */\n+  public static void createDomainAndVerify(Domain domain, String domainNamespace) {\n+\n+    // create the domain CR\n+    assertNotNull(domain, \"domain is null\");\n+    assertNotNull(domain.getSpec(), \"domain spec is null\");\n+    String domainUid = domain.getSpec().getDomainUid();\n+\n+    logger.info(\"Creating domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Checking for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create an ingress for the domain with domainUid in the specified namespace.\n+   *\n+   * @param domainUid WebLogic domainUid which is backend to the ingress to be created\n+   * @param domainNamespace WebLogic domain namespace in which the domain exists\n+   * @param managedServerPort port number of WebLogic domain managed servers\n+   * @param clusterNames list of the WebLogic domain cluster names in the domain\n+   * @return list of ingress hosts\n+   */\n+  public static List<String> createIngressForDomainAndVerify(String domainUid,\n+                                                             String domainNamespace,\n+                                                             int managedServerPort,\n+                                                             List<String> clusterNames) {\n+\n+    // create an ingress in domain namespace\n+    String ingressName = domainUid + \"-nginx\";\n+    List<String> ingressHostList =\n+        createIngress(ingressName, domainNamespace, domainUid, managedServerPort, clusterNames);\n+\n+    assertNotNull(ingressHostList,\n+        String.format(\"Ingress creation failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+\n+    // check the ingress was found in the domain namespace\n+    assertThat(assertDoesNotThrow(() -> listIngresses(domainNamespace)))\n+        .as(\"Test ingress {0} was found in namespace {1}\", ingressName, domainNamespace)\n+        .withFailMessage(\"Ingress {0} was not found in namespace {1}\", ingressName, domainNamespace)\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress {0} for domain {1} was created in namespace {2}\",\n+        ingressName, domainUid, domainNamespace);\n+\n+    return ingressHostList;\n+  }\n+\n+  /**\n+   * Check pod is created.", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODY2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208662", "bodyText": "and you are not really checking it was created, you are checking it exists, which is not exactly the same thing", "author": "markxnelson", "createdAt": "2020-05-17T02:07:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NTMyOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426275328", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODY3OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208678", "bodyText": "pods do not exist in domains", "author": "markxnelson", "createdAt": "2020-05-17T02:07:25Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.\n+   *\n+   * @param nginxNamespace the namespace in which the NGINX will be installed\n+   * @param nodeportshttp the http nodeport of NGINX\n+   * @param nodeportshttps the https nodeport of NGINX\n+   * @return the NGINX Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyNginx(String nginxNamespace,\n+                                                 int nodeportshttp,\n+                                                 int nodeportshttps) {\n+\n+    // Helm install parameters\n+    HelmParams nginxHelmParams = new HelmParams()\n+        .releaseName(NGINX_RELEASE_NAME)\n+        .namespace(nginxNamespace)\n+        .repoUrl(GOOGLE_REPO_URL)\n+        .repoName(STABLE_REPO_NAME)\n+        .chartName(NGINX_CHART_NAME);\n+\n+    // NGINX chart values to override\n+    NginxParams nginxParams = new NginxParams()\n+        .helmParams(nginxHelmParams)\n+        .nodePortsHttp(nodeportshttp)\n+        .nodePortsHttps(nodeportshttps);\n+\n+    // install NGINX\n+    assertThat(installNginx(nginxParams))\n+        .as(\"Test NGINX installation succeeds\")\n+        .withFailMessage(\"NGINX installation is failed\")\n+        .isTrue();\n+\n+    // verify that NGINX is installed\n+    logger.info(\"Checking NGINX release {0} status in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+    assertTrue(isHelmReleaseDeployed(NGINX_RELEASE_NAME, nginxNamespace),\n+        String.format(\"NGINX release %s is not in deployed status in namespace %s\",\n+            NGINX_RELEASE_NAME, nginxNamespace));\n+    logger.info(\"NGINX release {0} status is deployed in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+\n+    // wait until the NGINX pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for NGINX to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                nginxNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isNginxReady(nginxNamespace), \"isNginxReady failed with ApiException\"));\n+\n+    return nginxHelmParams;\n+  }\n+\n+  /**\n+   * Create a domain in the specified namespace and wait up to 5 minutes until the domain exists.\n+   *\n+   * @param domain the oracle.weblogic.domain.Domain object to create domain custom resource\n+   * @param domainNamespace namespace in which the domain will be created\n+   */\n+  public static void createDomainAndVerify(Domain domain, String domainNamespace) {\n+\n+    // create the domain CR\n+    assertNotNull(domain, \"domain is null\");\n+    assertNotNull(domain.getSpec(), \"domain spec is null\");\n+    String domainUid = domain.getSpec().getDomainUid();\n+\n+    logger.info(\"Creating domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Checking for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create an ingress for the domain with domainUid in the specified namespace.\n+   *\n+   * @param domainUid WebLogic domainUid which is backend to the ingress to be created\n+   * @param domainNamespace WebLogic domain namespace in which the domain exists\n+   * @param managedServerPort port number of WebLogic domain managed servers\n+   * @param clusterNames list of the WebLogic domain cluster names in the domain\n+   * @return list of ingress hosts\n+   */\n+  public static List<String> createIngressForDomainAndVerify(String domainUid,\n+                                                             String domainNamespace,\n+                                                             int managedServerPort,\n+                                                             List<String> clusterNames) {\n+\n+    // create an ingress in domain namespace\n+    String ingressName = domainUid + \"-nginx\";\n+    List<String> ingressHostList =\n+        createIngress(ingressName, domainNamespace, domainUid, managedServerPort, clusterNames);\n+\n+    assertNotNull(ingressHostList,\n+        String.format(\"Ingress creation failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+\n+    // check the ingress was found in the domain namespace\n+    assertThat(assertDoesNotThrow(() -> listIngresses(domainNamespace)))\n+        .as(\"Test ingress {0} was found in namespace {1}\", ingressName, domainNamespace)\n+        .withFailMessage(\"Ingress {0} was not found in namespace {1}\", ingressName, domainNamespace)\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress {0} for domain {1} was created in namespace {2}\",\n+        ingressName, domainUid, domainNamespace);\n+\n+    return ingressHostList;\n+  }\n+\n+  /**\n+   * Check pod is created.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodCreated(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podExists(podName, domainUid, domainNamespace),\n+            String.format(\"podExists failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod is ready.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NTM2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426275363", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODcxNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208715", "bodyText": "services do not exist in domain namespaces", "author": "markxnelson", "createdAt": "2020-05-17T02:07:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.\n+   *\n+   * @param nginxNamespace the namespace in which the NGINX will be installed\n+   * @param nodeportshttp the http nodeport of NGINX\n+   * @param nodeportshttps the https nodeport of NGINX\n+   * @return the NGINX Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyNginx(String nginxNamespace,\n+                                                 int nodeportshttp,\n+                                                 int nodeportshttps) {\n+\n+    // Helm install parameters\n+    HelmParams nginxHelmParams = new HelmParams()\n+        .releaseName(NGINX_RELEASE_NAME)\n+        .namespace(nginxNamespace)\n+        .repoUrl(GOOGLE_REPO_URL)\n+        .repoName(STABLE_REPO_NAME)\n+        .chartName(NGINX_CHART_NAME);\n+\n+    // NGINX chart values to override\n+    NginxParams nginxParams = new NginxParams()\n+        .helmParams(nginxHelmParams)\n+        .nodePortsHttp(nodeportshttp)\n+        .nodePortsHttps(nodeportshttps);\n+\n+    // install NGINX\n+    assertThat(installNginx(nginxParams))\n+        .as(\"Test NGINX installation succeeds\")\n+        .withFailMessage(\"NGINX installation is failed\")\n+        .isTrue();\n+\n+    // verify that NGINX is installed\n+    logger.info(\"Checking NGINX release {0} status in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+    assertTrue(isHelmReleaseDeployed(NGINX_RELEASE_NAME, nginxNamespace),\n+        String.format(\"NGINX release %s is not in deployed status in namespace %s\",\n+            NGINX_RELEASE_NAME, nginxNamespace));\n+    logger.info(\"NGINX release {0} status is deployed in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+\n+    // wait until the NGINX pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for NGINX to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                nginxNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isNginxReady(nginxNamespace), \"isNginxReady failed with ApiException\"));\n+\n+    return nginxHelmParams;\n+  }\n+\n+  /**\n+   * Create a domain in the specified namespace and wait up to 5 minutes until the domain exists.\n+   *\n+   * @param domain the oracle.weblogic.domain.Domain object to create domain custom resource\n+   * @param domainNamespace namespace in which the domain will be created\n+   */\n+  public static void createDomainAndVerify(Domain domain, String domainNamespace) {\n+\n+    // create the domain CR\n+    assertNotNull(domain, \"domain is null\");\n+    assertNotNull(domain.getSpec(), \"domain spec is null\");\n+    String domainUid = domain.getSpec().getDomainUid();\n+\n+    logger.info(\"Creating domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Checking for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create an ingress for the domain with domainUid in the specified namespace.\n+   *\n+   * @param domainUid WebLogic domainUid which is backend to the ingress to be created\n+   * @param domainNamespace WebLogic domain namespace in which the domain exists\n+   * @param managedServerPort port number of WebLogic domain managed servers\n+   * @param clusterNames list of the WebLogic domain cluster names in the domain\n+   * @return list of ingress hosts\n+   */\n+  public static List<String> createIngressForDomainAndVerify(String domainUid,\n+                                                             String domainNamespace,\n+                                                             int managedServerPort,\n+                                                             List<String> clusterNames) {\n+\n+    // create an ingress in domain namespace\n+    String ingressName = domainUid + \"-nginx\";\n+    List<String> ingressHostList =\n+        createIngress(ingressName, domainNamespace, domainUid, managedServerPort, clusterNames);\n+\n+    assertNotNull(ingressHostList,\n+        String.format(\"Ingress creation failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+\n+    // check the ingress was found in the domain namespace\n+    assertThat(assertDoesNotThrow(() -> listIngresses(domainNamespace)))\n+        .as(\"Test ingress {0} was found in namespace {1}\", ingressName, domainNamespace)\n+        .withFailMessage(\"Ingress {0} was not found in namespace {1}\", ingressName, domainNamespace)\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress {0} for domain {1} was created in namespace {2}\",\n+        ingressName, domainUid, domainNamespace);\n+\n+    return ingressHostList;\n+  }\n+\n+  /**\n+   * Check pod is created.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodCreated(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podExists(podName, domainUid, domainNamespace),\n+            String.format(\"podExists failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod is ready.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodReady(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podReady(podName, domainUid, domainNamespace),\n+            String.format(\"podReady failed with ApiException for pod %s in namespace %s\",\n+               podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service is created.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the domain namespace in which the service exists", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NTQwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426275403", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODczNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208735", "bodyText": "you are not checking it was deleted, you are just checking it does not exist", "author": "markxnelson", "createdAt": "2020-05-17T02:08:20Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.\n+   *\n+   * @param nginxNamespace the namespace in which the NGINX will be installed\n+   * @param nodeportshttp the http nodeport of NGINX\n+   * @param nodeportshttps the https nodeport of NGINX\n+   * @return the NGINX Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyNginx(String nginxNamespace,\n+                                                 int nodeportshttp,\n+                                                 int nodeportshttps) {\n+\n+    // Helm install parameters\n+    HelmParams nginxHelmParams = new HelmParams()\n+        .releaseName(NGINX_RELEASE_NAME)\n+        .namespace(nginxNamespace)\n+        .repoUrl(GOOGLE_REPO_URL)\n+        .repoName(STABLE_REPO_NAME)\n+        .chartName(NGINX_CHART_NAME);\n+\n+    // NGINX chart values to override\n+    NginxParams nginxParams = new NginxParams()\n+        .helmParams(nginxHelmParams)\n+        .nodePortsHttp(nodeportshttp)\n+        .nodePortsHttps(nodeportshttps);\n+\n+    // install NGINX\n+    assertThat(installNginx(nginxParams))\n+        .as(\"Test NGINX installation succeeds\")\n+        .withFailMessage(\"NGINX installation is failed\")\n+        .isTrue();\n+\n+    // verify that NGINX is installed\n+    logger.info(\"Checking NGINX release {0} status in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+    assertTrue(isHelmReleaseDeployed(NGINX_RELEASE_NAME, nginxNamespace),\n+        String.format(\"NGINX release %s is not in deployed status in namespace %s\",\n+            NGINX_RELEASE_NAME, nginxNamespace));\n+    logger.info(\"NGINX release {0} status is deployed in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+\n+    // wait until the NGINX pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for NGINX to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                nginxNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isNginxReady(nginxNamespace), \"isNginxReady failed with ApiException\"));\n+\n+    return nginxHelmParams;\n+  }\n+\n+  /**\n+   * Create a domain in the specified namespace and wait up to 5 minutes until the domain exists.\n+   *\n+   * @param domain the oracle.weblogic.domain.Domain object to create domain custom resource\n+   * @param domainNamespace namespace in which the domain will be created\n+   */\n+  public static void createDomainAndVerify(Domain domain, String domainNamespace) {\n+\n+    // create the domain CR\n+    assertNotNull(domain, \"domain is null\");\n+    assertNotNull(domain.getSpec(), \"domain spec is null\");\n+    String domainUid = domain.getSpec().getDomainUid();\n+\n+    logger.info(\"Creating domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Checking for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create an ingress for the domain with domainUid in the specified namespace.\n+   *\n+   * @param domainUid WebLogic domainUid which is backend to the ingress to be created\n+   * @param domainNamespace WebLogic domain namespace in which the domain exists\n+   * @param managedServerPort port number of WebLogic domain managed servers\n+   * @param clusterNames list of the WebLogic domain cluster names in the domain\n+   * @return list of ingress hosts\n+   */\n+  public static List<String> createIngressForDomainAndVerify(String domainUid,\n+                                                             String domainNamespace,\n+                                                             int managedServerPort,\n+                                                             List<String> clusterNames) {\n+\n+    // create an ingress in domain namespace\n+    String ingressName = domainUid + \"-nginx\";\n+    List<String> ingressHostList =\n+        createIngress(ingressName, domainNamespace, domainUid, managedServerPort, clusterNames);\n+\n+    assertNotNull(ingressHostList,\n+        String.format(\"Ingress creation failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+\n+    // check the ingress was found in the domain namespace\n+    assertThat(assertDoesNotThrow(() -> listIngresses(domainNamespace)))\n+        .as(\"Test ingress {0} was found in namespace {1}\", ingressName, domainNamespace)\n+        .withFailMessage(\"Ingress {0} was not found in namespace {1}\", ingressName, domainNamespace)\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress {0} for domain {1} was created in namespace {2}\",\n+        ingressName, domainUid, domainNamespace);\n+\n+    return ingressHostList;\n+  }\n+\n+  /**\n+   * Check pod is created.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodCreated(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podExists(podName, domainUid, domainNamespace),\n+            String.format(\"podExists failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod is ready.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodReady(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podReady(podName, domainUid, domainNamespace),\n+            String.format(\"podReady failed with ApiException for pod %s in namespace %s\",\n+               podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service is created.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the domain namespace in which the service exists\n+   */\n+  public static void checkServiceCreated(String serviceName, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domainNamespace),\n+            String.format(\"serviceExists failed with ApiException for service %s in namespace %s\",\n+                serviceName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod was deleted.", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NTQxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426275410", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODczNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208737", "bodyText": "same", "author": "markxnelson", "createdAt": "2020-05-17T02:08:29Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.\n+   *\n+   * @param nginxNamespace the namespace in which the NGINX will be installed\n+   * @param nodeportshttp the http nodeport of NGINX\n+   * @param nodeportshttps the https nodeport of NGINX\n+   * @return the NGINX Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyNginx(String nginxNamespace,\n+                                                 int nodeportshttp,\n+                                                 int nodeportshttps) {\n+\n+    // Helm install parameters\n+    HelmParams nginxHelmParams = new HelmParams()\n+        .releaseName(NGINX_RELEASE_NAME)\n+        .namespace(nginxNamespace)\n+        .repoUrl(GOOGLE_REPO_URL)\n+        .repoName(STABLE_REPO_NAME)\n+        .chartName(NGINX_CHART_NAME);\n+\n+    // NGINX chart values to override\n+    NginxParams nginxParams = new NginxParams()\n+        .helmParams(nginxHelmParams)\n+        .nodePortsHttp(nodeportshttp)\n+        .nodePortsHttps(nodeportshttps);\n+\n+    // install NGINX\n+    assertThat(installNginx(nginxParams))\n+        .as(\"Test NGINX installation succeeds\")\n+        .withFailMessage(\"NGINX installation is failed\")\n+        .isTrue();\n+\n+    // verify that NGINX is installed\n+    logger.info(\"Checking NGINX release {0} status in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+    assertTrue(isHelmReleaseDeployed(NGINX_RELEASE_NAME, nginxNamespace),\n+        String.format(\"NGINX release %s is not in deployed status in namespace %s\",\n+            NGINX_RELEASE_NAME, nginxNamespace));\n+    logger.info(\"NGINX release {0} status is deployed in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+\n+    // wait until the NGINX pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for NGINX to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                nginxNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isNginxReady(nginxNamespace), \"isNginxReady failed with ApiException\"));\n+\n+    return nginxHelmParams;\n+  }\n+\n+  /**\n+   * Create a domain in the specified namespace and wait up to 5 minutes until the domain exists.\n+   *\n+   * @param domain the oracle.weblogic.domain.Domain object to create domain custom resource\n+   * @param domainNamespace namespace in which the domain will be created\n+   */\n+  public static void createDomainAndVerify(Domain domain, String domainNamespace) {\n+\n+    // create the domain CR\n+    assertNotNull(domain, \"domain is null\");\n+    assertNotNull(domain.getSpec(), \"domain spec is null\");\n+    String domainUid = domain.getSpec().getDomainUid();\n+\n+    logger.info(\"Creating domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Checking for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create an ingress for the domain with domainUid in the specified namespace.\n+   *\n+   * @param domainUid WebLogic domainUid which is backend to the ingress to be created\n+   * @param domainNamespace WebLogic domain namespace in which the domain exists\n+   * @param managedServerPort port number of WebLogic domain managed servers\n+   * @param clusterNames list of the WebLogic domain cluster names in the domain\n+   * @return list of ingress hosts\n+   */\n+  public static List<String> createIngressForDomainAndVerify(String domainUid,\n+                                                             String domainNamespace,\n+                                                             int managedServerPort,\n+                                                             List<String> clusterNames) {\n+\n+    // create an ingress in domain namespace\n+    String ingressName = domainUid + \"-nginx\";\n+    List<String> ingressHostList =\n+        createIngress(ingressName, domainNamespace, domainUid, managedServerPort, clusterNames);\n+\n+    assertNotNull(ingressHostList,\n+        String.format(\"Ingress creation failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+\n+    // check the ingress was found in the domain namespace\n+    assertThat(assertDoesNotThrow(() -> listIngresses(domainNamespace)))\n+        .as(\"Test ingress {0} was found in namespace {1}\", ingressName, domainNamespace)\n+        .withFailMessage(\"Ingress {0} was not found in namespace {1}\", ingressName, domainNamespace)\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress {0} for domain {1} was created in namespace {2}\",\n+        ingressName, domainUid, domainNamespace);\n+\n+    return ingressHostList;\n+  }\n+\n+  /**\n+   * Check pod is created.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodCreated(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podExists(podName, domainUid, domainNamespace),\n+            String.format(\"podExists failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod is ready.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodReady(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podReady(podName, domainUid, domainNamespace),\n+            String.format(\"podReady failed with ApiException for pod %s in namespace %s\",\n+               podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service is created.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the domain namespace in which the service exists\n+   */\n+  public static void checkServiceCreated(String serviceName, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domainNamespace),\n+            String.format(\"serviceExists failed with ApiException for service %s in namespace %s\",\n+                serviceName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod was deleted.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain uid in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodDeleted(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, domainUid, domainNamespace),\n+            String.format(\"podDoesNotExist failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service was deleted.", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NTQxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426275419", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:45:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODc1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208756", "bodyText": "... for a model ...", "author": "markxnelson", "createdAt": "2020-05-17T02:09:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.\n+   *\n+   * @param nginxNamespace the namespace in which the NGINX will be installed\n+   * @param nodeportshttp the http nodeport of NGINX\n+   * @param nodeportshttps the https nodeport of NGINX\n+   * @return the NGINX Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyNginx(String nginxNamespace,\n+                                                 int nodeportshttp,\n+                                                 int nodeportshttps) {\n+\n+    // Helm install parameters\n+    HelmParams nginxHelmParams = new HelmParams()\n+        .releaseName(NGINX_RELEASE_NAME)\n+        .namespace(nginxNamespace)\n+        .repoUrl(GOOGLE_REPO_URL)\n+        .repoName(STABLE_REPO_NAME)\n+        .chartName(NGINX_CHART_NAME);\n+\n+    // NGINX chart values to override\n+    NginxParams nginxParams = new NginxParams()\n+        .helmParams(nginxHelmParams)\n+        .nodePortsHttp(nodeportshttp)\n+        .nodePortsHttps(nodeportshttps);\n+\n+    // install NGINX\n+    assertThat(installNginx(nginxParams))\n+        .as(\"Test NGINX installation succeeds\")\n+        .withFailMessage(\"NGINX installation is failed\")\n+        .isTrue();\n+\n+    // verify that NGINX is installed\n+    logger.info(\"Checking NGINX release {0} status in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+    assertTrue(isHelmReleaseDeployed(NGINX_RELEASE_NAME, nginxNamespace),\n+        String.format(\"NGINX release %s is not in deployed status in namespace %s\",\n+            NGINX_RELEASE_NAME, nginxNamespace));\n+    logger.info(\"NGINX release {0} status is deployed in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+\n+    // wait until the NGINX pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for NGINX to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                nginxNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isNginxReady(nginxNamespace), \"isNginxReady failed with ApiException\"));\n+\n+    return nginxHelmParams;\n+  }\n+\n+  /**\n+   * Create a domain in the specified namespace and wait up to 5 minutes until the domain exists.\n+   *\n+   * @param domain the oracle.weblogic.domain.Domain object to create domain custom resource\n+   * @param domainNamespace namespace in which the domain will be created\n+   */\n+  public static void createDomainAndVerify(Domain domain, String domainNamespace) {\n+\n+    // create the domain CR\n+    assertNotNull(domain, \"domain is null\");\n+    assertNotNull(domain.getSpec(), \"domain spec is null\");\n+    String domainUid = domain.getSpec().getDomainUid();\n+\n+    logger.info(\"Creating domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Checking for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create an ingress for the domain with domainUid in the specified namespace.\n+   *\n+   * @param domainUid WebLogic domainUid which is backend to the ingress to be created\n+   * @param domainNamespace WebLogic domain namespace in which the domain exists\n+   * @param managedServerPort port number of WebLogic domain managed servers\n+   * @param clusterNames list of the WebLogic domain cluster names in the domain\n+   * @return list of ingress hosts\n+   */\n+  public static List<String> createIngressForDomainAndVerify(String domainUid,\n+                                                             String domainNamespace,\n+                                                             int managedServerPort,\n+                                                             List<String> clusterNames) {\n+\n+    // create an ingress in domain namespace\n+    String ingressName = domainUid + \"-nginx\";\n+    List<String> ingressHostList =\n+        createIngress(ingressName, domainNamespace, domainUid, managedServerPort, clusterNames);\n+\n+    assertNotNull(ingressHostList,\n+        String.format(\"Ingress creation failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+\n+    // check the ingress was found in the domain namespace\n+    assertThat(assertDoesNotThrow(() -> listIngresses(domainNamespace)))\n+        .as(\"Test ingress {0} was found in namespace {1}\", ingressName, domainNamespace)\n+        .withFailMessage(\"Ingress {0} was not found in namespace {1}\", ingressName, domainNamespace)\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress {0} for domain {1} was created in namespace {2}\",\n+        ingressName, domainUid, domainNamespace);\n+\n+    return ingressHostList;\n+  }\n+\n+  /**\n+   * Check pod is created.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodCreated(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podExists(podName, domainUid, domainNamespace),\n+            String.format(\"podExists failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod is ready.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodReady(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podReady(podName, domainUid, domainNamespace),\n+            String.format(\"podReady failed with ApiException for pod %s in namespace %s\",\n+               podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service is created.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the domain namespace in which the service exists\n+   */\n+  public static void checkServiceCreated(String serviceName, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domainNamespace),\n+            String.format(\"serviceExists failed with ApiException for service %s in namespace %s\",\n+                serviceName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod was deleted.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain uid in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodDeleted(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, domainUid, domainNamespace),\n+            String.format(\"podDoesNotExist failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service was deleted.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the namespace in which to check whether the service was deleted\n+   */\n+  public static void checkServiceDeleted(String serviceName, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceDoesNotExist(serviceName, null, domainNamespace),\n+            String.format(\"serviceDoesNotExist failed with ApiException for service %s in namespace %s\",\n+                serviceName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Create a Docker image for model in image domain.", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NTQyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426275427", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODgyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208827", "bodyText": "you really should be checking the registry name matches the dockerImage arg", "author": "markxnelson", "createdAt": "2020-05-17T02:10:13Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.\n+   *\n+   * @param nginxNamespace the namespace in which the NGINX will be installed\n+   * @param nodeportshttp the http nodeport of NGINX\n+   * @param nodeportshttps the https nodeport of NGINX\n+   * @return the NGINX Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyNginx(String nginxNamespace,\n+                                                 int nodeportshttp,\n+                                                 int nodeportshttps) {\n+\n+    // Helm install parameters\n+    HelmParams nginxHelmParams = new HelmParams()\n+        .releaseName(NGINX_RELEASE_NAME)\n+        .namespace(nginxNamespace)\n+        .repoUrl(GOOGLE_REPO_URL)\n+        .repoName(STABLE_REPO_NAME)\n+        .chartName(NGINX_CHART_NAME);\n+\n+    // NGINX chart values to override\n+    NginxParams nginxParams = new NginxParams()\n+        .helmParams(nginxHelmParams)\n+        .nodePortsHttp(nodeportshttp)\n+        .nodePortsHttps(nodeportshttps);\n+\n+    // install NGINX\n+    assertThat(installNginx(nginxParams))\n+        .as(\"Test NGINX installation succeeds\")\n+        .withFailMessage(\"NGINX installation is failed\")\n+        .isTrue();\n+\n+    // verify that NGINX is installed\n+    logger.info(\"Checking NGINX release {0} status in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+    assertTrue(isHelmReleaseDeployed(NGINX_RELEASE_NAME, nginxNamespace),\n+        String.format(\"NGINX release %s is not in deployed status in namespace %s\",\n+            NGINX_RELEASE_NAME, nginxNamespace));\n+    logger.info(\"NGINX release {0} status is deployed in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+\n+    // wait until the NGINX pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for NGINX to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                nginxNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isNginxReady(nginxNamespace), \"isNginxReady failed with ApiException\"));\n+\n+    return nginxHelmParams;\n+  }\n+\n+  /**\n+   * Create a domain in the specified namespace and wait up to 5 minutes until the domain exists.\n+   *\n+   * @param domain the oracle.weblogic.domain.Domain object to create domain custom resource\n+   * @param domainNamespace namespace in which the domain will be created\n+   */\n+  public static void createDomainAndVerify(Domain domain, String domainNamespace) {\n+\n+    // create the domain CR\n+    assertNotNull(domain, \"domain is null\");\n+    assertNotNull(domain.getSpec(), \"domain spec is null\");\n+    String domainUid = domain.getSpec().getDomainUid();\n+\n+    logger.info(\"Creating domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Checking for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create an ingress for the domain with domainUid in the specified namespace.\n+   *\n+   * @param domainUid WebLogic domainUid which is backend to the ingress to be created\n+   * @param domainNamespace WebLogic domain namespace in which the domain exists\n+   * @param managedServerPort port number of WebLogic domain managed servers\n+   * @param clusterNames list of the WebLogic domain cluster names in the domain\n+   * @return list of ingress hosts\n+   */\n+  public static List<String> createIngressForDomainAndVerify(String domainUid,\n+                                                             String domainNamespace,\n+                                                             int managedServerPort,\n+                                                             List<String> clusterNames) {\n+\n+    // create an ingress in domain namespace\n+    String ingressName = domainUid + \"-nginx\";\n+    List<String> ingressHostList =\n+        createIngress(ingressName, domainNamespace, domainUid, managedServerPort, clusterNames);\n+\n+    assertNotNull(ingressHostList,\n+        String.format(\"Ingress creation failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+\n+    // check the ingress was found in the domain namespace\n+    assertThat(assertDoesNotThrow(() -> listIngresses(domainNamespace)))\n+        .as(\"Test ingress {0} was found in namespace {1}\", ingressName, domainNamespace)\n+        .withFailMessage(\"Ingress {0} was not found in namespace {1}\", ingressName, domainNamespace)\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress {0} for domain {1} was created in namespace {2}\",\n+        ingressName, domainUid, domainNamespace);\n+\n+    return ingressHostList;\n+  }\n+\n+  /**\n+   * Check pod is created.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodCreated(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podExists(podName, domainUid, domainNamespace),\n+            String.format(\"podExists failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod is ready.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodReady(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podReady(podName, domainUid, domainNamespace),\n+            String.format(\"podReady failed with ApiException for pod %s in namespace %s\",\n+               podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service is created.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the domain namespace in which the service exists\n+   */\n+  public static void checkServiceCreated(String serviceName, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domainNamespace),\n+            String.format(\"serviceExists failed with ApiException for service %s in namespace %s\",\n+                serviceName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod was deleted.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain uid in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodDeleted(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, domainUid, domainNamespace),\n+            String.format(\"podDoesNotExist failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service was deleted.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the namespace in which to check whether the service was deleted\n+   */\n+  public static void checkServiceDeleted(String serviceName, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceDoesNotExist(serviceName, null, domainNamespace),\n+            String.format(\"serviceDoesNotExist failed with ApiException for service %s in namespace %s\",\n+                serviceName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Create a Docker image for model in image domain.\n+   *\n+   * @param imageNameBase the base image name used in local or to construct the image name in repository\n+   * @param wdtModelFile the WDT model file used to build the Docker image\n+   * @param appName the sample application name used to build sample app ear file in WDT model file\n+   * @return image name with tag\n+   */\n+  public static  String createMiiImageAndVerify(String imageNameBase,\n+                                                String wdtModelFile,\n+                                                String appName) {\n+\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_NAME + imageNameBase;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + wdtModelFile);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(appName)), String.format(\"Failed to create app archive for %s\", appName));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // For k8s 1.16 support and as of May 6, 2020, we presently need a different JDK for these\n+    // tests and for image tool. This is expected to no longer be necessary once JDK 11.0.8 or\n+    // the next JDK 14 versions are released.\n+    String witJavaHome = System.getenv(\"WIT_JAVA_HOME\");\n+    if (witJavaHome != null) {\n+      env.put(\"JAVA_HOME\", witJavaHome);\n+    }\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Creating image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    // Check image exists using docker images | grep image tag.\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s does not exist\", image));\n+\n+    return image;\n+  }\n+\n+  /**\n+   * Create a Docker registry secret in the specified namespace.\n+   *\n+   * @param namespace the namespace in which the secret will be created\n+   */\n+  public static void createDockerRegistrySecret(String namespace) {\n+\n+    // Create Docker registry secret in the namespace to pull the image from repository\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(namespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace %s\",\n+        REPO_SECRET_NAME, namespace));\n+  }\n+\n+  /**\n+   * Docker login and push the image to Docker registry.\n+   *\n+   * @param dockerImage the Docker image to push to registry\n+   */\n+  public static void dockerLoginAndPushImageToRegistry(String dockerImage) {\n+    // docker login, if necessary\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NTQ2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426275460", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODg3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208870", "bodyText": "don't start a sentence with \"And\"", "author": "markxnelson", "createdAt": "2020-05-17T02:10:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.\n+   *\n+   * @param nginxNamespace the namespace in which the NGINX will be installed\n+   * @param nodeportshttp the http nodeport of NGINX\n+   * @param nodeportshttps the https nodeport of NGINX\n+   * @return the NGINX Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyNginx(String nginxNamespace,\n+                                                 int nodeportshttp,\n+                                                 int nodeportshttps) {\n+\n+    // Helm install parameters\n+    HelmParams nginxHelmParams = new HelmParams()\n+        .releaseName(NGINX_RELEASE_NAME)\n+        .namespace(nginxNamespace)\n+        .repoUrl(GOOGLE_REPO_URL)\n+        .repoName(STABLE_REPO_NAME)\n+        .chartName(NGINX_CHART_NAME);\n+\n+    // NGINX chart values to override\n+    NginxParams nginxParams = new NginxParams()\n+        .helmParams(nginxHelmParams)\n+        .nodePortsHttp(nodeportshttp)\n+        .nodePortsHttps(nodeportshttps);\n+\n+    // install NGINX\n+    assertThat(installNginx(nginxParams))\n+        .as(\"Test NGINX installation succeeds\")\n+        .withFailMessage(\"NGINX installation is failed\")\n+        .isTrue();\n+\n+    // verify that NGINX is installed\n+    logger.info(\"Checking NGINX release {0} status in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+    assertTrue(isHelmReleaseDeployed(NGINX_RELEASE_NAME, nginxNamespace),\n+        String.format(\"NGINX release %s is not in deployed status in namespace %s\",\n+            NGINX_RELEASE_NAME, nginxNamespace));\n+    logger.info(\"NGINX release {0} status is deployed in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+\n+    // wait until the NGINX pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for NGINX to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                nginxNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isNginxReady(nginxNamespace), \"isNginxReady failed with ApiException\"));\n+\n+    return nginxHelmParams;\n+  }\n+\n+  /**\n+   * Create a domain in the specified namespace and wait up to 5 minutes until the domain exists.\n+   *\n+   * @param domain the oracle.weblogic.domain.Domain object to create domain custom resource\n+   * @param domainNamespace namespace in which the domain will be created\n+   */\n+  public static void createDomainAndVerify(Domain domain, String domainNamespace) {\n+\n+    // create the domain CR\n+    assertNotNull(domain, \"domain is null\");\n+    assertNotNull(domain.getSpec(), \"domain spec is null\");\n+    String domainUid = domain.getSpec().getDomainUid();\n+\n+    logger.info(\"Creating domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Checking for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create an ingress for the domain with domainUid in the specified namespace.\n+   *\n+   * @param domainUid WebLogic domainUid which is backend to the ingress to be created\n+   * @param domainNamespace WebLogic domain namespace in which the domain exists\n+   * @param managedServerPort port number of WebLogic domain managed servers\n+   * @param clusterNames list of the WebLogic domain cluster names in the domain\n+   * @return list of ingress hosts\n+   */\n+  public static List<String> createIngressForDomainAndVerify(String domainUid,\n+                                                             String domainNamespace,\n+                                                             int managedServerPort,\n+                                                             List<String> clusterNames) {\n+\n+    // create an ingress in domain namespace\n+    String ingressName = domainUid + \"-nginx\";\n+    List<String> ingressHostList =\n+        createIngress(ingressName, domainNamespace, domainUid, managedServerPort, clusterNames);\n+\n+    assertNotNull(ingressHostList,\n+        String.format(\"Ingress creation failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+\n+    // check the ingress was found in the domain namespace\n+    assertThat(assertDoesNotThrow(() -> listIngresses(domainNamespace)))\n+        .as(\"Test ingress {0} was found in namespace {1}\", ingressName, domainNamespace)\n+        .withFailMessage(\"Ingress {0} was not found in namespace {1}\", ingressName, domainNamespace)\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress {0} for domain {1} was created in namespace {2}\",\n+        ingressName, domainUid, domainNamespace);\n+\n+    return ingressHostList;\n+  }\n+\n+  /**\n+   * Check pod is created.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodCreated(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podExists(podName, domainUid, domainNamespace),\n+            String.format(\"podExists failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod is ready.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodReady(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podReady(podName, domainUid, domainNamespace),\n+            String.format(\"podReady failed with ApiException for pod %s in namespace %s\",\n+               podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service is created.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the domain namespace in which the service exists\n+   */\n+  public static void checkServiceCreated(String serviceName, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domainNamespace),\n+            String.format(\"serviceExists failed with ApiException for service %s in namespace %s\",\n+                serviceName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod was deleted.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain uid in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodDeleted(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, domainUid, domainNamespace),\n+            String.format(\"podDoesNotExist failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service was deleted.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the namespace in which to check whether the service was deleted\n+   */\n+  public static void checkServiceDeleted(String serviceName, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceDoesNotExist(serviceName, null, domainNamespace),\n+            String.format(\"serviceDoesNotExist failed with ApiException for service %s in namespace %s\",\n+                serviceName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Create a Docker image for model in image domain.\n+   *\n+   * @param imageNameBase the base image name used in local or to construct the image name in repository\n+   * @param wdtModelFile the WDT model file used to build the Docker image\n+   * @param appName the sample application name used to build sample app ear file in WDT model file\n+   * @return image name with tag\n+   */\n+  public static  String createMiiImageAndVerify(String imageNameBase,\n+                                                String wdtModelFile,\n+                                                String appName) {\n+\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_NAME + imageNameBase;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + wdtModelFile);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(appName)), String.format(\"Failed to create app archive for %s\", appName));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // For k8s 1.16 support and as of May 6, 2020, we presently need a different JDK for these\n+    // tests and for image tool. This is expected to no longer be necessary once JDK 11.0.8 or\n+    // the next JDK 14 versions are released.\n+    String witJavaHome = System.getenv(\"WIT_JAVA_HOME\");\n+    if (witJavaHome != null) {\n+      env.put(\"JAVA_HOME\", witJavaHome);\n+    }\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Creating image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    // Check image exists using docker images | grep image tag.\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s does not exist\", image));\n+\n+    return image;\n+  }\n+\n+  /**\n+   * Create a Docker registry secret in the specified namespace.\n+   *\n+   * @param namespace the namespace in which the secret will be created\n+   */\n+  public static void createDockerRegistrySecret(String namespace) {\n+\n+    // Create Docker registry secret in the namespace to pull the image from repository\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(namespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace %s\",\n+        REPO_SECRET_NAME, namespace));\n+  }\n+\n+  /**\n+   * Docker login and push the image to Docker registry.\n+   *\n+   * @param dockerImage the Docker image to push to registry\n+   */\n+  public static void dockerLoginAndPushImageToRegistry(String dockerImage) {\n+    // docker login, if necessary\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+    }\n+\n+    // push image, if necessary\n+    if (!REPO_NAME.isEmpty()) {\n+      logger.info(\"docker push image {0} to {1}\", dockerImage, REPO_NAME);\n+      assertTrue(dockerPush(dockerImage), String.format(\"docker push failed for image %s\", dockerImage));\n+    }\n+  }\n+\n+  /**\n+   * Create a secret with username and password in the specified namespace.\n+   *\n+   * @param secretName secret name to create\n+   * @param namespace namespace in which the secret will be created\n+   * @param username username in the secret\n+   * @param password passowrd in the secret\n+   */\n+  public static void createSecretWithUsernamePassword(String secretName,\n+                                                      String namespace,\n+                                                      String username,\n+                                                      String password) {\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(secretName)\n+            .namespace(namespace))\n+        .stringData(secretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", secretName));\n+  }\n+\n+  /** Scale the WebLogic cluster to specified number of servers.\n+   *  And verify the sample app can be accessed through NGINX.", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NTQ3Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426275473", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODg5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208895", "bodyText": "the namespace in which the domain exists", "author": "markxnelson", "createdAt": "2020-05-17T02:11:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.\n+   *\n+   * @param nginxNamespace the namespace in which the NGINX will be installed\n+   * @param nodeportshttp the http nodeport of NGINX\n+   * @param nodeportshttps the https nodeport of NGINX\n+   * @return the NGINX Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyNginx(String nginxNamespace,\n+                                                 int nodeportshttp,\n+                                                 int nodeportshttps) {\n+\n+    // Helm install parameters\n+    HelmParams nginxHelmParams = new HelmParams()\n+        .releaseName(NGINX_RELEASE_NAME)\n+        .namespace(nginxNamespace)\n+        .repoUrl(GOOGLE_REPO_URL)\n+        .repoName(STABLE_REPO_NAME)\n+        .chartName(NGINX_CHART_NAME);\n+\n+    // NGINX chart values to override\n+    NginxParams nginxParams = new NginxParams()\n+        .helmParams(nginxHelmParams)\n+        .nodePortsHttp(nodeportshttp)\n+        .nodePortsHttps(nodeportshttps);\n+\n+    // install NGINX\n+    assertThat(installNginx(nginxParams))\n+        .as(\"Test NGINX installation succeeds\")\n+        .withFailMessage(\"NGINX installation is failed\")\n+        .isTrue();\n+\n+    // verify that NGINX is installed\n+    logger.info(\"Checking NGINX release {0} status in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+    assertTrue(isHelmReleaseDeployed(NGINX_RELEASE_NAME, nginxNamespace),\n+        String.format(\"NGINX release %s is not in deployed status in namespace %s\",\n+            NGINX_RELEASE_NAME, nginxNamespace));\n+    logger.info(\"NGINX release {0} status is deployed in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+\n+    // wait until the NGINX pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for NGINX to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                nginxNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isNginxReady(nginxNamespace), \"isNginxReady failed with ApiException\"));\n+\n+    return nginxHelmParams;\n+  }\n+\n+  /**\n+   * Create a domain in the specified namespace and wait up to 5 minutes until the domain exists.\n+   *\n+   * @param domain the oracle.weblogic.domain.Domain object to create domain custom resource\n+   * @param domainNamespace namespace in which the domain will be created\n+   */\n+  public static void createDomainAndVerify(Domain domain, String domainNamespace) {\n+\n+    // create the domain CR\n+    assertNotNull(domain, \"domain is null\");\n+    assertNotNull(domain.getSpec(), \"domain spec is null\");\n+    String domainUid = domain.getSpec().getDomainUid();\n+\n+    logger.info(\"Creating domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Checking for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create an ingress for the domain with domainUid in the specified namespace.\n+   *\n+   * @param domainUid WebLogic domainUid which is backend to the ingress to be created\n+   * @param domainNamespace WebLogic domain namespace in which the domain exists\n+   * @param managedServerPort port number of WebLogic domain managed servers\n+   * @param clusterNames list of the WebLogic domain cluster names in the domain\n+   * @return list of ingress hosts\n+   */\n+  public static List<String> createIngressForDomainAndVerify(String domainUid,\n+                                                             String domainNamespace,\n+                                                             int managedServerPort,\n+                                                             List<String> clusterNames) {\n+\n+    // create an ingress in domain namespace\n+    String ingressName = domainUid + \"-nginx\";\n+    List<String> ingressHostList =\n+        createIngress(ingressName, domainNamespace, domainUid, managedServerPort, clusterNames);\n+\n+    assertNotNull(ingressHostList,\n+        String.format(\"Ingress creation failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+\n+    // check the ingress was found in the domain namespace\n+    assertThat(assertDoesNotThrow(() -> listIngresses(domainNamespace)))\n+        .as(\"Test ingress {0} was found in namespace {1}\", ingressName, domainNamespace)\n+        .withFailMessage(\"Ingress {0} was not found in namespace {1}\", ingressName, domainNamespace)\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress {0} for domain {1} was created in namespace {2}\",\n+        ingressName, domainUid, domainNamespace);\n+\n+    return ingressHostList;\n+  }\n+\n+  /**\n+   * Check pod is created.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodCreated(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podExists(podName, domainUid, domainNamespace),\n+            String.format(\"podExists failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod is ready.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodReady(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podReady(podName, domainUid, domainNamespace),\n+            String.format(\"podReady failed with ApiException for pod %s in namespace %s\",\n+               podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service is created.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the domain namespace in which the service exists\n+   */\n+  public static void checkServiceCreated(String serviceName, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domainNamespace),\n+            String.format(\"serviceExists failed with ApiException for service %s in namespace %s\",\n+                serviceName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod was deleted.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain uid in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodDeleted(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, domainUid, domainNamespace),\n+            String.format(\"podDoesNotExist failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service was deleted.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the namespace in which to check whether the service was deleted\n+   */\n+  public static void checkServiceDeleted(String serviceName, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceDoesNotExist(serviceName, null, domainNamespace),\n+            String.format(\"serviceDoesNotExist failed with ApiException for service %s in namespace %s\",\n+                serviceName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Create a Docker image for model in image domain.\n+   *\n+   * @param imageNameBase the base image name used in local or to construct the image name in repository\n+   * @param wdtModelFile the WDT model file used to build the Docker image\n+   * @param appName the sample application name used to build sample app ear file in WDT model file\n+   * @return image name with tag\n+   */\n+  public static  String createMiiImageAndVerify(String imageNameBase,\n+                                                String wdtModelFile,\n+                                                String appName) {\n+\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_NAME + imageNameBase;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + wdtModelFile);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(appName)), String.format(\"Failed to create app archive for %s\", appName));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // For k8s 1.16 support and as of May 6, 2020, we presently need a different JDK for these\n+    // tests and for image tool. This is expected to no longer be necessary once JDK 11.0.8 or\n+    // the next JDK 14 versions are released.\n+    String witJavaHome = System.getenv(\"WIT_JAVA_HOME\");\n+    if (witJavaHome != null) {\n+      env.put(\"JAVA_HOME\", witJavaHome);\n+    }\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Creating image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    // Check image exists using docker images | grep image tag.\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s does not exist\", image));\n+\n+    return image;\n+  }\n+\n+  /**\n+   * Create a Docker registry secret in the specified namespace.\n+   *\n+   * @param namespace the namespace in which the secret will be created\n+   */\n+  public static void createDockerRegistrySecret(String namespace) {\n+\n+    // Create Docker registry secret in the namespace to pull the image from repository\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(namespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace %s\",\n+        REPO_SECRET_NAME, namespace));\n+  }\n+\n+  /**\n+   * Docker login and push the image to Docker registry.\n+   *\n+   * @param dockerImage the Docker image to push to registry\n+   */\n+  public static void dockerLoginAndPushImageToRegistry(String dockerImage) {\n+    // docker login, if necessary\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+    }\n+\n+    // push image, if necessary\n+    if (!REPO_NAME.isEmpty()) {\n+      logger.info(\"docker push image {0} to {1}\", dockerImage, REPO_NAME);\n+      assertTrue(dockerPush(dockerImage), String.format(\"docker push failed for image %s\", dockerImage));\n+    }\n+  }\n+\n+  /**\n+   * Create a secret with username and password in the specified namespace.\n+   *\n+   * @param secretName secret name to create\n+   * @param namespace namespace in which the secret will be created\n+   * @param username username in the secret\n+   * @param password passowrd in the secret\n+   */\n+  public static void createSecretWithUsernamePassword(String secretName,\n+                                                      String namespace,\n+                                                      String username,\n+                                                      String password) {\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(secretName)\n+            .namespace(namespace))\n+        .stringData(secretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", secretName));\n+  }\n+\n+  /** Scale the WebLogic cluster to specified number of servers.\n+   *  And verify the sample app can be accessed through NGINX.\n+   *\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param domainUid the domain to which the cluster belongs\n+   * @param domainNamespace the domain namespace in which the domain exists", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NTQ5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426275493", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODkxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426208914", "bodyText": "include more detail, like you do in the as()", "author": "markxnelson", "createdAt": "2020-05-17T02:11:59Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonUtils.java", "diffHunk": "@@ -0,0 +1,655 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listIngresses;\n+import static oracle.weblogic.kubernetes.actions.TestActions.scaleCluster;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podStateNotChanged;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The common utility class for tests.\n+ */\n+public class CommonUtils {\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Install WebLogic operator and wait up to 5 minutes until the operator pod is ready.\n+   *\n+   * @param opNamespace the operator namespace in which the operator will be installed\n+   * @param domainNamespace the list of the domain namespaces which will be managed by the operator\n+   * @return the operator Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyOperator(String opNamespace,\n+                                                    String... domainNamespace) {\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(new V1ObjectMeta()\n+            .namespace(opNamespace)\n+            .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"operator image name can not be empty\");\n+    logger.info(\"operator image name {0}\", operatorImage);\n+\n+    // Create Docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating Docker registry secret in namespace {0}\", opNamespace);\n+    createDockerRegistrySecret(opNamespace);\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // Helm install parameters\n+    HelmParams opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // operator chart values to override\n+    OperatorParams opParams = new OperatorParams()\n+        .helmParams(opHelmParams)\n+        .image(operatorImage)\n+        .imagePullSecrets(secretNameMap)\n+        .domainNamespaces(Arrays.asList(domainNamespace))\n+        .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Failed to install operator in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list Helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // wait for the operator is ready\n+    logger.info(\"Wait for the operator pod is ready in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> operatorIsReady(opNamespace),\n+            \"operatorIsReady failed with ApiException\"));\n+\n+    return opHelmParams;\n+  }\n+\n+  /**\n+   * Install NGINX and wait up to 5 minutes until the NGINX pod is ready.\n+   *\n+   * @param nginxNamespace the namespace in which the NGINX will be installed\n+   * @param nodeportshttp the http nodeport of NGINX\n+   * @param nodeportshttps the https nodeport of NGINX\n+   * @return the NGINX Helm installation parameters\n+   */\n+  public static HelmParams installAndVerifyNginx(String nginxNamespace,\n+                                                 int nodeportshttp,\n+                                                 int nodeportshttps) {\n+\n+    // Helm install parameters\n+    HelmParams nginxHelmParams = new HelmParams()\n+        .releaseName(NGINX_RELEASE_NAME)\n+        .namespace(nginxNamespace)\n+        .repoUrl(GOOGLE_REPO_URL)\n+        .repoName(STABLE_REPO_NAME)\n+        .chartName(NGINX_CHART_NAME);\n+\n+    // NGINX chart values to override\n+    NginxParams nginxParams = new NginxParams()\n+        .helmParams(nginxHelmParams)\n+        .nodePortsHttp(nodeportshttp)\n+        .nodePortsHttps(nodeportshttps);\n+\n+    // install NGINX\n+    assertThat(installNginx(nginxParams))\n+        .as(\"Test NGINX installation succeeds\")\n+        .withFailMessage(\"NGINX installation is failed\")\n+        .isTrue();\n+\n+    // verify that NGINX is installed\n+    logger.info(\"Checking NGINX release {0} status in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+    assertTrue(isHelmReleaseDeployed(NGINX_RELEASE_NAME, nginxNamespace),\n+        String.format(\"NGINX release %s is not in deployed status in namespace %s\",\n+            NGINX_RELEASE_NAME, nginxNamespace));\n+    logger.info(\"NGINX release {0} status is deployed in namespace {1}\",\n+        NGINX_RELEASE_NAME, nginxNamespace);\n+\n+    // wait until the NGINX pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for NGINX to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                nginxNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isNginxReady(nginxNamespace), \"isNginxReady failed with ApiException\"));\n+\n+    return nginxHelmParams;\n+  }\n+\n+  /**\n+   * Create a domain in the specified namespace and wait up to 5 minutes until the domain exists.\n+   *\n+   * @param domain the oracle.weblogic.domain.Domain object to create domain custom resource\n+   * @param domainNamespace namespace in which the domain will be created\n+   */\n+  public static void createDomainAndVerify(Domain domain, String domainNamespace) {\n+\n+    // create the domain CR\n+    assertNotNull(domain, \"domain is null\");\n+    assertNotNull(domain.getSpec(), \"domain spec is null\");\n+    String domainUid = domain.getSpec().getDomainUid();\n+\n+    logger.info(\"Creating domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Checking for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create an ingress for the domain with domainUid in the specified namespace.\n+   *\n+   * @param domainUid WebLogic domainUid which is backend to the ingress to be created\n+   * @param domainNamespace WebLogic domain namespace in which the domain exists\n+   * @param managedServerPort port number of WebLogic domain managed servers\n+   * @param clusterNames list of the WebLogic domain cluster names in the domain\n+   * @return list of ingress hosts\n+   */\n+  public static List<String> createIngressForDomainAndVerify(String domainUid,\n+                                                             String domainNamespace,\n+                                                             int managedServerPort,\n+                                                             List<String> clusterNames) {\n+\n+    // create an ingress in domain namespace\n+    String ingressName = domainUid + \"-nginx\";\n+    List<String> ingressHostList =\n+        createIngress(ingressName, domainNamespace, domainUid, managedServerPort, clusterNames);\n+\n+    assertNotNull(ingressHostList,\n+        String.format(\"Ingress creation failed for domain %s in namespace %s\", domainUid, domainNamespace));\n+\n+    // check the ingress was found in the domain namespace\n+    assertThat(assertDoesNotThrow(() -> listIngresses(domainNamespace)))\n+        .as(\"Test ingress {0} was found in namespace {1}\", ingressName, domainNamespace)\n+        .withFailMessage(\"Ingress {0} was not found in namespace {1}\", ingressName, domainNamespace)\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress {0} for domain {1} was created in namespace {2}\",\n+        ingressName, domainUid, domainNamespace);\n+\n+    return ingressHostList;\n+  }\n+\n+  /**\n+   * Check pod is created.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodCreated(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podExists(podName, domainUid, domainNamespace),\n+            String.format(\"podExists failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod is ready.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodReady(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podReady(podName, domainUid, domainNamespace),\n+            String.format(\"podReady failed with ApiException for pod %s in namespace %s\",\n+               podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service is created.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the domain namespace in which the service exists\n+   */\n+  public static void checkServiceCreated(String serviceName, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domainNamespace),\n+            String.format(\"serviceExists failed with ApiException for service %s in namespace %s\",\n+                serviceName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check pod was deleted.\n+   *\n+   * @param podName pod name to check\n+   * @param domainUid the domain uid in which the pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   */\n+  public static void checkPodDeleted(String podName, String domainUid, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, domainUid, domainNamespace),\n+            String.format(\"podDoesNotExist failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Check service was deleted.\n+   *\n+   * @param serviceName service name to check\n+   * @param domainNamespace the namespace in which to check whether the service was deleted\n+   */\n+  public static void checkServiceDeleted(String serviceName, String domainNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be deleted in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceDoesNotExist(serviceName, null, domainNamespace),\n+            String.format(\"serviceDoesNotExist failed with ApiException for service %s in namespace %s\",\n+                serviceName, domainNamespace)));\n+  }\n+\n+  /**\n+   * Create a Docker image for model in image domain.\n+   *\n+   * @param imageNameBase the base image name used in local or to construct the image name in repository\n+   * @param wdtModelFile the WDT model file used to build the Docker image\n+   * @param appName the sample application name used to build sample app ear file in WDT model file\n+   * @return image name with tag\n+   */\n+  public static  String createMiiImageAndVerify(String imageNameBase,\n+                                                String wdtModelFile,\n+                                                String appName) {\n+\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_NAME + imageNameBase;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + wdtModelFile);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(appName)), String.format(\"Failed to create app archive for %s\", appName));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // For k8s 1.16 support and as of May 6, 2020, we presently need a different JDK for these\n+    // tests and for image tool. This is expected to no longer be necessary once JDK 11.0.8 or\n+    // the next JDK 14 versions are released.\n+    String witJavaHome = System.getenv(\"WIT_JAVA_HOME\");\n+    if (witJavaHome != null) {\n+      env.put(\"JAVA_HOME\", witJavaHome);\n+    }\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Creating image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    // Check image exists using docker images | grep image tag.\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s does not exist\", image));\n+\n+    return image;\n+  }\n+\n+  /**\n+   * Create a Docker registry secret in the specified namespace.\n+   *\n+   * @param namespace the namespace in which the secret will be created\n+   */\n+  public static void createDockerRegistrySecret(String namespace) {\n+\n+    // Create Docker registry secret in the namespace to pull the image from repository\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(namespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace %s\",\n+        REPO_SECRET_NAME, namespace));\n+  }\n+\n+  /**\n+   * Docker login and push the image to Docker registry.\n+   *\n+   * @param dockerImage the Docker image to push to registry\n+   */\n+  public static void dockerLoginAndPushImageToRegistry(String dockerImage) {\n+    // docker login, if necessary\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+    }\n+\n+    // push image, if necessary\n+    if (!REPO_NAME.isEmpty()) {\n+      logger.info(\"docker push image {0} to {1}\", dockerImage, REPO_NAME);\n+      assertTrue(dockerPush(dockerImage), String.format(\"docker push failed for image %s\", dockerImage));\n+    }\n+  }\n+\n+  /**\n+   * Create a secret with username and password in the specified namespace.\n+   *\n+   * @param secretName secret name to create\n+   * @param namespace namespace in which the secret will be created\n+   * @param username username in the secret\n+   * @param password passowrd in the secret\n+   */\n+  public static void createSecretWithUsernamePassword(String secretName,\n+                                                      String namespace,\n+                                                      String username,\n+                                                      String password) {\n+    Map<String, String> secretMap = new HashMap<>();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(secretName)\n+            .namespace(namespace))\n+        .stringData(secretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", secretName));\n+  }\n+\n+  /** Scale the WebLogic cluster to specified number of servers.\n+   *  And verify the sample app can be accessed through NGINX.\n+   *\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param domainUid the domain to which the cluster belongs\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param replicasAfterScale the replicas of the WebLogic cluster after the scale\n+   * @param curlCmd the curl command to verify ingress controller can access the sample apps from all managed servers\n+   *                in the cluster, if curlCmd is null, the method will not verify the accessibility of the sample app\n+   *                through ingress controller\n+   * @param expectedServerNames list of managed servers in the cluster before scale, if curlCmd is null,\n+   *                            set expectedServerNames to null too\n+   */\n+  public static void scaleAndVerifyCluster(String clusterName,\n+                                           String domainUid,\n+                                           String domainNamespace,\n+                                           int replicasBeforeScale,\n+                                           int replicasAfterScale,\n+                                           String curlCmd,\n+                                           List<String> expectedServerNames) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-\" + MANAGED_SERVER_NAME_BASE;\n+\n+    // get the original managed server pod creation timestamp before scale\n+    List<String> listOfPodCreationTimestamp = new ArrayList<>();\n+    for (int i = 1; i <= replicasBeforeScale; i++) {\n+      String managedServerPodName = manageServerPodNamePrefix + i;\n+      String originalCreationTimestamp =\n+          assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", managedServerPodName),\n+              String.format(\"getPodCreationTimestamp failed with ApiException for pod %s in namespace %s\",\n+                  managedServerPodName, domainNamespace));\n+      listOfPodCreationTimestamp.add(originalCreationTimestamp);\n+    }\n+\n+    // scale the cluster in the domain\n+    logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} to {3} servers\",\n+        clusterName, domainUid, domainNamespace, replicasAfterScale);\n+    assertThat(assertDoesNotThrow(() -> scaleCluster(domainUid, domainNamespace, clusterName, replicasAfterScale)))\n+        .as(\"Verify scaling cluster {0} of domain {1} in namespace {2} succeeds\",\n+            clusterName, domainUid, domainNamespace)\n+        .withFailMessage(\"Scaling cluster failed\")", "originalCommit": "b3b625772e549a57874a143cf621e760d1eef107", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NTUwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1655#discussion_r426275504", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-17T15:46:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODkxNA=="}], "type": "inlineReview"}, {"oid": "475e317cb886076724c0870ac50d5f28e433d183", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/475e317cb886076724c0870ac50d5f28e433d183", "message": "fix with Mark's comments", "committedDate": "2020-05-17T17:04:05Z", "type": "commit"}, {"oid": "3d78e7d0c78e9ee67af5fa47064ed1116f752a30", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3d78e7d0c78e9ee67af5fa47064ed1116f752a30", "message": "Merge branch 'develop' into xc-convert-operator", "committedDate": "2020-05-17T19:36:46Z", "type": "commit"}]}