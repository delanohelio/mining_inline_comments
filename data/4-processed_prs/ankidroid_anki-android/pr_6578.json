{"pr_number": 6578, "pr_title": "Load deck tree before number on start", "pr_createdAt": "2020-06-29T01:38:15Z", "pr_url": "https://github.com/ankidroid/Anki-Android/pull/6578", "timeline": [{"oid": "73531c07b3f1f9b6e2517c906e407ed6d2d1af5f", "url": "https://github.com/ankidroid/Anki-Android/commit/73531c07b3f1f9b6e2517c906e407ed6d2d1af5f", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-06-29T01:55:23Z", "type": "forcePushed"}, {"oid": "d3b7558b9756b551e7e107cb300db40617a123ab", "url": "https://github.com/ankidroid/Anki-Android/commit/d3b7558b9756b551e7e107cb300db40617a123ab", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-06-29T12:54:42Z", "type": "forcePushed"}, {"oid": "ab61cf3927308a27c01181f744272e87b9c331dd", "url": "https://github.com/ankidroid/Anki-Android/commit/ab61cf3927308a27c01181f744272e87b9c331dd", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-06-30T00:35:58Z", "type": "forcePushed"}, {"oid": "cbac69058afa4d9fd232b69ff6820dddaff7c42d", "url": "https://github.com/ankidroid/Anki-Android/commit/cbac69058afa4d9fd232b69ff6820dddaff7c42d", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-06-30T20:16:45Z", "type": "forcePushed"}, {"oid": "f003472f6ad7a799bddbb3bf91b8fa1baf524924", "url": "https://github.com/ankidroid/Anki-Android/commit/f003472f6ad7a799bddbb3bf91b8fa1baf524924", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-07-04T17:20:21Z", "type": "forcePushed"}, {"oid": "49e3c91dd6beb7a8aba1cc0460afa1e843f475df", "url": "https://github.com/ankidroid/Anki-Android/commit/49e3c91dd6beb7a8aba1cc0460afa1e843f475df", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-07-04T20:25:14Z", "type": "forcePushed"}, {"oid": "376fa96d71164326ee8869fa39e315eec3acdaa2", "url": "https://github.com/ankidroid/Anki-Android/commit/376fa96d71164326ee8869fa39e315eec3acdaa2", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-07-05T15:18:22Z", "type": "forcePushed"}, {"oid": "cef56d7752deb3eb3a6e5fdaf0aea3e86f6885a0", "url": "https://github.com/ankidroid/Anki-Android/commit/cef56d7752deb3eb3a6e5fdaf0aea3e86f6885a0", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-07-05T23:45:15Z", "type": "forcePushed"}, {"oid": "0a8ebc951e02eafdaca66ea9139055c8475c4680", "url": "https://github.com/ankidroid/Anki-Android/commit/0a8ebc951e02eafdaca66ea9139055c8475c4680", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-07-24T19:50:54Z", "type": "forcePushed"}, {"oid": "2c368c7e1cd0bbbe995c7869109f47072446701a", "url": "https://github.com/ankidroid/Anki-Android/commit/2c368c7e1cd0bbbe995c7869109f47072446701a", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-08-05T12:36:07Z", "type": "forcePushed"}, {"oid": "6f916914173e629a37299d29e203a08eab5156a0", "url": "https://github.com/ankidroid/Anki-Android/commit/6f916914173e629a37299d29e203a08eab5156a0", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-08-05T16:58:31Z", "type": "forcePushed"}, {"oid": "224113b9e55ed62f1c80b687f022ad8ed03bba5e", "url": "https://github.com/ankidroid/Anki-Android/commit/224113b9e55ed62f1c80b687f022ad8ed03bba5e", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-08-07T21:26:33Z", "type": "forcePushed"}, {"oid": "4c4d8c5fd78bd7fed0212f8b1ef52dcfbb605f37", "url": "https://github.com/ankidroid/Anki-Android/commit/4c4d8c5fd78bd7fed0212f8b1ef52dcfbb605f37", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-08-08T19:13:15Z", "type": "forcePushed"}, {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "url": "https://github.com/ankidroid/Anki-Android/commit/038c805d7ad27694a95f54c0e28d6ec2ca44312a", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-08-13T00:40:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NTQ5OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469795498", "bodyText": "Could you extract this condition (instanceof) to a member on AbstractDeckTreeNode with a reasonable name", "author": "david-allison-1", "createdAt": "2020-08-13T08:46:23Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,7 +2107,21 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_ instanceof DeckDueTreeNode)) {", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NjgyMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469796823", "bodyText": "I don't feel the copy/pasting works well here.\nCombine the two into (deckDueTreeNode_.shouldOpenReviewerOnSelection())", "author": "david-allison-1", "createdAt": "2020-08-13T08:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2OTM1Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470169352", "bodyText": "I'm not convinced it makes the code easier to read, because anyway I'm going to use a cast; so instanceOf makes sens here.\nI am pretty sure I had a good reason not to factorize, but I can't recall it", "author": "Arthur-Milchior", "createdAt": "2020-08-13T18:43:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NTQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NzYyMg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469797622", "bodyText": "@Nullable - and ensure that there are no lint warnings", "author": "david-allison-1", "createdAt": "2020-08-13T08:49:51Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -319,15 +329,23 @@ public int findDeckPosition(long did) {\n     }\n \n \n-    public int getEta() {\n-        return mCol.getSched().eta(new int[]{mNew, mLrn, mRev});\n+    public Integer getEta() {", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzMTY4MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470231680", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-08-13T20:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NzYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NzcwMQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469797701", "bodyText": "Ditto", "author": "david-allison-1", "createdAt": "2020-08-13T08:49:57Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -319,15 +329,23 @@ public int findDeckPosition(long did) {\n     }\n \n \n-    public int getEta() {\n-        return mCol.getSched().eta(new int[]{mNew, mLrn, mRev});\n+    public Integer getEta() {\n+        if (numbersComputed) {\n+            return mCol.getSched().eta(new int[] {mNew, mLrn, mRev});\n+        } else {\n+            return null;\n+        }\n     }\n \n-    public int getDue() {\n-        return mNew + mLrn + mRev;\n+    public Integer getDue() {", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzMTczMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470231733", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-08-13T20:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NzcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTE1Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469799157", "bodyText": "For discussion:\ninstanceof is typically seen as a code smell: https://softwareengineering.stackexchange.com/questions/394856/instanceof-code-smell\nConsider removing this instanceof, and returning 0 (or null, or Optional.none()) from getNewCount on unprocessed nodes", "author": "david-allison-1", "createdAt": "2020-08-13T08:52:15Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -287,9 +294,12 @@ private void processNodes(List<DeckDueTreeNode> nodes) {\n \n             // Add this node's counts to the totals if it's a parent deck\n             if (node.getDepth() == 0) {\n-                mNew += node.getNewCount();\n-                mLrn += node.getLrnCount();\n-                mRev += node.getRevCount();\n+                if (node instanceof DeckDueTreeNode) {", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3NTM5Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470175396", "bodyText": "I'm really surprised. Because my first implementation returned 0 when no number were known and you told me to avoid to do that.\nAgreed, I displayed the 0's to the user, which was not a good idea. Having a method returning an arbitrary value seems less a problem. But still, I don't like the idea of returning a wrong value. Nor checking every returned value when it's easy to know in advance whether we will get relevant values", "author": "Arthur-Milchior", "createdAt": "2020-08-13T18:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwNTgwMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470205800", "bodyText": "I should note that, if at some point we merge #6573 then the top level will also be a tree node, and so we won't need to consider it as a special case in deck adapter. I still believe it would made the code cleaner, but that would not improve computation time so it's not my priority", "author": "Arthur-Milchior", "createdAt": "2020-08-13T19:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwOTU1OQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470209559", "bodyText": "Actually displaying 0 is a bad idea, returning 0 could be fine as long as there's other state to say \"don't display this\". There's also the consideration that you don't need to recurse if values are unavailable.", "author": "david-allison-1", "createdAt": "2020-08-13T19:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTg2Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469799866", "bodyText": "How are partial values guarded against? If some subdecks have counts, and others haven't been processed, is this displayed, should it be, and does it mattter?", "author": "david-allison-1", "createdAt": "2020-08-13T08:53:32Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -267,8 +274,8 @@ private void setDeckExpander(ImageButton expander, ImageButton indent, DeckDueTr\n     }\n \n \n-    private void processNodes(List<DeckDueTreeNode> nodes) {\n-        for (DeckDueTreeNode node : nodes) {\n+    private void processNodes(List<AbstractDeckTreeNode> nodes) {", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MzY0NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470173644", "bodyText": "I protected it as well as I could given java type. That is, DeckDueTreeNode is an AbstracDeckTreeNode<DeckDueTreeNode> which means that each children of DeckDueTreeNode are DeckDueTreeNode and similarly for DeckTreeNode.\nI agree that this is far from perfect and we could do error really easily, the typing is a small protection here.", "author": "Arthur-Milchior", "createdAt": "2020-08-13T18:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDIyNA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469800224", "bodyText": "node.shouldDisplayCounts, and avoid the instanceof", "author": "david-allison-1", "createdAt": "2020-08-13T08:54:08Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -213,12 +217,15 @@ public void onBindViewHolder(ViewHolder holder, int position) {\n         }\n \n         // Set the card counts and their colors\n-        holder.deckNew.setText(String.valueOf(node.getNewCount()));\n-        holder.deckNew.setTextColor((node.getNewCount() == 0) ? mZeroCountColor : mNewCountColor);\n-        holder.deckLearn.setText(String.valueOf(node.getLrnCount()));\n-        holder.deckLearn.setTextColor((node.getLrnCount() == 0) ? mZeroCountColor : mLearnCountColor);\n-        holder.deckRev.setText(String.valueOf(node.getRevCount()));\n-        holder.deckRev.setTextColor((node.getRevCount() == 0) ? mZeroCountColor : mReviewCountColor);\n+        if (node instanceof DeckDueTreeNode) {", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MjE2Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470172163", "bodyText": "As above, since I need a cast anyway, I'm confused by the fact that you want to remove an instanceOf", "author": "Arthur-Milchior", "createdAt": "2020-08-13T18:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDUxOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469800519", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean numbersComputed;\n          \n          \n            \n                private boolean mNumbersComputed;", "author": "david-allison-1", "createdAt": "2020-08-13T08:54:36Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -71,6 +73,7 @@\n     private int mNew;\n     private int mLrn;\n     private int mRev;\n+    private boolean numbersComputed;", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MTQwNg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470171406", "bodyText": "Thanks", "author": "Arthur-Milchior", "createdAt": "2020-08-13T18:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDg5MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469800891", "bodyText": "maybe rename to LOAD_DECK_QUICK", "author": "david-allison-1", "createdAt": "2020-08-13T08:55:12Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2193,6 +2211,11 @@ private void scrollDecklistToDeck(long did) {\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n+        CollectionTask.TASK_TYPE task_type = (quick) ? LOAD_DECK : LOAD_DECK_COUNTS;", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MDU5Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470170592", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-08-13T18:45:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMTU3NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469801574", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Timber.e(e, \"doInBackgroundLoadDeckCounts - error\");\n          \n          \n            \n                        Timber.w(e, \"doInBackgroundLoadDeckCounts - error\");", "author": "david-allison-1", "createdAt": "2020-08-13T08:56:21Z", "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "diffHunk": "@@ -593,6 +597,20 @@ private TaskData doInBackgroundAnswerCard(TaskData param) {\n     }\n \n \n+    private TaskData doInBackgroundLoadDeck() {\n+        Timber.d(\"doInBackgroundLoadDeckCounts\");\n+        Collection col = CollectionHelper.getInstance().getCol(mContext);\n+        try {\n+            // Get due tree\n+            Object[] o = new Object[] {col.getSched().quickDeckDueTree()};\n+            return new TaskData(o);\n+        } catch (RuntimeException e) {\n+            Timber.e(e, \"doInBackgroundLoadDeckCounts - error\");", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjA0Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469802047", "bodyText": "\ud83d\udc4d null is handled correctly", "author": "david-allison-1", "createdAt": "2020-08-13T08:57:06Z", "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "diffHunk": "@@ -593,6 +597,20 @@ private TaskData doInBackgroundAnswerCard(TaskData param) {\n     }\n \n \n+    private TaskData doInBackgroundLoadDeck() {\n+        Timber.d(\"doInBackgroundLoadDeckCounts\");\n+        Collection col = CollectionHelper.getInstance().getCol(mContext);\n+        try {\n+            // Get due tree\n+            Object[] o = new Object[] {col.getSched().quickDeckDueTree()};\n+            return new TaskData(o);\n+        } catch (RuntimeException e) {\n+            Timber.e(e, \"doInBackgroundLoadDeckCounts - error\");\n+            return null;", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjQyOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469802429", "bodyText": "can be simplified by an Integer.compareTo(x, y)", "author": "david-allison-1", "createdAt": "2020-08-13T08:57:43Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MDE5NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470180194", "bodyText": "Done in https://github.com/ankidroid/Anki-Android/pull/6890/files", "author": "Arthur-Milchior", "createdAt": "2020-08-13T18:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjg1OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469802858", "bodyText": "Needs better internationalisation", "author": "david-allison-1", "createdAt": "2020-08-13T08:58:29Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MDcyOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470180729", "bodyText": "I should note that this is only used in Timber. Timber prints recursively the deck and its subdeck, and so I wanted to have a general method to get the timbered line for this specific deck without dealing with recursion.\nSo in this case, I don't believe we actually want to internationalize. Instead we want to write in comment what I just wrote", "author": "Arthur-Milchior", "createdAt": "2020-08-13T19:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwODQ3NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470208475", "bodyText": "Yeah - that's fine - a comment that it's only used in Timber would be useful", "author": "david-allison-1", "createdAt": "2020-08-13T19:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzMDQ0Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470230447", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-08-13T20:31:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMzQ4Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469803487", "bodyText": "This throws when mChildren is null", "author": "david-allison-1", "createdAt": "2020-08-13T08:59:35Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MjI3Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470182273", "bodyText": "Thanks", "author": "Arthur-Milchior", "createdAt": "2020-08-13T19:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMzQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMzgzNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469803837", "bodyText": "I think this needs a null check on mChildren. mChildren is null and tree is non-null would crash", "author": "david-allison-1", "createdAt": "2020-08-13T09:00:10Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (!(object instanceof AbstractDeckTreeNode)) {\n+            return false;\n+        }\n+        AbstractDeckTreeNode tree = (AbstractDeckTreeNode) object;\n+        return Decks.equalName(getFullDeckName(), tree.getFullDeckName()) &&", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4NDMwOA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470184308", "bodyText": "Thanks", "author": "Arthur-Milchior", "createdAt": "2020-08-13T19:07:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMzgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDI5NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469804294", "bodyText": "No null checks for object", "author": "david-allison-1", "createdAt": "2020-08-13T09:00:57Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (!(object instanceof AbstractDeckTreeNode)) {", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MzUxNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470183517", "bodyText": "Thanks", "author": "Arthur-Milchior", "createdAt": "2020-08-13T19:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDgzMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469804833", "bodyText": "Revert this file - spacing changes", "author": "david-allison-1", "createdAt": "2020-08-13T09:01:54Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedTest.java", "diffHunk": "@@ -128,9 +128,9 @@ private void markNextCardAsGood(Sched sched) {\n \n     @NonNull\n     private DeckDueTreeNode getCountsForDid(double didToFind) {\n-        List<DeckDueTreeNode> tree = getCol().getSched().deckDueTree();\n+        List<DeckDueTreeNode> tree =  getCol().getSched().deckDueTree();", "originalCommit": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4NDYyNg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470184626", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-08-13T19:08:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDgzMw=="}], "type": "inlineReview"}, {"oid": "954500b41fe4e29244ccadd4781683db650f5865", "url": "https://github.com/ankidroid/Anki-Android/commit/954500b41fe4e29244ccadd4781683db650f5865", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-08-13T19:07:58Z", "type": "forcePushed"}, {"oid": "00318d15652b978fa18a213cd0d2598459ee2aa3", "url": "https://github.com/ankidroid/Anki-Android/commit/00318d15652b978fa18a213cd0d2598459ee2aa3", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-08-13T19:08:45Z", "type": "forcePushed"}, {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce", "url": "https://github.com/ankidroid/Anki-Android/commit/397e5d1af888b4a2c9469a5f408243c77b0d2fce", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-08-13T20:31:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNTk1Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470235957", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!(deckDueTreeNode_.shouldDisplayCounts())) {\n          \n          \n            \n                    if (!deckDueTreeNode_.shouldDisplayCounts()) {", "author": "david-allison-1", "createdAt": "2020-08-13T20:42:27Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,17 +2118,19 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_.shouldDisplayCounts())) {", "originalCommit": "397e5d1af888b4a2c9469a5f408243c77b0d2fce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MDI1OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470250258", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-08-13T21:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNzE4NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470237185", "bodyText": "Nicer already!\nCould be even nicer if you performed (!shouldDisplayCounts() || .hasNoPendingReps())", "author": "david-allison-1", "createdAt": "2020-08-13T20:44:38Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,17 +2118,19 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_.shouldDisplayCounts())) {", "originalCommit": "397e5d1af888b4a2c9469a5f408243c77b0d2fce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NTIzNA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470275234", "bodyText": "Ok", "author": "Arthur-Milchior", "createdAt": "2020-08-13T22:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNzE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNzQ0NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470237445", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CollectionTask.TASK_TYPE task_type = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;\n          \n          \n            \n                    CollectionTask.TASK_TYPE taskType = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "author": "david-allison-1", "createdAt": "2020-08-13T20:45:00Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2193,6 +2210,11 @@ private void scrollDecklistToDeck(long did) {\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n+        CollectionTask.TASK_TYPE task_type = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "originalCommit": "397e5d1af888b4a2c9469a5f408243c77b0d2fce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MDYzMg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470250632", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-08-13T21:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNzQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzODA1Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470238053", "bodyText": "Would be better to use polymorphism here so we don't need to cast. I know there's a discussion below.", "author": "david-allison-1", "createdAt": "2020-08-13T20:46:07Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -213,12 +219,15 @@ public void onBindViewHolder(ViewHolder holder, int position) {\n         }\n \n         // Set the card counts and their colors\n-        holder.deckNew.setText(String.valueOf(node.getNewCount()));\n-        holder.deckNew.setTextColor((node.getNewCount() == 0) ? mZeroCountColor : mNewCountColor);\n-        holder.deckLearn.setText(String.valueOf(node.getLrnCount()));\n-        holder.deckLearn.setTextColor((node.getLrnCount() == 0) ? mZeroCountColor : mLearnCountColor);\n-        holder.deckRev.setText(String.valueOf(node.getRevCount()));\n-        holder.deckRev.setTextColor((node.getRevCount() == 0) ? mZeroCountColor : mReviewCountColor);\n+        if (node.shouldDisplayCounts()) {\n+            DeckDueTreeNode node_ = (DeckDueTreeNode) node;", "originalCommit": "397e5d1af888b4a2c9469a5f408243c77b0d2fce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzODY0Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470238647", "bodyText": "It would be better to stop processing straight away if shouldDisplayCounts is false - it means that children also have no counts.\nMaybe alias the name to canCalculateCounts for better semantic meaning here", "author": "david-allison-1", "createdAt": "2020-08-13T20:47:09Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -287,9 +296,12 @@ private void processNodes(List<DeckDueTreeNode> nodes) {\n \n             // Add this node's counts to the totals if it's a parent deck\n             if (node.getDepth() == 0) {", "originalCommit": "397e5d1af888b4a2c9469a5f408243c77b0d2fce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MzU5Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470273597", "bodyText": "processNodes is in charge of transforming the tree of deck into the list shown in DeckPicker. I believe that you do not want to stop the process even if there is no count.", "author": "Arthur-Milchior", "createdAt": "2020-08-13T22:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzODY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzOTIxNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470239215", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int childrenHash;\n          \n          \n            \n                    int childrenHash = mChildren == null ? 0 : mChildren.hashCode();", "author": "david-allison-1", "createdAt": "2020-08-13T20:48:15Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        return Integer.compare(getDepth(), rhs.getDepth());\n+    }\n+\n+    /** Line representing this string without its children. Used in timbers only. */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash;", "originalCommit": "397e5d1af888b4a2c9469a5f408243c77b0d2fce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzOTU1MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470239551", "bodyText": "ditto", "author": "david-allison-1", "createdAt": "2020-08-13T20:48:49Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/DeckDueTreeNode.java", "diffHunk": "@@ -182,7 +82,13 @@ public void setChildren(@NonNull List<DeckDueTreeNode> children, boolean addRev)\n \n     @Override\n     public int hashCode() {\n-        int childrenHash = mChildren.hashCode();\n+        int childrenHash;\n+        @Nullable List<DeckDueTreeNode> children = getChildren();", "originalCommit": "397e5d1af888b4a2c9469a5f408243c77b0d2fce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f52db65a9e18836551684be887d0944ab20c0590", "url": "https://github.com/ankidroid/Anki-Android/commit/f52db65a9e18836551684be887d0944ab20c0590", "message": "NF: knownToHaveCount", "committedDate": "2020-08-13T22:06:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzNTM1Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r471035352", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void shouldOpenReviewerOnSelection(boolean dontSkipStudyOptions) {\n          \n          \n            \n                private void openReviewerOrStudyOptions(boolean dontSkipStudyOptions) {\n          \n      \n    \n    \n  \n\nJust a name suggestion so it is aligned with what is actually happening in this commit", "author": "mikehardy", "createdAt": "2020-08-15T21:24:40Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2090,6 +2090,17 @@ private void openStudyOptions(boolean withDeckOptions) {\n         }\n     }\n \n+    private void shouldOpenReviewerOnSelection(boolean dontSkipStudyOptions) {", "originalCommit": "1ed51e5756e17ae88c37943fca8ef57e1dc4b03b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzODI2NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r471038265", "bodyText": "Fine by me", "author": "Arthur-Milchior", "createdAt": "2020-08-15T22:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzNTM1Mg=="}], "type": "inlineReview"}, {"oid": "b9475f67610e111f4f508ed82fec3fd5b4f2e0c4", "url": "https://github.com/ankidroid/Anki-Android/commit/b9475f67610e111f4f508ed82fec3fd5b4f2e0c4", "message": "NF: knownToHaveCount", "committedDate": "2020-08-15T21:50:04Z", "type": "forcePushed"}, {"oid": "c5a8d38a8d36d0e72cd6a16c3576c944d2a0c54a", "url": "https://github.com/ankidroid/Anki-Android/commit/c5a8d38a8d36d0e72cd6a16c3576c944d2a0c54a", "message": "NF: knownToHaveCount", "committedDate": "2020-08-15T22:09:34Z", "type": "forcePushed"}, {"oid": "b16d00296eae0eead2fefb9af3f0e686b7b858a6", "url": "https://github.com/ankidroid/Anki-Android/commit/b16d00296eae0eead2fefb9af3f0e686b7b858a6", "message": "NF: knownToHaveCount", "committedDate": "2020-08-21T08:01:34Z", "type": "forcePushed"}, {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500", "url": "https://github.com/ankidroid/Anki-Android/commit/ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500", "message": "NF: knownToHaveCount", "committedDate": "2020-08-22T10:02:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwMzQzMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476303433", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return;", "author": "david-allison-1", "createdAt": "2020-08-25T09:16:34Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2138,6 +2142,17 @@ private void openStudyOptions(boolean withDeckOptions) {\n         }\n     }\n \n+    private void openReviewerOrStudyOptions(boolean dontSkipStudyOptions) {\n+        if (mFragmented || dontSkipStudyOptions) {\n+            // Go to StudyOptions screen when tablet or deck counts area was clicked\n+            openStudyOptions(false);\n+        } else {\n+            // Otherwise jump straight to the reviewer\n+            openReviewer();\n+        }\n+        return;", "originalCommit": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwMzk4MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476303980", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CollectionTask.TASK_TYPE taskType = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;\n          \n          \n            \n                    CollectionTask.TASK_TYPE taskType = quick ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "author": "david-allison-1", "createdAt": "2020-08-25T09:17:30Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2279,8 +2290,13 @@ public void actualOnPostExecute(@NonNull DeckPicker deckPicker, TaskData result)\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n         TaskListener listener = updateDeckListListener();\n-        CollectionTask task = CollectionTask.launchCollectionTask(LOAD_DECK_COUNTS, listener);\n+        CollectionTask.TASK_TYPE taskType = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "originalCommit": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg4NDEwNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476884107", "bodyText": "I didn't even know it works without parenthesis. I thought it was like if, with mandatory parenthesis", "author": "Arthur-Milchior", "createdAt": "2020-08-25T23:54:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwMzk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNTQwMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476305400", "bodyText": "addRev is unused", "author": "david-allison-1", "createdAt": "2020-08-25T09:19:41Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        return Integer.compare(getDepth(), rhs.getDepth());\n+    }\n+\n+    /** Line representing this string without its children. Used in timbers only. */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {", "originalCommit": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg4NTcwOA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476885708", "bodyText": "It is used in the child. And I need to have the same method in parent and child if I want overridding to work", "author": "Arthur-Milchior", "createdAt": "2020-08-25T23:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNTQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNjA2Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476306066", "bodyText": "May be able to use Comparable<AbstractDeckTreeNode<T>> to improve the signature of compare()", "author": "david-allison-1", "createdAt": "2020-08-25T09:20:42Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {", "originalCommit": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg4ODU3Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476888573", "bodyText": "Nice", "author": "Arthur-Milchior", "createdAt": "2020-08-25T23:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNjA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNzY3Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476307673", "bodyText": "Questionable - might be best to extract to return a new (nullable) instance of a DeckCounts class so people don't misuse the API.\nImplementer's choice here", "author": "david-allison-1", "createdAt": "2020-08-25T09:23:22Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        return Integer.compare(getDepth(), rhs.getDepth());\n+    }\n+\n+    /** Line representing this string without its children. Used in timbers only. */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren == null ? 0 : mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == null || !(object instanceof AbstractDeckTreeNode)) {\n+            return false;\n+        }\n+        AbstractDeckTreeNode tree = (AbstractDeckTreeNode) object;\n+        return Decks.equalName(getFullDeckName(), tree.getFullDeckName()) &&\n+            (mChildren == null && tree.mChildren == null) || // Would be the case if both are null, or the same pointer\n+            (mChildren != null && mChildren.equals(tree.mChildren))\n+            ;\n+    }\n+\n+    public Collection getCol() {\n+        return mCol;\n+    }\n+\n+    public boolean shouldDisplayCounts() {\n+        return false;\n+    }\n+\n+    /* Number of new cards to see today known to be in this deck and its descendants. The number to show to user*/\n+    public int getNewCount() {\n+        throw new UnsupportedOperationException();", "originalCommit": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg5MTYxMQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476891611", "bodyText": "I don't see how returning null instead of throwing ensures it's used correctly. On the contrary, with throwing, as soon as the program is tested on a phone/emulator, it'll fail if it is used incorrectly.\nI don't expect any solution to be perfect, I'm happy with this version.", "author": "Arthur-Milchior", "createdAt": "2020-08-26T00:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNzY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjkwNjEzOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476906139", "bodyText": "There's currently an implicit dependency between getNewCount and shouldDisplayCounts.\nReturning an object removes that dependency (shouldDisplayCounts is equivalent to object == null), if the returned signature is @Nullable, then the caller will get a compiler warning if they're doing something wrong (trying to get counts before checking whether counts are supported).", "author": "david-allison-1", "createdAt": "2020-08-26T00:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNzY3Mw=="}], "type": "inlineReview"}, {"oid": "ba4adebcd072e9a317c50bb76b961087ef9c62ee", "url": "https://github.com/ankidroid/Anki-Android/commit/ba4adebcd072e9a317c50bb76b961087ef9c62ee", "message": "NF: shouldOpenReviewerOnSelection", "committedDate": "2020-08-25T23:54:27Z", "type": "commit"}, {"oid": "6f3d530084dae78c9600fa35451bf42630571931", "url": "https://github.com/ankidroid/Anki-Android/commit/6f3d530084dae78c9600fa35451bf42630571931", "message": "NF: Split DeckTreeNode in two\n\nAn abstract version without numbers, and the previous version with numbers.", "committedDate": "2020-08-26T00:00:26Z", "type": "commit"}, {"oid": "35c4301aa72d322ab7e69a96c660925a677cfcf0", "url": "https://github.com/ankidroid/Anki-Android/commit/35c4301aa72d322ab7e69a96c660925a677cfcf0", "message": "NF: quickDeckDueTree", "committedDate": "2020-08-26T00:00:27Z", "type": "commit"}, {"oid": "6b6f8e40d9938f1c8bfc4fc85acded4b7de7ef0b", "url": "https://github.com/ankidroid/Anki-Android/commit/6b6f8e40d9938f1c8bfc4fc85acded4b7de7ef0b", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call.", "committedDate": "2020-08-26T00:00:27Z", "type": "commit"}, {"oid": "3e0f4f9deb7fa0998fe1110deaebbd78f50d67a9", "url": "https://github.com/ankidroid/Anki-Android/commit/3e0f4f9deb7fa0998fe1110deaebbd78f50d67a9", "message": "NF: knownToHaveCount", "committedDate": "2020-08-26T00:00:27Z", "type": "commit"}, {"oid": "3e0f4f9deb7fa0998fe1110deaebbd78f50d67a9", "url": "https://github.com/ankidroid/Anki-Android/commit/3e0f4f9deb7fa0998fe1110deaebbd78f50d67a9", "message": "NF: knownToHaveCount", "committedDate": "2020-08-26T00:00:27Z", "type": "forcePushed"}]}