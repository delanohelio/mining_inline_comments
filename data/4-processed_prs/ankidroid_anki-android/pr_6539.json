{"pr_number": 6539, "pr_title": "NF: _groupChildrenMain simplification", "pr_createdAt": "2020-06-23T17:12:30Z", "pr_url": "https://github.com/ankidroid/Anki-Android/pull/6539", "timeline": [{"oid": "1ffaa61230dad165c5ce2288fe7979651758bf63", "url": "https://github.com/ankidroid/Anki-Android/commit/1ffaa61230dad165c5ce2288fe7979651758bf63", "message": "NF: _groupChildrenMain simplificitation\n\nThis use the fact that _groupChildrenMain is called only after the\ndeck collection is checked, so there is no duplicate and each nested\ndeck has a parent.\n\nCurrently what occurs is that, if you have the list of deck [\"A\",\n\"A::B\", \"A::C\", \"A::C::D\", \"E\"], the function will first process the\nsublist [\"A\", \"A::B\", \"A::C\", \"A::C::D\"] and then the sublist\n[\"E\"] (this is because it looks only as the first component of the\nname)\n\nThen, in the first sublist, it will look for the parent \"A\" and the\nchildren [\"A::B\", \"A::C\", \"A::C::D\"], by looking at which deck has\ndepth 0... that is useles, because, thanks to the sorting, we know the\nparent exists and is the first element of the list. Therefore, I\nremoving the condition dealing with the first element of the list and\nuse the fact that I know that it is the first element.\n\nBy itself it should be a really really small improvement. However, it\nallows to simplify the code and eventually to add great improvement\ninto it.", "committedDate": "2020-06-23T17:11:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxMzcxMg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6539#discussion_r444413712", "bodyText": "Can't we just write a groupby now we've got access to lambdas?", "author": "david-allison-1", "createdAt": "2020-06-23T18:09:20Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/Sched.java", "diffHunk": "@@ -252,42 +252,32 @@ private void unburyCardsForDeck(List<Long> allDecks) {\n         while (it.hasNext()) {\n             DeckDueTreeNode node = it.next();\n             String head = node.getNamePart(0);\n-            // Compose the \"tail\" node list. The tail is a list of all the nodes that proceed\n-            // the current one that contain the same name[0]. I.e., they are subdecks that stem\n-            // from this node. This is our version of python's itertools.groupby.\n-            List<DeckDueTreeNode> tail  = new ArrayList<>();\n-            tail.add(node);\n+            // Compose the \"children\" node list. The children is a list of all the nodes that proceed\n+            // the current one that contain the same name[0], except for the current one itself.\n+            // I.e., they are subdecks that stem from this node.\n+            // This is our version of python's itertools.groupby.", "originalCommit": "1ffaa61230dad165c5ce2288fe7979651758bf63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNjIxNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6539#discussion_r444416215", "bodyText": "if possible maybe a follow-on with a unit test?", "author": "mikehardy", "createdAt": "2020-06-23T18:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxMzcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxODMwNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6539#discussion_r444418305", "bodyText": "That would be incompatible with #6538 in this case, because in #6538 instead of looking at position 0 I look at the current depth level", "author": "Arthur-Milchior", "createdAt": "2020-06-23T18:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxMzcxMg=="}], "type": "inlineReview"}]}