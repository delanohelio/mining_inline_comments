{"pr_number": 6212, "pr_title": "Use TTS progress listener status in Card Viewer auto-advance delay", "pr_createdAt": "2020-05-18T07:25:24Z", "pr_url": "https://github.com/ankidroid/Anki-Android/pull/6212", "timeline": [{"oid": "c1a7d9809ab95f6a2ce39a1776a82dc862ebbda1", "url": "https://github.com/ankidroid/Anki-Android/commit/c1a7d9809ab95f6a2ce39a1776a82dc862ebbda1", "message": "fix issue#6087", "committedDate": "2020-05-18T04:12:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NTAxMQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r426445011", "bodyText": "Can be shortened to: UIUtils.showThemedToast(context, context.getString(R.string.no_tts_available_message), false);", "author": "david-allison-1", "createdAt": "2020-05-18T08:14:36Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -1,3113 +1,3174 @@\n-/****************************************************************************************\n- * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *\n- * Copyright (c) 2014\u201315 Roland Sieker <ospalh@gmail.com>                               *\n- * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *\n- * Copyright (c) 2016 Mark Carter <mark@marcardar.com>                                  *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.annotation.TargetApi;\n-import android.app.Activity;\n-import android.content.ActivityNotFoundException;\n-import android.content.BroadcastReceiver;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.IntentFilter;\n-import android.content.SharedPreferences;\n-import android.content.res.Configuration;\n-import android.content.res.Resources;\n-import android.graphics.Color;\n-import android.net.Uri;\n-import android.os.Build;\n-import android.os.Bundle;\n-import android.os.Handler;\n-import android.os.Message;\n-import android.os.SystemClock;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.IdRes;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import androidx.core.view.GestureDetectorCompat;\n-import androidx.appcompat.app.ActionBar;\n-import android.text.SpannableString;\n-import android.text.Spanned;\n-import android.text.SpannedString;\n-import android.text.TextUtils;\n-import android.text.style.UnderlineSpan;\n-import android.util.TypedValue;\n-import android.view.GestureDetector.SimpleOnGestureListener;\n-import android.view.KeyEvent;\n-import android.view.LayoutInflater;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.View.OnClickListener;\n-import android.view.ViewGroup;\n-import android.view.WindowManager;\n-import android.view.inputmethod.EditorInfo;\n-import android.view.inputmethod.InputMethodManager;\n-import android.webkit.JsResult;\n-import android.webkit.RenderProcessGoneDetail;\n-import android.webkit.WebChromeClient;\n-import android.webkit.WebResourceRequest;\n-import android.webkit.WebResourceResponse;\n-import android.webkit.WebView;\n-import android.webkit.WebViewClient;\n-import android.widget.Button;\n-import android.widget.Chronometer;\n-import android.widget.EditText;\n-import android.widget.FrameLayout;\n-import android.widget.ImageView;\n-import android.widget.LinearLayout;\n-import android.widget.RelativeLayout;\n-import android.widget.TextView;\n-\n-import com.afollestad.materialdialogs.MaterialDialog;\n-import com.afollestad.materialdialogs.util.TypefaceHelper;\n-import com.ichi2.anim.ActivityTransitionAnimation;\n-import com.ichi2.anim.ViewAnimation;\n-import com.ichi2.anki.cardviewer.CardAppearance;\n-import com.ichi2.anki.receiver.SdCardReceiver;\n-import com.ichi2.anki.reviewer.CardMarker;\n-import com.ichi2.anki.reviewer.CardMarker.FlagDef;\n-import com.ichi2.anki.reviewer.ReviewerCustomFonts;\n-import com.ichi2.anki.reviewer.ReviewerUi;\n-import com.ichi2.anki.cardviewer.TypedAnswer;\n-import com.ichi2.async.CollectionTask;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.sched.AbstractSched;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Note;\n-import com.ichi2.libanki.Sound;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.template.Template;\n-import com.ichi2.themes.HtmlColors;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.utils.AdaptionUtil;\n-import com.ichi2.utils.DiffEngine;\n-import com.ichi2.utils.FunctionalInterfaces.Consumer;\n-import com.ichi2.utils.FunctionalInterfaces.Function;\n-\n-import com.ichi2.utils.JSONArray;\n-import com.ichi2.utils.JSONException;\n-import com.ichi2.utils.JSONObject;\n-import com.ichi2.utils.WebViewDebugging;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.UnsupportedEncodingException;\n-import java.lang.ref.WeakReference;\n-import java.net.URLDecoder;\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReadWriteLock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.calculateDynamicFontSize;\n-import static com.ichi2.anki.cardviewer.ViewerCommand.*;\n-import static com.ichi2.anki.reviewer.CardMarker.*;\n-\n-@SuppressWarnings({\"PMD.AvoidThrowingRawExceptionTypes\",\"PMD.FieldDeclarationsShouldBeAtStartOfClass\"})\n-public abstract class AbstractFlashcardViewer extends NavigationDrawerActivity implements ReviewerUi, CommandProcessor {\n-\n-    /**\n-     * Result codes that are returned when this activity finishes.\n-     */\n-    public static final int RESULT_DEFAULT = 50;\n-    public static final int RESULT_NO_MORE_CARDS = 52;\n-\n-    /**\n-     * Available options performed by other activities.\n-     */\n-    public static final int EDIT_CURRENT_CARD = 0;\n-    public static final int DECK_OPTIONS = 1;\n-\n-    public static final int EASE_1 = 1;\n-    public static final int EASE_2 = 2;\n-    public static final int EASE_3 = 3;\n-    public static final int EASE_4 = 4;\n-\n-    /** Maximum time in milliseconds to wait before accepting answer button presses. */\n-    private static final int DOUBLE_TAP_IGNORE_THRESHOLD = 200;\n-\n-    /** Time to wait in milliseconds before resuming fullscreen mode **/\n-    protected static final int INITIAL_HIDE_DELAY = 200;\n-\n-    // Type answer patterns\n-    private static final Pattern sTypeAnsPat = Pattern.compile(\"\\\\[\\\\[type:(.+?)\\\\]\\\\]\");\n-\n-    /** to be sent to and from the card editor */\n-    private static Card sEditorCard;\n-\n-    protected static boolean sDisplayAnswer = false;\n-\n-    private boolean mTtsInitialized = false;\n-    private boolean mReplayOnTtsInit = false;\n-\n-    protected static final int MENU_DISABLED = 3;\n-\n-\n-    /**\n-     * Broadcast that informs us when the sd card is about to be unmounted\n-     */\n-    private BroadcastReceiver mUnmountReceiver = null;\n-\n-    /**\n-     * Variables to hold preferences\n-     */\n-    private CardAppearance mCardAppearance;\n-    private boolean mPrefHideDueCount;\n-    private boolean mPrefShowETA;\n-    private boolean mShowTimer;\n-    protected boolean mPrefWhiteboard;\n-    private int mPrefFullscreenReview;\n-    private int mRelativeButtonSize;\n-    private boolean mDoubleScrolling;\n-    private boolean mScrollingButtons;\n-    private boolean mGesturesEnabled;\n-    // Android WebView\n-    protected boolean mSpeakText;\n-    protected boolean mDisableClipboard = false;\n-\n-    protected boolean mOptUseGeneralTimerSettings;\n-\n-    protected boolean mUseTimer;\n-    protected int mWaitAnswerSecond;\n-    protected int mWaitQuestionSecond;\n-\n-    protected boolean mPrefUseTimer;\n-\n-    protected boolean mOptUseTimer;\n-    protected int mOptWaitAnswerSecond;\n-    protected int mOptWaitQuestionSecond;\n-\n-    protected boolean mUseInputTag;\n-\n-    // Preferences from the collection\n-    private boolean mShowNextReviewTime;\n-    private boolean mShowRemainingCardCount;\n-\n-    // Answer card & cloze deletion variables\n-    private String mTypeCorrect = null;\n-    // The correct answer in the compare to field if answer should be given by learner. Null if no answer is expected.\n-    private String mTypeInput = \"\";  // What the learner actually typed\n-    private String mTypeFont = \"\";  // Font face of the compare to field\n-    private int mTypeSize = 0;  // Its font size\n-    private String mTypeWarning;\n-\n-    private boolean mIsSelecting = false;\n-    private boolean mTouchStarted = false;\n-    private boolean mInAnswer = false;\n-    private boolean mAnswerSoundsAdded = false;\n-\n-    private String mCardTemplate;\n-\n-    /**\n-     * Variables to hold layout objects that we need to update or handle events for\n-     */\n-    private View mLookUpIcon;\n-    private WebView mCard;\n-    private FrameLayout mCardFrame;\n-    private FrameLayout mTouchLayer;\n-    private TextView mTextBarNew;\n-    private TextView mTextBarLearn;\n-    private TextView mTextBarReview;\n-    private TextView mChosenAnswer;\n-    protected TextView mNext1;\n-    protected TextView mNext2;\n-    protected TextView mNext3;\n-    protected TextView mNext4;\n-    protected EditText mAnswerField;\n-    protected TextView mEase1;\n-    protected TextView mEase2;\n-    protected TextView mEase3;\n-    protected TextView mEase4;\n-    protected LinearLayout mFlipCardLayout;\n-    protected LinearLayout mEase1Layout;\n-    protected LinearLayout mEase2Layout;\n-    protected LinearLayout mEase3Layout;\n-    protected LinearLayout mEase4Layout;\n-    protected RelativeLayout mTopBarLayout;\n-    private Chronometer mCardTimer;\n-    protected Whiteboard mWhiteboard;\n-    @SuppressWarnings(\"deprecation\") // Tracked separately as #5023 on github\n-    private android.text.ClipboardManager mClipboard;\n-\n-    protected Card mCurrentCard;\n-    private int mCurrentEase;\n-\n-    private boolean mButtonHeightSet = false;\n-\n-    private boolean mConfigurationChanged = false;\n-    private int mShowChosenAnswerLength = 2000;\n-\n-    /**\n-     * A record of the last time the \"show answer\" or ease buttons were pressed. We keep track\n-     * of this time to ignore accidental button presses.\n-     */\n-    private long mLastClickTime;\n-\n-    /**\n-     * Swipe Detection\n-     */\n-    private GestureDetectorCompat gestureDetector;\n-\n-    private boolean mIsXScrolling = false;\n-    private boolean mIsYScrolling = false;\n-\n-    /**\n-     * Gesture Allocation\n-     */\n-    private int mGestureSwipeUp;\n-    private int mGestureSwipeDown;\n-    private int mGestureSwipeLeft;\n-    private int mGestureSwipeRight;\n-    private int mGestureDoubleTap;\n-    private int mGestureTapLeft;\n-    private int mGestureTapRight;\n-    private int mGestureTapTop;\n-    private int mGestureTapBottom;\n-    private int mGestureLongclick;\n-\n-    private Spanned mCardContent;\n-    private String mBaseUrl;\n-\n-    private int mFadeDuration = 300;\n-\n-    protected AbstractSched mSched;\n-\n-    private Sound mSoundPlayer = new Sound();\n-\n-    private long mUseTimerDynamicMS;\n-\n-    /**\n-     * Last card that the WebView Renderer crashed on.\n-     * If we get 2 crashes on the same card, then we likely have an infinite loop and want to exit gracefully.\n-     */\n-    @Nullable\n-    private Long lastCrashingCardId = null;\n-\n-    /** Reference to the parent of the cardFrame to allow regeneration of the cardFrame in case of crash */\n-    private ViewGroup mCardFrameParent;\n-\n-    /** Lock to allow thread-safe regeneration of mCard */\n-    private ReadWriteLock mCardLock = new ReentrantReadWriteLock();\n-\n-    /** whether controls are currently blocked */\n-    private boolean mControlBlocked = true;\n-\n-    /** Handle Mark/Flag state of cards */\n-    private CardMarker mCardMarker;\n-    // private int zEase;\n-\n-    // ----------------------------------------------------------------------------\n-    // LISTENERS\n-    // ----------------------------------------------------------------------------\n-\n-    private Handler mHandler = new Handler() {\n-\n-        @Override\n-        public void handleMessage(Message msg) {\n-            mSoundPlayer.stopSounds();\n-            mSoundPlayer.playSound((String) msg.obj, null);\n-        }\n-    };\n-\n-    private final Handler longClickHandler = new Handler();\n-    private final Runnable longClickTestRunnable = new Runnable() {\n-        @Override\n-        public void run() {\n-            Timber.i(\"AbstractFlashcardViewer:: onEmulatedLongClick\");\n-            // Show hint about lookup function if dictionary available\n-            if (!mDisableClipboard && Lookup.isAvailable()) {\n-                String lookupHint = getResources().getString(R.string.lookup_hint);\n-                UIUtils.showThemedToast(AbstractFlashcardViewer.this, lookupHint, false);\n-            }\n-            CompatHelper.getCompat().vibrate(AnkiDroidApp.getInstance().getApplicationContext(), 50);\n-            longClickHandler.postDelayed(startLongClickAction, 300);\n-        }\n-    };\n-    private final Runnable startLongClickAction = new Runnable() {\n-        @Override\n-        public void run() {\n-            executeCommand(mGestureLongclick);\n-        }\n-    };\n-\n-\n-    // Handler for the \"show answer\" button\n-    private View.OnClickListener mFlipCardListener = new View.OnClickListener() {\n-        @Override\n-        public void onClick(View view) {\n-            Timber.i(\"AbstractFlashcardViewer:: Show answer button pressed\");\n-            // Ignore what is most likely an accidental double-tap.\n-            if (SystemClock.elapsedRealtime() - mLastClickTime < DOUBLE_TAP_IGNORE_THRESHOLD) {\n-                return;\n-            }\n-            mLastClickTime = SystemClock.elapsedRealtime();\n-            mTimeoutHandler.removeCallbacks(mShowAnswerTask);\n-            displayCardAnswer();\n-        }\n-    };\n-\n-    private View.OnClickListener mSelectEaseHandler = new View.OnClickListener() {\n-        @Override\n-        public void onClick(View view) {\n-            // Ignore what is most likely an accidental double-tap.\n-            if (SystemClock.elapsedRealtime() - mLastClickTime < DOUBLE_TAP_IGNORE_THRESHOLD) {\n-                return;\n-            }\n-            mLastClickTime = SystemClock.elapsedRealtime();\n-            mTimeoutHandler.removeCallbacks(mShowQuestionTask);\n-            switch (view.getId()) {\n-                case R.id.flashcard_layout_ease1:\n-                    Timber.i(\"AbstractFlashcardViewer:: EASE_1 pressed\");\n-                    answerCard(EASE_1);\n-                    break;\n-                case R.id.flashcard_layout_ease2:\n-                    Timber.i(\"AbstractFlashcardViewer:: EASE_2 pressed\");\n-                    answerCard(EASE_2);\n-                    break;\n-                case R.id.flashcard_layout_ease3:\n-                    Timber.i(\"AbstractFlashcardViewer:: EASE_3 pressed\");\n-                    answerCard(EASE_3);\n-                    break;\n-                case R.id.flashcard_layout_ease4:\n-                    Timber.i(\"AbstractFlashcardViewer:: EASE_4 pressed\");\n-                    answerCard(EASE_4);\n-                    break;\n-                default:\n-                    mCurrentEase = 0;\n-                    break;\n-            }\n-        }\n-    };\n-\n-    private View.OnTouchListener mGestureListener = new View.OnTouchListener() {\n-        @Override\n-        public boolean onTouch(View v, MotionEvent event) {\n-            if (gestureDetector.onTouchEvent(event)) {\n-                return true;\n-            }\n-            if (!mDisableClipboard) {\n-                switch (event.getAction()) {\n-                    case MotionEvent.ACTION_DOWN:\n-                        mTouchStarted = true;\n-                        longClickHandler.postDelayed(longClickTestRunnable, 800);\n-                        break;\n-                    case MotionEvent.ACTION_UP:\n-                    case MotionEvent.ACTION_MOVE:\n-                        if (mTouchStarted) {\n-                            longClickHandler.removeCallbacks(longClickTestRunnable);\n-                            mTouchStarted = false;\n-                        }\n-                        break;\n-                    default:\n-                        longClickHandler.removeCallbacks(longClickTestRunnable);\n-                        mTouchStarted = false;\n-                        break;\n-                }\n-            }\n-            //Gesture listener is added before mCard is set\n-            processCardAction(card -> {\n-                if (card == null) return;\n-                card.dispatchTouchEvent(event);\n-            });\n-            return false;\n-        }\n-    };\n-\n-    @SuppressLint(\"CheckResult\")\n-    private void processCardAction(Consumer<WebView> cardConsumer) {\n-        processCardFunction(card -> {\n-            cardConsumer.consume(card);\n-            return true;\n-        });\n-    }\n-\n-    @CheckResult\n-    private <T> T processCardFunction(Function<WebView, T> cardFunction) {\n-        Lock readLock = mCardLock.readLock();\n-        try {\n-            readLock.lock();\n-            return cardFunction.apply(mCard);\n-        } finally {\n-            readLock.unlock();\n-        }\n-    }\n-\n-\n-    protected CollectionTask.TaskListener mDismissCardHandler = new NextCardHandler() { /* superclass is sufficient */ };\n-\n-\n-    private CollectionTask.TaskListener mUpdateCardHandler = new CollectionTask.TaskListener() {\n-        private boolean mNoMoreCards;\n-\n-\n-        @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n-        }\n-\n-\n-        @Override\n-        public void onProgressUpdate(CollectionTask.TaskData... values) {\n-            boolean cardChanged = false;\n-            if (mCurrentCard != values[0].getCard()) {\n-                /*\n-                 * Before updating mCurrentCard, we check whether it is changing or not. If the current card changes,\n-                 * then we need to display it as a new card, without showing the answer.\n-                 */\n-                sDisplayAnswer = false;\n-                cardChanged = true;  // Keep track of that so we can run a bit of new-card code\n-            }\n-            mCurrentCard = values[0].getCard();\n-            if (mCurrentCard == null) {\n-                // If the card is null means that there are no more cards scheduled for review.\n-                mNoMoreCards = true;\n-                showProgressBar();\n-                return;\n-            }\n-            if (mPrefWhiteboard && mWhiteboard != null) {\n-                mWhiteboard.clear();\n-            }\n-\n-            if (sDisplayAnswer) {\n-                mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n-                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n-                generateQuestionSoundList(); // questions must be intentionally regenerated\n-                displayCardAnswer();\n-            } else {\n-                if (cardChanged) {\n-                    updateTypeAnswerInfo();\n-                }\n-                displayCardQuestion();\n-                mCurrentCard.startTimer();\n-                initTimer();\n-            }\n-            hideProgressBar();\n-        }\n-\n-\n-        @Override\n-        public void onPostExecute(CollectionTask.TaskData result) {\n-            if (!result.getBoolean()) {\n-                // RuntimeException occurred on update cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n-                return;\n-            }\n-            if (mNoMoreCards) {\n-                closeReviewer(RESULT_NO_MORE_CARDS, true);\n-            }\n-        }\n-    };\n-\n-    abstract class NextCardHandler extends CollectionTask.TaskListener {\n-        private boolean mNoMoreCards;\n-\n-\n-        @Override\n-        public void onPreExecute() { /* do nothing */}\n-\n-\n-        @Override\n-        public void onProgressUpdate(CollectionTask.TaskData... values) {\n-            displayNext(values[0].getCard());\n-        }\n-\n-        protected void displayNext(Card nextCard) {\n-\n-            Resources res = getResources();\n-\n-            if (mSched == null) {\n-                // TODO: proper testing for restored activity\n-                finishWithoutAnimation();\n-                return;\n-            }\n-\n-            mCurrentCard = nextCard;\n-            if (mCurrentCard == null) {\n-                // If the card is null means that there are no more cards scheduled for review.\n-                mNoMoreCards = true; // other handlers use this, toggle state every time through\n-            } else {\n-                mNoMoreCards = false; // other handlers use this, toggle state every time through\n-                // Start reviewing next card\n-                updateTypeAnswerInfo();\n-                hideProgressBar();\n-                AbstractFlashcardViewer.this.unblockControls();\n-                AbstractFlashcardViewer.this.displayCardQuestion();\n-            }\n-\n-            // Since reps are incremented on fetch of next card, we will miss counting the\n-            // last rep since there isn't a next card. We manually account for it here.\n-            if (mNoMoreCards) {\n-                mSched.setReps(mSched.getReps() + 1);\n-            }\n-\n-            Long[] elapsed = getCol().timeboxReached();\n-            if (elapsed != null) {\n-                // AnkiDroid is always counting one rep ahead, so we decrement it before displaying\n-                // it to the user.\n-                int nCards = elapsed[1].intValue() - 1;\n-                int nMins = elapsed[0].intValue() / 60;\n-                String mins = res.getQuantityString(R.plurals.in_minutes, nMins, nMins);\n-                String timeboxMessage = res.getQuantityString(R.plurals.timebox_reached, nCards, nCards, mins);\n-                UIUtils.showThemedToast(AbstractFlashcardViewer.this, timeboxMessage, true);\n-                getCol().startTimebox();\n-            }\n-        }\n-\n-\n-        @Override\n-        public void onPostExecute(CollectionTask.TaskData result) {\n-            postNextCardDisplay(result.getBoolean());\n-        }\n-\n-        protected void postNextCardDisplay(boolean displaySuccess) {\n-            if (!displaySuccess) {\n-                // RuntimeException occurred on answering cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n-                return;\n-            }\n-            // Check for no more cards before session complete. If they are both true, no more cards will take\n-            // precedence when returning to study options.\n-            if (mNoMoreCards) {\n-                closeReviewer(RESULT_NO_MORE_CARDS, true);\n-            }\n-            // set the correct mark/unmark icon on action bar\n-            refreshActionBar();\n-            findViewById(R.id.root_layout).requestFocus();\n-        }\n-    }\n-\n-\n-    protected CollectionTask.TaskListener mAnswerCardHandler = new NextCardHandler() {\n-\n-\n-        @Override\n-        public void onPreExecute() {\n-            blockControls();\n-        }\n-    };\n-\n-\n-    /**\n-     * Extract type answer/cloze text and font/size\n-     */\n-    private void updateTypeAnswerInfo() {\n-        mTypeCorrect = null;\n-        mTypeInput = \"\";\n-        String q = mCurrentCard.q(false);\n-        Matcher m = sTypeAnsPat.matcher(q);\n-        int clozeIdx = 0;\n-        if (!m.find()) {\n-            return;\n-        }\n-        String fld = m.group(1);\n-        // if it's a cloze, extract data\n-        if (fld.startsWith(\"cloze:\", 0)) {\n-            // get field and cloze position\n-            clozeIdx = mCurrentCard.getOrd() + 1;\n-            fld = fld.split(\":\")[1];\n-        }\n-        // loop through fields for a match\n-        JSONArray ja = mCurrentCard.model().getJSONArray(\"flds\");\n-        for (int i = 0; i < ja.length(); i++) {\n-            String name = (String) (ja.getJSONObject(i).get(\"name\"));\n-            if (name.equals(fld)) {\n-                mTypeCorrect = mCurrentCard.note().getItem(name);\n-                if (clozeIdx != 0) {\n-                    // narrow to cloze\n-                    mTypeCorrect = contentForCloze(mTypeCorrect, clozeIdx);\n-                }\n-                mTypeFont = (String) (ja.getJSONObject(i).get(\"font\"));\n-                mTypeSize = (int) (ja.getJSONObject(i).get(\"size\"));\n-                break;\n-            }\n-        }\n-        if (mTypeCorrect == null) {\n-            if (clozeIdx != 0) {\n-                mTypeWarning = getResources().getString(R.string.empty_card_warning);\n-            } else {\n-                mTypeWarning = getResources().getString(R.string.unknown_type_field_warning, fld);\n-            }\n-        } else if (\"\".equals(mTypeCorrect)) {\n-            mTypeCorrect = null;\n-        } else {\n-            mTypeWarning = null;\n-        }\n-    }\n-\n-\n-    /**\n-     * Format question field when it contains typeAnswer or clozes. If there was an error during type text extraction, a\n-     * warning is displayed\n-     *\n-     * @param buf The question text\n-     * @return The formatted question text\n-     */\n-    private String typeAnsQuestionFilter(String buf) {\n-        Matcher m = sTypeAnsPat.matcher(buf);\n-        if (mTypeWarning != null) {\n-            return m.replaceFirst(mTypeWarning);\n-        }\n-        StringBuilder sb = new StringBuilder();\n-        if (mUseInputTag) {\n-            // These functions are defined in the JavaScript file assets/scripts/card.js. We get the text back in\n-            // shouldOverrideUrlLoading() in createWebView() in this file.\n-            sb.append(\"<center>\\n<input type=\\\"text\\\" name=\\\"typed\\\" id=\\\"typeans\\\" onfocus=\\\"taFocus();\\\" \" +\n-                    \"onblur=\\\"taBlur(this);\\\" onKeyPress=\\\"return taKey(this, event)\\\" autocomplete=\\\"off\\\" \");\n-            // We have to watch out. For the preview we don\u2019t know the font or font size. Skip those there. (Anki\n-            // desktop just doesn\u2019t show the input tag there. Do it with standard values here instead.)\n-            if (mTypeFont != null && !TextUtils.isEmpty(mTypeFont) && mTypeSize > 0) {\n-                sb.append(\"style=\\\"font-family: '\").append(mTypeFont).append(\"'; font-size: \")\n-                        .append(Integer.toString(mTypeSize)).append(\"px;\\\" \");\n-            }\n-            sb.append(\">\\n</center>\\n\");\n-        } else {\n-            sb.append(\"<span id=\\\"typeans\\\" class=\\\"typePrompt\");\n-            if (mUseInputTag) {\n-                sb.append(\" typeOff\");\n-            }\n-            sb.append(\"\\\">........</span>\");\n-        }\n-        return m.replaceAll(sb.toString());\n-    }\n-\n-\n-    /**\n-     * Fill the placeholder for the type comparison. Show the correct answer, and the comparison if appropriate.\n-     *\n-     * @param buf The answer text\n-     * @param userAnswer Text typed by the user, or empty.\n-     * @param correctAnswer The correct answer, taken from the note.\n-     * @return The formatted answer text\n-     */\n-    @VisibleForTesting\n-    String typeAnsAnswerFilter(String buf, String userAnswer, String correctAnswer) {\n-        Matcher m = sTypeAnsPat.matcher(buf);\n-        DiffEngine diffEngine = new DiffEngine();\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"<div><code id=\\\"typeans\\\">\");\n-\n-        // We have to use Matcher.quoteReplacement because the inputs here might have $ or \\.\n-\n-        if (!TextUtils.isEmpty(userAnswer)) {\n-            // The user did type something.\n-            if (userAnswer.equals(correctAnswer)) {\n-                // and it was right.\n-                sb.append(Matcher.quoteReplacement(DiffEngine.wrapGood(correctAnswer)));\n-                sb.append(\"<span id=\\\"typecheckmark\\\">\\u2714</span>\"); // Heavy check mark\n-            } else {\n-                // Answer not correct.\n-                // Only use the complex diff code when needed, that is when we have some typed text that is not\n-                // exactly the same as the correct text.\n-                String[] diffedStrings = diffEngine.diffedHtmlStrings(correctAnswer, userAnswer);\n-                // We know we get back two strings.\n-                sb.append(Matcher.quoteReplacement(diffedStrings[0]));\n-                sb.append(\"<br><span id=\\\"typearrow\\\">&darr;</span><br>\");\n-                sb.append(Matcher.quoteReplacement(diffedStrings[1]));\n-            }\n-        } else {\n-            if (!mUseInputTag) {\n-                sb.append(Matcher.quoteReplacement(DiffEngine.wrapMissing(correctAnswer)));\n-            } else {\n-                sb.append(Matcher.quoteReplacement(correctAnswer));\n-            }\n-        }\n-        sb.append(\"</code></div>\");\n-        return m.replaceAll(sb.toString());\n-    }\n-\n-    /**\n-     * Return the correct answer to use for {{type::cloze::NN}} fields.\n-     *\n-     * @param txt The field text with the clozes\n-     * @param idx The index of the cloze to use\n-     * @return A string with a comma-separeted list of unique cloze strings with the corret index.\n-     */\n-\n-    private String contentForCloze(String txt, int idx) {\n-        Pattern re = Pattern.compile(\"\\\\{\\\\{c\" + idx + \"::(.+?)\\\\}\\\\}\");\n-        Matcher m = re.matcher(txt);\n-        Set<String> matches = new LinkedHashSet<>();\n-        // LinkedHashSet: make entries appear only once, like Anki desktop (see also issue #2208), and keep the order\n-        // they appear in.\n-        String groupOne;\n-        int colonColonIndex = -1;\n-        while (m.find()) {\n-            groupOne = m.group(1);\n-            colonColonIndex = groupOne.indexOf(\"::\");\n-            if (colonColonIndex > -1) {\n-                // Cut out the hint.\n-                groupOne = groupOne.substring(0, colonColonIndex);\n-            }\n-            matches.add(groupOne);\n-        }\n-        // Now do what the pythonic \", \".join(matches) does in a tricky way\n-        String prefix = \"\";\n-        StringBuilder resultBuilder = new StringBuilder();\n-        for (String match : matches) {\n-            resultBuilder.append(prefix);\n-            resultBuilder.append(match);\n-            prefix = \", \";\n-        }\n-        return resultBuilder.toString();\n-    }\n-\n-    private Handler mTimerHandler = new Handler();\n-\n-    private Runnable removeChosenAnswerText = new Runnable() {\n-        @Override\n-        public void run() {\n-            mChosenAnswer.setText(\"\");\n-        }\n-    };\n-\n-    protected int mPrefWaitAnswerSecond;\n-    protected int mPrefWaitQuestionSecond;\n-\n-    protected int getDefaultEase() {\n-        if (getAnswerButtonCount() == 4) {\n-            return EASE_3;\n-        } else {\n-            return EASE_2;\n-        }\n-    }\n-\n-\n-    protected int getAnswerButtonCount() {\n-        return getCol().getSched().answerButtons(mCurrentCard);\n-    }\n-\n-\n-    // ----------------------------------------------------------------------------\n-    // ANDROID METHODS\n-    // ----------------------------------------------------------------------------\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        Timber.d(\"onCreate()\");\n-        SharedPreferences preferences = restorePreferences();\n-        mCardAppearance = CardAppearance.create(new ReviewerCustomFonts(this.getBaseContext()), preferences);\n-        super.onCreate(savedInstanceState);\n-        setContentView(getContentViewAttr(mPrefFullscreenReview));\n-\n-        // Make ACTION_PROCESS_TEXT for in-app searching possible on > Android 4.0\n-        getDelegate().setHandleNativeActionModesEnabled(true);\n-\n-        View mainView = findViewById(android.R.id.content);\n-        initNavigationDrawer(mainView);\n-    }\n-\n-    protected int getContentViewAttr(int fullscreenMode) {\n-        return R.layout.reviewer;\n-    }\n-\n-    @ Override\n-    public void onConfigurationChanged(Configuration config) {\n-        // called when screen rotated, etc, since recreating the Webview is too expensive\n-        super.onConfigurationChanged(config);\n-        refreshActionBar();\n-    }\n-\n-\n-    protected abstract void setTitle();\n-\n-\n-    // Finish initializing the activity after the collection has been correctly loaded\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        mSched = col.getSched();\n-        mBaseUrl = Utils.getBaseUrl(col.getMedia().dir());\n-\n-        registerExternalStorageListener();\n-\n-        restoreCollectionPreferences();\n-\n-        initLayout();\n-\n-        setTitle();\n-\n-        if (!mDisableClipboard) {\n-            clipboardSetText(\"\");\n-        }\n-\n-        // Load the template for the card\n-        try {\n-            mCardTemplate = Utils.convertStreamToString(getAssets().open(\"card_template.html\"));\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-\n-        // Initialize text-to-speech. This is an asynchronous operation.\n-        if (mSpeakText) {\n-            ReadText.initializeTts(this);\n-        }\n-\n-        // Initialize dictionary lookup feature\n-        Lookup.initialize(this);\n-\n-        updateScreenCounts();\n-        supportInvalidateOptionsMenu();\n-    }\n-\n-    // Saves deck each time Reviewer activity loses focus\n-    @Override\n-    protected void onPause() {\n-        super.onPause();\n-        Timber.d(\"onPause()\");\n-\n-        mTimeoutHandler.removeCallbacks(mShowAnswerTask);\n-        mTimeoutHandler.removeCallbacks(mShowQuestionTask);\n-        longClickHandler.removeCallbacks(longClickTestRunnable);\n-        longClickHandler.removeCallbacks(startLongClickAction);\n-\n-        pauseTimer();\n-        mSoundPlayer.stopSounds();\n-\n-        // Prevent loss of data in Cookies\n-        CompatHelper.getCompat().flushWebViewCookies();\n-    }\n-\n-\n-    @Override\n-    protected void onResume() {\n-        super.onResume();\n-        resumeTimer();\n-        // Set the context for the Sound manager\n-        mSoundPlayer.setContext(new WeakReference<Activity>(this));\n-        // Reset the activity title\n-        setTitle();\n-        updateScreenCounts();\n-        selectNavigationItem(-1);\n-    }\n-\n-\n-    @Override\n-    protected void onDestroy() {\n-        super.onDestroy();\n-        Timber.d(\"onDestroy()\");\n-        if (mSpeakText) {\n-            ReadText.releaseTts();\n-        }\n-        if (mUnmountReceiver != null) {\n-            unregisterReceiver(mUnmountReceiver);\n-        }\n-        // WebView.destroy() should be called after the end of use\n-        // http://developer.android.com/reference/android/webkit/WebView.html#destroy()\n-        if (mCardFrame != null) {\n-            mCardFrame.removeAllViews();\n-        }\n-        destroyWebView(mCard); //OK to do without a lock\n-    }\n-\n-\n-    @Override\n-    public void onBackPressed() {\n-        if (isDrawerOpen()) {\n-            super.onBackPressed();\n-        } else {\n-            Timber.i(\"Back key pressed\");\n-            closeReviewer(RESULT_DEFAULT, false);\n-        }\n-    }\n-\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        if (processCardFunction(card -> processHardwareButtonScroll(keyCode, card))) {\n-            return true;\n-        }\n-        return super.onKeyDown(keyCode, event);\n-    }\n-\n-\n-    private boolean processHardwareButtonScroll(int keyCode, WebView card) {\n-        if (keyCode == KeyEvent.KEYCODE_PAGE_UP) {\n-            card.pageUp(false);\n-            if (mDoubleScrolling) {\n-                card.pageUp(false);\n-            }\n-            return true;\n-        }\n-        if (keyCode == KeyEvent.KEYCODE_PAGE_DOWN) {\n-            card.pageDown(false);\n-            if (mDoubleScrolling) {\n-                card.pageDown(false);\n-            }\n-            return true;\n-        }\n-        if (mScrollingButtons && keyCode == KeyEvent.KEYCODE_PICTSYMBOLS) {\n-            card.pageUp(false);\n-            if (mDoubleScrolling) {\n-                card.pageUp(false);\n-            }\n-            return true;\n-        }\n-        if (mScrollingButtons && keyCode == KeyEvent.KEYCODE_SWITCH_CHARSET) {\n-            card.pageDown(false);\n-            if (mDoubleScrolling) {\n-                card.pageDown(false);\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-\n-    @Override\n-    public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyUp(keyCode, event);\n-        }\n-        if (!sDisplayAnswer) {\n-            if (keyCode == KeyEvent.KEYCODE_SPACE || keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_NUMPAD_ENTER) {\n-                displayCardAnswer();\n-                return true;\n-            }\n-        }\n-        return super.onKeyUp(keyCode, event);\n-    }\n-\n-\n-    protected boolean answerFieldIsFocused() {\n-        return mAnswerField != null && mAnswerField.isFocused();\n-    }\n-\n-\n-    @SuppressWarnings(\"deprecation\") // Tracked separately as #5023 on github\n-    protected boolean clipboardHasText() {\n-        return mClipboard != null && mClipboard.hasText();\n-    }\n-\n-\n-    @SuppressWarnings(\"deprecation\") // Tracked separately as #5023 on github\n-    private void clipboardSetText(CharSequence text) {\n-        if (mClipboard != null) {\n-            try {\n-                mClipboard.setText(text);\n-            } catch (Exception e) {\n-                // https://code.google.com/p/ankidroid/issues/detail?id=1746\n-                // https://code.google.com/p/ankidroid/issues/detail?id=1820\n-                // Some devices or external applications make the clipboard throw exceptions. If this happens, we\n-                // must disable it or AnkiDroid will crash if it tries to use it.\n-                Timber.e(\"Clipboard error. Disabling text selection setting.\");\n-                mDisableClipboard = true;\n-            }\n-        }\n-    }\n-\n-\n-    /**\n-     * Returns the text stored in the clipboard or the empty string if the clipboard is empty or contains something that\n-     * cannot be convered to text.\n-     *\n-     * @return the text in clipboard or the empty string.\n-     */\n-    @SuppressWarnings(\"deprecation\") // Tracked separately as #5023 on github\n-    private CharSequence clipboardGetText() {\n-        CharSequence text = mClipboard != null ? mClipboard.getText() : null;\n-        return text != null ? text : \"\";\n-    }\n-\n-\n-    @Override\n-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n-        super.onActivityResult(requestCode, resultCode, data);\n-\n-        if (resultCode == DeckPicker.RESULT_DB_ERROR) {\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n-        }\n-\n-        if (resultCode == DeckPicker.RESULT_MEDIA_EJECTED) {\n-            finishNoStorageAvailable();\n-        }\n-\n-        /* Reset the schedule and reload the latest card off the top of the stack if required.\n-           The card could have been rescheduled, the deck could have changed, or a change of\n-           note type could have lead to the card being deleted */\n-        if (data != null && data.hasExtra(\"reloadRequired\")) {\n-            getCol().getSched().reset();\n-            CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler,\n-                    new CollectionTask.TaskData(null, 0));\n-        }\n-\n-        if (requestCode == EDIT_CURRENT_CARD) {\n-            if (resultCode == RESULT_OK) {\n-                // content of note was changed so update the note and current card\n-                Timber.i(\"AbstractFlashcardViewer:: Saving card...\");\n-                CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_UPDATE_NOTE, mUpdateCardHandler,\n-                        new CollectionTask.TaskData(sEditorCard, true));\n-            } else if (resultCode == RESULT_CANCELED && !(data!=null && data.hasExtra(\"reloadRequired\"))) {\n-                // nothing was changed by the note editor so just redraw the card\n-                redrawCard();\n-            }\n-        } else if (requestCode == DECK_OPTIONS && resultCode == RESULT_OK) {\n-            getCol().getSched().reset();\n-            CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler,\n-                    new CollectionTask.TaskData(null, 0));\n-        }\n-        if (!mDisableClipboard) {\n-            clipboardSetText(\"\");\n-        }\n-    }\n-\n-\n-    // ----------------------------------------------------------------------------\n-    // CUSTOM METHODS\n-    // ----------------------------------------------------------------------------\n-\n-    // Get the did of the parent deck (ignoring any subdecks)\n-    protected long getParentDid() {\n-        long deckID = getCol().getDecks().selected();\n-        return deckID;\n-    }\n-\n-    private void redrawCard() {\n-        //#3654 We can call this from ActivityResult, which could mean that the card content hasn't yet been set\n-        //if the activity was destroyed. In this case, just wait until onCollectionLoaded callback succeeds.\n-        if (hasLoadedCardContent()) {\n-            fillFlashcard();\n-        } else {\n-            Timber.i(\"Skipping card redraw - card still initialising.\");\n-        }\n-    }\n-\n-    /** Whether the callback to onCollectionLoaded has loaded card content */\n-    private boolean hasLoadedCardContent() {\n-        return mCardContent != null;\n-    }\n-\n-\n-    public GestureDetectorCompat getGestureDetector() {\n-        return gestureDetector;\n-    }\n-\n-\n-    /**\n-     * Show/dismiss dialog when sd card is ejected/remounted (collection is saved by SdCardReceiver)\n-     */\n-    private void registerExternalStorageListener() {\n-        if (mUnmountReceiver == null) {\n-            mUnmountReceiver = new BroadcastReceiver() {\n-                @Override\n-                public void onReceive(Context context, Intent intent) {\n-                    if (intent.getAction().equals(SdCardReceiver.MEDIA_EJECT)) {\n-                        finishWithoutAnimation();\n-                    }\n-                }\n-            };\n-            IntentFilter iFilter = new IntentFilter();\n-            iFilter.addAction(SdCardReceiver.MEDIA_EJECT);\n-            registerReceiver(mUnmountReceiver, iFilter);\n-        }\n-    }\n-\n-\n-    private void pauseTimer() {\n-        if (mCurrentCard != null) {\n-            mCurrentCard.stopTimer();\n-        }\n-        // We also stop the UI timer so it doesn't trigger the tick listener while paused. Letting\n-        // it run would trigger the time limit condition (red, stopped timer) in the background.\n-        if (mCardTimer != null) {\n-            mCardTimer.stop();\n-        }\n-    }\n-\n-\n-    private void resumeTimer() {\n-        if (mCurrentCard != null) {\n-            // Resume the card timer first. It internally accounts for the time gap between\n-            // suspend and resume.\n-            mCurrentCard.resumeTimer();\n-            // Then update and resume the UI timer. Set the base time as if the timer had started\n-            // timeTaken() seconds ago.\n-            mCardTimer.setBase(SystemClock.elapsedRealtime() - mCurrentCard.timeTaken());\n-            // Don't start the timer if we have already reached the time limit or it will tick over\n-            if ((SystemClock.elapsedRealtime() - mCardTimer.getBase()) < mCurrentCard.timeLimit()) {\n-                mCardTimer.start();\n-            }\n-        }\n-    }\n-\n-\n-    protected void undo() {\n-        if (getCol().undoAvailable()) {\n-            blockControls();\n-            CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_UNDO, mAnswerCardHandler);\n-        }\n-    }\n-\n-\n-    private void finishNoStorageAvailable() {\n-        AbstractFlashcardViewer.this.setResult(DeckPicker.RESULT_MEDIA_EJECTED);\n-        finishWithoutAnimation();\n-    }\n-\n-\n-    protected boolean editCard() {\n-        if (mCurrentCard == null) {\n-            // This should never occurs. It means the review button was pressed while there is no more card in the reviewer.\n-            return true;\n-        }\n-        Intent editCard = new Intent(AbstractFlashcardViewer.this, NoteEditor.class);\n-        editCard.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER);\n-        sEditorCard = mCurrentCard;\n-        startActivityForResultWithAnimation(editCard, EDIT_CURRENT_CARD, ActivityTransitionAnimation.LEFT);\n-        return true;\n-    }\n-\n-\n-    protected void generateQuestionSoundList() {\n-        mSoundPlayer.addSounds(mBaseUrl, mCurrentCard.qSimple(), Sound.SOUNDS_QUESTION);\n-    }\n-\n-\n-    protected void lookUpOrSelectText() {\n-        if (clipboardHasText()) {\n-            Timber.d(\"Clipboard has text = \" + clipboardHasText());\n-            lookUp();\n-        } else {\n-            selectAndCopyText();\n-        }\n-    }\n-\n-\n-    private boolean lookUp() {\n-        mLookUpIcon.setVisibility(View.GONE);\n-        mIsSelecting = false;\n-        if (Lookup.lookUp(clipboardGetText().toString())) {\n-            clipboardSetText(\"\");\n-        }\n-        return true;\n-    }\n-\n-\n-    private void showLookupButtonIfNeeded() {\n-        if (!mDisableClipboard && mClipboard != null) {\n-            if (clipboardGetText().length() != 0 && Lookup.isAvailable() && mLookUpIcon.getVisibility() != View.VISIBLE) {\n-                mLookUpIcon.setVisibility(View.VISIBLE);\n-                enableViewAnimation(mLookUpIcon, ViewAnimation.fade(ViewAnimation.FADE_IN, mFadeDuration, 0));\n-            } else if (mLookUpIcon.getVisibility() == View.VISIBLE) {\n-                mLookUpIcon.setVisibility(View.GONE);\n-                enableViewAnimation(mLookUpIcon, ViewAnimation.fade(ViewAnimation.FADE_OUT, mFadeDuration, 0));\n-            }\n-        }\n-    }\n-\n-\n-    private void hideLookupButton() {\n-        if (!mDisableClipboard && mLookUpIcon.getVisibility() != View.GONE) {\n-            mLookUpIcon.setVisibility(View.GONE);\n-            enableViewAnimation(mLookUpIcon, ViewAnimation.fade(ViewAnimation.FADE_OUT, mFadeDuration, 0));\n-            clipboardSetText(\"\");\n-        }\n-    }\n-\n-\n-    protected void showDeleteNoteDialog() {\n-        Resources res = getResources();\n-        new MaterialDialog.Builder(this)\n-                .title(res.getString(R.string.delete_card_title))\n-                .iconAttr(R.attr.dialogErrorIcon)\n-                .content(String.format(res.getString(R.string.delete_note_message),\n-                        Utils.stripHTML(mCurrentCard.q(true))))\n-                .positiveText(res.getString(R.string.dialog_positive_delete))\n-                .negativeText(res.getString(R.string.dialog_cancel))\n-                .onPositive((dialog, which) -> {\n-                    Timber.i(\"AbstractFlashcardViewer:: OK button pressed to delete note %d\", mCurrentCard.getNid());\n-                    mSoundPlayer.stopSounds();\n-                    dismiss(Collection.DismissType.DELETE_NOTE);\n-                })\n-                .build().show();\n-    }\n-\n-\n-    private int getRecommendedEase(boolean easy) {\n-        try {\n-            switch (mSched.answerButtons(mCurrentCard)) {\n-                case 2:\n-                    return EASE_2;\n-                case 3:\n-                    return easy ? EASE_3 : EASE_2;\n-                case 4:\n-                    return easy ? EASE_4 : EASE_3;\n-                default:\n-                    return 0;\n-            }\n-        } catch (RuntimeException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"AbstractReviewer-getRecommendedEase\");\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, true);\n-            return 0;\n-        }\n-    }\n-\n-\n-    protected void answerCard(int ease) {\n-        if (mInAnswer) {\n-            return;\n-        }\n-        mIsSelecting = false;\n-        hideLookupButton();\n-        int buttonNumber = getCol().getSched().answerButtons(mCurrentCard);\n-        // Detect invalid ease for current card (e.g. by using keyboard shortcut or gesture).\n-        if (buttonNumber < ease) {\n-            return;\n-        }\n-        // Set the dots appearing below the toolbar\n-        switch (ease) {\n-            case EASE_1:\n-                mChosenAnswer.setText(\"\\u2022\");\n-                mChosenAnswer.setTextColor(ContextCompat.getColor(this, R.color.material_red_500));\n-                break;\n-            case EASE_2:\n-                mChosenAnswer.setText(\"\\u2022\\u2022\");\n-                mChosenAnswer.setTextColor(ContextCompat.getColor(this, buttonNumber == Consts.BUTTON_FOUR ?\n-                        R.color.material_blue_grey_600:\n-                        R.color.material_green_500));\n-                break;\n-            case EASE_3:\n-                mChosenAnswer.setText(\"\\u2022\\u2022\\u2022\");\n-                mChosenAnswer.setTextColor(ContextCompat.getColor(this, buttonNumber == Consts.BUTTON_FOUR ?\n-                        R.color.material_green_500 :\n-                        R.color.material_light_blue_500));\n-                break;\n-            case EASE_4:\n-                mChosenAnswer.setText(\"\\u2022\\u2022\\u2022\\u2022\");\n-                mChosenAnswer.setTextColor(ContextCompat.getColor(this, R.color.material_light_blue_500));\n-                break;\n-            default:\n-                Timber.w(\"Unknown easy type %s\", ease);\n-                break;\n-        }\n-\n-        // remove chosen answer hint after a while\n-        mTimerHandler.removeCallbacks(removeChosenAnswerText);\n-        mTimerHandler.postDelayed(removeChosenAnswerText, mShowChosenAnswerLength);\n-        mSoundPlayer.stopSounds();\n-        mCurrentEase = ease;\n-\n-        CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler,\n-                new CollectionTask.TaskData(mCurrentCard, mCurrentEase));\n-    }\n-\n-\n-    // Set the content view to the one provided and initialize accessors.\n-    @SuppressWarnings(\"deprecation\") // Tracked separately as #5023 on github for clipboard\n-    protected void initLayout() {\n-        FrameLayout mCardContainer = (FrameLayout) findViewById(R.id.flashcard_frame);\n-\n-        mTopBarLayout = (RelativeLayout) findViewById(R.id.top_bar);\n-\n-        ImageView mark = mTopBarLayout.findViewById(R.id.mark_icon);\n-        ImageView flag = mTopBarLayout.findViewById(R.id.flag_icon);\n-        mCardMarker = new CardMarker(mark, flag);\n-\n-        mCardFrame = (FrameLayout) findViewById(R.id.flashcard);\n-        mCardFrameParent = (ViewGroup) mCardFrame.getParent();\n-        mTouchLayer = (FrameLayout) findViewById(R.id.touch_layer);\n-        mTouchLayer.setOnTouchListener(mGestureListener);\n-        if (!mDisableClipboard) {\n-            mClipboard = (android.text.ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);\n-        }\n-        mCardFrame.removeAllViews();\n-\n-        // Initialize swipe\n-        gestureDetector = new GestureDetectorCompat(this, new MyGestureDetector());\n-\n-        mEase1 = (TextView) findViewById(R.id.ease1);\n-        mEase1.setTypeface(TypefaceHelper.get(this, \"Roboto-Medium\"));\n-        mEase1Layout = (LinearLayout) findViewById(R.id.flashcard_layout_ease1);\n-        mEase1Layout.setOnClickListener(mSelectEaseHandler);\n-\n-        mEase2 = (TextView) findViewById(R.id.ease2);\n-        mEase2.setTypeface(TypefaceHelper.get(this, \"Roboto-Medium\"));\n-        mEase2Layout = (LinearLayout) findViewById(R.id.flashcard_layout_ease2);\n-        mEase2Layout.setOnClickListener(mSelectEaseHandler);\n-\n-        mEase3 = (TextView) findViewById(R.id.ease3);\n-        mEase3.setTypeface(TypefaceHelper.get(this, \"Roboto-Medium\"));\n-        mEase3Layout = (LinearLayout) findViewById(R.id.flashcard_layout_ease3);\n-        mEase3Layout.setOnClickListener(mSelectEaseHandler);\n-\n-        mEase4 = (TextView) findViewById(R.id.ease4);\n-        mEase4.setTypeface(TypefaceHelper.get(this, \"Roboto-Medium\"));\n-        mEase4Layout = (LinearLayout) findViewById(R.id.flashcard_layout_ease4);\n-        mEase4Layout.setOnClickListener(mSelectEaseHandler);\n-\n-        mNext1 = (TextView) findViewById(R.id.nextTime1);\n-        mNext2 = (TextView) findViewById(R.id.nextTime2);\n-        mNext3 = (TextView) findViewById(R.id.nextTime3);\n-        mNext4 = (TextView) findViewById(R.id.nextTime4);\n-        mNext1.setTypeface(TypefaceHelper.get(this, \"Roboto-Regular\"));\n-        mNext2.setTypeface(TypefaceHelper.get(this, \"Roboto-Regular\"));\n-        mNext3.setTypeface(TypefaceHelper.get(this, \"Roboto-Regular\"));\n-        mNext4.setTypeface(TypefaceHelper.get(this, \"Roboto-Regular\"));\n-\n-        if (!mShowNextReviewTime) {\n-            mNext1.setVisibility(View.GONE);\n-            mNext2.setVisibility(View.GONE);\n-            mNext3.setVisibility(View.GONE);\n-            mNext4.setVisibility(View.GONE);\n-        }\n-\n-        Button mFlipCard = (Button) findViewById(R.id.flip_card);\n-        mFlipCard.setTypeface(TypefaceHelper.get(this, \"Roboto-Medium\"));\n-        mFlipCardLayout = (LinearLayout) findViewById(R.id.flashcard_layout_flip);\n-        mFlipCardLayout.setOnClickListener(mFlipCardListener);\n-\n-        if (!mButtonHeightSet && mRelativeButtonSize != 100) {\n-            ViewGroup.LayoutParams params = mFlipCardLayout.getLayoutParams();\n-            params.height = params.height * mRelativeButtonSize / 100;\n-            params = mEase1Layout.getLayoutParams();\n-            params.height = params.height * mRelativeButtonSize / 100;\n-            params = mEase2Layout.getLayoutParams();\n-            params.height = params.height * mRelativeButtonSize / 100;\n-            params = mEase3Layout.getLayoutParams();\n-            params.height = params.height * mRelativeButtonSize / 100;\n-            params = mEase4Layout.getLayoutParams();\n-            params.height = params.height * mRelativeButtonSize / 100;\n-            mButtonHeightSet = true;\n-        }\n-\n-        mTextBarNew = (TextView) findViewById(R.id.new_number);\n-        mTextBarLearn = (TextView) findViewById(R.id.learn_number);\n-        mTextBarReview = (TextView) findViewById(R.id.review_number);\n-\n-        if (!mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.GONE);\n-            mTextBarLearn.setVisibility(View.GONE);\n-            mTextBarReview.setVisibility(View.GONE);\n-        }\n-\n-        mCardTimer = (Chronometer) findViewById(R.id.card_time);\n-\n-        mChosenAnswer = (TextView) findViewById(R.id.choosen_answer);\n-\n-        mAnswerField = (EditText) findViewById(R.id.answer_field);\n-\n-        mLookUpIcon = findViewById(R.id.lookup_button);\n-        mLookUpIcon.setVisibility(View.GONE);\n-        mLookUpIcon.setOnClickListener(new OnClickListener() {\n-\n-            @Override\n-            public void onClick(View arg0) {\n-                Timber.i(\"AbstractFlashcardViewer:: Lookup button pressed\");\n-                if (clipboardHasText()) {\n-                    lookUp();\n-                }\n-            }\n-\n-        });\n-        initControls();\n-\n-        // Position answer buttons\n-        String answerButtonsPosition = AnkiDroidApp.getSharedPrefs(this).getString(\n-                getString(R.string.answer_buttons_position_preference),\n-                \"bottom\"\n-        );\n-        LinearLayout answerArea = (LinearLayout) findViewById(R.id.bottom_area_layout);\n-        RelativeLayout.LayoutParams answerAreaParams = (RelativeLayout.LayoutParams) answerArea.getLayoutParams();\n-        RelativeLayout.LayoutParams cardContainerParams = (RelativeLayout.LayoutParams) mCardContainer.getLayoutParams();\n-\n-        switch (answerButtonsPosition) {\n-            case \"top\":\n-                cardContainerParams.addRule(RelativeLayout.BELOW, R.id.bottom_area_layout);\n-                answerAreaParams.addRule(RelativeLayout.BELOW, R.id.top_bar);\n-                answerArea.removeView(mAnswerField);\n-                answerArea.addView(mAnswerField, 1);\n-                break;\n-            case \"bottom\":\n-                cardContainerParams.addRule(RelativeLayout.ABOVE, R.id.bottom_area_layout);\n-                cardContainerParams.addRule(RelativeLayout.BELOW, R.id.top_bar);\n-                answerAreaParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);\n-                break;\n-            default:\n-                Timber.w(\"Unknown answerButtonsPosition: %s\", answerButtonsPosition);\n-                break;\n-        }\n-        answerArea.setLayoutParams(answerAreaParams);\n-        mCardContainer.setLayoutParams(cardContainerParams);\n-    }\n-\n-\n-    @SuppressLint(\"SetJavaScriptEnabled\") // they request we review carefully because of XSS security, we have\n-    private WebView createWebView() {\n-        WebView webView = new MyWebView(this);\n-        webView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_OVERLAY);\n-        webView.getSettings().setDisplayZoomControls(false);\n-        webView.getSettings().setBuiltInZoomControls(true);\n-        webView.getSettings().setSupportZoom(true);\n-        // Start at the most zoomed-out level\n-        webView.getSettings().setLoadWithOverviewMode(true);\n-        webView.getSettings().setJavaScriptEnabled(true);\n-        webView.setWebChromeClient(new AnkiDroidWebChromeClient());\n-        // Problems with focus and input tags is the reason we keep the old type answer mechanism for old Androids.\n-        webView.setFocusableInTouchMode(mUseInputTag);\n-        webView.setScrollbarFadingEnabled(true);\n-        Timber.d(\"Focusable = %s, Focusable in touch mode = %s\", webView.isFocusable(), webView.isFocusableInTouchMode());\n-\n-        webView.setWebViewClient(new CardViewerWebClient());\n-        // Set transparent color to prevent flashing white when night mode enabled\n-        webView.setBackgroundColor(Color.argb(1, 0, 0, 0));\n-        return webView;\n-    }\n-\n-    /** If a card is displaying the question, flip it, otherwise answer it */\n-    private void flipOrAnswerCard(int cardOrdinal) {\n-        if (!sDisplayAnswer) {\n-           displayCardAnswer();\n-           return;\n-        }\n-        answerCard(cardOrdinal);\n-    }\n-\n-    private boolean webViewRendererLastCrashedOnCard(long cardId) {\n-        return lastCrashingCardId != null && lastCrashingCardId == cardId;\n-    }\n-\n-\n-    private boolean canRecoverFromWebViewRendererCrash() {\n-        // DEFECT\n-        // If we don't have a card to render, we're in a bad state. The class doesn't currently track state\n-        // well enough to be able to know exactly where we are in the initialisation pipeline.\n-        // so it's best to mark the crash as non-recoverable.\n-        // We should fix this, but it's very unlikely that we'll ever get here. Logs will tell\n-\n-        // Revisit webViewCrashedOnCard() if changing this. Logic currently assumes we have a card.\n-        return mCurrentCard != null;\n-    }\n-\n-    //#5780 - Users could OOM the WebView Renderer. This triggers the same symptoms\n-    @VisibleForTesting()\n-    @SuppressWarnings(\"unused\")\n-    public void crashWebViewRenderer() {\n-        loadUrlInViewer(\"chrome://crash\");\n-    }\n-\n-\n-    /** Used to set the \"javascript:\" URIs for IPC */\n-    private void loadUrlInViewer(final String url) {\n-        processCardAction(card -> card.loadUrl(url));\n-    }\n-\n-    private <T extends View> T inflateNewView(@IdRes int id) {\n-        int layoutId = getContentViewAttr(mPrefFullscreenReview);\n-        ViewGroup content = (ViewGroup) LayoutInflater.from(AbstractFlashcardViewer.this).inflate(layoutId, null, false);\n-        T ret = content.findViewById(id);\n-        ((ViewGroup) ret.getParent()).removeView(ret); //detach the view from its parent\n-        content.removeAllViews();\n-        return ret;\n-    }\n-\n-    private void destroyWebView(WebView webView) {\n-        try {\n-            if (webView != null) {\n-                webView.stopLoading();\n-                webView.setWebChromeClient(null);\n-                webView.setWebViewClient(null);\n-                webView.destroy();\n-            }\n-        } catch (NullPointerException npe) {\n-            Timber.e(npe, \"WebView became null on destruction\");\n-        }\n-    }\n-\n-    protected boolean shouldShowNextReviewTime() {\n-        return mShowNextReviewTime;\n-    }\n-\n-    protected void displayAnswerBottomBar() {\n-        // hide flipcard button\n-        mFlipCardLayout.setVisibility(View.GONE);\n-    }\n-\n-\n-    protected void hideEaseButtons() {\n-        mEase1Layout.setVisibility(View.GONE);\n-        mEase2Layout.setVisibility(View.GONE);\n-        mEase3Layout.setVisibility(View.GONE);\n-        mEase4Layout.setVisibility(View.GONE);\n-        mFlipCardLayout.setVisibility(View.VISIBLE);\n-        focusAnswerCompletionField();\n-    }\n-\n-    /**\n-     * Focuses the appropriate field for an answer\n-     * And allows keyboard shortcuts to go to the default handlers.\n-     * */\n-    private void focusAnswerCompletionField() {\n-        // This does not handle mUseInputTag (the WebView contains an input field with a typable answer).\n-        // In this case, the user can use touch to focus the field if necessary.\n-        if (typeAnswer()) {\n-            mAnswerField.requestFocus();\n-        } else {\n-            mFlipCardLayout.requestFocus();\n-        }\n-    }\n-\n-\n-    private void switchTopBarVisibility(int visible) {\n-        if (mShowTimer) {\n-            mCardTimer.setVisibility(visible);\n-        }\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(visible);\n-            mTextBarLearn.setVisibility(visible);\n-            mTextBarReview.setVisibility(visible);\n-        }\n-        mChosenAnswer.setVisibility(visible);\n-    }\n-\n-\n-    protected void initControls() {\n-        mCardFrame.setVisibility(View.VISIBLE);\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.VISIBLE);\n-            mTextBarLearn.setVisibility(View.VISIBLE);\n-            mTextBarReview.setVisibility(View.VISIBLE);\n-        }\n-        mChosenAnswer.setVisibility(View.VISIBLE);\n-        mFlipCardLayout.setVisibility(View.VISIBLE);\n-\n-        mAnswerField.setVisibility(typeAnswer() ? View.VISIBLE : View.GONE);\n-        mAnswerField.setOnEditorActionListener(new EditText.OnEditorActionListener() {\n-            @Override\n-            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {\n-                if (actionId == EditorInfo.IME_ACTION_DONE) {\n-                    displayCardAnswer();\n-                    return true;\n-                }\n-                return false;\n-            }\n-        });\n-        mAnswerField.setOnKeyListener(new View.OnKeyListener() {\n-            @Override\n-            public boolean onKey(View v, int keyCode, KeyEvent event) {\n-                if (event.getAction() == KeyEvent.ACTION_UP &&\n-                        (keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_NUMPAD_ENTER)) {\n-                    displayCardAnswer();\n-                    return true;\n-                }\n-                return false;\n-            }\n-        });\n-    }\n-\n-\n-    protected SharedPreferences restorePreferences() {\n-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());\n-\n-        mPrefHideDueCount = preferences.getBoolean(\"hideDueCount\", false);\n-        mPrefShowETA = preferences.getBoolean(\"showETA\", true);\n-        mUseInputTag = preferences.getBoolean(\"useInputTag\", false);\n-        // On newer Androids, ignore this setting, which should be hidden in the prefs anyway.\n-        mDisableClipboard = \"0\".equals(preferences.getString(\"dictionary\", \"0\"));\n-        // mDeckFilename = preferences.getString(\"deckFilename\", \"\");\n-        mPrefFullscreenReview = Integer.parseInt(preferences.getString(\"fullscreenMode\", \"0\"));\n-        mRelativeButtonSize = preferences.getInt(\"answerButtonSize\", 100);\n-        mSpeakText = preferences.getBoolean(\"tts\", false);\n-        mPrefUseTimer = preferences.getBoolean(\"timeoutAnswer\", false);\n-        mPrefWaitAnswerSecond = preferences.getInt(\"timeoutAnswerSeconds\", 20);\n-        mPrefWaitQuestionSecond = preferences.getInt(\"timeoutQuestionSeconds\", 60);\n-        mScrollingButtons = preferences.getBoolean(\"scrolling_buttons\", false);\n-        mDoubleScrolling = preferences.getBoolean(\"double_scrolling\", false);\n-\n-        mGesturesEnabled = AnkiDroidApp.initiateGestures(preferences);\n-        if (mGesturesEnabled) {\n-            mGestureSwipeUp = Integer.parseInt(preferences.getString(\"gestureSwipeUp\", \"9\"));\n-            mGestureSwipeDown = Integer.parseInt(preferences.getString(\"gestureSwipeDown\", \"0\"));\n-            mGestureSwipeLeft = Integer.parseInt(preferences.getString(\"gestureSwipeLeft\", \"8\"));\n-            mGestureSwipeRight = Integer.parseInt(preferences.getString(\"gestureSwipeRight\", \"17\"));\n-            mGestureDoubleTap = Integer.parseInt(preferences.getString(\"gestureDoubleTap\", \"7\"));\n-            mGestureTapLeft = Integer.parseInt(preferences.getString(\"gestureTapLeft\", \"3\"));\n-            mGestureTapRight = Integer.parseInt(preferences.getString(\"gestureTapRight\", \"6\"));\n-            mGestureTapTop = Integer.parseInt(preferences.getString(\"gestureTapTop\", \"12\"));\n-            mGestureTapBottom = Integer.parseInt(preferences.getString(\"gestureTapBottom\", \"2\"));\n-            mGestureLongclick = Integer.parseInt(preferences.getString(\"gestureLongclick\", \"11\"));\n-        }\n-\n-        if (preferences.getBoolean(\"keepScreenOn\", false)) {\n-            this.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n-        }\n-\n-        return preferences;\n-    }\n-\n-\n-    private void restoreCollectionPreferences() {\n-\n-        // These are preferences we pull out of the collection instead of SharedPreferences\n-        try {\n-            mShowNextReviewTime = getCol().getConf().getBoolean(\"estTimes\");\n-            mShowRemainingCardCount = getCol().getConf().getBoolean(\"dueCounts\");\n-\n-            // Dynamic don't have review options; attempt to get deck-specific auto-advance options\n-            // but be prepared to go with all default if it's a dynamic deck\n-            JSONObject revOptions = new JSONObject();\n-            long selectedDid = getCol().getDecks().selected();\n-            if (!getCol().getDecks().isDyn(selectedDid)) {\n-                revOptions = getCol().getDecks().confForDid(selectedDid).getJSONObject(\"rev\");\n-            }\n-\n-            mOptUseGeneralTimerSettings = revOptions.optBoolean(\"useGeneralTimeoutSettings\", true);\n-            mOptUseTimer = revOptions.optBoolean(\"timeoutAnswer\", false);\n-            mOptWaitAnswerSecond = revOptions.optInt(\"timeoutAnswerSeconds\", 20);\n-            mOptWaitQuestionSecond = revOptions.optInt(\"timeoutQuestionSeconds\", 60);\n-        } catch (JSONException e) {\n-            Timber.e(e, \"Unable to restoreCollectionPreferences\");\n-            throw new RuntimeException(e);\n-        } catch (NullPointerException npe) {\n-            // NPE on collection only happens if the Collection is broken, follow AnkiActivity example\n-            Intent deckPicker = new Intent(this, DeckPicker.class);\n-            deckPicker.putExtra(\"collectionLoadError\", true); // don't currently do anything with this\n-            deckPicker.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n-            startActivityWithAnimation(deckPicker, ActivityTransitionAnimation.LEFT);\n-        }\n-    }\n-\n-\n-    private void setInterface() {\n-        if (mCurrentCard == null) {\n-            return;\n-        }\n-        recreateWebView();\n-    }\n-\n-    private void recreateWebView() {\n-        if (mCard == null) {\n-            mCard = createWebView();\n-            WebViewDebugging.initializeDebugging(AnkiDroidApp.getSharedPrefs(this));\n-            mCardFrame.addView(mCard);\n-        }\n-        if (mCard.getVisibility() != View.VISIBLE) {\n-            mCard.setVisibility(View.VISIBLE);\n-        }\n-    }\n-\n-\n-    private void updateForNewCard() {\n-        updateScreenCounts();\n-\n-        // Clean answer field\n-        if (typeAnswer()) {\n-            mAnswerField.setText(\"\");\n-        }\n-\n-        if (mPrefWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.clear();\n-        }\n-    }\n-\n-\n-    protected void updateScreenCounts() {\n-        if (mCurrentCard == null) return;\n-        ActionBar actionBar = getSupportActionBar();\n-        int[] counts = mSched.counts(mCurrentCard);\n-\n-        if (actionBar != null) {\n-            String title = Decks.basename(getCol().getDecks().get(mCurrentCard.getDid()).getString(\"name\"));\n-            actionBar.setTitle(title);\n-            if (mPrefShowETA) {\n-                int eta = mSched.eta(counts, false);\n-                actionBar.setSubtitle(Utils.remainingTime(AnkiDroidApp.getInstance(), eta * 60));\n-            }\n-        }\n-\n-        SpannableString newCount = new SpannableString(String.valueOf(counts[0]));\n-        SpannableString lrnCount = new SpannableString(String.valueOf(counts[1]));\n-        SpannableString revCount = new SpannableString(String.valueOf(counts[2]));\n-        if (mPrefHideDueCount) {\n-            revCount = new SpannableString(\"???\");\n-        }\n-\n-        switch (mSched.countIdx(mCurrentCard)) {\n-            case Consts.CARD_TYPE_NEW:\n-                newCount.setSpan(new UnderlineSpan(), 0, newCount.length(), 0);\n-                break;\n-            case Consts.CARD_TYPE_LRN:\n-                lrnCount.setSpan(new UnderlineSpan(), 0, lrnCount.length(), 0);\n-                break;\n-            case Consts.CARD_TYPE_REV:\n-                revCount.setSpan(new UnderlineSpan(), 0, revCount.length(), 0);\n-                break;\n-            default:\n-                Timber.w(\"Unknown card type %s\", mSched.countIdx(mCurrentCard));\n-                break;\n-        }\n-\n-        mTextBarNew.setText(newCount);\n-        mTextBarLearn.setText(lrnCount);\n-        mTextBarReview.setText(revCount);\n-    }\n-\n-    /*\n-     * Handler for the delay in auto showing question and/or answer One toggle for both question and answer, could set\n-     * longer delay for auto next question\n-     */\n-    protected Handler mTimeoutHandler = new Handler();\n-\n-    protected Runnable mShowQuestionTask = new Runnable() {\n-        @Override\n-        public void run() {\n-            // Assume hitting the \"Again\" button when auto next question\n-            if (mEase1Layout.isEnabled() && mEase1Layout.getVisibility() == View.VISIBLE) {\n-                mEase1Layout.performClick();\n-            }\n-        }\n-    };\n-\n-    protected Runnable mShowAnswerTask = new Runnable() {\n-        @Override\n-        public void run() {\n-            if (mFlipCardLayout.isEnabled() && mFlipCardLayout.getVisibility() == View.VISIBLE) {\n-                mFlipCardLayout.performClick();\n-            }\n-        }\n-    };\n-\n-\n-    protected void initTimer() {\n-        final TypedValue typedValue = new TypedValue();\n-        mShowTimer = mCurrentCard.showTimer();\n-        if (mShowTimer && mCardTimer.getVisibility() == View.INVISIBLE) {\n-            mCardTimer.setVisibility(View.VISIBLE);\n-        } else if (!mShowTimer && mCardTimer.getVisibility() != View.INVISIBLE) {\n-            mCardTimer.setVisibility(View.INVISIBLE);\n-        }\n-        // Set normal timer color\n-        getTheme().resolveAttribute(android.R.attr.textColor, typedValue, true);\n-        mCardTimer.setTextColor(typedValue.data);\n-\n-        mCardTimer.setBase(SystemClock.elapsedRealtime());\n-        mCardTimer.start();\n-\n-        // Stop and highlight the timer if it reaches the time limit.\n-        getTheme().resolveAttribute(R.attr.maxTimerColor, typedValue, true);\n-        final int limit = mCurrentCard.timeLimit();\n-        mCardTimer.setOnChronometerTickListener(new Chronometer.OnChronometerTickListener() {\n-            @Override\n-            public void onChronometerTick(Chronometer chronometer) {\n-                long elapsed = SystemClock.elapsedRealtime() - chronometer.getBase();\n-                if (elapsed >= limit) {\n-                    chronometer.setTextColor(typedValue.data);\n-                    chronometer.stop();\n-                }\n-            }\n-        });\n-    }\n-\n-\n-    protected void displayCardQuestion() {\n-        Timber.d(\"displayCardQuestion()\");\n-        sDisplayAnswer = false;\n-\n-        setInterface();\n-\n-        String question;\n-        String displayString = \"\";\n-        if (mCurrentCard.isEmpty()) {\n-            displayString = getResources().getString(R.string.empty_card_warning);\n-        } else {\n-            question = mCurrentCard.q();\n-            question = getCol().getMedia().escapeImages(question);\n-            question = typeAnsQuestionFilter(question);\n-\n-            Timber.v(\"question: '%s'\", question);\n-            // Show text entry based on if the user wants to write the answer\n-            if (typeAnswer()) {\n-                mAnswerField.setVisibility(View.VISIBLE);\n-            } else {\n-                mAnswerField.setVisibility(View.GONE);\n-            }\n-\n-            displayString = CardAppearance.enrichWithQADiv(question, false);\n-\n-            //if (mSpeakText) {\n-            // ReadText.setLanguageInformation(Model.getModel(DeckManager.getMainDeck(),\n-            // mCurrentCard.getCardModelId(), false).getId(), mCurrentCard.getCardModelId());\n-            //}\n-        }\n-\n-        updateCard(displayString);\n-        hideEaseButtons();\n-\n-        // Check if it should use the general 'Timeout settings' or the ones specific to this deck\n-        if (mOptUseGeneralTimerSettings) {\n-            mUseTimer = mPrefUseTimer;\n-            mWaitAnswerSecond = mPrefWaitAnswerSecond;\n-            mWaitQuestionSecond = mPrefWaitQuestionSecond;\n-        } else {\n-            mUseTimer = mOptUseTimer;\n-            mWaitAnswerSecond = mOptWaitAnswerSecond;\n-            mWaitQuestionSecond = mOptWaitQuestionSecond;\n-        }\n-\n-        // If the user wants to show the answer automatically\n-        if (mUseTimer) {\n-            long delay = mWaitAnswerSecond * 1000 + mUseTimerDynamicMS;\n-            if (delay > 0) {\n-                mTimeoutHandler.removeCallbacks(mShowAnswerTask);\n-                mTimeoutHandler.postDelayed(mShowAnswerTask, delay);\n-            }\n-        }\n-\n-        Timber.i(\"AbstractFlashcardViewer:: Question successfully shown for card id %d\", mCurrentCard.getId());\n-    }\n-\n-\n-    /**\n-     * Clean up the correct answer text, so it can be used for the comparison with the typed text\n-     *\n-     * @param answer The content of the field the text typed by the user is compared to.\n-     * @return The correct answer text, with actual HTML and media references removed, and HTML entities unescaped.\n-     */\n-    protected String cleanCorrectAnswer(String answer) {\n-        return TypedAnswer.cleanCorrectAnswer(answer);\n-    }\n-\n-\n-    /**\n-     * Clean up the typed answer text, so it can be used for the comparison with the correct answer\n-     *\n-     * @param answer The answer text typed by the user.\n-     * @return The typed answer text, cleaned up.\n-     */\n-    protected String cleanTypedAnswer(String answer) {\n-        if (answer == null || \"\".equals(answer)) {\n-            return \"\";\n-        }\n-        return Utils.nfcNormalized(answer.trim());\n-    }\n-\n-\n-    protected void displayCardAnswer() {\n-        Timber.d(\"displayCardAnswer()\");\n-\n-        // prevent answering (by e.g. gestures) before card is loaded\n-        if (mCurrentCard == null) {\n-            return;\n-        }\n-\n-        // Explicitly hide the soft keyboard. It *should* be hiding itself automatically,\n-        // but sometimes failed to do so (e.g. if an OnKeyListener is attached).\n-        if (typeAnswer()) {\n-            InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n-            inputMethodManager.hideSoftInputFromWindow(mAnswerField.getWindowToken(), 0);\n-        }\n-\n-        sDisplayAnswer = true;\n-\n-        String answer = mCurrentCard.a();\n-\n-        mSoundPlayer.stopSounds();\n-        answer = getCol().getMedia().escapeImages(answer);\n-\n-        mAnswerField.setVisibility(View.GONE);\n-        // Clean up the user answer and the correct answer\n-        String userAnswer;\n-        if (mUseInputTag) {\n-            userAnswer = cleanTypedAnswer(mTypeInput);\n-        } else {\n-            userAnswer = cleanTypedAnswer(mAnswerField.getText().toString());\n-        }\n-        String correctAnswer = cleanCorrectAnswer(mTypeCorrect);\n-        Timber.d(\"correct answer = %s\", correctAnswer);\n-        Timber.d(\"user answer = %s\", userAnswer);\n-\n-        answer = typeAnsAnswerFilter(answer, userAnswer, correctAnswer);\n-\n-        mIsSelecting = false;\n-        updateCard(CardAppearance.enrichWithQADiv(answer, true));\n-        displayAnswerBottomBar();\n-        // If the user wants to show the next question automatically\n-        if (mUseTimer) {\n-            long delay = mWaitQuestionSecond * 1000 + mUseTimerDynamicMS;\n-            if (delay > 0) {\n-                mTimeoutHandler.removeCallbacks(mShowQuestionTask);\n-                mTimeoutHandler.postDelayed(mShowQuestionTask, delay);\n-            }\n-        }\n-    }\n-\n-\n-    /** Scroll the currently shown flashcard vertically\n-     *\n-     * @param dy amount to be scrolled\n-     */\n-    public void scrollCurrentCardBy(int dy) {\n-        processCardAction(card -> {\n-            if (dy != 0 && card.canScrollVertically(dy)) {\n-                card.scrollBy(0, dy);\n-            }\n-        });\n-    }\n-\n-\n-    /** Tap onto the currently shown flashcard at position x and y\n-     *\n-     * @param x horizontal position of the event\n-     * @param y vertical position of the event\n-     */\n-    public void tapOnCurrentCard(int x, int y) {\n-        // assemble suitable ACTION_DOWN and ACTION_UP events and forward them to the card's handler\n-        MotionEvent eDown = MotionEvent.obtain(SystemClock.uptimeMillis(),\n-                SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, x, y,\n-                1, 1, 0, 1, 1, 0, 0);\n-        processCardAction(card -> card.dispatchTouchEvent(eDown));\n-\n-        MotionEvent eUp = MotionEvent.obtain(eDown.getDownTime(),\n-                SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, x, y,\n-                1, 1, 0, 1, 1, 0, 0);\n-        processCardAction(card -> card.dispatchTouchEvent(eUp));\n-\n-    }\n-\n-\n-    /**\n-     * getAnswerFormat returns the answer part of this card's template as entered by user, without any parsing\n-     */\n-    public String getAnswerFormat() {\n-        JSONObject model = mCurrentCard.model();\n-        JSONObject template;\n-        if (model.getInt(\"type\") == Consts.MODEL_STD) {\n-            template = model.getJSONArray(\"tmpls\").getJSONObject(mCurrentCard.getOrd());\n-        } else {\n-            template = model.getJSONArray(\"tmpls\").getJSONObject(0);\n-        }\n-\n-        return template.getString(\"afmt\");\n-    }\n-\n-    private void addAnswerSounds(String answer) {\n-        // don't add answer sounds multiple times, such as when reshowing card after exiting editor\n-        // additionally, this condition reduces computation time\n-        if (!mAnswerSoundsAdded) {\n-            String answerSoundSource = removeFrontSideAudio(answer);\n-            mSoundPlayer.addSounds(mBaseUrl, answerSoundSource, Sound.SOUNDS_ANSWER);\n-            mAnswerSoundsAdded = true;\n-        }\n-    }\n-\n-    protected boolean isInNightMode() {\n-        return mCardAppearance.isNightMode();\n-    }\n-\n-\n-    private void updateCard(final String newContent) {\n-        Timber.d(\"updateCard()\");\n-\n-        mUseTimerDynamicMS = 0;\n-\n-        // Add CSS for font color and font size\n-        if (mCurrentCard == null) {\n-            processCardAction(card -> card.getSettings().setDefaultFontSize(calculateDynamicFontSize(newContent)));\n-        }\n-\n-        if (sDisplayAnswer) {\n-            addAnswerSounds(newContent);\n-        } else {\n-            // reset sounds each time first side of card is displayed, which may happen repeatedly without ever\n-            // leaving the card (such as when edited)\n-            mSoundPlayer.resetSounds();\n-            mAnswerSoundsAdded = false;\n-            mSoundPlayer.addSounds(mBaseUrl, newContent, Sound.SOUNDS_QUESTION);\n-            if (mUseTimer && !mAnswerSoundsAdded && getConfigForCurrentCard().optBoolean(\"autoplay\", false)) {\n-                addAnswerSounds(mCurrentCard.a());\n-            }\n-        }\n-\n-        String content = Sound.expandSounds(mBaseUrl, newContent);\n-\n-        content = CardAppearance.fixBoldStyle(content);\n-\n-        Timber.v(\"content card = \\n %s\", content);\n-\n-        String style = mCardAppearance.getStyle();\n-        Timber.v(\"::style:: / %s\", style);\n-\n-        // CSS class for card-specific styling\n-        String cardClass = mCardAppearance.getCardClass(mCurrentCard.getOrd() + 1, Themes.getCurrentTheme(this));\n-        if (Template.textContainsMathjax(content)) {\n-            cardClass += \" mathjax-needs-to-render\";\n-        }\n-\n-        if (isInNightMode()) {\n-            // If card styling doesn't contain any mention of the night_mode class then do color inversion as fallback\n-            // TODO: find more robust solution that won't match unrelated classes like \"night_mode_old\"\n-            if (!mCurrentCard.css().contains(\".night_mode\")) {\n-                content = HtmlColors.invertColors(content);\n-            }\n-        }\n-\n-\n-        content = CardAppearance.convertSmpToHtmlEntity(content);\n-        mCardContent = new SpannedString(mCardTemplate.replace(\"::content::\", content)\n-                .replace(\"::style::\", style).replace(\"::class::\", cardClass));\n-        Timber.d(\"base url = %s\", mBaseUrl);\n-\n-        if (AnkiDroidApp.getSharedPrefs(this).getBoolean(\"html_javascript_debugging\", false)) {\n-            try {\n-                try (FileOutputStream f = new FileOutputStream(new File(CollectionHelper.getCurrentAnkiDroidDirectory(this),\n-                        \"card.html\"))) {\n-                    f.write(mCardContent.toString().getBytes());\n-                }\n-            } catch (IOException e) {\n-                Timber.d(e, \"failed to save card\");\n-            }\n-        }\n-        fillFlashcard();\n-\n-        if (!mConfigurationChanged) {\n-            playSounds(false); // Play sounds if appropriate\n-        }\n-    }\n-\n-    /**\n-     * Plays sounds (or TTS, if configured) for currently shown side of card.\n-     *\n-     * @param doAudioReplay indicates an anki desktop-like replay call is desired, whose behavior is identical to\n-     *            pressing the keyboard shortcut R on the desktop\n-     */\n-    protected void playSounds(boolean doAudioReplay) {\n-        boolean replayQuestion = getConfigForCurrentCard().optBoolean(\"replayq\", true);\n-\n-        if (getConfigForCurrentCard().optBoolean(\"autoplay\", false) || doAudioReplay) {\n-            // Use TTS if TTS preference enabled and no other sound source\n-            boolean useTTS = mSpeakText &&\n-                    !(sDisplayAnswer && mSoundPlayer.hasAnswer()) && !(!sDisplayAnswer && mSoundPlayer.hasQuestion());\n-            // We need to play the sounds from the proper side of the card\n-            if (!useTTS) { // Text to speech not in effect here\n-                if (doAudioReplay && replayQuestion && sDisplayAnswer) {\n-                    // only when all of the above are true will question be played with answer, to match desktop\n-                    mSoundPlayer.playSounds(Sound.SOUNDS_QUESTION_AND_ANSWER);\n-                } else if (sDisplayAnswer) {\n-                    mSoundPlayer.playSounds(Sound.SOUNDS_ANSWER);\n-                    if (mUseTimer) {\n-                        mUseTimerDynamicMS = mSoundPlayer.getSoundsLength(Sound.SOUNDS_ANSWER);\n-                    }\n-                } else { // question is displayed\n-                    mSoundPlayer.playSounds(Sound.SOUNDS_QUESTION);\n-                    // If the user wants to show the answer automatically\n-                    if (mUseTimer) {\n-                        mUseTimerDynamicMS = mSoundPlayer.getSoundsLength(Sound.SOUNDS_QUESTION_AND_ANSWER);\n-                    }\n-                }\n-            } else { // Text to speech is in effect here\n-                // If the question is displayed or if the question should be replayed, read the question\n-                if (mTtsInitialized) {\n-                    if (!sDisplayAnswer || doAudioReplay && replayQuestion) {\n-                        readCardText(mCurrentCard, Sound.SOUNDS_QUESTION);\n-                    }\n-                    if (sDisplayAnswer) {\n-                        readCardText(mCurrentCard, Sound.SOUNDS_ANSWER);\n-                    }\n-                } else {\n-                    mReplayOnTtsInit = true;\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Reads the text (using TTS) for the given side of a card.\n-     *\n-     * @param card     The card to play TTS for\n-     * @param cardSide The side of the current card to play TTS for\n-     */\n-    private static void readCardText(final Card card, final int cardSide) {\n-        final String cardSideContent;\n-        if (Sound.SOUNDS_QUESTION == cardSide) {\n-            cardSideContent = card.q(true);\n-        } else if (Sound.SOUNDS_ANSWER == cardSide) {\n-            cardSideContent = card.getPureAnswer();\n-        } else {\n-            Timber.w(\"Unrecognised cardSide\");\n-            return;\n-        }\n-\n-        ReadText.readCardSide(cardSide, cardSideContent, getDeckIdForCard(card), card.getOrd());\n-    }\n-\n-    /**\n-     * Shows the dialogue for selecting TTS for the current card and cardside.\n-     */\n-    protected void showSelectTtsDialogue() {\n-        if (mTtsInitialized) {\n-            if (!sDisplayAnswer) {\n-                ReadText.selectTts(Utils.stripHTML(mCurrentCard.q(true)), getDeckIdForCard(mCurrentCard), mCurrentCard.getOrd(),\n-                        Sound.SOUNDS_QUESTION);\n-            } else {\n-                ReadText.selectTts(Utils.stripHTML(mCurrentCard.getPureAnswer()), getDeckIdForCard(mCurrentCard),\n-                        mCurrentCard.getOrd(), Sound.SOUNDS_ANSWER);\n-            }\n-        }\n-    }\n-\n-\n-    /**\n-     * Returns the configuration for the current {@link Card}.\n-     *\n-     * @return The configuration for the current {@link Card}\n-     */\n-    private JSONObject getConfigForCurrentCard() {\n-        return getCol().getDecks().confForDid(getDeckIdForCard(mCurrentCard));\n-    }\n-\n-\n-    /**\n-     * Returns the deck ID of the given {@link Card}.\n-     *\n-     * @param card The {@link Card} to get the deck ID\n-     * @return The deck ID of the {@link Card}\n-     */\n-    private static long getDeckIdForCard(final Card card) {\n-        // Try to get the configuration by the original deck ID (available in case of a cram deck),\n-        // else use the direct deck ID (in case of a 'normal' deck.\n-        return card.getODid() == 0 ? card.getDid() : card.getODid();\n-    }\n-\n-\n-    public void fillFlashcard() {\n-        Timber.d(\"fillFlashcard()\");\n-        Timber.d(\"base url = %s\", mBaseUrl);\n-        if (mCardContent == null) {\n-            Timber.w(\"fillFlashCard() called with no card content\");\n-            return;\n-        }\n-        final String cardContent = mCardContent.toString();\n-        processCardAction(card -> loadContentIntoCard(card, cardContent));\n-        if (mShowTimer && mCardTimer.getVisibility() == View.INVISIBLE) {\n-            switchTopBarVisibility(View.VISIBLE);\n-        }\n-        if (!sDisplayAnswer) {\n-            updateForNewCard();\n-        }\n-    }\n-\n-\n-    private void loadContentIntoCard(WebView card, String content) {\n-        if (card != null) {\n-            CompatHelper.getCompat().setHTML5MediaAutoPlay(card.getSettings(), getConfigForCurrentCard().optBoolean(\"autoplay\"));\n-            card.loadDataWithBaseURL(mBaseUrl + \"__viewer__.html\", content, \"text/html\", \"utf-8\", null);\n-        }\n-    }\n-\n-\n-    public static Card getEditorCard() {\n-        return sEditorCard;\n-    }\n-\n-\n-    /**\n-     * @return true if the AnkiDroid preference for writing answer is true and if the Anki Deck CardLayout specifies a\n-     *         field to query\n-     */\n-    private boolean typeAnswer() {\n-        return !mUseInputTag && null != mTypeCorrect;\n-    }\n-\n-\n-    private void unblockControls() {\n-        mControlBlocked = false;\n-        mCardFrame.setEnabled(true);\n-        mFlipCardLayout.setEnabled(true);\n-\n-        switch (mCurrentEase) {\n-            case EASE_1:\n-                mEase1Layout.setClickable(true);\n-                mEase2Layout.setEnabled(true);\n-                mEase3Layout.setEnabled(true);\n-                mEase4Layout.setEnabled(true);\n-                break;\n-\n-            case EASE_2:\n-                mEase1Layout.setEnabled(true);\n-                mEase2Layout.setClickable(true);\n-                mEase3Layout.setEnabled(true);\n-                mEase4Layout.setEnabled(true);\n-                break;\n-\n-            case EASE_3:\n-                mEase1Layout.setEnabled(true);\n-                mEase2Layout.setEnabled(true);\n-                mEase3Layout.setClickable(true);\n-                mEase4Layout.setEnabled(true);\n-                break;\n-\n-            case EASE_4:\n-                mEase1Layout.setEnabled(true);\n-                mEase2Layout.setEnabled(true);\n-                mEase3Layout.setEnabled(true);\n-                mEase4Layout.setClickable(true);\n-                break;\n-\n-            default:\n-                mEase1Layout.setEnabled(true);\n-                mEase2Layout.setEnabled(true);\n-                mEase3Layout.setEnabled(true);\n-                mEase4Layout.setEnabled(true);\n-                break;\n-        }\n-\n-        if (mPrefWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.setEnabled(true);\n-        }\n-\n-        if (typeAnswer()) {\n-            mAnswerField.setEnabled(true);\n-        }\n-        mTouchLayer.setVisibility(View.VISIBLE);\n-        mInAnswer = false;\n-        invalidateOptionsMenu();\n-    }\n-\n-\n-    private void blockControls() {\n-        mControlBlocked = true;\n-        mCardFrame.setEnabled(false);\n-        mFlipCardLayout.setEnabled(false);\n-        mTouchLayer.setVisibility(View.INVISIBLE);\n-        mInAnswer = true;\n-\n-        switch (mCurrentEase) {\n-            case EASE_1:\n-                mEase1Layout.setClickable(false);\n-                mEase2Layout.setEnabled(false);\n-                mEase3Layout.setEnabled(false);\n-                mEase4Layout.setEnabled(false);\n-                break;\n-\n-            case EASE_2:\n-                mEase1Layout.setEnabled(false);\n-                mEase2Layout.setClickable(false);\n-                mEase3Layout.setEnabled(false);\n-                mEase4Layout.setEnabled(false);\n-                break;\n-\n-            case EASE_3:\n-                mEase1Layout.setEnabled(false);\n-                mEase2Layout.setEnabled(false);\n-                mEase3Layout.setClickable(false);\n-                mEase4Layout.setEnabled(false);\n-                break;\n-\n-            case EASE_4:\n-                mEase1Layout.setEnabled(false);\n-                mEase2Layout.setEnabled(false);\n-                mEase3Layout.setEnabled(false);\n-                mEase4Layout.setClickable(false);\n-                break;\n-\n-            default:\n-                mEase1Layout.setEnabled(false);\n-                mEase2Layout.setEnabled(false);\n-                mEase3Layout.setEnabled(false);\n-                mEase4Layout.setEnabled(false);\n-                break;\n-        }\n-\n-        if (mPrefWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.setEnabled(false);\n-        }\n-\n-        if (typeAnswer()) {\n-            mAnswerField.setEnabled(false);\n-        }\n-        invalidateOptionsMenu();\n-    }\n-\n-\n-    /**\n-     * Select Text in the webview and automatically sends the selected text to the clipboard. From\n-     * http://cosmez.blogspot.com/2010/04/webview-emulateshiftheld-on-android.html\n-     */\n-    @SuppressWarnings(\"deprecation\") // Tracked separately in Github as #5024\n-    private void selectAndCopyText() {\n-        try {\n-            KeyEvent shiftPressEvent = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_SHIFT_LEFT, 0, 0);\n-            processCardAction(shiftPressEvent::dispatch);\n-            shiftPressEvent.isShiftPressed();\n-            mIsSelecting = true;\n-        } catch (Exception e) {\n-            throw new AssertionError(e);\n-        }\n-    }\n-\n-    public boolean executeCommand(@ViewerCommandDef int which) {\n-        if (getControlBlocked()) {\n-            return false;\n-        }\n-        switch (which) {\n-            case COMMAND_NOTHING:\n-                return true;\n-            case COMMAND_SHOW_ANSWER:\n-                if (sDisplayAnswer) {\n-                    return false;\n-                }\n-                displayCardAnswer();\n-                return true;\n-            case COMMAND_FLIP_OR_ANSWER_EASE1:\n-                flipOrAnswerCard(EASE_1);\n-                return true;\n-            case COMMAND_FLIP_OR_ANSWER_EASE2:\n-                flipOrAnswerCard(EASE_2);\n-                return true;\n-            case COMMAND_FLIP_OR_ANSWER_EASE3:\n-                flipOrAnswerCard(EASE_3);\n-                return true;\n-            case COMMAND_FLIP_OR_ANSWER_EASE4:\n-                flipOrAnswerCard(EASE_4);\n-                return true;\n-            case COMMAND_FLIP_OR_ANSWER_RECOMMENDED:\n-                flipOrAnswerCard(getRecommendedEase(false));\n-                return true;\n-            case COMMAND_FLIP_OR_ANSWER_BETTER_THAN_RECOMMENDED:\n-                flipOrAnswerCard(getRecommendedEase(true));\n-                return true;\n-            case COMMAND_EXIT:\n-                closeReviewer(RESULT_DEFAULT, false);\n-                return true;\n-            case COMMAND_UNDO:\n-                if (!getCol().undoAvailable()) {\n-                    return false;\n-                }\n-                undo();\n-                return true;\n-            case COMMAND_EDIT:\n-                editCard();\n-                return true;\n-            case COMMAND_MARK:\n-                onMark(mCurrentCard);\n-                return true;\n-            case COMMAND_LOOKUP:\n-                lookUpOrSelectText();\n-                return true;\n-            case COMMAND_BURY_CARD:\n-                dismiss(Collection.DismissType.BURY_CARD);\n-                return true;\n-            case COMMAND_BURY_NOTE:\n-                dismiss(Collection.DismissType.BURY_NOTE);\n-                return true;\n-            case COMMAND_SUSPEND_CARD:\n-                dismiss(Collection.DismissType.SUSPEND_CARD);\n-                return true;\n-            case COMMAND_SUSPEND_NOTE:\n-                dismiss(Collection.DismissType.SUSPEND_NOTE);\n-                return true;\n-            case COMMAND_DELETE:\n-                showDeleteNoteDialog();\n-                return true;\n-            case COMMAND_PLAY_MEDIA:\n-                playSounds(true);\n-                return true;\n-            case COMMAND_TOGGLE_FLAG_RED:\n-                toggleFlag(FLAG_RED);\n-                return true;\n-            case COMMAND_TOGGLE_FLAG_ORANGE:\n-                toggleFlag(FLAG_ORANGE);\n-                return true;\n-            case COMMAND_TOGGLE_FLAG_GREEN:\n-                toggleFlag(FLAG_GREEN);\n-                return true;\n-            case COMMAND_TOGGLE_FLAG_BLUE:\n-                toggleFlag(FLAG_BLUE);\n-                return true;\n-            case COMMAND_UNSET_FLAG:\n-                onFlag(mCurrentCard, FLAG_NONE);\n-                return true;\n-            default:\n-                Timber.w(\"Unknown command requested: %s\", which);\n-                return false;\n-        }\n-    }\n-\n-\n-    private void toggleFlag(@FlagDef int flag) {\n-        if (mCurrentCard.getUserFlag() == flag) {\n-            Timber.i(\"Toggle flag: unsetting flag\");\n-            onFlag(mCurrentCard, FLAG_NONE);\n-        } else {\n-            Timber.i(\"Toggle flag: Setting flag to %d\", flag);\n-            onFlag(mCurrentCard, flag);\n-        }\n-    }\n-\n-    // ----------------------------------------------------------------------------\n-    // INNER CLASSES\n-    // ----------------------------------------------------------------------------\n-\n-    /**\n-     * Provides a hook for calling \"alert\" from javascript. Useful for debugging your javascript.\n-     */\n-    public final class AnkiDroidWebChromeClient extends WebChromeClient {\n-        @Override\n-        public boolean onJsAlert(WebView view, String url, String message, JsResult result) {\n-            Timber.i(\"AbstractFlashcardViewer:: onJsAlert: %s\", message);\n-            result.confirm();\n-            return true;\n-        }\n-    }\n-\n-\n-    protected void closeReviewer(int result, boolean saveDeck) {\n-        mTimeoutHandler.removeCallbacks(mShowAnswerTask);\n-        mTimeoutHandler.removeCallbacks(mShowQuestionTask);\n-        mTimerHandler.removeCallbacks(removeChosenAnswerText);\n-        longClickHandler.removeCallbacks(longClickTestRunnable);\n-        longClickHandler.removeCallbacks(startLongClickAction);\n-\n-        AbstractFlashcardViewer.this.setResult(result);\n-\n-        if (saveDeck) {\n-            UIUtils.saveCollectionInBackground(this);\n-        }\n-        finishWithAnimation(ActivityTransitionAnimation.RIGHT);\n-    }\n-\n-\n-    protected void refreshActionBar() {\n-        supportInvalidateOptionsMenu();\n-    }\n-\n-    /** Fixing bug 720: <input> focus, thanks to pablomouzo on android issue 7189 */\n-    class MyWebView extends WebView {\n-\n-        public MyWebView(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        protected void onScrollChanged(int horiz, int vert, int oldHoriz, int oldVert) {\n-            super.onScrollChanged(horiz, vert, oldHoriz, oldVert);\n-            if (Math.abs(horiz - oldHoriz) > Math.abs(vert - oldVert)) {\n-                mIsXScrolling = true;\n-                scrollHandler.removeCallbacks(scrollXRunnable);\n-                scrollHandler.postDelayed(scrollXRunnable, 300);\n-            } else {\n-                mIsYScrolling = true;\n-                scrollHandler.removeCallbacks(scrollYRunnable);\n-                scrollHandler.postDelayed(scrollYRunnable, 300);\n-            }\n-        }\n-\n-        private final Handler scrollHandler = new Handler();\n-        private final Runnable scrollXRunnable = new Runnable() {\n-            @Override\n-            public void run() {\n-                mIsXScrolling = false;\n-            }\n-        };\n-        private final Runnable scrollYRunnable = new Runnable() {\n-            @Override\n-            public void run() {\n-                mIsYScrolling = false;\n-            }\n-        };\n-\n-    }\n-\n-    class MyGestureDetector extends SimpleOnGestureListener {\n-\n-        @Override\n-        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {\n-            // Go back to immersive mode if the user had temporarily exited it (and then execute swipe gesture)\n-            if (mPrefFullscreenReview > 0 &&\n-                    CompatHelper.getCompat().isImmersiveSystemUiVisible(AbstractFlashcardViewer.this)) {\n-                delayedHide(INITIAL_HIDE_DELAY);\n-            }\n-            if (mGesturesEnabled) {\n-                try {\n-                    float dy = e2.getY() - e1.getY();\n-                    float dx = e2.getX() - e1.getX();\n-\n-                    if (Math.abs(dx) > Math.abs(dy)) {\n-                        // horizontal swipe if moved further in x direction than y direction\n-                        if (dx > AnkiDroidApp.sSwipeMinDistance\n-                                && Math.abs(velocityX) > AnkiDroidApp.sSwipeThresholdVelocity\n-                                && !mIsXScrolling && !mIsSelecting) {\n-                            // right\n-                            executeCommand(mGestureSwipeRight);\n-                        } else if (dx < -AnkiDroidApp.sSwipeMinDistance\n-                                && Math.abs(velocityX) > AnkiDroidApp.sSwipeThresholdVelocity\n-                                && !mIsXScrolling && !mIsSelecting) {\n-                            // left\n-                            executeCommand(mGestureSwipeLeft);\n-                        }\n-                    } else {\n-                        // otherwise vertical swipe\n-                        if (dy > AnkiDroidApp.sSwipeMinDistance\n-                                && Math.abs(velocityY) > AnkiDroidApp.sSwipeThresholdVelocity\n-                                && !mIsYScrolling) {\n-                            // down\n-                            executeCommand(mGestureSwipeDown);\n-                        } else if (dy < -AnkiDroidApp.sSwipeMinDistance\n-                                && Math.abs(velocityY) > AnkiDroidApp.sSwipeThresholdVelocity\n-                                && !mIsYScrolling) {\n-                            // up\n-                            executeCommand(mGestureSwipeUp);\n-                        }\n-                    }\n-                } catch (Exception e) {\n-                    Timber.e(e, \"onFling Exception\");\n-                }\n-            }\n-            return false;\n-        }\n-\n-\n-        @Override\n-        public boolean onDoubleTap(MotionEvent e) {\n-            if (mGesturesEnabled) {\n-                executeCommand(mGestureDoubleTap);\n-            }\n-            return true;\n-        }\n-\n-\n-        @Override\n-        public boolean onSingleTapUp(MotionEvent e) {\n-            if (mTouchStarted) {\n-                longClickHandler.removeCallbacks(longClickTestRunnable);\n-                mTouchStarted = false;\n-            }\n-            return false;\n-        }\n-\n-\n-        @Override\n-        public boolean onSingleTapConfirmed(MotionEvent e) {\n-            // Go back to immersive mode if the user had temporarily exited it (and ignore the tap gesture)\n-            if (mPrefFullscreenReview > 0 &&\n-                    CompatHelper.getCompat().isImmersiveSystemUiVisible(AbstractFlashcardViewer.this)) {\n-                delayedHide(INITIAL_HIDE_DELAY);\n-                return true;\n-            }\n-            if (mGesturesEnabled && !mIsSelecting) {\n-                int height = mTouchLayer.getHeight();\n-                int width = mTouchLayer.getWidth();\n-                float posX = e.getX();\n-                float posY = e.getY();\n-                if (posX > posY / height * width) {\n-                    if (posY > height * (1 - posX / width)) {\n-                        executeCommand(mGestureTapRight);\n-                    } else {\n-                        executeCommand(mGestureTapTop);\n-                    }\n-                } else {\n-                    if (posY > height * (1 - posX / width)) {\n-                        executeCommand(mGestureTapBottom);\n-                    } else {\n-                        executeCommand(mGestureTapLeft);\n-                    }\n-                }\n-            }\n-            mIsSelecting = false;\n-            showLookupButtonIfNeeded();\n-            return false;\n-        }\n-    }\n-\n-\n-    protected final Handler mFullScreenHandler = new Handler() {\n-        @Override\n-        public void handleMessage(Message msg) {\n-            if (mPrefFullscreenReview > 0) {\n-                CompatHelper.getCompat().setFullScreen(AbstractFlashcardViewer.this);\n-            }\n-        }\n-    };\n-\n-    protected void delayedHide(int delayMillis) {\n-        mFullScreenHandler.removeMessages(0);\n-        mFullScreenHandler.sendEmptyMessageDelayed(0, delayMillis);\n-    }\n-\n-    /**\n-     * Removes first occurrence in answerContent of any audio that is present due to use of\n-     * {{FrontSide}} on the answer.\n-     * @param answerContent     The content from which to remove front side audio.\n-     * @return                  The content stripped of audio due to {{FrontSide}} inclusion.\n-     */\n-    private String removeFrontSideAudio(String answerContent) {\n-        String answerFormat = getAnswerFormat();\n-        String newAnswerContent = answerContent;\n-        if (answerFormat.contains(\"{{FrontSide}}\")) { // possible audio removal necessary\n-            String frontSideFormat = mCurrentCard._getQA(false).get(\"q\");\n-            Matcher audioReferences = Sound.sSoundPattern.matcher(frontSideFormat);\n-            // remove the first instance of audio contained in \"{{FrontSide}}\"\n-            while (audioReferences.find()) {\n-                newAnswerContent = newAnswerContent.replaceFirst(Pattern.quote(audioReferences.group()), \"\");\n-            }\n-        }\n-        return newAnswerContent;\n-    }\n-\n-    /**\n-     * Public method to start new video player activity\n-     */\n-    public void playVideo(String path) {\n-        Timber.i(\"Launching Video: %s\", path);\n-        Intent videoPlayer = new Intent(this, VideoPlayer.class);\n-        videoPlayer.putExtra(\"path\", path);\n-        startActivityWithoutAnimation(videoPlayer);\n-    }\n-\n-    /** Callback for when TTS has been initialized. */\n-    public void ttsInitialized() {\n-        mTtsInitialized = true;\n-        if (mReplayOnTtsInit) {\n-            playSounds(true);\n-        }\n-    }\n-\n-    private void drawMark() {\n-        if (mCurrentCard == null) {\n-            return;\n-        }\n-        mCardMarker.displayMark(shouldDisplayMark());\n-    }\n-\n-\n-    protected boolean shouldDisplayMark() {\n-        return mCurrentCard.note().hasTag(\"marked\");\n-    }\n-\n-\n-    protected void onMark(Card card) {\n-        if (card == null) {\n-            return;\n-        }\n-        Note note = card.note();\n-        if (note.hasTag(\"marked\")) {\n-            note.delTag(\"marked\");\n-        } else {\n-            note.addTag(\"marked\");\n-        }\n-        note.flush();\n-        refreshActionBar();\n-        drawMark();\n-    }\n-\n-    private void drawFlag() {\n-        if (mCurrentCard == null) {\n-            return;\n-        }\n-        mCardMarker.displayFlag(getFlagToDisplay());\n-    }\n-\n-\n-    protected @FlagDef int getFlagToDisplay() {\n-        return mCurrentCard.getUserFlag();\n-    }\n-\n-\n-    protected void onFlag(Card card, @FlagDef int flag) {\n-        if (card == null) {\n-            return;\n-        }\n-        card.setUserFlag(flag);\n-        card.flush();\n-        refreshActionBar();\n-        drawFlag();\n-        /* Following code would allow to update value of {{cardFlag}}.\n-           Anki does not update this value when a flag is changed, so\n-           currently this code would do something that anki itself\n-           does not do. I hope in the future Anki will correct that\n-           and this code may becomes useful.\n-\n-        card._getQA(true); //force reload. Useful iff {{cardFlag}} occurs in the template\n-        if (sDisplayAnswer) {\n-            displayCardAnswer();\n-        } else {\n-            displayCardQuestion();\n-            } */\n-    }\n-\n-    protected void dismiss(Collection.DismissType type) {\n-        blockControls();\n-        CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_DISMISS, mDismissCardHandler,\n-                new CollectionTask.TaskData(new Object[]{mCurrentCard, type}));\n-    }\n-\n-    /** Signals from a WebView represent actions with no parameters */\n-    @VisibleForTesting\n-    static class WebViewSignalParserUtils {\n-        /** A signal which we did not know how to handle */\n-        public static final int SIGNAL_UNHANDLED = 0;\n-        /** A known signal which should perform a noop */\n-        public static final int SIGNAL_NOOP = 1;\n-\n-        public static final int TYPE_FOCUS = 2;\n-        /** Tell the app that we no longer want to focus the WebView and should instead return keyboard focus to a\n-         * native answer input method. */\n-        public static final int RELINQUISH_FOCUS = 3;\n-\n-        public static final int SHOW_ANSWER = 4;\n-        public static final int ANSWER_ORDINAL_1 = 5;\n-        public static final int ANSWER_ORDINAL_2 = 6;\n-        public static final int ANSWER_ORDINAL_3 = 7;\n-        public static final int ANSWER_ORDINAL_4 = 8;\n-\n-        public static int getSignalFromUrl(String url) {\n-            switch (url) {\n-                case \"signal:typefocus\": return TYPE_FOCUS;\n-                case \"signal:relinquishFocus\": return RELINQUISH_FOCUS;\n-                case \"signal:show_answer\": return SHOW_ANSWER;\n-                case \"signal:answer_ease1\": return ANSWER_ORDINAL_1;\n-                case \"signal:answer_ease2\": return ANSWER_ORDINAL_2;\n-                case \"signal:answer_ease3\": return ANSWER_ORDINAL_3;\n-                case \"signal:answer_ease4\": return ANSWER_ORDINAL_4;\n-                default: break;\n-            }\n-\n-            if (url.startsWith(\"signal:answer_ease\")) {\n-                Timber.w(\"Unhandled signal: ease value: %s\", url);\n-                return SIGNAL_NOOP;\n-            }\n-\n-            return SIGNAL_UNHANDLED; //unknown, or not a signal.\n-        }\n-    }\n-\n-    protected class CardViewerWebClient extends WebViewClient {\n-        @Override\n-        @TargetApi(Build.VERSION_CODES.N)\n-        public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {\n-            String url = request.getUrl().toString();\n-            Timber.d(\"Obtained URL from card: '%s'\", url);\n-            return filterUrl(url);\n-        }\n-\n-\n-        @Override\n-        @TargetApi(Build.VERSION_CODES.N)\n-        public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n-            WebResourceResponse webResourceResponse = null;\n-            if (!AdaptionUtil.hasWebBrowser(getBaseContext())) {\n-                String scheme = request.getUrl().getScheme().trim();\n-                if (\"http\".equalsIgnoreCase(scheme) || \"https\".equalsIgnoreCase(scheme)) {\n-                    String response = getResources().getString(R.string.no_outgoing_link_in_cardbrowser);\n-                    webResourceResponse = new WebResourceResponse(\"text/html\", \"utf-8\", new ByteArrayInputStream(response.getBytes()));\n-                }\n-            }\n-            return webResourceResponse;\n-        }\n-\n-\n-        @Override\n-        @SuppressWarnings(\"deprecation\") // tracked as #5017 in github\n-        public boolean shouldOverrideUrlLoading(WebView view, String url) {\n-            return filterUrl(url);\n-        }\n-\n-\n-        // Filter any links using the custom \"playsound\" protocol defined in Sound.java.\n-        // We play sounds through these links when a user taps the sound icon.\n-        private boolean filterUrl(String url) {\n-            if (url.startsWith(\"playsound:\")) {\n-                // Send a message that will be handled on the UI thread.\n-                Message msg = Message.obtain();\n-                String soundPath = url.replaceFirst(\"playsound:\", \"\");\n-                msg.obj = soundPath;\n-                mHandler.sendMessage(msg);\n-                return true;\n-            }\n-            if (url.startsWith(\"file\") || url.startsWith(\"data:\")) {\n-                return false; // Let the webview load files, i.e. local images.\n-            }\n-            if (url.startsWith(\"typeblurtext:\")) {\n-                // Store the text the javascript has send us\u2026\n-                mTypeInput = decodeUrl(url.replaceFirst(\"typeblurtext:\", \"\"));\n-                // \u2026 and show the \u201cSHOW ANSWER\u201d button again.\n-                mFlipCardLayout.setVisibility(View.VISIBLE);\n-                return true;\n-            }\n-            if (url.startsWith(\"typeentertext:\")) {\n-                // Store the text the javascript has send us\u2026\n-                mTypeInput = decodeUrl(url.replaceFirst(\"typeentertext:\", \"\"));\n-                // \u2026 and show the answer.\n-                mFlipCardLayout.performClick();\n-                return true;\n-            }\n-            // card.html reload\n-            if (url.startsWith(\"signal:reload_card_html\")) {\n-                redrawCard();\n-                return true;\n-            }\n-            int signalOrdinal = WebViewSignalParserUtils.getSignalFromUrl(url);\n-            switch (signalOrdinal) {\n-                case WebViewSignalParserUtils.SIGNAL_UNHANDLED:\n-                    break; //continue parsing\n-                case WebViewSignalParserUtils.SIGNAL_NOOP:\n-                    return true;\n-                case WebViewSignalParserUtils.TYPE_FOCUS:\n-                    // Hide the \u201cSHOW ANSWER\u201d button when the input has focus. The soft keyboard takes up enough\n-                    // space by itself.\n-                    mFlipCardLayout.setVisibility(View.GONE);\n-                    return true;\n-                case WebViewSignalParserUtils.RELINQUISH_FOCUS:\n-                    //#5811 - The WebView could be focused via mouse. Allow components to return focus to Android.\n-                    focusAnswerCompletionField();\n-                    return true;\n-                /**\n-                 *  Call displayCardAnswer() and answerCard() from anki deck template using javascript\n-                 *  See card.js in assets/scripts folder\n-                 */\n-                case WebViewSignalParserUtils.SHOW_ANSWER:\n-                    // display answer when showAnswer() called from card.js\n-                    if (!sDisplayAnswer) {\n-                        displayCardAnswer();\n-                    }\n-                    return true;\n-                case WebViewSignalParserUtils.ANSWER_ORDINAL_1:\n-                    flipOrAnswerCard(EASE_1);\n-                    return true;\n-                case WebViewSignalParserUtils.ANSWER_ORDINAL_2:\n-                    flipOrAnswerCard(EASE_2);\n-                    return true;\n-                case WebViewSignalParserUtils.ANSWER_ORDINAL_3:\n-                    flipOrAnswerCard(EASE_3);\n-                    return true;\n-                case WebViewSignalParserUtils.ANSWER_ORDINAL_4:\n-                    flipOrAnswerCard(EASE_4);\n-                    return true;\n-                default:\n-                    //We know it was a signal, but forgot a case in the case statement.\n-                    //This is not the same as SIGNAL_UNHANDLED, where it isn't a known signal.\n-                    Timber.w(\"Unhandled signal case: %d\", signalOrdinal);\n-                    return true;\n-            }\n-            Intent intent = null;\n-            try {\n-                if (url.startsWith(\"intent:\")) {\n-                    intent = Intent.parseUri(url, Intent.URI_INTENT_SCHEME);\n-                } else if (url.startsWith(\"android-app:\")) {\n-                    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP_MR1) {\n-                        intent = Intent.parseUri(url, 0);\n-                        intent.setData(null);\n-                        intent.setPackage(Uri.parse(url).getHost());\n-                    } else {\n-                        intent = Intent.parseUri(url, Intent.URI_ANDROID_APP_SCHEME);\n-                    }\n-                }\n-                if (intent != null) {\n-                    if (getPackageManager().resolveActivity(intent, 0) == null) {\n-                        String packageName = intent.getPackage();\n-                        if (packageName == null) {\n-                            Timber.d(\"Not using resolved intent uri because not available: %s\", intent);\n-                            intent = null;\n-                        } else {\n-                            Timber.d(\"Resolving intent uri to market uri because not available: %s\", intent);\n-                            intent = new Intent(Intent.ACTION_VIEW,\n-                                    Uri.parse(\"market://details?id=\" + packageName));\n-                            if (getPackageManager().resolveActivity(intent, 0) == null) {\n-                                intent = null;\n-                            }\n-                        }\n-                    } else {\n-                        // https://developer.chrome.com/multidevice/android/intents says that we should remove this\n-                        intent.addCategory(Intent.CATEGORY_BROWSABLE);\n-                    }\n-                }\n-            } catch (Throwable t) {\n-                Timber.w(\"Unable to parse intent uri: %s because: %s\", url, t.getMessage());\n-            }\n-            if (intent == null) {\n-                Timber.d(\"Opening external link \\\"%s\\\" with an Intent\", url);\n-                intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n-            } else {\n-                Timber.d(\"Opening resolved external link \\\"%s\\\" with an Intent: %s\", url, intent);\n-            }\n-            try {\n-                startActivityWithoutAnimation(intent);\n-            } catch (ActivityNotFoundException e) {\n-                e.printStackTrace(); // Don't crash if the intent is not handled\n-            }\n-            return true;\n-        }\n-\n-\n-        private String decodeUrl(String url) {\n-            try {\n-                return URLDecoder.decode(url, \"UTF-8\");\n-            } catch (UnsupportedEncodingException e) {\n-                Timber.e(e, \"UTF-8 isn't supported as an encoding?\");\n-            } catch (Exception e) {\n-                Timber.e(e, \"Exception decoding: '%s'\", url);\n-                UIUtils.showThemedToast(AbstractFlashcardViewer.this, getString(R.string.card_viewer_url_decode_error), true);\n-            }\n-            return \"\";\n-        }\n-\n-\n-        // Run any post-load events in javascript that rely on the window being completely loaded.\n-        @Override\n-        public void onPageFinished(WebView view, String url) {\n-            Timber.d(\"onPageFinished triggered\");\n-            drawFlag();\n-            drawMark();\n-            view.loadUrl(\"javascript:onPageFinished();\");\n-        }\n-\n-\n-        /** Fix: #5780 - WebView Renderer OOM crashes reviewer */\n-        @Override\n-        @TargetApi(Build.VERSION_CODES.O)\n-        public boolean onRenderProcessGone(WebView view, RenderProcessGoneDetail detail) {\n-            Timber.i(\"Obtaining write lock for card\");\n-            Lock writeLock = mCardLock.writeLock();\n-            Timber.i(\"Obtained write lock for card\");\n-            try {\n-                writeLock.lock();\n-                if (mCard == null || !mCard.equals(view)) {\n-                    //A view crashed that wasn't ours.\n-                    //We have nothing to handle. Returning false is a desire to crash, so return true.\n-                    Timber.i(\"Unrelated WebView Renderer terminated. Crashed: %b\",  detail.didCrash());\n-                    return true;\n-                }\n-\n-                Timber.e(\"WebView Renderer process terminated. Crashed: %b\",  detail.didCrash());\n-\n-                //Destroy the current WebView (to ensure WebView is GCed).\n-                //Otherwise, we get the following error:\n-                //\"crash wasn't handled by all associated webviews, triggering application crash\"\n-                mCardFrame.removeAllViews();\n-                mCardFrameParent.removeView(mCardFrame);\n-                //destroy after removal from the view - produces logcat warnings otherwise\n-                destroyWebView(mCard);\n-                mCard = null;\n-                //inflate a new instance of mCardFrame\n-                mCardFrame = inflateNewView(R.id.flashcard);\n-                //Even with the above, I occasionally saw the above error. Manually trigger the GC.\n-                //I'll keep this line unless I see another crash, which would point to another underlying issue.\n-                System.gc();\n-\n-                //We only want to show one message per branch.\n-\n-                //It's not necessarily an OOM crash, false implies a general code which is for \"system terminated\".\n-                int errorCauseId = detail.didCrash() ? R.string.webview_crash_unknown : R.string.webview_crash_oom;\n-                String errorCauseString = getResources().getString(errorCauseId);\n-\n-                if (!canRecoverFromWebViewRendererCrash()) {\n-                    Timber.e(\"Unrecoverable WebView Render crash\");\n-                    String errorMessage = getResources().getString(R.string.webview_crash_fatal, errorCauseString);\n-                    UIUtils.showThemedToast(AbstractFlashcardViewer.this, errorMessage, false);\n-                    finishWithoutAnimation();\n-                    return true;\n-                }\n-\n-                if (webViewRendererLastCrashedOnCard(mCurrentCard.getId())) {\n-                    Timber.e(\"Web Renderer crash loop on card: %d\", mCurrentCard.getId());\n-                    displayRenderLoopDialog(mCurrentCard, detail);\n-                    return true;\n-                }\n-\n-                // If we get here, the error is non-fatal and we should re-render the WebView\n-                // This logic may need to be better defined. The card could have changed by the time we get here.\n-                lastCrashingCardId = mCurrentCard.getId();\n-\n-\n-                String nonFatalError = getResources().getString(R.string.webview_crash_nonfatal, errorCauseString);\n-                UIUtils.showThemedToast(AbstractFlashcardViewer.this, nonFatalError, false);\n-\n-                //we need to add at index 0 so gestures still go through.\n-                mCardFrameParent.addView(mCardFrame, 0);\n-\n-                recreateWebView();\n-            } finally {\n-                writeLock.unlock();\n-                Timber.d(\"Relinquished writeLock\");\n-            }\n-            displayCardQuestion();\n-\n-            //We handled the crash and can continue.\n-            return true;\n-        }\n-\n-\n-        @TargetApi(Build.VERSION_CODES.O)\n-        private void displayRenderLoopDialog(Card mCurrentCard, RenderProcessGoneDetail detail) {\n-            String cardInformation = Long.toString(mCurrentCard.getId());\n-            Resources res = getResources();\n-\n-            String errorDetails = detail.didCrash()\n-                    ? res.getString(R.string.webview_crash_unknwon_detailed)\n-                    : res.getString(R.string.webview_crash_oom_details);\n-            new MaterialDialog.Builder(AbstractFlashcardViewer.this)\n-                    .title(res.getString(R.string.webview_crash_loop_dialog_title))\n-                    .content(res.getString(R.string.webview_crash_loop_dialog_content, cardInformation, errorDetails))\n-                    .positiveText(R.string.dialog_ok)\n-                    .cancelable(false)\n-                    .canceledOnTouchOutside(false)\n-                    .onPositive((materialDialog, dialogAction) -> finishWithoutAnimation())\n-                    .show();\n-        }\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    protected String getTypedInputText() {\n-        return mTypeInput;\n-    }\n-\n-    @SuppressLint(\"WebViewApiAvailability\")\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    void handleUrlFromJavascript(String url) {\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-            //WebViewCompat recommended here, but I'll avoid the dependency as it's test code\n-            CardViewerWebClient c = ((CardViewerWebClient) this.mCard.getWebViewClient());\n-            if (c == null) {\n-                throw new IllegalStateException(\"Couldn't obtain WebView - maybe it wasn't created yet\");\n-            }\n-            c.filterUrl(url);\n-        } else {\n-            throw new IllegalStateException(\"Can't get WebViewClient due to Android API\");\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    void loadInitialCard() {\n-        CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler,\n-                new CollectionTask.TaskData(null, 0));\n-    }\n-\n-    public boolean getControlBlocked() {\n-        return mControlBlocked;\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    static void setEditorCard(Card card) {\n-        //I don't see why we don't do this by intent.\n-        sEditorCard = card;\n-    }\n-}\n+/****************************************************************************************\r\n+ * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\r\n+ * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *\r\n+ * Copyright (c) 2014\u201315 Roland Sieker <ospalh@gmail.com>                               *\r\n+ * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *\r\n+ * Copyright (c) 2016 Mark Carter <mark@marcardar.com>                                  *\r\n+ *                                                                                      *\r\n+ * This program is free software; you can redistribute it and/or modify it under        *\r\n+ * the terms of the GNU General Public License as published by the Free Software        *\r\n+ * Foundation; either version 3 of the License, or (at your option) any later           *\r\n+ * version.                                                                             *\r\n+ *                                                                                      *\r\n+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\r\n+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\r\n+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\r\n+ *                                                                                      *\r\n+ * You should have received a copy of the GNU General Public License along with         *\r\n+ * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\r\n+ ****************************************************************************************/\r\n+// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way\r\n+\r\n+package com.ichi2.anki;\r\n+\r\n+import android.annotation.SuppressLint;\r\n+import android.annotation.TargetApi;\r\n+import android.app.Activity;\r\n+import android.content.ActivityNotFoundException;\r\n+import android.content.BroadcastReceiver;\r\n+import android.content.Context;\r\n+import android.content.Intent;\r\n+import android.content.IntentFilter;\r\n+import android.content.SharedPreferences;\r\n+import android.content.res.Configuration;\r\n+import android.content.res.Resources;\r\n+import android.graphics.Color;\r\n+import android.net.Uri;\r\n+import android.os.Build;\r\n+import android.os.Bundle;\r\n+import android.os.Handler;\r\n+import android.os.Message;\r\n+import android.os.SystemClock;\r\n+\r\n+import androidx.annotation.CheckResult;\r\n+import androidx.annotation.IdRes;\r\n+import androidx.annotation.Nullable;\r\n+import androidx.annotation.VisibleForTesting;\r\n+import androidx.core.content.ContextCompat;\r\n+import androidx.core.view.GestureDetectorCompat;\r\n+import androidx.appcompat.app.ActionBar;\r\n+\r\n+import android.speech.tts.TextToSpeech;\r\n+import android.speech.tts.UtteranceProgressListener;\r\n+import android.text.SpannableString;\r\n+import android.text.Spanned;\r\n+import android.text.SpannedString;\r\n+import android.text.TextUtils;\r\n+import android.text.style.UnderlineSpan;\r\n+import android.util.TypedValue;\r\n+import android.view.GestureDetector.SimpleOnGestureListener;\r\n+import android.view.KeyEvent;\r\n+import android.view.LayoutInflater;\r\n+import android.view.MotionEvent;\r\n+import android.view.View;\r\n+import android.view.View.OnClickListener;\r\n+import android.view.ViewGroup;\r\n+import android.view.WindowManager;\r\n+import android.view.inputmethod.EditorInfo;\r\n+import android.view.inputmethod.InputMethodManager;\r\n+import android.webkit.JsResult;\r\n+import android.webkit.RenderProcessGoneDetail;\r\n+import android.webkit.WebChromeClient;\r\n+import android.webkit.WebResourceRequest;\r\n+import android.webkit.WebResourceResponse;\r\n+import android.webkit.WebView;\r\n+import android.webkit.WebViewClient;\r\n+import android.widget.Button;\r\n+import android.widget.Chronometer;\r\n+import android.widget.EditText;\r\n+import android.widget.FrameLayout;\r\n+import android.widget.ImageView;\r\n+import android.widget.LinearLayout;\r\n+import android.widget.RelativeLayout;\r\n+import android.widget.TextView;\r\n+import android.widget.Toast;\r\n+\r\n+import com.afollestad.materialdialogs.MaterialDialog;\r\n+import com.afollestad.materialdialogs.util.TypefaceHelper;\r\n+import com.google.android.material.snackbar.Snackbar;\r\n+import com.ichi2.anim.ActivityTransitionAnimation;\r\n+import com.ichi2.anim.ViewAnimation;\r\n+import com.ichi2.anki.cardviewer.CardAppearance;\r\n+import com.ichi2.anki.receiver.SdCardReceiver;\r\n+import com.ichi2.anki.reviewer.CardMarker;\r\n+import com.ichi2.anki.reviewer.ReviewerCustomFonts;\r\n+import com.ichi2.anki.reviewer.ReviewerUi;\r\n+import com.ichi2.async.CollectionTask;\r\n+import com.ichi2.compat.CompatHelper;\r\n+import com.ichi2.libanki.Decks;\r\n+import com.ichi2.libanki.sched.AbstractSched;\r\n+import com.ichi2.libanki.Card;\r\n+import com.ichi2.libanki.Collection;\r\n+import com.ichi2.libanki.Consts;\r\n+import com.ichi2.libanki.Note;\r\n+import com.ichi2.libanki.Sound;\r\n+import com.ichi2.libanki.Utils;\r\n+import com.ichi2.libanki.template.Template;\r\n+import com.ichi2.themes.HtmlColors;\r\n+import com.ichi2.themes.Themes;\r\n+import com.ichi2.utils.AdaptionUtil;\r\n+import com.ichi2.utils.DiffEngine;\r\n+import com.ichi2.utils.FunctionalInterfaces.Consumer;\r\n+import com.ichi2.utils.FunctionalInterfaces.Function;\r\n+\r\n+import com.ichi2.utils.JSONArray;\r\n+import com.ichi2.utils.JSONException;\r\n+import com.ichi2.utils.JSONObject;\r\n+import com.ichi2.utils.WebViewDebugging;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.File;\r\n+import java.io.FileOutputStream;\r\n+import java.io.IOException;\r\n+import java.io.UnsupportedEncodingException;\r\n+import java.lang.ref.WeakReference;\r\n+import java.net.URLDecoder;\r\n+import java.util.LinkedHashSet;\r\n+import java.util.Set;\r\n+import java.util.concurrent.locks.Lock;\r\n+import java.util.concurrent.locks.ReadWriteLock;\r\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\r\n+import java.util.regex.Matcher;\r\n+import java.util.regex.Pattern;\r\n+\r\n+import timber.log.Timber;\r\n+\r\n+import static com.ichi2.anki.cardviewer.CardAppearance.calculateDynamicFontSize;\r\n+import static com.ichi2.anki.cardviewer.ViewerCommand.*;\r\n+\r\n+@SuppressWarnings({\"PMD.AvoidThrowingRawExceptionTypes\",\"PMD.FieldDeclarationsShouldBeAtStartOfClass\"})\r\n+public abstract class AbstractFlashcardViewer extends NavigationDrawerActivity implements ReviewerUi, CommandProcessor {\r\n+\r\n+    /**\r\n+     * Result codes that are returned when this activity finishes.\r\n+     */\r\n+    public static final int RESULT_DEFAULT = 50;\r\n+    public static final int RESULT_NO_MORE_CARDS = 52;\r\n+\r\n+    /**\r\n+     * Available options performed by other activities.\r\n+     */\r\n+    public static final int EDIT_CURRENT_CARD = 0;\r\n+    public static final int DECK_OPTIONS = 1;\r\n+\r\n+    public static final int EASE_1 = 1;\r\n+    public static final int EASE_2 = 2;\r\n+    public static final int EASE_3 = 3;\r\n+    public static final int EASE_4 = 4;\r\n+\r\n+    /** Maximum time in milliseconds to wait before accepting answer button presses. */\r\n+    private static final int DOUBLE_TAP_IGNORE_THRESHOLD = 200;\r\n+\r\n+    /** Time to wait in milliseconds before resuming fullscreen mode **/\r\n+    protected static final int INITIAL_HIDE_DELAY = 200;\r\n+\r\n+    /** Regex pattern used in removing tags from text before diff */\r\n+    private static final Pattern sSpanPattern = Pattern.compile(\"</?span[^>]*>\");\r\n+    private static final Pattern sBrPattern = Pattern.compile(\"<br\\\\s?/?>\");\r\n+\r\n+    // Type answer patterns\r\n+    private static final Pattern sTypeAnsPat = Pattern.compile(\"\\\\[\\\\[type:(.+?)\\\\]\\\\]\");\r\n+\r\n+    /** to be sent to and from the card editor */\r\n+    private static Card sEditorCard;\r\n+\r\n+    protected static boolean sDisplayAnswer = false;\r\n+\r\n+    private boolean mTtsInitialized = false;\r\n+    private boolean mReplayOnTtsInit = false;\r\n+\r\n+    protected static final int MENU_DISABLED = 3;\r\n+\r\n+\r\n+    /**\r\n+     * Broadcast that informs us when the sd card is about to be unmounted\r\n+     */\r\n+    private BroadcastReceiver mUnmountReceiver = null;\r\n+\r\n+    /**\r\n+     * Variables to hold preferences\r\n+     */\r\n+    private CardAppearance mCardAppearance;\r\n+    private boolean mPrefHideDueCount;\r\n+    private boolean mPrefShowETA;\r\n+    private boolean mShowTimer;\r\n+    protected boolean mPrefWhiteboard;\r\n+    private int mPrefFullscreenReview;\r\n+    private int mRelativeButtonSize;\r\n+    private boolean mDoubleScrolling;\r\n+    private boolean mScrollingButtons;\r\n+    private boolean mGesturesEnabled;\r\n+    // Android WebView\r\n+    protected boolean mSpeakText;\r\n+    protected boolean mDisableClipboard = false;\r\n+\r\n+    protected boolean mOptUseGeneralTimerSettings;\r\n+\r\n+    protected boolean mUseTimer;\r\n+    protected int mWaitAnswerSecond;\r\n+    protected int mWaitQuestionSecond;\r\n+\r\n+    protected boolean mPrefUseTimer;\r\n+\r\n+    protected boolean mOptUseTimer;\r\n+    protected int mOptWaitAnswerSecond;\r\n+    protected int mOptWaitQuestionSecond;\r\n+\r\n+    protected boolean mUseInputTag;\r\n+\r\n+    // Preferences from the collection\r\n+    private boolean mShowNextReviewTime;\r\n+    private boolean mShowRemainingCardCount;\r\n+\r\n+    // Answer card & cloze deletion variables\r\n+    private String mTypeCorrect = null;\r\n+    // The correct answer in the compare to field if answer should be given by learner. Null if no answer is expected.\r\n+    private String mTypeInput = \"\";  // What the learner actually typed\r\n+    private String mTypeFont = \"\";  // Font face of the compare to field\r\n+    private int mTypeSize = 0;  // Its font size\r\n+    private String mTypeWarning;\r\n+\r\n+    private boolean mIsSelecting = false;\r\n+    private boolean mTouchStarted = false;\r\n+    private boolean mInAnswer = false;\r\n+    private boolean mAnswerSoundsAdded = false;\r\n+\r\n+    private String mCardTemplate;\r\n+\r\n+    /**\r\n+     * Variables to hold layout objects that we need to update or handle events for\r\n+     */\r\n+    private View mLookUpIcon;\r\n+    private WebView mCard;\r\n+    private FrameLayout mCardFrame;\r\n+    private FrameLayout mTouchLayer;\r\n+    private TextView mTextBarNew;\r\n+    private TextView mTextBarLearn;\r\n+    private TextView mTextBarReview;\r\n+    private TextView mChosenAnswer;\r\n+    protected TextView mNext1;\r\n+    protected TextView mNext2;\r\n+    protected TextView mNext3;\r\n+    protected TextView mNext4;\r\n+    protected EditText mAnswerField;\r\n+    protected TextView mEase1;\r\n+    protected TextView mEase2;\r\n+    protected TextView mEase3;\r\n+    protected TextView mEase4;\r\n+    protected LinearLayout mFlipCardLayout;\r\n+    protected LinearLayout mEase1Layout;\r\n+    protected LinearLayout mEase2Layout;\r\n+    protected LinearLayout mEase3Layout;\r\n+    protected LinearLayout mEase4Layout;\r\n+    protected RelativeLayout mTopBarLayout;\r\n+    private Chronometer mCardTimer;\r\n+    protected Whiteboard mWhiteboard;\r\n+    @SuppressWarnings(\"deprecation\") // Tracked separately as #5023 on github\r\n+    private android.text.ClipboardManager mClipboard;\r\n+\r\n+    protected Card mCurrentCard;\r\n+    private int mCurrentEase;\r\n+\r\n+    private boolean mButtonHeightSet = false;\r\n+\r\n+    private boolean mConfigurationChanged = false;\r\n+    private int mShowChosenAnswerLength = 2000;\r\n+\r\n+    /**\r\n+     * A record of the last time the \"show answer\" or ease buttons were pressed. We keep track\r\n+     * of this time to ignore accidental button presses.\r\n+     */\r\n+    private long mLastClickTime;\r\n+\r\n+    /**\r\n+     * Swipe Detection\r\n+     */\r\n+    private GestureDetectorCompat gestureDetector;\r\n+\r\n+    private boolean mIsXScrolling = false;\r\n+    private boolean mIsYScrolling = false;\r\n+\r\n+    /**\r\n+     * Gesture Allocation\r\n+     */\r\n+    private int mGestureSwipeUp;\r\n+    private int mGestureSwipeDown;\r\n+    private int mGestureSwipeLeft;\r\n+    private int mGestureSwipeRight;\r\n+    private int mGestureDoubleTap;\r\n+    private int mGestureTapLeft;\r\n+    private int mGestureTapRight;\r\n+    private int mGestureTapTop;\r\n+    private int mGestureTapBottom;\r\n+    private int mGestureLongclick;\r\n+\r\n+    private Spanned mCardContent;\r\n+    private String mBaseUrl;\r\n+\r\n+    private int mFadeDuration = 300;\r\n+\r\n+    protected AbstractSched mSched;\r\n+\r\n+    private Sound mSoundPlayer = new Sound();\r\n+\r\n+    private long mUseTimerDynamicMS;\r\n+\r\n+    /**\r\n+     * Last card that the WebView Renderer crashed on.\r\n+     * If we get 2 crashes on the same card, then we likely have an infinite loop and want to exit gracefully.\r\n+     */\r\n+    @Nullable\r\n+    private Long lastCrashingCardId = null;\r\n+\r\n+    /** Reference to the parent of the cardFrame to allow regeneration of the cardFrame in case of crash */\r\n+    private ViewGroup mCardFrameParent;\r\n+\r\n+    /** Lock to allow thread-safe regeneration of mCard */\r\n+    private ReadWriteLock mCardLock = new ReentrantReadWriteLock();\r\n+\r\n+    /** whether controls are currently blocked */\r\n+    private boolean mControlBlocked = true;\r\n+\r\n+    /** Handle Mark/Flag state of cards */\r\n+    private CardMarker mCardMarker;\r\n+    // private int zEase;\r\n+\r\n+    // ----------------------------------------------------------------------------\r\n+    // LISTENERS\r\n+    // ----------------------------------------------------------------------------\r\n+\r\n+    private Handler mHandler = new Handler() {\r\n+\r\n+        @Override\r\n+        public void handleMessage(Message msg) {\r\n+            mSoundPlayer.stopSounds();\r\n+            mSoundPlayer.playSound((String) msg.obj, null);\r\n+        }\r\n+    };\r\n+\r\n+    private final Handler longClickHandler = new Handler();\r\n+    private final Runnable longClickTestRunnable = new Runnable() {\r\n+        @Override\r\n+        public void run() {\r\n+            Timber.i(\"AbstractFlashcardViewer:: onEmulatedLongClick\");\r\n+            // Show hint about lookup function if dictionary available\r\n+            if (!mDisableClipboard && Lookup.isAvailable()) {\r\n+                String lookupHint = getResources().getString(R.string.lookup_hint);\r\n+                UIUtils.showThemedToast(AbstractFlashcardViewer.this, lookupHint, false);\r\n+            }\r\n+            CompatHelper.getCompat().vibrate(AnkiDroidApp.getInstance().getApplicationContext(), 50);\r\n+            longClickHandler.postDelayed(startLongClickAction, 300);\r\n+        }\r\n+    };\r\n+    private final Runnable startLongClickAction = new Runnable() {\r\n+        @Override\r\n+        public void run() {\r\n+            executeCommand(mGestureLongclick);\r\n+        }\r\n+    };\r\n+\r\n+\r\n+    // Handler for the \"show answer\" button\r\n+    private View.OnClickListener mFlipCardListener = new View.OnClickListener() {\r\n+        @Override\r\n+        public void onClick(View view) {\r\n+            Timber.i(\"AbstractFlashcardViewer:: Show answer button pressed\");\r\n+            // Ignore what is most likely an accidental double-tap.\r\n+            if (SystemClock.elapsedRealtime() - mLastClickTime < DOUBLE_TAP_IGNORE_THRESHOLD) {\r\n+                return;\r\n+            }\r\n+            mLastClickTime = SystemClock.elapsedRealtime();\r\n+            mTimeoutHandler.removeCallbacks(mShowAnswerTask);\r\n+            displayCardAnswer();\r\n+        }\r\n+    };\r\n+\r\n+    private View.OnClickListener mSelectEaseHandler = new View.OnClickListener() {\r\n+        @Override\r\n+        public void onClick(View view) {\r\n+            // Ignore what is most likely an accidental double-tap.\r\n+            if (SystemClock.elapsedRealtime() - mLastClickTime < DOUBLE_TAP_IGNORE_THRESHOLD) {\r\n+                return;\r\n+            }\r\n+            mLastClickTime = SystemClock.elapsedRealtime();\r\n+            mTimeoutHandler.removeCallbacks(mShowQuestionTask);\r\n+            switch (view.getId()) {\r\n+                case R.id.flashcard_layout_ease1:\r\n+                    Timber.i(\"AbstractFlashcardViewer:: EASE_1 pressed\");\r\n+                    answerCard(EASE_1);\r\n+                    break;\r\n+                case R.id.flashcard_layout_ease2:\r\n+                    Timber.i(\"AbstractFlashcardViewer:: EASE_2 pressed\");\r\n+                    answerCard(EASE_2);\r\n+                    break;\r\n+                case R.id.flashcard_layout_ease3:\r\n+                    Timber.i(\"AbstractFlashcardViewer:: EASE_3 pressed\");\r\n+                    answerCard(EASE_3);\r\n+                    break;\r\n+                case R.id.flashcard_layout_ease4:\r\n+                    Timber.i(\"AbstractFlashcardViewer:: EASE_4 pressed\");\r\n+                    answerCard(EASE_4);\r\n+                    break;\r\n+                default:\r\n+                    mCurrentEase = 0;\r\n+                    break;\r\n+            }\r\n+        }\r\n+    };\r\n+\r\n+    private View.OnTouchListener mGestureListener = new View.OnTouchListener() {\r\n+        @Override\r\n+        public boolean onTouch(View v, MotionEvent event) {\r\n+            if (gestureDetector.onTouchEvent(event)) {\r\n+                return true;\r\n+            }\r\n+            if (!mDisableClipboard) {\r\n+                switch (event.getAction()) {\r\n+                    case MotionEvent.ACTION_DOWN:\r\n+                        mTouchStarted = true;\r\n+                        longClickHandler.postDelayed(longClickTestRunnable, 800);\r\n+                        break;\r\n+                    case MotionEvent.ACTION_UP:\r\n+                    case MotionEvent.ACTION_MOVE:\r\n+                        if (mTouchStarted) {\r\n+                            longClickHandler.removeCallbacks(longClickTestRunnable);\r\n+                            mTouchStarted = false;\r\n+                        }\r\n+                        break;\r\n+                    default:\r\n+                        longClickHandler.removeCallbacks(longClickTestRunnable);\r\n+                        mTouchStarted = false;\r\n+                        break;\r\n+                }\r\n+            }\r\n+            //Gesture listener is added before mCard is set\r\n+            processCardAction(card -> {\r\n+                if (card == null) return;\r\n+                card.dispatchTouchEvent(event);\r\n+            });\r\n+            return false;\r\n+        }\r\n+    };\r\n+\r\n+    @SuppressLint(\"CheckResult\")\r\n+    private void processCardAction(Consumer<WebView> cardConsumer) {\r\n+        processCardFunction(card -> {\r\n+            cardConsumer.consume(card);\r\n+            return true;\r\n+        });\r\n+    }\r\n+\r\n+    @CheckResult\r\n+    private <T> T processCardFunction(Function<WebView, T> cardFunction) {\r\n+        Lock readLock = mCardLock.readLock();\r\n+        try {\r\n+            readLock.lock();\r\n+            return cardFunction.apply(mCard);\r\n+        } finally {\r\n+            readLock.unlock();\r\n+        }\r\n+    }\r\n+\r\n+\r\n+    protected CollectionTask.TaskListener mDismissCardHandler = new NextCardHandler() { /* superclass is sufficient */ };\r\n+\r\n+\r\n+    private CollectionTask.TaskListener mUpdateCardHandler = new CollectionTask.TaskListener() {\r\n+        private boolean mNoMoreCards;\r\n+\r\n+\r\n+        @Override\r\n+        public void onPreExecute() {\r\n+            showProgressBar();\r\n+        }\r\n+\r\n+\r\n+        @Override\r\n+        public void onProgressUpdate(CollectionTask.TaskData... values) {\r\n+            boolean cardChanged = false;\r\n+            if (mCurrentCard != values[0].getCard()) {\r\n+                /*\r\n+                 * Before updating mCurrentCard, we check whether it is changing or not. If the current card changes,\r\n+                 * then we need to display it as a new card, without showing the answer.\r\n+                 */\r\n+                sDisplayAnswer = false;\r\n+                cardChanged = true;  // Keep track of that so we can run a bit of new-card code\r\n+            }\r\n+            mCurrentCard = values[0].getCard();\r\n+            if (mCurrentCard == null) {\r\n+                // If the card is null means that there are no more cards scheduled for review.\r\n+                mNoMoreCards = true;\r\n+                showProgressBar();\r\n+                return;\r\n+            }\r\n+            if (mPrefWhiteboard && mWhiteboard != null) {\r\n+                mWhiteboard.clear();\r\n+            }\r\n+\r\n+            if (sDisplayAnswer) {\r\n+                mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\r\n+                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\r\n+                generateQuestionSoundList(); // questions must be intentionally regenerated\r\n+                displayCardAnswer();\r\n+            } else {\r\n+                if (cardChanged) {\r\n+                    updateTypeAnswerInfo();\r\n+                }\r\n+                displayCardQuestion();\r\n+                mCurrentCard.startTimer();\r\n+                initTimer();\r\n+            }\r\n+            hideProgressBar();\r\n+        }\r\n+\r\n+\r\n+        @Override\r\n+        public void onPostExecute(CollectionTask.TaskData result) {\r\n+            if (!result.getBoolean()) {\r\n+                // RuntimeException occurred on update cards\r\n+                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\r\n+                return;\r\n+            }\r\n+            if (mNoMoreCards) {\r\n+                closeReviewer(RESULT_NO_MORE_CARDS, true);\r\n+            }\r\n+        }\r\n+    };\r\n+\r\n+    abstract class NextCardHandler extends CollectionTask.TaskListener {\r\n+        private boolean mNoMoreCards;\r\n+\r\n+\r\n+        @Override\r\n+        public void onPreExecute() { /* do nothing */}\r\n+\r\n+\r\n+        @Override\r\n+        public void onProgressUpdate(CollectionTask.TaskData... values) {\r\n+            displayNext(values[0].getCard());\r\n+        }\r\n+\r\n+        protected void displayNext(Card nextCard) {\r\n+\r\n+            Resources res = getResources();\r\n+\r\n+            if (mSched == null) {\r\n+                // TODO: proper testing for restored activity\r\n+                finishWithoutAnimation();\r\n+                return;\r\n+            }\r\n+\r\n+            mCurrentCard = nextCard;\r\n+            if (mCurrentCard == null) {\r\n+                // If the card is null means that there are no more cards scheduled for review.\r\n+                mNoMoreCards = true; // other handlers use this, toggle state every time through\r\n+            } else {\r\n+                mNoMoreCards = false; // other handlers use this, toggle state every time through\r\n+                // Start reviewing next card\r\n+                updateTypeAnswerInfo();\r\n+                hideProgressBar();\r\n+                AbstractFlashcardViewer.this.unblockControls();\r\n+                AbstractFlashcardViewer.this.displayCardQuestion();\r\n+            }\r\n+\r\n+            // Since reps are incremented on fetch of next card, we will miss counting the\r\n+            // last rep since there isn't a next card. We manually account for it here.\r\n+            if (mNoMoreCards) {\r\n+                mSched.setReps(mSched.getReps() + 1);\r\n+            }\r\n+\r\n+            Long[] elapsed = getCol().timeboxReached();\r\n+            if (elapsed != null) {\r\n+                // AnkiDroid is always counting one rep ahead, so we decrement it before displaying\r\n+                // it to the user.\r\n+                int nCards = elapsed[1].intValue() - 1;\r\n+                int nMins = elapsed[0].intValue() / 60;\r\n+                String mins = res.getQuantityString(R.plurals.in_minutes, nMins, nMins);\r\n+                String timeboxMessage = res.getQuantityString(R.plurals.timebox_reached, nCards, nCards, mins);\r\n+                UIUtils.showThemedToast(AbstractFlashcardViewer.this, timeboxMessage, true);\r\n+                getCol().startTimebox();\r\n+            }\r\n+        }\r\n+\r\n+\r\n+        @Override\r\n+        public void onPostExecute(CollectionTask.TaskData result) {\r\n+            postNextCardDisplay(result.getBoolean());\r\n+        }\r\n+\r\n+        protected void postNextCardDisplay(boolean displaySuccess) {\r\n+            if (!displaySuccess) {\r\n+                // RuntimeException occurred on answering cards\r\n+                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\r\n+                return;\r\n+            }\r\n+            // Check for no more cards before session complete. If they are both true, no more cards will take\r\n+            // precedence when returning to study options.\r\n+            if (mNoMoreCards) {\r\n+                closeReviewer(RESULT_NO_MORE_CARDS, true);\r\n+            }\r\n+            // set the correct mark/unmark icon on action bar\r\n+            refreshActionBar();\r\n+            findViewById(R.id.root_layout).requestFocus();\r\n+        }\r\n+    }\r\n+\r\n+\r\n+    protected CollectionTask.TaskListener mAnswerCardHandler = new NextCardHandler() {\r\n+\r\n+\r\n+        @Override\r\n+        public void onPreExecute() {\r\n+            blockControls();\r\n+        }\r\n+    };\r\n+\r\n+\r\n+    /**\r\n+     * Extract type answer/cloze text and font/size\r\n+     */\r\n+    private void updateTypeAnswerInfo() {\r\n+        mTypeCorrect = null;\r\n+        mTypeInput = \"\";\r\n+        String q = mCurrentCard.q(false);\r\n+        Matcher m = sTypeAnsPat.matcher(q);\r\n+        int clozeIdx = 0;\r\n+        if (!m.find()) {\r\n+            return;\r\n+        }\r\n+        String fld = m.group(1);\r\n+        // if it's a cloze, extract data\r\n+        if (fld.startsWith(\"cloze:\", 0)) {\r\n+            // get field and cloze position\r\n+            clozeIdx = mCurrentCard.getOrd() + 1;\r\n+            fld = fld.split(\":\")[1];\r\n+        }\r\n+        // loop through fields for a match\r\n+        JSONArray ja = mCurrentCard.model().getJSONArray(\"flds\");\r\n+        for (int i = 0; i < ja.length(); i++) {\r\n+            String name = (String) (ja.getJSONObject(i).get(\"name\"));\r\n+            if (name.equals(fld)) {\r\n+                mTypeCorrect = mCurrentCard.note().getItem(name);\r\n+                if (clozeIdx != 0) {\r\n+                    // narrow to cloze\r\n+                    mTypeCorrect = contentForCloze(mTypeCorrect, clozeIdx);\r\n+                }\r\n+                mTypeFont = (String) (ja.getJSONObject(i).get(\"font\"));\r\n+                mTypeSize = (int) (ja.getJSONObject(i).get(\"size\"));\r\n+                break;\r\n+            }\r\n+        }\r\n+        if (mTypeCorrect == null) {\r\n+            if (clozeIdx != 0) {\r\n+                mTypeWarning = getResources().getString(R.string.empty_card_warning);\r\n+            } else {\r\n+                mTypeWarning = getResources().getString(R.string.unknown_type_field_warning, fld);\r\n+            }\r\n+        } else if (\"\".equals(mTypeCorrect)) {\r\n+            mTypeCorrect = null;\r\n+        } else {\r\n+            mTypeWarning = null;\r\n+        }\r\n+    }\r\n+\r\n+\r\n+    /**\r\n+     * Format question field when it contains typeAnswer or clozes. If there was an error during type text extraction, a\r\n+     * warning is displayed\r\n+     *\r\n+     * @param buf The question text\r\n+     * @return The formatted question text\r\n+     */\r\n+    private String typeAnsQuestionFilter(String buf) {\r\n+        Matcher m = sTypeAnsPat.matcher(buf);\r\n+        if (mTypeWarning != null) {\r\n+            return m.replaceFirst(mTypeWarning);\r\n+        }\r\n+        StringBuilder sb = new StringBuilder();\r\n+        if (mUseInputTag) {\r\n+            // These functions are defined in the JavaScript file assets/scripts/card.js. We get the text back in\r\n+            // shouldOverrideUrlLoading() in createWebView() in this file.\r\n+            sb.append(\"<center>\\n<input type=\\\"text\\\" name=\\\"typed\\\" id=\\\"typeans\\\" onfocus=\\\"taFocus();\\\" \" +\r\n+                    \"onblur=\\\"taBlur(this);\\\" onKeyPress=\\\"return taKey(this, event)\\\" autocomplete=\\\"off\\\" \");\r\n+            // We have to watch out. For the preview we don\u2019t know the font or font size. Skip those there. (Anki\r\n+            // desktop just doesn\u2019t show the input tag there. Do it with standard values here instead.)\r\n+            if (mTypeFont != null && !TextUtils.isEmpty(mTypeFont) && mTypeSize > 0) {\r\n+                sb.append(\"style=\\\"font-family: '\").append(mTypeFont).append(\"'; font-size: \")\r\n+                        .append(Integer.toString(mTypeSize)).append(\"px;\\\" \");\r\n+            }\r\n+            sb.append(\">\\n</center>\\n\");\r\n+        } else {\r\n+            sb.append(\"<span id=\\\"typeans\\\" class=\\\"typePrompt\");\r\n+            if (mUseInputTag) {\r\n+                sb.append(\" typeOff\");\r\n+            }\r\n+            sb.append(\"\\\">........</span>\");\r\n+        }\r\n+        return m.replaceAll(sb.toString());\r\n+    }\r\n+\r\n+\r\n+    /**\r\n+     * Fill the placeholder for the type comparison. Show the correct answer, and the comparison if appropriate.\r\n+     *\r\n+     * @param buf The answer text\r\n+     * @param userAnswer Text typed by the user, or empty.\r\n+     * @param correctAnswer The correct answer, taken from the note.\r\n+     * @return The formatted answer text\r\n+     */\r\n+    @VisibleForTesting\r\n+    String typeAnsAnswerFilter(String buf, String userAnswer, String correctAnswer) {\r\n+        Matcher m = sTypeAnsPat.matcher(buf);\r\n+        DiffEngine diffEngine = new DiffEngine();\r\n+        StringBuilder sb = new StringBuilder();\r\n+        sb.append(\"<div><code id=\\\"typeans\\\">\");\r\n+\r\n+        // We have to use Matcher.quoteReplacement because the inputs here might have $ or \\.\r\n+\r\n+        if (!TextUtils.isEmpty(userAnswer)) {\r\n+            // The user did type something.\r\n+            if (userAnswer.equals(correctAnswer)) {\r\n+                // and it was right.\r\n+                sb.append(Matcher.quoteReplacement(DiffEngine.wrapGood(correctAnswer)));\r\n+                sb.append(\"<span id=\\\"typecheckmark\\\">\\u2714</span>\"); // Heavy check mark\r\n+            } else {\r\n+                // Answer not correct.\r\n+                // Only use the complex diff code when needed, that is when we have some typed text that is not\r\n+                // exactly the same as the correct text.\r\n+                String[] diffedStrings = diffEngine.diffedHtmlStrings(correctAnswer, userAnswer);\r\n+                // We know we get back two strings.\r\n+                sb.append(Matcher.quoteReplacement(diffedStrings[0]));\r\n+                sb.append(\"<br><span id=\\\"typearrow\\\">&darr;</span><br>\");\r\n+                sb.append(Matcher.quoteReplacement(diffedStrings[1]));\r\n+            }\r\n+        } else {\r\n+            if (!mUseInputTag) {\r\n+                sb.append(Matcher.quoteReplacement(DiffEngine.wrapMissing(correctAnswer)));\r\n+            } else {\r\n+                sb.append(Matcher.quoteReplacement(correctAnswer));\r\n+            }\r\n+        }\r\n+        sb.append(\"</code></div>\");\r\n+        return m.replaceAll(sb.toString());\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the correct answer to use for {{type::cloze::NN}} fields.\r\n+     *\r\n+     * @param txt The field text with the clozes\r\n+     * @param idx The index of the cloze to use\r\n+     * @return A string with a comma-separeted list of unique cloze strings with the corret index.\r\n+     */\r\n+\r\n+    private String contentForCloze(String txt, int idx) {\r\n+        Pattern re = Pattern.compile(\"\\\\{\\\\{c\" + idx + \"::(.+?)\\\\}\\\\}\");\r\n+        Matcher m = re.matcher(txt);\r\n+        Set<String> matches = new LinkedHashSet<>();\r\n+        // LinkedHashSet: make entries appear only once, like Anki desktop (see also issue #2208), and keep the order\r\n+        // they appear in.\r\n+        String groupOne;\r\n+        int colonColonIndex = -1;\r\n+        while (m.find()) {\r\n+            groupOne = m.group(1);\r\n+            colonColonIndex = groupOne.indexOf(\"::\");\r\n+            if (colonColonIndex > -1) {\r\n+                // Cut out the hint.\r\n+                groupOne = groupOne.substring(0, colonColonIndex);\r\n+            }\r\n+            matches.add(groupOne);\r\n+        }\r\n+        // Now do what the pythonic \", \".join(matches) does in a tricky way\r\n+        String prefix = \"\";\r\n+        StringBuilder resultBuilder = new StringBuilder();\r\n+        for (String match : matches) {\r\n+            resultBuilder.append(prefix);\r\n+            resultBuilder.append(match);\r\n+            prefix = \", \";\r\n+        }\r\n+        return resultBuilder.toString();\r\n+    }\r\n+\r\n+    private Handler mTimerHandler = new Handler();\r\n+\r\n+    private Runnable removeChosenAnswerText = new Runnable() {\r\n+        @Override\r\n+        public void run() {\r\n+            mChosenAnswer.setText(\"\");\r\n+        }\r\n+    };\r\n+\r\n+    protected int mPrefWaitAnswerSecond;\r\n+    protected int mPrefWaitQuestionSecond;\r\n+\r\n+    protected int getDefaultEase() {\r\n+        if (getAnswerButtonCount() == 4) {\r\n+            return EASE_3;\r\n+        } else {\r\n+            return EASE_2;\r\n+        }\r\n+    }\r\n+\r\n+\r\n+    protected int getAnswerButtonCount() {\r\n+        return getCol().getSched().answerButtons(mCurrentCard);\r\n+    }\r\n+\r\n+\r\n+    // ----------------------------------------------------------------------------\r\n+    // ANDROID METHODS\r\n+    // ----------------------------------------------------------------------------\r\n+\r\n+    @Override\r\n+    protected void onCreate(Bundle savedInstanceState) {\r\n+        Timber.d(\"onCreate()\");\r\n+        SharedPreferences preferences = restorePreferences();\r\n+        mCardAppearance = CardAppearance.create(new ReviewerCustomFonts(this.getBaseContext()), preferences);\r\n+        super.onCreate(savedInstanceState);\r\n+        setContentView(getContentViewAttr(mPrefFullscreenReview));\r\n+\r\n+        // Make ACTION_PROCESS_TEXT for in-app searching possible on > Android 4.0\r\n+        getDelegate().setHandleNativeActionModesEnabled(true);\r\n+\r\n+        View mainView = findViewById(android.R.id.content);\r\n+        initNavigationDrawer(mainView);\r\n+    }\r\n+\r\n+    protected int getContentViewAttr(int fullscreenMode) {\r\n+        return R.layout.reviewer;\r\n+    }\r\n+\r\n+    @ Override\r\n+    public void onConfigurationChanged(Configuration config) {\r\n+        // called when screen rotated, etc, since recreating the Webview is too expensive\r\n+        super.onConfigurationChanged(config);\r\n+        refreshActionBar();\r\n+    }\r\n+\r\n+\r\n+    protected abstract void setTitle();\r\n+\r\n+    public void showQuestionTask(){\r\n+        long delay = mWaitQuestionSecond * 1000;\r\n+        if (delay > 0) {\r\n+            mTimeoutHandler.postDelayed(mShowQuestionTask, delay);\r\n+        }\r\n+    }\r\n+    public void showAnswerTask(){\r\n+        long delay = mWaitAnswerSecond * 1000;\r\n+        if (delay > 0) {\r\n+            mTimeoutHandler.postDelayed(mShowAnswerTask, delay);\r\n+        }\r\n+    }\r\n+    private static void openTtsHelpUrl(Uri helpUrl) {\r\n+        AnkiActivity activity =  (AnkiActivity) ReadText.getmReviewer().get();\r\n+        activity.openUrl(helpUrl);\r\n+    }\r\n+    public void initializeTts(Context context) {\r\n+        // Store weak reference to Activity to prevent memory leak\r\n+        ReadText.setmReviewer(new WeakReference<>(context));\r\n+        // Create new TTS object and setup its onInit Listener\r\n+        ReadText.setmTts( new TextToSpeech(context, new TextToSpeech.OnInitListener() {\r\n+            @Override\r\n+            public void onInit(int status) {\r\n+                if (status == TextToSpeech.SUCCESS) {\r\n+                    // build list of available languages\r\n+                    ReadText.buildAvailableLanguages();\r\n+                    if (ReadText.getAvailableTtsLocales().size() > 0) {\r\n+                        // notify the reviewer that TTS has been initialized\r\n+                        Timber.d(\"TTS initialized and available languages found\");\r\n+                        ((AbstractFlashcardViewer) ReadText.getmReviewer().get()).ttsInitialized();\r\n+                    } else {\r\n+                        Toast.makeText(ReadText.getmReviewer().get(), ReadText.getmReviewer().get().getString(R.string.no_tts_available_message), Toast.LENGTH_LONG).show();\r\n+                        Timber.w(\"TTS initialized but no available languages found\");\r\n+                    }\r\n+                    ReadText.getmTts().setOnUtteranceProgressListener(new UtteranceProgressListener() {\r\n+                        @Override\r\n+                        public void onDone(String arg0) {\r\n+                            if (ReadText.sTextQueue.size() > 0) {\r\n+                                String[] text = ReadText.sTextQueue.remove(0);\r\n+                                ReadText.speak(text[0], text[1], TextToSpeech.QUEUE_FLUSH);\r\n+                            }\r\n+                            if(ReadText.getmQuestionAnswer()==Sound.SOUNDS_QUESTION){\r\n+                                showAnswerTask();\r\n+                            }else if(ReadText.getmQuestionAnswer()==Sound.SOUNDS_ANSWER){\r\n+                                showQuestionTask();\r\n+                            }\r\n+                        }\r\n+                        @Override\r\n+                        @Deprecated\r\n+                        public void onError(String utteranceId) {\r\n+                            Timber.v(\"Andoid TTS failed. Check logcat for error. Indicates a problem with Android TTS engine.\");\r\n+\r\n+                            final Uri helpUrl = Uri.parse(ReadText.getmReviewer().get().getString(R.string.link_faq_tts));\r\n+                            final AnkiActivity ankiActivity = (AnkiActivity) ReadText.getmReviewer().get();\r\n+                            ankiActivity.mayOpenUrl(helpUrl);\r\n+                            UIUtils.showSnackbar(ankiActivity, R.string.no_tts_available_message, false, R.string.help,\r\n+                                    v -> openTtsHelpUrl(helpUrl), ankiActivity.findViewById(R.id.root_layout),\r\n+                                    new Snackbar.Callback());\r\n+                        }\r\n+                        @Override\r\n+                        public void onStart(String arg0) {\r\n+                            // no nothing\r\n+                        }\r\n+                    });\r\n+                } else {\r\n+                    Toast.makeText(ReadText.getmReviewer().get(), ReadText.getmReviewer().get().getString(R.string.no_tts_available_message), Toast.LENGTH_LONG).show();\r", "originalCommit": "c1a7d9809ab95f6a2ce39a1776a82dc862ebbda1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NjEwMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r426446103", "bodyText": "This PR has reverted some changes in AbstractFlashCardViewer, could you undo this so the commit only contains changes that you've made which are required for the feature.", "author": "david-allison-1", "createdAt": "2020-05-18T08:16:30Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -1,3113 +1,3174 @@\n-/****************************************************************************************\n- * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *\n- * Copyright (c) 2014\u201315 Roland Sieker <ospalh@gmail.com>                               *\n- * Copyright (c) 2015 Timothy Rae <perceptualchaos2@gmail.com>                          *\n- * Copyright (c) 2016 Mark Carter <mark@marcardar.com>                                  *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.annotation.TargetApi;\n-import android.app.Activity;\n-import android.content.ActivityNotFoundException;\n-import android.content.BroadcastReceiver;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.IntentFilter;\n-import android.content.SharedPreferences;\n-import android.content.res.Configuration;\n-import android.content.res.Resources;\n-import android.graphics.Color;\n-import android.net.Uri;\n-import android.os.Build;\n-import android.os.Bundle;\n-import android.os.Handler;\n-import android.os.Message;\n-import android.os.SystemClock;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.IdRes;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import androidx.core.view.GestureDetectorCompat;\n-import androidx.appcompat.app.ActionBar;\n-import android.text.SpannableString;\n-import android.text.Spanned;\n-import android.text.SpannedString;\n-import android.text.TextUtils;\n-import android.text.style.UnderlineSpan;\n-import android.util.TypedValue;\n-import android.view.GestureDetector.SimpleOnGestureListener;\n-import android.view.KeyEvent;\n-import android.view.LayoutInflater;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.View.OnClickListener;\n-import android.view.ViewGroup;\n-import android.view.WindowManager;\n-import android.view.inputmethod.EditorInfo;\n-import android.view.inputmethod.InputMethodManager;\n-import android.webkit.JsResult;\n-import android.webkit.RenderProcessGoneDetail;\n-import android.webkit.WebChromeClient;\n-import android.webkit.WebResourceRequest;\n-import android.webkit.WebResourceResponse;\n-import android.webkit.WebView;\n-import android.webkit.WebViewClient;\n-import android.widget.Button;\n-import android.widget.Chronometer;\n-import android.widget.EditText;\n-import android.widget.FrameLayout;\n-import android.widget.ImageView;\n-import android.widget.LinearLayout;\n-import android.widget.RelativeLayout;\n-import android.widget.TextView;\n-\n-import com.afollestad.materialdialogs.MaterialDialog;\n-import com.afollestad.materialdialogs.util.TypefaceHelper;\n-import com.ichi2.anim.ActivityTransitionAnimation;\n-import com.ichi2.anim.ViewAnimation;\n-import com.ichi2.anki.cardviewer.CardAppearance;\n-import com.ichi2.anki.receiver.SdCardReceiver;\n-import com.ichi2.anki.reviewer.CardMarker;\n-import com.ichi2.anki.reviewer.CardMarker.FlagDef;\n-import com.ichi2.anki.reviewer.ReviewerCustomFonts;\n-import com.ichi2.anki.reviewer.ReviewerUi;\n-import com.ichi2.anki.cardviewer.TypedAnswer;\n-import com.ichi2.async.CollectionTask;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.sched.AbstractSched;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Note;\n-import com.ichi2.libanki.Sound;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.template.Template;\n-import com.ichi2.themes.HtmlColors;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.utils.AdaptionUtil;\n-import com.ichi2.utils.DiffEngine;\n-import com.ichi2.utils.FunctionalInterfaces.Consumer;\n-import com.ichi2.utils.FunctionalInterfaces.Function;\n-\n-import com.ichi2.utils.JSONArray;\n-import com.ichi2.utils.JSONException;\n-import com.ichi2.utils.JSONObject;\n-import com.ichi2.utils.WebViewDebugging;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.UnsupportedEncodingException;\n-import java.lang.ref.WeakReference;\n-import java.net.URLDecoder;\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReadWriteLock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.calculateDynamicFontSize;\n-import static com.ichi2.anki.cardviewer.ViewerCommand.*;\n-import static com.ichi2.anki.reviewer.CardMarker.*;\n-\n-@SuppressWarnings({\"PMD.AvoidThrowingRawExceptionTypes\",\"PMD.FieldDeclarationsShouldBeAtStartOfClass\"})\n-public abstract class AbstractFlashcardViewer extends NavigationDrawerActivity implements ReviewerUi, CommandProcessor {\n-\n-    /**\n-     * Result codes that are returned when this activity finishes.\n-     */\n-    public static final int RESULT_DEFAULT = 50;\n-    public static final int RESULT_NO_MORE_CARDS = 52;\n-\n-    /**\n-     * Available options performed by other activities.\n-     */\n-    public static final int EDIT_CURRENT_CARD = 0;\n-    public static final int DECK_OPTIONS = 1;\n-\n-    public static final int EASE_1 = 1;\n-    public static final int EASE_2 = 2;\n-    public static final int EASE_3 = 3;\n-    public static final int EASE_4 = 4;\n-\n-    /** Maximum time in milliseconds to wait before accepting answer button presses. */\n-    private static final int DOUBLE_TAP_IGNORE_THRESHOLD = 200;\n-\n-    /** Time to wait in milliseconds before resuming fullscreen mode **/\n-    protected static final int INITIAL_HIDE_DELAY = 200;\n-\n-    // Type answer patterns\n-    private static final Pattern sTypeAnsPat = Pattern.compile(\"\\\\[\\\\[type:(.+?)\\\\]\\\\]\");\n-\n-    /** to be sent to and from the card editor */\n-    private static Card sEditorCard;\n-\n-    protected static boolean sDisplayAnswer = false;\n-\n-    private boolean mTtsInitialized = false;\n-    private boolean mReplayOnTtsInit = false;\n-\n-    protected static final int MENU_DISABLED = 3;\n-\n-\n-    /**\n-     * Broadcast that informs us when the sd card is about to be unmounted\n-     */\n-    private BroadcastReceiver mUnmountReceiver = null;\n-\n-    /**\n-     * Variables to hold preferences\n-     */\n-    private CardAppearance mCardAppearance;\n-    private boolean mPrefHideDueCount;\n-    private boolean mPrefShowETA;\n-    private boolean mShowTimer;\n-    protected boolean mPrefWhiteboard;\n-    private int mPrefFullscreenReview;\n-    private int mRelativeButtonSize;\n-    private boolean mDoubleScrolling;\n-    private boolean mScrollingButtons;\n-    private boolean mGesturesEnabled;\n-    // Android WebView\n-    protected boolean mSpeakText;\n-    protected boolean mDisableClipboard = false;\n-\n-    protected boolean mOptUseGeneralTimerSettings;\n-\n-    protected boolean mUseTimer;\n-    protected int mWaitAnswerSecond;\n-    protected int mWaitQuestionSecond;\n-\n-    protected boolean mPrefUseTimer;\n-\n-    protected boolean mOptUseTimer;\n-    protected int mOptWaitAnswerSecond;\n-    protected int mOptWaitQuestionSecond;\n-\n-    protected boolean mUseInputTag;\n-\n-    // Preferences from the collection\n-    private boolean mShowNextReviewTime;\n-    private boolean mShowRemainingCardCount;\n-\n-    // Answer card & cloze deletion variables\n-    private String mTypeCorrect = null;\n-    // The correct answer in the compare to field if answer should be given by learner. Null if no answer is expected.\n-    private String mTypeInput = \"\";  // What the learner actually typed\n-    private String mTypeFont = \"\";  // Font face of the compare to field\n-    private int mTypeSize = 0;  // Its font size\n-    private String mTypeWarning;\n-\n-    private boolean mIsSelecting = false;\n-    private boolean mTouchStarted = false;\n-    private boolean mInAnswer = false;\n-    private boolean mAnswerSoundsAdded = false;\n-\n-    private String mCardTemplate;\n-\n-    /**\n-     * Variables to hold layout objects that we need to update or handle events for\n-     */\n-    private View mLookUpIcon;\n-    private WebView mCard;\n-    private FrameLayout mCardFrame;\n-    private FrameLayout mTouchLayer;\n-    private TextView mTextBarNew;\n-    private TextView mTextBarLearn;\n-    private TextView mTextBarReview;\n-    private TextView mChosenAnswer;\n-    protected TextView mNext1;\n-    protected TextView mNext2;\n-    protected TextView mNext3;\n-    protected TextView mNext4;\n-    protected EditText mAnswerField;\n-    protected TextView mEase1;\n-    protected TextView mEase2;\n-    protected TextView mEase3;\n-    protected TextView mEase4;\n-    protected LinearLayout mFlipCardLayout;\n-    protected LinearLayout mEase1Layout;\n-    protected LinearLayout mEase2Layout;\n-    protected LinearLayout mEase3Layout;\n-    protected LinearLayout mEase4Layout;\n-    protected RelativeLayout mTopBarLayout;\n-    private Chronometer mCardTimer;\n-    protected Whiteboard mWhiteboard;\n-    @SuppressWarnings(\"deprecation\") // Tracked separately as #5023 on github\n-    private android.text.ClipboardManager mClipboard;\n-\n-    protected Card mCurrentCard;\n-    private int mCurrentEase;\n-\n-    private boolean mButtonHeightSet = false;\n-\n-    private boolean mConfigurationChanged = false;\n-    private int mShowChosenAnswerLength = 2000;\n-\n-    /**\n-     * A record of the last time the \"show answer\" or ease buttons were pressed. We keep track\n-     * of this time to ignore accidental button presses.\n-     */\n-    private long mLastClickTime;\n-\n-    /**\n-     * Swipe Detection\n-     */\n-    private GestureDetectorCompat gestureDetector;\n-\n-    private boolean mIsXScrolling = false;\n-    private boolean mIsYScrolling = false;\n-\n-    /**\n-     * Gesture Allocation\n-     */\n-    private int mGestureSwipeUp;\n-    private int mGestureSwipeDown;\n-    private int mGestureSwipeLeft;\n-    private int mGestureSwipeRight;\n-    private int mGestureDoubleTap;\n-    private int mGestureTapLeft;\n-    private int mGestureTapRight;\n-    private int mGestureTapTop;\n-    private int mGestureTapBottom;\n-    private int mGestureLongclick;\n-\n-    private Spanned mCardContent;\n-    private String mBaseUrl;\n-\n-    private int mFadeDuration = 300;\n-\n-    protected AbstractSched mSched;\n-\n-    private Sound mSoundPlayer = new Sound();\n-\n-    private long mUseTimerDynamicMS;\n-\n-    /**\n-     * Last card that the WebView Renderer crashed on.\n-     * If we get 2 crashes on the same card, then we likely have an infinite loop and want to exit gracefully.\n-     */\n-    @Nullable\n-    private Long lastCrashingCardId = null;\n-\n-    /** Reference to the parent of the cardFrame to allow regeneration of the cardFrame in case of crash */\n-    private ViewGroup mCardFrameParent;\n-\n-    /** Lock to allow thread-safe regeneration of mCard */\n-    private ReadWriteLock mCardLock = new ReentrantReadWriteLock();\n-\n-    /** whether controls are currently blocked */\n-    private boolean mControlBlocked = true;\n-\n-    /** Handle Mark/Flag state of cards */\n-    private CardMarker mCardMarker;\n-    // private int zEase;\n-\n-    // ----------------------------------------------------------------------------\n-    // LISTENERS\n-    // ----------------------------------------------------------------------------\n-\n-    private Handler mHandler = new Handler() {\n-\n-        @Override\n-        public void handleMessage(Message msg) {\n-            mSoundPlayer.stopSounds();\n-            mSoundPlayer.playSound((String) msg.obj, null);\n-        }\n-    };\n-\n-    private final Handler longClickHandler = new Handler();\n-    private final Runnable longClickTestRunnable = new Runnable() {\n-        @Override\n-        public void run() {\n-            Timber.i(\"AbstractFlashcardViewer:: onEmulatedLongClick\");\n-            // Show hint about lookup function if dictionary available\n-            if (!mDisableClipboard && Lookup.isAvailable()) {\n-                String lookupHint = getResources().getString(R.string.lookup_hint);\n-                UIUtils.showThemedToast(AbstractFlashcardViewer.this, lookupHint, false);\n-            }\n-            CompatHelper.getCompat().vibrate(AnkiDroidApp.getInstance().getApplicationContext(), 50);\n-            longClickHandler.postDelayed(startLongClickAction, 300);\n-        }\n-    };\n-    private final Runnable startLongClickAction = new Runnable() {\n-        @Override\n-        public void run() {\n-            executeCommand(mGestureLongclick);\n-        }\n-    };\n-\n-\n-    // Handler for the \"show answer\" button\n-    private View.OnClickListener mFlipCardListener = new View.OnClickListener() {\n-        @Override\n-        public void onClick(View view) {\n-            Timber.i(\"AbstractFlashcardViewer:: Show answer button pressed\");\n-            // Ignore what is most likely an accidental double-tap.\n-            if (SystemClock.elapsedRealtime() - mLastClickTime < DOUBLE_TAP_IGNORE_THRESHOLD) {\n-                return;\n-            }\n-            mLastClickTime = SystemClock.elapsedRealtime();\n-            mTimeoutHandler.removeCallbacks(mShowAnswerTask);\n-            displayCardAnswer();\n-        }\n-    };\n-\n-    private View.OnClickListener mSelectEaseHandler = new View.OnClickListener() {\n-        @Override\n-        public void onClick(View view) {\n-            // Ignore what is most likely an accidental double-tap.\n-            if (SystemClock.elapsedRealtime() - mLastClickTime < DOUBLE_TAP_IGNORE_THRESHOLD) {\n-                return;\n-            }\n-            mLastClickTime = SystemClock.elapsedRealtime();\n-            mTimeoutHandler.removeCallbacks(mShowQuestionTask);\n-            switch (view.getId()) {\n-                case R.id.flashcard_layout_ease1:\n-                    Timber.i(\"AbstractFlashcardViewer:: EASE_1 pressed\");\n-                    answerCard(EASE_1);\n-                    break;\n-                case R.id.flashcard_layout_ease2:\n-                    Timber.i(\"AbstractFlashcardViewer:: EASE_2 pressed\");\n-                    answerCard(EASE_2);\n-                    break;\n-                case R.id.flashcard_layout_ease3:\n-                    Timber.i(\"AbstractFlashcardViewer:: EASE_3 pressed\");\n-                    answerCard(EASE_3);\n-                    break;\n-                case R.id.flashcard_layout_ease4:\n-                    Timber.i(\"AbstractFlashcardViewer:: EASE_4 pressed\");\n-                    answerCard(EASE_4);\n-                    break;\n-                default:\n-                    mCurrentEase = 0;\n-                    break;\n-            }\n-        }\n-    };\n-\n-    private View.OnTouchListener mGestureListener = new View.OnTouchListener() {\n-        @Override\n-        public boolean onTouch(View v, MotionEvent event) {\n-            if (gestureDetector.onTouchEvent(event)) {\n-                return true;\n-            }\n-            if (!mDisableClipboard) {\n-                switch (event.getAction()) {\n-                    case MotionEvent.ACTION_DOWN:\n-                        mTouchStarted = true;\n-                        longClickHandler.postDelayed(longClickTestRunnable, 800);\n-                        break;\n-                    case MotionEvent.ACTION_UP:\n-                    case MotionEvent.ACTION_MOVE:\n-                        if (mTouchStarted) {\n-                            longClickHandler.removeCallbacks(longClickTestRunnable);\n-                            mTouchStarted = false;\n-                        }\n-                        break;\n-                    default:\n-                        longClickHandler.removeCallbacks(longClickTestRunnable);\n-                        mTouchStarted = false;\n-                        break;\n-                }\n-            }\n-            //Gesture listener is added before mCard is set\n-            processCardAction(card -> {\n-                if (card == null) return;\n-                card.dispatchTouchEvent(event);\n-            });\n-            return false;\n-        }\n-    };\n-\n-    @SuppressLint(\"CheckResult\")\n-    private void processCardAction(Consumer<WebView> cardConsumer) {\n-        processCardFunction(card -> {\n-            cardConsumer.consume(card);\n-            return true;\n-        });\n-    }\n-\n-    @CheckResult\n-    private <T> T processCardFunction(Function<WebView, T> cardFunction) {\n-        Lock readLock = mCardLock.readLock();\n-        try {\n-            readLock.lock();\n-            return cardFunction.apply(mCard);\n-        } finally {\n-            readLock.unlock();\n-        }\n-    }\n-\n-\n-    protected CollectionTask.TaskListener mDismissCardHandler = new NextCardHandler() { /* superclass is sufficient */ };\n-\n-\n-    private CollectionTask.TaskListener mUpdateCardHandler = new CollectionTask.TaskListener() {\n-        private boolean mNoMoreCards;\n-\n-\n-        @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n-        }\n-\n-\n-        @Override\n-        public void onProgressUpdate(CollectionTask.TaskData... values) {\n-            boolean cardChanged = false;\n-            if (mCurrentCard != values[0].getCard()) {\n-                /*\n-                 * Before updating mCurrentCard, we check whether it is changing or not. If the current card changes,\n-                 * then we need to display it as a new card, without showing the answer.\n-                 */\n-                sDisplayAnswer = false;\n-                cardChanged = true;  // Keep track of that so we can run a bit of new-card code\n-            }\n-            mCurrentCard = values[0].getCard();\n-            if (mCurrentCard == null) {\n-                // If the card is null means that there are no more cards scheduled for review.\n-                mNoMoreCards = true;\n-                showProgressBar();\n-                return;\n-            }\n-            if (mPrefWhiteboard && mWhiteboard != null) {\n-                mWhiteboard.clear();\n-            }\n-\n-            if (sDisplayAnswer) {\n-                mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n-                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n-                generateQuestionSoundList(); // questions must be intentionally regenerated\n-                displayCardAnswer();\n-            } else {\n-                if (cardChanged) {\n-                    updateTypeAnswerInfo();\n-                }\n-                displayCardQuestion();\n-                mCurrentCard.startTimer();\n-                initTimer();\n-            }\n-            hideProgressBar();\n-        }\n-\n-\n-        @Override\n-        public void onPostExecute(CollectionTask.TaskData result) {\n-            if (!result.getBoolean()) {\n-                // RuntimeException occurred on update cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n-                return;\n-            }\n-            if (mNoMoreCards) {\n-                closeReviewer(RESULT_NO_MORE_CARDS, true);\n-            }\n-        }\n-    };\n-\n-    abstract class NextCardHandler extends CollectionTask.TaskListener {\n-        private boolean mNoMoreCards;\n-\n-\n-        @Override\n-        public void onPreExecute() { /* do nothing */}\n-\n-\n-        @Override\n-        public void onProgressUpdate(CollectionTask.TaskData... values) {\n-            displayNext(values[0].getCard());\n-        }\n-\n-        protected void displayNext(Card nextCard) {\n-\n-            Resources res = getResources();\n-\n-            if (mSched == null) {\n-                // TODO: proper testing for restored activity\n-                finishWithoutAnimation();\n-                return;\n-            }\n-\n-            mCurrentCard = nextCard;\n-            if (mCurrentCard == null) {\n-                // If the card is null means that there are no more cards scheduled for review.\n-                mNoMoreCards = true; // other handlers use this, toggle state every time through\n-            } else {\n-                mNoMoreCards = false; // other handlers use this, toggle state every time through\n-                // Start reviewing next card\n-                updateTypeAnswerInfo();\n-                hideProgressBar();\n-                AbstractFlashcardViewer.this.unblockControls();\n-                AbstractFlashcardViewer.this.displayCardQuestion();\n-            }\n-\n-            // Since reps are incremented on fetch of next card, we will miss counting the\n-            // last rep since there isn't a next card. We manually account for it here.\n-            if (mNoMoreCards) {\n-                mSched.setReps(mSched.getReps() + 1);\n-            }\n-\n-            Long[] elapsed = getCol().timeboxReached();\n-            if (elapsed != null) {\n-                // AnkiDroid is always counting one rep ahead, so we decrement it before displaying\n-                // it to the user.\n-                int nCards = elapsed[1].intValue() - 1;\n-                int nMins = elapsed[0].intValue() / 60;\n-                String mins = res.getQuantityString(R.plurals.in_minutes, nMins, nMins);\n-                String timeboxMessage = res.getQuantityString(R.plurals.timebox_reached, nCards, nCards, mins);\n-                UIUtils.showThemedToast(AbstractFlashcardViewer.this, timeboxMessage, true);\n-                getCol().startTimebox();\n-            }\n-        }\n-\n-\n-        @Override\n-        public void onPostExecute(CollectionTask.TaskData result) {\n-            postNextCardDisplay(result.getBoolean());\n-        }\n-\n-        protected void postNextCardDisplay(boolean displaySuccess) {\n-            if (!displaySuccess) {\n-                // RuntimeException occurred on answering cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n-                return;\n-            }\n-            // Check for no more cards before session complete. If they are both true, no more cards will take\n-            // precedence when returning to study options.\n-            if (mNoMoreCards) {\n-                closeReviewer(RESULT_NO_MORE_CARDS, true);\n-            }\n-            // set the correct mark/unmark icon on action bar\n-            refreshActionBar();\n-            findViewById(R.id.root_layout).requestFocus();\n-        }\n-    }\n-\n-\n-    protected CollectionTask.TaskListener mAnswerCardHandler = new NextCardHandler() {\n-\n-\n-        @Override\n-        public void onPreExecute() {\n-            blockControls();\n-        }\n-    };\n-\n-\n-    /**\n-     * Extract type answer/cloze text and font/size\n-     */\n-    private void updateTypeAnswerInfo() {\n-        mTypeCorrect = null;\n-        mTypeInput = \"\";\n-        String q = mCurrentCard.q(false);\n-        Matcher m = sTypeAnsPat.matcher(q);\n-        int clozeIdx = 0;\n-        if (!m.find()) {\n-            return;\n-        }\n-        String fld = m.group(1);\n-        // if it's a cloze, extract data\n-        if (fld.startsWith(\"cloze:\", 0)) {\n-            // get field and cloze position\n-            clozeIdx = mCurrentCard.getOrd() + 1;\n-            fld = fld.split(\":\")[1];\n-        }\n-        // loop through fields for a match\n-        JSONArray ja = mCurrentCard.model().getJSONArray(\"flds\");\n-        for (int i = 0; i < ja.length(); i++) {\n-            String name = (String) (ja.getJSONObject(i).get(\"name\"));\n-            if (name.equals(fld)) {\n-                mTypeCorrect = mCurrentCard.note().getItem(name);\n-                if (clozeIdx != 0) {\n-                    // narrow to cloze\n-                    mTypeCorrect = contentForCloze(mTypeCorrect, clozeIdx);\n-                }\n-                mTypeFont = (String) (ja.getJSONObject(i).get(\"font\"));\n-                mTypeSize = (int) (ja.getJSONObject(i).get(\"size\"));\n-                break;\n-            }\n-        }\n-        if (mTypeCorrect == null) {\n-            if (clozeIdx != 0) {\n-                mTypeWarning = getResources().getString(R.string.empty_card_warning);\n-            } else {\n-                mTypeWarning = getResources().getString(R.string.unknown_type_field_warning, fld);\n-            }\n-        } else if (\"\".equals(mTypeCorrect)) {\n-            mTypeCorrect = null;\n-        } else {\n-            mTypeWarning = null;\n-        }\n-    }\n-\n-\n-    /**\n-     * Format question field when it contains typeAnswer or clozes. If there was an error during type text extraction, a\n-     * warning is displayed\n-     *\n-     * @param buf The question text\n-     * @return The formatted question text\n-     */\n-    private String typeAnsQuestionFilter(String buf) {\n-        Matcher m = sTypeAnsPat.matcher(buf);\n-        if (mTypeWarning != null) {\n-            return m.replaceFirst(mTypeWarning);\n-        }\n-        StringBuilder sb = new StringBuilder();\n-        if (mUseInputTag) {\n-            // These functions are defined in the JavaScript file assets/scripts/card.js. We get the text back in\n-            // shouldOverrideUrlLoading() in createWebView() in this file.\n-            sb.append(\"<center>\\n<input type=\\\"text\\\" name=\\\"typed\\\" id=\\\"typeans\\\" onfocus=\\\"taFocus();\\\" \" +\n-                    \"onblur=\\\"taBlur(this);\\\" onKeyPress=\\\"return taKey(this, event)\\\" autocomplete=\\\"off\\\" \");\n-            // We have to watch out. For the preview we don\u2019t know the font or font size. Skip those there. (Anki\n-            // desktop just doesn\u2019t show the input tag there. Do it with standard values here instead.)\n-            if (mTypeFont != null && !TextUtils.isEmpty(mTypeFont) && mTypeSize > 0) {\n-                sb.append(\"style=\\\"font-family: '\").append(mTypeFont).append(\"'; font-size: \")\n-                        .append(Integer.toString(mTypeSize)).append(\"px;\\\" \");\n-            }\n-            sb.append(\">\\n</center>\\n\");\n-        } else {\n-            sb.append(\"<span id=\\\"typeans\\\" class=\\\"typePrompt\");\n-            if (mUseInputTag) {\n-                sb.append(\" typeOff\");\n-            }\n-            sb.append(\"\\\">........</span>\");\n-        }\n-        return m.replaceAll(sb.toString());\n-    }\n-\n-\n-    /**\n-     * Fill the placeholder for the type comparison. Show the correct answer, and the comparison if appropriate.\n-     *\n-     * @param buf The answer text\n-     * @param userAnswer Text typed by the user, or empty.\n-     * @param correctAnswer The correct answer, taken from the note.\n-     * @return The formatted answer text\n-     */\n-    @VisibleForTesting\n-    String typeAnsAnswerFilter(String buf, String userAnswer, String correctAnswer) {\n-        Matcher m = sTypeAnsPat.matcher(buf);\n-        DiffEngine diffEngine = new DiffEngine();\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"<div><code id=\\\"typeans\\\">\");\n-\n-        // We have to use Matcher.quoteReplacement because the inputs here might have $ or \\.\n-\n-        if (!TextUtils.isEmpty(userAnswer)) {\n-            // The user did type something.\n-            if (userAnswer.equals(correctAnswer)) {\n-                // and it was right.\n-                sb.append(Matcher.quoteReplacement(DiffEngine.wrapGood(correctAnswer)));\n-                sb.append(\"<span id=\\\"typecheckmark\\\">\\u2714</span>\"); // Heavy check mark\n-            } else {\n-                // Answer not correct.\n-                // Only use the complex diff code when needed, that is when we have some typed text that is not\n-                // exactly the same as the correct text.\n-                String[] diffedStrings = diffEngine.diffedHtmlStrings(correctAnswer, userAnswer);\n-                // We know we get back two strings.\n-                sb.append(Matcher.quoteReplacement(diffedStrings[0]));\n-                sb.append(\"<br><span id=\\\"typearrow\\\">&darr;</span><br>\");\n-                sb.append(Matcher.quoteReplacement(diffedStrings[1]));\n-            }\n-        } else {\n-            if (!mUseInputTag) {\n-                sb.append(Matcher.quoteReplacement(DiffEngine.wrapMissing(correctAnswer)));\n-            } else {\n-                sb.append(Matcher.quoteReplacement(correctAnswer));\n-            }\n-        }\n-        sb.append(\"</code></div>\");\n-        return m.replaceAll(sb.toString());\n-    }\n-\n-    /**\n-     * Return the correct answer to use for {{type::cloze::NN}} fields.\n-     *\n-     * @param txt The field text with the clozes\n-     * @param idx The index of the cloze to use\n-     * @return A string with a comma-separeted list of unique cloze strings with the corret index.\n-     */\n-\n-    private String contentForCloze(String txt, int idx) {\n-        Pattern re = Pattern.compile(\"\\\\{\\\\{c\" + idx + \"::(.+?)\\\\}\\\\}\");\n-        Matcher m = re.matcher(txt);\n-        Set<String> matches = new LinkedHashSet<>();\n-        // LinkedHashSet: make entries appear only once, like Anki desktop (see also issue #2208), and keep the order\n-        // they appear in.\n-        String groupOne;\n-        int colonColonIndex = -1;\n-        while (m.find()) {\n-            groupOne = m.group(1);\n-            colonColonIndex = groupOne.indexOf(\"::\");\n-            if (colonColonIndex > -1) {\n-                // Cut out the hint.\n-                groupOne = groupOne.substring(0, colonColonIndex);\n-            }\n-            matches.add(groupOne);\n-        }\n-        // Now do what the pythonic \", \".join(matches) does in a tricky way\n-        String prefix = \"\";\n-        StringBuilder resultBuilder = new StringBuilder();\n-        for (String match : matches) {\n-            resultBuilder.append(prefix);\n-            resultBuilder.append(match);\n-            prefix = \", \";\n-        }\n-        return resultBuilder.toString();\n-    }\n-\n-    private Handler mTimerHandler = new Handler();\n-\n-    private Runnable removeChosenAnswerText = new Runnable() {\n-        @Override\n-        public void run() {\n-            mChosenAnswer.setText(\"\");\n-        }\n-    };\n-\n-    protected int mPrefWaitAnswerSecond;\n-    protected int mPrefWaitQuestionSecond;\n-\n-    protected int getDefaultEase() {\n-        if (getAnswerButtonCount() == 4) {\n-            return EASE_3;\n-        } else {\n-            return EASE_2;\n-        }\n-    }\n-\n-\n-    protected int getAnswerButtonCount() {\n-        return getCol().getSched().answerButtons(mCurrentCard);\n-    }\n-\n-\n-    // ----------------------------------------------------------------------------\n-    // ANDROID METHODS\n-    // ----------------------------------------------------------------------------\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        Timber.d(\"onCreate()\");\n-        SharedPreferences preferences = restorePreferences();\n-        mCardAppearance = CardAppearance.create(new ReviewerCustomFonts(this.getBaseContext()), preferences);\n-        super.onCreate(savedInstanceState);\n-        setContentView(getContentViewAttr(mPrefFullscreenReview));\n-\n-        // Make ACTION_PROCESS_TEXT for in-app searching possible on > Android 4.0\n-        getDelegate().setHandleNativeActionModesEnabled(true);\n-\n-        View mainView = findViewById(android.R.id.content);\n-        initNavigationDrawer(mainView);\n-    }\n-\n-    protected int getContentViewAttr(int fullscreenMode) {\n-        return R.layout.reviewer;\n-    }\n-\n-    @ Override\n-    public void onConfigurationChanged(Configuration config) {\n-        // called when screen rotated, etc, since recreating the Webview is too expensive\n-        super.onConfigurationChanged(config);\n-        refreshActionBar();\n-    }\n-\n-\n-    protected abstract void setTitle();\n-\n-\n-    // Finish initializing the activity after the collection has been correctly loaded\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        mSched = col.getSched();\n-        mBaseUrl = Utils.getBaseUrl(col.getMedia().dir());\n-\n-        registerExternalStorageListener();\n-\n-        restoreCollectionPreferences();\n-\n-        initLayout();\n-\n-        setTitle();\n-\n-        if (!mDisableClipboard) {\n-            clipboardSetText(\"\");\n-        }\n-\n-        // Load the template for the card\n-        try {\n-            mCardTemplate = Utils.convertStreamToString(getAssets().open(\"card_template.html\"));\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-\n-        // Initialize text-to-speech. This is an asynchronous operation.\n-        if (mSpeakText) {\n-            ReadText.initializeTts(this);\n-        }\n-\n-        // Initialize dictionary lookup feature\n-        Lookup.initialize(this);\n-\n-        updateScreenCounts();\n-        supportInvalidateOptionsMenu();\n-    }\n-\n-    // Saves deck each time Reviewer activity loses focus\n-    @Override\n-    protected void onPause() {\n-        super.onPause();\n-        Timber.d(\"onPause()\");\n-\n-        mTimeoutHandler.removeCallbacks(mShowAnswerTask);\n-        mTimeoutHandler.removeCallbacks(mShowQuestionTask);\n-        longClickHandler.removeCallbacks(longClickTestRunnable);\n-        longClickHandler.removeCallbacks(startLongClickAction);\n-\n-        pauseTimer();\n-        mSoundPlayer.stopSounds();\n-\n-        // Prevent loss of data in Cookies\n-        CompatHelper.getCompat().flushWebViewCookies();\n-    }\n-\n-\n-    @Override\n-    protected void onResume() {\n-        super.onResume();\n-        resumeTimer();\n-        // Set the context for the Sound manager\n-        mSoundPlayer.setContext(new WeakReference<Activity>(this));\n-        // Reset the activity title\n-        setTitle();\n-        updateScreenCounts();\n-        selectNavigationItem(-1);\n-    }\n-\n-\n-    @Override\n-    protected void onDestroy() {\n-        super.onDestroy();\n-        Timber.d(\"onDestroy()\");\n-        if (mSpeakText) {\n-            ReadText.releaseTts();\n-        }\n-        if (mUnmountReceiver != null) {\n-            unregisterReceiver(mUnmountReceiver);\n-        }\n-        // WebView.destroy() should be called after the end of use\n-        // http://developer.android.com/reference/android/webkit/WebView.html#destroy()\n-        if (mCardFrame != null) {\n-            mCardFrame.removeAllViews();\n-        }\n-        destroyWebView(mCard); //OK to do without a lock\n-    }\n-\n-\n-    @Override\n-    public void onBackPressed() {\n-        if (isDrawerOpen()) {\n-            super.onBackPressed();\n-        } else {\n-            Timber.i(\"Back key pressed\");\n-            closeReviewer(RESULT_DEFAULT, false);\n-        }\n-    }\n-\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        if (processCardFunction(card -> processHardwareButtonScroll(keyCode, card))) {\n-            return true;\n-        }\n-        return super.onKeyDown(keyCode, event);\n-    }\n-\n-\n-    private boolean processHardwareButtonScroll(int keyCode, WebView card) {\n-        if (keyCode == KeyEvent.KEYCODE_PAGE_UP) {\n-            card.pageUp(false);\n-            if (mDoubleScrolling) {\n-                card.pageUp(false);\n-            }\n-            return true;\n-        }\n-        if (keyCode == KeyEvent.KEYCODE_PAGE_DOWN) {\n-            card.pageDown(false);\n-            if (mDoubleScrolling) {\n-                card.pageDown(false);\n-            }\n-            return true;\n-        }\n-        if (mScrollingButtons && keyCode == KeyEvent.KEYCODE_PICTSYMBOLS) {\n-            card.pageUp(false);\n-            if (mDoubleScrolling) {\n-                card.pageUp(false);\n-            }\n-            return true;\n-        }\n-        if (mScrollingButtons && keyCode == KeyEvent.KEYCODE_SWITCH_CHARSET) {\n-            card.pageDown(false);\n-            if (mDoubleScrolling) {\n-                card.pageDown(false);\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-\n-    @Override\n-    public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyUp(keyCode, event);\n-        }\n-        if (!sDisplayAnswer) {\n-            if (keyCode == KeyEvent.KEYCODE_SPACE || keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_NUMPAD_ENTER) {\n-                displayCardAnswer();\n-                return true;\n-            }\n-        }\n-        return super.onKeyUp(keyCode, event);\n-    }\n-\n-\n-    protected boolean answerFieldIsFocused() {\n-        return mAnswerField != null && mAnswerField.isFocused();\n-    }\n-\n-\n-    @SuppressWarnings(\"deprecation\") // Tracked separately as #5023 on github\n-    protected boolean clipboardHasText() {\n-        return mClipboard != null && mClipboard.hasText();\n-    }\n-\n-\n-    @SuppressWarnings(\"deprecation\") // Tracked separately as #5023 on github\n-    private void clipboardSetText(CharSequence text) {\n-        if (mClipboard != null) {\n-            try {\n-                mClipboard.setText(text);\n-            } catch (Exception e) {\n-                // https://code.google.com/p/ankidroid/issues/detail?id=1746\n-                // https://code.google.com/p/ankidroid/issues/detail?id=1820\n-                // Some devices or external applications make the clipboard throw exceptions. If this happens, we\n-                // must disable it or AnkiDroid will crash if it tries to use it.\n-                Timber.e(\"Clipboard error. Disabling text selection setting.\");\n-                mDisableClipboard = true;\n-            }\n-        }\n-    }\n-\n-\n-    /**\n-     * Returns the text stored in the clipboard or the empty string if the clipboard is empty or contains something that\n-     * cannot be convered to text.\n-     *\n-     * @return the text in clipboard or the empty string.\n-     */\n-    @SuppressWarnings(\"deprecation\") // Tracked separately as #5023 on github\n-    private CharSequence clipboardGetText() {\n-        CharSequence text = mClipboard != null ? mClipboard.getText() : null;\n-        return text != null ? text : \"\";\n-    }\n-\n-\n-    @Override\n-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n-        super.onActivityResult(requestCode, resultCode, data);\n-\n-        if (resultCode == DeckPicker.RESULT_DB_ERROR) {\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n-        }\n-\n-        if (resultCode == DeckPicker.RESULT_MEDIA_EJECTED) {\n-            finishNoStorageAvailable();\n-        }\n-\n-        /* Reset the schedule and reload the latest card off the top of the stack if required.\n-           The card could have been rescheduled, the deck could have changed, or a change of\n-           note type could have lead to the card being deleted */\n-        if (data != null && data.hasExtra(\"reloadRequired\")) {\n-            getCol().getSched().reset();\n-            CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler,\n-                    new CollectionTask.TaskData(null, 0));\n-        }\n-\n-        if (requestCode == EDIT_CURRENT_CARD) {\n-            if (resultCode == RESULT_OK) {\n-                // content of note was changed so update the note and current card\n-                Timber.i(\"AbstractFlashcardViewer:: Saving card...\");\n-                CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_UPDATE_NOTE, mUpdateCardHandler,\n-                        new CollectionTask.TaskData(sEditorCard, true));\n-            } else if (resultCode == RESULT_CANCELED && !(data!=null && data.hasExtra(\"reloadRequired\"))) {\n-                // nothing was changed by the note editor so just redraw the card\n-                redrawCard();\n-            }\n-        } else if (requestCode == DECK_OPTIONS && resultCode == RESULT_OK) {\n-            getCol().getSched().reset();\n-            CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler,\n-                    new CollectionTask.TaskData(null, 0));\n-        }\n-        if (!mDisableClipboard) {\n-            clipboardSetText(\"\");\n-        }\n-    }\n-\n-\n-    // ----------------------------------------------------------------------------\n-    // CUSTOM METHODS\n-    // ----------------------------------------------------------------------------\n-\n-    // Get the did of the parent deck (ignoring any subdecks)\n-    protected long getParentDid() {\n-        long deckID = getCol().getDecks().selected();\n-        return deckID;\n-    }\n-\n-    private void redrawCard() {\n-        //#3654 We can call this from ActivityResult, which could mean that the card content hasn't yet been set\n-        //if the activity was destroyed. In this case, just wait until onCollectionLoaded callback succeeds.\n-        if (hasLoadedCardContent()) {\n-            fillFlashcard();\n-        } else {\n-            Timber.i(\"Skipping card redraw - card still initialising.\");\n-        }\n-    }\n-\n-    /** Whether the callback to onCollectionLoaded has loaded card content */\n-    private boolean hasLoadedCardContent() {\n-        return mCardContent != null;\n-    }\n-\n-\n-    public GestureDetectorCompat getGestureDetector() {\n-        return gestureDetector;\n-    }\n-\n-\n-    /**\n-     * Show/dismiss dialog when sd card is ejected/remounted (collection is saved by SdCardReceiver)\n-     */\n-    private void registerExternalStorageListener() {\n-        if (mUnmountReceiver == null) {\n-            mUnmountReceiver = new BroadcastReceiver() {\n-                @Override\n-                public void onReceive(Context context, Intent intent) {\n-                    if (intent.getAction().equals(SdCardReceiver.MEDIA_EJECT)) {\n-                        finishWithoutAnimation();\n-                    }\n-                }\n-            };\n-            IntentFilter iFilter = new IntentFilter();\n-            iFilter.addAction(SdCardReceiver.MEDIA_EJECT);\n-            registerReceiver(mUnmountReceiver, iFilter);\n-        }\n-    }\n-\n-\n-    private void pauseTimer() {\n-        if (mCurrentCard != null) {\n-            mCurrentCard.stopTimer();\n-        }\n-        // We also stop the UI timer so it doesn't trigger the tick listener while paused. Letting\n-        // it run would trigger the time limit condition (red, stopped timer) in the background.\n-        if (mCardTimer != null) {\n-            mCardTimer.stop();\n-        }\n-    }\n-\n-\n-    private void resumeTimer() {\n-        if (mCurrentCard != null) {\n-            // Resume the card timer first. It internally accounts for the time gap between\n-            // suspend and resume.\n-            mCurrentCard.resumeTimer();\n-            // Then update and resume the UI timer. Set the base time as if the timer had started\n-            // timeTaken() seconds ago.\n-            mCardTimer.setBase(SystemClock.elapsedRealtime() - mCurrentCard.timeTaken());\n-            // Don't start the timer if we have already reached the time limit or it will tick over\n-            if ((SystemClock.elapsedRealtime() - mCardTimer.getBase()) < mCurrentCard.timeLimit()) {\n-                mCardTimer.start();\n-            }\n-        }\n-    }\n-\n-\n-    protected void undo() {\n-        if (getCol().undoAvailable()) {\n-            blockControls();\n-            CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_UNDO, mAnswerCardHandler);\n-        }\n-    }\n-\n-\n-    private void finishNoStorageAvailable() {\n-        AbstractFlashcardViewer.this.setResult(DeckPicker.RESULT_MEDIA_EJECTED);\n-        finishWithoutAnimation();\n-    }\n-\n-\n-    protected boolean editCard() {\n-        if (mCurrentCard == null) {\n-            // This should never occurs. It means the review button was pressed while there is no more card in the reviewer.\n-            return true;\n-        }\n-        Intent editCard = new Intent(AbstractFlashcardViewer.this, NoteEditor.class);\n-        editCard.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER);\n-        sEditorCard = mCurrentCard;\n-        startActivityForResultWithAnimation(editCard, EDIT_CURRENT_CARD, ActivityTransitionAnimation.LEFT);\n-        return true;\n-    }\n-\n-\n-    protected void generateQuestionSoundList() {\n-        mSoundPlayer.addSounds(mBaseUrl, mCurrentCard.qSimple(), Sound.SOUNDS_QUESTION);\n-    }\n-\n-\n-    protected void lookUpOrSelectText() {\n-        if (clipboardHasText()) {\n-            Timber.d(\"Clipboard has text = \" + clipboardHasText());\n-            lookUp();\n-        } else {\n-            selectAndCopyText();\n-        }\n-    }\n-\n-\n-    private boolean lookUp() {\n-        mLookUpIcon.setVisibility(View.GONE);\n-        mIsSelecting = false;\n-        if (Lookup.lookUp(clipboardGetText().toString())) {\n-            clipboardSetText(\"\");\n-        }\n-        return true;\n-    }\n-\n-\n-    private void showLookupButtonIfNeeded() {\n-        if (!mDisableClipboard && mClipboard != null) {\n-            if (clipboardGetText().length() != 0 && Lookup.isAvailable() && mLookUpIcon.getVisibility() != View.VISIBLE) {\n-                mLookUpIcon.setVisibility(View.VISIBLE);\n-                enableViewAnimation(mLookUpIcon, ViewAnimation.fade(ViewAnimation.FADE_IN, mFadeDuration, 0));\n-            } else if (mLookUpIcon.getVisibility() == View.VISIBLE) {\n-                mLookUpIcon.setVisibility(View.GONE);\n-                enableViewAnimation(mLookUpIcon, ViewAnimation.fade(ViewAnimation.FADE_OUT, mFadeDuration, 0));\n-            }\n-        }\n-    }\n-\n-\n-    private void hideLookupButton() {\n-        if (!mDisableClipboard && mLookUpIcon.getVisibility() != View.GONE) {\n-            mLookUpIcon.setVisibility(View.GONE);\n-            enableViewAnimation(mLookUpIcon, ViewAnimation.fade(ViewAnimation.FADE_OUT, mFadeDuration, 0));\n-            clipboardSetText(\"\");\n-        }\n-    }\n-\n-\n-    protected void showDeleteNoteDialog() {\n-        Resources res = getResources();\n-        new MaterialDialog.Builder(this)\n-                .title(res.getString(R.string.delete_card_title))\n-                .iconAttr(R.attr.dialogErrorIcon)\n-                .content(String.format(res.getString(R.string.delete_note_message),\n-                        Utils.stripHTML(mCurrentCard.q(true))))\n-                .positiveText(res.getString(R.string.dialog_positive_delete))\n-                .negativeText(res.getString(R.string.dialog_cancel))\n-                .onPositive((dialog, which) -> {\n-                    Timber.i(\"AbstractFlashcardViewer:: OK button pressed to delete note %d\", mCurrentCard.getNid());\n-                    mSoundPlayer.stopSounds();\n-                    dismiss(Collection.DismissType.DELETE_NOTE);\n-                })\n-                .build().show();\n-    }\n-\n-\n-    private int getRecommendedEase(boolean easy) {\n-        try {\n-            switch (mSched.answerButtons(mCurrentCard)) {\n-                case 2:\n-                    return EASE_2;\n-                case 3:\n-                    return easy ? EASE_3 : EASE_2;\n-                case 4:\n-                    return easy ? EASE_4 : EASE_3;\n-                default:\n-                    return 0;\n-            }\n-        } catch (RuntimeException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"AbstractReviewer-getRecommendedEase\");\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, true);\n-            return 0;\n-        }\n-    }\n-\n-\n-    protected void answerCard(int ease) {\n-        if (mInAnswer) {\n-            return;\n-        }\n-        mIsSelecting = false;\n-        hideLookupButton();\n-        int buttonNumber = getCol().getSched().answerButtons(mCurrentCard);\n-        // Detect invalid ease for current card (e.g. by using keyboard shortcut or gesture).\n-        if (buttonNumber < ease) {\n-            return;\n-        }\n-        // Set the dots appearing below the toolbar\n-        switch (ease) {\n-            case EASE_1:\n-                mChosenAnswer.setText(\"\\u2022\");\n-                mChosenAnswer.setTextColor(ContextCompat.getColor(this, R.color.material_red_500));\n-                break;\n-            case EASE_2:\n-                mChosenAnswer.setText(\"\\u2022\\u2022\");\n-                mChosenAnswer.setTextColor(ContextCompat.getColor(this, buttonNumber == Consts.BUTTON_FOUR ?\n-                        R.color.material_blue_grey_600:\n-                        R.color.material_green_500));\n-                break;\n-            case EASE_3:\n-                mChosenAnswer.setText(\"\\u2022\\u2022\\u2022\");\n-                mChosenAnswer.setTextColor(ContextCompat.getColor(this, buttonNumber == Consts.BUTTON_FOUR ?\n-                        R.color.material_green_500 :\n-                        R.color.material_light_blue_500));\n-                break;\n-            case EASE_4:\n-                mChosenAnswer.setText(\"\\u2022\\u2022\\u2022\\u2022\");\n-                mChosenAnswer.setTextColor(ContextCompat.getColor(this, R.color.material_light_blue_500));\n-                break;\n-            default:\n-                Timber.w(\"Unknown easy type %s\", ease);\n-                break;\n-        }\n-\n-        // remove chosen answer hint after a while\n-        mTimerHandler.removeCallbacks(removeChosenAnswerText);\n-        mTimerHandler.postDelayed(removeChosenAnswerText, mShowChosenAnswerLength);\n-        mSoundPlayer.stopSounds();\n-        mCurrentEase = ease;\n-\n-        CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler,\n-                new CollectionTask.TaskData(mCurrentCard, mCurrentEase));\n-    }\n-\n-\n-    // Set the content view to the one provided and initialize accessors.\n-    @SuppressWarnings(\"deprecation\") // Tracked separately as #5023 on github for clipboard\n-    protected void initLayout() {\n-        FrameLayout mCardContainer = (FrameLayout) findViewById(R.id.flashcard_frame);\n-\n-        mTopBarLayout = (RelativeLayout) findViewById(R.id.top_bar);\n-\n-        ImageView mark = mTopBarLayout.findViewById(R.id.mark_icon);\n-        ImageView flag = mTopBarLayout.findViewById(R.id.flag_icon);\n-        mCardMarker = new CardMarker(mark, flag);\n-\n-        mCardFrame = (FrameLayout) findViewById(R.id.flashcard);\n-        mCardFrameParent = (ViewGroup) mCardFrame.getParent();\n-        mTouchLayer = (FrameLayout) findViewById(R.id.touch_layer);\n-        mTouchLayer.setOnTouchListener(mGestureListener);\n-        if (!mDisableClipboard) {\n-            mClipboard = (android.text.ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);\n-        }\n-        mCardFrame.removeAllViews();\n-\n-        // Initialize swipe\n-        gestureDetector = new GestureDetectorCompat(this, new MyGestureDetector());\n-\n-        mEase1 = (TextView) findViewById(R.id.ease1);\n-        mEase1.setTypeface(TypefaceHelper.get(this, \"Roboto-Medium\"));\n-        mEase1Layout = (LinearLayout) findViewById(R.id.flashcard_layout_ease1);\n-        mEase1Layout.setOnClickListener(mSelectEaseHandler);\n-\n-        mEase2 = (TextView) findViewById(R.id.ease2);\n-        mEase2.setTypeface(TypefaceHelper.get(this, \"Roboto-Medium\"));\n-        mEase2Layout = (LinearLayout) findViewById(R.id.flashcard_layout_ease2);\n-        mEase2Layout.setOnClickListener(mSelectEaseHandler);\n-\n-        mEase3 = (TextView) findViewById(R.id.ease3);\n-        mEase3.setTypeface(TypefaceHelper.get(this, \"Roboto-Medium\"));\n-        mEase3Layout = (LinearLayout) findViewById(R.id.flashcard_layout_ease3);\n-        mEase3Layout.setOnClickListener(mSelectEaseHandler);\n-\n-        mEase4 = (TextView) findViewById(R.id.ease4);\n-        mEase4.setTypeface(TypefaceHelper.get(this, \"Roboto-Medium\"));\n-        mEase4Layout = (LinearLayout) findViewById(R.id.flashcard_layout_ease4);\n-        mEase4Layout.setOnClickListener(mSelectEaseHandler);\n-\n-        mNext1 = (TextView) findViewById(R.id.nextTime1);\n-        mNext2 = (TextView) findViewById(R.id.nextTime2);\n-        mNext3 = (TextView) findViewById(R.id.nextTime3);\n-        mNext4 = (TextView) findViewById(R.id.nextTime4);\n-        mNext1.setTypeface(TypefaceHelper.get(this, \"Roboto-Regular\"));\n-        mNext2.setTypeface(TypefaceHelper.get(this, \"Roboto-Regular\"));\n-        mNext3.setTypeface(TypefaceHelper.get(this, \"Roboto-Regular\"));\n-        mNext4.setTypeface(TypefaceHelper.get(this, \"Roboto-Regular\"));\n-\n-        if (!mShowNextReviewTime) {\n-            mNext1.setVisibility(View.GONE);\n-            mNext2.setVisibility(View.GONE);\n-            mNext3.setVisibility(View.GONE);\n-            mNext4.setVisibility(View.GONE);\n-        }\n-\n-        Button mFlipCard = (Button) findViewById(R.id.flip_card);\n-        mFlipCard.setTypeface(TypefaceHelper.get(this, \"Roboto-Medium\"));\n-        mFlipCardLayout = (LinearLayout) findViewById(R.id.flashcard_layout_flip);\n-        mFlipCardLayout.setOnClickListener(mFlipCardListener);\n-\n-        if (!mButtonHeightSet && mRelativeButtonSize != 100) {\n-            ViewGroup.LayoutParams params = mFlipCardLayout.getLayoutParams();\n-            params.height = params.height * mRelativeButtonSize / 100;\n-            params = mEase1Layout.getLayoutParams();\n-            params.height = params.height * mRelativeButtonSize / 100;\n-            params = mEase2Layout.getLayoutParams();\n-            params.height = params.height * mRelativeButtonSize / 100;\n-            params = mEase3Layout.getLayoutParams();\n-            params.height = params.height * mRelativeButtonSize / 100;\n-            params = mEase4Layout.getLayoutParams();\n-            params.height = params.height * mRelativeButtonSize / 100;\n-            mButtonHeightSet = true;\n-        }\n-\n-        mTextBarNew = (TextView) findViewById(R.id.new_number);\n-        mTextBarLearn = (TextView) findViewById(R.id.learn_number);\n-        mTextBarReview = (TextView) findViewById(R.id.review_number);\n-\n-        if (!mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.GONE);\n-            mTextBarLearn.setVisibility(View.GONE);\n-            mTextBarReview.setVisibility(View.GONE);\n-        }\n-\n-        mCardTimer = (Chronometer) findViewById(R.id.card_time);\n-\n-        mChosenAnswer = (TextView) findViewById(R.id.choosen_answer);\n-\n-        mAnswerField = (EditText) findViewById(R.id.answer_field);\n-\n-        mLookUpIcon = findViewById(R.id.lookup_button);\n-        mLookUpIcon.setVisibility(View.GONE);\n-        mLookUpIcon.setOnClickListener(new OnClickListener() {\n-\n-            @Override\n-            public void onClick(View arg0) {\n-                Timber.i(\"AbstractFlashcardViewer:: Lookup button pressed\");\n-                if (clipboardHasText()) {\n-                    lookUp();\n-                }\n-            }\n-\n-        });\n-        initControls();\n-\n-        // Position answer buttons\n-        String answerButtonsPosition = AnkiDroidApp.getSharedPrefs(this).getString(\n-                getString(R.string.answer_buttons_position_preference),\n-                \"bottom\"\n-        );\n-        LinearLayout answerArea = (LinearLayout) findViewById(R.id.bottom_area_layout);\n-        RelativeLayout.LayoutParams answerAreaParams = (RelativeLayout.LayoutParams) answerArea.getLayoutParams();\n-        RelativeLayout.LayoutParams cardContainerParams = (RelativeLayout.LayoutParams) mCardContainer.getLayoutParams();\n-\n-        switch (answerButtonsPosition) {\n-            case \"top\":\n-                cardContainerParams.addRule(RelativeLayout.BELOW, R.id.bottom_area_layout);\n-                answerAreaParams.addRule(RelativeLayout.BELOW, R.id.top_bar);\n-                answerArea.removeView(mAnswerField);\n-                answerArea.addView(mAnswerField, 1);\n-                break;\n-            case \"bottom\":\n-                cardContainerParams.addRule(RelativeLayout.ABOVE, R.id.bottom_area_layout);\n-                cardContainerParams.addRule(RelativeLayout.BELOW, R.id.top_bar);\n-                answerAreaParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);\n-                break;\n-            default:\n-                Timber.w(\"Unknown answerButtonsPosition: %s\", answerButtonsPosition);\n-                break;\n-        }\n-        answerArea.setLayoutParams(answerAreaParams);\n-        mCardContainer.setLayoutParams(cardContainerParams);\n-    }\n-\n-\n-    @SuppressLint(\"SetJavaScriptEnabled\") // they request we review carefully because of XSS security, we have\n-    private WebView createWebView() {\n-        WebView webView = new MyWebView(this);\n-        webView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_OVERLAY);\n-        webView.getSettings().setDisplayZoomControls(false);\n-        webView.getSettings().setBuiltInZoomControls(true);\n-        webView.getSettings().setSupportZoom(true);\n-        // Start at the most zoomed-out level\n-        webView.getSettings().setLoadWithOverviewMode(true);\n-        webView.getSettings().setJavaScriptEnabled(true);\n-        webView.setWebChromeClient(new AnkiDroidWebChromeClient());\n-        // Problems with focus and input tags is the reason we keep the old type answer mechanism for old Androids.\n-        webView.setFocusableInTouchMode(mUseInputTag);\n-        webView.setScrollbarFadingEnabled(true);\n-        Timber.d(\"Focusable = %s, Focusable in touch mode = %s\", webView.isFocusable(), webView.isFocusableInTouchMode());\n-\n-        webView.setWebViewClient(new CardViewerWebClient());\n-        // Set transparent color to prevent flashing white when night mode enabled\n-        webView.setBackgroundColor(Color.argb(1, 0, 0, 0));\n-        return webView;\n-    }\n-\n-    /** If a card is displaying the question, flip it, otherwise answer it */\n-    private void flipOrAnswerCard(int cardOrdinal) {\n-        if (!sDisplayAnswer) {\n-           displayCardAnswer();\n-           return;\n-        }\n-        answerCard(cardOrdinal);\n-    }\n-\n-    private boolean webViewRendererLastCrashedOnCard(long cardId) {\n-        return lastCrashingCardId != null && lastCrashingCardId == cardId;\n-    }\n-\n-\n-    private boolean canRecoverFromWebViewRendererCrash() {\n-        // DEFECT\n-        // If we don't have a card to render, we're in a bad state. The class doesn't currently track state\n-        // well enough to be able to know exactly where we are in the initialisation pipeline.\n-        // so it's best to mark the crash as non-recoverable.\n-        // We should fix this, but it's very unlikely that we'll ever get here. Logs will tell\n-\n-        // Revisit webViewCrashedOnCard() if changing this. Logic currently assumes we have a card.\n-        return mCurrentCard != null;\n-    }\n-\n-    //#5780 - Users could OOM the WebView Renderer. This triggers the same symptoms\n-    @VisibleForTesting()\n-    @SuppressWarnings(\"unused\")\n-    public void crashWebViewRenderer() {\n-        loadUrlInViewer(\"chrome://crash\");\n-    }\n-\n-\n-    /** Used to set the \"javascript:\" URIs for IPC */\n-    private void loadUrlInViewer(final String url) {\n-        processCardAction(card -> card.loadUrl(url));\n-    }\n-\n-    private <T extends View> T inflateNewView(@IdRes int id) {\n-        int layoutId = getContentViewAttr(mPrefFullscreenReview);\n-        ViewGroup content = (ViewGroup) LayoutInflater.from(AbstractFlashcardViewer.this).inflate(layoutId, null, false);\n-        T ret = content.findViewById(id);\n-        ((ViewGroup) ret.getParent()).removeView(ret); //detach the view from its parent\n-        content.removeAllViews();\n-        return ret;\n-    }\n-\n-    private void destroyWebView(WebView webView) {\n-        try {\n-            if (webView != null) {\n-                webView.stopLoading();\n-                webView.setWebChromeClient(null);\n-                webView.setWebViewClient(null);\n-                webView.destroy();\n-            }\n-        } catch (NullPointerException npe) {\n-            Timber.e(npe, \"WebView became null on destruction\");\n-        }\n-    }\n-\n-    protected boolean shouldShowNextReviewTime() {\n-        return mShowNextReviewTime;\n-    }\n-\n-    protected void displayAnswerBottomBar() {\n-        // hide flipcard button\n-        mFlipCardLayout.setVisibility(View.GONE);\n-    }\n-\n-\n-    protected void hideEaseButtons() {\n-        mEase1Layout.setVisibility(View.GONE);\n-        mEase2Layout.setVisibility(View.GONE);\n-        mEase3Layout.setVisibility(View.GONE);\n-        mEase4Layout.setVisibility(View.GONE);\n-        mFlipCardLayout.setVisibility(View.VISIBLE);\n-        focusAnswerCompletionField();\n-    }\n-\n-    /**\n-     * Focuses the appropriate field for an answer\n-     * And allows keyboard shortcuts to go to the default handlers.\n-     * */\n-    private void focusAnswerCompletionField() {\n-        // This does not handle mUseInputTag (the WebView contains an input field with a typable answer).\n-        // In this case, the user can use touch to focus the field if necessary.\n-        if (typeAnswer()) {\n-            mAnswerField.requestFocus();\n-        } else {\n-            mFlipCardLayout.requestFocus();\n-        }\n-    }\n-\n-\n-    private void switchTopBarVisibility(int visible) {\n-        if (mShowTimer) {\n-            mCardTimer.setVisibility(visible);\n-        }\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(visible);\n-            mTextBarLearn.setVisibility(visible);\n-            mTextBarReview.setVisibility(visible);\n-        }\n-        mChosenAnswer.setVisibility(visible);\n-    }\n-\n-\n-    protected void initControls() {\n-        mCardFrame.setVisibility(View.VISIBLE);\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.VISIBLE);\n-            mTextBarLearn.setVisibility(View.VISIBLE);\n-            mTextBarReview.setVisibility(View.VISIBLE);\n-        }\n-        mChosenAnswer.setVisibility(View.VISIBLE);\n-        mFlipCardLayout.setVisibility(View.VISIBLE);\n-\n-        mAnswerField.setVisibility(typeAnswer() ? View.VISIBLE : View.GONE);\n-        mAnswerField.setOnEditorActionListener(new EditText.OnEditorActionListener() {\n-            @Override\n-            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {\n-                if (actionId == EditorInfo.IME_ACTION_DONE) {\n-                    displayCardAnswer();\n-                    return true;\n-                }\n-                return false;\n-            }\n-        });\n-        mAnswerField.setOnKeyListener(new View.OnKeyListener() {\n-            @Override\n-            public boolean onKey(View v, int keyCode, KeyEvent event) {\n-                if (event.getAction() == KeyEvent.ACTION_UP &&\n-                        (keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_NUMPAD_ENTER)) {\n-                    displayCardAnswer();\n-                    return true;\n-                }\n-                return false;\n-            }\n-        });\n-    }\n-\n-\n-    protected SharedPreferences restorePreferences() {\n-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());\n-\n-        mPrefHideDueCount = preferences.getBoolean(\"hideDueCount\", false);\n-        mPrefShowETA = preferences.getBoolean(\"showETA\", true);\n-        mUseInputTag = preferences.getBoolean(\"useInputTag\", false);\n-        // On newer Androids, ignore this setting, which should be hidden in the prefs anyway.\n-        mDisableClipboard = \"0\".equals(preferences.getString(\"dictionary\", \"0\"));\n-        // mDeckFilename = preferences.getString(\"deckFilename\", \"\");\n-        mPrefFullscreenReview = Integer.parseInt(preferences.getString(\"fullscreenMode\", \"0\"));\n-        mRelativeButtonSize = preferences.getInt(\"answerButtonSize\", 100);\n-        mSpeakText = preferences.getBoolean(\"tts\", false);\n-        mPrefUseTimer = preferences.getBoolean(\"timeoutAnswer\", false);\n-        mPrefWaitAnswerSecond = preferences.getInt(\"timeoutAnswerSeconds\", 20);\n-        mPrefWaitQuestionSecond = preferences.getInt(\"timeoutQuestionSeconds\", 60);\n-        mScrollingButtons = preferences.getBoolean(\"scrolling_buttons\", false);\n-        mDoubleScrolling = preferences.getBoolean(\"double_scrolling\", false);\n-\n-        mGesturesEnabled = AnkiDroidApp.initiateGestures(preferences);\n-        if (mGesturesEnabled) {\n-            mGestureSwipeUp = Integer.parseInt(preferences.getString(\"gestureSwipeUp\", \"9\"));\n-            mGestureSwipeDown = Integer.parseInt(preferences.getString(\"gestureSwipeDown\", \"0\"));\n-            mGestureSwipeLeft = Integer.parseInt(preferences.getString(\"gestureSwipeLeft\", \"8\"));\n-            mGestureSwipeRight = Integer.parseInt(preferences.getString(\"gestureSwipeRight\", \"17\"));\n-            mGestureDoubleTap = Integer.parseInt(preferences.getString(\"gestureDoubleTap\", \"7\"));\n-            mGestureTapLeft = Integer.parseInt(preferences.getString(\"gestureTapLeft\", \"3\"));\n-            mGestureTapRight = Integer.parseInt(preferences.getString(\"gestureTapRight\", \"6\"));\n-            mGestureTapTop = Integer.parseInt(preferences.getString(\"gestureTapTop\", \"12\"));\n-            mGestureTapBottom = Integer.parseInt(preferences.getString(\"gestureTapBottom\", \"2\"));\n-            mGestureLongclick = Integer.parseInt(preferences.getString(\"gestureLongclick\", \"11\"));\n-        }\n-\n-        if (preferences.getBoolean(\"keepScreenOn\", false)) {\n-            this.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n-        }\n-\n-        return preferences;\n-    }\n-\n-\n-    private void restoreCollectionPreferences() {\n-\n-        // These are preferences we pull out of the collection instead of SharedPreferences\n-        try {\n-            mShowNextReviewTime = getCol().getConf().getBoolean(\"estTimes\");\n-            mShowRemainingCardCount = getCol().getConf().getBoolean(\"dueCounts\");\n-\n-            // Dynamic don't have review options; attempt to get deck-specific auto-advance options\n-            // but be prepared to go with all default if it's a dynamic deck\n-            JSONObject revOptions = new JSONObject();\n-            long selectedDid = getCol().getDecks().selected();\n-            if (!getCol().getDecks().isDyn(selectedDid)) {\n-                revOptions = getCol().getDecks().confForDid(selectedDid).getJSONObject(\"rev\");\n-            }\n-\n-            mOptUseGeneralTimerSettings = revOptions.optBoolean(\"useGeneralTimeoutSettings\", true);\n-            mOptUseTimer = revOptions.optBoolean(\"timeoutAnswer\", false);\n-            mOptWaitAnswerSecond = revOptions.optInt(\"timeoutAnswerSeconds\", 20);\n-            mOptWaitQuestionSecond = revOptions.optInt(\"timeoutQuestionSeconds\", 60);\n-        } catch (JSONException e) {\n-            Timber.e(e, \"Unable to restoreCollectionPreferences\");\n-            throw new RuntimeException(e);\n-        } catch (NullPointerException npe) {\n-            // NPE on collection only happens if the Collection is broken, follow AnkiActivity example\n-            Intent deckPicker = new Intent(this, DeckPicker.class);\n-            deckPicker.putExtra(\"collectionLoadError\", true); // don't currently do anything with this\n-            deckPicker.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n-            startActivityWithAnimation(deckPicker, ActivityTransitionAnimation.LEFT);\n-        }\n-    }\n-\n-\n-    private void setInterface() {\n-        if (mCurrentCard == null) {\n-            return;\n-        }\n-        recreateWebView();\n-    }\n-\n-    private void recreateWebView() {\n-        if (mCard == null) {\n-            mCard = createWebView();\n-            WebViewDebugging.initializeDebugging(AnkiDroidApp.getSharedPrefs(this));\n-            mCardFrame.addView(mCard);\n-        }\n-        if (mCard.getVisibility() != View.VISIBLE) {\n-            mCard.setVisibility(View.VISIBLE);\n-        }\n-    }\n-\n-\n-    private void updateForNewCard() {\n-        updateScreenCounts();\n-\n-        // Clean answer field\n-        if (typeAnswer()) {\n-            mAnswerField.setText(\"\");\n-        }\n-\n-        if (mPrefWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.clear();\n-        }\n-    }\n-\n-\n-    protected void updateScreenCounts() {\n-        if (mCurrentCard == null) return;\n-        ActionBar actionBar = getSupportActionBar();\n-        int[] counts = mSched.counts(mCurrentCard);\n-\n-        if (actionBar != null) {\n-            String title = Decks.basename(getCol().getDecks().get(mCurrentCard.getDid()).getString(\"name\"));\n-            actionBar.setTitle(title);\n-            if (mPrefShowETA) {\n-                int eta = mSched.eta(counts, false);\n-                actionBar.setSubtitle(Utils.remainingTime(AnkiDroidApp.getInstance(), eta * 60));\n-            }\n-        }\n-\n-        SpannableString newCount = new SpannableString(String.valueOf(counts[0]));\n-        SpannableString lrnCount = new SpannableString(String.valueOf(counts[1]));\n-        SpannableString revCount = new SpannableString(String.valueOf(counts[2]));\n-        if (mPrefHideDueCount) {\n-            revCount = new SpannableString(\"???\");\n-        }\n-\n-        switch (mSched.countIdx(mCurrentCard)) {\n-            case Consts.CARD_TYPE_NEW:\n-                newCount.setSpan(new UnderlineSpan(), 0, newCount.length(), 0);\n-                break;\n-            case Consts.CARD_TYPE_LRN:\n-                lrnCount.setSpan(new UnderlineSpan(), 0, lrnCount.length(), 0);\n-                break;\n-            case Consts.CARD_TYPE_REV:\n-                revCount.setSpan(new UnderlineSpan(), 0, revCount.length(), 0);\n-                break;\n-            default:\n-                Timber.w(\"Unknown card type %s\", mSched.countIdx(mCurrentCard));\n-                break;\n-        }\n-\n-        mTextBarNew.setText(newCount);\n-        mTextBarLearn.setText(lrnCount);\n-        mTextBarReview.setText(revCount);\n-    }\n-\n-    /*\n-     * Handler for the delay in auto showing question and/or answer One toggle for both question and answer, could set\n-     * longer delay for auto next question\n-     */\n-    protected Handler mTimeoutHandler = new Handler();\n-\n-    protected Runnable mShowQuestionTask = new Runnable() {\n-        @Override\n-        public void run() {\n-            // Assume hitting the \"Again\" button when auto next question\n-            if (mEase1Layout.isEnabled() && mEase1Layout.getVisibility() == View.VISIBLE) {\n-                mEase1Layout.performClick();\n-            }\n-        }\n-    };\n-\n-    protected Runnable mShowAnswerTask = new Runnable() {\n-        @Override\n-        public void run() {\n-            if (mFlipCardLayout.isEnabled() && mFlipCardLayout.getVisibility() == View.VISIBLE) {\n-                mFlipCardLayout.performClick();\n-            }\n-        }\n-    };\n-\n-\n-    protected void initTimer() {\n-        final TypedValue typedValue = new TypedValue();\n-        mShowTimer = mCurrentCard.showTimer();\n-        if (mShowTimer && mCardTimer.getVisibility() == View.INVISIBLE) {\n-            mCardTimer.setVisibility(View.VISIBLE);\n-        } else if (!mShowTimer && mCardTimer.getVisibility() != View.INVISIBLE) {\n-            mCardTimer.setVisibility(View.INVISIBLE);\n-        }\n-        // Set normal timer color\n-        getTheme().resolveAttribute(android.R.attr.textColor, typedValue, true);\n-        mCardTimer.setTextColor(typedValue.data);\n-\n-        mCardTimer.setBase(SystemClock.elapsedRealtime());\n-        mCardTimer.start();\n-\n-        // Stop and highlight the timer if it reaches the time limit.\n-        getTheme().resolveAttribute(R.attr.maxTimerColor, typedValue, true);\n-        final int limit = mCurrentCard.timeLimit();\n-        mCardTimer.setOnChronometerTickListener(new Chronometer.OnChronometerTickListener() {\n-            @Override\n-            public void onChronometerTick(Chronometer chronometer) {\n-                long elapsed = SystemClock.elapsedRealtime() - chronometer.getBase();\n-                if (elapsed >= limit) {\n-                    chronometer.setTextColor(typedValue.data);\n-                    chronometer.stop();\n-                }\n-            }\n-        });\n-    }\n-\n-\n-    protected void displayCardQuestion() {\n-        Timber.d(\"displayCardQuestion()\");\n-        sDisplayAnswer = false;\n-\n-        setInterface();\n-\n-        String question;\n-        String displayString = \"\";\n-        if (mCurrentCard.isEmpty()) {\n-            displayString = getResources().getString(R.string.empty_card_warning);\n-        } else {\n-            question = mCurrentCard.q();\n-            question = getCol().getMedia().escapeImages(question);\n-            question = typeAnsQuestionFilter(question);\n-\n-            Timber.v(\"question: '%s'\", question);\n-            // Show text entry based on if the user wants to write the answer\n-            if (typeAnswer()) {\n-                mAnswerField.setVisibility(View.VISIBLE);\n-            } else {\n-                mAnswerField.setVisibility(View.GONE);\n-            }\n-\n-            displayString = CardAppearance.enrichWithQADiv(question, false);\n-\n-            //if (mSpeakText) {\n-            // ReadText.setLanguageInformation(Model.getModel(DeckManager.getMainDeck(),\n-            // mCurrentCard.getCardModelId(), false).getId(), mCurrentCard.getCardModelId());\n-            //}\n-        }\n-\n-        updateCard(displayString);\n-        hideEaseButtons();\n-\n-        // Check if it should use the general 'Timeout settings' or the ones specific to this deck\n-        if (mOptUseGeneralTimerSettings) {\n-            mUseTimer = mPrefUseTimer;\n-            mWaitAnswerSecond = mPrefWaitAnswerSecond;\n-            mWaitQuestionSecond = mPrefWaitQuestionSecond;\n-        } else {\n-            mUseTimer = mOptUseTimer;\n-            mWaitAnswerSecond = mOptWaitAnswerSecond;\n-            mWaitQuestionSecond = mOptWaitQuestionSecond;\n-        }\n-\n-        // If the user wants to show the answer automatically\n-        if (mUseTimer) {\n-            long delay = mWaitAnswerSecond * 1000 + mUseTimerDynamicMS;\n-            if (delay > 0) {\n-                mTimeoutHandler.removeCallbacks(mShowAnswerTask);\n-                mTimeoutHandler.postDelayed(mShowAnswerTask, delay);\n-            }\n-        }\n-\n-        Timber.i(\"AbstractFlashcardViewer:: Question successfully shown for card id %d\", mCurrentCard.getId());\n-    }\n-\n-\n-    /**\n-     * Clean up the correct answer text, so it can be used for the comparison with the typed text\n-     *\n-     * @param answer The content of the field the text typed by the user is compared to.\n-     * @return The correct answer text, with actual HTML and media references removed, and HTML entities unescaped.\n-     */\n-    protected String cleanCorrectAnswer(String answer) {\n-        return TypedAnswer.cleanCorrectAnswer(answer);", "originalCommit": "c1a7d9809ab95f6a2ce39a1776a82dc862ebbda1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ5NjUwMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r426496503", "bodyText": "Is it because the version I fork is not the latest?\nHow about creating a new pull request for that?", "author": "jianersswlq", "createdAt": "2020-05-18T09:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NjEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU0Nzg3Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r426547872", "bodyText": "It's fine to request a pull request from an earlier branch. I don't quite see how you don't have merge conflicts since you're based off master, but moving forward towards a branch in the past. It's a strange situation to be in.\nI'd probably have a google to understand how I got into the situation and see what's advised.\nAlternately: shelve to keep the changes safe, then: revert and reapply, but it's up to you.", "author": "david-allison-1", "createdAt": "2020-05-18T11:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NjEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYxMTUwMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r426611503", "bodyText": "I'd go a little more firm: Always make a PR of current master, like master as of that moment, start fully up to date, then start making changes. Do not change whitespace unnecessarily for sure. I'm excited for this change though! We have had a few people asking for it, and my reply has been \"please make a PR\", now we have a PR :-). I'm sure we can get past the \"PR mechanics\" phase and get this in", "author": "mikehardy", "createdAt": "2020-05-18T13:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NjEwMw=="}], "type": "inlineReview"}, {"oid": "7f4e08e806e91d4568b3c3b43ac4895a480846c7", "url": "https://github.com/ankidroid/Anki-Android/commit/7f4e08e806e91d4568b3c3b43ac4895a480846c7", "message": "try reload diff", "committedDate": "2020-05-18T13:31:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY0ODI1NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r426648255", "bodyText": "This diff looks a lot cleaner but I don't understand all the motion around imports - your proposed change does not affect these imports at all, or the expansion of the ViewerCommand ones below. Can you please revert these changes and just restrict the PR to only the exact things necessary to implement the feature?", "author": "mikehardy", "createdAt": "2020-05-18T14:01:05Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -128,11 +123,47 @@\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n+import androidx.annotation.CheckResult;\n+import androidx.annotation.IdRes;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.appcompat.app.ActionBar;\n+import androidx.core.content.ContextCompat;\n+import androidx.core.view.GestureDetectorCompat;", "originalCommit": "7f4e08e806e91d4568b3c3b43ac4895a480846c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1MTczNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r426651735", "bodyText": "This change is unrelated to your PR - please revert", "author": "mikehardy", "createdAt": "2020-05-18T14:06:07Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -2726,7 +2837,8 @@ private void drawFlag() {\n     }\n \n \n-    protected @FlagDef int getFlagToDisplay() {", "originalCommit": "7f4e08e806e91d4568b3c3b43ac4895a480846c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1NTkwOA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r426655908", "bodyText": "I'm concerned in general by the motion of code into AbstractFlashcardViewer, that object is huge, and TTS was already separated from it nicely\nI'm looking for any solution that involves keeping the initializeTts out of AbstractFlashcardViewer\nIt seems like the real change is the addition of this\n                            if(ReadText.getmQuestionAnswer()==Sound.SOUNDS_QUESTION){\n                                showAnswerTask();\n                            }else if(ReadText.getmQuestionAnswer()==Sound.SOUNDS_ANSWER){\n                                showQuestionTask();\n                            }\nPerhaps as a different structure we could have a ReadTextListener interface inside ReadText that just had one method onDone\nHave AbstractFlashcardViewer implement it, with the code above as the implementatio, add the listener argument as a parameter to initializeTts and as you setOnUtteranceProgressListener you bind them together by having the onDone + empty queue logic call ReadTextListener.onDone()\nThen we can keep the TTS stuff in ReadText and not increase AbstractFlashcardViewer size much except the actual postDelayed logic", "author": "mikehardy", "createdAt": "2020-05-18T14:12:03Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -2682,7 +2717,83 @@ public void playVideo(String path) {\n         startActivityWithoutAnimation(videoPlayer);\n     }\n \n+\n+    public void showQuestionTask(){\n+        long delay = mWaitQuestionSecond * 1000;\n+        if (delay > 0) {\n+            mTimeoutHandler.postDelayed(mShowQuestionTask, delay);\n+        }\n+    }\n+    public void showAnswerTask(){\n+        long delay = mWaitAnswerSecond * 1000;\n+        if (delay > 0) {\n+            mTimeoutHandler.postDelayed(mShowAnswerTask, delay);\n+        }\n+    }\n     /** Callback for when TTS has been initialized. */\n+    public void initializeTts(Context context) {", "originalCommit": "7f4e08e806e91d4568b3c3b43ac4895a480846c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "97d2346edae87d9ac1bb1575ce79474b6ca72bbc", "url": "https://github.com/ankidroid/Anki-Android/commit/97d2346edae87d9ac1bb1575ce79474b6ca72bbc", "message": "revert the order of import", "committedDate": "2020-05-18T14:19:05Z", "type": "commit"}, {"oid": "5e689cc60f15a86c8af2bf45fcb549c9d0ff6f81", "url": "https://github.com/ankidroid/Anki-Android/commit/5e689cc60f15a86c8af2bf45fcb549c9d0ff6f81", "message": "modify ReadTextListener", "committedDate": "2020-05-18T15:30:34Z", "type": "commit"}, {"oid": "3c800f977d27afa1a8223eec59f782e4b641312f", "url": "https://github.com/ankidroid/Anki-Android/commit/3c800f977d27afa1a8223eec59f782e4b641312f", "message": "modify ReadTextListener", "committedDate": "2020-05-18T15:37:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0MjM2Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r426742362", "bodyText": "Just adding whitespace according to our coding standards, logic seems fine does it work for you like this in your testing?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class ReadTextListener implements ReadText.ReadTextListener{\n          \n          \n            \n                    public void onDone(){\n          \n          \n            \n                        if(ReadText.getmQuestionAnswer()==Sound.SOUNDS_QUESTION){\n          \n          \n            \n                            long delay = mWaitAnswerSecond * 1000;\n          \n          \n            \n                            if (delay > 0) {\n          \n          \n            \n                                mTimeoutHandler.postDelayed(mShowAnswerTask, delay);\n          \n          \n            \n                            }\n          \n          \n            \n                        }else if(ReadText.getmQuestionAnswer()==Sound.SOUNDS_ANSWER){\n          \n          \n            \n                            long delay = mWaitQuestionSecond * 1000;\n          \n          \n            \n                            if (delay > 0) {\n          \n          \n            \n                                mTimeoutHandler.postDelayed(mShowQuestionTask, delay);\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                class ReadTextListener implements ReadText.ReadTextListener {\n          \n          \n            \n                    public void onDone() {\n          \n          \n            \n                        if (ReadText.getmQuestionAnswer() == Sound.SOUNDS_QUESTION) {\n          \n          \n            \n                            long delay = mWaitAnswerSecond * 1000;\n          \n          \n            \n                            if (delay > 0) {\n          \n          \n            \n                                mTimeoutHandler.postDelayed(mShowAnswerTask, delay);\n          \n          \n            \n                            }\n          \n          \n            \n                        } else if (ReadText.getmQuestionAnswer() == Sound.SOUNDS_ANSWER) {\n          \n          \n            \n                            long delay = mWaitQuestionSecond * 1000;\n          \n          \n            \n                            if (delay > 0) {\n          \n          \n            \n                                mTimeoutHandler.postDelayed(mShowQuestionTask, delay);\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "mikehardy", "createdAt": "2020-05-18T16:14:21Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -1795,6 +1795,21 @@ public void run() {\n         }\n     };\n \n+    class ReadTextListener implements ReadText.ReadTextListener{\n+        public void onDone(){\n+            if(ReadText.getmQuestionAnswer()==Sound.SOUNDS_QUESTION){\n+                long delay = mWaitAnswerSecond * 1000;\n+                if (delay > 0) {\n+                    mTimeoutHandler.postDelayed(mShowAnswerTask, delay);\n+                }\n+            }else if(ReadText.getmQuestionAnswer()==Sound.SOUNDS_ANSWER){\n+                long delay = mWaitQuestionSecond * 1000;\n+                if (delay > 0) {\n+                    mTimeoutHandler.postDelayed(mShowQuestionTask, delay);\n+                }\n+            }\n+        }\n+    }", "originalCommit": "3c800f977d27afa1a8223eec59f782e4b641312f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0MjcwMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r426742703", "bodyText": "Same as above - whitespace changes only to match project standards\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if(!mSpeakText){\n          \n          \n            \n                            if (!mSpeakText) {", "author": "mikehardy", "createdAt": "2020-05-18T16:14:53Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -1877,7 +1892,9 @@ protected void displayCardQuestion() {\n             long delay = mWaitAnswerSecond * 1000 + mUseTimerDynamicMS;\n             if (delay > 0) {\n                 mTimeoutHandler.removeCallbacks(mShowAnswerTask);\n-                mTimeoutHandler.postDelayed(mShowAnswerTask, delay);\n+                if(!mSpeakText){", "originalCommit": "3c800f977d27afa1a8223eec59f782e4b641312f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0MzA0Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r426743046", "bodyText": "Same as above - whitespace changes only to match project standards\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if(!mSpeakText){\n          \n          \n            \n                            if (!mSpeakText) {", "author": "mikehardy", "createdAt": "2020-05-18T16:15:23Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -1954,7 +1971,9 @@ protected void displayCardAnswer() {\n             long delay = mWaitQuestionSecond * 1000 + mUseTimerDynamicMS;\n             if (delay > 0) {\n                 mTimeoutHandler.removeCallbacks(mShowQuestionTask);\n-                mTimeoutHandler.postDelayed(mShowQuestionTask, delay);\n+                if(!mSpeakText){", "originalCommit": "3c800f977d27afa1a8223eec59f782e4b641312f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "70e5a15eb8785dfb91e398cc4bb9c8f0a358252b", "url": "https://github.com/ankidroid/Anki-Android/commit/70e5a15eb8785dfb91e398cc4bb9c8f0a358252b", "message": "Update AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java\n\nCo-authored-by: Mike Hardy <github@mikehardy.net>", "committedDate": "2020-05-19T01:39:32Z", "type": "commit"}, {"oid": "be026c2ac2840420df1326fd01d9f9bed229de38", "url": "https://github.com/ankidroid/Anki-Android/commit/be026c2ac2840420df1326fd01d9f9bed229de38", "message": "Update AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java\n\nCo-authored-by: Mike Hardy <github@mikehardy.net>", "committedDate": "2020-05-19T01:39:57Z", "type": "commit"}, {"oid": "6be54d320528897168d9ece34929e1081fe457ef", "url": "https://github.com/ankidroid/Anki-Android/commit/6be54d320528897168d9ece34929e1081fe457ef", "message": "Update AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java\n\nCo-authored-by: Mike Hardy <github@mikehardy.net>", "committedDate": "2020-05-19T01:40:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwODA4NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r427608085", "bodyText": "Could you mark listener as non-null here to help future developers avoid programming errors:\n@NonNull ReadTextListener listener)", "author": "david-allison-1", "createdAt": "2020-05-19T21:22:53Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/ReadText.java", "diffHunk": "@@ -272,7 +275,7 @@ private static boolean isLanguageAvailable(String localeCode) {\n                 TextToSpeech.LANG_AVAILABLE;\n     }\n \n-    public static void initializeTts(Context context) {\n+    public static void initializeTts(Context context, ReadTextListener listener) {", "originalCommit": "6be54d320528897168d9ece34929e1081fe457ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwOTkwNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r427609905", "bodyText": "Can we perform an early return here if mUseTimer is false?", "author": "david-allison-1", "createdAt": "2020-05-19T21:26:30Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -1795,6 +1795,21 @@ public void run() {\n         }\n     };\n \n+    class ReadTextListener implements ReadText.ReadTextListener {\n+        public void onDone() {\n+            if (ReadText.getmQuestionAnswer() == Sound.SOUNDS_QUESTION) {", "originalCommit": "6be54d320528897168d9ece34929e1081fe457ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNTcwOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r428415709", "bodyText": "Dose it mean we should check if(mUseTimer) here?", "author": "jianersswlq", "createdAt": "2020-05-21T02:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwOTkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzMjA2Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r428532063", "bodyText": "Yeah! something along the lines of\nif (!mUseTimer) {\n    return;\n}", "author": "david-allison-1", "createdAt": "2020-05-21T08:59:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwOTkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU5ODYwNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6212#discussion_r428598605", "bodyText": "I have already done. See the latest commit.", "author": "jianersswlq", "createdAt": "2020-05-21T11:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwOTkwNQ=="}], "type": "inlineReview"}, {"oid": "df062bbb7275ee9c235b0090079c72d10dbe11bf", "url": "https://github.com/ankidroid/Anki-Android/commit/df062bbb7275ee9c235b0090079c72d10dbe11bf", "message": "update checking if(mUseTime)", "committedDate": "2020-05-21T02:54:32Z", "type": "commit"}, {"oid": "c03b2787377473aa474a54b4553b4f40d8b2c677", "url": "https://github.com/ankidroid/Anki-Android/commit/c03b2787377473aa474a54b4553b4f40d8b2c677", "message": "clean import", "committedDate": "2020-05-21T03:04:02Z", "type": "commit"}]}