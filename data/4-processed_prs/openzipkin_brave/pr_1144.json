{"pr_number": 1144, "pr_title": "Adds example of custom trace ID parsing", "pr_createdAt": "2020-04-08T07:01:46Z", "pr_url": "https://github.com/openzipkin/brave/pull/1144", "timeline": [{"oid": "81d9def8bd7b6d069a4cea32babf95fa00de3d99", "url": "https://github.com/openzipkin/brave/commit/81d9def8bd7b6d069a4cea32babf95fa00de3d99", "message": "Adds example of custom trace ID parsing\n\nThis shows how people constrained to only propagating a trace ID can stash numerical data into\nthe trace ID. For example, a load balancer can set some bit flags like this.\n\nRumor has it that Twitter used to do this for embedding device information to ensure a\nspecific device couldn't absorb the entire random space. It isn't known if the amount of bits\nstolen was a nibble or a byte.\n\nSee https://github.com/spring-cloud/spring-cloud-sleuth/issues/1106", "committedDate": "2020-04-08T07:00:41Z", "type": "commit"}, {"oid": "5b4d401c9e60def0cf65ee4d14148b3a2a4667a8", "url": "https://github.com/openzipkin/brave/commit/5b4d401c9e60def0cf65ee4d14148b3a2a4667a8", "message": "actually create", "committedDate": "2020-04-08T07:03:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwMjY1Ng==", "url": "https://github.com/openzipkin/brave/pull/1144#discussion_r405302656", "bodyText": "Delete I guess", "author": "anuraaga", "createdAt": "2020-04-08T07:07:21Z", "path": "brave/src/test/java/brave/features/propagation/HackedTraceIdTest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.propagation;\n+\n+import brave.propagation.B3Propagation;\n+import brave.propagation.Propagation;\n+import brave.propagation.Propagation.KeyFactory;\n+import brave.propagation.TraceContext;\n+import brave.propagation.TraceContext.Extractor;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import org.junit.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+/**\n+ * This shows how people constrained to only propagating a trace ID can stash numerical data into\n+ * the trace ID. For example, a load balancer can set some bit flags like this.\n+ *\n+ * <p>Rumor has it that Twitter used to do this for embedding device information to ensure a\n+ * specific device couldn't absorb the entire random space. It isn't known if the amount of bits\n+ * stolen was a nibble or a byte.\n+ *\n+ * <p>See https://github.com/spring-cloud/spring-cloud-sleuth/issues/1106\n+ */\n+public class HackedTraceIdTest {\n+  String customTraceIdName = \"trace_id\";\n+  // CustomTraceIdPropagation.Factory substitutes for B3Propagation.FACTORY in real config.\n+  Propagation.Factory propagationFactory =\n+    CustomTraceIdPropagation.create(B3Propagation.FACTORY, customTraceIdName);\n+  Propagation<String> propagation = propagationFactory.create(KeyFactory.STRING);\n+  Extractor<Map<String, String>> extractor = propagation.extractor(Map::get);\n+  Map<String, String> headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n+\n+  // Let's say environment number zero is invalid, and its desired value is 3\n+  // There are at least 3 ways to embed this!\n+  @Test public void testFormatThatEmbedsEnvironmentNumber() {\n+    // Lead with single-digit, then pad-right zeros until the real trace ID.\n+    //\n+    // This is not great because it limits to 9 environment numbers. However, parsing is easy\n+    // as you look only at the first character.\n+    headers.put(customTraceIdName, \"3000000000000000e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"3000000000000000e457b5a2e4d86bd1\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"e457b5a2e4d86bd1\"));\n+    headers.put(customTraceIdName, \"3000000000000000\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"3000000000000000\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"3000000000000000\"));\n+\n+    // Use the upper 64-bits (left 16 hex) as the environment ID\n+    //\n+    // This allows a lot of env numbers, and is easy to parse. This still gives 64-bit trace IDs\n+    headers.put(customTraceIdName, \"0000000000000003e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"0000000000000003e457b5a2e4d86bd1\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"e457b5a2e4d86bd1\"));\n+    headers.put(customTraceIdName, \"3e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"0000000000000003e457b5a2e4d86bd1\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"e457b5a2e4d86bd1\"));\n+\n+    // Steal the upper nibble (first hex character) of the 64-bit trace ID as the environment ID\n+    //\n+    // This allows 15 env numbers, and is easy to parse. It allows 60-bits for the trace ID, which\n+    // is good enough for most sites.\n+    String customTraceIdString = \"3457b5a2e4d86bd1\";\n+    headers.put(customTraceIdName, customTraceIdString);\n+    TraceContext extractedContext = extractor.extract(headers).context();\n+    assertThat(extractedContext)\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(customTraceIdString))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(customTraceIdString))\n+      .satisfies(c -> assertThat((c.traceId() >>> 64 - 4L) & 0xf).isEqualTo(3));\n+  }\n+\n+  @Test public void testB3SingleWins() {\n+    headers.put(\"b3\", \"1111111111111111-2222222222222222\");\n+    headers.put(customTraceIdName, \"1000000000000000e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"1111111111111111\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"2222222222222222\"));\n+  }\n+\n+  @Test public void testB3MultiWins() {\n+    headers.put(\"X-B3-TraceId\", \"1111111111111111\");\n+    headers.put(\"X-B3-SpanId\", \"2222222222222222\");\n+    headers.put(customTraceIdName, \"1000000000000000e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"1111111111111111\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"2222222222222222\"));\n+  }\n+\n+  @Test public void invalidTraceIdsDontCrash() {", "originalCommit": "5b4d401c9e60def0cf65ee4d14148b3a2a4667a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwMzAzMw==", "url": "https://github.com/openzipkin/brave/pull/1144#discussion_r405303033", "bodyText": "thx!", "author": "codefromthecrypt", "createdAt": "2020-04-08T07:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwMjY1Ng=="}], "type": "inlineReview"}, {"oid": "3db1b333ecb4598c402c8f03777d7a4b7a593b5a", "url": "https://github.com/openzipkin/brave/commit/3db1b333ecb4598c402c8f03777d7a4b7a593b5a", "message": "remove", "committedDate": "2020-04-08T07:08:12Z", "type": "commit"}]}