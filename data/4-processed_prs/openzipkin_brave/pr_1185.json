{"pr_number": 1185, "pr_title": "Improves quality of TraceContextOrSamplingFlags", "pr_createdAt": "2020-05-03T06:12:18Z", "pr_url": "https://github.com/openzipkin/brave/pull/1185", "timeline": [{"oid": "ac5de4106d93a2ae58f178378ab8c1b321d77aff", "url": "https://github.com/openzipkin/brave/commit/ac5de4106d93a2ae58f178378ab8c1b321d77aff", "message": "Improves quality of TraceContextOrSamplingFlags\n\nThis deprecates methods only used in tests, or those that can lead to\nnull pointers. It backfills JavaDoc and complete test coverage.\n\nSince `TraceContextOrSamplingFlags` primarily called \"extracted\", this\nimproves the `toString` based on experience of what's important to know.\n\nEx. we want to know what we extracted, if any sampling status exists,\nand if any extra propagated state exists.", "committedDate": "2020-05-03T06:10:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1NDM3Ng==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419054376", "bodyText": "this inlines the method that was only used once", "author": "codefromthecrypt", "createdAt": "2020-05-03T06:12:55Z", "path": "brave/src/main/java/brave/propagation/B3Propagation.java", "diffHunk": "@@ -280,8 +280,16 @@ void injectMulti(TraceContext context, R request) {\n       boolean debug = \"1\".equals(getter.get(request, propagation.debugKey));\n \n       String traceIdString = getter.get(request, propagation.traceIdKey);\n+\n       // It is ok to go without a trace ID, if sampling or debug is set\n-      if (traceIdString == null) return TraceContextOrSamplingFlags.create(sampledV, debug);\n+      if (traceIdString == null) {", "originalCommit": "ac5de4106d93a2ae58f178378ab8c1b321d77aff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1NDQwNg==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419054406", "bodyText": "the former toString was really not nice ;)", "author": "codefromthecrypt", "createdAt": "2020-05-03T06:13:20Z", "path": "brave/src/main/java/brave/propagation/SamplingFlags.java", "diffHunk": "@@ -110,13 +110,25 @@ public final boolean debug() {\n   }\n \n   @Override public String toString() {\n-    return \"SamplingFlags(sampled=\"\n-      + sampled()\n-      + \", sampledLocal=\"\n-      + sampledLocal()\n-      + \", debug=\"\n-      + debug()\n-      + \")\";\n+    return toString(flags);", "originalCommit": "ac5de4106d93a2ae58f178378ab8c1b321d77aff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1NDQ0MA==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419054440", "bodyText": "There is no need for this method", "author": "codefromthecrypt", "createdAt": "2020-05-03T06:13:49Z", "path": "brave/src/main/java/brave/propagation/TraceContext.java", "diffHunk": "@@ -343,13 +345,18 @@ public Builder shared(boolean shared) {\n       return this;\n     }\n \n-    /**\n-     * Shares the input with the builder, replacing any current data in the builder.\n-     *\n-     * @see TraceContext#extra()\n-     */\n-    public final Builder extra(List<Object> extra) {\n-      this.extra = extra;\n+    /** @deprecated Since 5.12, use {@link #addExtra(Object)} */\n+    @Deprecated public final Builder extra(List<Object> extraList) {", "originalCommit": "ac5de4106d93a2ae58f178378ab8c1b321d77aff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1NDY1Nw==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419054657", "bodyText": "this is the main file that changed.", "author": "codefromthecrypt", "createdAt": "2020-05-03T06:16:11Z", "path": "brave/src/main/java/brave/propagation/TraceContextOrSamplingFlags.java", "diffHunk": "@@ -46,26 +48,119 @@\n  * <p>This started as a port of {@code com.github.kristofa.brave.TraceData}, which served the same\n  * purpose.\n  *\n- * @see TraceContext.Extractor\n+ * @see Extractor\n+ * @since 4.0\n  */\n //@Immutable\n public final class TraceContextOrSamplingFlags {", "originalCommit": "ac5de4106d93a2ae58f178378ab8c1b321d77aff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1NDc4OA==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419054788", "bodyText": "this change caused a lot of diff, but it improves the quality. the test is the same though", "author": "codefromthecrypt", "createdAt": "2020-05-03T06:17:23Z", "path": "brave/src/test/java/brave/baggage/CorrelationScopeDecoratorTest.java", "diffHunk": "@@ -59,12 +59,13 @@\n     .add(SingleBaggageField.remote(FLUSH_FIELD.baggageField()))\n     .build();\n \n-  TraceContext context = baggageFactory.decorate(TraceContext.newBuilder()\n+  TraceContext context = TraceContext.newBuilder()", "originalCommit": "ac5de4106d93a2ae58f178378ab8c1b321d77aff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1NDgxMA==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419054810", "bodyText": "This is the backfilling of all the tests", "author": "codefromthecrypt", "createdAt": "2020-05-03T06:17:49Z", "path": "brave/src/test/java/brave/propagation/TraceContextOrSamplingFlagsTest.java", "diffHunk": "@@ -13,204 +13,513 @@\n  */\n package brave.propagation;\n \n-import java.util.Collections;\n+import java.util.function.Supplier;\n import org.junit.Test;\n \n-import static brave.internal.InternalPropagation.FLAG_SAMPLED;\n-import static brave.internal.InternalPropagation.FLAG_SAMPLED_SET;\n+import static brave.propagation.SamplingFlags.EMPTY;\n+import static brave.propagation.SamplingFlags.NOT_SAMPLED;\n+import static brave.propagation.SamplingFlags.SAMPLED;\n+import static java.util.Arrays.asList;\n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n public class TraceContextOrSamplingFlagsTest {", "originalCommit": "ac5de4106d93a2ae58f178378ab8c1b321d77aff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1fea68796b9203b77230ef9266b6d3dae86514b7", "url": "https://github.com/openzipkin/brave/commit/1fea68796b9203b77230ef9266b6d3dae86514b7", "message": "defuzz", "committedDate": "2020-05-03T06:19:00Z", "type": "commit"}, {"oid": "48f3f2e88e070181c3fcf87aafc8bde1134b9885", "url": "https://github.com/openzipkin/brave/commit/48f3f2e88e070181c3fcf87aafc8bde1134b9885", "message": "add rationale for toString", "committedDate": "2020-05-03T06:24:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1NjcxNA==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419056714", "bodyText": "I think this can produce NOT_SAMPLED|SAMPLED_LOCAL which seems a bit weird.", "author": "anuraaga", "createdAt": "2020-05-03T06:39:25Z", "path": "brave/src/main/java/brave/propagation/SamplingFlags.java", "diffHunk": "@@ -110,13 +110,25 @@ public final boolean debug() {\n   }\n \n   @Override public String toString() {\n-    return \"SamplingFlags(sampled=\"\n-      + sampled()\n-      + \", sampledLocal=\"\n-      + sampledLocal()\n-      + \", debug=\"\n-      + debug()\n-      + \")\";\n+    return toString(flags);\n+  }\n+\n+  static String toString(int flags) {\n+    StringBuilder result = new StringBuilder();\n+    if ((flags & FLAG_DEBUG) == FLAG_DEBUG) {\n+      result.append(\"DEBUG\");\n+    } else  if ((flags & FLAG_SAMPLED_SET) == FLAG_SAMPLED_SET) {\n+      if ((flags & FLAG_SAMPLED) == FLAG_SAMPLED) {\n+        result.append(\"SAMPLED\");\n+      } else {\n+        result.append(\"NOT_SAMPLED\");\n+      }\n+    }\n+    if ((flags & FLAG_SAMPLED_LOCAL) == FLAG_SAMPLED_LOCAL) {\n+      if (result.length() > 0) result.append('|');\n+      result.append(\"SAMPLED_LOCAL\");", "originalCommit": "48f3f2e88e070181c3fcf87aafc8bde1134b9885", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA2MDc5Mg==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419060792", "bodyText": "should we rename to NOT_SAMPLED_REMOTE?", "author": "codefromthecrypt", "createdAt": "2020-05-03T07:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1NjcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1NzUwNQ==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419057505", "bodyText": "See this is the same as before, but reformat to our normal grammar while we're here?\nReturns a list of additional state extracted from the request. Will be non-empty when {@link #context()} is {@code null}.", "author": "anuraaga", "createdAt": "2020-05-03T06:47:01Z", "path": "brave/src/main/java/brave/propagation/TraceContextOrSamplingFlags.java", "diffHunk": "@@ -81,64 +176,130 @@ public TraceContextOrSamplingFlags sampled(@Nullable Boolean sampled) {\n     return withFlags(flags);\n   }\n \n+  /**\n+   * This is used to apply a {@link SamplerFunction} decision with least overhead.\n+   *\n+   * Ex.\n+   * <pre>{@code\n+   * Boolean sampled = extracted.sampled();\n+   * // only recreate the context if the messaging sampler made a decision\n+   * if (sampled == null && (sampled = sampler.trySample(request)) != null) {\n+   *   extracted = extracted.sampled(sampled.booleanValue());\n+   * }\n+   * }</pre>\n+   *\n+   * @param sampled decision to apply\n+   * @return {@code this} unless {@link #sampled()} differs from the input.\n+   * @since 5.2\n+   */\n   public TraceContextOrSamplingFlags sampled(boolean sampled) {\n+    Boolean thisSampled = sampled();\n+    if (thisSampled != null && thisSampled.equals(sampled)) return this;\n     int flags = InternalPropagation.sampled(sampled, value.flags);\n     if (flags == value.flags) return this; // save effort if no change\n     return withFlags(flags);\n   }\n \n+  /**\n+   * Returns non-{@code null} when both a {@linkplain TraceContext#traceIdString() trace ID} and\n+   * {@linkplain TraceContext#spanIdString() span ID} were  {@link Extractor#extract(Object)\n+   * extracted} from a request.\n+   *\n+   * <p>For example, given the header \"b3: 80f198ee56343ba864fe8b2a57d3eff7-e457b5a2e4d86bd1-1\",\n+   * {@link B3Propagation} extracts the following:\n+   * <ul>\n+   *   <li>{@link TraceContext#traceIdString()}: \"80f198ee56343ba864fe8b2a57d3eff7\"</li>\n+   *   <li>{@link TraceContext#spanIdString()}: \"e457b5a2e4d86bd1\"</li>\n+   *   <li>{@link TraceContext#sampled()}: {@code true}</li>\n+   * </ul>\n+   *\n+   * @return the trace context when {@link #traceIdContext()} ()} and {@link #samplingFlags()} are\n+   * not {@code null}\n+   * @see #create(TraceContext)\n+   * @see #newBuilder(TraceContext)\n+   * @since 4.0\n+   */\n   @Nullable public TraceContext context() {\n     return type == 1 ? (TraceContext) value : null;\n   }\n \n+  /**\n+   * Returns non-{@code null} when a {@linkplain TraceIdContext#traceIdString() trace ID} was {@link\n+   * Extractor#extract(Object) extracted} from a request, but a {@linkplain\n+   * TraceContext#spanIdString() span ID} was not.\n+   *\n+   * <p>For example, given the header \"x-amzn-trace-id: Root=1-5759e988-bd862e3fe1be46a994272793\",\n+   * <a href=\"https://github.com/openzipkin/zipkin-aws/tree/master/brave-propagation-aws\">AWSPropagation</a>\n+   * extracts the following:\n+   * <ul>\n+   *   <li>{@link TraceIdContext#traceIdString()}: \"15759e988bd862e3fe1be46a994272793\"</li>\n+   *   <li>{@link TraceIdContext#sampled()}: {@code null}</li>\n+   * </ul>\n+   *\n+   * @return the trace ID context when {@link #context()} and {@link #samplingFlags()} are not\n+   * {@code null}\n+   * @see #create(TraceIdContext)\n+   * @see #newBuilder(TraceIdContext)\n+   * @since 4.9\n+   */\n   @Nullable public TraceIdContext traceIdContext() {\n     return type == 2 ? (TraceIdContext) value : null;\n   }\n \n+  /**\n+   * Returns non-{@code null} when a {@linkplain TraceContext#traceIdString() trace ID} was not\n+   * {@link Extractor#extract(Object) extracted} from a request.\n+   *\n+   * <p>For example, given the header \"b3: 1\", {@link B3Propagation} extracts {@link #SAMPLED}.\n+   *\n+   * @return sampling flags when {@link #context()} and {@link #traceIdContext()} are not {@code\n+   * null}\n+   * @see #create(SamplingFlags)\n+   * @see #newBuilder(SamplingFlags)\n+   * @since 4.9\n+   */\n   @Nullable public SamplingFlags samplingFlags() {\n     return type == 3 ? value : null;\n   }\n \n   /**\n-   * Non-empty when {@link #context} is null: A list of additional state extracted from the\n-   * request.\n+   * Non-empty when {@link #context()} is {@code null}: A list of additional state extracted from", "originalCommit": "48f3f2e88e070181c3fcf87aafc8bde1134b9885", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA2MDgyNw==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419060827", "bodyText": "sg", "author": "codefromthecrypt", "createdAt": "2020-05-03T07:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1NzUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1NzY1Mg==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419057652", "bodyText": "Should either this or ensureExtraAdded return Collections.unmodifaibleList?", "author": "anuraaga", "createdAt": "2020-05-03T06:48:37Z", "path": "brave/src/main/java/brave/propagation/TraceContextOrSamplingFlags.java", "diffHunk": "@@ -81,64 +176,130 @@ public TraceContextOrSamplingFlags sampled(@Nullable Boolean sampled) {\n     return withFlags(flags);\n   }\n \n+  /**\n+   * This is used to apply a {@link SamplerFunction} decision with least overhead.\n+   *\n+   * Ex.\n+   * <pre>{@code\n+   * Boolean sampled = extracted.sampled();\n+   * // only recreate the context if the messaging sampler made a decision\n+   * if (sampled == null && (sampled = sampler.trySample(request)) != null) {\n+   *   extracted = extracted.sampled(sampled.booleanValue());\n+   * }\n+   * }</pre>\n+   *\n+   * @param sampled decision to apply\n+   * @return {@code this} unless {@link #sampled()} differs from the input.\n+   * @since 5.2\n+   */\n   public TraceContextOrSamplingFlags sampled(boolean sampled) {\n+    Boolean thisSampled = sampled();\n+    if (thisSampled != null && thisSampled.equals(sampled)) return this;\n     int flags = InternalPropagation.sampled(sampled, value.flags);\n     if (flags == value.flags) return this; // save effort if no change\n     return withFlags(flags);\n   }\n \n+  /**\n+   * Returns non-{@code null} when both a {@linkplain TraceContext#traceIdString() trace ID} and\n+   * {@linkplain TraceContext#spanIdString() span ID} were  {@link Extractor#extract(Object)\n+   * extracted} from a request.\n+   *\n+   * <p>For example, given the header \"b3: 80f198ee56343ba864fe8b2a57d3eff7-e457b5a2e4d86bd1-1\",\n+   * {@link B3Propagation} extracts the following:\n+   * <ul>\n+   *   <li>{@link TraceContext#traceIdString()}: \"80f198ee56343ba864fe8b2a57d3eff7\"</li>\n+   *   <li>{@link TraceContext#spanIdString()}: \"e457b5a2e4d86bd1\"</li>\n+   *   <li>{@link TraceContext#sampled()}: {@code true}</li>\n+   * </ul>\n+   *\n+   * @return the trace context when {@link #traceIdContext()} ()} and {@link #samplingFlags()} are\n+   * not {@code null}\n+   * @see #create(TraceContext)\n+   * @see #newBuilder(TraceContext)\n+   * @since 4.0\n+   */\n   @Nullable public TraceContext context() {\n     return type == 1 ? (TraceContext) value : null;\n   }\n \n+  /**\n+   * Returns non-{@code null} when a {@linkplain TraceIdContext#traceIdString() trace ID} was {@link\n+   * Extractor#extract(Object) extracted} from a request, but a {@linkplain\n+   * TraceContext#spanIdString() span ID} was not.\n+   *\n+   * <p>For example, given the header \"x-amzn-trace-id: Root=1-5759e988-bd862e3fe1be46a994272793\",\n+   * <a href=\"https://github.com/openzipkin/zipkin-aws/tree/master/brave-propagation-aws\">AWSPropagation</a>\n+   * extracts the following:\n+   * <ul>\n+   *   <li>{@link TraceIdContext#traceIdString()}: \"15759e988bd862e3fe1be46a994272793\"</li>\n+   *   <li>{@link TraceIdContext#sampled()}: {@code null}</li>\n+   * </ul>\n+   *\n+   * @return the trace ID context when {@link #context()} and {@link #samplingFlags()} are not\n+   * {@code null}\n+   * @see #create(TraceIdContext)\n+   * @see #newBuilder(TraceIdContext)\n+   * @since 4.9\n+   */\n   @Nullable public TraceIdContext traceIdContext() {\n     return type == 2 ? (TraceIdContext) value : null;\n   }\n \n+  /**\n+   * Returns non-{@code null} when a {@linkplain TraceContext#traceIdString() trace ID} was not\n+   * {@link Extractor#extract(Object) extracted} from a request.\n+   *\n+   * <p>For example, given the header \"b3: 1\", {@link B3Propagation} extracts {@link #SAMPLED}.\n+   *\n+   * @return sampling flags when {@link #context()} and {@link #traceIdContext()} are not {@code\n+   * null}\n+   * @see #create(SamplingFlags)\n+   * @see #newBuilder(SamplingFlags)\n+   * @since 4.9\n+   */\n   @Nullable public SamplingFlags samplingFlags() {\n     return type == 3 ? value : null;\n   }\n \n   /**\n-   * Non-empty when {@link #context} is null: A list of additional state extracted from the\n-   * request.\n+   * Non-empty when {@link #context()} is {@code null}: A list of additional state extracted from\n+   * the request.\n    *\n    * @see TraceContext#extra()\n+   * @since 4.9\n    */\n   public final List<Object> extra() {\n-    return extra;\n+    return extraList;", "originalCommit": "48f3f2e88e070181c3fcf87aafc8bde1134b9885", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA2MDkxMA==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419060910", "bodyText": "ensureImmutable(extraList) should have already done this. I'll backfill a test", "author": "codefromthecrypt", "createdAt": "2020-05-03T07:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1NzY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1ODA0Mw==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419058043", "bodyText": "Maybe an extra line or two but seems quite a bit simpler to lowercase before append without the 0's\nresult.append(\"Extracted{\")\nString valueClass = value.getClass().getSimpleName();\n// Lowercase first char of class name\nresult.append(Character.toLowerCase(valueClass.charAt(0));\nresult.append(valueClass, 1, valueClass.length());", "author": "anuraaga", "createdAt": "2020-05-03T06:52:07Z", "path": "brave/src/main/java/brave/propagation/TraceContextOrSamplingFlags.java", "diffHunk": "@@ -81,64 +176,130 @@ public TraceContextOrSamplingFlags sampled(@Nullable Boolean sampled) {\n     return withFlags(flags);\n   }\n \n+  /**\n+   * This is used to apply a {@link SamplerFunction} decision with least overhead.\n+   *\n+   * Ex.\n+   * <pre>{@code\n+   * Boolean sampled = extracted.sampled();\n+   * // only recreate the context if the messaging sampler made a decision\n+   * if (sampled == null && (sampled = sampler.trySample(request)) != null) {\n+   *   extracted = extracted.sampled(sampled.booleanValue());\n+   * }\n+   * }</pre>\n+   *\n+   * @param sampled decision to apply\n+   * @return {@code this} unless {@link #sampled()} differs from the input.\n+   * @since 5.2\n+   */\n   public TraceContextOrSamplingFlags sampled(boolean sampled) {\n+    Boolean thisSampled = sampled();\n+    if (thisSampled != null && thisSampled.equals(sampled)) return this;\n     int flags = InternalPropagation.sampled(sampled, value.flags);\n     if (flags == value.flags) return this; // save effort if no change\n     return withFlags(flags);\n   }\n \n+  /**\n+   * Returns non-{@code null} when both a {@linkplain TraceContext#traceIdString() trace ID} and\n+   * {@linkplain TraceContext#spanIdString() span ID} were  {@link Extractor#extract(Object)\n+   * extracted} from a request.\n+   *\n+   * <p>For example, given the header \"b3: 80f198ee56343ba864fe8b2a57d3eff7-e457b5a2e4d86bd1-1\",\n+   * {@link B3Propagation} extracts the following:\n+   * <ul>\n+   *   <li>{@link TraceContext#traceIdString()}: \"80f198ee56343ba864fe8b2a57d3eff7\"</li>\n+   *   <li>{@link TraceContext#spanIdString()}: \"e457b5a2e4d86bd1\"</li>\n+   *   <li>{@link TraceContext#sampled()}: {@code true}</li>\n+   * </ul>\n+   *\n+   * @return the trace context when {@link #traceIdContext()} ()} and {@link #samplingFlags()} are\n+   * not {@code null}\n+   * @see #create(TraceContext)\n+   * @see #newBuilder(TraceContext)\n+   * @since 4.0\n+   */\n   @Nullable public TraceContext context() {\n     return type == 1 ? (TraceContext) value : null;\n   }\n \n+  /**\n+   * Returns non-{@code null} when a {@linkplain TraceIdContext#traceIdString() trace ID} was {@link\n+   * Extractor#extract(Object) extracted} from a request, but a {@linkplain\n+   * TraceContext#spanIdString() span ID} was not.\n+   *\n+   * <p>For example, given the header \"x-amzn-trace-id: Root=1-5759e988-bd862e3fe1be46a994272793\",\n+   * <a href=\"https://github.com/openzipkin/zipkin-aws/tree/master/brave-propagation-aws\">AWSPropagation</a>\n+   * extracts the following:\n+   * <ul>\n+   *   <li>{@link TraceIdContext#traceIdString()}: \"15759e988bd862e3fe1be46a994272793\"</li>\n+   *   <li>{@link TraceIdContext#sampled()}: {@code null}</li>\n+   * </ul>\n+   *\n+   * @return the trace ID context when {@link #context()} and {@link #samplingFlags()} are not\n+   * {@code null}\n+   * @see #create(TraceIdContext)\n+   * @see #newBuilder(TraceIdContext)\n+   * @since 4.9\n+   */\n   @Nullable public TraceIdContext traceIdContext() {\n     return type == 2 ? (TraceIdContext) value : null;\n   }\n \n+  /**\n+   * Returns non-{@code null} when a {@linkplain TraceContext#traceIdString() trace ID} was not\n+   * {@link Extractor#extract(Object) extracted} from a request.\n+   *\n+   * <p>For example, given the header \"b3: 1\", {@link B3Propagation} extracts {@link #SAMPLED}.\n+   *\n+   * @return sampling flags when {@link #context()} and {@link #traceIdContext()} are not {@code\n+   * null}\n+   * @see #create(SamplingFlags)\n+   * @see #newBuilder(SamplingFlags)\n+   * @since 4.9\n+   */\n   @Nullable public SamplingFlags samplingFlags() {\n     return type == 3 ? value : null;\n   }\n \n   /**\n-   * Non-empty when {@link #context} is null: A list of additional state extracted from the\n-   * request.\n+   * Non-empty when {@link #context()} is {@code null}: A list of additional state extracted from\n+   * the request.\n    *\n    * @see TraceContext#extra()\n+   * @since 4.9\n    */\n   public final List<Object> extra() {\n-    return extra;\n+    return extraList;\n   }\n \n-  public final Builder toBuilder() {\n-    Builder result = new Builder();\n-    result.type = type;\n-    result.value = value;\n-    result.extra = extra;\n-    return result;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"{value=\" + value + \", extra=\" + extra + \"}\";\n-  }\n-\n-  public static TraceContextOrSamplingFlags create(TraceContext context) {\n-    return new TraceContextOrSamplingFlags(1, context, emptyList());\n-  }\n-\n-  public static TraceContextOrSamplingFlags create(TraceIdContext traceIdContext) {\n-    return new TraceContextOrSamplingFlags(2, traceIdContext, emptyList());\n+  /**\n+   * Use to decorate an {@link Extractor#extract extraction result} with {@link #sampledLocal()} or\n+   * additional {@link #extra()}.\n+   *\n+   * @since 4.9\n+   */\n+  public Builder toBuilder() {\n+    return new Builder(type, value, effectiveExtra());\n   }\n \n-  public static TraceContextOrSamplingFlags create(SamplingFlags flags) {\n-    // reuses constants to avoid excess allocation\n-    if (flags == SamplingFlags.SAMPLED) return SAMPLED;\n-    if (flags == SamplingFlags.EMPTY) return EMPTY;\n-    if (flags == SamplingFlags.NOT_SAMPLED) return NOT_SAMPLED;\n-    if (flags == SamplingFlags.DEBUG) return DEBUG;\n-    return new TraceContextOrSamplingFlags(3, flags, emptyList());\n+  @Override public String toString() {\n+    List<Object> extra = effectiveExtra();\n+    StringBuilder result = new StringBuilder();\n+    result.append(value.getClass().getSimpleName()).append('=').append(value);\n+    result.setCharAt(0, Character.toLowerCase(result.charAt(0))); // lowercase the first char", "originalCommit": "48f3f2e88e070181c3fcf87aafc8bde1134b9885", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA2MDk0MQ==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419060941", "bodyText": "thanks good idea", "author": "codefromthecrypt", "createdAt": "2020-05-03T07:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1ODA0Mw=="}], "type": "inlineReview"}, {"oid": "e9bb9d392d2407958e2468ef888257100968a614", "url": "https://github.com/openzipkin/brave/commit/e9bb9d392d2407958e2468ef888257100968a614", "message": "feedback", "committedDate": "2020-05-03T09:06:44Z", "type": "commit"}, {"oid": "b5905ab121c9527611d94688d0e8335d4decc9a0", "url": "https://github.com/openzipkin/brave/commit/b5905ab121c9527611d94688d0e8335d4decc9a0", "message": "fixes unmodifiable bug", "committedDate": "2020-05-03T09:18:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA3NjA0OA==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419076048", "bodyText": "Don't think this changed the return type, concat returns it too, and uses the fixed length list as delegate", "author": "anuraaga", "createdAt": "2020-05-03T09:33:44Z", "path": "brave/src/main/java/brave/internal/Lists.java", "diffHunk": "@@ -36,7 +36,7 @@\n     if (list.size() == 1) return Collections.singletonList(list.get(0));\n     if (isImmutable(list)) return list;\n \n-    return concat(list, Collections.emptyList());\n+    return Collections.unmodifiableList(new ArrayList<>(list));", "originalCommit": "b5905ab121c9527611d94688d0e8335d4decc9a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA3OTI0Ng==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419079246", "bodyText": "concat special cased one side empty and in that special casing didn't ensure the input was immutable. that was the bug.", "author": "codefromthecrypt", "createdAt": "2020-05-03T10:00:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA3NjA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA3NjMxOA==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419076318", "bodyText": "Sorry my previous comment was invalid I think. I didn't notice the ensure immutable here.", "author": "anuraaga", "createdAt": "2020-05-03T09:36:04Z", "path": "brave/src/main/java/brave/propagation/TraceContext.java", "diffHunk": "@@ -481,7 +488,7 @@ public final TraceContext build() {\n       if (spanId == 0L) missing += \" spanId\";\n       if (!\"\".equals(missing)) throw new IllegalArgumentException(\"Missing:\" + missing);\n       return new TraceContext(\n-        flags, traceIdHigh, traceId, localRootId, parentId, spanId, ensureImmutable(extra)\n+        flags, traceIdHigh, traceId, localRootId, parentId, spanId, ensureImmutable(extraList)", "originalCommit": "b5905ab121c9527611d94688d0e8335d4decc9a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA3OTMxMA==", "url": "https://github.com/openzipkin/brave/pull/1185#discussion_r419079310", "bodyText": "there was a bug just not here :)", "author": "codefromthecrypt", "createdAt": "2020-05-03T10:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA3NjMxOA=="}], "type": "inlineReview"}]}