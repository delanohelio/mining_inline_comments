{"pr_number": 1175, "pr_title": "Renovates gRPC instrumentation in preparation of standard parsing", "pr_createdAt": "2020-04-27T01:39:41Z", "pr_url": "https://github.com/openzipkin/brave/pull/1175", "timeline": [{"oid": "66dd94ef3efdd7a66b3bad5706beb269bd3674ba", "url": "https://github.com/openzipkin/brave/commit/66dd94ef3efdd7a66b3bad5706beb269bd3674ba", "message": "Renovates gRPC instrumentation in preparation of standard parsing\n\nThis fixes some glitches in preparation of #999\n\n* Bumps gRPC to 1.29 (there was no impact)\n* GrpcClientRequest and GrpcServerRequest unwrapped `this`, not the call.\n* Anonymous GrpcClientParser and GrpcServerParser used ErrorParser unnecessarily\n  * This is implicitly done in the Zipkin span handler\n* Status.cause was ignored\n  * This led to a less precise \"error\" tag\n* Client headers were unnecessarily null during sampling. This was caused by\n  too eager allocation of a span.\n* ClientCall.Listener was wrapped twice\n* Most ClientCall hooks were not placed in scope\n* ServerCall's span was started too late", "committedDate": "2020-04-27T02:46:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUzNjQ3Mw==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415536473", "bodyText": "Don't know if I've seen @ before and not sure how to search for it. Quick pointer to what it is?", "author": "anuraaga", "createdAt": "2020-04-27T06:11:10Z", "path": "instrumentation/grpc/src/it/grpc12/pom.xml", "diffHunk": "@@ -47,6 +47,11 @@\n       <artifactId>junit</artifactId>\n       <version>@junit.version@</version>\n     </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <version>@mockito.version@</version>", "originalCommit": "8d33e66e088c2d28df52679cd8cd23b622f79230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1MzI1MQ==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415553251", "bodyText": "maven-invoker-plugin isolates the build environment, so you have to opt-in to inherit anything. This syntax means the property is lifted from the invoking environment\nhttp://maven.apache.org/plugins/maven-invoker-plugin/examples/filtering.html", "author": "codefromthecrypt", "createdAt": "2020-04-27T06:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUzNjQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUzNjYzNQ==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415536635", "bodyText": "Maybe not since it's exposed out of tree, but could consider putting these resources in brave-test", "author": "anuraaga", "createdAt": "2020-04-27T06:11:30Z", "path": "instrumentation/grpc/src/it/grpc12/src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker", "diffHunk": "@@ -0,0 +1 @@\n+mock-maker-inline", "originalCommit": "8d33e66e088c2d28df52679cd8cd23b622f79230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1Mzc1OA==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415553758", "bodyText": "brave-test doesn't currently depend on mockito, and mockito versions have been painful in the past.. good idea in general, but I feel I don't want to move anything mockito related to a wider scope.. make sense?", "author": "codefromthecrypt", "createdAt": "2020-04-27T06:49:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUzNjYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0MDk5NQ==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415540995", "bodyText": "I think status or trailers are never null", "author": "anuraaga", "createdAt": "2020-04-27T06:22:03Z", "path": "instrumentation/grpc/src/main/java/brave/grpc/GrpcClientResponse.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.grpc;\n+\n+import brave.Response;\n+import brave.Span;\n+import brave.internal.Nullable;\n+import io.grpc.ClientCall;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+\n+// intentionally not yet public until we add tag parsing functionality\n+final class GrpcClientResponse extends Response {\n+  final GrpcClientRequest request;\n+  @Nullable final Status status;\n+  @Nullable final Metadata trailers;\n+  @Nullable final Throwable error;\n+\n+  GrpcClientResponse(GrpcClientRequest request,\n+    @Nullable Status status, @Nullable Metadata trailers, @Nullable Throwable error) {", "originalCommit": "8d33e66e088c2d28df52679cd8cd23b622f79230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1ODk5OA==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415558998", "bodyText": "when we assume close is always called, I agree.. this ties to your other point, which I'm ok documenting in RATIONALE so in case the assumption proves wrong, we can update and move do this again\nJust note if it does prove wrong we will have to mark something we said was not nullable nullable, which would surprise people.\nPlease ack if you feel confident enough that we should assume grpc always calls close, as that's not an assumption we make elsewhere, and frankly I would be surprised if that's provable.", "author": "codefromthecrypt", "createdAt": "2020-04-27T06:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0MDk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYwMDQ3NQ==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415600475", "bodyText": "Thanks - after writing some tests, realized that indeed close isn't always called when interceptors are badly behaving.\nFor the nullability in particular, I noticed we only call new Grpc*Response in close though, elsewhere we just finish the span directly without using this class. I guess it makes sense, that a GrpcResponse is a gRPC response, where gRPC responses always have status / trailers as per the wire format, and any other case there is no response and this wouldn't be initialized, but maybe we're anticipating such a case so keeping it loose is fine too.", "author": "anuraaga", "createdAt": "2020-04-27T08:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0MDk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyNjI2NA==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415626264", "bodyText": "appreciate the help with the tests as without them this is all folklore!\nFWIW the code with \"finish\" is more forward thinking for #999 which would actually use the status stuff. more of this was re-jigging in anticipation of that being used... admittedly makes less sense until that it merged also.", "author": "codefromthecrypt", "createdAt": "2020-04-27T08:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0MDk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyOTQyMw==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415629423", "bodyText": "since the GrpcResponse types are hidden anyway, let's move this to #999 where you can see them used (and also where they are made public)", "author": "codefromthecrypt", "createdAt": "2020-04-27T08:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0MDk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0MjE1Ng==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415542156", "bodyText": "Not sure but I think this would only happen if there is an error in the business logic on the client side when processing the closure, even if the request itself succeeded. So this might not warrant marking the span as error.", "author": "anuraaga", "createdAt": "2020-04-27T06:24:25Z", "path": "instrumentation/grpc/src/main/java/brave/grpc/TracingClientInterceptor.java", "diffHunk": "@@ -127,38 +192,23 @@\n \n     @Override public void onMessage(RespT message) {\n       try (Scope scope = currentTraceContext.maybeScope(invocationContext)) {\n+        Span span = spanRef.get(); // could be an error\n+        SpanCustomizer customizer = span != null ? span.customizer() : NoopSpanCustomizer.INSTANCE;\n+        messageProcessor.onMessageReceived(message, customizer);\n         delegate().onMessage(message);\n       }\n     }\n \n     @Override public void onClose(Status status, Metadata trailers) {\n+      Throwable error = null;\n       try (Scope scope = currentTraceContext.maybeScope(invocationContext)) {\n         delegate().onClose(status, trailers);\n-      }\n-    }\n-  }\n-\n-  final class TracingClientCallListener<RespT> extends SimpleForwardingClientCallListener<RespT> {\n-    final Span span;\n-\n-    TracingClientCallListener(Listener<RespT> responseListener, Span span) {\n-      super(responseListener);\n-      this.span = span;\n-    }\n-\n-    @Override public void onMessage(RespT message) {\n-      try (Scope scope = currentTraceContext.maybeScope(span.context())) {\n-        parser.onMessageReceived(message, span.customizer());\n-        delegate().onMessage(message);\n-      }\n-    }\n-\n-    @Override public void onClose(Status status, Metadata trailers) {\n-      try (Scope scope = currentTraceContext.maybeScope(span.context())) {\n-        super.onClose(status, trailers);\n-        parser.onClose(status, trailers, span.customizer());\n+      } catch (Throwable e) {\n+        error = e;", "originalCommit": "8d33e66e088c2d28df52679cd8cd23b622f79230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0ODc4OQ==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415648789", "bodyText": "agree. made a note in the rationale", "author": "codefromthecrypt", "createdAt": "2020-04-27T09:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0MjE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0MzQ3Mw==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415543473", "bodyText": "I'm less clear about this one since closure on the server side is handled by the framework, so an error may or may not indicate the response failed. Ideally, our interceptor is in a location where the only possibility of an exception here is a grpc-java bug.", "author": "anuraaga", "createdAt": "2020-04-27T06:27:25Z", "path": "instrumentation/grpc/src/main/java/brave/grpc/TracingServerInterceptor.java", "diffHunk": "@@ -91,96 +99,119 @@ Span nextSpan(TraceContextOrSamplingFlags extracted, GrpcServerRequest request)\n       : tracer.nextSpan(extracted);\n   }\n \n+  void finish(GrpcServerResponse response, @Nullable Span span) {\n+    if (span == null || span.isNoop()) return;\n+    Throwable error = response.error();\n+    if (error != null) span.error(error);\n+    parser.onClose(response.status, response.trailers, span.customizer());\n+    span.finish();\n+  }\n+\n+  void finishWithError(@Nullable Span span, Throwable error) {\n+    if (span == null || span.isNoop()) return;\n+    if (error != null) span.error(error);\n+    span.finish();\n+  }\n+\n   final class TracingServerCall<ReqT, RespT> extends SimpleForwardingServerCall<ReqT, RespT> {\n-    final Span span;\n+    final TraceContext context;\n+    final AtomicReference<Span> spanRef;\n+    final GrpcServerRequest request;\n \n-    TracingServerCall(Span span, ServerCall<ReqT, RespT> call) {\n-      super(call);\n-      this.span = span;\n+    TracingServerCall(ServerCall<ReqT, RespT> delegate, Span span, AtomicReference<Span> spanRef,\n+      GrpcServerRequest request) {\n+      super(delegate);\n+      this.context = span.context();\n+      this.spanRef = spanRef;\n+      this.request = request;\n     }\n \n     @Override public void request(int numMessages) {\n-      span.start();\n-      try (Scope scope = currentTraceContext.maybeScope(span.context())) {\n-        super.request(numMessages);\n+      try (Scope scope = currentTraceContext.maybeScope(context)) {\n+        delegate().request(numMessages);\n       }\n     }\n \n     @Override public void sendHeaders(Metadata headers) {\n-      try (Scope scope = currentTraceContext.maybeScope(span.context())) {\n-        super.sendHeaders(headers);\n+      try (Scope scope = currentTraceContext.maybeScope(context)) {\n+        delegate().sendHeaders(headers);\n       }\n     }\n \n     @Override public void sendMessage(RespT message) {\n-      try (Scope scope = currentTraceContext.maybeScope(span.context())) {\n-        super.sendMessage(message);\n-        parser.onMessageSent(message, span.customizer());\n+      try (Scope scope = currentTraceContext.maybeScope(context)) {\n+        delegate().sendMessage(message);\n+        Span span = spanRef.get(); // could be an error\n+        SpanCustomizer customizer = span != null ? span.customizer() : NoopSpanCustomizer.INSTANCE;\n+        messageProcessor.onMessageSent(message, customizer);\n       }\n     }\n \n     @Override public void close(Status status, Metadata trailers) {\n-      try (Scope scope = currentTraceContext.maybeScope(span.context())) {\n-        super.close(status, trailers);\n-        parser.onClose(status, trailers, span.customizer());\n+      Throwable error = null;\n+      try (Scope scope = currentTraceContext.maybeScope(context)) {\n+        delegate().close(status, trailers);\n       } catch (Throwable e) {\n-        span.error(e);\n+        error = e;", "originalCommit": "8d33e66e088c2d28df52679cd8cd23b622f79230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY1MTcyOA==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415651728", "bodyText": "agreed and in rationale now. thanks!", "author": "codefromthecrypt", "createdAt": "2020-04-27T09:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0MzQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NDA5Mg==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415544092", "bodyText": "Related to my other comments, instead of passing in an error, for gRPC it's probably more correct to just always use status.getCause(). The framework is supposed to convert any business logic exception into a Status with the cause set to that exception.", "author": "anuraaga", "createdAt": "2020-04-27T06:28:47Z", "path": "instrumentation/grpc/src/main/java/brave/grpc/GrpcClientResponse.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.grpc;\n+\n+import brave.Response;\n+import brave.Span;\n+import brave.internal.Nullable;\n+import io.grpc.ClientCall;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+\n+// intentionally not yet public until we add tag parsing functionality\n+final class GrpcClientResponse extends Response {\n+  final GrpcClientRequest request;\n+  @Nullable final Status status;\n+  @Nullable final Metadata trailers;\n+  @Nullable final Throwable error;\n+\n+  GrpcClientResponse(GrpcClientRequest request,\n+    @Nullable Status status, @Nullable Metadata trailers, @Nullable Throwable error) {\n+    if (request == null) throw new NullPointerException(\"request == null\");\n+    this.request = request;\n+    this.status = status;\n+    this.trailers = trailers;\n+    this.error = error != null ? error : status != null ? status.getCause() : null;", "originalCommit": "8d33e66e088c2d28df52679cd8cd23b622f79230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1NjcwOA==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415556708", "bodyText": "I think what you are saying in general is that we should assume grpc will always call close() even if client interceptors/handlers etc fail.\nI'm cool with that. We do have code that is in other libraries that we should still be careful about. In the case that we find grpc has bugs what will happen is that we will leak spans. This is imho ok as such leaks we can address in a non-api affecting patch release.", "author": "codefromthecrypt", "createdAt": "2020-04-27T06:55:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NDA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0OTY2Mg==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415649662", "bodyText": "I think this comment drifted as we are catching things which don't incur a grpc status, so resolving it.", "author": "codefromthecrypt", "createdAt": "2020-04-27T09:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NDA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NjU1MQ==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415546551", "bodyText": "I think close will be called with this error packed into the Status and we probably don't need to specially handle it.", "author": "anuraaga", "createdAt": "2020-04-27T06:33:54Z", "path": "instrumentation/grpc/src/main/java/brave/grpc/TracingClientInterceptor.java", "diffHunk": "@@ -30,95 +32,158 @@\n import io.grpc.ForwardingClientCall.SimpleForwardingClientCall;\n import io.grpc.ForwardingClientCallListener.SimpleForwardingClientCallListener;\n import io.grpc.Metadata;\n+import io.grpc.Metadata.Key;\n import io.grpc.MethodDescriptor;\n import io.grpc.Status;\n import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import static brave.grpc.GrpcClientRequest.SETTER;\n \n // not exposed directly as implementation notably changes between versions 1.2 and 1.3\n final class TracingClientInterceptor implements ClientInterceptor {\n-  final Tracer tracer;\n+  final Map<String, Key<String>> nameToKey;\n   final CurrentTraceContext currentTraceContext;\n+  final Tracer tracer;\n   final SamplerFunction<RpcRequest> sampler;\n   final Injector<GrpcClientRequest> injector;\n   final GrpcClientParser parser;\n-  final Map<String, Metadata.Key<String>> nameToKey;\n+  final MessageProcessor messageProcessor;\n \n   TracingClientInterceptor(GrpcTracing grpcTracing) {\n-    tracer = grpcTracing.rpcTracing.tracing().tracer();\n+    nameToKey = grpcTracing.nameToKey;\n     currentTraceContext = grpcTracing.rpcTracing.tracing().currentTraceContext();\n+    tracer = grpcTracing.rpcTracing.tracing().tracer();\n     sampler = grpcTracing.rpcTracing.clientSampler();\n     injector = grpcTracing.propagation.injector(SETTER);\n     parser = grpcTracing.clientParser;\n-    nameToKey = grpcTracing.nameToKey;\n+    messageProcessor = grpcTracing.clientMessageProcessor;\n   }\n \n   @Override\n   public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(MethodDescriptor<ReqT, RespT> method,\n     CallOptions callOptions, Channel next) {\n-    TraceContext invocationContext = currentTraceContext.get();\n-\n-    GrpcClientRequest request = new GrpcClientRequest(nameToKey, method);\n-    Span span = tracer.nextSpanWithParent(sampler, request, invocationContext);\n-\n-    Throwable error = null;\n-    try (Scope scope = currentTraceContext.maybeScope(span.context())) {\n-      return new SimpleForwardingClientCall<ReqT, RespT>(next.newCall(method, callOptions)) {\n-        @Override public void start(Listener<RespT> responseListener, Metadata headers) {\n-          request.metadata = headers;\n-          injector.inject(span.context(), request);\n-          span.kind(Span.Kind.CLIENT).start();\n-          try (Scope scope = currentTraceContext.maybeScope(span.context())) {\n-            parser.onStart(method, callOptions, headers, span.customizer());\n-\n-            // See RATIONALE.md which notes response callbacks are in the invocation context\n-            responseListener = new TraceContextCallListener<>(\n-              responseListener,\n-              currentTraceContext,\n-              invocationContext\n-            );\n-\n-            super.start(new TracingClientCallListener<>(responseListener, span), headers);\n-          }\n-        }\n-\n-        @Override public void sendMessage(ReqT message) {\n-          try (Scope scope = currentTraceContext.maybeScope(span.context())) {\n-            super.sendMessage(message);\n-            parser.onMessageSent(message, span.customizer());\n-          }\n-        }\n-      };\n-    } catch (Throwable e) {\n-      error = e;\n-      throw e;\n-    } finally {\n-      if (error != null) span.error(error).finish();\n+    return new TracingClientCall<>(\n+      method, callOptions, currentTraceContext.get(), next.newCall(method, callOptions));\n+  }\n+\n+  void finish(GrpcClientResponse response, @Nullable Span span) {\n+    if (span == null || span.isNoop()) return;\n+    Throwable error = response.error();\n+    if (error != null) span.error(error);\n+    parser.onClose(response.status, response.trailers, span.customizer());\n+    span.finish();\n+  }\n+\n+  void finishWithError(@Nullable Span span, Throwable error) {\n+    if (span == null || span.isNoop()) return;\n+    if (error != null) span.error(error);\n+    span.finish();\n+  }\n+\n+  final class TracingClientCall<ReqT, RespT> extends SimpleForwardingClientCall<ReqT, RespT> {\n+    final MethodDescriptor<ReqT, RespT> method;\n+    final CallOptions callOptions;\n+    final TraceContext invocationContext;\n+    final AtomicReference<Span> spanRef = new AtomicReference<>();\n+\n+    TracingClientCall(MethodDescriptor<ReqT, RespT> method, CallOptions callOptions,\n+      TraceContext invocationContext, ClientCall<ReqT, RespT> call) {\n+      super(call);\n+      this.method = method;\n+      this.callOptions = callOptions;\n+      this.invocationContext = invocationContext;\n+    }\n+\n+    @Override public void start(Listener<RespT> responseListener, Metadata headers) {\n+      GrpcClientRequest request =\n+        new GrpcClientRequest(nameToKey, method, callOptions, delegate(), headers);\n+\n+      Span span = tracer.nextSpanWithParent(sampler, request, invocationContext);\n+      injector.inject(span.context(), request);\n+      if (!span.isNoop()) {\n+        span.kind(Span.Kind.CLIENT).start();\n+        parser.onStart(method, callOptions, headers, span.customizer());\n+      }\n+      spanRef.set(span);\n+\n+      responseListener = new TracingClientCallListener<>(\n+        responseListener,\n+        invocationContext,\n+        spanRef,\n+        request\n+      );\n+\n+      try (Scope scope = currentTraceContext.maybeScope(span.context())) {\n+        super.start(responseListener, headers);\n+      } catch (Throwable e) {\n+        finishWithError(spanRef.getAndSet(null), e);", "originalCommit": "8d33e66e088c2d28df52679cd8cd23b622f79230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY1MTIxNw==", "url": "https://github.com/openzipkin/brave/pull/1175#discussion_r415651217", "bodyText": "userInterceptor_throwsOnStart now exists to explain this.", "author": "codefromthecrypt", "createdAt": "2020-04-27T09:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NjU1MQ=="}], "type": "inlineReview"}, {"oid": "f08c09366b3547a4b19944551412da5cdce17d5e", "url": "https://github.com/openzipkin/brave/commit/f08c09366b3547a4b19944551412da5cdce17d5e", "message": "Renovates gRPC instrumentation in preparation of standard parsing\n\nThis fixes some glitches in preparation of #999\n\n* Bumps gRPC to 1.29 (there was no impact)\n* GrpcClientRequest and GrpcServerRequest unwrapped `this`, not the call.\n* Anonymous GrpcClientParser and GrpcServerParser used ErrorParser unnecessarily\n  * This is implicitly done in the Zipkin span handler\n* Status.cause was ignored\n  * This led to a less precise \"error\" tag\n* Client headers were unnecessarily null during sampling. This was caused by\n  too eager allocation of a span.\n* ClientCall.Listener was wrapped twice\n* Most ClientCall hooks were not placed in scope\n* ServerCall's span was started too late", "committedDate": "2020-04-27T11:03:32Z", "type": "forcePushed"}, {"oid": "8920d3c89d0c4243f9626241eb5dd62a5cc93d51", "url": "https://github.com/openzipkin/brave/commit/8920d3c89d0c4243f9626241eb5dd62a5cc93d51", "message": "Renovates gRPC instrumentation in preparation of standard parsing\n\nThis fixes some glitches in preparation of #999\n\n* Bumps gRPC to 1.29 (there was no impact)\n* GrpcClientRequest and GrpcServerRequest unwrapped `this`, not the call.\n* Anonymous GrpcClientParser and GrpcServerParser used ErrorParser unnecessarily\n  * This is implicitly done in the Zipkin span handler\n* Status.cause was ignored\n  * This led to a less precise \"error\" tag\n* Client headers were unnecessarily null during sampling. This was caused by\n  too eager allocation of a span.\n* ClientCall.Listener was wrapped twice\n* Most ClientCall hooks were not placed in scope\n* ServerCall's span was started too late", "committedDate": "2020-04-27T11:45:32Z", "type": "forcePushed"}, {"oid": "8920d3c89d0c4243f9626241eb5dd62a5cc93d51", "url": "https://github.com/openzipkin/brave/commit/8920d3c89d0c4243f9626241eb5dd62a5cc93d51", "message": "Renovates gRPC instrumentation in preparation of standard parsing\n\nThis fixes some glitches in preparation of #999\n\n* Bumps gRPC to 1.29 (there was no impact)\n* GrpcClientRequest and GrpcServerRequest unwrapped `this`, not the call.\n* Anonymous GrpcClientParser and GrpcServerParser used ErrorParser unnecessarily\n  * This is implicitly done in the Zipkin span handler\n* Status.cause was ignored\n  * This led to a less precise \"error\" tag\n* Client headers were unnecessarily null during sampling. This was caused by\n  too eager allocation of a span.\n* ClientCall.Listener was wrapped twice\n* Most ClientCall hooks were not placed in scope\n* ServerCall's span was started too late", "committedDate": "2020-04-27T11:45:32Z", "type": "commit"}, {"oid": "7626a8f0099d026ad5c391ab50906baf6f4e1783", "url": "https://github.com/openzipkin/brave/commit/7626a8f0099d026ad5c391ab50906baf6f4e1783", "message": "Good Riddance fancy mocks", "committedDate": "2020-04-27T12:15:43Z", "type": "commit"}, {"oid": "a0ea5b6fea775e9ee1aa8979a7db78dae40df219", "url": "https://github.com/openzipkin/brave/commit/a0ea5b6fea775e9ee1aa8979a7db78dae40df219", "message": "die mockito", "committedDate": "2020-04-27T12:19:32Z", "type": "commit"}, {"oid": "8af75406ed0396952f450edc132035de94e87e03", "url": "https://github.com/openzipkin/brave/commit/8af75406ed0396952f450edc132035de94e87e03", "message": "less flakey", "committedDate": "2020-04-27T12:48:26Z", "type": "commit"}]}