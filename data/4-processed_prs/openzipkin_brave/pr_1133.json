{"pr_number": 1133, "pr_title": "Adds Tag, Tags and HttpTags", "pr_createdAt": "2020-04-01T04:00:50Z", "pr_url": "https://github.com/openzipkin/brave/pull/1133", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MTYwOQ==", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401351609", "bodyText": "I guess it's either Nullable result or Possibly null result. Though maybe better to phrase something like The result to add as a span tag. {@code null} means no tag will be added.", "author": "anuraaga", "createdAt": "2020-04-01T04:38:00Z", "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!", "originalCommit": "4b88cd4bd589b7ae433162c60252d90ec58f09c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3MDg1NA==", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401370854", "bodyText": "sgtm", "author": "codefromthecrypt", "createdAt": "2020-04-01T05:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MTYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjI5Mg==", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401352292", "bodyText": "Maybe can leave off these docs at Tags the value parsed from the {@code input}.. The non-null is really a job of parseValue, and there's no way to tag a no-op span anyways, the key point is we don't waste time parsing when it's no-op but that's an implementation detail.", "author": "anuraaga", "createdAt": "2020-04-01T04:41:10Z", "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * {@linkplain ScopedSpan#tag(String, String) Tags} the value parsed from the {@code input} when", "originalCommit": "4b88cd4bd589b7ae433162c60252d90ec58f09c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3MTMyOQ==", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401371329", "bodyText": "cool", "author": "codefromthecrypt", "createdAt": "2020-04-01T05:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjUwOA==", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401352508", "bodyText": "I'm sure it must have been thought no need for detail - any thoughts on a shared interface?", "author": "anuraaga", "createdAt": "2020-04-01T04:42:13Z", "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * {@linkplain ScopedSpan#tag(String, String) Tags} the value parsed from the {@code input} when\n+   * non-null and the {@linkplain ScopedSpan#isNoop() span is not no-op}.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, ScopedSpan span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    tag(span, input, span.context());\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) Tags} the value parsed from the {@code input}\n+   * when non-null and the span is not no-op.\n+   *\n+   * @since 5.11\n+   */\n+  // ex void parse(HttpRequest request, TraceContext context, SpanCustomizer span);\n+  public final void tag(I input, TraceContext context, SpanCustomizer span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (context == null) throw new NullPointerException(\"context == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    if (span == NoopSpanCustomizer.INSTANCE) return;\n+    tag(span, input, context);\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) Tags} the value parsed from the {@code input}\n+   * when non-null and the span is not no-op.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, SpanCustomizer span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    TraceContext context = null;\n+    if (span instanceof Span) {\n+      Span asSpan = (Span) span;\n+      if (asSpan.isNoop()) return;\n+      context = asSpan.context();\n+    } else if (span == NoopSpanCustomizer.INSTANCE) {\n+      return;\n+    }\n+    tag(span, input, context);\n+  }\n+\n+  /**\n+   * {@linkplain MutableSpan#tag(String, String) Tags} the value parsed from the {@code input} when\n+   * non-null.\n+   *\n+   * @see FinishedSpanHandler#handle(TraceContext, MutableSpan)\n+   * @since 5.11\n+   */\n+  public final void tag(I input, TraceContext context, MutableSpan span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    tag(span, input, context);\n+  }\n+\n+  final String key;\n+\n+  /** @since 5.11 */\n+  protected Tag(String key) {\n+    this.key = validateNonEmpty(\"key\", key);\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName() + \"{\" + key + \"}\";\n+  }\n+\n+  final void tag(Object span, I input, @Nullable TraceContext context) {\n+    String value;\n+    try {\n+      value = parseValue(input, context);\n+    } catch (Throwable e) {\n+      propagateIfFatal(e);\n+      Platform.get().log(\"Error parsing tag value of input %s\", input, e);\n+      return;\n+    }\n+    if (value == null) return;\n+    if (span instanceof SpanCustomizer) {", "originalCommit": "4b88cd4bd589b7ae433162c60252d90ec58f09c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3MjMzOA==", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401372338", "bodyText": "sure. here's the context\nSpan is indeed instanceof SpanCustomizer\nScopedSpan doesn't allow name overrides\nMutableSpan doesn't have an implicit timestamp", "author": "codefromthecrypt", "createdAt": "2020-04-01T05:58:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3Mjg5Nw==", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401372897", "bodyText": "we could allow ScopedSpan to override its name.. now wouldn't be a bad time to do that..", "author": "codefromthecrypt", "createdAt": "2020-04-01T05:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3NzQ0Ng==", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401377446", "bodyText": "#1134", "author": "codefromthecrypt", "createdAt": "2020-04-01T06:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjUwOA=="}], "type": "inlineReview"}, {"oid": "63033a81b5ba02c2d60eacf1851672020ed10b7a", "url": "https://github.com/openzipkin/brave/commit/63033a81b5ba02c2d60eacf1851672020ed10b7a", "message": "feedback", "committedDate": "2020-04-01T05:58:38Z", "type": "forcePushed"}, {"oid": "82c81817ed490b0f4e16760bd62fbce33540eeb7", "url": "https://github.com/openzipkin/brave/commit/82c81817ed490b0f4e16760bd62fbce33540eeb7", "message": "Adds Tag, Tags and HttpTags\n\nThis adds a long overdue feature to ease support of tagging spans. `Tag`\nbakes in all logic needed to add a tag to a `Span`, `ScopedSpan`,\n`SpanCustomizer` or `MutableSpan` leaving the user left only to decide\nwhat the key is and how to parse it.\n\nThis also takes care of error handling and obviation of parsing into a\nno-op span.\n\nHere's an example of a potentially expensive tag:\n```java\nSUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n  @Override protected String parseValue(Summarizer input, TraceContext context) {\n    return input.computeSummary();\n  }\n}\n\n// This works for any variant of span\nSUMMARY_TAG.tag(summarizer, span);\n```\n\nWe need to solve a common case for `BaggageField` which is to add that\nas a span tag. This is the best time to fix this problem.\n\nThe closest type we have is `ErrorParser` as that does a similar\ndispatch. Externally, the closest is [OpenTracing Tag](https://github.com/opentracing/opentracing-java/blob/master/opentracing-api/src/main/java/io/opentracing/tag/Tag.java).\n\nOur approach is different notably as we seal everything except how to\nparse the value. This helps avoid leaking exceptions or accidentally\nadding null values.", "committedDate": "2020-04-01T06:38:49Z", "type": "commit"}, {"oid": "43119912aa9f69a78251eb0fd5109d8ac4a5b9ac", "url": "https://github.com/openzipkin/brave/commit/43119912aa9f69a78251eb0fd5109d8ac4a5b9ac", "message": "feedback", "committedDate": "2020-04-01T06:43:53Z", "type": "commit"}, {"oid": "43119912aa9f69a78251eb0fd5109d8ac4a5b9ac", "url": "https://github.com/openzipkin/brave/commit/43119912aa9f69a78251eb0fd5109d8ac4a5b9ac", "message": "feedback", "committedDate": "2020-04-01T06:43:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM4OTMwMg==", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401389302", "bodyText": "I left these overloads to help reduce branching to get noop", "author": "codefromthecrypt", "createdAt": "2020-04-01T06:45:38Z", "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return The result to add as a span tag. {@code null} means no tag will be added. Note: empty\n+   * string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * Tags the value parsed from the {@code input}.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, ScopedSpan span) {", "originalCommit": "43119912aa9f69a78251eb0fd5109d8ac4a5b9ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}