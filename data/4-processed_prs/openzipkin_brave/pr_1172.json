{"pr_number": 1172, "pr_title": "Refreshes main README about Request tracing", "pr_createdAt": "2020-04-25T12:14:07Z", "pr_url": "https://github.com/openzipkin/brave/pull/1172", "timeline": [{"oid": "c0470c589b9333bc80c972de8115869cf95682c2", "url": "https://github.com/openzipkin/brave/commit/c0470c589b9333bc80c972de8115869cf95682c2", "message": "Refreshes main README about Request tracing\n\nThis attempts to clarify the main README to reduce grief for folks who read it.\nParticularly, sometimes we get people modeling different things, such as local\nactivity or long-lived connections as CLIENT spans.\n\nSee https://github.com/openzipkin/zipkin-support/issues/2", "committedDate": "2020-04-25T12:12:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA2OTQ3MQ==", "url": "https://github.com/openzipkin/brave/pull/1172#discussion_r415069471", "bodyText": "i would move this block above 'once you model your request'", "author": "jorgheymans", "createdAt": "2020-04-25T14:04:47Z", "path": "brave/README.md", "diffHunk": "@@ -167,37 +167,59 @@ void userCode() {\n }\n ```\n \n-### RPC tracing\n+### Request tracing\n Check for [instrumentation written here](../instrumentation/) and [Zipkin's list](https://zipkin.io/pages/existing_instrumentations.html)\n-before rolling your own RPC instrumentation!\n-\n-RPC tracing is often done automatically by interceptors. Under the scenes,\n-they add tags and events that relate to their role in an RPC operation.\n-\n-Note: this is intentionally not an HTTP example, as we have [a special layer](../instrumentation/http)\n-for that.\n-\n-Here's an example of a client span:\n-```java\n-// before you send a request, add metadata that describes the operation\n-span = tracer.nextSpan().name(service + \"/\" + method).kind(CLIENT);\n-span.tag(\"myrpc.version\", \"1.0.0\");\n-span.remoteServiceName(\"backend\");\n-span.remoteIpAndPort(\"172.3.4.1\", 8108);\n-\n-// Add the trace context to the request, so it can be propagated in-band\n-tracing.propagation().injector(Request::addHeader)\n-                     .inject(span.context(), request);\n-\n-// when the request is scheduled, start the span\n+before rolling your own Request instrumentation!\n+\n+Brave includes two fundamental types to support tracing interprocess\n+communication `brave.Request` and `brave.Response`. These types represent the\n+following communication patterns, defined by the [Zipkin Api][https://zipkin.io/zipkin-api/#/default/post_spans]\n+and returned by `spanKind()`:\n+\n+ * CLIENT\n+ * SERVER\n+ * PRODUCER\n+ * CONSUMER\n+\n+Once you model your request, you generally need to...\n+1. Start the span and add trace headers to the request\n+2. Put the span in scope so things like log integration works\n+3. Invoke the request\n+4. Catch any errors\n+5. Complete the span\n+\n+Here's a simplified example:\n+```java\n+requestWrapper = new ClientRequestWrapper(request);\n+span = tracer.nextSpan(sampler, requestWrapper); // 1.\n+tracing.propagation().injector(ClientRequestWrapper::addHeader)\n+                     .inject(span.context(), requestWrapper);\n+span.kind(request.spanKind());\n+span.name(\"Report\");\n span.start();\n+try (Scope ws = currentTraceContext.newScope(span.context())) { // 2.\n+  return invoke(request); // 3.\n+} catch (Throwable e) {\n+  span.error(error); // 4.\n+  throw e;\n+} finally {\n+  span.finish(); // 5.\n+}\n+```\n \n-// if there is an error, tag the span\n-span.tag(\"error\", error.getCode());\n+The above code is example only. Abstractions exist that handle aspects\n+including sampling, header processing and data parsing:\n+ * [HTTP](../instrumentation/http/README.md) is CLIENT/SERVER\n+ * [Messaging](../instrumentation/rpc/README.md) is PRODUCER/CONSUMER\n+ * [RPC](../instrumentation/rpc/README.md) is CLIENT/SERVER\n \n-// when the response is complete, finish the span\n-span.finish();\n-```\n+You should use these abstractions instead of modeling your own, as there are\n+modeling gotchas that might not be intuitive at first. For example, a common\n+mistake is using CLIENT kind for long lived connections such as database pools\n+or chat sessions. Doing so, however, can result in confusing data, such as\n+incorrect service diagrams or server calls being attached to the wrong trace.\n+If you have doubts, please chat with a maintainer on [Gitter](https://gitter.im/openzipkin/zipkin]\n+as it might save you grief later!", "originalCommit": "c0470c589b9333bc80c972de8115869cf95682c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA2OTU5OA==", "url": "https://github.com/openzipkin/brave/pull/1172#discussion_r415069598", "bodyText": "\"If you really think that the existing abstractions do not match your need, and you want to model your request yourself, you generally ....\"", "author": "jorgheymans", "createdAt": "2020-04-25T14:05:38Z", "path": "brave/README.md", "diffHunk": "@@ -167,37 +167,59 @@ void userCode() {\n }\n ```\n \n-### RPC tracing\n+### Request tracing\n Check for [instrumentation written here](../instrumentation/) and [Zipkin's list](https://zipkin.io/pages/existing_instrumentations.html)\n-before rolling your own RPC instrumentation!\n-\n-RPC tracing is often done automatically by interceptors. Under the scenes,\n-they add tags and events that relate to their role in an RPC operation.\n-\n-Note: this is intentionally not an HTTP example, as we have [a special layer](../instrumentation/http)\n-for that.\n-\n-Here's an example of a client span:\n-```java\n-// before you send a request, add metadata that describes the operation\n-span = tracer.nextSpan().name(service + \"/\" + method).kind(CLIENT);\n-span.tag(\"myrpc.version\", \"1.0.0\");\n-span.remoteServiceName(\"backend\");\n-span.remoteIpAndPort(\"172.3.4.1\", 8108);\n-\n-// Add the trace context to the request, so it can be propagated in-band\n-tracing.propagation().injector(Request::addHeader)\n-                     .inject(span.context(), request);\n-\n-// when the request is scheduled, start the span\n+before rolling your own Request instrumentation!\n+\n+Brave includes two fundamental types to support tracing interprocess\n+communication `brave.Request` and `brave.Response`. These types represent the\n+following communication patterns, defined by the [Zipkin Api][https://zipkin.io/zipkin-api/#/default/post_spans]\n+and returned by `spanKind()`:\n+\n+ * CLIENT\n+ * SERVER\n+ * PRODUCER\n+ * CONSUMER\n+\n+Once you model your request, you generally need to...", "originalCommit": "c0470c589b9333bc80c972de8115869cf95682c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5OTg4OA==", "url": "https://github.com/openzipkin/brave/pull/1172#discussion_r415199888", "bodyText": "Wrong href", "author": "anuraaga", "createdAt": "2020-04-26T03:08:54Z", "path": "brave/README.md", "diffHunk": "@@ -167,37 +167,59 @@ void userCode() {\n }\n ```\n \n-### RPC tracing\n+### Request tracing\n Check for [instrumentation written here](../instrumentation/) and [Zipkin's list](https://zipkin.io/pages/existing_instrumentations.html)\n-before rolling your own RPC instrumentation!\n-\n-RPC tracing is often done automatically by interceptors. Under the scenes,\n-they add tags and events that relate to their role in an RPC operation.\n-\n-Note: this is intentionally not an HTTP example, as we have [a special layer](../instrumentation/http)\n-for that.\n-\n-Here's an example of a client span:\n-```java\n-// before you send a request, add metadata that describes the operation\n-span = tracer.nextSpan().name(service + \"/\" + method).kind(CLIENT);\n-span.tag(\"myrpc.version\", \"1.0.0\");\n-span.remoteServiceName(\"backend\");\n-span.remoteIpAndPort(\"172.3.4.1\", 8108);\n-\n-// Add the trace context to the request, so it can be propagated in-band\n-tracing.propagation().injector(Request::addHeader)\n-                     .inject(span.context(), request);\n-\n-// when the request is scheduled, start the span\n+before rolling your own Request instrumentation!\n+\n+Brave includes two fundamental types to support tracing interprocess\n+communication `brave.Request` and `brave.Response`. These types represent the\n+following communication patterns, defined by the [Zipkin Api][https://zipkin.io/zipkin-api/#/default/post_spans]\n+and returned by `spanKind()`:\n+\n+ * CLIENT\n+ * SERVER\n+ * PRODUCER\n+ * CONSUMER\n+\n+Once you model your request, you generally need to...\n+1. Start the span and add trace headers to the request\n+2. Put the span in scope so things like log integration works\n+3. Invoke the request\n+4. Catch any errors\n+5. Complete the span\n+\n+Here's a simplified example:\n+```java\n+requestWrapper = new ClientRequestWrapper(request);\n+span = tracer.nextSpan(sampler, requestWrapper); // 1.\n+tracing.propagation().injector(ClientRequestWrapper::addHeader)\n+                     .inject(span.context(), requestWrapper);\n+span.kind(request.spanKind());\n+span.name(\"Report\");\n span.start();\n+try (Scope ws = currentTraceContext.newScope(span.context())) { // 2.\n+  return invoke(request); // 3.\n+} catch (Throwable e) {\n+  span.error(error); // 4.\n+  throw e;\n+} finally {\n+  span.finish(); // 5.\n+}\n+```\n \n-// if there is an error, tag the span\n-span.tag(\"error\", error.getCode());\n+The above code is example only. Abstractions exist that handle aspects\n+including sampling, header processing and data parsing:\n+ * [HTTP](../instrumentation/http/README.md) is CLIENT/SERVER\n+ * [Messaging](../instrumentation/rpc/README.md) is PRODUCER/CONSUMER", "originalCommit": "c0470c589b9333bc80c972de8115869cf95682c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTIwNDE1Nw==", "url": "https://github.com/openzipkin/brave/pull/1172#discussion_r415204157", "bodyText": "thx fixed in latest.  I realized we repeated a lot of this in the instrumentation README!", "author": "codefromthecrypt", "createdAt": "2020-04-26T03:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5OTg4OA=="}], "type": "inlineReview"}, {"oid": "e5f2b81226dc35957e60cd2e3904431a3e750beb", "url": "https://github.com/openzipkin/brave/commit/e5f2b81226dc35957e60cd2e3904431a3e750beb", "message": "big reorg", "committedDate": "2020-04-26T03:36:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTIwNDM5Nw==", "url": "https://github.com/openzipkin/brave/pull/1172#discussion_r415204397", "bodyText": "@anuraaga this bud's for you", "author": "codefromthecrypt", "createdAt": "2020-04-26T03:38:32Z", "path": "instrumentation/README.md", "diffHunk": "@@ -95,14 +95,52 @@ We worked very hard to make writing new instrumentation easy and efficient.\n Most of our built-in instrumentation are 50-100 lines of code, yet allow\n flexible configuration of tags and sampling policy.\n \n-If you need to write new http instrumentation, check [our docs](http/README.md),\n-as this shows how to write it in a way that is least effort for you and\n-easy for others to configure. For example, we have a standard [test suite](http-tests)\n-you can use to make sure things interop, and standard configuration works.\n-\n-If you need to do something not http, you'll want to use our [tracer library](../brave/README.md).\n-If you are in this position, you may find our [feature tests](../brave/src/test/java/brave/features)\n-helpful.\n-\n-Regardless, you may need support along the way. Please reach out on [gitter](https://gitter.im/openzipkin/zipkin),\n-as there's usually others around to help.\n+Brave includes two fundamental types to support tracing interprocess\n+communication `brave.Request` and `brave.Response`. These types represent the\n+following communication patterns, defined by the [Zipkin Api][https://zipkin.io/zipkin-api/#/default/post_spans]\n+and returned by `spanKind()`:\n+\n+ * CLIENT\n+ * SERVER\n+ * PRODUCER\n+ * CONSUMER\n+\n+Brave includes abstractions for the above that handle aspects including\n+sampling, header processing and data parsing:\n+ * [HTTP](http/README.md) is CLIENT/SERVER\n+ * [Messaging](messaging/README.md) is PRODUCER/CONSUMER\n+ * [RPC](rpc/README.md) is CLIENT/SERVER\n+\n+You should use these abstractions instead of modeling your own. Not only are\n+they well thought through, but they also include tests to prevent common\n+mistakes. For example, [HTTP tests](http-tests) makes sure spans are modeled\n+consistently and uniform configuration works.\n+\n+Using abstractions also helps avoid modeling gotchas that might not be\n+intuitive at first.\n+\n+For example, a common mistake is using CLIENT kind for long lived connections\n+such as database pools or chat sessions. Doing so, however, can result in\n+confusing data, such as incorrect service diagrams or server calls being\n+attached to the wrong trace.\n+\n+It is also a common misconception that a grouping of CLIENT spans should itself", "originalCommit": "e5f2b81226dc35957e60cd2e3904431a3e750beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTIwNDUzNg==", "url": "https://github.com/openzipkin/brave/pull/1172#discussion_r415204536", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            documented, that might prefer. Moreover, folks usually want support and we\n          \n          \n            \n            documented, you might prefer. Moreover, folks usually want support and we", "author": "codefromthecrypt", "createdAt": "2020-04-26T03:39:27Z", "path": "instrumentation/README.md", "diffHunk": "@@ -95,14 +95,52 @@ We worked very hard to make writing new instrumentation easy and efficient.\n Most of our built-in instrumentation are 50-100 lines of code, yet allow\n flexible configuration of tags and sampling policy.\n \n-If you need to write new http instrumentation, check [our docs](http/README.md),\n-as this shows how to write it in a way that is least effort for you and\n-easy for others to configure. For example, we have a standard [test suite](http-tests)\n-you can use to make sure things interop, and standard configuration works.\n-\n-If you need to do something not http, you'll want to use our [tracer library](../brave/README.md).\n-If you are in this position, you may find our [feature tests](../brave/src/test/java/brave/features)\n-helpful.\n-\n-Regardless, you may need support along the way. Please reach out on [gitter](https://gitter.im/openzipkin/zipkin),\n-as there's usually others around to help.\n+Brave includes two fundamental types to support tracing interprocess\n+communication `brave.Request` and `brave.Response`. These types represent the\n+following communication patterns, defined by the [Zipkin Api][https://zipkin.io/zipkin-api/#/default/post_spans]\n+and returned by `spanKind()`:\n+\n+ * CLIENT\n+ * SERVER\n+ * PRODUCER\n+ * CONSUMER\n+\n+Brave includes abstractions for the above that handle aspects including\n+sampling, header processing and data parsing:\n+ * [HTTP](http/README.md) is CLIENT/SERVER\n+ * [Messaging](messaging/README.md) is PRODUCER/CONSUMER\n+ * [RPC](rpc/README.md) is CLIENT/SERVER\n+\n+You should use these abstractions instead of modeling your own. Not only are\n+they well thought through, but they also include tests to prevent common\n+mistakes. For example, [HTTP tests](http-tests) makes sure spans are modeled\n+consistently and uniform configuration works.\n+\n+Using abstractions also helps avoid modeling gotchas that might not be\n+intuitive at first.\n+\n+For example, a common mistake is using CLIENT kind for long lived connections\n+such as database pools or chat sessions. Doing so, however, can result in\n+confusing data, such as incorrect service diagrams or server calls being\n+attached to the wrong trace.\n+\n+It is also a common misconception that a grouping of CLIENT spans should itself\n+be a CLIENT span. A logical span that serves only to group others, is a local\n+span (Span.kind() is unset). CLIENT spans represent a single remote request. It\n+is relatively common to use a local span as the parent of multiple CLIENT\n+requests, or to represent a single request that was served from a local cache.\n+\n+Some features that already exist are subtle, yet proven with tests. It is best\n+to look for tests in the \"features\" package before deciding something doesn't\n+work.\n+* [Core feature tests](../brave/src/test/java/brave/features)\n+* [HTTP feature tests](http-tests/src/test/java/brave/http/features)\n+* [Messaging feature tests](messaging/src/test/java/brave/rpc/features)\n+* [RPC feature tests](rpc/src/test/java/brave/rpc/features)\n+\n+If you end up in a position where you still believe you need a custom model,\n+please contact us before committing to it. There may be an alternative not yet\n+documented, that might prefer. Moreover, folks usually want support and we", "originalCommit": "e5f2b81226dc35957e60cd2e3904431a3e750beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5eb19c516be2e57411236384138d8ef612b35917", "url": "https://github.com/openzipkin/brave/commit/5eb19c516be2e57411236384138d8ef612b35917", "message": "you", "committedDate": "2020-04-26T03:39:33Z", "type": "commit"}]}