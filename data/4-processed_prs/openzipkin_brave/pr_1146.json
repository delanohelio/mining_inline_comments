{"pr_number": 1146, "pr_title": "Adds an example about counting children", "pr_createdAt": "2020-04-10T07:04:18Z", "pr_url": "https://github.com/openzipkin/brave/pull/1146", "timeline": [{"oid": "bb32d51233d05c1aebc28389b90f0c058616c3f5", "url": "https://github.com/openzipkin/brave/commit/bb32d51233d05c1aebc28389b90f0c058616c3f5", "message": "Adds an example about counting children\n\nThose who need to process statistics on children can do something\nlike this, which works for any instrumentation.\n\nRequested by @fletch3555", "committedDate": "2020-04-10T07:03:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzNjA3MQ==", "url": "https://github.com/openzipkin/brave/pull/1146#discussion_r406636071", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * <p><em>Note:</em> this currently only works with children enclosed by their parents. If you have\n          \n          \n            \n             * <p><em>Note:</em> this currently only works with children fully enclosed by their parents. If you have\n          \n      \n    \n    \n  \n\nVery small suggestion that I think makes it quite a bit more readable.", "author": "anuraaga", "createdAt": "2020-04-10T07:17:29Z", "path": "brave/src/test/java/brave/features/handler/CountingChildrenTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.Tracer;\n+import brave.Tracing;\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.After;\n+import org.junit.Test;\n+import zipkin2.Span;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.tuple;\n+\n+/**\n+ * This shows how a {@link FinishedSpanHandler} can add data some external formats need, such as\n+ * child count.\n+ *\n+ * <p><em>Note:</em> this currently only works with children enclosed by their parents. If you have", "originalCommit": "bb32d51233d05c1aebc28389b90f0c058616c3f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzOTA1OQ==", "url": "https://github.com/openzipkin/brave/pull/1146#discussion_r406639059", "bodyText": "A bit less noisy, and easier to switch to a possibly more efficient structure, using Collections.synchronizedMap instead of synchronizing the methods.", "author": "anuraaga", "createdAt": "2020-04-10T07:26:41Z", "path": "brave/src/test/java/brave/features/handler/FinishedChildrenHandler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.propagation.TraceContext;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+\n+import static java.util.Collections.emptyList;\n+\n+public abstract class FinishedChildrenHandler extends FinishedSpanHandler {\n+\n+  protected abstract void handle(MutableSpan parent, Iterable<MutableSpan> children);\n+\n+  /** This holds the children of the current parent until the former is finished or abandoned. */\n+  final ParentToChildren parentToChildren = new ParentToChildren();\n+\n+  @Override public boolean supportsOrphans() {\n+    return true; // We need to clear the map entry even if the parent doesn't finish normally\n+  }\n+\n+  @Override public boolean handle(TraceContext context, MutableSpan span) {\n+    if (!context.isLocalRoot()) { // a child\n+      parentToChildren.add(context.parentIdString(), span);\n+    }\n+\n+    Iterable<MutableSpan> children = parentToChildren.remove(context.spanIdString());\n+\n+    FinishedChildrenHandler.this.handle(span, children != null ? children : emptyList());\n+    return true;\n+  }\n+\n+  static final class ParentToChildren {\n+    final Map<String, Set<MutableSpan>> delegate = new WeakHashMap<>();", "originalCommit": "bb32d51233d05c1aebc28389b90f0c058616c3f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5NTI2Nw==", "url": "https://github.com/openzipkin/brave/pull/1146#discussion_r406695267", "bodyText": "yeah better!", "author": "codefromthecrypt", "createdAt": "2020-04-10T10:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzOTA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzOTMzNw==", "url": "https://github.com/openzipkin/brave/pull/1146#discussion_r406639337", "bodyText": "Wonder if we should go ahead and copy into another list when passing to handler.", "author": "anuraaga", "createdAt": "2020-04-10T07:27:37Z", "path": "brave/src/test/java/brave/features/handler/FinishedChildrenHandler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.propagation.TraceContext;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+\n+import static java.util.Collections.emptyList;\n+\n+public abstract class FinishedChildrenHandler extends FinishedSpanHandler {\n+\n+  protected abstract void handle(MutableSpan parent, Iterable<MutableSpan> children);\n+\n+  /** This holds the children of the current parent until the former is finished or abandoned. */\n+  final ParentToChildren parentToChildren = new ParentToChildren();\n+\n+  @Override public boolean supportsOrphans() {\n+    return true; // We need to clear the map entry even if the parent doesn't finish normally\n+  }\n+\n+  @Override public boolean handle(TraceContext context, MutableSpan span) {\n+    if (!context.isLocalRoot()) { // a child\n+      parentToChildren.add(context.parentIdString(), span);\n+    }\n+\n+    Iterable<MutableSpan> children = parentToChildren.remove(context.spanIdString());", "originalCommit": "bb32d51233d05c1aebc28389b90f0c058616c3f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5Mzk5MA==", "url": "https://github.com/openzipkin/brave/pull/1146#discussion_r406693990", "bodyText": "I guess I'm confusing things by being inconsistent. I intentionally used synchronized above because we don't have a better collection type at the moment. That isn't not good for performance, so me avoiding array allocation here is probably not intuitive.\nIn real code I'd probably not do that, as it is possibly going to happen inline with a random call to Span.finish (time is stolen to invoke this hook). I'd probably prefer exposing Iterator instead..", "author": "codefromthecrypt", "createdAt": "2020-04-10T10:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzOTMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5NjU0OA==", "url": "https://github.com/openzipkin/brave/pull/1146#discussion_r406696548", "bodyText": "updated with some notes on why.. ack allocation defence it is unimportant with how it is currently implemented though.", "author": "codefromthecrypt", "createdAt": "2020-04-10T10:14:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzOTMzNw=="}], "type": "inlineReview"}, {"oid": "8d3eff66eeda9eff9e895c1f8afa83293940e941", "url": "https://github.com/openzipkin/brave/commit/8d3eff66eeda9eff9e895c1f8afa83293940e941", "message": "Update brave/src/test/java/brave/features/handler/CountingChildrenTest.java\n\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-04-10T10:02:24Z", "type": "commit"}, {"oid": "dacdf39d48dc93e607203490808e8926cc7b2f68", "url": "https://github.com/openzipkin/brave/commit/dacdf39d48dc93e607203490808e8926cc7b2f68", "message": "polish", "committedDate": "2020-04-10T10:14:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5ODE0MA==", "url": "https://github.com/openzipkin/brave/pull/1146#discussion_r406698140", "bodyText": "@anuraaga actually in this impl we could probably pass control to the user.. just anyway I want to get the other hooks in before we do that, just in case in a concurrent weak map variant, we can't give such a thing.", "author": "codefromthecrypt", "createdAt": "2020-04-10T10:19:48Z", "path": "brave/src/test/java/brave/features/handler/FinishedChildrenHandler.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.propagation.TraceContext;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+\n+import static java.util.Collections.emptyIterator;\n+import static java.util.Collections.synchronizedMap;\n+\n+public abstract class FinishedChildrenHandler extends FinishedSpanHandler {\n+\n+  protected abstract void handle(MutableSpan parent, Iterator<MutableSpan> children);\n+\n+  /** This holds the children of the current parent until the former is finished or abandoned. */\n+  final ParentToChildren parentToChildren = new ParentToChildren();\n+\n+  @Override public boolean handle(TraceContext context, MutableSpan span) {\n+    if (!context.isLocalRoot()) { // a child\n+      parentToChildren.add(context.parentIdString(), span);\n+    }\n+\n+    // There could be a lot of children. Instead of copying the list result, expose the iterator.\n+    // The main goal is to not add too much overhead as this is invoked on the same thread as\n+    // application code which implicitly call Span.finish() through instrumentation.\n+    Set<MutableSpan> children = parentToChildren.remove(context.spanIdString());", "originalCommit": "dacdf39d48dc93e607203490808e8926cc7b2f68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}