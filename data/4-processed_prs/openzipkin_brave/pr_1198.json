{"pr_number": 1198, "pr_title": "Ports brave core tests to MutableSpan", "pr_createdAt": "2020-05-10T02:14:53Z", "pr_url": "https://github.com/openzipkin/brave/pull/1198", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU3Mjc1OQ==", "url": "https://github.com/openzipkin/brave/pull/1198#discussion_r422572759", "bodyText": "this is a preview of what will be in brave-tests. The \"reporter\" which was there will be renamed to IntegrationTestSpanHandler", "author": "codefromthecrypt", "createdAt": "2020-05-10T02:15:40Z", "path": "brave/src/test/java/brave/test/TestSpanHandler.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package brave.test;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanHandler;\n+import brave.propagation.TraceContext;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+// copy of what's in brave-tests\n+public final class TestSpanHandler extends SpanHandler implements Iterable<MutableSpan> {", "originalCommit": "5fca258f6a83a62e2cb173d9ea6da790c00ad36d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5fca258f6a83a62e2cb173d9ea6da790c00ad36d", "url": "https://github.com/openzipkin/brave/commit/5fca258f6a83a62e2cb173d9ea6da790c00ad36d", "message": "Ports brave core tests to MutableSpan", "committedDate": "2020-05-10T02:15:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU3Mjc3Ng==", "url": "https://github.com/openzipkin/brave/pull/1198#discussion_r422572776", "bodyText": "this is a zipkin concept so no longer relevant", "author": "codefromthecrypt", "createdAt": "2020-05-10T02:16:08Z", "path": "brave/src/test/java/brave/internal/recorder/PendingSpansTest.java", "diffHunk": "@@ -133,21 +126,22 @@ public void remove_doesntReport() {\n   public void reportOrphanedSpans_afterGC() {\n     TraceContext context1 = context.toBuilder().traceId(1).spanId(1).build();\n     PendingSpan span = pendingSpans.getOrCreate(null, context1, false);\n-    span.span.name(\"foo\");\n+    span.span.tag(\"foo\", \"bar\");\n+    span.span.tag(\"ice\", \"melt\");\n+\n+    // Prove that copy constructor doesn't pin GC\n+    MutableSpan copyOfData = new MutableSpan(span.span);\n     span = null; // clear reference so GC occurs\n+\n     TraceContext context2 = context.toBuilder().traceId(2).spanId(2).build();\n     pendingSpans.getOrCreate(null, context2, false);\n     TraceContext context3 = context.toBuilder().traceId(3).spanId(3).build();\n     pendingSpans.getOrCreate(null, context3, false);\n     TraceContext context4 = context.toBuilder().traceId(4).spanId(4).build();\n     pendingSpans.getOrCreate(null, context4, false);\n-    // ensure sampled local spans are not reported when orphaned unless they are also sampled remote", "originalCommit": "5fca258f6a83a62e2cb173d9ea6da790c00ad36d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU3MjgxNg==", "url": "https://github.com/openzipkin/brave/pull/1198#discussion_r422572816", "bodyText": "not worth the dependency, we can assume this", "author": "codefromthecrypt", "createdAt": "2020-05-10T02:16:41Z", "path": "brave/src/test/java/brave/features/handler/SkeletalSpansTest.java", "diffHunk": "@@ -120,39 +103,13 @@\n       );\n \n     assertThat(skeletalSpans.values())\n-      .extracting(s -> s.stream().map(zipkin2.Span::name).collect(Collectors.toList()))\n+      .extracting(s -> s.stream().map(MutableSpan::name).collect(Collectors.toList()))\n       .containsExactly(\n         asList(\"post\", \"post\", \"get\"),\n         asList(\"post\", \"post\", \"post\", \"get\")\n       );\n   }\n \n-  @Test public void skeletalSpans_produceSameServiceGraph() {", "originalCommit": "5fca258f6a83a62e2cb173d9ea6da790c00ad36d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU3Mjg2OA==", "url": "https://github.com/openzipkin/brave/pull/1198#discussion_r422572868", "bodyText": "a lot of tests will drift like this, but it is good as it proves brave doesn't meddle with case format even though our zipkin handler does.", "author": "codefromthecrypt", "createdAt": "2020-05-10T02:17:30Z", "path": "brave/src/test/java/brave/features/handler/CountingChildrenTest.java", "diffHunk": "@@ -136,12 +135,12 @@ public boolean begin(TraceContext context, MutableSpan span, @Nullable TraceCont\n     assertThat(nameToChildCount)\n       .isEqualTo(nameToChildCountDirect)\n       .containsExactly(\n-        tuple(\"root1child1child2child1\", \"0\"),\n-        tuple(\"root2child1\", \"0\"),\n-        tuple(\"root1child1child1\", \"1\"),\n+        tuple(\"root1Child1Child2Child1\", \"0\"),", "originalCommit": "5fca258f6a83a62e2cb173d9ea6da790c00ad36d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU3MjkzOA==", "url": "https://github.com/openzipkin/brave/pull/1198#discussion_r422572938", "bodyText": "not a bug, just MutableSpan is timestamps not timestamp,duration", "author": "codefromthecrypt", "createdAt": "2020-05-10T02:18:13Z", "path": "brave/src/test/java/brave/TracerTest.java", "diffHunk": "@@ -187,27 +180,27 @@\n    * other for the server.\n    */\n   @Test public void join_sharedDataIsSeparate() {\n-    Span clientSide = tracer.newTrace().kind(Kind.CLIENT).start(1L);\n-    Span serverSide = tracer.joinSpan(clientSide.context()).kind(Kind.SERVER).start(2L);\n+    Span clientSide = tracer.newTrace().kind(CLIENT).start(1L);\n+    Span serverSide = tracer.joinSpan(clientSide.context()).kind(SERVER).start(2L);\n     serverSide.finish(3L);\n     clientSide.finish(4L);\n \n     // Ensure they use the same span ID (sanity check)\n     String spanId = spans.get(0).id();\n-    assertThat(spans).extracting(zipkin2.Span::id)\n+    assertThat(spans).extracting(MutableSpan::id)\n       .containsExactly(spanId, spanId);\n \n     // Ensure the important parts are separated correctly\n     assertThat(spans).extracting(\n-      zipkin2.Span::kind, zipkin2.Span::shared, zipkin2.Span::timestamp, zipkin2.Span::duration\n+      MutableSpan::kind, MutableSpan::shared, MutableSpan::startTimestamp, MutableSpan::finishTimestamp\n     ).containsExactly(\n-      tuple(zipkin2.Span.Kind.SERVER, true, 2L, 1L),\n-      tuple(zipkin2.Span.Kind.CLIENT, null, 1L, 3L)\n+      tuple(SERVER, true, 2L, 3L),", "originalCommit": "5fca258f6a83a62e2cb173d9ea6da790c00ad36d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU3Mjk3Nw==", "url": "https://github.com/openzipkin/brave/pull/1198#discussion_r422572977", "bodyText": "some tests that did nothing with scopes had strict context, which is distracting.", "author": "codefromthecrypt", "createdAt": "2020-05-10T02:18:50Z", "path": "brave/src/test/java/brave/LazySpanTest.java", "diffHunk": "@@ -14,22 +14,17 @@\n package brave;\n \n import brave.propagation.CurrentTraceContext.Scope;\n-import brave.propagation.StrictCurrentTraceContext;\n import brave.propagation.TraceContext;\n import brave.propagation.TraceContextOrSamplingFlags;\n-import java.util.ArrayList;\n-import java.util.List;\n+import brave.test.TestSpanHandler;\n import org.junit.After;\n import org.junit.Test;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n public class LazySpanTest {\n-  List<zipkin2.Span> spans = new ArrayList<>();\n-  Tracing tracing = Tracing.newBuilder()\n-    .currentTraceContext(StrictCurrentTraceContext.create())", "originalCommit": "5fca258f6a83a62e2cb173d9ea6da790c00ad36d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}