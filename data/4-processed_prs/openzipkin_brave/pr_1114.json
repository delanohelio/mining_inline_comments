{"pr_number": 1114, "pr_title": "Fixes bugs in B3 single parsing and completes coverage", "pr_createdAt": "2020-03-13T05:05:07Z", "pr_url": "https://github.com/openzipkin/brave/pull/1114", "timeline": [{"oid": "717cc2e5ddd51874b718e3fbc1c0c47b6e156852", "url": "https://github.com/openzipkin/brave/commit/717cc2e5ddd51874b718e3fbc1c0c47b6e156852", "message": "Fixes bugs in B3 single parsing and completes coverage", "committedDate": "2020-03-13T04:54:21Z", "type": "commit"}, {"oid": "5ba130facad712541ff28b581b574d355bf1cd04", "url": "https://github.com/openzipkin/brave/commit/5ba130facad712541ff28b581b574d355bf1cd04", "message": "dead", "committedDate": "2020-03-13T05:05:17Z", "type": "commit"}, {"oid": "6507edaf85ae6cc071b049c003b497fd93c215a1", "url": "https://github.com/openzipkin/brave/commit/6507edaf85ae6cc071b049c003b497fd93c215a1", "message": "copy/paste fail", "committedDate": "2020-03-13T05:07:58Z", "type": "commit"}, {"oid": "64d960ef33d2d56824adf23d976354212c54407e", "url": "https://github.com/openzipkin/brave/commit/64d960ef33d2d56824adf23d976354212c54407e", "message": "more fuzz", "committedDate": "2020-03-13T05:59:39Z", "type": "commit"}, {"oid": "6797b668ca300cd84fd533c330caf98b3b5d6796", "url": "https://github.com/openzipkin/brave/commit/6797b668ca300cd84fd533c330caf98b3b5d6796", "message": "another fuzz", "committedDate": "2020-03-13T06:01:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0MzU0Mg==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392043542", "bodyText": "the sequence isn't necessarily all lowerHex", "author": "codefromthecrypt", "createdAt": "2020-03-13T06:00:19Z", "path": "brave/src/main/java/brave/internal/HexCodec.java", "diffHunk": "@@ -33,19 +33,36 @@ public static long lowerHexToUnsignedLong(CharSequence lowerHex) {\n   /**\n    * Parses a 16 character lower-hex string with no prefix into an unsigned long, starting at the\n    * specified index.\n+   *\n+   * <p>This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a lower-hex encoded unsigned long.\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first lower-hex character representing the unsigned long.\n    */\n-  public static long lowerHexToUnsignedLong(CharSequence lowerHex, int index) {", "originalCommit": "64d960ef33d2d56824adf23d976354212c54407e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0MzY5NQ==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392043695", "bodyText": "the sequence isn't necessarily all b3 data", "author": "codefromthecrypt", "createdAt": "2020-03-13T06:00:54Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -135,106 +135,114 @@ static int writeB3SingleFormat(TraceContext context, long parentId, char[] resul\n   }\n \n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3) {\n-    return parseB3SingleFormat(b3, 0, b3.length());\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value) {\n+    return parseB3SingleFormat(value, 0, value.length());\n   }\n \n   /**\n-   * @param beginIndex the start index, inclusive\n-   * @param endIndex the end index, exclusive\n+   * This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a B3 single formatted trace context\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first character in B3 single format.\n+   * @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}\n+   * <em>after</em> the last character in B3 single format.\n    */\n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, int beginIndex,\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value, int beginIndex,", "originalCommit": "64d960ef33d2d56824adf23d976354212c54407e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0NDc2Nw==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392044767", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  pos++; // consume the delimiter\n          \n          \n            \n                  pos++; // consume the hyphen", "author": "anuraaga", "createdAt": "2020-03-13T06:05:31Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -140,101 +140,109 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3) {\n   }\n \n   /**\n-   * @param beginIndex the start index, inclusive\n-   * @param endIndex the end index, exclusive\n+   * This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a B3 single formatted trace context\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first character in B3 single format.\n+   * @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}\n+   * <em>after</em> the last character in B3 single format.\n    */\n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, int beginIndex,\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value, int beginIndex,\n     int endIndex) {\n-    if (beginIndex == endIndex) {\n-      Platform.get().log(\"Invalid input: empty\", null);\n-      return null;\n-    }\n+    int length = endIndex - beginIndex;\n \n-    int pos = beginIndex;\n-    if (pos + 1 == endIndex) { // possibly sampling flags\n-      return tryParseSamplingFlags(b3, pos);\n-    }\n-\n-    // At this point we minimally expect a traceId-spanId pair\n-    if (endIndex < 16 + 1 + 16 /* traceid64-spanid */) {\n-      Platform.get().log(\"Invalid input: truncated\", null);\n+    if (length == 0) {\n+      Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n-    } else if (endIndex > FORMAT_MAX_LENGTH) {\n+    } else if (length == 1) { // possibly sampling flags\n+      return tryParseSamplingFlags(value.charAt(beginIndex));\n+    } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // Cheaply check for only ASCII characters. This allows for more precise messages later, but\n-    // kicks out early on data such as unicode.\n+    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n+    // they need to consider, and if there are not enough or too many fields.\n+    int hyphenCount = 0;\n+    int indexOfFirstHyphen = -1;\n     for (int i = beginIndex; i < endIndex; i++) {\n-      if (b3.charAt(i) >= 128) {\n-        Platform.get().log(\"Invalid input: non-ASCII character at offset {0}\", i, null);\n+      char c = value.charAt(i);\n+      if (c == '-') {\n+        if (indexOfFirstHyphen == -1) {\n+          indexOfFirstHyphen = i;\n+        }\n+        hyphenCount++;\n+      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n+        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n         return null;\n       }\n     }\n \n-    long traceIdHigh, traceId;\n-    if (b3.charAt(pos + 32) == '-') {\n-      traceIdHigh = tryParse16HexCharacters(b3, pos, endIndex);\n-      pos += 16; // upper 64 bits of the trace ID\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    } else {\n-      traceIdHigh = 0L;\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    }\n-    pos += 16; // traceId\n-\n-    if (traceIdHigh == 0L && traceId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID at offset 0\", null);\n+    if (hyphenCount < 1) {\n+      Platform.get().log(\"Truncated reading trace ID\", null);\n       return null;\n-    }\n-\n-    if (isLowerHex(b3.charAt(pos))) {\n-      Platform.get().log(\"Invalid input: trace ID is too long\", null);\n+    } else if (hyphenCount > 3) {\n+      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n       return null;\n     }\n \n-    if (!checkHyphen(b3, pos++)) return null;\n+    int pos = beginIndex;\n \n-    long spanId = tryParse16HexCharacters(b3, pos, endIndex);\n-    if (spanId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 lower hex span ID at offset {0}\", pos, null);\n+    long traceIdHigh, traceId;\n+    int traceIdLength = indexOfFirstHyphen - beginIndex;\n+    if (traceIdLength == 32) {\n+      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n+      pos += 16; // upper 64 bits of the trace ID\n+    } else if (traceIdLength == 16) {\n+      traceIdHigh = 0L;\n+    } else {\n+      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n       return null;\n     }\n+\n+    traceId = tryParseId(\"trace\", value, pos, endIndex);\n+    if (traceId == 0) return null;\n+    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+\n+    long spanId = tryParseId(\"span\", value, pos, endIndex);\n+    if (spanId == 0) return null;\n     pos += 16; // spanid\n \n     int flags = 0;\n     long parentId = 0L;\n     if (endIndex > pos) {\n-      if (isLowerHex(b3.charAt(pos))) {\n-        Platform.get().log(\"Invalid input: span ID is too long\", null);\n+      pos++; // consume the delimiter", "originalCommit": "6797b668ca300cd84fd533c330caf98b3b5d6796", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0NjkxNg==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392046916", "bodyText": "If the precision in the error messages isn't important, it might be nice to have these checks in the validation loop above so it's all together.", "author": "anuraaga", "createdAt": "2020-03-13T06:14:47Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -140,101 +140,109 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3) {\n   }\n \n   /**\n-   * @param beginIndex the start index, inclusive\n-   * @param endIndex the end index, exclusive\n+   * This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a B3 single formatted trace context\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first character in B3 single format.\n+   * @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}\n+   * <em>after</em> the last character in B3 single format.\n    */\n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, int beginIndex,\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value, int beginIndex,\n     int endIndex) {\n-    if (beginIndex == endIndex) {\n-      Platform.get().log(\"Invalid input: empty\", null);\n-      return null;\n-    }\n+    int length = endIndex - beginIndex;\n \n-    int pos = beginIndex;\n-    if (pos + 1 == endIndex) { // possibly sampling flags\n-      return tryParseSamplingFlags(b3, pos);\n-    }\n-\n-    // At this point we minimally expect a traceId-spanId pair\n-    if (endIndex < 16 + 1 + 16 /* traceid64-spanid */) {\n-      Platform.get().log(\"Invalid input: truncated\", null);\n+    if (length == 0) {\n+      Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n-    } else if (endIndex > FORMAT_MAX_LENGTH) {\n+    } else if (length == 1) { // possibly sampling flags\n+      return tryParseSamplingFlags(value.charAt(beginIndex));\n+    } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // Cheaply check for only ASCII characters. This allows for more precise messages later, but\n-    // kicks out early on data such as unicode.\n+    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n+    // they need to consider, and if there are not enough or too many fields.\n+    int hyphenCount = 0;\n+    int indexOfFirstHyphen = -1;\n     for (int i = beginIndex; i < endIndex; i++) {\n-      if (b3.charAt(i) >= 128) {\n-        Platform.get().log(\"Invalid input: non-ASCII character at offset {0}\", i, null);\n+      char c = value.charAt(i);\n+      if (c == '-') {\n+        if (indexOfFirstHyphen == -1) {\n+          indexOfFirstHyphen = i;\n+        }\n+        hyphenCount++;\n+      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n+        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n         return null;\n       }\n     }\n \n-    long traceIdHigh, traceId;\n-    if (b3.charAt(pos + 32) == '-') {\n-      traceIdHigh = tryParse16HexCharacters(b3, pos, endIndex);\n-      pos += 16; // upper 64 bits of the trace ID\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    } else {\n-      traceIdHigh = 0L;\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    }\n-    pos += 16; // traceId\n-\n-    if (traceIdHigh == 0L && traceId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID at offset 0\", null);\n+    if (hyphenCount < 1) {\n+      Platform.get().log(\"Truncated reading trace ID\", null);\n       return null;\n-    }\n-\n-    if (isLowerHex(b3.charAt(pos))) {\n-      Platform.get().log(\"Invalid input: trace ID is too long\", null);\n+    } else if (hyphenCount > 3) {\n+      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n       return null;\n     }\n \n-    if (!checkHyphen(b3, pos++)) return null;\n+    int pos = beginIndex;\n \n-    long spanId = tryParse16HexCharacters(b3, pos, endIndex);\n-    if (spanId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 lower hex span ID at offset {0}\", pos, null);\n+    long traceIdHigh, traceId;\n+    int traceIdLength = indexOfFirstHyphen - beginIndex;\n+    if (traceIdLength == 32) {\n+      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n+      pos += 16; // upper 64 bits of the trace ID\n+    } else if (traceIdLength == 16) {\n+      traceIdHigh = 0L;\n+    } else {\n+      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n       return null;\n     }\n+\n+    traceId = tryParseId(\"trace\", value, pos, endIndex);\n+    if (traceId == 0) return null;\n+    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+\n+    long spanId = tryParseId(\"span\", value, pos, endIndex);\n+    if (spanId == 0) return null;\n     pos += 16; // spanid\n \n     int flags = 0;\n     long parentId = 0L;\n     if (endIndex > pos) {\n-      if (isLowerHex(b3.charAt(pos))) {\n-        Platform.get().log(\"Invalid input: span ID is too long\", null);\n+      pos++; // consume the delimiter\n+\n+      if (endIndex == pos) { // traceid-spanid-\n+        Platform.get().log(\"Truncated after reading span ID\", null);", "originalCommit": "6797b668ca300cd84fd533c330caf98b3b5d6796", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA3NjM5NQ==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392076395", "bodyText": "think we're good here.. only a small loosening made a lot of things possible. good idea", "author": "codefromthecrypt", "createdAt": "2020-03-13T07:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0NjkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0NzYzMw==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392047633", "bodyText": "My mind is being blown by nextChar and nextPos not being the same position here. Is it possible to remove nextPos for readability?", "author": "anuraaga", "createdAt": "2020-03-13T06:17:43Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -140,101 +140,109 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3) {\n   }\n \n   /**\n-   * @param beginIndex the start index, inclusive\n-   * @param endIndex the end index, exclusive\n+   * This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a B3 single formatted trace context\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first character in B3 single format.\n+   * @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}\n+   * <em>after</em> the last character in B3 single format.\n    */\n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, int beginIndex,\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value, int beginIndex,\n     int endIndex) {\n-    if (beginIndex == endIndex) {\n-      Platform.get().log(\"Invalid input: empty\", null);\n-      return null;\n-    }\n+    int length = endIndex - beginIndex;\n \n-    int pos = beginIndex;\n-    if (pos + 1 == endIndex) { // possibly sampling flags\n-      return tryParseSamplingFlags(b3, pos);\n-    }\n-\n-    // At this point we minimally expect a traceId-spanId pair\n-    if (endIndex < 16 + 1 + 16 /* traceid64-spanid */) {\n-      Platform.get().log(\"Invalid input: truncated\", null);\n+    if (length == 0) {\n+      Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n-    } else if (endIndex > FORMAT_MAX_LENGTH) {\n+    } else if (length == 1) { // possibly sampling flags\n+      return tryParseSamplingFlags(value.charAt(beginIndex));\n+    } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // Cheaply check for only ASCII characters. This allows for more precise messages later, but\n-    // kicks out early on data such as unicode.\n+    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n+    // they need to consider, and if there are not enough or too many fields.\n+    int hyphenCount = 0;\n+    int indexOfFirstHyphen = -1;\n     for (int i = beginIndex; i < endIndex; i++) {\n-      if (b3.charAt(i) >= 128) {\n-        Platform.get().log(\"Invalid input: non-ASCII character at offset {0}\", i, null);\n+      char c = value.charAt(i);\n+      if (c == '-') {\n+        if (indexOfFirstHyphen == -1) {\n+          indexOfFirstHyphen = i;\n+        }\n+        hyphenCount++;\n+      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n+        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n         return null;\n       }\n     }\n \n-    long traceIdHigh, traceId;\n-    if (b3.charAt(pos + 32) == '-') {\n-      traceIdHigh = tryParse16HexCharacters(b3, pos, endIndex);\n-      pos += 16; // upper 64 bits of the trace ID\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    } else {\n-      traceIdHigh = 0L;\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    }\n-    pos += 16; // traceId\n-\n-    if (traceIdHigh == 0L && traceId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID at offset 0\", null);\n+    if (hyphenCount < 1) {\n+      Platform.get().log(\"Truncated reading trace ID\", null);\n       return null;\n-    }\n-\n-    if (isLowerHex(b3.charAt(pos))) {\n-      Platform.get().log(\"Invalid input: trace ID is too long\", null);\n+    } else if (hyphenCount > 3) {\n+      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n       return null;\n     }\n \n-    if (!checkHyphen(b3, pos++)) return null;\n+    int pos = beginIndex;\n \n-    long spanId = tryParse16HexCharacters(b3, pos, endIndex);\n-    if (spanId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 lower hex span ID at offset {0}\", pos, null);\n+    long traceIdHigh, traceId;\n+    int traceIdLength = indexOfFirstHyphen - beginIndex;\n+    if (traceIdLength == 32) {\n+      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n+      pos += 16; // upper 64 bits of the trace ID\n+    } else if (traceIdLength == 16) {\n+      traceIdHigh = 0L;\n+    } else {\n+      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n       return null;\n     }\n+\n+    traceId = tryParseId(\"trace\", value, pos, endIndex);\n+    if (traceId == 0) return null;\n+    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+\n+    long spanId = tryParseId(\"span\", value, pos, endIndex);\n+    if (spanId == 0) return null;\n     pos += 16; // spanid\n \n     int flags = 0;\n     long parentId = 0L;\n     if (endIndex > pos) {\n-      if (isLowerHex(b3.charAt(pos))) {\n-        Platform.get().log(\"Invalid input: span ID is too long\", null);\n+      pos++; // consume the delimiter\n+\n+      if (endIndex == pos) { // traceid-spanid-\n+        Platform.get().log(\"Truncated after reading span ID\", null);\n         return null;\n       }\n \n-      // If we are at this point, we have more than just traceId-spanId.\n-      // If the sampling field is present, we'll have a delimiter 2 characters from now. Ex \"-1\"\n-      // If it is absent, but a parent ID is (which is strange), we'll have at least 17 characters.\n-      // Therefore, if we have less than two characters, the input is truncated.\n-      if (endIndex == pos + 1) {\n-        Platform.get().log(\"Invalid input: truncated\", null);\n+      char nextChar = value.charAt(pos);\n+      if (nextChar == '-') { // traceid-spanid--...\n+        Platform.get().log(\"Invalid input: empty sampled field\", null);\n         return null;\n       }\n-      if (!checkHyphen(b3, pos++)) return null;\n \n-      // If our position is at the end of the string, or another delimiter is one character past our\n-      // position, try to read sampled status.\n-      boolean afterSampledField = notHexFollowsPos(b3, pos, endIndex);\n-      if (endIndex == pos + 1 || afterSampledField) {\n-        flags = parseFlags(b3, pos);\n+      // At this point, we are either at the sampling field, or first character of the parentId\n+      int nextPos = pos + 1;", "originalCommit": "6797b668ca300cd84fd533c330caf98b3b5d6796", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA1MDc4Mw==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392050783", "bodyText": "sure", "author": "codefromthecrypt", "createdAt": "2020-03-13T06:30:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0NzYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0ODA2Mg==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392048062", "bodyText": "Think this is supposed to be pos - if not then minutes of staring still hasn't let my brain fully grok nextPos", "author": "anuraaga", "createdAt": "2020-03-13T06:19:22Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -140,101 +140,109 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3) {\n   }\n \n   /**\n-   * @param beginIndex the start index, inclusive\n-   * @param endIndex the end index, exclusive\n+   * This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a B3 single formatted trace context\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first character in B3 single format.\n+   * @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}\n+   * <em>after</em> the last character in B3 single format.\n    */\n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, int beginIndex,\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value, int beginIndex,\n     int endIndex) {\n-    if (beginIndex == endIndex) {\n-      Platform.get().log(\"Invalid input: empty\", null);\n-      return null;\n-    }\n+    int length = endIndex - beginIndex;\n \n-    int pos = beginIndex;\n-    if (pos + 1 == endIndex) { // possibly sampling flags\n-      return tryParseSamplingFlags(b3, pos);\n-    }\n-\n-    // At this point we minimally expect a traceId-spanId pair\n-    if (endIndex < 16 + 1 + 16 /* traceid64-spanid */) {\n-      Platform.get().log(\"Invalid input: truncated\", null);\n+    if (length == 0) {\n+      Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n-    } else if (endIndex > FORMAT_MAX_LENGTH) {\n+    } else if (length == 1) { // possibly sampling flags\n+      return tryParseSamplingFlags(value.charAt(beginIndex));\n+    } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // Cheaply check for only ASCII characters. This allows for more precise messages later, but\n-    // kicks out early on data such as unicode.\n+    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n+    // they need to consider, and if there are not enough or too many fields.\n+    int hyphenCount = 0;\n+    int indexOfFirstHyphen = -1;\n     for (int i = beginIndex; i < endIndex; i++) {\n-      if (b3.charAt(i) >= 128) {\n-        Platform.get().log(\"Invalid input: non-ASCII character at offset {0}\", i, null);\n+      char c = value.charAt(i);\n+      if (c == '-') {\n+        if (indexOfFirstHyphen == -1) {\n+          indexOfFirstHyphen = i;\n+        }\n+        hyphenCount++;\n+      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n+        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n         return null;\n       }\n     }\n \n-    long traceIdHigh, traceId;\n-    if (b3.charAt(pos + 32) == '-') {\n-      traceIdHigh = tryParse16HexCharacters(b3, pos, endIndex);\n-      pos += 16; // upper 64 bits of the trace ID\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    } else {\n-      traceIdHigh = 0L;\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    }\n-    pos += 16; // traceId\n-\n-    if (traceIdHigh == 0L && traceId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID at offset 0\", null);\n+    if (hyphenCount < 1) {\n+      Platform.get().log(\"Truncated reading trace ID\", null);\n       return null;\n-    }\n-\n-    if (isLowerHex(b3.charAt(pos))) {\n-      Platform.get().log(\"Invalid input: trace ID is too long\", null);\n+    } else if (hyphenCount > 3) {\n+      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n       return null;\n     }\n \n-    if (!checkHyphen(b3, pos++)) return null;\n+    int pos = beginIndex;\n \n-    long spanId = tryParse16HexCharacters(b3, pos, endIndex);\n-    if (spanId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 lower hex span ID at offset {0}\", pos, null);\n+    long traceIdHigh, traceId;\n+    int traceIdLength = indexOfFirstHyphen - beginIndex;\n+    if (traceIdLength == 32) {\n+      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n+      pos += 16; // upper 64 bits of the trace ID\n+    } else if (traceIdLength == 16) {\n+      traceIdHigh = 0L;\n+    } else {\n+      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n       return null;\n     }\n+\n+    traceId = tryParseId(\"trace\", value, pos, endIndex);\n+    if (traceId == 0) return null;\n+    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+\n+    long spanId = tryParseId(\"span\", value, pos, endIndex);\n+    if (spanId == 0) return null;\n     pos += 16; // spanid\n \n     int flags = 0;\n     long parentId = 0L;\n     if (endIndex > pos) {\n-      if (isLowerHex(b3.charAt(pos))) {\n-        Platform.get().log(\"Invalid input: span ID is too long\", null);\n+      pos++; // consume the delimiter\n+\n+      if (endIndex == pos) { // traceid-spanid-\n+        Platform.get().log(\"Truncated after reading span ID\", null);\n         return null;\n       }\n \n-      // If we are at this point, we have more than just traceId-spanId.\n-      // If the sampling field is present, we'll have a delimiter 2 characters from now. Ex \"-1\"\n-      // If it is absent, but a parent ID is (which is strange), we'll have at least 17 characters.\n-      // Therefore, if we have less than two characters, the input is truncated.\n-      if (endIndex == pos + 1) {\n-        Platform.get().log(\"Invalid input: truncated\", null);\n+      char nextChar = value.charAt(pos);\n+      if (nextChar == '-') { // traceid-spanid--...\n+        Platform.get().log(\"Invalid input: empty sampled field\", null);\n         return null;\n       }\n-      if (!checkHyphen(b3, pos++)) return null;\n \n-      // If our position is at the end of the string, or another delimiter is one character past our\n-      // position, try to read sampled status.\n-      boolean afterSampledField = notHexFollowsPos(b3, pos, endIndex);\n-      if (endIndex == pos + 1 || afterSampledField) {\n-        flags = parseFlags(b3, pos);\n+      // At this point, we are either at the sampling field, or first character of the parentId\n+      int nextPos = pos + 1;\n+      boolean hasSampledAndParent = hyphenCount == 3;\n+      if (nextPos == endIndex || hasSampledAndParent) {\n+        flags = parseSampledFlags(nextChar);\n+        pos++; // consume the sampled field\n         if (flags == 0) return null;\n-        pos++; // consume the sampled status\n-        if (afterSampledField && !checkHyphen(b3, pos++)) return null; // consume the delimiter\n+        if (hasSampledAndParent && value.charAt(pos++) != '-') {\n+          Platform.get().log(\"Invalid input: sampled is too long\", null);\n+          return null;\n+        }\n       }\n \n-      if (endIndex > pos || afterSampledField) {\n+      if (endIndex > nextPos) {", "originalCommit": "6797b668ca300cd84fd533c330caf98b3b5d6796", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA1MjQ3NQ==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392052475", "bodyText": "it isn't pos.. anyway I'll try to rename things", "author": "codefromthecrypt", "createdAt": "2020-03-13T06:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0ODA2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA3MzEwMg==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392073102", "bodyText": "tried a different approach. PTAL", "author": "codefromthecrypt", "createdAt": "2020-03-13T07:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0ODA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0ODcxNA==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392048714", "bodyText": "Not sure if this method is used elsewhere - but at a glance it seems this duplicates some validation with the validation code in parseB3SingleFormat. Maybe fine to be safer than sorry though.", "author": "anuraaga", "createdAt": "2020-03-13T06:21:40Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -251,69 +259,48 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, i\n   }\n \n   /** Returns zero if truncated, malformed, or too big after logging */\n-  static long tryParseParentId(CharSequence b3, int pos, int endIndex) {\n-    if (endIndex < pos + 16) {\n-      Platform.get().log(\"Invalid input: truncated\", null);\n+  static long tryParseId(String name, CharSequence value, int beginIndex, int endIndex) {\n+    int endOfId = beginIndex + 16;\n+    if (beginIndex == endIndex || value.charAt(beginIndex) == '-') {", "originalCommit": "6797b668ca300cd84fd533c330caf98b3b5d6796", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA1MTI3Mw==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392051273", "bodyText": "traceID is a special case, as it can be variable length, and the sampled flag is single-character.. I couldn't re-use this logic for all field permutations, but most of them I could!", "author": "codefromthecrypt", "createdAt": "2020-03-13T06:31:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0ODcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA3MzM2Mg==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392073362", "bodyText": "I loosened one log entry to reduce the logic with little loss in fidelity. PTAL!", "author": "codefromthecrypt", "createdAt": "2020-03-13T07:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0ODcxNA=="}], "type": "inlineReview"}, {"oid": "8b3b9bd38f3cb2b8629adcf3c5f4d0276da5f3d8", "url": "https://github.com/openzipkin/brave/commit/8b3b9bd38f3cb2b8629adcf3c5f4d0276da5f3d8", "message": "Update brave/src/main/java/brave/propagation/B3SingleFormat.java\n\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-03-13T06:29:32Z", "type": "commit"}, {"oid": "1a15b6bfd31c37bf7da605dc2a5bfd952b309e80", "url": "https://github.com/openzipkin/brave/commit/1a15b6bfd31c37bf7da605dc2a5bfd952b309e80", "message": "another pass", "committedDate": "2020-03-13T07:49:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA3NDY5NA==", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392074694", "bodyText": "Thanks this is very clear now!", "author": "anuraaga", "createdAt": "2020-03-13T07:52:36Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -140,102 +140,96 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3) {\n   }\n \n   /**\n-   * @param beginIndex the start index, inclusive\n-   * @param endIndex the end index, exclusive\n+   * This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a B3 single formatted trace context\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first character in B3 single format.\n+   * @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}\n+   * <em>after</em> the last character in B3 single format.\n    */\n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, int beginIndex,\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value, int beginIndex,\n     int endIndex) {\n-    if (beginIndex == endIndex) {\n-      Platform.get().log(\"Invalid input: empty\", null);\n-      return null;\n-    }\n-\n-    int pos = beginIndex;\n-    if (pos + 1 == endIndex) { // possibly sampling flags\n-      return tryParseSamplingFlags(b3, pos);\n-    }\n+    int length = endIndex - beginIndex;\n \n-    // At this point we minimally expect a traceId-spanId pair\n-    if (endIndex < 16 + 1 + 16 /* traceid64-spanid */) {\n-      Platform.get().log(\"Invalid input: truncated\", null);\n+    if (length == 0) {\n+      Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n-    } else if (endIndex > FORMAT_MAX_LENGTH) {\n+    } else if (length == 1) { // possibly sampling flags\n+      return tryParseSamplingFlags(value.charAt(beginIndex));\n+    } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // Cheaply check for only ASCII characters. This allows for more precise messages later, but\n-    // kicks out early on data such as unicode.\n+    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n+    // they need to consider, and if there are not enough or too many fields.\n+    int hyphenCount = 0;\n+    int indexOfFirstHyphen = -1;\n     for (int i = beginIndex; i < endIndex; i++) {\n-      if (b3.charAt(i) >= 128) {\n-        Platform.get().log(\"Invalid input: non-ASCII character at offset {0}\", i, null);\n+      char c = value.charAt(i);\n+      if (c == '-') {\n+        if (indexOfFirstHyphen == -1) {\n+          indexOfFirstHyphen = i;\n+        }\n+        hyphenCount++;\n+      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n+        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n         return null;\n       }\n     }\n \n-    long traceIdHigh, traceId;\n-    if (b3.charAt(pos + 32) == '-') {\n-      traceIdHigh = tryParse16HexCharacters(b3, pos, endIndex);\n-      pos += 16; // upper 64 bits of the trace ID\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    } else {\n-      traceIdHigh = 0L;\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    }\n-    pos += 16; // traceId\n-\n-    if (traceIdHigh == 0L && traceId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID at offset 0\", null);\n+    if (indexOfFirstHyphen == -1) {\n+      Platform.get().log(\"Truncated reading trace ID\", null);\n       return null;\n-    }\n-\n-    if (isLowerHex(b3.charAt(pos))) {\n-      Platform.get().log(\"Invalid input: trace ID is too long\", null);\n+    } else if (hyphenCount > 3) {\n+      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n       return null;\n     }\n \n-    if (!checkHyphen(b3, pos++)) return null;\n+    int pos = beginIndex;\n \n-    long spanId = tryParse16HexCharacters(b3, pos, endIndex);\n-    if (spanId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 lower hex span ID at offset {0}\", pos, null);\n+    long traceIdHigh, traceId;\n+    int traceIdLength = indexOfFirstHyphen - beginIndex;\n+    if (traceIdLength == 32) {\n+      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n+      pos += 16; // upper 64 bits of the trace ID\n+    } else if (traceIdLength == 16) {\n+      traceIdHigh = 0L;\n+    } else {\n+      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n       return null;\n     }\n+\n+    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n+    if (traceId == 0) return null;\n+    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+\n+    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n+    if (spanId == 0) return null;\n     pos += 16; // spanid\n \n     int flags = 0;\n     long parentId = 0L;\n-    if (endIndex > pos) {\n-      if (isLowerHex(b3.charAt(pos))) {\n-        Platform.get().log(\"Invalid input: span ID is too long\", null);\n-        return null;\n-      }\n+    if (hyphenCount > 1) { // traceid-spanid-\n+      pos++; // consume the hyphen\n \n-      // If we are at this point, we have more than just traceId-spanId.\n-      // If the sampling field is present, we'll have a delimiter 2 characters from now. Ex \"-1\"\n-      // If it is absent, but a parent ID is (which is strange), we'll have at least 17 characters.\n-      // Therefore, if we have less than two characters, the input is truncated.\n-      if (endIndex == pos + 1) {\n-        Platform.get().log(\"Invalid input: truncated\", null);\n-        return null;\n-      }\n-      if (!checkHyphen(b3, pos++)) return null;\n-\n-      // If our position is at the end of the string, or another delimiter is one character past our\n-      // position, try to read sampled status.\n-      boolean afterSampledField = notHexFollowsPos(b3, pos, endIndex);\n-      if (endIndex == pos + 1 || afterSampledField) {\n-        flags = parseFlags(b3, pos);\n+      if (hyphenCount == 3) { // we should parse sampled AND parent ID", "originalCommit": "1a15b6bfd31c37bf7da605dc2a5bfd952b309e80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}