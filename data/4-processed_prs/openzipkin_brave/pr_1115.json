{"pr_number": 1115, "pr_title": "Simplifies B3 single by parsing in a single loop", "pr_createdAt": "2020-03-16T05:44:40Z", "pr_url": "https://github.com/openzipkin/brave/pull/1115", "timeline": [{"oid": "d87b477c3f1326a03c721297893cbd7511a28105", "url": "https://github.com/openzipkin/brave/commit/d87b477c3f1326a03c721297893cbd7511a28105", "message": "Simplifies B3 single by parsing in a single loop\n\nThis consolidates logic and removes duplication via the following:\n* it is odd that parent ID is sent without sampled flag, assume it isn't\n* exploit being in the same package as `SamplingFlags`\n\nNote: the performance isn't better, it is just less code.", "committedDate": "2020-03-16T05:42:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc5Mjk5OQ==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392792999", "bodyText": "forgot we were in the same package before. this removes duplicate logic.", "author": "codefromthecrypt", "createdAt": "2020-03-16T05:48:03Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,100 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n+\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n+\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n+\n       if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n         }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+          if (isEof) break; // fields after span ID are optional\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos -1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;", "originalCommit": "d87b477c3f1326a03c721297893cbd7511a28105", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7fb56d006bb13ec14f4aedfa8c44836b9e755c2c", "url": "https://github.com/openzipkin/brave/commit/7fb56d006bb13ec14f4aedfa8c44836b9e755c2c", "message": "remove redundant checks", "committedDate": "2020-03-16T05:49:36Z", "type": "commit"}, {"oid": "047c18104257d69714be721dc83b1902c60fe14a", "url": "https://github.com/openzipkin/brave/commit/047c18104257d69714be721dc83b1902c60fe14a", "message": "less parsing", "committedDate": "2020-03-16T05:51:19Z", "type": "commit"}, {"oid": "0ae33e296967aec8378715a5417d2626848d1172", "url": "https://github.com/openzipkin/brave/commit/0ae33e296967aec8378715a5417d2626848d1172", "message": "Makes sure there are no zeros at ID boundaries in tests", "committedDate": "2020-03-16T06:02:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc5NzAxNQ==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392797015", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Otherwise, we'd have to process again when outside the loop.\n          \n          \n            \n                // Otherwise, we'd have to process again when outside the loop to handle dangling data on EOF.", "author": "codefromthecrypt", "createdAt": "2020-03-16T06:05:36Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.", "originalCommit": "0ae33e296967aec8378715a5417d2626848d1172", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgxODU1NQ==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392818555", "bodyText": "Realize this is the same as current, but if pursuing more benchmarking, maybe worth looking into either having a switch with sixteen cases or a lookup table.", "author": "anuraaga", "createdAt": "2020-03-16T07:04:15Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;\n         } else {\n-          parentId = tryParseParentId(value, endIndex, pos);\n-          if (parentId == 0L) return null;\n+          parentId = buffer;\n+\n+          if (!isEof) {\n+            Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n+            return null;\n+          }\n         }\n+\n+        buffer = 0L;\n+        currentFieldLength = 0;\n+        continue;\n+      } else if (currentField == Field.TRACE_ID && beginIndex + 16 == pos) {\n+        // special casing the only valid non-hyphen at position 16\n+        // we don't guard against all zeros as traceIdHigh can be all zeros for 128-bit\n+        traceIdHigh = buffer;\n+\n+        // This character is the next hex. If it isn't, the next iteration will throw. Either way,\n+        // reset so that we can capture the next 16 characters of the trace ID.\n+        buffer = 0;\n+        currentFieldLength = 0;\n       }\n+\n+      // The rest of this is normal lower-hex decoding\n+      buffer <<= 4;\n+      if (c >= '0' && c <= '9') {", "originalCommit": "0ae33e296967aec8378715a5417d2626848d1172", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyNzIwNA==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392827204", "bodyText": "ooo I like", "author": "codefromthecrypt", "createdAt": "2020-03-16T07:27:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgxODU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MjI5Ng==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392852296", "bodyText": "running benchmarks again now. I did all the other tricks I could think of along the way", "author": "codefromthecrypt", "createdAt": "2020-03-16T08:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgxODU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgxOTg2Nw==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392819867", "bodyText": "Think it's helpful to have one of\nassert currentField == Field.PARENT_SPAN_ID;\n// Parent Span ID", "author": "anuraaga", "createdAt": "2020-03-16T07:06:19Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;\n         } else {\n-          parentId = tryParseParentId(value, endIndex, pos);\n-          if (parentId == 0L) return null;\n+          parentId = buffer;", "originalCommit": "0ae33e296967aec8378715a5417d2626848d1172", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyODU4MQ==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392828581", "bodyText": "yeah intellij kept getting mad at me for the redundant else if. this is better though", "author": "codefromthecrypt", "createdAt": "2020-03-16T07:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgxOTg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyMjQ0Ng==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392822446", "bodyText": "Reasoning this continue out is tough since it's buried among much code. IIUC, this just avoids a single buffer = 0L so maybe not worth special casing?", "author": "anuraaga", "createdAt": "2020-03-16T07:12:30Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;", "originalCommit": "0ae33e296967aec8378715a5417d2626848d1172", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyODI0OQ==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392828249", "bodyText": "this was fuzz indeed.. good eye!", "author": "codefromthecrypt", "createdAt": "2020-03-16T07:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyMjQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyMjcxNQ==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392822715", "bodyText": "The above if block is huge so I'd add a comment\n  continue;\n}\n\n// Not a hyphen\n\nif (currentField == Field.TRACE_ID...", "author": "anuraaga", "createdAt": "2020-03-16T07:13:28Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;\n         } else {\n-          parentId = tryParseParentId(value, endIndex, pos);\n-          if (parentId == 0L) return null;\n+          parentId = buffer;\n+\n+          if (!isEof) {\n+            Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n+            return null;\n+          }\n         }\n+\n+        buffer = 0L;\n+        currentFieldLength = 0;\n+        continue;\n+      } else if (currentField == Field.TRACE_ID && beginIndex + 16 == pos) {", "originalCommit": "0ae33e296967aec8378715a5417d2626848d1172", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyODkzNA==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392828934", "bodyText": "good idea", "author": "codefromthecrypt", "createdAt": "2020-03-16T07:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyMjcxNQ=="}], "type": "inlineReview"}, {"oid": "dc4d4f6ebfc553f3432e8183258ccbdc377cb459", "url": "https://github.com/openzipkin/brave/commit/dc4d4f6ebfc553f3432e8183258ccbdc377cb459", "message": "Update brave/src/main/java/brave/propagation/B3SingleFormat.java", "committedDate": "2020-03-16T07:27:29Z", "type": "commit"}, {"oid": "f5de5b8e5faf6671433792a10723f101c09be050", "url": "https://github.com/openzipkin/brave/commit/f5de5b8e5faf6671433792a10723f101c09be050", "message": "feedback", "committedDate": "2020-03-16T07:33:12Z", "type": "commit"}, {"oid": "0e2b0781fb408ebf304f741982e6e90774c767bd", "url": "https://github.com/openzipkin/brave/commit/0e2b0781fb408ebf304f741982e6e90774c767bd", "message": "brings allocation back down to 104 bytes/op", "committedDate": "2020-03-16T07:54:52Z", "type": "commit"}, {"oid": "ae418e9ed784fbd9d1765e07eb0929202822d73b", "url": "https://github.com/openzipkin/brave/commit/ae418e9ed784fbd9d1765e07eb0929202822d73b", "message": "Optimizations:\n\n* no fields from `Field` unless there's an error.\n* only a single counter increment (pos)\n* switch/case for hex decoding\n* optimized long runs of zeros", "committedDate": "2020-03-16T08:28:53Z", "type": "commit"}, {"oid": "5c51272a92b692a278bf3be99109d956fd226da2", "url": "https://github.com/openzipkin/brave/commit/5c51272a92b692a278bf3be99109d956fd226da2", "message": "reverts long runs of zeros as perf is actually worse", "committedDate": "2020-03-16T08:46:10Z", "type": "commit"}, {"oid": "4249a51be36c63058917686589d3e2c9ecf07dc4", "url": "https://github.com/openzipkin/brave/commit/4249a51be36c63058917686589d3e2c9ecf07dc4", "message": "smaller bytecode by no internal enum", "committedDate": "2020-03-16T08:57:04Z", "type": "commit"}, {"oid": "5856dcb979be070310c6435068c72b762a849546", "url": "https://github.com/openzipkin/brave/commit/5856dcb979be070310c6435068c72b762a849546", "message": "everything fast as can get", "committedDate": "2020-03-16T09:33:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4OTE5NA==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392889194", "bodyText": "added this because we usually do when we use thread locals", "author": "codefromthecrypt", "createdAt": "2020-03-16T09:40:44Z", "path": "brave-tests/src/main/java/brave/test/propagation/B3SingleFormatClassLoaderTest.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.test.propagation;\n+\n+import brave.propagation.B3SingleFormat;\n+import org.junit.Test;\n+\n+import static brave.test.util.ClassLoaders.assertRunIsUnloadable;\n+\n+public class B3SingleFormatClassLoaderTest {", "originalCommit": "5856dcb979be070310c6435068c72b762a849546", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4OTkzOA==", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392889938", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // The handle malformed cases like below, it is easier to assume the next field is\n          \n          \n            \n                        // To handle malformed cases like below, it is easier to assume the next field is", "author": "codefromthecrypt", "createdAt": "2020-03-16T09:41:55Z", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,81 +161,118 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n+\n+    // Assume it is a 128-bit trace ID and revise back as necessary\n+    int currentField = FIELD_TRACE_ID_HIGH, currentFieldLength = 0;\n+    // Used for hex-decoding, performed by bitwise addition\n+    long buffer = 0L;\n+\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop to handle dangling data on EOF.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n+\n       if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n+        if (currentField == FIELD_SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = FIELD_PARENT_SPAN_ID;\n+          }\n+        } else if (currentField == FIELD_TRACE_ID_HIGH) {\n+          // We reached a hyphen before the 17th hex character. This means it is a 64-bit trace ID.\n+          currentField = FIELD_TRACE_ID;\n         }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n+\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n+\n+        switch (currentField) {\n+          case FIELD_TRACE_ID:\n+            traceId = buffer;\n+\n+            currentField = FIELD_SPAN_ID;\n+            break;\n+          case FIELD_SPAN_ID:\n+            spanId = buffer;\n+\n+            // The handle malformed cases like below, it is easier to assume the next field is", "originalCommit": "5856dcb979be070310c6435068c72b762a849546", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "43e3691edd6dfa80a3a689db39edb8614568a96e", "url": "https://github.com/openzipkin/brave/commit/43e3691edd6dfa80a3a689db39edb8614568a96e", "message": "Update brave/src/main/java/brave/propagation/B3SingleFormat.java", "committedDate": "2020-03-16T09:47:22Z", "type": "commit"}]}