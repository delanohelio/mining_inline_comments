{"pr_number": 1186, "pr_title": "Adds UnsafeArrayMap and deprecated BaggageField.getAll for getAllValues", "pr_createdAt": "2020-05-03T08:58:38Z", "pr_url": "https://github.com/openzipkin/brave/pull/1186", "timeline": [{"oid": "18eaf055df2a7c3067c51d70b2abb3e631d3ba2c", "url": "https://github.com/openzipkin/brave/commit/18eaf055df2a7c3067c51d70b2abb3e631d3ba2c", "message": "Adds UnsafeArrayMap and deprecated BaggageField.getAll for getAllValues\n\nIn analyzing the usage of the (recently added BaggageField.getAll), I\nnoticed in every case the keys are coersed to strings and all non-null\nvalues are read.\n\nThis provides a more efficient alternative, via `UnsafeArrayMap`, pulled\nin from #1183", "committedDate": "2020-05-03T08:57:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA4MjUwNg==", "url": "https://github.com/openzipkin/brave/pull/1186#discussion_r419082506", "bodyText": "Can we use SimpleImmutableEntry instead of this class?", "author": "anuraaga", "createdAt": "2020-05-03T10:28:47Z", "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. Keys with {@code null} are filtered out.\n+ *\n+ * <p>The array is shared with the caller to {@link Builder#build(Object[])}, hence being called\n+ * \"unsafe\". This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>An input with no keys coerces to {@link Collections#emptyMap()}.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final int MAX_FILTERED_KEYS = LongBitSet.MAX_SIZE;\n+\n+  interface Mapper<V1, V2> {\n+    V2 map(V1 input);\n+  }\n+\n+  static <K, V> Builder<K, V> newBuilder() {\n+    return new Builder<>();\n+  }\n+\n+  static final class Builder<K, V> {\n+    Mapper<Object, K> keyMapper;\n+    K[] filteredKeys = (K[]) new Object[0];\n+\n+    Builder<K, V> mapKeys(Mapper<Object, K> keyMapper) {\n+      if (keyMapper == null) throw new NullPointerException(\"keyMapper == null\");\n+      this.keyMapper = keyMapper;\n+      return this;\n+    }\n+\n+    /** @param filteredKeys keys that won't be visible in the resulting map. */\n+    Builder<K, V> filterKeys(K... filteredKeys) {\n+      if (filteredKeys == null) throw new NullPointerException(\"filteredKeys == null\");\n+      if (filteredKeys.length > MAX_FILTERED_KEYS) {\n+        throw new IllegalArgumentException(\n+            \"cannot filter more than \" + MAX_FILTERED_KEYS + \" keys\");\n+      }\n+      this.filteredKeys = filteredKeys;\n+      return this;\n+    }\n+\n+    /** @param array pairwise array holding key values */\n+    Map<K, V> build(Object[] array) {\n+      if (array == null) throw new NullPointerException(\"array == null\");\n+      long filteredBitSet = 0;\n+      int i = 0, numFiltered = 0;\n+      for (; i < array.length; i += 2) {\n+        if (array[i] == null) break; // we ignore anything starting at first null key\n+\n+        if (array[i + 1] == null) { // filter null values\n+          filteredBitSet = setFilteredKey(filteredBitSet, i);\n+          numFiltered++;\n+          continue;\n+        }\n+\n+        K key = keyMapper != null ? keyMapper.map(array[i]) : (K) array[i];\n+        for (K filteredKey : filteredKeys) {\n+          if (filteredKey.equals(key)) {\n+            filteredBitSet = setFilteredKey(filteredBitSet, i);\n+            numFiltered++;\n+            break;\n+          }\n+        }\n+      }\n+      if (numFiltered == i / 2) return Collections.emptyMap();\n+      if (keyMapper == null) return new UnsafeArrayMap<>(array, i, filteredBitSet);\n+      return new KeyMapping<>(this, array, i, filteredBitSet);\n+    }\n+  }\n+\n+  static final class KeyMapping<K, V> extends UnsafeArrayMap<K, V> {\n+    final Mapper<Object, K> keyMapper;\n+\n+    KeyMapping(Builder builder, Object[] array, int toIndex, long filteredBitSet) {\n+      super(array, toIndex, filteredBitSet);\n+      this.keyMapper = builder.keyMapper;\n+    }\n+\n+    @Override K key(int i) {\n+      return keyMapper.map(array[i]);\n+    }\n+  }\n+\n+  final Object[] array;\n+  final int toIndex, size;\n+  final long filteredBitSet;\n+\n+  UnsafeArrayMap(Object[] array, int toIndex, long filteredBitSet) {\n+    this.array = array;\n+    this.toIndex = toIndex;\n+    this.filteredBitSet = filteredBitSet;\n+    this.size = toIndex / 2 - LongBitSet.size(filteredBitSet);\n+  }\n+\n+  @Override public int size() {\n+    return size;\n+  }\n+\n+  @Override public boolean containsKey(Object o) {\n+    if (o == null) return false; // null keys are not allowed\n+    return arrayIndexOfKey(o) != -1;\n+  }\n+\n+  @Override public boolean containsValue(Object o) {\n+    for (int i = 0; i < toIndex; i += 2) {\n+      if (!isFilteredKey(filteredBitSet, i) && value(i + 1).equals(o)) return true;\n+    }\n+    return false;\n+  }\n+\n+  @Override public V get(Object o) {\n+    if (o == null) return null; // null keys are not allowed\n+    int i = arrayIndexOfKey(o);\n+    return i != -1 ? value(i + 1) : null;\n+  }\n+\n+  int arrayIndexOfKey(Object o) {\n+    int result = -1;\n+    for (int i = 0; i < toIndex; i += 2) {\n+      if (!isFilteredKey(filteredBitSet, i) && o.equals(key(i))) {\n+        return i;\n+      }\n+    }\n+    return result;\n+  }\n+\n+  K key(int i) {\n+    return (K) array[i];\n+  }\n+\n+  V value(int i) {\n+    return (V) array[i];\n+  }\n+\n+  @Override public Set<K> keySet() {\n+    return new KeySetView();\n+  }\n+\n+  @Override public Collection<V> values() {\n+    return new ValuesView();\n+  }\n+\n+  @Override public Set<Map.Entry<K, V>> entrySet() {\n+    return new EntrySetView();\n+  }\n+\n+  @Override public boolean isEmpty() {\n+    return false;\n+  }\n+\n+  @Override public V put(K key, V value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public V remove(Object key) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void putAll(Map<? extends K, ? extends V> m) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void clear() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  final class KeySetView extends SetView<K> {\n+    @Override K elementAtArrayIndex(int i) {\n+      return key(i);\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsKey(o);\n+    }\n+  }\n+\n+  final class ValuesView extends SetView<V> {\n+    @Override V elementAtArrayIndex(int i) {\n+      return value(i + 1);\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsValue(o);\n+    }\n+  }\n+\n+  final class EntrySetView extends SetView<Map.Entry<K, V>> {\n+    @Override Map.Entry<K, V> elementAtArrayIndex(int i) {\n+      return new Entry<>(key(i), value(i + 1));\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      if (!(o instanceof Map.Entry) || ((Map.Entry) o).getKey() == null) return false;\n+      Map.Entry that = (Map.Entry) o;\n+      int i = arrayIndexOfKey(that.getKey());\n+      if (i == -1) return false;\n+      return value(i + 1).equals(that.getValue());\n+    }\n+  }\n+\n+  abstract class SetView<E> implements Set<E> {\n+    int advancePastFiltered(int i) {\n+      while (i < toIndex && isFilteredKey(filteredBitSet, i)) i += 2;\n+      return i;\n+    }\n+\n+    @Override public int size() {\n+      return size;\n+    }\n+\n+    /**\n+     * By abstracting this, {@link #keySet()} {@link #values()} and {@link #entrySet()} only\n+     * implement need implement two methods based on {@link #<E>}: this method and and {@link\n+     * #contains(Object)}.\n+     */\n+    abstract E elementAtArrayIndex(int i);\n+\n+    @Override public Iterator<E> iterator() {\n+      return new ReadOnlyIterator();\n+    }\n+\n+    @Override public Object[] toArray() {\n+      return copyTo(new Object[size]);\n+    }\n+\n+    @Override public <T> T[] toArray(T[] a) {\n+      T[] result = a.length >= size ? a\n+          : (T[]) Array.newInstance(a.getClass().getComponentType(), size());\n+      return copyTo(result);\n+    }\n+\n+    <T> T[] copyTo(T[] dest) {\n+      for (int i = 0, d = 0; i < toIndex; i += 2) {\n+        if (isFilteredKey(filteredBitSet, i)) continue;\n+        dest[d++] = (T) elementAtArrayIndex(i);\n+      }\n+      return dest;\n+    }\n+\n+    final class ReadOnlyIterator implements Iterator<E> {\n+      int i = advancePastFiltered(0);\n+\n+      @Override public boolean hasNext() {\n+        i = advancePastFiltered(i);\n+        return i < toIndex;\n+      }\n+\n+      @Override public E next() {\n+        if (!hasNext()) throw new NoSuchElementException();\n+        E result = elementAtArrayIndex(i);\n+        i += 2;\n+        return result;\n+      }\n+\n+      @Override public void remove() {\n+        throw new UnsupportedOperationException();\n+      }\n+    }\n+\n+    @Override public boolean containsAll(Collection<?> c) {\n+      if (c == null) return false;\n+      if (c.isEmpty()) return true;\n+\n+      for (Object element : c) {\n+        if (!contains(element)) return false;\n+      }\n+      return true;\n+    }\n+\n+    @Override public boolean isEmpty() {\n+      return false;\n+    }\n+\n+    @Override public boolean add(E e) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public boolean remove(Object o) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public boolean addAll(Collection<? extends E> c) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public boolean retainAll(Collection<?> c) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public boolean removeAll(Collection<?> c) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public void clear() {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  static final class Entry<K, V> implements Map.Entry<K, V> {", "originalCommit": "18eaf055df2a7c3067c51d70b2abb3e631d3ba2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA4MzgwNQ==", "url": "https://github.com/openzipkin/brave/pull/1186#discussion_r419083805", "bodyText": "sure can. I didn't know that was public! also it is the same as are lowest java level. score!", "author": "codefromthecrypt", "createdAt": "2020-05-03T10:39:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA4MjUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA4NDA1Mg==", "url": "https://github.com/openzipkin/brave/pull/1186#discussion_r419084052", "bodyText": "80 less lines thanks to you!", "author": "codefromthecrypt", "createdAt": "2020-05-03T10:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA4MjUwNg=="}], "type": "inlineReview"}, {"oid": "8138c8db3d37dddfb5c43e3d550f5b623771d9e9", "url": "https://github.com/openzipkin/brave/commit/8138c8db3d37dddfb5c43e3d550f5b623771d9e9", "message": "less code", "committedDate": "2020-05-03T10:42:17Z", "type": "commit"}]}