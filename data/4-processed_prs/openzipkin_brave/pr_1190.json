{"pr_number": 1190, "pr_title": "Renames internal ExtraHandler back to ExtraFactory and clarifies", "pr_createdAt": "2020-05-06T03:37:53Z", "pr_url": "https://github.com/openzipkin/brave/pull/1190", "timeline": [{"oid": "bd22f664c4a8937a9c59d1a750d4a559cd40d1b7", "url": "https://github.com/openzipkin/brave/commit/bd22f664c4a8937a9c59d1a750d4a559cd40d1b7", "message": "Renames internal ExtraHandler back to ExtraFactory and clarifies\n\nWhen integrating secondary sampling, I found the new name (I caused)\nmore distracting then helpful. The defensive api which led to renaming\nwas a cure worse than the disease of a preventable programming error.\n\nInstead, this improves Javadoc, notably mentioning how to use the\nfactory properly (and not crashing on mistake).", "committedDate": "2020-05-06T03:34:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyODc4Mg==", "url": "https://github.com/openzipkin/brave/pull/1190#discussion_r420528782", "bodyText": "note: this is public just because the type itself lives in a different package (brave.internal.baggage) than the call site (brave.baggage). In most cases, they will be in the same package, so implementations can leave it protected.", "author": "codefromthecrypt", "createdAt": "2020-05-06T03:40:42Z", "path": "brave/src/main/java/brave/internal/baggage/BaggageFieldsFactory.java", "diffHunk": "@@ -51,7 +51,7 @@ public static BaggageFieldsHandler create(List<BaggageField> fields, boolean dyn\n     this.initialArrayLength = initialState.length;\n   }\n \n-  @Override protected BaggageFields provisionExtra() {\n+  @Override public BaggageFields create() {", "originalCommit": "bd22f664c4a8937a9c59d1a750d4a559cd40d1b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyODg3Mg==", "url": "https://github.com/openzipkin/brave/pull/1190#discussion_r420528872", "bodyText": "moved to the factory as the relevant notes around this are there", "author": "codefromthecrypt", "createdAt": "2020-05-06T03:41:04Z", "path": "brave/src/main/java/brave/internal/baggage/Extra.java", "diffHunk": "@@ -21,23 +21,19 @@\n /**\n  * Holds extended state in {@link TraceContext#extra()} or {@link TraceContextOrSamplingFlags#extra()}.\n  *\n- * <p>We need to retain propagation state extracted from headers. However, we don't know the trace", "originalCommit": "bd22f664c4a8937a9c59d1a750d4a559cd40d1b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyOTE2Ng==", "url": "https://github.com/openzipkin/brave/pull/1190#discussion_r420529166", "bodyText": "because I added so much javadoc, this became a new file. The logic hasn't changed except coersing bugs to the input context", "author": "codefromthecrypt", "createdAt": "2020-05-06T03:42:23Z", "path": "brave/src/main/java/brave/internal/baggage/ExtraFactory.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.Tracing;\n+import brave.baggage.BaggageField;\n+import brave.internal.InternalPropagation;\n+import brave.internal.Platform;\n+import brave.propagation.Propagation;\n+import brave.propagation.TraceContext;\n+import brave.propagation.TraceContextOrSamplingFlags;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This manages an mutable element of {@link TraceContext#extra()} of type ({@link Extra}). The most\n+ * common usage is assigning {@linkplain BaggageField baggage} parsed from the request to a span.\n+ * However, this supports other use cases such as extended trace contexts and secondary sampling.\n+ *\n+ * <h3>Method overview</h3>\n+ * {@link #decorate(TraceContext)} ensures that the resulting {@link TraceContext} has an instance\n+ * of \"extra\" ({@link #<E>}), that it is associated only with the context's span ID, and that fields\n+ * inside \"extra\" considers upstream values, such as from a parent span.\n+ *\n+ * <p>{@link #create()} is used to add an instance of {@link #<E>} to an {@link\n+ * TraceContextOrSamplingFlags extraction result}. Concretely, this allows additional request data,\n+ * such as a request ID, to be inherited from a request, and possibly changed, before a trace\n+ * context is {@linkplain #decorate(TraceContext) decorated}.\n+ *\n+ * <h3>Integration</h3>\n+ * The only valid way to integrate this is via a custom {@link Propagation.Factory}. Its {@link\n+ * Propagation.Factory#decorate(TraceContext)} method MUST dispatch to {@link\n+ * #decorate(TraceContext)}.\n+ *\n+ * <p>If request state is needed, {@link Propagation#extractor(Propagation.Getter)}\n+ * MUST call {@link #create()} only once per request. The result should be added to\n+ * TraceContextOrSamplingFlags.Builder#addExtra(Object)}.\n+ *\n+ * <h3>Notes</h3>\n+ * <p>The reason {@link #create()} is decoupled from {@link #decorate(TraceContext)} is because\n+ * extra data can exist in a request even if a trace context does not. Even when a trace context\n+ * exists in headers, it is only used directly when {@linkplain Tracing.Builder#supportsJoin(boolean)\n+ * join is supported}. In other words, {@link #<E>} carries any data from the request until it can\n+ * be associated with a {@link TraceContext} (via {@link #decorate(TraceContext)}.\n+ *\n+ * <p>It may not be intuitive why implementations should always add\n+ *\n+ * <p>If your data is not mutable, and is constant through the trace, do not use this. Instead, add\n+ * your own type via {@link TraceContextOrSamplingFlags.Builder#addExtra(Object)} as the tracer will\n+ * copy it down to children by default.\n+ *\n+ * <p>Even though {@link #<E>} is mutable, it must be copy-on-write internally. This type manages\n+ * state forking that ensures that updates to child spans are invisible to their parents or\n+ * siblings.\n+ *\n+ * @param <E> They type of {@link Extra} managed by this factory. Must be a final class. The type is\n+ * typically package private to avoid accidental interference.\n+ * @param <F> An instance of this factory. {@link #<E>} should be associated with only one factory.\n+ */\n+public abstract class ExtraFactory<E extends Extra<E, F>, F extends ExtraFactory<E, F>> {", "originalCommit": "bd22f664c4a8937a9c59d1a750d4a559cd40d1b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "62c89fd3093487a2b5cbbfac8906fb99bccdff74", "url": "https://github.com/openzipkin/brave/commit/62c89fd3093487a2b5cbbfac8906fb99bccdff74", "message": "fuzz", "committedDate": "2020-05-06T03:45:10Z", "type": "commit"}, {"oid": "6d7b07d90c95cf160c0c3d173592f63eee2fbea7", "url": "https://github.com/openzipkin/brave/commit/6d7b07d90c95cf160c0c3d173592f63eee2fbea7", "message": "Merge branch 'master' into back-to-factory", "committedDate": "2020-05-06T05:23:27Z", "type": "commit"}]}