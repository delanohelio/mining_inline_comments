{"pr_number": 292, "pr_title": "[Mac Manager] Optimize Mac Allocation Algorithm to Cut Latency", "pr_createdAt": "2020-07-09T12:28:05Z", "pr_url": "https://github.com/futurewei-cloud/alcor/pull/292", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwMDcyMw==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r452600723", "bodyText": "In the message, let us add the exact conflicted MAC address.", "author": "xieus", "createdAt": "2020-07-10T03:18:45Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/service/implement/MacServiceImpl.java", "diffHunk": "@@ -100,13 +94,26 @@ public MacState getMacStateByMacAddress(String macAddress) throws ParameterNullO\n     public MacState createMacState(MacState macState) throws ParameterNullOrEmptyException, MacRepositoryTransactionErrorException, MacRangeInvalidException, MacAddressUniquenessViolationException, MacAddressFullException, MacAddressRetryLimitExceedException {\n         if (macState == null)\n             throw (new ParameterNullOrEmptyException(MacManagerConstant.MAC_EXCEPTION_PARAMETER_NULL_EMPTY));\n+\n+        String macAddress = macState.getMacAddress();\n+        if(!StringUtils.isEmpty(macAddress)){\n+            try {\n+                MacState dbMacState = macStateRepository.findItem(macAddress);\n+                if(dbMacState != null){\n+                    throw new MacAddressUniquenessViolationException(\"mac address is in use!\");", "originalCommit": "8148a7dd02e0887c9430c60fcb5775bac102017c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNTU2NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r452605564", "bodyText": "I know this is not your code @Gzure Looking back this line of code will impact the performance significantly. As we are do a major refactor, let us take this opportunity to get rid of the \"default range\" and use a range selector.\nIn the MacRangeRepository or a new repository, create a table to track the utilization of each range.\nOption 1 Explicit update:\nEvery allocation request always goes to that table to pick up the latest range with least utilization,  and increment the count after an allocation request or decrease the count after a release request.\nThis option is easy to implement at a cost of write performance (more DB access!).\nOption 2 In-Memory Counter with Background Monitoring:\nEach Mac Manager Instance has an in-memory counter that tracks the utilization of each range. The counter gets updated by a running monitoring thread in a periodic manner. This thread should run not very frequently, say every 30 minutes or so, and keep the counter always up-to-date. The allocation/release request only needs to read the in-memory counter but no obligation to update it.\nNOTE that when every Mac Manager instance launches or restart, it also needs to initialize its in-memory counter.", "author": "xieus", "createdAt": "2020-07-10T03:40:08Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/service/implement/MacServiceImpl.java", "diffHunk": "@@ -100,13 +94,26 @@ public MacState getMacStateByMacAddress(String macAddress) throws ParameterNullO\n     public MacState createMacState(MacState macState) throws ParameterNullOrEmptyException, MacRepositoryTransactionErrorException, MacRangeInvalidException, MacAddressUniquenessViolationException, MacAddressFullException, MacAddressRetryLimitExceedException {\n         if (macState == null)\n             throw (new ParameterNullOrEmptyException(MacManagerConstant.MAC_EXCEPTION_PARAMETER_NULL_EMPTY));\n+\n+        String macAddress = macState.getMacAddress();\n+        if(!StringUtils.isEmpty(macAddress)){\n+            try {\n+                MacState dbMacState = macStateRepository.findItem(macAddress);\n+                if(dbMacState != null){\n+                    throw new MacAddressUniquenessViolationException(\"mac address is in use!\");\n+                }\n+                macStateRepository.addItem(macState);\n+                return macState;\n+            } catch (CacheException e) {\n+                throw new MacRepositoryTransactionErrorException(\"create mac address failed :\" + e.getMessage());\n+            }\n+        }\n+\n         String rangeId = MacManagerConstant.DEFAULT_RANGE;", "originalCommit": "8148a7dd02e0887c9430c60fcb5775bac102017c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MTk2Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456451966", "bodyText": "We could consider it as a future improvement we might not hit the issue in short term.\nCreate a tracking item #302. Please ack on that item so that it could be assigned to you @Gzure", "author": "xieus", "createdAt": "2020-07-17T13:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNTU2NA=="}], "type": "inlineReview"}, {"oid": "23a1c80f83f60ea3d100d2c4cc55d03b8cddc328", "url": "https://github.com/futurewei-cloud/alcor/commit/23a1c80f83f60ea3d100d2c4cc55d03b8cddc328", "message": "rewrite mac manager", "committedDate": "2020-07-15T03:51:11Z", "type": "commit"}, {"oid": "bcbaab66cf62d1d057502e5e4b7251c6ad9f5940", "url": "https://github.com/futurewei-cloud/alcor/commit/bcbaab66cf62d1d057502e5e4b7251c6ad9f5940", "message": "change UTS pass", "committedDate": "2020-07-15T03:51:11Z", "type": "commit"}, {"oid": "31b5b0c049c114a3e6aae57d7cde7f7b4a568f4c", "url": "https://github.com/futurewei-cloud/alcor/commit/31b5b0c049c114a3e6aae57d7cde7f7b4a568f4c", "message": "add some new APIS in db related", "committedDate": "2020-07-15T04:00:31Z", "type": "commit"}, {"oid": "7db53ecbe92d90ae4ae093f1dc69d2e8f2904b85", "url": "https://github.com/futurewei-cloud/alcor/commit/7db53ecbe92d90ae4ae093f1dc69d2e8f2904b85", "message": "add bulk create mac operations", "committedDate": "2020-07-15T04:00:34Z", "type": "commit"}, {"oid": "556ec6f26d3e37e57aeaab726dc7d3124edb426b", "url": "https://github.com/futurewei-cloud/alcor/commit/556ec6f26d3e37e57aeaab726dc7d3124edb426b", "message": "add bulk create mac operations", "committedDate": "2020-07-15T04:00:34Z", "type": "commit"}, {"oid": "73fdc795436f97b8bde828a6fc9a7e616fb1794f", "url": "https://github.com/futurewei-cloud/alcor/commit/73fdc795436f97b8bde828a6fc9a7e616fb1794f", "message": "remove trylock", "committedDate": "2020-07-15T04:03:00Z", "type": "commit"}, {"oid": "e005acc69fca4d64a07ffe3a7a9ac9330fd9e289", "url": "https://github.com/futurewei-cloud/alcor/commit/e005acc69fca4d64a07ffe3a7a9ac9330fd9e289", "message": "remove tryLock exception", "committedDate": "2020-07-15T06:11:06Z", "type": "commit"}, {"oid": "e005acc69fca4d64a07ffe3a7a9ac9330fd9e289", "url": "https://github.com/futurewei-cloud/alcor/commit/e005acc69fca4d64a07ffe3a7a9ac9330fd9e289", "message": "remove tryLock exception", "committedDate": "2020-07-15T06:11:06Z", "type": "forcePushed"}, {"oid": "ceb5adc3ec9cdb9232bebc1f533606a349aaf46a", "url": "https://github.com/futurewei-cloud/alcor/commit/ceb5adc3ec9cdb9232bebc1f533606a349aaf46a", "message": "add a common MacPoolApi for different algorithm implement\nadd a new mac allocate algorithm", "committedDate": "2020-07-15T10:56:23Z", "type": "commit"}, {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "url": "https://github.com/futurewei-cloud/alcor/commit/97c15d8679d1a23aa56c1ac604501a0fa525767a", "message": "add default constructor", "committedDate": "2020-07-16T04:29:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMDUyMA==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456500520", "bodyText": "Clean up MacRange.bitset in next round.", "author": "xieus", "createdAt": "2020-07-17T15:04:42Z", "path": "web/src/main/java/com/futurewei/alcor/web/entity/mac/MacRange.java", "diffHunk": "@@ -35,8 +36,9 @@\n     @JsonProperty(\"state\")\n     private String state;\n \n-    @JsonIgnore\n-    private BitSet bitSet;\n+    private long capacity;\n+//    @JsonIgnore", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMzg1Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456503856", "bodyText": "let us use verb for method name just for consistency.\nrangeSize => getRangeSize\nrangeAvailableSize => getRangeRemainingCapacity", "author": "xieus", "createdAt": "2020-07-17T15:10:11Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/MacPoolApi.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+\n+import java.util.Set;\n+\n+public interface MacPoolApi {\n+\n+    /**\n+     * allocate a new mac\n+     * @return\n+     */\n+    String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException;\n+\n+    /**\n+     * allocate multi macs once\n+     * @param size\n+     * @return\n+     */\n+    Set<String> allocateBulk(String oui, MacRange macRange, int size)  throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException ;\n+\n+    /**\n+     * reclaim a mac\n+     * @param rangeId\n+     * @param mac\n+     * @return\n+     */\n+    Boolean reclaim(String rangeId, String oui, String mac);\n+\n+    /**\n+     * allocate a new mac form foreign\n+     * @param rangeId\n+     * @param oui\n+     * @param mac\n+     */\n+    void markMac(String rangeId, String oui, String mac) throws CacheException, DistributedLockException;\n+\n+    /**\n+     * get a range total size\n+     * @param rangeId\n+     * @return\n+     */\n+    long rangeSize(String rangeId) throws CacheException;", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwNDY2MA==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456504660", "bodyText": "This is an excellent interface which allows different implementation of allocation algorithm and performance comparison.", "author": "xieus", "createdAt": "2020-07-17T15:11:26Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/MacPoolApi.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+\n+import java.util.Set;\n+\n+public interface MacPoolApi {", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwNTEyMw==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456505123", "bodyText": "We will need to get some performance number for this new allocation algorithm. @Gzure", "author": "xieus", "createdAt": "2020-07-17T15:12:16Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.db.CacheFactory;\n+import com.futurewei.alcor.common.db.DistributedLockFactory;\n+import com.futurewei.alcor.common.db.IDistributedLock;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.dao.MacRangePartitionRepository;\n+import com.futurewei.alcor.macmanager.dao.MacStateRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.exception.MacRepositoryTransactionErrorException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import com.futurewei.alcor.web.entity.mac.MacRangePartition;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+//@Component", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwODc1Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456508757", "bodyText": "Need to add these new configurations in application.properties and kubernetes yaml files (configMap session) @Gzure", "author": "xieus", "createdAt": "2020-07-17T15:18:17Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwOTQ3NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456509474", "bodyText": "A recommended format is like\nmacmanager.pool.low_request_numers = 10\nmacmanager.pool.middle_request_numers = 20\nmacmanager.pool.high_request_numers = 60\n....", "author": "xieus", "createdAt": "2020-07-17T15:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwODc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxNjY3Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456516676", "bodyText": "Recommend to rename loadRate to usedRatio", "author": "xieus", "createdAt": "2020-07-17T15:31:39Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")\n+    private int lowRequestNumbers;\n+\n+    @Value(\"${middle-request-numbers: 20}\")\n+    private int middleRequestNumbers;\n+\n+    @Value(\"${high-request-numbers: 60}\")\n+    private int highRequestNumbers;\n+\n+    @Value(\"${top-request-numbers: 400}\")\n+    private int topRequestNumbers;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException {\n+\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        float loadRate = (float) used/macRange.getCapacity();", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyMTM0NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456521344", "bodyText": "macs.add(i)? @Gzure", "author": "xieus", "createdAt": "2020-07-17T15:39:57Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")\n+    private int lowRequestNumbers;\n+\n+    @Value(\"${middle-request-numbers: 20}\")\n+    private int middleRequestNumbers;\n+\n+    @Value(\"${high-request-numbers: 60}\")\n+    private int highRequestNumbers;\n+\n+    @Value(\"${top-request-numbers: 400}\")\n+    private int topRequestNumbers;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException {\n+\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        float loadRate = (float) used/macRange.getCapacity();\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+            if (loadRate < BOTTOM_LOAD_FACTOR) {\n+                if(check(rangeId, next)){\n+                    return longToMac(oui, next);\n+                }\n+            }else {\n+                int requestNumbers = getRequestNumbers(loadRate);\n+                requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+                long left = next - requestNumbers / 2;\n+                long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+                if (left < start) {\n+                    right += start - left;\n+                    left = start;\n+                }\n+\n+                if (right > end) {\n+                    left -= right - end;\n+                    right = end + 1;\n+                }\n+\n+                if(requestNumbers > MUTIL_QUERY_THRESHOLD){\n+                    Set<Long> macs = new HashSet<>();\n+                    for (long i = left; i < right; i++) {\n+                        macs.add(i);\n+                    }\n+                    Set<Long> newMacs = checkMulti(rangeId, macs);\n+                    if(newMacs != null){\n+                        for(Long macLong: newMacs){\n+                            if(check(rangeId, macLong)){\n+                                return longToMac(oui, macLong);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    for (long i = left; i < right; i++) {\n+                        if(check(rangeId, i)){\n+                            return longToMac(oui, i);\n+                        };\n+                    }\n+                }\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocateMacs = new HashSet<>(size);\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+\n+            int requestNumbers = size;\n+            requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+            long left = next - requestNumbers / 2;\n+            long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+            if (left < start) {\n+                right += start - left;\n+                left = start;\n+            }\n+\n+            if (right > end) {\n+                left -= right - end;\n+                right = end + 1;\n+            }\n+\n+            Set<Long> macs = new HashSet<>();\n+            for (long i = left; i < right; i++) {\n+                macs.add(next);", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyMjYwMg==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456522602", "bodyText": "Recommend to give a more specific name like\ncheckMulti => retrieveMultiMacAddresses\ncheck => tryAllocateMacAddress", "author": "xieus", "createdAt": "2020-07-17T15:42:15Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")\n+    private int lowRequestNumbers;\n+\n+    @Value(\"${middle-request-numbers: 20}\")\n+    private int middleRequestNumbers;\n+\n+    @Value(\"${high-request-numbers: 60}\")\n+    private int highRequestNumbers;\n+\n+    @Value(\"${top-request-numbers: 400}\")\n+    private int topRequestNumbers;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException {\n+\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        float loadRate = (float) used/macRange.getCapacity();\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+            if (loadRate < BOTTOM_LOAD_FACTOR) {\n+                if(check(rangeId, next)){\n+                    return longToMac(oui, next);\n+                }\n+            }else {\n+                int requestNumbers = getRequestNumbers(loadRate);\n+                requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+                long left = next - requestNumbers / 2;\n+                long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+                if (left < start) {\n+                    right += start - left;\n+                    left = start;\n+                }\n+\n+                if (right > end) {\n+                    left -= right - end;\n+                    right = end + 1;\n+                }\n+\n+                if(requestNumbers > MUTIL_QUERY_THRESHOLD){\n+                    Set<Long> macs = new HashSet<>();\n+                    for (long i = left; i < right; i++) {\n+                        macs.add(i);\n+                    }\n+                    Set<Long> newMacs = checkMulti(rangeId, macs);\n+                    if(newMacs != null){\n+                        for(Long macLong: newMacs){\n+                            if(check(rangeId, macLong)){\n+                                return longToMac(oui, macLong);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    for (long i = left; i < right; i++) {\n+                        if(check(rangeId, i)){\n+                            return longToMac(oui, i);\n+                        };\n+                    }\n+                }\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocateMacs = new HashSet<>(size);\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+\n+            int requestNumbers = size;\n+            requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+            long left = next - requestNumbers / 2;\n+            long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+            if (left < start) {\n+                right += start - left;\n+                left = start;\n+            }\n+\n+            if (right > end) {\n+                left -= right - end;\n+                right = end + 1;\n+            }\n+\n+            Set<Long> macs = new HashSet<>();\n+            for (long i = left; i < right; i++) {\n+                macs.add(next);\n+            }\n+            Set<Long> newMacs = checkMulti(rangeId, macs);\n+            if(newMacs != null){\n+                for(Long macLong: newMacs){\n+                    if(check(rangeId, macLong)){\n+                        newAllocateMacs.add(longToMac(oui, macLong));\n+                    }\n+                }\n+            }\n+            if (newAllocateMacs.size() >= size){\n+                return newAllocateMacs;\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Boolean reclaim(String rangeId, String oui, String mac) {\n+        try {\n+            Long macLong = macToLong(getMacSuffix(oui, mac));\n+            return macRangeMappingRepository.releaseMac(rangeId, macLong);\n+        } catch (CacheException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public long rangeSize(String rangeId) throws CacheException {\n+        return macRangeMappingRepository.size(rangeId);\n+    }\n+\n+    @Override\n+    public long rangeAvailableSize(MacRange macRange) throws CacheException {\n+        long size = macRangeMappingRepository.size(macRange.getRangeId());\n+        return macRange.getCapacity() - size;\n+    }\n+\n+    @Override\n+    public void markMac(String rangeId, String oui, String mac) throws CacheException {\n+        Long macLong = macToLong(getMacSuffix(oui, mac));\n+        macRangeMappingRepository.putIfAbsent(rangeId, macLong);\n+    }\n+\n+    private int getRequestNumbers(float loadRate){\n+        if (loadRate < LOW_LOAD_FACTOR){\n+            return lowRequestNumbers;\n+        }else if (loadRate < MIDDLE_LOAD_FACTOR){\n+            return middleRequestNumbers;\n+        }else if (loadRate < HIGH_LOAD_FACTOR){\n+            return highRequestNumbers;\n+        }\n+        return topRequestNumbers;\n+    }\n+\n+    private boolean check(String rangeId, Long macLong){\n+        try {\n+            return macRangeMappingRepository.putIfAbsent(rangeId, macLong);\n+        } catch (CacheException e) {\n+            return false;\n+        }\n+    }\n+\n+    private Set<Long> checkMulti(String rangeId, Set<Long> macs){", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyNTc0Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456525747", "bodyText": "The \"if(newAllocateMacs.size() >= size)\" loop needs to move inside the for loop. Otherwise, we allocate more than what is needed.\n@Gzure Please try to fix this issue in next PR.", "author": "xieus", "createdAt": "2020-07-17T15:47:44Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")\n+    private int lowRequestNumbers;\n+\n+    @Value(\"${middle-request-numbers: 20}\")\n+    private int middleRequestNumbers;\n+\n+    @Value(\"${high-request-numbers: 60}\")\n+    private int highRequestNumbers;\n+\n+    @Value(\"${top-request-numbers: 400}\")\n+    private int topRequestNumbers;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException {\n+\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        float loadRate = (float) used/macRange.getCapacity();\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+            if (loadRate < BOTTOM_LOAD_FACTOR) {\n+                if(check(rangeId, next)){\n+                    return longToMac(oui, next);\n+                }\n+            }else {\n+                int requestNumbers = getRequestNumbers(loadRate);\n+                requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+                long left = next - requestNumbers / 2;\n+                long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+                if (left < start) {\n+                    right += start - left;\n+                    left = start;\n+                }\n+\n+                if (right > end) {\n+                    left -= right - end;\n+                    right = end + 1;\n+                }\n+\n+                if(requestNumbers > MUTIL_QUERY_THRESHOLD){\n+                    Set<Long> macs = new HashSet<>();\n+                    for (long i = left; i < right; i++) {\n+                        macs.add(i);\n+                    }\n+                    Set<Long> newMacs = checkMulti(rangeId, macs);\n+                    if(newMacs != null){\n+                        for(Long macLong: newMacs){\n+                            if(check(rangeId, macLong)){\n+                                return longToMac(oui, macLong);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    for (long i = left; i < right; i++) {\n+                        if(check(rangeId, i)){\n+                            return longToMac(oui, i);\n+                        };\n+                    }\n+                }\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocateMacs = new HashSet<>(size);\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+\n+            int requestNumbers = size;\n+            requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+            long left = next - requestNumbers / 2;\n+            long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+            if (left < start) {\n+                right += start - left;\n+                left = start;\n+            }\n+\n+            if (right > end) {\n+                left -= right - end;\n+                right = end + 1;\n+            }\n+\n+            Set<Long> macs = new HashSet<>();\n+            for (long i = left; i < right; i++) {\n+                macs.add(next);\n+            }\n+            Set<Long> newMacs = checkMulti(rangeId, macs);\n+            if(newMacs != null){\n+                for(Long macLong: newMacs){\n+                    if(check(rangeId, macLong)){\n+                        newAllocateMacs.add(longToMac(oui, macLong));\n+                    }\n+                }\n+            }\n+            if (newAllocateMacs.size() >= size){\n+                return newAllocateMacs;\n+            }", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyNjI3Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456526276", "bodyText": "reclaim => release", "author": "xieus", "createdAt": "2020-07-17T15:48:40Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")\n+    private int lowRequestNumbers;\n+\n+    @Value(\"${middle-request-numbers: 20}\")\n+    private int middleRequestNumbers;\n+\n+    @Value(\"${high-request-numbers: 60}\")\n+    private int highRequestNumbers;\n+\n+    @Value(\"${top-request-numbers: 400}\")\n+    private int topRequestNumbers;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException {\n+\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        float loadRate = (float) used/macRange.getCapacity();\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+            if (loadRate < BOTTOM_LOAD_FACTOR) {\n+                if(check(rangeId, next)){\n+                    return longToMac(oui, next);\n+                }\n+            }else {\n+                int requestNumbers = getRequestNumbers(loadRate);\n+                requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+                long left = next - requestNumbers / 2;\n+                long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+                if (left < start) {\n+                    right += start - left;\n+                    left = start;\n+                }\n+\n+                if (right > end) {\n+                    left -= right - end;\n+                    right = end + 1;\n+                }\n+\n+                if(requestNumbers > MUTIL_QUERY_THRESHOLD){\n+                    Set<Long> macs = new HashSet<>();\n+                    for (long i = left; i < right; i++) {\n+                        macs.add(i);\n+                    }\n+                    Set<Long> newMacs = checkMulti(rangeId, macs);\n+                    if(newMacs != null){\n+                        for(Long macLong: newMacs){\n+                            if(check(rangeId, macLong)){\n+                                return longToMac(oui, macLong);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    for (long i = left; i < right; i++) {\n+                        if(check(rangeId, i)){\n+                            return longToMac(oui, i);\n+                        };\n+                    }\n+                }\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocateMacs = new HashSet<>(size);\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+\n+            int requestNumbers = size;\n+            requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+            long left = next - requestNumbers / 2;\n+            long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+            if (left < start) {\n+                right += start - left;\n+                left = start;\n+            }\n+\n+            if (right > end) {\n+                left -= right - end;\n+                right = end + 1;\n+            }\n+\n+            Set<Long> macs = new HashSet<>();\n+            for (long i = left; i < right; i++) {\n+                macs.add(next);\n+            }\n+            Set<Long> newMacs = checkMulti(rangeId, macs);\n+            if(newMacs != null){\n+                for(Long macLong: newMacs){\n+                    if(check(rangeId, macLong)){\n+                        newAllocateMacs.add(longToMac(oui, macLong));\n+                    }\n+                }\n+            }\n+            if (newAllocateMacs.size() >= size){\n+                return newAllocateMacs;\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Boolean reclaim(String rangeId, String oui, String mac) {", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyNzA0OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456527049", "bodyText": "The method name \"macRangeMappingRepository.size\" is recommended to change to\nmacRangeMappingRepository.getUsedCapacity", "author": "xieus", "createdAt": "2020-07-17T15:50:01Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")\n+    private int lowRequestNumbers;\n+\n+    @Value(\"${middle-request-numbers: 20}\")\n+    private int middleRequestNumbers;\n+\n+    @Value(\"${high-request-numbers: 60}\")\n+    private int highRequestNumbers;\n+\n+    @Value(\"${top-request-numbers: 400}\")\n+    private int topRequestNumbers;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException {\n+\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        float loadRate = (float) used/macRange.getCapacity();\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+            if (loadRate < BOTTOM_LOAD_FACTOR) {\n+                if(check(rangeId, next)){\n+                    return longToMac(oui, next);\n+                }\n+            }else {\n+                int requestNumbers = getRequestNumbers(loadRate);\n+                requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+                long left = next - requestNumbers / 2;\n+                long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+                if (left < start) {\n+                    right += start - left;\n+                    left = start;\n+                }\n+\n+                if (right > end) {\n+                    left -= right - end;\n+                    right = end + 1;\n+                }\n+\n+                if(requestNumbers > MUTIL_QUERY_THRESHOLD){\n+                    Set<Long> macs = new HashSet<>();\n+                    for (long i = left; i < right; i++) {\n+                        macs.add(i);\n+                    }\n+                    Set<Long> newMacs = checkMulti(rangeId, macs);\n+                    if(newMacs != null){\n+                        for(Long macLong: newMacs){\n+                            if(check(rangeId, macLong)){\n+                                return longToMac(oui, macLong);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    for (long i = left; i < right; i++) {\n+                        if(check(rangeId, i)){\n+                            return longToMac(oui, i);\n+                        };\n+                    }\n+                }\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocateMacs = new HashSet<>(size);\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+\n+            int requestNumbers = size;\n+            requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+            long left = next - requestNumbers / 2;\n+            long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+            if (left < start) {\n+                right += start - left;\n+                left = start;\n+            }\n+\n+            if (right > end) {\n+                left -= right - end;\n+                right = end + 1;\n+            }\n+\n+            Set<Long> macs = new HashSet<>();\n+            for (long i = left; i < right; i++) {\n+                macs.add(next);\n+            }\n+            Set<Long> newMacs = checkMulti(rangeId, macs);\n+            if(newMacs != null){\n+                for(Long macLong: newMacs){\n+                    if(check(rangeId, macLong)){\n+                        newAllocateMacs.add(longToMac(oui, macLong));\n+                    }\n+                }\n+            }\n+            if (newAllocateMacs.size() >= size){\n+                return newAllocateMacs;\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Boolean reclaim(String rangeId, String oui, String mac) {\n+        try {\n+            Long macLong = macToLong(getMacSuffix(oui, mac));\n+            return macRangeMappingRepository.releaseMac(rangeId, macLong);\n+        } catch (CacheException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public long rangeSize(String rangeId) throws CacheException {\n+        return macRangeMappingRepository.size(rangeId);\n+    }\n+\n+    @Override\n+    public long rangeAvailableSize(MacRange macRange) throws CacheException {\n+        long size = macRangeMappingRepository.size(macRange.getRangeId());", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUzNjk0NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456536945", "bodyText": "I don't think we should increase Used value in this case.", "author": "xieus", "createdAt": "2020-07-17T16:08:08Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.db.CacheFactory;\n+import com.futurewei.alcor.common.db.DistributedLockFactory;\n+import com.futurewei.alcor.common.db.IDistributedLock;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.dao.MacRangePartitionRepository;\n+import com.futurewei.alcor.macmanager.dao.MacStateRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.exception.MacRepositoryTransactionErrorException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import com.futurewei.alcor.web.entity.mac.MacRangePartition;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+//@Component\n+public class BitmapPoolImpl implements MacPoolApi {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(BitmapPoolImpl.class);\n+\n+    private static final int PARTITION_SIZE = 4096;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangePartitionRepository macRangePartitionRepository;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    private final IDistributedLock lock;\n+\n+    @Autowired\n+    public BitmapPoolImpl(DistributedLockFactory cacheFactory){\n+        lock = cacheFactory.getDistributedLock(MacRangePartition.class);\n+    }\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException,\n+            MacAddressRetryLimitExceedException, CacheException {\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int partitionNubs = (int) (macRange.getCapacity()/PARTITION_SIZE + 1);\n+        int partitionIndex = 0;\n+        int retryTime = 0;\n+        while (retryTime < nRetryLimit) {\n+\n+            boolean locked = false;\n+            while (!locked) {\n+                partitionIndex = RandomUtils.nextInt(0, partitionNubs);\n+                locked = lock.tryLock(rangeId + \"_\" + partitionIndex);\n+            }\n+\n+            String id = rangeId + \"_\" + partitionIndex;\n+            try {\n+                boolean needUpdate = false;\n+                MacRangePartition macRangePartition = macRangePartitionRepository.findItem(id);\n+\n+                // if null create a new one\n+                if (macRangePartition == null) {\n+                    macRangePartition = new MacRangePartition(id, partitionIndex, PARTITION_SIZE * partitionIndex,\n+                            PARTITION_SIZE * (partitionIndex + 1));\n+                    needUpdate = true;\n+                }\n+\n+                while (macRangePartition.getUsed() < macRangePartition.getTotal()) {\n+                    long macLong = generate(macRangePartition);\n+                    if(check(rangeId, macLong)) {\n+                        macRangePartition.incUsed();\n+                        macRangePartitionRepository.addItem(macRangePartition);\n+                        return longToMac(oui, macLong);\n+                    }else{\n+                        // if not put success, it already allocated\n+                        macRangePartition.incUsed();", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUzOTkwNw==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456539907", "bodyText": "If put is not successful, we shouldn't increase the Used value, right?", "author": "xieus", "createdAt": "2020-07-17T16:13:47Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.db.CacheFactory;\n+import com.futurewei.alcor.common.db.DistributedLockFactory;\n+import com.futurewei.alcor.common.db.IDistributedLock;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.dao.MacRangePartitionRepository;\n+import com.futurewei.alcor.macmanager.dao.MacStateRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.exception.MacRepositoryTransactionErrorException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import com.futurewei.alcor.web.entity.mac.MacRangePartition;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+//@Component\n+public class BitmapPoolImpl implements MacPoolApi {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(BitmapPoolImpl.class);\n+\n+    private static final int PARTITION_SIZE = 4096;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangePartitionRepository macRangePartitionRepository;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    private final IDistributedLock lock;\n+\n+    @Autowired\n+    public BitmapPoolImpl(DistributedLockFactory cacheFactory){\n+        lock = cacheFactory.getDistributedLock(MacRangePartition.class);\n+    }\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException,\n+            MacAddressRetryLimitExceedException, CacheException {\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int partitionNubs = (int) (macRange.getCapacity()/PARTITION_SIZE + 1);\n+        int partitionIndex = 0;\n+        int retryTime = 0;\n+        while (retryTime < nRetryLimit) {\n+\n+            boolean locked = false;\n+            while (!locked) {\n+                partitionIndex = RandomUtils.nextInt(0, partitionNubs);\n+                locked = lock.tryLock(rangeId + \"_\" + partitionIndex);\n+            }\n+\n+            String id = rangeId + \"_\" + partitionIndex;\n+            try {\n+                boolean needUpdate = false;\n+                MacRangePartition macRangePartition = macRangePartitionRepository.findItem(id);\n+\n+                // if null create a new one\n+                if (macRangePartition == null) {\n+                    macRangePartition = new MacRangePartition(id, partitionIndex, PARTITION_SIZE * partitionIndex,\n+                            PARTITION_SIZE * (partitionIndex + 1));\n+                    needUpdate = true;\n+                }\n+\n+                while (macRangePartition.getUsed() < macRangePartition.getTotal()) {\n+                    long macLong = generate(macRangePartition);\n+                    if(check(rangeId, macLong)) {\n+                        macRangePartition.incUsed();\n+                        macRangePartitionRepository.addItem(macRangePartition);\n+                        return longToMac(oui, macLong);\n+                    }else{\n+                        // if not put success, it already allocated\n+                        macRangePartition.incUsed();\n+                        needUpdate = true;\n+                    }\n+                }\n+\n+                if (needUpdate) {\n+                    macRangePartitionRepository.addItem(macRangePartition);\n+                }\n+\n+            } finally {\n+                try {\n+                    lock.unlock(id);\n+                } catch (DistributedLockException e) {\n+                    logger.error(\"unlock cluster lock {} failed: {}\", id, e.getMessage());\n+                }\n+            }\n+        }\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException,\n+            MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocatedMacs = new HashSet<>();\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        if(used + size >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int partitionNums = (int) (macRange.getCapacity()/PARTITION_SIZE + 1);\n+        int partitionIndex = 0;\n+        int retryTime = 0;\n+        while (retryTime < nRetryLimit) {\n+\n+            boolean locked = false;\n+            while (!locked) {\n+                partitionIndex = RandomUtils.nextInt(0, partitionNums);\n+                locked = lock.tryLock(rangeId + \"_\" + partitionIndex);\n+            }\n+\n+            String id = rangeId + \"_\" + partitionIndex;\n+            try {\n+                boolean needUpdate = false;\n+                MacRangePartition macRangePartition = macRangePartitionRepository.findItem(id);\n+\n+                // if null create a new one\n+                if (macRangePartition == null) {\n+                    macRangePartition = new MacRangePartition(id, partitionIndex, PARTITION_SIZE * partitionIndex,\n+                            PARTITION_SIZE * (partitionIndex + 1));\n+                    needUpdate = true;\n+                }\n+\n+                while (macRangePartition.getUsed() < macRangePartition.getTotal()) {\n+                    long macLong = generate(macRangePartition);\n+                    if(check(rangeId, macLong)) {\n+                        macRangePartition.incUsed();\n+                        needUpdate = true;\n+                        newAllocatedMacs.add(longToMac(oui, macLong));\n+                        if(newAllocatedMacs.size() >= size){\n+                            macRangePartitionRepository.addItem(macRangePartition);\n+                            return newAllocatedMacs;\n+                        }\n+                    }else{\n+                        // if not put success, it already allocated", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4Njg2Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456986863", "bodyText": "If the MAC address fails to be added to the MAC address table, the MAC address is in use.", "author": "Gzure", "createdAt": "2020-07-20T01:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUzOTkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU0MjU2MQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456542561", "bodyText": "Going through the whole algorithm, we didn't find the usage of MacRangePartition.setBitSet.\nIn the current implementation, it seems that the allocation is still using the range-level BitSet, instead of using the partition-level BitSet. If we have partition-level bitset, the range-level one should be abandoned.\nLet us discuss more in next open-source meeting.", "author": "xieus", "createdAt": "2020-07-17T16:19:10Z", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.db.CacheFactory;\n+import com.futurewei.alcor.common.db.DistributedLockFactory;\n+import com.futurewei.alcor.common.db.IDistributedLock;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.dao.MacRangePartitionRepository;\n+import com.futurewei.alcor.macmanager.dao.MacStateRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.exception.MacRepositoryTransactionErrorException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import com.futurewei.alcor.web.entity.mac.MacRangePartition;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+//@Component\n+public class BitmapPoolImpl implements MacPoolApi {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(BitmapPoolImpl.class);\n+\n+    private static final int PARTITION_SIZE = 4096;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangePartitionRepository macRangePartitionRepository;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    private final IDistributedLock lock;\n+\n+    @Autowired\n+    public BitmapPoolImpl(DistributedLockFactory cacheFactory){\n+        lock = cacheFactory.getDistributedLock(MacRangePartition.class);\n+    }\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException,", "originalCommit": "97c15d8679d1a23aa56c1ac604501a0fa525767a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}