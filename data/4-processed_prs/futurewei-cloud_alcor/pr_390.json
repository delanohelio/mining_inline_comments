{"pr_number": 390, "pr_title": "[Documentation] Security Group Host Design", "pr_createdAt": "2020-09-23T23:21:41Z", "pr_url": "https://github.com/futurewei-cloud/alcor/pull/390", "timeline": [{"oid": "0cda73d8a8434407b062628521bb8e062421614f", "url": "https://github.com/futurewei-cloud/alcor/commit/0cda73d8a8434407b062628521bb8e062421614f", "message": "security group host design draft", "committedDate": "2020-09-23T20:55:14Z", "type": "commit"}, {"oid": "024f751dcd7ff2c3451c0c012e57fcaa9d2968ed", "url": "https://github.com/futurewei-cloud/alcor/commit/024f751dcd7ff2c3451c0c012e57fcaa9d2968ed", "message": "update text format", "committedDate": "2020-09-24T01:41:15Z", "type": "commit"}, {"oid": "ec33cd9ff7276dadacf381431eb0cb90cd935ca5", "url": "https://github.com/futurewei-cloud/alcor/commit/ec33cd9ff7276dadacf381431eb0cb90cd935ca5", "message": "added picture for remote SG rule", "committedDate": "2020-09-24T02:24:00Z", "type": "commit"}, {"oid": "22235f1133dbc776b47aedbc8302c995de6bffc5", "url": "https://github.com/futurewei-cloud/alcor/commit/22235f1133dbc776b47aedbc8302c995de6bffc5", "message": "updated doc and added workflow", "committedDate": "2020-09-28T23:06:35Z", "type": "commit"}, {"oid": "ce7b3afb6f70034ddcaee5dea94cefed3579bdf4", "url": "https://github.com/futurewei-cloud/alcor/commit/ce7b3afb6f70034ddcaee5dea94cefed3579bdf4", "message": "added implementation proposal", "committedDate": "2020-09-29T16:21:46Z", "type": "commit"}, {"oid": "99b343881ce728462a1ac1c8d90279a796a703fd", "url": "https://github.com/futurewei-cloud/alcor/commit/99b343881ce728462a1ac1c8d90279a796a703fd", "message": "update workflow", "committedDate": "2020-09-30T02:04:44Z", "type": "commit"}, {"oid": "7142f9427b2ab124ec6f3e952eee96d448bf8ed8", "url": "https://github.com/futurewei-cloud/alcor/commit/7142f9427b2ab124ec6f3e952eee96d448bf8ed8", "message": "added delta update detail and start adding table info", "committedDate": "2020-10-01T18:56:18Z", "type": "commit"}, {"oid": "8ebba639aed2c37941563d148fe9f854c3194579", "url": "https://github.com/futurewei-cloud/alcor/commit/8ebba639aed2c37941563d148fe9f854c3194579", "message": "adding more openflow table info - WIP", "committedDate": "2020-10-02T20:33:58Z", "type": "commit"}, {"oid": "3296b228d7034c5efbf8462614edda98b396f8e4", "url": "https://github.com/futurewei-cloud/alcor/commit/3296b228d7034c5efbf8462614edda98b396f8e4", "message": "Merge branch 'master' into doc/security_group", "committedDate": "2020-10-03T11:55:39Z", "type": "commit"}, {"oid": "2739972e8f37445babbf620b5653bfe960d0b1ba", "url": "https://github.com/futurewei-cloud/alcor/commit/2739972e8f37445babbf620b5653bfe960d0b1ba", "message": "Update context and correct grammar errors", "committedDate": "2020-10-03T12:54:04Z", "type": "commit"}, {"oid": "b731a8a78ea59e72d7c9837e194cbbd0b2c8dd46", "url": "https://github.com/futurewei-cloud/alcor/commit/b731a8a78ea59e72d7c9837e194cbbd0b2c8dd46", "message": "added more openflow table info", "committedDate": "2020-10-05T05:31:28Z", "type": "commit"}, {"oid": "eef9b03e59a3158337200810e37b533e43e74323", "url": "https://github.com/futurewei-cloud/alcor/commit/eef9b03e59a3158337200810e37b533e43e74323", "message": "added wording about the quoted text", "committedDate": "2020-10-05T17:53:51Z", "type": "commit"}, {"oid": "d66b54de0b0a65f6e930f20598ace1e7d720ccd5", "url": "https://github.com/futurewei-cloud/alcor/commit/d66b54de0b0a65f6e930f20598ace1e7d720ccd5", "message": "added recommended code changes session", "committedDate": "2020-10-08T23:54:28Z", "type": "commit"}, {"oid": "71b5914ee689550db032629e4d8ec3b6fd1368b1", "url": "https://github.com/futurewei-cloud/alcor/commit/71b5914ee689550db032629e4d8ec3b6fd1368b1", "message": "update session name", "committedDate": "2020-10-08T23:55:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxMjg3OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r503012879", "bodyText": "Do we only consider delta update between DPM and ACA? Dose delta update for ovs flows are considered here?", "author": "chenpiaoping", "createdAt": "2020-10-12T02:52:04Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,466 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;", "originalCommit": "71b5914ee689550db032629e4d8ec3b6fd1368b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY3NTQxOQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r503675419", "bodyText": "yes, we will need delta update for ovs flows also. In order to support that, security group implementation in ACA will need to keep an internal map of port to security group (and its rules) mapping. Keep it in runtime memory would work, but it will not survive reboot/crash and hard to support older ACA to new ACA update (note that this problem is also applicable to ther ACA modules which is runtime memory as storage).", "author": "er1cthe0ne", "createdAt": "2020-10-13T05:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxMjg3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwMTE4OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r503701188", "bodyText": "Consider the situation where the security rules of two security groups of a port overlap. If we delete the security group rules of the overlapping part of one of the security groups, it will be troublesome to deal with them by delta update.", "author": "chenpiaoping", "createdAt": "2020-10-13T06:41:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxMjg3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0NzM0NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r504347345", "bodyText": "Let's step back to the advantage of ACA vs neutron OVS agent:\n\nplan to survive ACA crash or migration from older ACA to new ACA\ndelta update when only one security group rule is added/deleted/modified\n\nBoth of them requires ACA to keep an internal map of port to security group (and its rules) mapping. With this internal map, we can accept delta update and figure out the minimal set of openflow rule to modify.", "author": "er1cthe0ne", "createdAt": "2020-10-14T01:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxMjg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxNjgwMQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r503016801", "bodyText": "How do we do this?", "author": "chenpiaoping", "createdAt": "2020-10-12T03:10:57Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,466 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Only one set of security group rules is configured in OVS to be shared with all ports using it", "originalCommit": "71b5914ee689550db032629e4d8ec3b6fd1368b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NDYwNw==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r503684607", "bodyText": "I will update the wordings to clarify. Please use the below as a reference: Uses of conjunctive flows\nhttps://docs.openstack.org/neutron/train/contributor/internals/openvswitch_firewall.html", "author": "er1cthe0ne", "createdAt": "2020-10-13T05:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxNjgwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwMjA5OA==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r503702098", "bodyText": "Yes, I've read this link. I mean, how do multiple port share a flow?", "author": "chenpiaoping", "createdAt": "2020-10-13T06:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxNjgwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwNTY3NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r503705675", "bodyText": "Let's take the egress flows as an example:\n1.table=TRANSIENT_TABLE,priority=100,in_port=ofport,actions=set_field:{ofport}->reg{REG_PORT},set_field:{local_vlan}->reg{REG_NET},resubmit(,BASE_EGRESS_TABLE)\n2.table=BASE_EGRESS_TABLE,priority=65,reg_port=ofport,dl_type=ETHERTYPE_IP,in_port=ofport,dl_src=mac_addr,nw_src=ip_addr,actions=ct(table={RULES_EGRESS_TABLE},zone=NXM_NX_REG{REG_NET}[0..15])\n3.table=RULES_EGRESS_TABLE,priority=70+,dl_type=ethertype,reg_port=ofport,nw_dst=dst_ip_prefix,nw_proto=protocol,tcp_src=sport,tcp_dst=dport,ct_state=+new-est,actions=resubmit(,ACCEPT_OR_INGRESS_TABLE)\n4.table=ACCEPT_OR_INGRESS_TABLE,priority=90,dl_type=ETHERTYPE_IP,reg_port=ofport,ct_state=+new-est,actions=ct(commit,zone=NXM_NX_REG{REG_NET}[0..15]),resubmit(,ACCEPTED_EGRESS_TRAFFIC_TABLE)\nIf multiple ports share flow#3, what should flows look like?", "author": "chenpiaoping", "createdAt": "2020-10-13T06:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxNjgwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0NzQyNA==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r504347424", "bodyText": "The current design can reuse rule for conjunctive flows only, that's only used for security group rule with remote_group.", "author": "er1cthe0ne", "createdAt": "2020-10-14T01:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxNjgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxNzM5OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r503017399", "bodyText": "Is the pain point of neutron remote_group or is it that multiple vm on the same host share a security group rule?", "author": "chenpiaoping", "createdAt": "2020-10-12T03:13:33Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,466 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Only one set of security group rules is configured in OVS to be shared with all ports using it\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron", "originalCommit": "71b5914ee689550db032629e4d8ec3b6fd1368b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NTMxOQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r503685319", "bodyText": "I believe one of the pain point is having too many openflow rules installed on a compute node. Both neutron remote_group and mutiple VMs (on same host) assoicated to a lot of security group rules would contribute to the pain point.", "author": "er1cthe0ne", "createdAt": "2020-10-13T06:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAxNzM5OQ=="}], "type": "inlineReview"}, {"oid": "8fd3e707ec64386585478235d45fc5e52357adc6", "url": "https://github.com/futurewei-cloud/alcor/commit/8fd3e707ec64386585478235d45fc5e52357adc6", "message": "added vxlan-gpe topic and fix typos", "committedDate": "2020-10-14T23:11:47Z", "type": "commit"}, {"oid": "a73ca7b530e4824a1fe0a24d92424d48b7e1c823", "url": "https://github.com/futurewei-cloud/alcor/commit/a73ca7b530e4824a1fe0a24d92424d48b7e1c823", "message": "improve formatting of openflow rule sample", "committedDate": "2020-10-14T23:54:07Z", "type": "commit"}, {"oid": "084256759bf8050d4a569dbcd48bdbfd49067fba", "url": "https://github.com/futurewei-cloud/alcor/commit/084256759bf8050d4a569dbcd48bdbfd49067fba", "message": "adding vxlan-gpe info", "committedDate": "2020-10-19T21:36:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwMTQ1MA==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515501450", "bodyText": "If the TBD item is done, we can get rid of it here.", "author": "xieus", "createdAt": "2020-10-31T14:16:00Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0MjQ4Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515542486", "bodyText": "yes, TBD is done and I have removed the TBD, comfirmed Neutron agent needs all the security group rule to be pushed down to recompile the IP tables.", "author": "er1cthe0ne", "createdAt": "2020-10-31T21:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwMTQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQyNDYwMg==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r516424602", "bodyText": "Cool and thanks.", "author": "xieus", "createdAt": "2020-11-03T04:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwMTQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNTIwMg==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515505202", "bodyText": "@er1cthe0ne, is this supported in our schema? I think it would be good to include it in this design.", "author": "xieus", "createdAt": "2020-10-31T14:57:53Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0Mjg0NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515542844", "bodyText": "That's the design but not in our schema yet. @chenpiaoping we are going to need this neighbor SG ID in our neighbor configuration for remote SG rules right?", "author": "er1cthe0ne", "createdAt": "2020-10-31T21:40:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNTIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNTQ5MQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515505491", "bodyText": "Line 166-168 is about L2 and L3 neighbors, not directly related to SG. Recommend to move them to other design doc, or create a sub-session for them.", "author": "xieus", "createdAt": "2020-10-31T15:00:45Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.\n+For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).\n+For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0MzE0Nw==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515543147", "bodyText": "The design is the use L3/L2 neighbor state to support SG remote rule, therefore it is related to SG.", "author": "er1cthe0ne", "createdAt": "2020-10-31T21:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNTQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNTk1Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515505953", "bodyText": "match on the \"n\" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports \"m\" associated with this security group.\n=> match on the N IP addresses (nw_src) and the M MAC addresses (dl_src) of all remote ports which are associated with the remote security group.", "author": "xieus", "createdAt": "2020-10-31T15:05:51Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.\n+For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).\n+For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.\n+We will consider doing on-demand rule for L2 neighbors in the future if needed.\n+\n+=== Conjunctive flows\n+\n+With a security group rule that is associated with a remote group ID, ingress rule will need to match on the \"n\" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports \"m\" associated with this security group.", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0MzMzNA==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515543334", "bodyText": "fixed.", "author": "er1cthe0ne", "createdAt": "2020-10-31T21:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNTk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNjEwMg==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515506102", "bodyText": "It will result in N*M flows without using conjuctive flows.", "author": "xieus", "createdAt": "2020-10-31T15:07:35Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.\n+For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).\n+For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.\n+We will consider doing on-demand rule for L2 neighbors in the future if needed.\n+\n+=== Conjunctive flows\n+\n+With a security group rule that is associated with a remote group ID, ingress rule will need to match on the \"n\" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports \"m\" associated with this security group.\n+It will result with n * m flows without using conjuctive flows.", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0MzM4NQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515543385", "bodyText": "fixed.", "author": "er1cthe0ne", "createdAt": "2020-10-31T21:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNjEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNjM4OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515506389", "bodyText": "Consider to put two dimensions in two bullet points.\n. Point 1...\n. Point 2...", "author": "xieus", "createdAt": "2020-10-31T15:10:30Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.\n+For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).\n+For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.\n+We will consider doing on-demand rule for L2 neighbors in the future if needed.\n+\n+=== Conjunctive flows\n+\n+With a security group rule that is associated with a remote group ID, ingress rule will need to match on the \"n\" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports \"m\" associated with this security group.\n+It will result with n * m flows without using conjuctive flows.\n+The situation is much worse when there are multiple (e.g. 10) security groups associated with a single port.\n+\n+We will use a conj_id for each combination of (remote SG_id, local port SG_id, ingress/egress, ethertype, flow priority).\n+This rule is shared between security group rules and used by any flow that matches the same combo.\n+\n+Conjunctive flows can have 2 or more dimensions.\n+We will use the first dimension to match the remote ports IP.", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0MzUwNA==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515543504", "bodyText": "fixed.", "author": "er1cthe0ne", "createdAt": "2020-10-31T21:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwNjM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODExNA==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515508114", "bodyText": "Do we match the MAC addresses of the local port or remote ports?", "author": "xieus", "createdAt": "2020-10-31T15:29:08Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.\n+For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).\n+For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.\n+We will consider doing on-demand rule for L2 neighbors in the future if needed.\n+\n+=== Conjunctive flows\n+\n+With a security group rule that is associated with a remote group ID, ingress rule will need to match on the \"n\" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports \"m\" associated with this security group.\n+It will result with n * m flows without using conjuctive flows.\n+The situation is much worse when there are multiple (e.g. 10) security groups associated with a single port.\n+\n+We will use a conj_id for each combination of (remote SG_id, local port SG_id, ingress/egress, ethertype, flow priority).\n+This rule is shared between security group rules and used by any flow that matches the same combo.\n+\n+Conjunctive flows can have 2 or more dimensions.\n+We will use the first dimension to match the remote ports IP.\n+We want to merge the rules with when there are multiple IP address if possible.\n+The second dimension will be used to match the local port mac addresses and also other portion of the rule other than its remote SG_id.", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0MzU3Mg==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515543572", "bodyText": "we use the mac address to match the local port.", "author": "er1cthe0ne", "createdAt": "2020-10-31T21:47:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwODExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwOTA5Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515509096", "bodyText": "Should we move IP Protocol to the end of a rule so that the fields looks more organized by IP stack layer?", "author": "xieus", "createdAt": "2020-10-31T15:40:12Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.\n+For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).\n+For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.\n+We will consider doing on-demand rule for L2 neighbors in the future if needed.\n+\n+=== Conjunctive flows\n+\n+With a security group rule that is associated with a remote group ID, ingress rule will need to match on the \"n\" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports \"m\" associated with this security group.\n+It will result with n * m flows without using conjuctive flows.\n+The situation is much worse when there are multiple (e.g. 10) security groups associated with a single port.\n+\n+We will use a conj_id for each combination of (remote SG_id, local port SG_id, ingress/egress, ethertype, flow priority).\n+This rule is shared between security group rules and used by any flow that matches the same combo.\n+\n+Conjunctive flows can have 2 or more dimensions.\n+We will use the first dimension to match the remote ports IP.\n+We want to merge the rules with when there are multiple IP address if possible.\n+The second dimension will be used to match the local port mac addresses and also other portion of the rule other than its remote SG_id.\n+With multiple security group rules associated with a single port, the openflow rules can overlap.\n+To improve the situation, we want to consolidate and merge the second dimension rules.\n+\n+Once a traffic flow matches both dimensions, it will be assigned with a conj_id. The conj_id will point to the openflow rules for security group rules processing.\n+\n+\n+=== Default Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0Mzg3Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515543876", "bodyText": "Interesting suggestion, I used this format to align with popular public cloud documentation.", "author": "er1cthe0ne", "createdAt": "2020-10-31T21:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwOTA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwOTMxNw==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515509317", "bodyText": "Currently the hidden SG policies are not aware by Controller and only implemented on the host. This appears not a big deal as the hidden policies is supposed to be static.\nDo you expect it to be changed in a near future?", "author": "xieus", "createdAt": "2020-10-31T15:42:56Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.\n+For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).\n+For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.\n+We will consider doing on-demand rule for L2 neighbors in the future if needed.\n+\n+=== Conjunctive flows\n+\n+With a security group rule that is associated with a remote group ID, ingress rule will need to match on the \"n\" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports \"m\" associated with this security group.\n+It will result with n * m flows without using conjuctive flows.\n+The situation is much worse when there are multiple (e.g. 10) security groups associated with a single port.\n+\n+We will use a conj_id for each combination of (remote SG_id, local port SG_id, ingress/egress, ethertype, flow priority).\n+This rule is shared between security group rules and used by any flow that matches the same combo.\n+\n+Conjunctive flows can have 2 or more dimensions.\n+We will use the first dimension to match the remote ports IP.\n+We want to merge the rules with when there are multiple IP address if possible.\n+The second dimension will be used to match the local port mac addresses and also other portion of the rule other than its remote SG_id.\n+With multiple security group rules associated with a single port, the openflow rules can overlap.\n+To improve the situation, we want to consolidate and merge the second dimension rules.\n+\n+Once a traffic flow matches both dimensions, it will be assigned with a conj_id. The conj_id will point to the openflow rules for security group rules processing.\n+\n+\n+=== Default Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0\n+ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0\n+ALLOW: Direction=Ingress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote SG=default\n+ALLOW: Direction=Ingress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote SG=default\n+------------------------------------------------------------\n+\n+User can add or delete rules but cannot remove this security group.\n+\n+\n+=== Customer created Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0\n+ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0\n+------------------------------------------------------------\n+\n+User can add or delete rules or remove this security group.\n+\n+\n+=== Hidden Security Group Policies", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NDA1Ng==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515544056", "bodyText": "good point, I don't think that would likely change in the future. We can simply keep it as internal ACA implementation.", "author": "er1cthe0ne", "createdAt": "2020-10-31T21:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwOTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQyNTIwOA==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r516425208", "bodyText": "Okay, sounds good to me.", "author": "xieus", "createdAt": "2020-11-03T04:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwOTMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDUyNw==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515510527", "bodyText": "The calls to SG Mgr and Node Mgr are triggered in a parallel manner. So it would be better to show that in the diagram.\nOne way to do that is use the same number + postfix, for example, 6.a, 6.b.\nAn example:\nhttps://github.com/futurewei-cloud/alcor/blob/master/docs/modules/ROOT/pages/high_level/southbound_workflow.adoc", "author": "xieus", "createdAt": "2020-10-31T15:55:34Z", "path": "docs/modules/ROOT/workflows/security_group_workflow.puml", "diffHunk": "@@ -0,0 +1,76 @@\n+' Copyright 2019 The Alcor Authors.\n+\n+' Licensed under the Apache License, Version 2.0 (the \"License\");\n+'        you may not use this file except in compliance with the License.\n+'        You may obtain a copy of the License at\n+\n+'        http://www.apache.org/licenses/LICENSE-2.0\n+\n+'        Unless required by applicable law or agreed to in writing, software\n+'        distributed under the License is distributed on an \"AS IS\" BASIS,\n+'        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+'        See the License for the specific language governing permissions and\n+'        limitations under the License.\n+\n+@startuml\n+\n+skinparam monochrome true\n+\n+actor \"Customer\"\n+collections \"SG Manager\"\n+collections \"Node Manager\"\n+collections \"Port Manager\"\n+collections \"Data Plane Manager\"\n+\n+box \"Compute Host 1\" #LightBlue\n+participant \"ACA on \\n Host 1\"\n+end box\n+\n+box \"Compute Host 2\" #LightGreen\n+participant \"ACA on \\n Host 2\"\n+end box\n+\n+===Scenarios A: Create P1 which assoicated with SG1 and SG2, local SG rules only (no remote)==\n+\n+autonumber 10\n+\"Customer\" -> \"Port Manager\": Create P1 and assoicated it with SG1 and SG2\n+\"Port Manager\" -> \"SG Manager\": Query SG1 and SG2 info for P1\n+\"SG Manager\" -> \"Port Manager\": Response {SG_info...)}\n+\"Port Manager\" -> \"Node Manager\": Get node info input: {host_id}, new port\\n output: {host_ip}\n+\"Port Manager\" -> \"Data Plane Manager\": POST /port sync with RequestBody NetworkConfiguration=\\n {[P1 port w/ L2_neighbor_Id=NULL \\n L3_neighbor_Id=NULL],[Subnet],[VPC],[SG1,SG2]}\n+\"Data Plane Manager\" -> \"ACA on \\n Host 1\": Port: CREATE (FULL) P1, DHCP: CREATE (FULL) P1,\\n Subnet: INFO, [SG1, SG2]: INFO\n+\n+===Scenarios B: Create P1 which assoicated with SG2, One ingress SG rules points to remote SG1==\n+\n+autonumber 20\n+\"Customer\" -> \"Port Manager\": Create P1 assoicated with SG2\n+\"Port Manager\" -> \"SG Manager\": Query SG2 info for P1\n+\"SG Manager\" -> \"Port Manager\": Response {SG_info...)}, found one ingress SG rule points to remote SG1", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NTgxNg==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515545816", "bodyText": "fixed.", "author": "er1cthe0ne", "createdAt": "2020-10-31T22:11:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDY5NA==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515510694", "bodyText": "A high-level comment: This documents has a lot of sessions and subsessions. Can we add session number in front of each session and subsession?", "author": "xieus", "createdAt": "2020-10-31T15:57:29Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NjM4OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515546389", "bodyText": "fixed, putting this at top of the file will do the magic :)\n:sectnums:", "author": "er1cthe0ne", "createdAt": "2020-10-31T22:17:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDc5OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515510799", "bodyText": "please move \"futurewei team will do that\".", "author": "xieus", "createdAt": "2020-10-31T15:58:51Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.\n+For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).\n+For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.\n+We will consider doing on-demand rule for L2 neighbors in the future if needed.\n+\n+=== Conjunctive flows\n+\n+With a security group rule that is associated with a remote group ID, ingress rule will need to match on the \"n\" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports \"m\" associated with this security group.\n+It will result with n * m flows without using conjuctive flows.\n+The situation is much worse when there are multiple (e.g. 10) security groups associated with a single port.\n+\n+We will use a conj_id for each combination of (remote SG_id, local port SG_id, ingress/egress, ethertype, flow priority).\n+This rule is shared between security group rules and used by any flow that matches the same combo.\n+\n+Conjunctive flows can have 2 or more dimensions.\n+We will use the first dimension to match the remote ports IP.\n+We want to merge the rules with when there are multiple IP address if possible.\n+The second dimension will be used to match the local port mac addresses and also other portion of the rule other than its remote SG_id.\n+With multiple security group rules associated with a single port, the openflow rules can overlap.\n+To improve the situation, we want to consolidate and merge the second dimension rules.\n+\n+Once a traffic flow matches both dimensions, it will be assigned with a conj_id. The conj_id will point to the openflow rules for security group rules processing.\n+\n+\n+=== Default Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0\n+ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0\n+ALLOW: Direction=Ingress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote SG=default\n+ALLOW: Direction=Ingress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote SG=default\n+------------------------------------------------------------\n+\n+User can add or delete rules but cannot remove this security group.\n+\n+\n+=== Customer created Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0\n+ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0\n+------------------------------------------------------------\n+\n+User can add or delete rules or remove this security group.\n+\n+\n+=== Hidden Security Group Policies\n+\n+With port security enabled, since all the traffic are blocked by default.\n+A list of hidden security group rule are allowed to enable basic connectivity, which include allowing for ICMP, ICMP6, ARP, DHCP, DHCPv6, \n+SSH (TCP Port:22), RDP (TCP Port:3389) and connection tracking. The rule to allow incoming SSH and RDP can go to default security group.\n+The system will also enable a rule to only allow traffic coming out from the port has the assigned virtual IP and virtual MAC address to \n+disallow IP and MAC spoofing.\n+See later session for a sample set of openflow rules when a VM port has been added.\n+\n+\n+== Workflow on Security Group programming\n+\n+image::security_group_workflow.png[] \n+\n+\n+== Implementation Proposal\n+\n+We will use a list of openflow tables on br-int for security group rule implementation, leveraging Neutron's ovs-firewall driver as a reference.\n+Most importantly, we need to keep scale and performance in mind.\n+Therefore, we will:\n+\n+. keep the minimal number of openflow tables as needed\n+. leverage the on-demand feature to install security group rules when needed, unknown egress L3 traffic will be sent to OpenFlow controller, which is ACA.\n+This is similar to L3 on-demand routing algorithm.\n+\n+In order to support remote SG rules, our neighbor configuration will be updated to include the associated SG_ids for the neighbor port.\n+\n+=== Recommended Code Changes\n+\n+This session list the proposed code change location and details:\n+\n+. update neighbor.proto to add \"repeated SecurityGroupId security_group_ids;\" to support remote_group rules - futurewei team will do that", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NjQyNg==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515546426", "bodyText": "fixed.", "author": "er1cthe0ne", "createdAt": "2020-10-31T22:18:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMDk5OQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515510999", "bodyText": "The instructions are pretty detailed. Awesome \ud83d\udc4d", "author": "xieus", "createdAt": "2020-10-31T16:00:44Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.\n+For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).\n+For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.\n+We will consider doing on-demand rule for L2 neighbors in the future if needed.\n+\n+=== Conjunctive flows\n+\n+With a security group rule that is associated with a remote group ID, ingress rule will need to match on the \"n\" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports \"m\" associated with this security group.\n+It will result with n * m flows without using conjuctive flows.\n+The situation is much worse when there are multiple (e.g. 10) security groups associated with a single port.\n+\n+We will use a conj_id for each combination of (remote SG_id, local port SG_id, ingress/egress, ethertype, flow priority).\n+This rule is shared between security group rules and used by any flow that matches the same combo.\n+\n+Conjunctive flows can have 2 or more dimensions.\n+We will use the first dimension to match the remote ports IP.\n+We want to merge the rules with when there are multiple IP address if possible.\n+The second dimension will be used to match the local port mac addresses and also other portion of the rule other than its remote SG_id.\n+With multiple security group rules associated with a single port, the openflow rules can overlap.\n+To improve the situation, we want to consolidate and merge the second dimension rules.\n+\n+Once a traffic flow matches both dimensions, it will be assigned with a conj_id. The conj_id will point to the openflow rules for security group rules processing.\n+\n+\n+=== Default Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0\n+ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0\n+ALLOW: Direction=Ingress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote SG=default\n+ALLOW: Direction=Ingress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote SG=default\n+------------------------------------------------------------\n+\n+User can add or delete rules but cannot remove this security group.\n+\n+\n+=== Customer created Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0\n+ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0\n+------------------------------------------------------------\n+\n+User can add or delete rules or remove this security group.\n+\n+\n+=== Hidden Security Group Policies\n+\n+With port security enabled, since all the traffic are blocked by default.\n+A list of hidden security group rule are allowed to enable basic connectivity, which include allowing for ICMP, ICMP6, ARP, DHCP, DHCPv6, \n+SSH (TCP Port:22), RDP (TCP Port:3389) and connection tracking. The rule to allow incoming SSH and RDP can go to default security group.\n+The system will also enable a rule to only allow traffic coming out from the port has the assigned virtual IP and virtual MAC address to \n+disallow IP and MAC spoofing.\n+See later session for a sample set of openflow rules when a VM port has been added.\n+\n+\n+== Workflow on Security Group programming\n+\n+image::security_group_workflow.png[] \n+\n+\n+== Implementation Proposal\n+\n+We will use a list of openflow tables on br-int for security group rule implementation, leveraging Neutron's ovs-firewall driver as a reference.\n+Most importantly, we need to keep scale and performance in mind.\n+Therefore, we will:\n+\n+. keep the minimal number of openflow tables as needed\n+. leverage the on-demand feature to install security group rules when needed, unknown egress L3 traffic will be sent to OpenFlow controller, which is ACA.\n+This is similar to L3 on-demand routing algorithm.\n+\n+In order to support remote SG rules, our neighbor configuration will be updated to include the associated SG_ids for the neighbor port.\n+\n+=== Recommended Code Changes\n+\n+This session list the proposed code change location and details:\n+\n+. update neighbor.proto to add \"repeated SecurityGroupId security_group_ids;\" to support remote_group rules - futurewei team will do that\n+. add the ignore logic when PortState::operation_type = INFO inside ACA_Dataplane_OVS::update_port_state_workitem similar to update_subnet_state_workitem\n+. add a new directory under /src, namely /sg.\n+. add the implementation files related to security group under the new /src/sg directory, the main file should be named aca_sg_state_handler.cpp, similar to aca_dhcp_state_handler.cpp. Note that we don't have an interface definition like dhcp_programming_if for security group.\n+. add a new class for the main security group implementation, add default openflow rules in constructor and clean up the openflow rules in destructor. Note that a port can have \"port security\" enabled (default) or disabled. Therefore, any default openflow rules need to work on both.\n+. for openflow rule manipulation, use ACA_OVS_Control::get_instance().add_flow/mod_flows/del_flows.\n+. modify CMakeLists.txt under /src to include new .cpp files.\n+. modify aca_comm_mgr.cpp - Aca_Comm_Manager::update_goal_state - add a new block for Aca_SG_State_Handler::get_instance().update_sg_states similar to update_dhcp_states.\n+. update test/gtest/aca_tests.cpp to include a set of unit and functional test cases for security group implementation. We may need to create a docker container, use ovs-docker to connect its port to br-int. Then push down a crafted goal state to configure a new port with a set of security group rules. The last step is to send some traffic to confirm the security group rules are working. See DISABLED_2_ports_ROUTING_test_traffic_one_machine in the same file for reference.", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMTg5MQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515511891", "bodyText": "Assuming that most majority of customer scenarios only use one SG, can we cut the header overhead to 16+8 = 24 bytes or 88 is not negotiable :-)", "author": "xieus", "createdAt": "2020-10-31T16:10:37Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.\n+For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).\n+For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.\n+We will consider doing on-demand rule for L2 neighbors in the future if needed.\n+\n+=== Conjunctive flows\n+\n+With a security group rule that is associated with a remote group ID, ingress rule will need to match on the \"n\" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports \"m\" associated with this security group.\n+It will result with n * m flows without using conjuctive flows.\n+The situation is much worse when there are multiple (e.g. 10) security groups associated with a single port.\n+\n+We will use a conj_id for each combination of (remote SG_id, local port SG_id, ingress/egress, ethertype, flow priority).\n+This rule is shared between security group rules and used by any flow that matches the same combo.\n+\n+Conjunctive flows can have 2 or more dimensions.\n+We will use the first dimension to match the remote ports IP.\n+We want to merge the rules with when there are multiple IP address if possible.\n+The second dimension will be used to match the local port mac addresses and also other portion of the rule other than its remote SG_id.\n+With multiple security group rules associated with a single port, the openflow rules can overlap.\n+To improve the situation, we want to consolidate and merge the second dimension rules.\n+\n+Once a traffic flow matches both dimensions, it will be assigned with a conj_id. The conj_id will point to the openflow rules for security group rules processing.\n+\n+\n+=== Default Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0\n+ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0\n+ALLOW: Direction=Ingress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote SG=default\n+ALLOW: Direction=Ingress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote SG=default\n+------------------------------------------------------------\n+\n+User can add or delete rules but cannot remove this security group.\n+\n+\n+=== Customer created Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0\n+ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0\n+------------------------------------------------------------\n+\n+User can add or delete rules or remove this security group.\n+\n+\n+=== Hidden Security Group Policies\n+\n+With port security enabled, since all the traffic are blocked by default.\n+A list of hidden security group rule are allowed to enable basic connectivity, which include allowing for ICMP, ICMP6, ARP, DHCP, DHCPv6, \n+SSH (TCP Port:22), RDP (TCP Port:3389) and connection tracking. The rule to allow incoming SSH and RDP can go to default security group.\n+The system will also enable a rule to only allow traffic coming out from the port has the assigned virtual IP and virtual MAC address to \n+disallow IP and MAC spoofing.\n+See later session for a sample set of openflow rules when a VM port has been added.\n+\n+\n+== Workflow on Security Group programming\n+\n+image::security_group_workflow.png[] \n+\n+\n+== Implementation Proposal\n+\n+We will use a list of openflow tables on br-int for security group rule implementation, leveraging Neutron's ovs-firewall driver as a reference.\n+Most importantly, we need to keep scale and performance in mind.\n+Therefore, we will:\n+\n+. keep the minimal number of openflow tables as needed\n+. leverage the on-demand feature to install security group rules when needed, unknown egress L3 traffic will be sent to OpenFlow controller, which is ACA.\n+This is similar to L3 on-demand routing algorithm.\n+\n+In order to support remote SG rules, our neighbor configuration will be updated to include the associated SG_ids for the neighbor port.\n+\n+=== Recommended Code Changes\n+\n+This session list the proposed code change location and details:\n+\n+. update neighbor.proto to add \"repeated SecurityGroupId security_group_ids;\" to support remote_group rules - futurewei team will do that\n+. add the ignore logic when PortState::operation_type = INFO inside ACA_Dataplane_OVS::update_port_state_workitem similar to update_subnet_state_workitem\n+. add a new directory under /src, namely /sg.\n+. add the implementation files related to security group under the new /src/sg directory, the main file should be named aca_sg_state_handler.cpp, similar to aca_dhcp_state_handler.cpp. Note that we don't have an interface definition like dhcp_programming_if for security group.\n+. add a new class for the main security group implementation, add default openflow rules in constructor and clean up the openflow rules in destructor. Note that a port can have \"port security\" enabled (default) or disabled. Therefore, any default openflow rules need to work on both.\n+. for openflow rule manipulation, use ACA_OVS_Control::get_instance().add_flow/mod_flows/del_flows.\n+. modify CMakeLists.txt under /src to include new .cpp files.\n+. modify aca_comm_mgr.cpp - Aca_Comm_Manager::update_goal_state - add a new block for Aca_SG_State_Handler::get_instance().update_sg_states similar to update_dhcp_states.\n+. update test/gtest/aca_tests.cpp to include a set of unit and functional test cases for security group implementation. We may need to create a docker container, use ovs-docker to connect its port to br-int. Then push down a crafted goal state to configure a new port with a set of security group rules. The last step is to send some traffic to confirm the security group rules are working. See DISABLED_2_ports_ROUTING_test_traffic_one_machine in the same file for reference.\n+\n+We will need to create/update the corresponding header files accordingly.\n+\n+=== Integration with Alcor Distributed Router\n+\n+Alcor Distribute Router was using table 0 to restore gateway mac address from the neighbor host DVR mac. \n+With addition of security group implementation, \n+we will move that to table 73 (ACCEPT_OR_INGRESS) since those connection is already accepted for ingress pipeline.\n+\n+\n+== VxLAN-GPE for remote security group\n+\n+We can consider leveraging VxLAN-GPE to address the scale problem with security group, on rules that contain remote security group as the number of ports (and assoicated IPs) on the remote group can be huge. That will require local host to be aware of all the ports assoicated IPs to construct the corresponding openflow rules.\n+\n+While the current design still need to work with VxLAN only environment, we can leveraging VxLAN-GPE to embed remote security group IDs or markings into ingress packets. The local host can then apply ingress SG rule without needing to know all the ports IPs from the remote group beforehand.\n+\n+=== VxLAN-GPE packet with remote security group info\n+\n+[source,shell]\n+------------------------------------------------------------\n+Outer header -- Next header ------------ Inner packet\n+VxLAN-GPE ----- NSH with remote SG ID -- IPv4/IPv6 original payload\n+------------------------------------------------------------\n+\n+=== OVS egress marking\n+\n+OVS (controlled by ACA) will need to stamp all packets coming out for a port with the assoicated SG IDs (zero to five).\n+\n+Each SG ID is 36 characters string (36 bytes) or we can represent it using 16 bytes encoding. 5 of them will be 80 bytes plus adding 8 bytes NSH header will total 88 bytes increase of packet header. While VxLAN-GPE + NSH can embed all those information, but 88 bytes is too much data to put into header of every single packet. ", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NjgzOA==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515546838", "bodyText": "that would cut it down to 16+8 bytes NSH header = 24 bytes. That's more negotiable :) @chenpiaoping @Gzure  - can we assume most customer scenarios only use one SG?", "author": "er1cthe0ne", "createdAt": "2020-10-31T22:22:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQyODE5Mg==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r516428192", "bodyText": "Let us bring this question up in the weekly open-source meeting. If the assumption is confirmed, we should take the proposal more serious :-)", "author": "xieus", "createdAt": "2020-11-03T04:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMTg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMjM5MQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515512391", "bodyText": "Agreed with the judgment here. Control packets are not the way to go for DC networking.", "author": "xieus", "createdAt": "2020-10-31T16:16:17Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.\n+For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).\n+For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.\n+We will consider doing on-demand rule for L2 neighbors in the future if needed.\n+\n+=== Conjunctive flows\n+\n+With a security group rule that is associated with a remote group ID, ingress rule will need to match on the \"n\" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports \"m\" associated with this security group.\n+It will result with n * m flows without using conjuctive flows.\n+The situation is much worse when there are multiple (e.g. 10) security groups associated with a single port.\n+\n+We will use a conj_id for each combination of (remote SG_id, local port SG_id, ingress/egress, ethertype, flow priority).\n+This rule is shared between security group rules and used by any flow that matches the same combo.\n+\n+Conjunctive flows can have 2 or more dimensions.\n+We will use the first dimension to match the remote ports IP.\n+We want to merge the rules with when there are multiple IP address if possible.\n+The second dimension will be used to match the local port mac addresses and also other portion of the rule other than its remote SG_id.\n+With multiple security group rules associated with a single port, the openflow rules can overlap.\n+To improve the situation, we want to consolidate and merge the second dimension rules.\n+\n+Once a traffic flow matches both dimensions, it will be assigned with a conj_id. The conj_id will point to the openflow rules for security group rules processing.\n+\n+\n+=== Default Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0\n+ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0\n+ALLOW: Direction=Ingress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote SG=default\n+ALLOW: Direction=Ingress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote SG=default\n+------------------------------------------------------------\n+\n+User can add or delete rules but cannot remove this security group.\n+\n+\n+=== Customer created Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0\n+ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0\n+------------------------------------------------------------\n+\n+User can add or delete rules or remove this security group.\n+\n+\n+=== Hidden Security Group Policies\n+\n+With port security enabled, since all the traffic are blocked by default.\n+A list of hidden security group rule are allowed to enable basic connectivity, which include allowing for ICMP, ICMP6, ARP, DHCP, DHCPv6, \n+SSH (TCP Port:22), RDP (TCP Port:3389) and connection tracking. The rule to allow incoming SSH and RDP can go to default security group.\n+The system will also enable a rule to only allow traffic coming out from the port has the assigned virtual IP and virtual MAC address to \n+disallow IP and MAC spoofing.\n+See later session for a sample set of openflow rules when a VM port has been added.\n+\n+\n+== Workflow on Security Group programming\n+\n+image::security_group_workflow.png[] \n+\n+\n+== Implementation Proposal\n+\n+We will use a list of openflow tables on br-int for security group rule implementation, leveraging Neutron's ovs-firewall driver as a reference.\n+Most importantly, we need to keep scale and performance in mind.\n+Therefore, we will:\n+\n+. keep the minimal number of openflow tables as needed\n+. leverage the on-demand feature to install security group rules when needed, unknown egress L3 traffic will be sent to OpenFlow controller, which is ACA.\n+This is similar to L3 on-demand routing algorithm.\n+\n+In order to support remote SG rules, our neighbor configuration will be updated to include the associated SG_ids for the neighbor port.\n+\n+=== Recommended Code Changes\n+\n+This session list the proposed code change location and details:\n+\n+. update neighbor.proto to add \"repeated SecurityGroupId security_group_ids;\" to support remote_group rules - futurewei team will do that\n+. add the ignore logic when PortState::operation_type = INFO inside ACA_Dataplane_OVS::update_port_state_workitem similar to update_subnet_state_workitem\n+. add a new directory under /src, namely /sg.\n+. add the implementation files related to security group under the new /src/sg directory, the main file should be named aca_sg_state_handler.cpp, similar to aca_dhcp_state_handler.cpp. Note that we don't have an interface definition like dhcp_programming_if for security group.\n+. add a new class for the main security group implementation, add default openflow rules in constructor and clean up the openflow rules in destructor. Note that a port can have \"port security\" enabled (default) or disabled. Therefore, any default openflow rules need to work on both.\n+. for openflow rule manipulation, use ACA_OVS_Control::get_instance().add_flow/mod_flows/del_flows.\n+. modify CMakeLists.txt under /src to include new .cpp files.\n+. modify aca_comm_mgr.cpp - Aca_Comm_Manager::update_goal_state - add a new block for Aca_SG_State_Handler::get_instance().update_sg_states similar to update_dhcp_states.\n+. update test/gtest/aca_tests.cpp to include a set of unit and functional test cases for security group implementation. We may need to create a docker container, use ovs-docker to connect its port to br-int. Then push down a crafted goal state to configure a new port with a set of security group rules. The last step is to send some traffic to confirm the security group rules are working. See DISABLED_2_ports_ROUTING_test_traffic_one_machine in the same file for reference.\n+\n+We will need to create/update the corresponding header files accordingly.\n+\n+=== Integration with Alcor Distributed Router\n+\n+Alcor Distribute Router was using table 0 to restore gateway mac address from the neighbor host DVR mac. \n+With addition of security group implementation, \n+we will move that to table 73 (ACCEPT_OR_INGRESS) since those connection is already accepted for ingress pipeline.\n+\n+\n+== VxLAN-GPE for remote security group\n+\n+We can consider leveraging VxLAN-GPE to address the scale problem with security group, on rules that contain remote security group as the number of ports (and assoicated IPs) on the remote group can be huge. That will require local host to be aware of all the ports assoicated IPs to construct the corresponding openflow rules.\n+\n+While the current design still need to work with VxLAN only environment, we can leveraging VxLAN-GPE to embed remote security group IDs or markings into ingress packets. The local host can then apply ingress SG rule without needing to know all the ports IPs from the remote group beforehand.\n+\n+=== VxLAN-GPE packet with remote security group info\n+\n+[source,shell]\n+------------------------------------------------------------\n+Outer header -- Next header ------------ Inner packet\n+VxLAN-GPE ----- NSH with remote SG ID -- IPv4/IPv6 original payload\n+------------------------------------------------------------\n+\n+=== OVS egress marking\n+\n+OVS (controlled by ACA) will need to stamp all packets coming out for a port with the assoicated SG IDs (zero to five).\n+\n+Each SG ID is 36 characters string (36 bytes) or we can represent it using 16 bytes encoding. 5 of them will be 80 bytes plus adding 8 bytes NSH header will total 88 bytes increase of packet header. While VxLAN-GPE + NSH can embed all those information, but 88 bytes is too much data to put into header of every single packet. \n+\n+[TBD] Therefore, we need to come up with a way for more efficient marking and pre-negotiate it between the two end points. \n+\n+\n+=== OVS ingress processing\n+\n+Security group rule with remote group will be coverted to openflow rule to match on SG ID on ingress traffic. Since all remote VxLAN-GPE ports has all the outgoing traffic stamped with the assoicated SG IDs markings, the one openflow rule will simply look at the matching remote SG ID instead of a potential large scale set of IPs belong to all the ports assoicated with the remote SG.\n+\n+[TBD] need to confirm openflow rule can match on NSH header for our need.\n+\n+=== Notes\n+\n+Marking remote port SG alone doesn't help much, since we are learning about the remote port SG through L2/L3 neighbor already. \n+Maybe it will be helpful to deal with non-L2/non-L3 neighbor, e.g. VPC peering.\n+Marking remote port SG will have benefit when we don't need to send down L2 and L3 neighbor, e.g. using Gateway approach.\n+\n+Another approach is to send control packets from remote host to local host to learn about the remote port IP to its assoicated SGs, right before the remote host is ready to send traffic to local host. The problems with this approach are:\n+\n+1. latency - first packet needs to wait until the control packet learning is completed\n+2. scale - ACA handling huge number of control packet, e.g. 100s of VMs on the same network triggering at the same time\n+3. security - put control packet outside tunnel has lower risk, but inside tenent networks tunnels has high risk because tenent can mess with it\n+4. acknowledgement - what happen if control packet are missed? There is not reply mechanism", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMjUxMQ==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515512511", "bodyText": "I remember we had discussion about storing SG information using local registry alike staff. Didn't find it in the documents.", "author": "xieus", "createdAt": "2020-10-31T16:17:51Z", "path": "docs/modules/ROOT/pages/high_level/security_group_host_design.adoc", "diffHunk": "@@ -0,0 +1,583 @@\n+= Alcor Security Group Design on Host\n+Eric Li <sze.li@futurewei.com>, Liguang Xie <lxie@futurewei.com>, Chun-Jen (James) Chung<cchung@futurewei.com>\n+v0.1, 2020-09-18\n+:toc: right\n+:imagesdir: ../../images\n+\n+NOTE: This document is under development\n+\n+== Architecture Overview\n+\n+[source,shell]\n+------------------------------------------------------------\n+                  .                                    .\n+           _______|\\                            _______|\\\n+          \\  egress \\                          \\  egress \\\n+          /_______  /                          /_______  /\n+                  |/     .----------------.            |/\n+                  '      |  OVS (br-int)  |            '\n+                         |                |\n+ VM/Container port <---> |    OpenFlow    | <--> br-tun then NIC HW\n+                         |     Rules      |\n+            .            |                |      .\n+           /|________    '----------------'     /|________\n+          /  ingress /                         /  ingress /\n+          \\  ________\\                         \\  ________\\\n+           \\|                                   \\|\n+            '                                    '\n+------------------------------------------------------------\n+\n+== Requirements\n+\n+We want to have a design that is:\n+\n+. Fast provision - end to end port provision including security group < a few 100ms\n+. Agile update - allow granular update/add/delete one or more security group rule on compute hosts, as opposed to push down all the rules for an update\n+. Scalable - needs to handle 100,000 ports in a VPC given 1,000,000 machines in a region\n+. High performance - low latency VM-to-VM communication with port security enabled\n+. Lean - minimal resource overhead on compute hosts (e.g., bridges, linux device, linux kernel)\n+. Fast migration - VMs migration should have network blackout time < a few seconds\n+\n+Note that Security groups are stateful, which means that allowed ingress connections are also allowed to flow out, and vice versa.\n+Therefore, a connection tracking mechanism is required for its implementation.\n+\n+\n+== Background: OpenStack Neutron Security Group\n+\n+OpenStack Neutron makes a significant change on design and implmentation of security group in its Mitaka release which was shipped on April 2016.\n+\n+\n+=== Before OpenStack Mitaka Release\n+\n+Here are a few historical challenge before OpenStack Mitaka release on April 2016.\n+\n+1. Adds a Linux bridge between each VM port and OVS bridge (br-int)\n+2. Uses Linux devices and linux kernel to support IP Tables implementation\n+3. Update of single security group rule requires the whole security group to be pushed down to compute hosts,\n+and requires the IP Tables chain to be recompiled (TBD: review Neutron Agent behavior)\n+4. This IP Tables implementation cannot be offloaded to hardware, except using a SoC/ARM based NIC which has capability to run the whole Linux OS\n+\n+[source,shell]\n+------------------------------------------------------------\n+   +-------------+                     +---------------+\n+   |             |                     |               |\n+   |    VM 1     |                     |     VM 2      |\n+   |             |                     |               |\n+   +---+------+--+                     +---+-------+---+\n+       | eth  |                            |  eth  |\n+       +--+---+                            +---+---+\n+          |                                    |\n+       +--+---+                            +---+---+\n+       | tap  |                            |  tap  |\n+ +-----+------+-----+                 +----+-------+-----+\n+ |                  |                 |                  |\n+ |   Linux Bridge 1 |                 |   Linux Bridge 2 |\n+ |                  |                 |                  |\n+ +-----+------+-----+                 +-----+------+-----+\n+       | veth |                             | veth |\n+       +--+---+                             +--+---+\n+          |                                    |\n+       +--+---+                             +--+---+\n+       | veth |                             | veth |\n++------+------+-----------------------------+------+---------+\n+|                                                            |\n+|                     OVS  Bridge  (br-int)                  |\n+|                                                            |\n++------------------------------------------------------------+\n+------------------------------------------------------------\n+\n+\n+=== After OpenStack Mitaka Release\n+\n+The OpenStack community recognized the challenge of IP Tables implementation for security group rules.\n+With OVS implementation of connection tracking <<ovs-conntrack>>, many open source solutions including ovs_dpdk_firewall<<intel>> and Dragonflow<<dragonflow-security-group>> start leveraging it for OpenStack.\n+It is natural for OpenStack Neutron to adopt it.\n+OpenStack Mitaka introduced official OVS Firewall driver, which addressed many of the issues in the prior releases.\n+But Alcor can do even better than that.\n+\n+\n+== Design approach\n+\n+The Security Group design uses OVS and OpenFlow, building on the latest Neutron OVS firewall rule approach.\n+It offers the following advantages compared to Neutron:\n+\n+. On-Host direct connection from VM port to OVS: it doesn't need extra Linux bridge, Linux devices, Linux kernel or IP Tables;\n+. Direct and simplified communication between Alcor controller to Alcor control agent;\n+. Delta update: Update of security group rule only require the changed rule to be push down to compute hosts;\n+. Reduced OVS SG rules: Same security group rule can be shared with any port which follows the same conjunctive rule for remote security group rules;\n+. Enable scale and performance from the ground up, addressing the biggest pain point on Neutron;\n+. OpenFlow rules can be offloaded to hardware\n+\n+Our highlighted improvement is to use only one OpenFlow rule per security group rule, to be shared with all the associated ports on a compute host.\n+That will promote the scale and performance compared to Neutron.\n+To support this, we will use openflow conjuction flow<<ovs-fields>>, which is a multiple dimension matching process.\n+We will mark the ports associated for a particular security group using the first dimension of a conjunctive flow discussed in the later session.\n+\n+=== Example of Delta Update\n+\n+Another highlight our design bring is to support minimal goal state message when only one SG rule is updated (in an SG which has 100s of existing rules).\n+We have added operation_type into each security group rule inside an SG configuration message.\n+Therefore, only one SG rule is needed in the goal state message without the need to include 100s of existing rules when they have not changed.\n+The DPM<->ACA schema (securitygroup.proto) already has that.\n+\n+[source,shell]\n+------------------------------------------------------------\n+    message SecurityGroupRule {\n+        04 bytes - OperationType operation_type = 1;  <---------here\n+        36 bytes - string security_group_id = 2;\n+        36 bytes - string id = 3;\n+        04 bytes - Direction direction = 4;\n+        04 bytes - EtherType ethertype = 5;\n+        04 bytes - Protocol protocol = 6;\n+        04 bytes - uint32 port_range_min = 7;\n+        04 bytes - uint32 port_range_max = 8;\n+        18 bytes - string remote_ip_prefix = 9;\n+        36 bytes - string remote_group_id = 10;\n+    }\n+------------------------------------------------------------\n+\n+The goal state message size reduction is significant.\n+With Delta update, message size with one security group rule will be around 150 bytes plus outer goal state message and protobuf overhead (around 50 bytes, message total ~200 bytes).\n+Without Delta update, full message size with 100 security group rules will be 150 bytes times 100 plus outer goal state message and protobuf overhead (around 50 bytes, message total ~15,050 bytes).\n+\n+=== Remote Security Group Rule Handling\n+\n+A Security Group rule can refer to a remote security group for both ingress and egress traffic.\n+When a security group rule is added to security group A, customer can set security group B as the source (for ingress rule) or destination (for egress rule).\n+This allows ports associated with security group B to access ports that are port of security group A, and vice versa.\n+\n+[source,shell]\n+------------------------------------------------------------\n++-----------+     +-----------+ \n+| Compute   |     | Compute   |\n+| Node 1    |     | Node 2    |\n+|           |     |           |\n+|       OVS + <---| OVS       |\n+|           |     |           |\n+| Port 1    |     | Port 2    |\n+| SG A      |     | SG B      |\n++-----------+     +-----------+\n+------------------------------------------------------------\n+\n+The default security group has rules that allow associated ports of the default rule to talk to each other.\n+\n+To support this using the minimal set of OpenFlow rules, we will mark remote ports with its associated security group using conjunctive flows discussed in the next session.\n+We will update our neighbor configuration schema to include associated security group IDs.\n+For L3 neighbor, we will leverage on-demand rules so that the OpenFlow rule for the marking is only setup when needed (for egress).\n+For L2 neighbor, we will go ahead to setup its OpenFlow rules for the marking since it is limited by the subnet size.\n+We will consider doing on-demand rule for L2 neighbors in the future if needed.\n+\n+=== Conjunctive flows\n+\n+With a security group rule that is associated with a remote group ID, ingress rule will need to match on the \"n\" remote ports IP address (nw_src) and match on the mac addresses (dl_src) for all the ports \"m\" associated with this security group.\n+It will result with n * m flows without using conjuctive flows.\n+The situation is much worse when there are multiple (e.g. 10) security groups associated with a single port.\n+\n+We will use a conj_id for each combination of (remote SG_id, local port SG_id, ingress/egress, ethertype, flow priority).\n+This rule is shared between security group rules and used by any flow that matches the same combo.\n+\n+Conjunctive flows can have 2 or more dimensions.\n+We will use the first dimension to match the remote ports IP.\n+We want to merge the rules with when there are multiple IP address if possible.\n+The second dimension will be used to match the local port mac addresses and also other portion of the rule other than its remote SG_id.\n+With multiple security group rules associated with a single port, the openflow rules can overlap.\n+To improve the situation, we want to consolidate and merge the second dimension rules.\n+\n+Once a traffic flow matches both dimensions, it will be assigned with a conj_id. The conj_id will point to the openflow rules for security group rules processing.\n+\n+\n+=== Default Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0\n+ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0\n+ALLOW: Direction=Ingress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote SG=default\n+ALLOW: Direction=Ingress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote SG=default\n+------------------------------------------------------------\n+\n+User can add or delete rules but cannot remove this security group.\n+\n+\n+=== Customer created Security Group\n+\n+[source,shell]\n+------------------------------------------------------------\n+ALLOW: Direction=Egress, Ether Type=IPv4, IP Protocol=Any, Port Range=Any, Remote IP Prefix=0.0.0.0/0\n+ALLOW: Direction=Egress, Ether Type=IPv6, IP Protocol=Any, Port Range=Any, Remote IP Prefix=::/0\n+------------------------------------------------------------\n+\n+User can add or delete rules or remove this security group.\n+\n+\n+=== Hidden Security Group Policies\n+\n+With port security enabled, since all the traffic are blocked by default.\n+A list of hidden security group rule are allowed to enable basic connectivity, which include allowing for ICMP, ICMP6, ARP, DHCP, DHCPv6, \n+SSH (TCP Port:22), RDP (TCP Port:3389) and connection tracking. The rule to allow incoming SSH and RDP can go to default security group.\n+The system will also enable a rule to only allow traffic coming out from the port has the assigned virtual IP and virtual MAC address to \n+disallow IP and MAC spoofing.\n+See later session for a sample set of openflow rules when a VM port has been added.\n+\n+\n+== Workflow on Security Group programming\n+\n+image::security_group_workflow.png[] \n+\n+\n+== Implementation Proposal\n+\n+We will use a list of openflow tables on br-int for security group rule implementation, leveraging Neutron's ovs-firewall driver as a reference.\n+Most importantly, we need to keep scale and performance in mind.\n+Therefore, we will:\n+\n+. keep the minimal number of openflow tables as needed\n+. leverage the on-demand feature to install security group rules when needed, unknown egress L3 traffic will be sent to OpenFlow controller, which is ACA.\n+This is similar to L3 on-demand routing algorithm.\n+\n+In order to support remote SG rules, our neighbor configuration will be updated to include the associated SG_ids for the neighbor port.\n+\n+=== Recommended Code Changes\n+\n+This session list the proposed code change location and details:\n+\n+. update neighbor.proto to add \"repeated SecurityGroupId security_group_ids;\" to support remote_group rules - futurewei team will do that\n+. add the ignore logic when PortState::operation_type = INFO inside ACA_Dataplane_OVS::update_port_state_workitem similar to update_subnet_state_workitem\n+. add a new directory under /src, namely /sg.\n+. add the implementation files related to security group under the new /src/sg directory, the main file should be named aca_sg_state_handler.cpp, similar to aca_dhcp_state_handler.cpp. Note that we don't have an interface definition like dhcp_programming_if for security group.\n+. add a new class for the main security group implementation, add default openflow rules in constructor and clean up the openflow rules in destructor. Note that a port can have \"port security\" enabled (default) or disabled. Therefore, any default openflow rules need to work on both.\n+. for openflow rule manipulation, use ACA_OVS_Control::get_instance().add_flow/mod_flows/del_flows.\n+. modify CMakeLists.txt under /src to include new .cpp files.\n+. modify aca_comm_mgr.cpp - Aca_Comm_Manager::update_goal_state - add a new block for Aca_SG_State_Handler::get_instance().update_sg_states similar to update_dhcp_states.\n+. update test/gtest/aca_tests.cpp to include a set of unit and functional test cases for security group implementation. We may need to create a docker container, use ovs-docker to connect its port to br-int. Then push down a crafted goal state to configure a new port with a set of security group rules. The last step is to send some traffic to confirm the security group rules are working. See DISABLED_2_ports_ROUTING_test_traffic_one_machine in the same file for reference.\n+\n+We will need to create/update the corresponding header files accordingly.\n+\n+=== Integration with Alcor Distributed Router\n+\n+Alcor Distribute Router was using table 0 to restore gateway mac address from the neighbor host DVR mac. \n+With addition of security group implementation, \n+we will move that to table 73 (ACCEPT_OR_INGRESS) since those connection is already accepted for ingress pipeline.\n+\n+\n+== VxLAN-GPE for remote security group\n+\n+We can consider leveraging VxLAN-GPE to address the scale problem with security group, on rules that contain remote security group as the number of ports (and assoicated IPs) on the remote group can be huge. That will require local host to be aware of all the ports assoicated IPs to construct the corresponding openflow rules.\n+\n+While the current design still need to work with VxLAN only environment, we can leveraging VxLAN-GPE to embed remote security group IDs or markings into ingress packets. The local host can then apply ingress SG rule without needing to know all the ports IPs from the remote group beforehand.\n+\n+=== VxLAN-GPE packet with remote security group info\n+\n+[source,shell]\n+------------------------------------------------------------\n+Outer header -- Next header ------------ Inner packet\n+VxLAN-GPE ----- NSH with remote SG ID -- IPv4/IPv6 original payload\n+------------------------------------------------------------\n+\n+=== OVS egress marking\n+\n+OVS (controlled by ACA) will need to stamp all packets coming out for a port with the assoicated SG IDs (zero to five).\n+\n+Each SG ID is 36 characters string (36 bytes) or we can represent it using 16 bytes encoding. 5 of them will be 80 bytes plus adding 8 bytes NSH header will total 88 bytes increase of packet header. While VxLAN-GPE + NSH can embed all those information, but 88 bytes is too much data to put into header of every single packet. \n+\n+[TBD] Therefore, we need to come up with a way for more efficient marking and pre-negotiate it between the two end points. \n+\n+\n+=== OVS ingress processing\n+\n+Security group rule with remote group will be coverted to openflow rule to match on SG ID on ingress traffic. Since all remote VxLAN-GPE ports has all the outgoing traffic stamped with the assoicated SG IDs markings, the one openflow rule will simply look at the matching remote SG ID instead of a potential large scale set of IPs belong to all the ports assoicated with the remote SG.\n+\n+[TBD] need to confirm openflow rule can match on NSH header for our need.\n+\n+=== Notes\n+\n+Marking remote port SG alone doesn't help much, since we are learning about the remote port SG through L2/L3 neighbor already. \n+Maybe it will be helpful to deal with non-L2/non-L3 neighbor, e.g. VPC peering.\n+Marking remote port SG will have benefit when we don't need to send down L2 and L3 neighbor, e.g. using Gateway approach.\n+\n+Another approach is to send control packets from remote host to local host to learn about the remote port IP to its assoicated SGs, right before the remote host is ready to send traffic to local host. The problems with this approach are:\n+\n+1. latency - first packet needs to wait until the control packet learning is completed\n+2. scale - ACA handling huge number of control packet, e.g. 100s of VMs on the same network triggering at the same time\n+3. security - put control packet outside tunnel has lower risk, but inside tenent networks tunnels has high risk because tenent can mess with it\n+4. acknowledgement - what happen if control packet are missed? There is not reply mechanism\n+\n+", "originalCommit": "084256759bf8050d4a569dbcd48bdbfd49067fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU0NzM2Mw==", "url": "https://github.com/futurewei-cloud/alcor/pull/390#discussion_r515547363", "bodyText": "I think that's the discussion mentioned on line 300 where we use control packet to learn about the remote port IP to its assoicated SG, and the store that information into ACA memory (or \"registry\" to survive reboot?).", "author": "er1cthe0ne", "createdAt": "2020-10-31T22:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxMjUxMQ=="}], "type": "inlineReview"}, {"oid": "ac95dd747a4fb13f4beef22c2203c01d01f60daa", "url": "https://github.com/futurewei-cloud/alcor/commit/ac95dd747a4fb13f4beef22c2203c01d01f60daa", "message": "update per feedback", "committedDate": "2020-10-31T22:30:19Z", "type": "commit"}]}