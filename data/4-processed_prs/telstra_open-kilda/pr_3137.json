{"pr_number": 3137, "pr_title": "Test/reroute on switch up", "pr_createdAt": "2020-01-22T13:59:22Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3137", "timeline": [{"oid": "e2cee7a3907312f0943bb826e7d4f282194580e6", "url": "https://github.com/telstra/open-kilda/commit/e2cee7a3907312f0943bb826e7d4f282194580e6", "message": "update database helper by setSwitchStatus", "committedDate": "2020-01-23T10:09:39Z", "type": "forcePushed"}, {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3", "url": "https://github.com/telstra/open-kilda/commit/360c546b2dbd8a16f96d78d99c18b5915b7296e3", "message": "update database helper by setSwitchStatus", "committedDate": "2020-01-23T10:25:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODM4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370048389", "bodyText": "I don't think this wait is required", "author": "rtretyak", "createdAt": "2020-01-23T10:48:08Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {", "originalCommit": "360c546b2dbd8a16f96d78d99c18b5915b7296e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyMjEwMA==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370522100", "bodyText": "agree", "author": "andriidovhan", "createdAt": "2020-01-24T08:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODgyMA==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370048820", "bodyText": "explain this, or use a meaningful name for the variable", "author": "rtretyak", "createdAt": "2020-01-23T10:49:01Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)", "originalCommit": "360c546b2dbd8a16f96d78d99c18b5915b7296e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUzNDcyOQ==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370534729", "bodyText": "done", "author": "andriidovhan", "createdAt": "2020-01-24T09:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MDE5NA==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370050194", "bodyText": "So the flow status is still UP at this point, am I correct?", "author": "rtretyak", "createdAt": "2020-01-23T10:52:05Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)", "originalCommit": "360c546b2dbd8a16f96d78d99c18b5915b7296e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUzMjE1NA==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370532154", "bodyText": "you are right", "author": "andriidovhan", "createdAt": "2020-01-24T09:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MDE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MDkzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370050935", "bodyText": "please prefer northbound.getLink(isltToBreak)... over your construction. IslUtils implementation will request all isls, while my call will only request one", "author": "rtretyak", "createdAt": "2020-01-23T10:53:39Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(islToBreak).get().state == FAILED", "originalCommit": "360c546b2dbd8a16f96d78d99c18b5915b7296e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUzNDM5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370534392", "bodyText": "done", "author": "andriidovhan", "createdAt": "2020-01-24T09:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MDkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MjU0Mw==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370052543", "bodyText": "any chance for tidy cleanup?", "author": "rtretyak", "createdAt": "2020-01-23T10:57:06Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(islToBreak).get().state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert islUtils.getIslInfo(islToReroute).get().state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.ACTIVATED\n+        }\n+\n+        then: \"Flow is rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == backupPath\n+        }\n+\n+        //and: \"Flow is rerouted due to switchUp event\"\n+        //TODO(andriidovhan) check flow history (it is not implemented yet)\n+\n+        and: \"Restore topology, delete the flow and reset costs\"", "originalCommit": "360c546b2dbd8a16f96d78d99c18b5915b7296e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU0MzA2NA==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370543064", "bodyText": "done", "author": "andriidovhan", "createdAt": "2020-01-24T09:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MjU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MzY2Mw==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370053663", "bodyText": "If you decide to do a tidy cleanup, I suggest to remove the flow as a first step, so that just in case it ended up in 'Down' state, we don't trigger it to 'in progress' by bringing above ports to up status", "author": "rtretyak", "createdAt": "2020-01-23T10:59:41Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(islToBreak).get().state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert islUtils.getIslInfo(islToReroute).get().state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.ACTIVATED\n+        }\n+\n+        then: \"Flow is rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == backupPath\n+        }\n+\n+        //and: \"Flow is rerouted due to switchUp event\"\n+        //TODO(andriidovhan) check flow history (it is not implemented yet)\n+\n+        and: \"Restore topology, delete the flow and reset costs\"\n+        antiflap.portUp(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+        broughtDownPorts.each { antiflap.portUp(it.switchId, it.portNo) }\n+        flowHelperV2.deleteFlow(flow.flowId)", "originalCommit": "360c546b2dbd8a16f96d78d99c18b5915b7296e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU0MzA0Nw==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370543047", "bodyText": "thx, done", "author": "andriidovhan", "createdAt": "2020-01-24T09:37:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MzY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1NTM3Ng==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370055376", "bodyText": "Please don't get too keen on commenting the code whith given/when/then. These blocks must describe the test case, not the code. You can comment code using regular //comment comments", "author": "rtretyak", "createdAt": "2020-01-23T11:03:48Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"", "originalCommit": "360c546b2dbd8a16f96d78d99c18b5915b7296e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyMTc5Ng==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370521796", "bodyText": "agree", "author": "andriidovhan", "createdAt": "2020-01-24T08:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1NTM3Ng=="}], "type": "inlineReview"}, {"oid": "b97d66744e46f468748b5e83decd301b889e3579", "url": "https://github.com/telstra/open-kilda/commit/b97d66744e46f468748b5e83decd301b889e3579", "message": "update database helper by setSwitchStatus", "committedDate": "2020-01-24T09:50:46Z", "type": "forcePushed"}, {"oid": "fb804be5890c9105de0b9f064a3fad43f32b1b9e", "url": "https://github.com/telstra/open-kilda/commit/fb804be5890c9105de0b9f064a3fad43f32b1b9e", "message": "update database helper by setSwitchStatus", "committedDate": "2020-01-24T15:15:41Z", "type": "forcePushed"}, {"oid": "8c5c93ca2be612d06b9e9e3f241736495e0e7f17", "url": "https://github.com/telstra/open-kilda/commit/8c5c93ca2be612d06b9e9e3f241736495e0e7f17", "message": "update database helper by setSwitchStatus", "committedDate": "2020-01-24T15:55:07Z", "type": "forcePushed"}, {"oid": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4", "url": "https://github.com/telstra/open-kilda/commit/38f8144afebe25141083d7c6cf3f3e9fc7e1ead4", "message": "add test: Flow is rerouted after switchUp event", "committedDate": "2020-01-27T09:22:54Z", "type": "commit"}, {"oid": "03ac7e54558b35af89d492058584fbd21a5956f6", "url": "https://github.com/telstra/open-kilda/commit/03ac7e54558b35af89d492058584fbd21a5956f6", "message": "update database helper by setSwitchStatus", "committedDate": "2020-01-27T09:22:54Z", "type": "forcePushed"}, {"oid": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4", "url": "https://github.com/telstra/open-kilda/commit/38f8144afebe25141083d7c6cf3f3e9fc7e1ead4", "message": "add test: Flow is rerouted after switchUp event", "committedDate": "2020-01-27T09:22:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIzNjk4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r371236987", "bodyText": "While we don't have a history verification that the reroute reason was 'switch up event', I'd like to see an explicit assert that all the switch-related isls are up before this action (or at least one?). Otherwise - I'm not sure what was the reason of reroute and it is very easy to receive a false-successful run.", "author": "rtretyak", "createdAt": "2020-01-27T13:25:21Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,6 +407,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links and two available paths\"\n+        assumeTrue(\"Reroute should be completed before link is FAILED\", rerouteDelay * 2 < discoveryTimeout)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //Main and backup paths for further manipulation with them\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        //All alternative paths are unavailable (bring ports down on the srcSwitch)\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        //Main path more preferable than the backup\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and: \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        TimeUnit.SECONDS.sleep(rerouteDelay * 2) // it helps to be sure that the auto-reroute operation is completed\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            assert northbound.getLink(islToBreak).state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert northbound.getLink(islToReroute).state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)", "originalCommit": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0MTg5NA==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r371241894", "bodyText": "I thought L464 should be enough.\nI can add the same verification before activating the switch, but I think there is no sense\nit takes system less than second for getting from L464 to L471", "author": "andriidovhan", "createdAt": "2020-01-27T13:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIzNjk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0ODcyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r371248725", "bodyText": "OK, didn't realize that islToReroute belongs to switch to break. It's fine then", "author": "rtretyak", "createdAt": "2020-01-27T13:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIzNjk4Nw=="}], "type": "inlineReview"}]}