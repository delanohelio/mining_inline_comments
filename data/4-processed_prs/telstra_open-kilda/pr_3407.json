{"pr_number": 3407, "pr_title": "Prioritize BFD alive status over round trip status", "pr_createdAt": "2020-04-22T17:01:05Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3407", "timeline": [{"oid": "dac0fc7148f9a972c367f9e6df76427db0397400", "url": "https://github.com/telstra/open-kilda/commit/dac0fc7148f9a972c367f9e6df76427db0397400", "message": "Prioritize BFD alive status over round trip status\n\nRoute BFD events up to ISL handler (till now they reached only uni-isl\nhandler) so it can to distinguish BFD events from POLL events and handle\nthem in another way.\n\nRework ISL-handler to make prioritization of discovery/alive event\nsources.", "committedDate": "2020-04-23T08:40:30Z", "type": "forcePushed"}, {"oid": "02221cfd4d5e11578216ff5c9bc52c23f27e4c1d", "url": "https://github.com/telstra/open-kilda/commit/02221cfd4d5e11578216ff5c9bc52c23f27e4c1d", "message": "Prioritize BFD alive status over round trip status\n\nRoute BFD events up to ISL handler (till now they reached only uni-isl\nhandler) so it can to distinguish BFD events from POLL events and handle\nthem in another way.\n\nRework ISL-handler to make prioritization of discovery/alive event\nsources.", "committedDate": "2020-04-23T11:39:14Z", "type": "forcePushed"}, {"oid": "065134755dc63ce52e6bd50383b136b05d95385a", "url": "https://github.com/telstra/open-kilda/commit/065134755dc63ce52e6bd50383b136b05d95385a", "message": "Prioritize BFD alive status over round trip status\n\nRoute BFD events up to ISL handler (till now they reached only uni-isl\nhandler) so it can to distinguish BFD events from POLL events and handle\nthem in another way.\n\nRework ISL-handler to make prioritization of discovery/alive event\nsources.", "committedDate": "2020-04-24T15:02:16Z", "type": "forcePushed"}, {"oid": "f9e9640878fb2cf35bd97f6ed4db0e1487d52c6e", "url": "https://github.com/telstra/open-kilda/commit/f9e9640878fb2cf35bd97f6ed4db0e1487d52c6e", "message": "Prioritize BFD alive status over round trip status\n\nRoute BFD events up to ISL handler (till now they reached only uni-isl\nhandler) so it can to distinguish BFD events from POLL events and handle\nthem in another way.\n\nRework ISL-handler to make prioritization of discovery/alive event\nsources.", "committedDate": "2020-04-24T17:59:45Z", "type": "forcePushed"}, {"oid": "2d9261b427fbfb4a85be23aa0349f59f2f9d8065", "url": "https://github.com/telstra/open-kilda/commit/2d9261b427fbfb4a85be23aa0349f59f2f9d8065", "message": "Prioritize BFD alive status over round trip status\n\nRoute BFD events up to ISL handler (till now they reached only uni-isl\nhandler) so it can to distinguish BFD events from POLL events and handle\nthem in another way.\n\nRework ISL-handler to make prioritization of discovery/alive event\nsources.", "committedDate": "2020-04-25T17:12:50Z", "type": "forcePushed"}, {"oid": "2310a9ac44f53025707552bd1f14bfd8ede9acf6", "url": "https://github.com/telstra/open-kilda/commit/2310a9ac44f53025707552bd1f14bfd8ede9acf6", "message": "refactor BFD spec to test RTL (#3431)", "committedDate": "2020-05-04T15:46:00Z", "type": "forcePushed"}, {"oid": "031c6a349cd2214b37614d8cfd43fe051fd3c592", "url": "https://github.com/telstra/open-kilda/commit/031c6a349cd2214b37614d8cfd43fe051fd3c592", "message": "Prioritize BFD alive status over round trip status\n\nRoute BFD events up to ISL handler (till now they reached only uni-isl\nhandler) so it can to distinguish BFD events from POLL events and handle\nthem in another way.\n\nRework ISL-handler to make prioritization of discovery/alive event\nsources.", "committedDate": "2020-05-04T15:50:53Z", "type": "commit"}, {"oid": "a8c555c4e3544d921b6ed20fb31f4595d88fc6fa", "url": "https://github.com/telstra/open-kilda/commit/a8c555c4e3544d921b6ed20fb31f4595d88fc6fa", "message": "refactor RoundTripIslSpec (#3419)", "committedDate": "2020-05-04T15:50:53Z", "type": "commit"}, {"oid": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4", "url": "https://github.com/telstra/open-kilda/commit/b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4", "message": "refactor BFD spec to test RTL (#3431)", "committedDate": "2020-05-04T15:50:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI2NTAzMA==", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420265030", "bodyText": "Maybe simplify to\nboolean isEnabled = discoveryData.stream().allMatch(IslEndpointBfdStatus::isEnabled); boolean isUp = discoveryData.stream().anyMatch(status -> status.getStatus() == IslStatus.ACTIVE);", "author": "rozdy", "createdAt": "2020-05-05T17:00:31Z", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/isl/DiscoveryBfdMonitor.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.network.controller.isl;\n+\n+import org.openkilda.model.Isl;\n+import org.openkilda.model.IslDownReason;\n+import org.openkilda.model.IslStatus;\n+import org.openkilda.wfm.share.model.Endpoint;\n+import org.openkilda.wfm.share.model.IslReference;\n+import org.openkilda.wfm.topology.network.controller.isl.IslFsm.IslFsmContext;\n+import org.openkilda.wfm.topology.network.controller.isl.IslFsm.IslFsmEvent;\n+import org.openkilda.wfm.topology.network.model.IslEndpointBfdStatus;\n+\n+import java.util.Iterator;\n+import java.util.Optional;\n+\n+public class DiscoveryBfdMonitor extends DiscoveryMonitor<IslEndpointBfdStatus> {\n+    public DiscoveryBfdMonitor(IslReference reference) {\n+        super(reference);\n+\n+        IslEndpointBfdStatus dummy = new IslEndpointBfdStatus();\n+        discoveryData.putBoth(dummy);\n+        cache.putBoth(dummy);\n+    }\n+\n+    @Override\n+    public Optional<IslStatus> evaluateStatus() {\n+        boolean isEnabled = true;\n+        boolean isUp = false;\n+\n+        for (Iterator<IslEndpointBfdStatus> it = discoveryData.stream().iterator(); it.hasNext(); ) {\n+            IslEndpointBfdStatus entry = it.next();\n+\n+            isEnabled &= entry.isEnabled();  // only if both endpoint are BFD capable we can use BFD statuses\n+            isUp |= entry.getStatus() == IslStatus.ACTIVE;\n+        }", "originalCommit": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMzA2MQ==", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420633061", "bodyText": "It is not simplification - you travel 2 times for each entry i.e. use 2 consecutive loops.", "author": "surabujin", "createdAt": "2020-05-06T08:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI2NTAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDYxMw==", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420290613", "bodyText": "resoruces -> resources", "author": "rozdy", "createdAt": "2020-05-05T17:41:20Z", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/isl/IslFsm.java", "diffHunk": "@@ -126,278 +125,229 @@ public IslFsm(Clock clock, PersistenceManager persistenceManager, IslReportFsm r\n         featureTogglesRepository = repositoryFactory.createFeatureTogglesRepository();\n         switchPropertiesRepository = repositoryFactory.createSwitchPropertiesRepository();\n \n-        roundTripExpirationTime = Duration.ofNanos(options.getDiscoveryTimeout());\n-\n-        this.reference = reference;\n-\n-        endpointStatus = new BiIslDataHolder<>(reference);\n-        endpointStatus.putBoth(new IslEndpointStatus(IslEndpointStatus.Status.DOWN));\n-\n-        endpointRoundTripStatus = new BiIslDataHolder<>(reference);\n-        endpointRoundTripStatus.put(reference.getSource(), new IslEndpointRoundTripStatus());\n-        endpointRoundTripStatus.put(reference.getDest(), new IslEndpointRoundTripStatus());\n-\n-        discoveryFacts = new DiscoveryFacts(reference);\n-        this.options = options;\n+        transactionManager = persistenceManager.getTransactionManager();\n+        transactionRetryPolicy = transactionManager.makeRetryPolicyBlank()\n+                .withMaxDuration(options.getDbRepeatMaxDurationSeconds(), TimeUnit.SECONDS);\n     }\n \n     // -- FSM actions --\n \n-    public void handleHistory(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        applyHistory(context.getHistory());\n+    public void operationalEnter(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        monitorsByPriority = ImmutableList.of(\n+                new DiscoveryPortStatusMonitor(reference),\n+                new DiscoveryBfdMonitor(reference),\n+                new DiscoveryRoundTripMonitor(reference, clock, options),\n+                new DiscoveryPollMonitor(reference));\n \n-        IslFsmEvent route;\n-        IslEndpointStatus.Status status = getAggregatedStatus();\n-        switch (status) {\n-            case UP:\n-                route = IslFsmEvent._HISTORY_UP;\n-                ignoreRerouteOnUp = true;\n-                break;\n-            case DOWN:\n-                route = IslFsmEvent._HISTORY_DOWN;\n-                break;\n-            case MOVED:\n-                route = IslFsmEvent._HISTORY_MOVED;\n-                break;\n-            default:\n-                throw new IllegalArgumentException(makeInvalidMappingMessage(\n-                        status.getClass(), IslFsmEvent.class, status));\n-        }\n+        transactionManager.doInTransaction(() -> {\n+            loadPersistentData(reference.getSource(), reference.getDest());\n+            loadPersistentData(reference.getDest(), reference.getSource());\n+        });\n \n-        fire(route, context);\n-    }\n+        evaluateStatus();\n \n-    public void historyRestoreUp(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        sendBfdEnable(context.getOutput());\n+        if (effectiveStatus == IslStatus.ACTIVE) {\n+            sendBfdEnable(context.getOutput());\n+        }\n     }\n \n-    public void handleInitialDiscovery(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateLinkData(context.getEndpoint(), context.getIslData());\n-        updateEndpointStatusByEvent(event, context);\n-        saveStatusTransaction();\n+    public void operationalExit(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        bfdManager.disable(context.getOutput());\n     }\n \n-    public void updateEndpointStatus(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateEndpointStatusByEvent(event, context);\n-    }\n+    public void updateMonitorsAction(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        boolean isSyncRequired = false;\n+        for (DiscoveryMonitor<?> entry : monitorsByPriority) {\n+            isSyncRequired |= entry.update(event, context);\n+        }\n \n-    public void updateAndPersistEndpointStatus(IslFsmState from, IslFsmState to, IslFsmEvent event,\n-                                               IslFsmContext context) {\n-        updateEndpointStatusByEvent(event, context);\n-        saveStatusTransaction();\n+        if (evaluateStatus()) {\n+            fireBecomeStateEvent(context);\n+        } else if (isSyncRequired) {\n+            fire(IslFsmEvent._FLUSH);\n+        }\n     }\n \n-    public void downEnter(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        reportFsm.fire(IslReportFsm.Event.BECOME_DOWN);\n-\n-        saveStatusTransaction();\n-        sendIslStatusUpdateNotification(context, IslStatus.INACTIVE);\n+    public void flushAction(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        flushTransaction();\n     }\n \n-    public void handleUpAttempt(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateLinkData(context.getEndpoint(), context.getIslData());\n-\n-        IslFsmEvent route;\n-        if (getAggregatedStatus() == IslEndpointStatus.Status.UP) {\n-            route = IslFsmEvent._UP_ATTEMPT_SUCCESS;\n-        } else {\n-            route = IslFsmEvent._UP_ATTEMPT_FAIL;\n+    public void removeAttempt(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        if (effectiveStatus != IslStatus.ACTIVE) {\n+            fire(IslFsmEvent._REMOVE_CONFIRMED, context);\n         }\n-        fire(route, context);\n     }\n \n     public void setUpResourcesEnter(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        log.info(\"ISL {} become {}\", discoveryFacts.getReference(), to);\n+        log.info(\"ISL {} initiate speaker resources setup process\", reference);\n+\n         islRulesAttempts = options.getRulesSynchronizationAttempts();\n-        sendInstallMultitable(context);\n-    }\n+        endpointMultiTableManagementCompleteStatus.putBoth(false);\n \n-    public void setUpResourcesTimeout(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        islRulesAttempts -= 1;\n-        if (islRulesAttempts >= 0) {\n-            log.info(\"Retrying to install rules for multi table mode on isl {}\", discoveryFacts.getReference());\n-            sendInstallMultitable(context);\n-        } else {\n-            log.warn(\"Failed to install rules for multi table mode on isl {}, required manual rule sync\",\n-                    discoveryFacts.getReference());\n-            endpointStatus.getForward().setHasIslRules(true);\n-            endpointStatus.getReverse().setHasIslRules(true);\n-            fire(IslFsmEvent.ISL_UP, context);\n-        }\n-    }\n+        sendInstallMultiTable(context.getOutput());\n \n-    public void cleanUpResourcesTimeout(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        islRulesAttempts -= 1;\n-        if (islRulesAttempts >= 0) {\n-            log.info(\"Retrying to remove rules for multi table mode on isl {}\", discoveryFacts.getReference());\n-            sendRemoveMultitable(context);\n-        } else {\n-            log.warn(\"Failed to remove rules for multi table mode on isl {}, required manual rule sync\",\n-                    discoveryFacts.getReference());\n-            endpointStatus.getForward().setHasIslRules(false);\n-            endpointStatus.getReverse().setHasIslRules(false);\n-            fire(IslFsmEvent.ISL_REMOVE_FINISHED, context);\n+        if (isMultiTableManagementCompleted()) {\n+            fire(IslFsmEvent._RESOURCES_DONE, context);\n         }\n     }\n \n-    public void upEnter(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        reportFsm.fire(IslReportFsm.Event.BECOME_UP);\n-\n-        saveAllTransaction();\n-        sendBfdEnable(context.getOutput());\n-\n-        if (!ignoreRerouteOnUp) {\n-            // Do not produce reroute during recovery system state from DB\n-            triggerDownFlowReroute(context);\n-        } else {\n-            ignoreRerouteOnUp = false;\n+    // FIXME(surabujin): protect from stale responses\n+    public void handleInstalledRule(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        Endpoint endpoint = context.getInstalledRulesEndpoint();\n+        if (endpoint == null) {\n+            throw new IllegalArgumentException(makeInvalidResourceManipulationResponseMessage());\n         }\n-    }\n \n-    public void upHandlePhysicalDown(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateEndpointStatusByEvent(event, context);\n-        saveStatusAndSetIslUnstableTimeTransaction();\n+        log.info(\"Receive response on ISL resource allocation request for {} (from {})\",\n+                reference, endpoint.getDatapath());\n+        endpointMultiTableManagementCompleteStatus.put(endpoint, true);\n+        if (isMultiTableManagementCompleted()) {\n+            fire(IslFsmEvent._RESOURCES_DONE, context);\n+        }\n     }\n \n-    public void upHandlePollEvent(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateEndpointStatusByEvent(event, context);\n-        saveStatusTransaction();\n-\n-        if (getAggregatedStatus() != IslEndpointStatus.Status.UP) {\n-            fire(IslFsmEvent._BECOME_DOWN, context);\n+    public void setUpResourcesTimeout(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        if (--islRulesAttempts >= 0) {\n+            log.info(\"Retrying ISL resoruces setup for {} (attempts lefs:{})\", reference, islRulesAttempts);", "originalCommit": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMzQ0Mg==", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420633442", "bodyText": "nice catch", "author": "surabujin", "createdAt": "2020-05-06T08:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwNDk2MA==", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420304960", "bodyText": "Why not to delete this class right now?", "author": "rozdy", "createdAt": "2020-05-05T18:04:40Z", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/model/TickClock.java", "diffHunk": "@@ -17,6 +17,7 @@\n \n import lombok.Getter;\n \n+// TODO - del", "originalCommit": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzNjU3Ng==", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420636576", "bodyText": "It is not related to the current change. This is my own reminder, it should not appear in final commit.", "author": "surabujin", "createdAt": "2020-05-06T08:50:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwNDk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwNTUzNw==", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420305537", "bodyText": "Why not to delete this class right now?", "author": "rozdy", "createdAt": "2020-05-05T18:05:35Z", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/model/IslEndpointStatus.java", "diffHunk": "@@ -20,6 +20,7 @@\n import lombok.Data;\n import lombok.Getter;\n \n+// TODO - del?", "originalCommit": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzODE5OA==", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420638198", "bodyText": "same here", "author": "surabujin", "createdAt": "2020-05-06T08:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwNTUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwOTE2Nw==", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420309167", "bodyText": "Didn't get it. Add some details please.", "author": "rozdy", "createdAt": "2020-05-05T18:11:38Z", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/storm/bolt/isl/IslHandler.java", "diffHunk": "@@ -160,12 +161,14 @@ public void islDefaultRulesDelete(Endpoint source, Endpoint destination) {\n         emit(STREAM_SPEAKER_RULES_ID, getCurrentTuple(), makeIslRulesDeleteTuple(source, destination));\n     }\n \n+    // FIXME(surabujin) - storm handler design violation", "originalCommit": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0Mjg5Ng==", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420642896", "bodyText": "Original design supposes for storm bolt to have makeStreamNameTuple methods for each stream. Here we define 2 such methods for 1 stream.", "author": "surabujin", "createdAt": "2020-05-06T09:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwOTE2Nw=="}], "type": "inlineReview"}, {"oid": "dfc57b176ac3110be4ecc2edd8a8bc9108340b5e", "url": "https://github.com/telstra/open-kilda/commit/dfc57b176ac3110be4ecc2edd8a8bc9108340b5e", "message": "refactor BFD spec to test RTL (#3431)", "committedDate": "2020-05-06T14:42:04Z", "type": "forcePushed"}, {"oid": "67d95034df316a4200f572a4874af268cf761b48", "url": "https://github.com/telstra/open-kilda/commit/67d95034df316a4200f572a4874af268cf761b48", "message": "refactor BFD spec to test RTL (#3431)", "committedDate": "2020-05-07T08:47:51Z", "type": "commit"}, {"oid": "67d95034df316a4200f572a4874af268cf761b48", "url": "https://github.com/telstra/open-kilda/commit/67d95034df316a4200f572a4874af268cf761b48", "message": "refactor BFD spec to test RTL (#3431)", "committedDate": "2020-05-07T08:47:51Z", "type": "forcePushed"}]}