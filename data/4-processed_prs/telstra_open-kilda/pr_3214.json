{"pr_number": 3214, "pr_title": "add test for isl alive confirmation via round trip latency", "pr_createdAt": "2020-02-17T15:03:04Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3214", "timeline": [{"oid": "fd21a4b2668c6779998368d188fbc2c85fa20b67", "url": "https://github.com/telstra/open-kilda/commit/fd21a4b2668c6779998368d188fbc2c85fa20b67", "message": "add test for isl alive confirmation via round trip latency", "committedDate": "2020-02-17T15:13:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0MjU1OQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380242559", "bodyText": "Remove 'noviflow' from everywhere.\n\nIt is not because the switch is noviflow, it is because we use round trip latency to determine the isl state\nWhen looking for switch, look at the switch features in order to determine whether the switch supports round trip latency (it can be an OVS switch in the future). The switch feature name which is used by system now is NOVIFLOW_COPY_FIELD", "author": "rtretyak", "createdAt": "2020-02-17T15:23:38Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "diffHunk": "@@ -651,6 +654,50 @@ class LinkSpec extends HealthCheckSpecification {\n         getIsl().srcSwitch.dpId | getIsl().srcPort | getIsl().dstSwitch.dpId | null      | \"dst_port\"\n     }\n \n+    @Tidy\n+    @Tags(HARDWARE)\n+    def \"An ISL between noviflow switches doesn't go down when one switch is DEACTIVATED\"(){", "originalCommit": "fd21a4b2668c6779998368d188fbc2c85fa20b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxMzAwNQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380513005", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-02-18T08:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0MjU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0NDgxNA==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380244814", "bodyText": "all  round trip latency isls", "author": "rtretyak", "createdAt": "2020-02-17T15:27:44Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "diffHunk": "@@ -651,6 +654,50 @@ class LinkSpec extends HealthCheckSpecification {\n         getIsl().srcSwitch.dpId | getIsl().srcPort | getIsl().dstSwitch.dpId | null      | \"dst_port\"\n     }\n \n+    @Tidy\n+    @Tags(HARDWARE)\n+    def \"An ISL between noviflow switches doesn't go down when one switch is DEACTIVATED\"(){\n+        given: \"A noviflow switch\"\n+        def swToDeactivate = topology.activeSwitches.find { it.noviflow }\n+\n+        when: \"Deactivate the src switch\"\n+        def relatedIsl = topology.getRelatedIsls(swToDeactivate)\n+        def nonNoviflowIsl = relatedIsl.find { !it.dstSwitch.noviflow }\n+\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def IsSwDeactivated = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All ISLs are still DISCOVERED because the system uses round trip latency for ISL alive confirmation\"", "originalCommit": "fd21a4b2668c6779998368d188fbc2c85fa20b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxNDA5NA==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380514094", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-02-18T08:15:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0NDgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0NTM0MQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380245341", "bodyText": "Why use timed loop here?", "author": "rtretyak", "createdAt": "2020-02-17T15:28:49Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "diffHunk": "@@ -651,6 +654,50 @@ class LinkSpec extends HealthCheckSpecification {\n         getIsl().srcSwitch.dpId | getIsl().srcPort | getIsl().dstSwitch.dpId | null      | \"dst_port\"\n     }\n \n+    @Tidy\n+    @Tags(HARDWARE)\n+    def \"An ISL between noviflow switches doesn't go down when one switch is DEACTIVATED\"(){\n+        given: \"A noviflow switch\"\n+        def swToDeactivate = topology.activeSwitches.find { it.noviflow }\n+\n+        when: \"Deactivate the src switch\"\n+        def relatedIsl = topology.getRelatedIsls(swToDeactivate)\n+        def nonNoviflowIsl = relatedIsl.find { !it.dstSwitch.noviflow }\n+\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def IsSwDeactivated = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All ISLs are still DISCOVERED because the system uses round trip latency for ISL alive confirmation\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        // make sure that ISLs are not in FAILED status after timeout\n+        Wrappers.timedLoop(WAIT_OFFSET / 2) {", "originalCommit": "fd21a4b2668c6779998368d188fbc2c85fa20b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxNDE1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380514152", "bodyText": "deleted", "author": "andriidovhan", "createdAt": "2020-02-18T08:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0NTM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0NTg1Nw==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380245857", "bodyText": "eachParallel. Or assert the whole loop rather than each isl", "author": "rtretyak", "createdAt": "2020-02-17T15:29:50Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "diffHunk": "@@ -651,6 +654,50 @@ class LinkSpec extends HealthCheckSpecification {\n         getIsl().srcSwitch.dpId | getIsl().srcPort | getIsl().dstSwitch.dpId | null      | \"dst_port\"\n     }\n \n+    @Tidy\n+    @Tags(HARDWARE)\n+    def \"An ISL between noviflow switches doesn't go down when one switch is DEACTIVATED\"(){\n+        given: \"A noviflow switch\"\n+        def swToDeactivate = topology.activeSwitches.find { it.noviflow }\n+\n+        when: \"Deactivate the src switch\"\n+        def relatedIsl = topology.getRelatedIsls(swToDeactivate)\n+        def nonNoviflowIsl = relatedIsl.find { !it.dstSwitch.noviflow }\n+\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def IsSwDeactivated = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All ISLs are still DISCOVERED because the system uses round trip latency for ISL alive confirmation\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        // make sure that ISLs are not in FAILED status after timeout\n+        Wrappers.timedLoop(WAIT_OFFSET / 2) {\n+            withPool {\n+                (relatedIsl - nonNoviflowIsl).everyParallel { link ->", "originalCommit": "fd21a4b2668c6779998368d188fbc2c85fa20b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxNDE4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380514186", "bodyText": "done", "author": "andriidovhan", "createdAt": "2020-02-18T08:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0NTg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0NzMzMw==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380247333", "bodyText": "This is a bit misleading. You can have a situation when you pick a switch that do not have non-noviflow neighbors. In this case your test will state that it checked that All ISLs where at least one switch is not Noviflow are FAILED, but in fact it will skip this check", "author": "rtretyak", "createdAt": "2020-02-17T15:32:38Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "diffHunk": "@@ -651,6 +654,50 @@ class LinkSpec extends HealthCheckSpecification {\n         getIsl().srcSwitch.dpId | getIsl().srcPort | getIsl().dstSwitch.dpId | null      | \"dst_port\"\n     }\n \n+    @Tidy\n+    @Tags(HARDWARE)\n+    def \"An ISL between noviflow switches doesn't go down when one switch is DEACTIVATED\"(){\n+        given: \"A noviflow switch\"\n+        def swToDeactivate = topology.activeSwitches.find { it.noviflow }\n+\n+        when: \"Deactivate the src switch\"\n+        def relatedIsl = topology.getRelatedIsls(swToDeactivate)\n+        def nonNoviflowIsl = relatedIsl.find { !it.dstSwitch.noviflow }\n+\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def IsSwDeactivated = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All ISLs are still DISCOVERED because the system uses round trip latency for ISL alive confirmation\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        // make sure that ISLs are not in FAILED status after timeout\n+        Wrappers.timedLoop(WAIT_OFFSET / 2) {\n+            withPool {\n+                (relatedIsl - nonNoviflowIsl).everyParallel { link ->\n+                    assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+                }\n+            }\n+        }\n+\n+        and: \"All ISLs where at least one switch is not Noviflow are FAILED\"", "originalCommit": "fd21a4b2668c6779998368d188fbc2c85fa20b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxNDU0NQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380514545", "bodyText": "fixed in the given block", "author": "andriidovhan", "createdAt": "2020-02-18T08:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0NzMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0NzYzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380247635", "bodyText": "camelCase", "author": "rtretyak", "createdAt": "2020-02-17T15:33:10Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "diffHunk": "@@ -651,6 +654,50 @@ class LinkSpec extends HealthCheckSpecification {\n         getIsl().srcSwitch.dpId | getIsl().srcPort | getIsl().dstSwitch.dpId | null      | \"dst_port\"\n     }\n \n+    @Tidy\n+    @Tags(HARDWARE)\n+    def \"An ISL between noviflow switches doesn't go down when one switch is DEACTIVATED\"(){\n+        given: \"A noviflow switch\"\n+        def swToDeactivate = topology.activeSwitches.find { it.noviflow }\n+\n+        when: \"Deactivate the src switch\"\n+        def relatedIsl = topology.getRelatedIsls(swToDeactivate)\n+        def nonNoviflowIsl = relatedIsl.find { !it.dstSwitch.noviflow }\n+\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def IsSwDeactivated = true", "originalCommit": "fd21a4b2668c6779998368d188fbc2c85fa20b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxMzAzMg==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380513032", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-02-18T08:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0NzYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0ODczNw==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380248737", "bodyText": "I'm surprised that no other tests required any refactoring. There should be tests that check that ISLs go to failed status when a switch fails. And they should become broken now", "author": "rtretyak", "createdAt": "2020-02-17T15:35:14Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "diffHunk": "@@ -651,6 +654,50 @@ class LinkSpec extends HealthCheckSpecification {\n         getIsl().srcSwitch.dpId | getIsl().srcPort | getIsl().dstSwitch.dpId | null      | \"dst_port\"\n     }\n \n+    @Tidy\n+    @Tags(HARDWARE)\n+    def \"An ISL between noviflow switches doesn't go down when one switch is DEACTIVATED\"(){\n+        given: \"A noviflow switch\"\n+        def swToDeactivate = topology.activeSwitches.find { it.noviflow }\n+\n+        when: \"Deactivate the src switch\"\n+        def relatedIsl = topology.getRelatedIsls(swToDeactivate)\n+        def nonNoviflowIsl = relatedIsl.find { !it.dstSwitch.noviflow }\n+\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def IsSwDeactivated = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All ISLs are still DISCOVERED because the system uses round trip latency for ISL alive confirmation\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        // make sure that ISLs are not in FAILED status after timeout\n+        Wrappers.timedLoop(WAIT_OFFSET / 2) {\n+            withPool {\n+                (relatedIsl - nonNoviflowIsl).everyParallel { link ->\n+                    assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+                }\n+            }\n+        }\n+\n+        and: \"All ISLs where at least one switch is not Noviflow are FAILED\"\n+        withPool {\n+            nonNoviflowIsl.everyParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.FAILED\n+            }\n+        }\n+\n+        cleanup:\n+        IsSwDeactivated && lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+", "originalCommit": "fd21a4b2668c6779998368d188fbc2c85fa20b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxNzIxOQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r380517219", "bodyText": "I'm surprised that no other tests required any refactoring.\n\nI haven't investigated it yet\n\nThere should be tests that check that ISLs go to failed status when a switch fails. And they should become\nbroken now\n\nagree", "author": "andriidovhan", "createdAt": "2020-02-18T08:23:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0ODczNw=="}], "type": "inlineReview"}, {"oid": "538efa12f47a33742be375be15505f8a8613641d", "url": "https://github.com/telstra/open-kilda/commit/538efa12f47a33742be375be15505f8a8613641d", "message": "add test for isl alive confirmation via round trip latency", "committedDate": "2020-02-18T08:28:21Z", "type": "forcePushed"}, {"oid": "489a8932e2c3471d56a27a819c63e512aa802364", "url": "https://github.com/telstra/open-kilda/commit/489a8932e2c3471d56a27a819c63e512aa802364", "message": "add missing tags", "committedDate": "2020-02-18T10:52:46Z", "type": "forcePushed"}, {"oid": "59fe1b0fb880f2bbd45c381917b9ed3dab7ba1ac", "url": "https://github.com/telstra/open-kilda/commit/59fe1b0fb880f2bbd45c381917b9ed3dab7ba1ac", "message": "add missing tags", "committedDate": "2020-02-18T14:19:01Z", "type": "forcePushed"}, {"oid": "33fa596ac772a398c87f24ca5d4097d88d47bf4c", "url": "https://github.com/telstra/open-kilda/commit/33fa596ac772a398c87f24ca5d4097d88d47bf4c", "message": "fix URL for blocking fl via lab-api", "committedDate": "2020-02-21T13:48:17Z", "type": "forcePushed"}, {"oid": "8d422889040f2d12ce56cd646ff85c1aa832a66c", "url": "https://github.com/telstra/open-kilda/commit/8d422889040f2d12ce56cd646ff85c1aa832a66c", "message": "fix URL for blocking fl via lab-api", "committedDate": "2020-02-24T14:30:36Z", "type": "forcePushed"}, {"oid": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "url": "https://github.com/telstra/open-kilda/commit/3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "message": "fix URL for blocking fl via lab-api", "committedDate": "2020-02-24T14:34:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwMTM1MA==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383301350", "bodyText": "Reason looks unrelated", "author": "rtretyak", "createdAt": "2020-02-24T14:38:09Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -500,6 +501,62 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n     }\n \n     @Tidy\n+    @Tags(HARDWARE)\n+    def \"Flow in 'UP' status is not rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches which support round trip latency\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            swP.paths.findAll { path ->\n+                path.size() == 2 && pathHelper.getInvolvedSwitches(path).every {\n+                    it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+            }\n+        } ?: assumeTrue(\"No suiting switches found for the first flow\", false)", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcwMTU2Nw==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383701567", "bodyText": "my bad, fixed", "author": "andriidovhan", "createdAt": "2020-02-25T07:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwMTM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwMTU5Ng==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383301596", "bodyText": "remove", "author": "rtretyak", "createdAt": "2020-02-24T14:38:32Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -500,6 +501,62 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n     }\n \n     @Tidy\n+    @Tags(HARDWARE)\n+    def \"Flow in 'UP' status is not rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches which support round trip latency\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            swP.paths.findAll { path ->\n+                path.size() == 2 && pathHelper.getInvolvedSwitches(path).every {\n+                    it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+            }\n+        } ?: assumeTrue(\"No suiting switches found for the first flow\", false)\n+\n+        and: \"A flow on the given switch pair\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        println(flow.flowId)", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcwMTgyMQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383701821", "bodyText": "done", "author": "andriidovhan", "createdAt": "2020-02-25T07:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwMTU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwMjM3MQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383302371", "bodyText": "Ok, but it is not the reason to use isl discovery timeout while waiting. It is not related. Hardcode a separate timeout", "author": "rtretyak", "createdAt": "2020-02-24T14:39:44Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -500,6 +501,62 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n     }\n \n     @Tidy\n+    @Tags(HARDWARE)\n+    def \"Flow in 'UP' status is not rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches which support round trip latency\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            swP.paths.findAll { path ->\n+                path.size() == 2 && pathHelper.getInvolvedSwitches(path).every {\n+                    it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+            }\n+        } ?: assumeTrue(\"No suiting switches found for the first flow\", false)\n+\n+        and: \"A flow on the given switch pair\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        println(flow.flowId)\n+\n+        when: \"Deactivate the src switch\"\n+        def swToDeactivate = switchPair.src\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcwMTI0Nw==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383701247", "bodyText": "initially it was separated variable, but then I changed it, I have no idea why\nnew variable is added  customWaitOffset", "author": "andriidovhan", "createdAt": "2020-02-25T07:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwMjM3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcwMzIyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383703225", "bodyText": "in addition it is fixed everywhere", "author": "andriidovhan", "createdAt": "2020-02-25T07:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwMjM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwNDA0Mw==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383304043", "bodyText": "really required only if lockKeeper.reviveSwitch(swToDeactivate) happen", "author": "rtretyak", "createdAt": "2020-02-24T14:42:31Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -500,6 +501,62 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n     }\n \n     @Tidy\n+    @Tags(HARDWARE)\n+    def \"Flow in 'UP' status is not rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches which support round trip latency\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            swP.paths.findAll { path ->\n+                path.size() == 2 && pathHelper.getInvolvedSwitches(path).every {\n+                    it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+            }\n+        } ?: assumeTrue(\"No suiting switches found for the first flow\", false)\n+\n+        and: \"A flow on the given switch pair\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        println(flow.flowId)\n+\n+        when: \"Deactivate the src switch\"\n+        def swToDeactivate = switchPair.src\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"Flow is UP\"\n+        northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+\n+        when: \"Activate the src switch\"\n+        lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        isSwDeactivated = false\n+\n+        then: \"System doesn't try to reroute the flow on the switchUp event because flow is already in UP state\"\n+        Wrappers.timedLoop(rerouteDelay + WAIT_OFFSET / 2) {\n+            assert northbound.getFlowHistory(flow.flowId).findAll { it.action == \"Flow rerouting\" }.empty\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        isSwDeactivated && lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(WAIT_OFFSET) {", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcwNDQwMQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383704401", "bodyText": "agree, fixed", "author": "andriidovhan", "createdAt": "2020-02-25T07:44:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwNDA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwOTQ0OQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383309449", "bodyText": "same", "author": "rtretyak", "createdAt": "2020-02-24T14:51:22Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxMDc1NQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383710755", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-02-25T08:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwOTQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxMDk2Ng==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383310966", "bodyText": "I think it's better to first wait for failed ISLs, and then show that round-trip ISLs remain discovered on the other hand. Also, this will allow you to sleep for less time and then use wait, instead of sleeping for too long.", "author": "rtretyak", "createdAt": "2020-02-24T14:53:48Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All round trip latency ISLs are still DISCOVERED (the system uses round trip latency \\\n+for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        withPool {\n+            roundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+\n+        and: \"All non round trip latency ISLs are FAILED\"", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxNDAwMQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383714001", "bodyText": "I changed the order of checking.\nI would prefer to sleep for discoveryTimeout,\nAs for me it allows to be sure that ISLs are either  DISCOVERED or FAILED", "author": "andriidovhan", "createdAt": "2020-02-25T08:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxMDk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxMTc3MA==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383311770", "bodyText": "when: \"Deactivate the switch\"\nthen: \"All round trip latency ISLs are still DISCOVERED\n\nNot clear steps as for me. If you use word 'still', please mention that you waited for timeout time, or add wait as a separate step", "author": "rtretyak", "createdAt": "2020-02-24T14:55:09Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All round trip latency ISLs are still DISCOVERED (the system uses round trip latency \\", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxMTU5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383711592", "bodyText": "added separate step", "author": "andriidovhan", "createdAt": "2020-02-25T08:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxMTc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxNDM1NQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383314355", "bodyText": "same. still related to what?", "author": "rtretyak", "createdAt": "2020-02-24T14:59:05Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All round trip latency ISLs are still DISCOVERED (the system uses round trip latency \\\n+for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        withPool {\n+            roundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+\n+        and: \"All non round trip latency ISLs are FAILED\"\n+        withPool {\n+            nonRoundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.FAILED\n+            }\n+        }\n+\n+        cleanup:\n+        isSwDeactivated && lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when both switches are DEACTIVATED\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSwToDeactivate = roundTripIsl.dstSwitch\n+\n+        when: \"Deactivate the src switch\"\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5ODE4NQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383798185", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-02-25T10:42:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxNDM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxNTY2OA==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383315668", "bodyText": "why you oversleep if you can wait?", "author": "rtretyak", "createdAt": "2020-02-24T15:01:14Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All round trip latency ISLs are still DISCOVERED (the system uses round trip latency \\\n+for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        withPool {\n+            roundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+\n+        and: \"All non round trip latency ISLs are FAILED\"\n+        withPool {\n+            nonRoundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.FAILED\n+            }\n+        }\n+\n+        cleanup:\n+        isSwDeactivated && lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when both switches are DEACTIVATED\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSwToDeactivate = roundTripIsl.dstSwitch\n+\n+        when: \"Deactivate the src switch\"\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        when: \"Deactivate the dst switch\"\n+        lockKeeper.knockoutSwitch(dstSwToDeactivate)\n+        def isDstSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip latency ISL is FAILED (because round_trip_status is not available in DB for current ISL \\\n+on both switches)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5ODM0OA==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383798348", "bodyText": "my fault. fixed", "author": "andriidovhan", "createdAt": "2020-02-25T10:42:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxNTY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxNjYxNg==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383316616", "bodyText": "I'm not sure that I like the scenario. Isn't it better to simultaneously knockout 2 switches? The part that proves that ISL will remain DISCOVERED when 1 side is down is already covered in previous test, while simultaneous knockout may be an edge case (consult with Dmitriy)", "author": "rtretyak", "createdAt": "2020-02-24T15:02:45Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All round trip latency ISLs are still DISCOVERED (the system uses round trip latency \\\n+for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        withPool {\n+            roundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+\n+        and: \"All non round trip latency ISLs are FAILED\"\n+        withPool {\n+            nonRoundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.FAILED\n+            }\n+        }\n+\n+        cleanup:\n+        isSwDeactivated && lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when both switches are DEACTIVATED\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSwToDeactivate = roundTripIsl.dstSwitch\n+\n+        when: \"Deactivate the src switch\"\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        when: \"Deactivate the dst switch\"\n+        lockKeeper.knockoutSwitch(dstSwToDeactivate)\n+        def isDstSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip latency ISL is FAILED (because round_trip_status is not available in DB for current ISL \\\n+on both switches)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        cleanup:\n+        isSrcSwDeactivated && lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        isDstSwDeactivated && lockKeeper.reviveSwitch(dstSwToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5ODQzMg==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383798432", "bodyText": "Isn't it better to simultaneously knockout 2 switches?\n\nagree, it would be better\ntest is refactored", "author": "andriidovhan", "createdAt": "2020-02-25T10:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxNjYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMjUxOA==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383322518", "bodyText": "I don't think that we should call it 'Deactivate the switch' in these scenarios. Deactivating the switch may be understood as if the switch actually became down. In these scenarios it is very important that we actually lose connection to switch, but the switch itself remains operable.", "author": "rtretyak", "createdAt": "2020-02-24T15:12:50Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxMDY3NQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383710675", "bodyText": "changed to -> when: \"Simulate connection lose between the switch and FL, the switch becomes DEACTIVATED and remains operable\"", "author": "andriidovhan", "createdAt": "2020-02-25T08:01:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMjUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMzYxNg==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383323616", "bodyText": "Is it mandatory to verify this again and again? It is actually a very time-consuming verification", "author": "rtretyak", "createdAt": "2020-02-24T15:14:37Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All round trip latency ISLs are still DISCOVERED (the system uses round trip latency \\\n+for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        withPool {\n+            roundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+\n+        and: \"All non round trip latency ISLs are FAILED\"\n+        withPool {\n+            nonRoundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.FAILED\n+            }\n+        }\n+\n+        cleanup:\n+        isSwDeactivated && lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when both switches are DEACTIVATED\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSwToDeactivate = roundTripIsl.dstSwitch\n+\n+        when: \"Deactivate the src switch\"\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        when: \"Deactivate the dst switch\"\n+        lockKeeper.knockoutSwitch(dstSwToDeactivate)\n+        def isDstSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip latency ISL is FAILED (because round_trip_status is not available in DB for current ISL \\\n+on both switches)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        cleanup:\n+        isSrcSwDeactivated && lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        isDstSwDeactivated && lockKeeper.reviveSwitch(dstSwToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when the src switch is DEACTIVATED and round trip latency rule is removed \\\n+on the dst switch\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSw = roundTripIsl.dstSwitch\n+\n+        and: \"Round trip status is ACTIVE for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert database.getIslRoundTripStatus(isl) == IslStatus.ACTIVE\n+        }\n+\n+        when: \"Deactivate the src switch\"\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5OTU2NA==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383799564", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-02-25T10:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMzYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNDE4MQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383324181", "bodyText": "don't sleep. use wait.", "author": "rtretyak", "createdAt": "2020-02-24T15:15:31Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All round trip latency ISLs are still DISCOVERED (the system uses round trip latency \\\n+for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        withPool {\n+            roundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+\n+        and: \"All non round trip latency ISLs are FAILED\"\n+        withPool {\n+            nonRoundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.FAILED\n+            }\n+        }\n+\n+        cleanup:\n+        isSwDeactivated && lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when both switches are DEACTIVATED\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSwToDeactivate = roundTripIsl.dstSwitch\n+\n+        when: \"Deactivate the src switch\"\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        when: \"Deactivate the dst switch\"\n+        lockKeeper.knockoutSwitch(dstSwToDeactivate)\n+        def isDstSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip latency ISL is FAILED (because round_trip_status is not available in DB for current ISL \\\n+on both switches)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        cleanup:\n+        isSrcSwDeactivated && lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        isDstSwDeactivated && lockKeeper.reviveSwitch(dstSwToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when the src switch is DEACTIVATED and round trip latency rule is removed \\\n+on the dst switch\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSw = roundTripIsl.dstSwitch\n+\n+        and: \"Round trip status is ACTIVE for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert database.getIslRoundTripStatus(isl) == IslStatus.ACTIVE\n+        }\n+\n+        when: \"Deactivate the src switch\"\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        and: \"Round trip status for forward direction is not available and ACTIVE in reverse direction\"\n+        !database.getIslRoundTripStatus(roundTripIsl)\n+        database.getIslRoundTripStatus(roundTripIsl.reversed) == IslStatus.ACTIVE\n+\n+        when: \"Delete ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.deleteSwitchRules(dstSw.dpId, DeleteRulesAction.REMOVE_ROUND_TRIP_LATENCY)\n+        def isRoundTripRuleDeleted = true\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.size() == 1\n+        }\n+\n+        then: \"The round trip latecny ISL is FAILED\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5OTYzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383799635", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-02-25T10:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNDE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNTAwMQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383325001", "bodyText": "why? Also don't really understand what are you testing here if you will again remove this rule on next step", "author": "rtretyak", "createdAt": "2020-02-24T15:16:48Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All round trip latency ISLs are still DISCOVERED (the system uses round trip latency \\\n+for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        withPool {\n+            roundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+\n+        and: \"All non round trip latency ISLs are FAILED\"\n+        withPool {\n+            nonRoundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.FAILED\n+            }\n+        }\n+\n+        cleanup:\n+        isSwDeactivated && lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when both switches are DEACTIVATED\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSwToDeactivate = roundTripIsl.dstSwitch\n+\n+        when: \"Deactivate the src switch\"\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        when: \"Deactivate the dst switch\"\n+        lockKeeper.knockoutSwitch(dstSwToDeactivate)\n+        def isDstSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip latency ISL is FAILED (because round_trip_status is not available in DB for current ISL \\\n+on both switches)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        cleanup:\n+        isSrcSwDeactivated && lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        isDstSwDeactivated && lockKeeper.reviveSwitch(dstSwToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when the src switch is DEACTIVATED and round trip latency rule is removed \\\n+on the dst switch\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSw = roundTripIsl.dstSwitch\n+\n+        and: \"Round trip status is ACTIVE for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert database.getIslRoundTripStatus(isl) == IslStatus.ACTIVE\n+        }\n+\n+        when: \"Deactivate the src switch\"\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        and: \"Round trip status for forward direction is not available and ACTIVE in reverse direction\"\n+        !database.getIslRoundTripStatus(roundTripIsl)\n+        database.getIslRoundTripStatus(roundTripIsl.reversed) == IslStatus.ACTIVE\n+\n+        when: \"Delete ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.deleteSwitchRules(dstSw.dpId, DeleteRulesAction.REMOVE_ROUND_TRIP_LATENCY)\n+        def isRoundTripRuleDeleted = true\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.size() == 1\n+        }\n+\n+        then: \"The round trip latecny ISL is FAILED\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        and: \"Round trip status is not available for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert !database.getIslRoundTripStatus(isl)\n+        }\n+\n+        when: \"Install ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.installSwitchRules(dstSw.dpId, InstallRulesAction.INSTALL_ROUND_TRIP_LATENCY)\n+        isRoundTripRuleDeleted = false\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.empty\n+        }\n+\n+        then: \"The round trip ISL is still FAILED\"", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5OTcwMw==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383799703", "bodyText": "deleted", "author": "andriidovhan", "createdAt": "2020-02-25T10:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNTAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjMxMA==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383326310", "bodyText": "switch", "author": "rtretyak", "createdAt": "2020-02-24T15:18:53Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All round trip latency ISLs are still DISCOVERED (the system uses round trip latency \\\n+for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        withPool {\n+            roundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+\n+        and: \"All non round trip latency ISLs are FAILED\"\n+        withPool {\n+            nonRoundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.FAILED\n+            }\n+        }\n+\n+        cleanup:\n+        isSwDeactivated && lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when both switches are DEACTIVATED\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSwToDeactivate = roundTripIsl.dstSwitch\n+\n+        when: \"Deactivate the src switch\"\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        when: \"Deactivate the dst switch\"\n+        lockKeeper.knockoutSwitch(dstSwToDeactivate)\n+        def isDstSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip latency ISL is FAILED (because round_trip_status is not available in DB for current ISL \\\n+on both switches)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        cleanup:\n+        isSrcSwDeactivated && lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        isDstSwDeactivated && lockKeeper.reviveSwitch(dstSwToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when the src switch is DEACTIVATED and round trip latency rule is removed \\\n+on the dst switch\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSw = roundTripIsl.dstSwitch\n+\n+        and: \"Round trip status is ACTIVE for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert database.getIslRoundTripStatus(isl) == IslStatus.ACTIVE\n+        }\n+\n+        when: \"Deactivate the src switch\"\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        and: \"Round trip status for forward direction is not available and ACTIVE in reverse direction\"\n+        !database.getIslRoundTripStatus(roundTripIsl)\n+        database.getIslRoundTripStatus(roundTripIsl.reversed) == IslStatus.ACTIVE\n+\n+        when: \"Delete ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.deleteSwitchRules(dstSw.dpId, DeleteRulesAction.REMOVE_ROUND_TRIP_LATENCY)\n+        def isRoundTripRuleDeleted = true\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.size() == 1\n+        }\n+\n+        then: \"The round trip latecny ISL is FAILED\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        and: \"Round trip status is not available for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert !database.getIslRoundTripStatus(isl)\n+        }\n+\n+        when: \"Install ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.installSwitchRules(dstSw.dpId, InstallRulesAction.INSTALL_ROUND_TRIP_LATENCY)\n+        isRoundTripRuleDeleted = false\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.empty\n+        }\n+\n+        then: \"The round trip ISL is still FAILED\"\n+        //ISL will be in the FAILED state until gets any discovery packet\n+        sleep((discoveryInterval + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        when: \"Delete ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch again\"\n+        northbound.deleteSwitchRules(dstSw.dpId, DeleteRulesAction.REMOVE_ROUND_TRIP_LATENCY)\n+        isRoundTripRuleDeleted = true\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.size() == 1\n+        }\n+\n+        and: \"Activate the src switches\"", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNzE0OA==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383327148", "bodyText": "Why do you expect it to be active in both directions if you removed the RTL rule on L194 and never installed it back?", "author": "rtretyak", "createdAt": "2020-02-24T15:20:16Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All round trip latency ISLs are still DISCOVERED (the system uses round trip latency \\\n+for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        withPool {\n+            roundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+\n+        and: \"All non round trip latency ISLs are FAILED\"\n+        withPool {\n+            nonRoundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.FAILED\n+            }\n+        }\n+\n+        cleanup:\n+        isSwDeactivated && lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when both switches are DEACTIVATED\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSwToDeactivate = roundTripIsl.dstSwitch\n+\n+        when: \"Deactivate the src switch\"\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        when: \"Deactivate the dst switch\"\n+        lockKeeper.knockoutSwitch(dstSwToDeactivate)\n+        def isDstSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip latency ISL is FAILED (because round_trip_status is not available in DB for current ISL \\\n+on both switches)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        cleanup:\n+        isSrcSwDeactivated && lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        isDstSwDeactivated && lockKeeper.reviveSwitch(dstSwToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when the src switch is DEACTIVATED and round trip latency rule is removed \\\n+on the dst switch\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSw = roundTripIsl.dstSwitch\n+\n+        and: \"Round trip status is ACTIVE for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert database.getIslRoundTripStatus(isl) == IslStatus.ACTIVE\n+        }\n+\n+        when: \"Deactivate the src switch\"\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        and: \"Round trip status for forward direction is not available and ACTIVE in reverse direction\"\n+        !database.getIslRoundTripStatus(roundTripIsl)\n+        database.getIslRoundTripStatus(roundTripIsl.reversed) == IslStatus.ACTIVE\n+\n+        when: \"Delete ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.deleteSwitchRules(dstSw.dpId, DeleteRulesAction.REMOVE_ROUND_TRIP_LATENCY)\n+        def isRoundTripRuleDeleted = true\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.size() == 1\n+        }\n+\n+        then: \"The round trip latecny ISL is FAILED\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        and: \"Round trip status is not available for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert !database.getIslRoundTripStatus(isl)\n+        }\n+\n+        when: \"Install ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.installSwitchRules(dstSw.dpId, InstallRulesAction.INSTALL_ROUND_TRIP_LATENCY)\n+        isRoundTripRuleDeleted = false\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.empty\n+        }\n+\n+        then: \"The round trip ISL is still FAILED\"\n+        //ISL will be in the FAILED state until gets any discovery packet\n+        sleep((discoveryInterval + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        when: \"Delete ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch again\"\n+        northbound.deleteSwitchRules(dstSw.dpId, DeleteRulesAction.REMOVE_ROUND_TRIP_LATENCY)\n+        isRoundTripRuleDeleted = true\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.size() == 1\n+        }\n+\n+        and: \"Activate the src switches\"\n+        lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        isSrcSwDeactivated = false\n+\n+        then: \"Round trip isl is DISCOVERED again\"\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        and: \"Round trip status is available again for the given ISL in both directions\"", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzMTAzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383331035", "bodyText": "I don't understand the purpose of this test. The situation with 'missing RTL rule' is already like maximum strange. Ok, got 1 strange test for it. But this is a second test which does not test anything new over the  \"A round trip latency ISL goes down when the src switch is DEACTIVATED and round trip latency rule is removed \\ on the dst switch\". So I'm kinda confused by what is being tested here again", "author": "rtretyak", "createdAt": "2020-02-24T15:26:23Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All round trip latency ISLs are still DISCOVERED (the system uses round trip latency \\\n+for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        withPool {\n+            roundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+\n+        and: \"All non round trip latency ISLs are FAILED\"\n+        withPool {\n+            nonRoundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.FAILED\n+            }\n+        }\n+\n+        cleanup:\n+        isSwDeactivated && lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when both switches are DEACTIVATED\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSwToDeactivate = roundTripIsl.dstSwitch\n+\n+        when: \"Deactivate the src switch\"\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        when: \"Deactivate the dst switch\"\n+        lockKeeper.knockoutSwitch(dstSwToDeactivate)\n+        def isDstSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip latency ISL is FAILED (because round_trip_status is not available in DB for current ISL \\\n+on both switches)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        cleanup:\n+        isSrcSwDeactivated && lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        isDstSwDeactivated && lockKeeper.reviveSwitch(dstSwToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when the src switch is DEACTIVATED and round trip latency rule is removed \\\n+on the dst switch\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSw = roundTripIsl.dstSwitch\n+\n+        and: \"Round trip status is ACTIVE for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert database.getIslRoundTripStatus(isl) == IslStatus.ACTIVE\n+        }\n+\n+        when: \"Deactivate the src switch\"\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        and: \"Round trip status for forward direction is not available and ACTIVE in reverse direction\"\n+        !database.getIslRoundTripStatus(roundTripIsl)\n+        database.getIslRoundTripStatus(roundTripIsl.reversed) == IslStatus.ACTIVE\n+\n+        when: \"Delete ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.deleteSwitchRules(dstSw.dpId, DeleteRulesAction.REMOVE_ROUND_TRIP_LATENCY)\n+        def isRoundTripRuleDeleted = true\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.size() == 1\n+        }\n+\n+        then: \"The round trip latecny ISL is FAILED\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        and: \"Round trip status is not available for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert !database.getIslRoundTripStatus(isl)\n+        }\n+\n+        when: \"Install ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.installSwitchRules(dstSw.dpId, InstallRulesAction.INSTALL_ROUND_TRIP_LATENCY)\n+        isRoundTripRuleDeleted = false\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.empty\n+        }\n+\n+        then: \"The round trip ISL is still FAILED\"\n+        //ISL will be in the FAILED state until gets any discovery packet\n+        sleep((discoveryInterval + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        when: \"Delete ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch again\"\n+        northbound.deleteSwitchRules(dstSw.dpId, DeleteRulesAction.REMOVE_ROUND_TRIP_LATENCY)\n+        isRoundTripRuleDeleted = true\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.size() == 1\n+        }\n+\n+        and: \"Activate the src switches\"\n+        lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        isSrcSwDeactivated = false\n+\n+        then: \"Round trip isl is DISCOVERED again\"\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        and: \"Round trip status is available again for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert database.getIslRoundTripStatus(isl) == IslStatus.ACTIVE\n+        }\n+\n+        cleanup:\n+        isSrcSwDeactivated && lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        isRoundTripRuleDeleted && northbound.installSwitchRules(dstSw.dpId, InstallRulesAction.INSTALL_ROUND_TRIP_LATENCY)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.empty\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when the switch supports round trip but rule for this purpose is not installed\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSw = roundTripIsl.dstSwitch\n+\n+        when: \"Delete ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.deleteSwitchRules(dstSw.dpId, DeleteRulesAction.REMOVE_ROUND_TRIP_LATENCY)\n+        def isRoundTripRuleDeleted = true\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.size() == 1\n+        }\n+\n+        and: \"Deactivate the src switch\"\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip latency ISL is FAILED\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        when: \"Install ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.installSwitchRules(dstSw.dpId, InstallRulesAction.INSTALL_ROUND_TRIP_LATENCY)\n+        isRoundTripRuleDeleted = false\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.empty\n+        }\n+\n+        then: \"The round trip latency ISL is still FAILED\"\n+        //ISL will be in the FAILED state until gets any discovery packet\n+        sleep((discoveryInterval + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        cleanup:\n+        isSrcSwDeactivated && lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        isRoundTripRuleDeleted && northbound.installSwitchRules(dstSw.dpId, InstallRulesAction.INSTALL_ROUND_TRIP_LATENCY)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.empty\n+        }\n+    }", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwMjQxMA==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383802410", "bodyText": "you are right, there is no much sense here(\ntest is deleted", "author": "andriidovhan", "createdAt": "2020-02-25T10:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzMTAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzMTc2MQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383331761", "bodyText": "Review all the sleeps. Remove unrequired sleeps, reduce the amount of duplicated time-consuming verifications.", "author": "rtretyak", "createdAt": "2020-02-24T15:27:20Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch is DEACTIVATED\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Deactivate the switch\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"All round trip latency ISLs are still DISCOVERED (the system uses round trip latency \\\n+for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        withPool {\n+            roundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+\n+        and: \"All non round trip latency ISLs are FAILED\"\n+        withPool {\n+            nonRoundTripIsls.eachParallel { link ->\n+                assert northbound.getLink(link).state == IslChangeType.FAILED\n+            }\n+        }\n+\n+        cleanup:\n+        isSwDeactivated && lockKeeper.reviveSwitch(swToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when both switches are DEACTIVATED\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSwToDeactivate = roundTripIsl.dstSwitch\n+\n+        when: \"Deactivate the src switch\"\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        when: \"Deactivate the dst switch\"\n+        lockKeeper.knockoutSwitch(dstSwToDeactivate)\n+        def isDstSwDeactivated = true\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip latency ISL is FAILED (because round_trip_status is not available in DB for current ISL \\\n+on both switches)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        cleanup:\n+        isSrcSwDeactivated && lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        isDstSwDeactivated && lockKeeper.reviveSwitch(dstSwToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getSwitch(dstSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when the src switch is DEACTIVATED and round trip latency rule is removed \\\n+on the dst switch\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSw = roundTripIsl.dstSwitch\n+\n+        and: \"Round trip status is ACTIVE for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert database.getIslRoundTripStatus(isl) == IslStatus.ACTIVE\n+        }\n+\n+        when: \"Deactivate the src switch\"\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip ISL is still DISCOVERED (the system uses round trip latency for ISL alive confirmation)\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        and: \"Round trip status for forward direction is not available and ACTIVE in reverse direction\"\n+        !database.getIslRoundTripStatus(roundTripIsl)\n+        database.getIslRoundTripStatus(roundTripIsl.reversed) == IslStatus.ACTIVE\n+\n+        when: \"Delete ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.deleteSwitchRules(dstSw.dpId, DeleteRulesAction.REMOVE_ROUND_TRIP_LATENCY)\n+        def isRoundTripRuleDeleted = true\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.size() == 1\n+        }\n+\n+        then: \"The round trip latecny ISL is FAILED\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        and: \"Round trip status is not available for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert !database.getIslRoundTripStatus(isl)\n+        }\n+\n+        when: \"Install ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.installSwitchRules(dstSw.dpId, InstallRulesAction.INSTALL_ROUND_TRIP_LATENCY)\n+        isRoundTripRuleDeleted = false\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.empty\n+        }\n+\n+        then: \"The round trip ISL is still FAILED\"\n+        //ISL will be in the FAILED state until gets any discovery packet\n+        sleep((discoveryInterval + WAIT_OFFSET / 2) * 1000 as long)\n+        northbound.getLink(roundTripIsl).state == IslChangeType.FAILED\n+\n+        when: \"Delete ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch again\"\n+        northbound.deleteSwitchRules(dstSw.dpId, DeleteRulesAction.REMOVE_ROUND_TRIP_LATENCY)\n+        isRoundTripRuleDeleted = true\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.size() == 1\n+        }\n+\n+        and: \"Activate the src switches\"\n+        lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        isSrcSwDeactivated = false\n+\n+        then: \"Round trip isl is DISCOVERED again\"\n+        northbound.getLink(roundTripIsl).state == IslChangeType.DISCOVERED\n+\n+        and: \"Round trip status is available again for the given ISL in both directions\"\n+        [roundTripIsl, roundTripIsl.reversed].each { isl ->\n+            assert database.getIslRoundTripStatus(isl) == IslStatus.ACTIVE\n+        }\n+\n+        cleanup:\n+        isSrcSwDeactivated && lockKeeper.reviveSwitch(srcSwToDeactivate)\n+        isRoundTripRuleDeleted && northbound.installSwitchRules(dstSw.dpId, InstallRulesAction.INSTALL_ROUND_TRIP_LATENCY)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.DISCOVERED\n+            }.size() == topology.islsForActiveSwitches.size() * 2\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.empty\n+        }\n+    }\n+\n+    @Tidy\n+    def \"A round trip latency ISL goes down when the switch supports round trip but rule for this purpose is not installed\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl\n+        def srcSwToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsl = topology.getRelatedIsls(sw).find {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsl\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable link\", false)\n+        def dstSw = roundTripIsl.dstSwitch\n+\n+        when: \"Delete ROUND_TRIP_LATENCY_RULE_COOKIE on the dst switch\"\n+        northbound.deleteSwitchRules(dstSw.dpId, DeleteRulesAction.REMOVE_ROUND_TRIP_LATENCY)\n+        def isRoundTripRuleDeleted = true\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert northbound.validateSwitch(dstSw.dpId).rules.missing.size() == 1\n+        }\n+\n+        and: \"Deactivate the src switch\"\n+        lockKeeper.knockoutSwitch(srcSwToDeactivate)\n+        def isSrcSwDeactivated = true\n+        // it takes more time to DEACTIVATE a switch via the 'knockoutSwitch' method on the stage env\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(srcSwToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        then: \"The round trip latency ISL is FAILED\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)", "originalCommit": "3352f59996d79923feb1f2db3a39d8e1aed4d8b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwMTE0OA==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383801148", "bodyText": "fixed everywhere", "author": "andriidovhan", "createdAt": "2020-02-25T10:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzMTc2MQ=="}], "type": "inlineReview"}, {"oid": "4cc37f2557e9e5e6a6acc46679b0f58cc2ead9da", "url": "https://github.com/telstra/open-kilda/commit/4cc37f2557e9e5e6a6acc46679b0f58cc2ead9da", "message": "fix URL for blocking fl via lab-api", "committedDate": "2020-02-25T10:53:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxNTEwOQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383815109", "bodyText": "still don't understand the  + WAIT_OFFSET / 2 thing. why not sleep for discoveryTimeout and then use wait in order to wait for FAILED status.?", "author": "rtretyak", "createdAt": "2020-02-25T11:14:59Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.openkilda.functionaltests.spec.links\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.command.switches.InstallRulesAction\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.model.IslStatus\n+import org.openkilda.model.SwitchFeature\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import spock.lang.See\n+\n+@Tags(HARDWARE)\n+// virtual env doesn't support round trip latency\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/network-discovery\")\n+class RoundTripIslSpec extends HealthCheckSpecification {\n+\n+    /*we need this variable because it takes more time to DEACTIVATE a switch\n+    via the 'knockoutSwitch' method on the stage env*/\n+    Integer customWaitOffset = WAIT_OFFSET * 4\n+\n+    @Tidy\n+    def \"A round trip latency ISL doesn't go down when one switch lose connection to FL\"() {\n+        given: \"A switch with/without round trip latency ISLs\"\n+        def roundTripIsls\n+        def nonRoundTripIsls\n+        def swToDeactivate = topology.activeSwitches.find { sw ->\n+            if (sw.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)) {\n+                roundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                nonRoundTripIsls = topology.getRelatedIsls(sw).findAll {\n+                    !it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+                }\n+                roundTripIsls && nonRoundTripIsls\n+            }\n+        } ?: assumeTrue(\"Wasn't able to find a switch with suitable links\", false)\n+\n+        when: \"Simulate connection lose between the switch and FL, the switch becomes DEACTIVATED and remains operable\"\n+        lockKeeper.knockoutSwitch(swToDeactivate)\n+        def isSwDeactivated = true\n+        Wrappers.wait(customWaitOffset) {\n+            assert northbound.getSwitch(swToDeactivate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and: \"Wait discoveryTimeout\"\n+        sleep((discoveryTimeout + WAIT_OFFSET / 2) * 1000 as long)", "originalCommit": "4cc37f2557e9e5e6a6acc46679b0f58cc2ead9da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgzOTk5NQ==", "url": "https://github.com/telstra/open-kilda/pull/3214#discussion_r383839995", "bodyText": "I thought it would be better to do it in the same line and then do the verifications.\nI am fine with your proposal. This line is refactored", "author": "andriidovhan", "createdAt": "2020-02-25T12:09:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxNTEwOQ=="}], "type": "inlineReview"}, {"oid": "b90a2a6e33cb0007bdbc73bb97d8c6efdfe5fe89", "url": "https://github.com/telstra/open-kilda/commit/b90a2a6e33cb0007bdbc73bb97d8c6efdfe5fe89", "message": "fix URL for blocking fl via lab-api", "committedDate": "2020-02-25T12:09:37Z", "type": "forcePushed"}, {"oid": "56c943444698b8e415ed62c4f8a7d11420431fff", "url": "https://github.com/telstra/open-kilda/commit/56c943444698b8e415ed62c4f8a7d11420431fff", "message": "fix URL for blocking fl via lab-api", "committedDate": "2020-03-02T11:53:12Z", "type": "forcePushed"}, {"oid": "ac38602ca163ac4230452fa3c6471a8e9b72bc25", "url": "https://github.com/telstra/open-kilda/commit/ac38602ca163ac4230452fa3c6471a8e9b72bc25", "message": "ignore test \"Able to delete an active switch with active ISLs if using force delete\"", "committedDate": "2020-03-03T13:17:56Z", "type": "forcePushed"}, {"oid": "91a4ba7a3f847bccc41ff396e78c734557708169", "url": "https://github.com/telstra/open-kilda/commit/91a4ba7a3f847bccc41ff396e78c734557708169", "message": "fix URL for blocking fl via lab-api", "committedDate": "2020-03-03T13:17:56Z", "type": "forcePushed"}, {"oid": "7df369c1fb9f2a14f31c01936bb36d2eabb41bdf", "url": "https://github.com/telstra/open-kilda/commit/7df369c1fb9f2a14f31c01936bb36d2eabb41bdf", "message": "add test for isl alive confirmation via round trip latency", "committedDate": "2020-03-06T07:34:59Z", "type": "commit"}, {"oid": "e123d065427cb3b152a7e9a0f2fa40529f82977e", "url": "https://github.com/telstra/open-kilda/commit/e123d065427cb3b152a7e9a0f2fa40529f82977e", "message": "add missing tags", "committedDate": "2020-03-06T07:34:59Z", "type": "commit"}, {"oid": "f3108425f6918d7e773255d7370839c701d94f5a", "url": "https://github.com/telstra/open-kilda/commit/f3108425f6918d7e773255d7370839c701d94f5a", "message": "fix URL for blocking fl via lab-api", "committedDate": "2020-03-06T07:34:59Z", "type": "commit"}, {"oid": "f3108425f6918d7e773255d7370839c701d94f5a", "url": "https://github.com/telstra/open-kilda/commit/f3108425f6918d7e773255d7370839c701d94f5a", "message": "fix URL for blocking fl via lab-api", "committedDate": "2020-03-06T07:34:59Z", "type": "forcePushed"}]}