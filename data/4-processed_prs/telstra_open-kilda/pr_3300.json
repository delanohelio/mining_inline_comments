{"pr_number": 3300, "pr_title": "improve test according to latest changes in #3295", "pr_createdAt": "2020-03-17T11:31:35Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3300", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0OTY3OA==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r393649678", "bodyText": "1 = 1 + 1\nSomething wrong here", "author": "rozdy", "createdAt": "2020-03-17T12:41:41Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -446,11 +446,16 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n \n         then: \"Flows are not rerouted and flows status are 'Down'\"\n         def flowPathMap = [(firstFlow.flowId): firstFlowMainPath, (secondFlow.flowId): secondFlowPath]\n-        TimeUnit.SECONDS.sleep(rerouteDelay * 2) // it helps to be sure that the auto-reroute operation is completed\n-        Wrappers.wait(WAIT_OFFSET) {\n-            assert northbound.getLink(islToBreak).state == FAILED\n-            // just to be sure that backup ISL is not failed\n-            assert northbound.getLink(islToReroute).state == DISCOVERED\n+        // 'wait' helps to be sure that the auto-reroute operation is completed\n+        Wrappers.wait(WAIT_OFFSET * 2) {\n+            def firstFlowHistory = northbound.getFlowHistory(firstFlow.flowId).findAll { it.action == \"Flow rerouting\" }\n+            assert firstFlowHistory.last().histories.find { it.action == REROUTE_FAIL }\n+            assert firstFlowHistory.size() == 1\n+            def secondFlowHistory = northbound.getFlowHistory(secondFlow.flowId).findAll { it.action == \"Flow rerouting\" }\n+            assert secondFlowHistory.findAll { it.action == \"Flow rerouting\" }.size() == 4\n+            /* 1 = first reroute due to the broken isl + 1 reroute on switch up event;", "originalCommit": "1f231bd227a2c3e7636fc8f907c1bd0baa7eaecb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY1NzcwMg==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r393657702", "bodyText": "thx, fixed", "author": "andriidovhan", "createdAt": "2020-03-17T12:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0OTY3OA=="}], "type": "inlineReview"}, {"oid": "8a0d47fdf7fd80b48942877b061de6513cc25c11", "url": "https://github.com/telstra/open-kilda/commit/8a0d47fdf7fd80b48942877b061de6513cc25c11", "message": "improve test according to #3295", "committedDate": "2020-03-17T12:55:22Z", "type": "forcePushed"}, {"oid": "fcc58b0581b97784575920ab6d91a276e96d0058", "url": "https://github.com/telstra/open-kilda/commit/fcc58b0581b97784575920ab6d91a276e96d0058", "message": "improve test according to #3295", "committedDate": "2020-03-17T17:05:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwOTk5OA==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394209998", "bodyText": "Why do you expect for 'retry #1' to be found more than 1 time?", "author": "rtretyak", "createdAt": "2020-03-18T09:30:57Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,21 +443,39 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n         antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n \n-        then: \"Flows are not rerouted and flows status are 'Down'\"\n+        then: \"Flows are not rerouted and system tries to reroute a flow with transit switch\"\n         def flowPathMap = [(firstFlow.flowId): firstFlowMainPath, (secondFlow.flowId): secondFlowPath]\n-        TimeUnit.SECONDS.sleep(rerouteDelay * 2) // it helps to be sure that the auto-reroute operation is completed\n-        Wrappers.wait(WAIT_OFFSET) {\n-            assert northbound.getLink(islToBreak).state == FAILED\n-            // just to be sure that backup ISL is not failed\n-            assert northbound.getLink(islToReroute).state == DISCOVERED\n+        Wrappers.wait(WAIT_OFFSET * 2) {\n+            def firstFlowHistory = northbound.getFlowHistory(firstFlow.flowId).findAll { it.action == \"Flow rerouting\" }\n+            assert firstFlowHistory.last().histories.find { it.action == REROUTE_FAIL }\n+            assert !firstFlowHistory.find { it.taskId =~ (/[^a-z_A-Z0-9-\\s]* : retry #1 :/) }\n+            def secondFlowHistory = northbound.getFlowHistory(secondFlow.flowId).findAll { it.action == \"Flow rerouting\" }\n+            assert secondFlowHistory.findAll { it.taskId =~ (/[^a-z_A-Z0-9-\\s]* : retry #1 :/) }.size() > 1", "originalCommit": "fcc58b0581b97784575920ab6d91a276e96d0058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ2Mjg2MQ==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394462861", "bodyText": "We have to be sure that all auto-retoute requests are completed.\nOtherwise all requests(for example: retry #2, inactive ISL, switchUp) will be put in the same queue, system pick one of them, and we will not be able to check  that flow is really rerouted after switchUp event.\nrefactored to /[^a-z_A-Z0-9-\\s]* : retry #2 :/", "author": "andriidovhan", "createdAt": "2020-03-18T16:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwOTk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMTA5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394211092", "bodyText": "can we do a more meaningful search here?", "author": "rtretyak", "createdAt": "2020-03-18T09:32:44Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,21 +443,39 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n         antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n \n-        then: \"Flows are not rerouted and flows status are 'Down'\"\n+        then: \"Flows are not rerouted and system tries to reroute a flow with transit switch\"\n         def flowPathMap = [(firstFlow.flowId): firstFlowMainPath, (secondFlow.flowId): secondFlowPath]\n-        TimeUnit.SECONDS.sleep(rerouteDelay * 2) // it helps to be sure that the auto-reroute operation is completed\n-        Wrappers.wait(WAIT_OFFSET) {\n-            assert northbound.getLink(islToBreak).state == FAILED\n-            // just to be sure that backup ISL is not failed\n-            assert northbound.getLink(islToReroute).state == DISCOVERED\n+        Wrappers.wait(WAIT_OFFSET * 2) {\n+            def firstFlowHistory = northbound.getFlowHistory(firstFlow.flowId).findAll { it.action == \"Flow rerouting\" }\n+            assert firstFlowHistory.last().histories.find { it.action == REROUTE_FAIL }\n+            assert !firstFlowHistory.find { it.taskId =~ (/[^a-z_A-Z0-9-\\s]* : retry #1 :/) }\n+            def secondFlowHistory = northbound.getFlowHistory(secondFlow.flowId).findAll { it.action == \"Flow rerouting\" }\n+            assert secondFlowHistory.findAll { it.taskId =~ (/[^a-z_A-Z0-9-\\s]* : retry #1 :/) }.size() > 1\n+            // reroute caused by failed ISL on main and backup paths\n+            assert secondFlowHistory.findAll { !(it.taskId =~ (/[^a-z_A-Z0-9-\\s]* : retry #1 :/)) }.size() > 1", "originalCommit": "fcc58b0581b97784575920ab6d91a276e96d0058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3MDQ2OA==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394470468", "bodyText": "refactored\nassert secondFlowHistory.findAll {\n                it.details =~ /Reason: ISL (.*) become INACTIVE because of FAIL TIMEOUT (.*)/\n            }.size() == 1", "author": "andriidovhan", "createdAt": "2020-03-18T16:15:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMTA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMjMwMA==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394212300", "bodyText": "ok", "author": "rtretyak", "createdAt": "2020-03-18T09:34:45Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,21 +443,39 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n         antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n \n-        then: \"Flows are not rerouted and flows status are 'Down'\"\n+        then: \"Flows are not rerouted and system tries to reroute a flow with transit switch\"\n         def flowPathMap = [(firstFlow.flowId): firstFlowMainPath, (secondFlow.flowId): secondFlowPath]\n-        TimeUnit.SECONDS.sleep(rerouteDelay * 2) // it helps to be sure that the auto-reroute operation is completed\n-        Wrappers.wait(WAIT_OFFSET) {\n-            assert northbound.getLink(islToBreak).state == FAILED\n-            // just to be sure that backup ISL is not failed\n-            assert northbound.getLink(islToReroute).state == DISCOVERED\n+        Wrappers.wait(WAIT_OFFSET * 2) {\n+            def firstFlowHistory = northbound.getFlowHistory(firstFlow.flowId).findAll { it.action == \"Flow rerouting\" }\n+            assert firstFlowHistory.last().histories.find { it.action == REROUTE_FAIL }\n+            assert !firstFlowHistory.find { it.taskId =~ (/[^a-z_A-Z0-9-\\s]* : retry #1 :/) }\n+            def secondFlowHistory = northbound.getFlowHistory(secondFlow.flowId).findAll { it.action == \"Flow rerouting\" }\n+            assert secondFlowHistory.findAll { it.taskId =~ (/[^a-z_A-Z0-9-\\s]* : retry #1 :/) }.size() > 1\n+            // reroute caused by failed ISL on main and backup paths\n+            assert secondFlowHistory.findAll { !(it.taskId =~ (/[^a-z_A-Z0-9-\\s]* : retry #1 :/)) }.size() > 1\n+            /* NOTE: retry is available for a flow when switchUp event appears on a transit switch\n+            We can't check that 3 attempts of reroute are available in flow history, system can't guarantee it.\n+            Reason: during retrying ISL on backup path can fail -> new reroute event(e.g. REROUTE_FAIL_ISL)\n+            will be triggered and put in the queue of reroute -> for instance: in the queue we have 3rd attempt\n+            and REROUTE_FAIL_ISL -> these two reroutes will be merged based on some algorithm ->\n+            system execute one reroute only.\n+            (System doesn't merge reason of reroute, it just pick any reason from queue) */", "originalCommit": "fcc58b0581b97784575920ab6d91a276e96d0058", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNDkwOQ==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394214909", "bodyText": "there is a risk that flows won't find a path during reroute", "author": "rtretyak", "createdAt": "2020-03-18T09:39:14Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -467,31 +484,23 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         }\n         isSwitchActivated = true\n \n-        then: \"Both flows are rerouted\"\n-        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n-            withPool {\n-                [firstFlow.flowId, secondFlow.flowId].eachParallel { String flowId ->\n-                    assert northbound.getFlowStatus(flowId).status == FlowState.UP\n-                    assert PathHelper.convert(northbound.getFlowPath(flowId)) != flowPathMap[flowId]\n-                }\n-            }\n-        }\n-\n-        and: \"Flow is rerouted due to switchUp event\"\n-        //TODO(andriidovhan) specify flow history verification(it is not implemented yet) Reroute reason: switchUp event\n+        then: \"System tries to reroute the flow on switchUp event\"\n+        /* there is a risk that flows wont be rerouted, because switch is online but ISL are not discovered yet,", "originalCommit": "fcc58b0581b97784575920ab6d91a276e96d0058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNTMzMA==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394215330", "bodyText": "ISL -> ISLs", "author": "rtretyak", "createdAt": "2020-03-18T09:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNDkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzODQyMQ==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394438421", "bodyText": "thx, fixed", "author": "andriidovhan", "createdAt": "2020-03-18T15:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNDkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNjI4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394216289", "bodyText": "As for me it makes sense to wait for UP status at least as a separate step/wait here before trying to remove the flow", "author": "rtretyak", "createdAt": "2020-03-18T09:41:37Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -467,31 +484,23 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         }\n         isSwitchActivated = true\n \n-        then: \"Both flows are rerouted\"\n-        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n-            withPool {\n-                [firstFlow.flowId, secondFlow.flowId].eachParallel { String flowId ->\n-                    assert northbound.getFlowStatus(flowId).status == FlowState.UP\n-                    assert PathHelper.convert(northbound.getFlowPath(flowId)) != flowPathMap[flowId]\n-                }\n-            }\n-        }\n-\n-        and: \"Flow is rerouted due to switchUp event\"\n-        //TODO(andriidovhan) specify flow history verification(it is not implemented yet) Reroute reason: switchUp event\n+        then: \"System tries to reroute the flow on switchUp event\"\n+        /* there is a risk that flows wont be rerouted, because switch is online but ISL are not discovered yet,\n+         that's why we check that system tries to reroute flow on the switchUp event and don't check that flow is UP */\n         Wrappers.wait(WAIT_OFFSET / 2) {\n-            assert northbound.getFlowHistory(firstFlow.flowId).findAll { it.action == \"Flow rerouting\" }.size() == 2\n-\n-            assert northbound.getFlowHistory(secondFlow.flowId).findAll { it.action == \"Flow rerouting\" }.size() == 5\n-            /* 2 = first reroute due to the broken isl + 1 reroute on switch up event;\n-             5 = first reroute due to the broken isl + 3 retries + 1 reroute on switch up event;\n-             NOTE: retry is available for a flow when switchUp event appears on a transit switch */\n+            assert northbound.getFlowHistory(firstFlow.flowId).findAll {\n+                it.action == \"Flow rerouting\"\n+            }.last().details == \"Reason: Switch '$switchPair1.src.dpId' online\"\n+            assert northbound.getFlowHistory(secondFlow.flowId).findAll {\n+                it.action == \"Flow rerouting\"\n+            }.last().details == \"Reason: Switch '$switchPair1.src.dpId' online\"\n         }\n ", "originalCommit": "fcc58b0581b97784575920ab6d91a276e96d0058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0Mjk0NQ==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394442945", "bodyText": "it can't be done in current implementation.\nAt the beginning of the test we disabled the flowsRerouteOnIslDiscoveryEnabled feature\nSo, switch is online, ISLs are not discovered. Then as a result flow reroute on switchUp event are going to fail and flow status is DOWN.", "author": "andriidovhan", "createdAt": "2020-03-18T15:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNjI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxODQwNQ==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394218405", "bodyText": "Is this expected? 'retry #' really made sense in the details description, not sure about task id.", "author": "rtretyak", "createdAt": "2020-03-18T09:45:08Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -76,7 +76,7 @@ and at least 1 path must remain safe\"\n         then: \"System fails to install rules on desired path and tries to retry path installation\"\n         Wrappers.wait(rerouteDelay + WAIT_OFFSET, 0.1) {\n             assert northbound.getFlowHistory(flow.flowId).find {\n-                it.action == \"Flow rerouting\" && it.details.matches(/Reason: .*?: retry #1/)\n+                it.action == \"Flow rerouting\" && it.taskId =~ (/[^a-z_A-Z0-9-\\s]* : retry #1 :/)", "originalCommit": "fcc58b0581b97784575920ab6d91a276e96d0058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0MDI4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394440287", "bodyText": "@rozdy Could you assist us?", "author": "andriidovhan", "createdAt": "2020-03-18T15:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxODQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5OTY3MA==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r394899670", "bodyText": "As for me \"retry #\" in task id section is useful to track reroute history in logs. Actually we can duplicate \"retry #\" to reroute request reason.", "author": "rozdy", "createdAt": "2020-03-19T09:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxODQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1NDI5MA==", "url": "https://github.com/telstra/open-kilda/pull/3300#discussion_r395554290", "bodyText": "I don't have a strong opinion here, just checking that this is not a typo", "author": "rtretyak", "createdAt": "2020-03-20T10:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxODQwNQ=="}], "type": "inlineReview"}, {"oid": "72aba99c26efa7dfea229b12d93c5b56959ac420", "url": "https://github.com/telstra/open-kilda/commit/72aba99c26efa7dfea229b12d93c5b56959ac420", "message": "improve test according to #3295", "committedDate": "2020-03-18T15:14:25Z", "type": "forcePushed"}, {"oid": "81c644a2549e2f654795a4b7337510e1c0dc88b7", "url": "https://github.com/telstra/open-kilda/commit/81c644a2549e2f654795a4b7337510e1c0dc88b7", "message": "improve test according to #3295", "committedDate": "2020-03-18T16:42:02Z", "type": "commit"}, {"oid": "81c644a2549e2f654795a4b7337510e1c0dc88b7", "url": "https://github.com/telstra/open-kilda/commit/81c644a2549e2f654795a4b7337510e1c0dc88b7", "message": "improve test according to #3295", "committedDate": "2020-03-18T16:42:02Z", "type": "forcePushed"}]}