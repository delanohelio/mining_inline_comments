{"pr_number": 3576, "pr_title": "Decrease amount of kafka bolts in flrouter", "pr_createdAt": "2020-06-30T09:53:18Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3576", "timeline": [{"oid": "1e84ce1c1ecd74885c85c85c9fee154c31451619", "url": "https://github.com/telstra/open-kilda/commit/1e84ce1c1ecd74885c85c85c9fee154c31451619", "message": "Decrease amount of kafka bolts in flrouter", "committedDate": "2020-07-01T13:37:28Z", "type": "forcePushed"}, {"oid": "e5e1f7db80a4b5ce528655a9b8aea758c6e49262", "url": "https://github.com/telstra/open-kilda/commit/e5e1f7db80a4b5ce528655a9b8aea758c6e49262", "message": "Decrease amount of kafka bolts in flrouter", "committedDate": "2020-07-20T07:29:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNjY3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r457606672", "bodyText": "Flow -> Floodlightrouter", "author": "rozdy", "createdAt": "2020-07-20T18:24:47Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/FloodlightRouterTopology.java", "diffHunk": "@@ -41,500 +48,290 @@\n  * Floodlight topology.\n  */\n public class FloodlightRouterTopology extends AbstractTopology<FloodlightRouterTopologyConfig> {\n+    private final Set<String> regions;\n+\n+    private final KafkaTopicsConfig kafkaTopics;\n     private final PersistenceManager persistenceManager;\n \n-    public FloodlightRouterTopology(LaunchEnvironment env) {\n+    public FloodlightRouterTopology(LaunchEnvironment env) throws ConfigurationException {\n         super(env, FloodlightRouterTopologyConfig.class);\n \n-        persistenceManager = PersistenceProvider.getInstance().createPersistenceManager(configurationProvider);\n-    }\n-\n-    private void createKildaFlowHsSpout(TopologyBuilder builder, int parallelism, List<String> kildaFlowTopics) {\n-        KafkaSpout kildaFlowHsSpout = buildKafkaSpoutForAbstractMessage(kildaFlowTopics,\n-                ComponentType.KILDA_FLOW_HS_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.KILDA_FLOW_HS_KAFKA_SPOUT, kildaFlowHsSpout, parallelism);\n-    }\n+        regions = topologyConfig.getFloodlightRegions().stream()\n+                .filter(entry -> !Strings.isNullOrEmpty(entry))\n+                .collect(Collectors.toSet());\n+        if (regions.isEmpty()) {\n+            throw new ConfigurationException(\"regions list must not be empty\");\n+        }\n \n-    private void createKildaFlowHsKafkaBolt(TopologyBuilder builder, int parallelism, KafkaTopicsConfig topicsConfig) {\n-        KafkaBolt kildaFlowHsKafkaBolt = buildKafkaBoltWithAbstractMessageSupport(topicsConfig.getFlowHsSpeakerTopic());\n-        builder.setBolt(ComponentType.KILDA_FLOW_HS_KAFKA_BOLT, kildaFlowHsKafkaBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_FLOW_HS_REPLY_BOLT, Stream.KILDA_HS_FLOW);\n+        kafkaTopics = topologyConfig.getKafkaTopics();\n+        persistenceManager = PersistenceProvider.getInstance().createPersistenceManager(configurationProvider);\n     }\n \n-    private void createKildaFlowHsReplyStream(TopologyBuilder builder, int spoutParallelism, int parallelism,\n-                                              KafkaTopicsConfig topicsConfig, List<String> kildaFlowHsTopics) {\n-        createKildaFlowHsSpout(builder, spoutParallelism, kildaFlowHsTopics);\n-        createKildaFlowHsKafkaBolt(builder, parallelism, topicsConfig);\n+    @Override\n+    public StormTopology createTopology() {\n+        logger.info(\"Creating FlowTopology - {}\", topologyName);", "originalCommit": "e5e1f7db80a4b5ce528655a9b8aea758c6e49262", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MDM1NQ==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r457860355", "bodyText": "+1", "author": "niksv", "createdAt": "2020-07-21T06:15:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNjY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI2OTQyOQ==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r458269429", "bodyText": "Weird log message in a weird place - it works during topology uploading.\nPS It is \"FlowTopology\" in our main branch now. :)", "author": "surabujin", "createdAt": "2020-07-21T17:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNjY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYxMjkzMw==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r457612933", "bodyText": "String format and string concat in one line looks wierd. Maybe add details into format as third argument?", "author": "rozdy", "createdAt": "2020-07-20T18:35:58Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/RegionAwareKafkaTopicSelector.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.floodlightrouter;\n+\n+import joptsimple.internal.Strings;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.storm.kafka.bolt.selector.KafkaTopicSelector;\n+import org.apache.storm.tuple.Tuple;\n+\n+@Slf4j\n+public class RegionAwareKafkaTopicSelector implements KafkaTopicSelector {\n+    public static final String FIELD_ID_TOPIC = \"topic\";\n+    public static final String FIELD_ID_REGION = \"region\";\n+\n+    @Override\n+    public String getTopic(Tuple tuple) {\n+        String topic;\n+        String region;\n+        try {\n+            topic = tuple.getStringByField(FIELD_ID_TOPIC);\n+            region = tuple.getStringByField(FIELD_ID_REGION);\n+        } catch (IndexOutOfBoundsException | ClassCastException e) {\n+            reportError(tuple, \"Can't extract topic and/or region names: %s\", e);\n+            return null;\n+        }\n+\n+        if (topic == null) {\n+            reportError(tuple, \"target topic is null\");\n+            return null;\n+        }\n+\n+        return formatTopicName(topic, region);\n+    }\n+\n+    private String formatTopicName(String topic, String region) {\n+        if (Strings.isNullOrEmpty(region)) {\n+            return topic;\n+        }\n+        return String.format(\"%s_%s\", topic, region);\n+    }\n+\n+    private void reportError(Tuple tuple, String details, Object... arguments) {\n+        String source = tuple.getSourceComponent();\n+        String stream = tuple.getSourceStreamId();\n+        String message = String.format(\"Invalid %s(%s) tuple - \", source, stream) + details;", "originalCommit": "e5e1f7db80a4b5ce528655a9b8aea758c6e49262", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3ODEyMA==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r458278120", "bodyText": "em... yes why not (can't remember why it is done in this way).", "author": "surabujin", "createdAt": "2020-07-21T17:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYxMjkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYxMzMxNA==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r457613314", "bodyText": "Either remove or add description please.", "author": "rozdy", "createdAt": "2020-07-20T18:36:37Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/Stream.java", "diffHunk": "@@ -17,6 +17,7 @@\n \n public final class Stream {\n \n+    // TODO: del?", "originalCommit": "e5e1f7db80a4b5ce528655a9b8aea758c6e49262", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4NzQ1MA==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r458287450", "bodyText": "Removed", "author": "surabujin", "createdAt": "2020-07-21T18:00:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYxMzMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYxNTg5MQ==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r457615891", "bodyText": "It would be nice to rename handleDirectRequest to handleUnicastRequest for consistency with BroadcastRequest.", "author": "rozdy", "createdAt": "2020-07-20T18:41:24Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/bolts/ControllerToSpeakerProxyBolt.java", "diffHunk": "@@ -37,42 +38,60 @@\n import java.util.Set;\n \n @Slf4j\n-public class RequestBolt extends AbstractBolt {\n-    protected final String outputMessageStream;\n-    protected final Set<String> regions;\n+public class ControllerToSpeakerProxyBolt extends AbstractBolt {\n+    private final String targetTopic;\n \n     protected transient SwitchTracker switchTracker;\n+    protected final Set<String> allRegions;\n \n-    public RequestBolt(String outputMessageStream, Set<String> regions) {\n-        this.outputMessageStream = outputMessageStream;\n-        this.regions = regions;\n+    public ControllerToSpeakerProxyBolt(String targetTopic, Set<String> allRegions) {\n+        this.targetTopic = targetTopic;\n+        this.allRegions = ImmutableSet.copyOf(allRegions);\n     }\n \n     @Override\n-    public void handleInput(Tuple input) throws Exception {\n-        if (Stream.REGION_NOTIFICATION.equals(input.getSourceStreamId())) {\n+    protected void dispatch(Tuple input) throws Exception {\n+        if (RegionTrackerBolt.STREAM_REGION_UPDATE_ID.equals(input.getSourceStreamId())) {\n             handleSwitchMappingUpdate(pullValue(input, AbstractTopology.MESSAGE_FIELD, SwitchMapping.class));\n         } else {\n-            handleControllerRequest(input);\n+            super.dispatch(input);\n         }\n     }\n \n+    @Override\n+    public void handleInput(Tuple input) throws Exception {\n+        handleControllerRequest(pullControllerPayload(input));\n+    }\n+\n     private void handleSwitchMappingUpdate(SwitchMapping mapping) {\n-        updateSwitchMapping(mapping);\n+        switchTracker.updateRegion(mapping);\n+    }\n+\n+    private void handleControllerRequest(Object payload) throws PipelineException {\n+        if (payload instanceof Message && RouterUtils.isBroadcast((Message) payload)) {\n+            handleBroadcastRequest((Message) payload);\n+        } else {\n+            handleDirectRequest(payload);", "originalCommit": "e5e1f7db80a4b5ce528655a9b8aea758c6e49262", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4NzkzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r458287935", "bodyText": "done", "author": "surabujin", "createdAt": "2020-07-21T18:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYxNTg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYxOTQwOA==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r457619408", "bodyText": "2020", "author": "rozdy", "createdAt": "2020-07-20T18:47:42Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/bolts/SpeakerToNetworkProxyBolt.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/* Copyright 2019 Telstra Open Source", "originalCommit": "e5e1f7db80a4b5ce528655a9b8aea758c6e49262", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5MDQzNA==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r458290434", "bodyText": "Hm... local git show it as rename\n .../main/java/org/openkilda/wfm/topology/floodlightrouter/bolts/{RequestBolt.java => ControllerToSpeakerProxyBolt.java}\n\nchanged to 2020.", "author": "surabujin", "createdAt": "2020-07-21T18:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYxOTQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYyNDEzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r457624135", "bodyText": "Is this working ok when you call reportError method without third argument?", "author": "rozdy", "createdAt": "2020-07-20T18:56:14Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/RegionAwareKafkaTopicSelector.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.floodlightrouter;\n+\n+import joptsimple.internal.Strings;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.storm.kafka.bolt.selector.KafkaTopicSelector;\n+import org.apache.storm.tuple.Tuple;\n+\n+@Slf4j\n+public class RegionAwareKafkaTopicSelector implements KafkaTopicSelector {\n+    public static final String FIELD_ID_TOPIC = \"topic\";\n+    public static final String FIELD_ID_REGION = \"region\";\n+\n+    @Override\n+    public String getTopic(Tuple tuple) {\n+        String topic;\n+        String region;\n+        try {\n+            topic = tuple.getStringByField(FIELD_ID_TOPIC);\n+            region = tuple.getStringByField(FIELD_ID_REGION);\n+        } catch (IndexOutOfBoundsException | ClassCastException e) {\n+            reportError(tuple, \"Can't extract topic and/or region names: %s\", e);\n+            return null;\n+        }\n+\n+        if (topic == null) {\n+            reportError(tuple, \"target topic is null\");\n+            return null;\n+        }\n+\n+        return formatTopicName(topic, region);\n+    }\n+\n+    private String formatTopicName(String topic, String region) {\n+        if (Strings.isNullOrEmpty(region)) {\n+            return topic;\n+        }\n+        return String.format(\"%s_%s\", topic, region);\n+    }\n+\n+    private void reportError(Tuple tuple, String details, Object... arguments) {\n+        String source = tuple.getSourceComponent();\n+        String stream = tuple.getSourceStreamId();\n+        String message = String.format(\"Invalid %s(%s) tuple - \", source, stream) + details;\n+        log.error(message, arguments);", "originalCommit": "e5e1f7db80a4b5ce528655a9b8aea758c6e49262", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4ODIwOA==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r458288208", "bodyText": "yes", "author": "surabujin", "createdAt": "2020-07-21T18:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYyNDEzNQ=="}], "type": "inlineReview"}, {"oid": "8a65132e396f77fe5212f0c303d6d821b4a4e398", "url": "https://github.com/telstra/open-kilda/commit/8a65132e396f77fe5212f0c303d6d821b4a4e398", "message": "Decrease amount of kafka bolts in flrouter", "committedDate": "2020-07-22T08:14:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU2NTY2Mg==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r458565662", "bodyText": "can't see any place where this static class is useful, since each declarer methods uses either generic or hs output, not boths. Makes code less readable imho.", "author": "timofei-durakov", "createdAt": "2020-07-22T06:35:01Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/FloodlightRouterTopology.java", "diffHunk": "@@ -41,500 +48,290 @@\n  * Floodlight topology.\n  */\n public class FloodlightRouterTopology extends AbstractTopology<FloodlightRouterTopologyConfig> {\n+    private final Set<String> regions;\n+\n+    private final KafkaTopicsConfig kafkaTopics;\n     private final PersistenceManager persistenceManager;\n \n-    public FloodlightRouterTopology(LaunchEnvironment env) {\n+    public FloodlightRouterTopology(LaunchEnvironment env) throws ConfigurationException {\n         super(env, FloodlightRouterTopologyConfig.class);\n \n-        persistenceManager = PersistenceProvider.getInstance().createPersistenceManager(configurationProvider);\n-    }\n-\n-    private void createKildaFlowHsSpout(TopologyBuilder builder, int parallelism, List<String> kildaFlowTopics) {\n-        KafkaSpout kildaFlowHsSpout = buildKafkaSpoutForAbstractMessage(kildaFlowTopics,\n-                ComponentType.KILDA_FLOW_HS_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.KILDA_FLOW_HS_KAFKA_SPOUT, kildaFlowHsSpout, parallelism);\n-    }\n+        regions = topologyConfig.getFloodlightRegions().stream()\n+                .filter(entry -> !Strings.isNullOrEmpty(entry))\n+                .collect(Collectors.toSet());\n+        if (regions.isEmpty()) {\n+            throw new ConfigurationException(\"regions list must not be empty\");\n+        }\n \n-    private void createKildaFlowHsKafkaBolt(TopologyBuilder builder, int parallelism, KafkaTopicsConfig topicsConfig) {\n-        KafkaBolt kildaFlowHsKafkaBolt = buildKafkaBoltWithAbstractMessageSupport(topicsConfig.getFlowHsSpeakerTopic());\n-        builder.setBolt(ComponentType.KILDA_FLOW_HS_KAFKA_BOLT, kildaFlowHsKafkaBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_FLOW_HS_REPLY_BOLT, Stream.KILDA_HS_FLOW);\n+        kafkaTopics = topologyConfig.getKafkaTopics();\n+        persistenceManager = PersistenceProvider.getInstance().createPersistenceManager(configurationProvider);\n     }\n \n-    private void createKildaFlowHsReplyStream(TopologyBuilder builder, int spoutParallelism, int parallelism,\n-                                              KafkaTopicsConfig topicsConfig, List<String> kildaFlowHsTopics) {\n-        createKildaFlowHsSpout(builder, spoutParallelism, kildaFlowHsTopics);\n-        createKildaFlowHsKafkaBolt(builder, parallelism, topicsConfig);\n+    @Override\n+    public StormTopology createTopology() {\n+        logger.info(\"Creating FlowTopology - {}\", topologyName);\n \n-        ReplyBolt replyBolt = new ReplyBolt(Stream.KILDA_HS_FLOW);\n-        builder.setBolt(ComponentType.KILDA_FLOW_HS_REPLY_BOLT, replyBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_FLOW_HS_KAFKA_SPOUT);\n+        TopologyBuilder builder = new TopologyBuilder();\n+        int newParallelism = topologyConfig.getNewParallelism();\n+        int parallelism = topologyConfig.getParallelism();\n \n-    }\n+        TopologyOutput output = kafkaOutput(builder, newParallelism);\n \n-    private void createKildaPingSpout(TopologyBuilder builder, int parallelism, List<String> kildaPingTopics) {\n-        KafkaSpout kildaPingSpout = buildKafkaSpout(kildaPingTopics,\n-                ComponentType.KILDA_PING_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.KILDA_PING_KAFKA_SPOUT, kildaPingSpout, parallelism);\n-    }\n+        speakerToNetwork(builder, parallelism, newParallelism, output);\n+        networkToSpeaker(builder, parallelism, newParallelism, output);\n \n-    private void createKildaPingKafkaBolt(TopologyBuilder builder, int parallelism, KafkaTopicsConfig topicsConfig) {\n-        KafkaBolt kildaPingKafkaBolt = buildKafkaBolt(topicsConfig.getPingTopic());\n-        builder.setBolt(ComponentType.KILDA_PING_KAFKA_BOLT, kildaPingKafkaBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_PING_REPLY_BOLT, Stream.KILDA_PING);\n-    }\n+        speakerToFlowHs(builder, parallelism, newParallelism, output);\n+        flowHsToSpeaker(builder, parallelism, newParallelism, output);\n \n+        speakerToPing(builder, parallelism, newParallelism, output);\n+        pingToSpeaker(builder, parallelism, newParallelism, output);\n \n-    private void createKildaPingReplyStream(TopologyBuilder builder, int spoutParallelism, int parallelism,\n-                                            KafkaTopicsConfig topicsConfig,\n-                                            List<String> kildaPingTopics) {\n-        createKildaPingSpout(builder, spoutParallelism, kildaPingTopics);\n-        createKildaPingKafkaBolt(builder, parallelism, topicsConfig);\n+        speakerToStats(builder, parallelism, newParallelism, output);\n+        speakerToIslLatency(builder, parallelism, newParallelism, output);\n+        speakerToConnectedDevices(builder, parallelism, newParallelism, output);\n+        speakerToSwitchManager(builder, parallelism, newParallelism, output);\n+        speakerToNorthbound(builder, parallelism, newParallelism, output);\n+        speakerToNbWorker(builder, parallelism, newParallelism, output);\n \n-        ReplyBolt replyBolt = new ReplyBolt(Stream.KILDA_PING);\n-        builder.setBolt(ComponentType.KILDA_PING_REPLY_BOLT, replyBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_PING_KAFKA_SPOUT);\n+        speakerToFlStats(builder, parallelism, newParallelism, output);\n+        flStatsToSpeaker(builder, parallelism, newParallelism, output);\n \n-    }\n+        controllerToSpeaker(builder, parallelism, newParallelism, output);\n \n-    private void createKildaStatsSpout(TopologyBuilder builder, int parallelism, List<String> kildaStatsTopics) {\n-        KafkaSpout kildaStatsSpout = buildKafkaSpout(kildaStatsTopics,\n-                ComponentType.KILDA_STATS_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.KILDA_STATS_KAFKA_SPOUT, kildaStatsSpout, parallelism);\n-    }\n+        regionTracker(builder, output);\n \n-    private void createKildaStatsKafkaBolt(TopologyBuilder builder, int parallelism, KafkaTopicsConfig topicsConfig) {\n-        KafkaBolt kildaStatsKafkaBolt = buildKafkaBolt(topicsConfig.getStatsTopic());\n-        builder.setBolt(ComponentType.KILDA_STATS_KAFKA_BOLT, kildaStatsKafkaBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_STATS_REPLY_BOLT, Stream.KILDA_STATS);\n+        return builder.createTopology();\n     }\n \n+    private void speakerToNetwork(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        KafkaSpout<String, Message> spout = buildKafkaSpout(\n+                makeRegionTopics(kafkaTopics.getTopoDiscoRegionTopic()), ComponentType.KILDA_TOPO_DISCO_KAFKA_SPOUT);\n+        topology.setSpout(ComponentType.KILDA_TOPO_DISCO_KAFKA_SPOUT, spout, spoutParallelism);\n \n-    private void createKildaStatsReplyStream(TopologyBuilder builder, int spoutParallelism, int parallelism,\n-                                             KafkaTopicsConfig topicsConfig,\n-                                            List<String> kildaStatsTopics) {\n-        createKildaStatsSpout(builder, spoutParallelism, kildaStatsTopics);\n-        createKildaStatsKafkaBolt(builder, parallelism, topicsConfig);\n-\n-        ReplyBolt replyBolt = new ReplyBolt(Stream.KILDA_STATS);\n-        builder.setBolt(ComponentType.KILDA_STATS_REPLY_BOLT, replyBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_STATS_KAFKA_SPOUT);\n-\n-    }\n+        SpeakerToNetworkProxyBolt proxy = new SpeakerToNetworkProxyBolt(kafkaTopics.getTopoDiscoTopic());\n+        topology.setBolt(ComponentType.KILDA_TOPO_DISCO_REPLY_BOLT, proxy, parallelism)\n+                .shuffleGrouping(ComponentType.KILDA_TOPO_DISCO_KAFKA_SPOUT);\n \n-    private void createKildaIslLatencySpout(TopologyBuilder builder, int parallelism, List<String> kildaStatsTopics) {\n-        KafkaSpout kildaStatsSpout = buildKafkaSpout(kildaStatsTopics,\n-                ComponentType.KILDA_ISL_LATENCY_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.KILDA_ISL_LATENCY_KAFKA_SPOUT, kildaStatsSpout, parallelism);\n+        output.getKafkaGenericOutput()\n+                .shuffleGrouping(ComponentType.KILDA_TOPO_DISCO_REPLY_BOLT);\n     }\n \n-    private void createKildaIslLatencyKafkaBolt(TopologyBuilder builder, int parallelism,\n-                                                KafkaTopicsConfig topicsConfig) {\n-        KafkaBolt kildaStatsKafkaBolt = buildKafkaBolt(topicsConfig.getTopoIslLatencyTopic());\n-        builder.setBolt(ComponentType.KILDA_ISL_LATENCY_KAFKA_BOLT, kildaStatsKafkaBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_ISL_LATENCY_REPLY_BOLT, Stream.KILDA_ISL_LATENCY);\n+    private void networkToSpeaker(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        declareControllerToSpeakerProxy(\n+                topology, kafkaTopics.getSpeakerDiscoRegionTopic(), kafkaTopics.getSpeakerDiscoTopic(),\n+                ComponentType.SPEAKER_DISCO_KAFKA_SPOUT, ComponentType.SPEAKER_DISCO_REQUEST_BOLT,\n+                output.getKafkaGenericOutput(), spoutParallelism, parallelism);\n     }\n \n-    private void createKildaIslLatencyReplyStream(TopologyBuilder builder, int spoutParallelism, int parallelism,\n-                                                  KafkaTopicsConfig topicsConfig, List<String> kildaIslLatencyTopics) {\n-        createKildaIslLatencySpout(builder, spoutParallelism, kildaIslLatencyTopics);\n-        createKildaIslLatencyKafkaBolt(builder, parallelism, topicsConfig);\n+    private void speakerToFlowHs(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        KafkaSpout<String, AbstractMessage> spout = buildKafkaSpoutForAbstractMessage(\n+                makeRegionTopics(kafkaTopics.getFlowHsSpeakerRegionTopic()), ComponentType.KILDA_FLOW_HS_KAFKA_SPOUT);\n+        topology.setSpout(ComponentType.KILDA_FLOW_HS_KAFKA_SPOUT, spout, spoutParallelism);\n \n-        ReplyBolt replyBolt = new ReplyBolt(Stream.KILDA_ISL_LATENCY);\n-        builder.setBolt(ComponentType.KILDA_ISL_LATENCY_REPLY_BOLT, replyBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_ISL_LATENCY_KAFKA_SPOUT);\n+        declareSpeakerToControllerProxy(\n+                topology, kafkaTopics.getFlowHsSpeakerTopic(),\n+                ComponentType.KILDA_FLOW_HS_KAFKA_SPOUT, ComponentType.KILDA_FLOW_HS_REPLY_BOLT,\n+                output.getKafkaHsOutput(), parallelism);\n     }\n \n-    private void createKildaConnectedDevicesSpout(TopologyBuilder builder, int parallelism, List<String> topics) {\n-        KafkaSpout spout = buildKafkaSpout(topics, ComponentType.KILDA_CONNECTED_DEVICES_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.KILDA_CONNECTED_DEVICES_KAFKA_SPOUT, spout, parallelism);\n-    }\n+    private void flowHsToSpeaker(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        KafkaSpout<String, AbstractMessage> spout = buildKafkaSpoutForAbstractMessage(\n+                kafkaTopics.getSpeakerFlowHsTopic(), ComponentType.SPEAKER_FLOW_HS_KAFKA_SPOUT);\n+        topology.setSpout(ComponentType.SPEAKER_FLOW_HS_KAFKA_SPOUT, spout, spoutParallelism);\n \n-    private void createKildaConnectedDevicesKafkaBolt(TopologyBuilder builder, int parallelism,\n-                                                      KafkaTopicsConfig topicsConfig) {\n-        KafkaBolt kafkaBolt = buildKafkaBolt(topicsConfig.getTopoConnectedDevicesTopic());\n-        builder.setBolt(ComponentType.KILDA_CONNECTED_DEVICES_KAFKA_BOLT, kafkaBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_CONNECTED_DEVICES_REPLY_BOLT, Stream.KILDA_CONNECTED_DEVICES);\n+        declareControllerToSpeakerProxy(\n+                topology, kafkaTopics.getSpeakerFlowRegionTopic(),\n+                ComponentType.SPEAKER_FLOW_HS_KAFKA_SPOUT, ComponentType.SPEAKER_FLOW_REQUEST_BOLT,\n+                output.getKafkaHsOutput(), parallelism);\n     }\n \n-    private void createKildaConnectedDevicesReplyStream(TopologyBuilder builder, int spoutParallelism, int parallelism,\n-                                                        KafkaTopicsConfig topicsConfig, List<String> topics) {\n-        createKildaConnectedDevicesSpout(builder, spoutParallelism, topics);\n-        createKildaConnectedDevicesKafkaBolt(builder, parallelism, topicsConfig);\n-\n-        ReplyBolt replyBolt = new ReplyBolt(Stream.KILDA_CONNECTED_DEVICES);\n-        builder.setBolt(ComponentType.KILDA_CONNECTED_DEVICES_REPLY_BOLT, replyBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_CONNECTED_DEVICES_KAFKA_SPOUT);\n+    private void speakerToPing(TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        declareSpeakerToControllerProxy(\n+                topology, kafkaTopics.getPingRegionTopic(), kafkaTopics.getPingTopic(),\n+                ComponentType.KILDA_PING_KAFKA_SPOUT, ComponentType.KILDA_PING_REPLY_BOLT,\n+                output.getKafkaGenericOutput(), spoutParallelism, parallelism);\n     }\n \n-    private void createKildaSwitchManagerSpout(TopologyBuilder builder, int parallelism,\n-                                               List<String> kildaSwitchManagerTopics) {\n-        KafkaSpout kildaSwitchManagerSpout = buildKafkaSpout(kildaSwitchManagerTopics,\n-                ComponentType.KILDA_SWITCH_MANAGER_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.KILDA_SWITCH_MANAGER_KAFKA_SPOUT, kildaSwitchManagerSpout, parallelism);\n+    private void pingToSpeaker(TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        declareControllerToSpeakerProxy(\n+                topology, kafkaTopics.getSpeakerFlowPingRegionTopic(), kafkaTopics.getSpeakerFlowPingTopic(),\n+                ComponentType.SPEAKER_PING_KAFKA_SPOUT, Stream.SPEAKER_PING, output.getKafkaGenericOutput(),\n+                spoutParallelism, parallelism);\n     }\n \n-    private void createKildaSwitchManagerKafkaBolt(TopologyBuilder builder, int parallelism,\n-                                                   KafkaTopicsConfig topicsConfig) {\n-        KafkaBolt kildaSwitchManagerKafkaBolt = buildKafkaBolt(topicsConfig.getTopoSwitchManagerTopic());\n-        builder.setBolt(ComponentType.KILDA_SWITCH_MANAGER_KAFKA_BOLT, kildaSwitchManagerKafkaBolt, parallelism)\n-                .shuffleGrouping(ComponentType.SPEAKER_REQUEST_BOLT, Stream.KILDA_SWITCH_MANAGER)\n-                .shuffleGrouping(ComponentType.KILDA_SWITCH_MANAGER_REPLY_BOLT, Stream.KILDA_SWITCH_MANAGER);\n+    private void speakerToStats(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        declareSpeakerToControllerProxy(\n+                topology, kafkaTopics.getStatsRegionTopic(), kafkaTopics.getStatsTopic(),\n+                ComponentType.KILDA_STATS_KAFKA_SPOUT, ComponentType.KILDA_STATS_REPLY_BOLT,\n+                output.getKafkaGenericOutput(), spoutParallelism, parallelism);\n     }\n \n-\n-    private void createKildaSwitchManagerReplyStream(TopologyBuilder builder, int spoutParallelism, int parallelism,\n-                                                     KafkaTopicsConfig topicsConfig,\n-                                                     List<String> kildaSwitchManagerTopics) {\n-        createKildaSwitchManagerSpout(builder, spoutParallelism, kildaSwitchManagerTopics);\n-        createKildaSwitchManagerKafkaBolt(builder, parallelism, topicsConfig);\n-\n-        ReplyBolt replyBolt = new ReplyBolt(Stream.KILDA_SWITCH_MANAGER);\n-        builder.setBolt(ComponentType.KILDA_SWITCH_MANAGER_REPLY_BOLT, replyBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_SWITCH_MANAGER_KAFKA_SPOUT);\n+    private void speakerToIslLatency(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        declareSpeakerToControllerProxy(\n+                topology, kafkaTopics.getTopoIslLatencyRegionTopic(), kafkaTopics.getTopoIslLatencyTopic(),\n+                ComponentType.KILDA_ISL_LATENCY_KAFKA_SPOUT, ComponentType.KILDA_ISL_LATENCY_REPLY_BOLT,\n+                output.getKafkaGenericOutput(), spoutParallelism, parallelism);\n     }\n \n-    private void createKildaNorthboundSpout(TopologyBuilder builder, int parallelism,\n-                                               List<String> kildaNorthboundTopics) {\n-        KafkaSpout kildaNorthboundSpout = buildKafkaSpout(kildaNorthboundTopics,\n-                ComponentType.NORTHBOUND_REPLY_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.NORTHBOUND_REPLY_KAFKA_SPOUT, kildaNorthboundSpout, parallelism);\n+    private void speakerToConnectedDevices(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        declareSpeakerToControllerProxy(\n+                topology, kafkaTopics.getTopoConnectedDevicesRegionTopic(), kafkaTopics.getTopoConnectedDevicesTopic(),\n+                ComponentType.KILDA_CONNECTED_DEVICES_KAFKA_SPOUT, ComponentType.KILDA_CONNECTED_DEVICES_REPLY_BOLT,\n+                output.getKafkaGenericOutput(), spoutParallelism, parallelism);\n     }\n \n-    private void createKildaNorthboundKafkaBolt(TopologyBuilder builder, int parallelism,\n-                                                   KafkaTopicsConfig topicsConfig) {\n-        KafkaBolt kildaNorthboundKafkaBolt = buildKafkaBolt(topicsConfig.getNorthboundTopic());\n-        builder.setBolt(ComponentType.NORTHBOUND_REPLY_KAFKA_BOLT, kildaNorthboundKafkaBolt, parallelism)\n-                .shuffleGrouping(ComponentType.SPEAKER_REQUEST_BOLT, Stream.NORTHBOUND_REPLY)\n-                .shuffleGrouping(ComponentType.NORTHBOUND_REPLY_BOLT, Stream.NORTHBOUND_REPLY);\n+    private void speakerToSwitchManager(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        declareSpeakerToControllerProxy(\n+                topology, kafkaTopics.getTopoSwitchManagerRegionTopic(), kafkaTopics.getTopoSwitchManagerTopic(),\n+                ComponentType.KILDA_SWITCH_MANAGER_KAFKA_SPOUT, ComponentType.KILDA_SWITCH_MANAGER_REPLY_BOLT,\n+                output.getKafkaGenericOutput(), spoutParallelism, parallelism);\n     }\n \n-\n-    private void createKildaNorthboundReplyStream(TopologyBuilder builder, int spoutParallelism, int parallelism,\n-                                                     KafkaTopicsConfig topicsConfig,\n-                                                     List<String> kildaNorthboundTopics) {\n-        createKildaNorthboundSpout(builder, spoutParallelism, kildaNorthboundTopics);\n-        createKildaNorthboundKafkaBolt(builder, parallelism, topicsConfig);\n-\n-        ReplyBolt replyBolt = new ReplyBolt(Stream.NORTHBOUND_REPLY);\n-        builder.setBolt(ComponentType.NORTHBOUND_REPLY_BOLT, replyBolt, parallelism)\n-                .shuffleGrouping(ComponentType.NORTHBOUND_REPLY_KAFKA_SPOUT);\n+    private void speakerToNorthbound(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        declareSpeakerToControllerProxy(\n+                topology, kafkaTopics.getNorthboundRegionTopic(), kafkaTopics.getNorthboundTopic(),\n+                ComponentType.NORTHBOUND_REPLY_KAFKA_SPOUT, ComponentType.NORTHBOUND_REPLY_BOLT,\n+                output.getKafkaGenericOutput(), spoutParallelism, parallelism);\n     }\n \n-    private void createKildaNbWorkerSpout(TopologyBuilder builder, int parallelism,\n-                                            List<String> kildaNbWorkerTopics) {\n-        KafkaSpout kildaNbWorkerSpout = buildKafkaSpout(kildaNbWorkerTopics,\n-                ComponentType.KILDA_NB_WORKER_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.KILDA_NB_WORKER_KAFKA_SPOUT, kildaNbWorkerSpout, parallelism);\n+    private void speakerToNbWorker(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        declareSpeakerToControllerProxy(\n+                topology, kafkaTopics.getTopoNbRegionTopic(), kafkaTopics.getTopoNbTopic(),\n+                ComponentType.KILDA_NB_WORKER_KAFKA_SPOUT, ComponentType.KILDA_NB_WORKER_REPLY_BOLT,\n+                output.getKafkaGenericOutput(), spoutParallelism, parallelism);\n     }\n \n-    private void createKildaNbWorkerKafkaBolt(TopologyBuilder builder, int parallelism,\n-                                                KafkaTopicsConfig topicsConfig) {\n-        KafkaBolt kildaNbWorkerKafkaBolt = buildKafkaBolt(topicsConfig.getTopoNbTopic());\n-        builder.setBolt(ComponentType.KILDA_NB_WORKER_KAFKA_BOLT, kildaNbWorkerKafkaBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_NB_WORKER_REPLY_BOLT, Stream.NB_WORKER);\n+    private void speakerToFlStats(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        declareSpeakerToControllerProxy(\n+                topology, kafkaTopics.getFlStatsSwitchesPrivRegionTopic(), kafkaTopics.getFlStatsSwitchesPrivTopic(),\n+                ComponentType.FL_STATS_SWITCHES_SPOUT, ComponentType.FL_STATS_SWITCHES_REPLY_BOLT,\n+                output.getKafkaGenericOutput(), spoutParallelism, parallelism);\n     }\n \n+    private void flStatsToSpeaker(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        KafkaSpout<String, Message> spout = buildKafkaSpout(\n+                kafkaTopics.getStatsStatsRequestPrivTopic(), ComponentType.STATS_STATS_REQUEST_KAFKA_SPOUT);\n+        topology.setSpout(ComponentType.STATS_STATS_REQUEST_KAFKA_SPOUT, spout, spoutParallelism);\n \n-    private void createKildaNbWorkerReplyStream(TopologyBuilder builder, int spoutParallelism, int parallelism,\n-                                                  KafkaTopicsConfig topicsConfig,\n-                                                  List<String> kildaNbWorkerTopics) {\n-        createKildaNbWorkerSpout(builder, spoutParallelism, kildaNbWorkerTopics);\n-        createKildaNbWorkerKafkaBolt(builder, parallelism, topicsConfig);\n+        ControllerToSpeakerBroadcastBolt broadcast = new ControllerToSpeakerBroadcastBolt(\n+                kafkaTopics.getStatsStatsRequestPrivRegionTopic(), regions);\n+        topology.setBolt(ComponentType.STATS_STATS_REQUEST_BOLT, broadcast, parallelism)\n+                .shuffleGrouping(ComponentType.STATS_STATS_REQUEST_KAFKA_SPOUT);\n \n-        ReplyBolt replyBolt = new ReplyBolt(Stream.NB_WORKER);\n-        builder.setBolt(ComponentType.KILDA_NB_WORKER_REPLY_BOLT, replyBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_NB_WORKER_KAFKA_SPOUT);\n+        output.getKafkaGenericOutput()\n+                .shuffleGrouping(ComponentType.STATS_STATS_REQUEST_BOLT);\n     }\n \n+    private void controllerToSpeaker(\n+            TopologyBuilder topology, int spoutParallelism, int parallelism, TopologyOutput output) {\n+        BoltDeclarer kafkaProducer = output.getKafkaGenericOutput();\n \n+        KafkaSpout<String, Message> spout = buildKafkaSpout(\n+                kafkaTopics.getSpeakerTopic(), ComponentType.SPEAKER_KAFKA_SPOUT);\n+        topology.setSpout(ComponentType.SPEAKER_KAFKA_SPOUT, spout, spoutParallelism);\n \n-    private void createSpeakerFlowRequestStream(TopologyBuilder builder, int parallelism,\n-                                                KafkaTopicsConfig topicsConfig) {\n-        createSpeakerFlowHsRequestSpoutAndKafkaBolt(builder, parallelism, topicsConfig);\n-\n-        RequestBolt speakerFlowRequestBolt = new RequestBolt(Stream.SPEAKER_FLOW_HS,\n-                topologyConfig.getFloodlightRegions());\n-        builder.setBolt(ComponentType.SPEAKER_FLOW_REQUEST_BOLT, speakerFlowRequestBolt, parallelism)\n-                .shuffleGrouping(ComponentType.SPEAKER_FLOW_HS_KAFKA_SPOUT)\n-                .allGrouping(ComponentType.KILDA_TOPO_DISCO_BOLT, Stream.REGION_NOTIFICATION);\n-    }\n+        ControllerToSpeakerProxyBolt proxy = new ControllerToSpeakerSharedProxyBolt(\n+                kafkaTopics.getSpeakerRegionTopic(), regions, kafkaTopics);\n+        topology.setBolt(ComponentType.SPEAKER_REQUEST_BOLT, proxy, parallelism)\n+                .shuffleGrouping(ComponentType.SPEAKER_KAFKA_SPOUT)\n+                .allGrouping(RegionTrackerBolt.BOLT_ID, RegionTrackerBolt.STREAM_REGION_UPDATE_ID);\n \n-    private void createSpeakerFlowHsRequestSpoutAndKafkaBolt(TopologyBuilder builder, int parallelism,\n-                                                             KafkaTopicsConfig topicsConfig) {\n-        KafkaSpout speakerFlowKafkaSpout = buildKafkaSpoutForAbstractMessage(topicsConfig.getSpeakerFlowHsTopic(),\n-                ComponentType.SPEAKER_FLOW_HS_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.SPEAKER_FLOW_HS_KAFKA_SPOUT, speakerFlowKafkaSpout);\n-\n-        for (String region: topologyConfig.getFloodlightRegions()) {\n-            KafkaBolt speakerFlowKafkaBolt = buildKafkaBoltWithAbstractMessageSupport(\n-                    Stream.formatWithRegion(topicsConfig.getSpeakerFlowRegionTopic(), region));\n-            builder.setBolt(Stream.formatWithRegion(ComponentType.SPEAKER_FLOW_HS_KAFKA_BOLT, region),\n-                    speakerFlowKafkaBolt, parallelism)\n-                    .shuffleGrouping(ComponentType.SPEAKER_FLOW_REQUEST_BOLT,\n-                            Stream.formatWithRegion(Stream.SPEAKER_FLOW_HS, region));\n-        }\n+        kafkaProducer\n+                .shuffleGrouping(ComponentType.SPEAKER_REQUEST_BOLT)\n+                .shuffleGrouping(ComponentType.SPEAKER_REQUEST_BOLT, Stream.KILDA_SWITCH_MANAGER)\n+                .shuffleGrouping(ComponentType.SPEAKER_REQUEST_BOLT, Stream.NORTHBOUND_REPLY);\n     }\n \n-    private void createSpeakerFlowPingRequestStream(TopologyBuilder builder, int parallelism,\n-                                                    KafkaTopicsConfig topicsConfig) {\n-        KafkaSpout speakerPingKafkaSpout = buildKafkaSpout(topicsConfig.getSpeakerFlowPingTopic(),\n-                ComponentType.SPEAKER_PING_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.SPEAKER_PING_KAFKA_SPOUT, speakerPingKafkaSpout);\n-\n-        for (String region: topologyConfig.getFloodlightRegions()) {\n-            KafkaBolt speakerPingKafkaBolt = buildKafkaBolt(\n-                    Stream.formatWithRegion(topicsConfig.getSpeakerFlowPingRegionTopic(), region));\n-            builder.setBolt(Stream.formatWithRegion(ComponentType.SPEAKER_PING_KAFKA_BOLT, region),\n-                    speakerPingKafkaBolt, parallelism)\n-                    .shuffleGrouping(ComponentType.SPEAKER_PING_REQUEST_BOLT,\n-                            Stream.formatWithRegion(Stream.SPEAKER_PING, region));\n-        }\n+    private void regionTracker(TopologyBuilder topology, TopologyOutput output) {\n+        RegionTrackerBolt bolt = new RegionTrackerBolt(\n+                kafkaTopics, persistenceManager, regions,\n+                topologyConfig.getFloodlightAliveTimeout(), topologyConfig.getFloodlightAliveInterval(),\n+                topologyConfig.getFloodlightDumpInterval());\n+        topology.setBolt(RegionTrackerBolt.BOLT_ID, bolt, 1)  // must be 1 for now\n+                .shuffleGrouping(ComponentType.KILDA_TOPO_DISCO_REPLY_BOLT, Stream.DISCO_REPLY);\n \n-        RequestBolt speakerPingRequestBolt = new RequestBolt(Stream.SPEAKER_PING,\n-                topologyConfig.getFloodlightRegions());\n-        builder.setBolt(ComponentType.SPEAKER_PING_REQUEST_BOLT, speakerPingRequestBolt, parallelism)\n-                .shuffleGrouping(ComponentType.SPEAKER_PING_KAFKA_SPOUT)\n-                .allGrouping(ComponentType.KILDA_TOPO_DISCO_BOLT, Stream.REGION_NOTIFICATION);\n+        output.getKafkaGenericOutput()\n+                .shuffleGrouping(RegionTrackerBolt.BOLT_ID, RegionTrackerBolt.STREAM_SPEAKER_ID)\n+                .shuffleGrouping(RegionTrackerBolt.BOLT_ID, RegionTrackerBolt.STREAM_NETWORK_ID);\n     }\n \n-    private void createSpeakerRequestStream(TopologyBuilder builder, int parallelism,\n-                                            KafkaTopicsConfig topicsConfig) {\n-        KafkaSpout speakerKafkaSpout = buildKafkaSpout(topicsConfig.getSpeakerTopic(),\n-                ComponentType.SPEAKER_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.SPEAKER_KAFKA_SPOUT, speakerKafkaSpout);\n-\n-        for (String region: topologyConfig.getFloodlightRegions()) {\n-            KafkaBolt speakerKafkaBolt = buildKafkaBolt(\n-                    Stream.formatWithRegion(topicsConfig.getSpeakerRegionTopic(), region));\n-            builder.setBolt(Stream.formatWithRegion(ComponentType.SPEAKER_KAFKA_BOLT, region),\n-                    speakerKafkaBolt, parallelism)\n-                    .shuffleGrouping(ComponentType.SPEAKER_REQUEST_BOLT,\n-                            Stream.formatWithRegion(Stream.SPEAKER, region));\n-        }\n+    private TopologyOutput kafkaOutput(TopologyBuilder topology, int scaleFactor) {\n+        RegionAwareKafkaTopicSelector topicSelector = new RegionAwareKafkaTopicSelector();\n+        BoltDeclarer generic = topology.setBolt(\n+                ComponentType.KAFKA_GENERIC_OUTPUT,\n+                makeKafkaBolt(MessageSerializer.class).withTopicSelector(topicSelector),\n+                scaleFactor);\n+        BoltDeclarer hs = topology.setBolt(\n+                ComponentType.KAFKA_HS_OUTPUT,\n+                makeKafkaBolt(AbstractMessageSerializer.class).withTopicSelector(topicSelector),\n+                scaleFactor);\n \n-        SpeakerRequestBolt speakerRequestBolt = new SpeakerRequestBolt(Stream.SPEAKER,\n-                topologyConfig.getFloodlightRegions());\n-        builder.setBolt(ComponentType.SPEAKER_REQUEST_BOLT, speakerRequestBolt, parallelism)\n-                .shuffleGrouping(ComponentType.SPEAKER_KAFKA_SPOUT)\n-                .allGrouping(ComponentType.KILDA_TOPO_DISCO_BOLT, Stream.REGION_NOTIFICATION);\n+        return new TopologyOutput(generic, hs);\n     }\n \n+    private void declareSpeakerToControllerProxy(\n+            TopologyBuilder topology, String speakerTopicsSeed, String controllerTopic, String spoutId,\n+            String proxyBoltId, BoltDeclarer output, int spoutParallelism, int proxyParallelism) {\n+        KafkaSpout<String, Message> spout = buildKafkaSpout(makeRegionTopics(speakerTopicsSeed), spoutId);\n+        topology.setSpout(spoutId, spout, spoutParallelism);\n \n-    private void createKildaTopoDiscoSpout(TopologyBuilder builder, int parallelism,\n-                                           List<String> kildaTopoDiscoTopics) {\n-        KafkaSpout kildaTopoDiscoSpout = buildKafkaSpout(kildaTopoDiscoTopics,\n-                ComponentType.KILDA_TOPO_DISCO_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.KILDA_TOPO_DISCO_KAFKA_SPOUT, kildaTopoDiscoSpout, parallelism);\n-    }\n-\n-    private void createKildaTopoDiscoKafkaBolt(TopologyBuilder builder, int parallelism,\n-                                               KafkaTopicsConfig topicsConfig) {\n-        KafkaBolt kildaTopoDiscoKafkaBolt = buildKafkaBolt(topicsConfig.getTopoDiscoTopic());\n-        builder.setBolt(ComponentType.KILDA_TOPO_DISCO_KAFKA_BOLT, kildaTopoDiscoKafkaBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_TOPO_DISCO_REPLY_BOLT, Stream.KILDA_TOPO_DISCO)\n-                .shuffleGrouping(ComponentType.KILDA_TOPO_DISCO_BOLT, Stream.KILDA_TOPO_DISCO);\n+        declareSpeakerToControllerProxy(topology, controllerTopic, spoutId, proxyBoltId, output, proxyParallelism);\n     }\n \n+    private void declareSpeakerToControllerProxy(\n+            TopologyBuilder topology, String controllerTopic, String spoutId, String proxyBoltId, BoltDeclarer output,\n+            int parallelism) {\n+        SpeakerToControllerProxyBolt proxy = new SpeakerToControllerProxyBolt(controllerTopic);\n+        topology.setBolt(proxyBoltId, proxy, parallelism)\n+                .shuffleGrouping(spoutId);\n \n-    private void createKildaTopoDiscoReplyStream(TopologyBuilder builder, int spoutParallelism, int parallelism,\n-                                                 KafkaTopicsConfig topicsConfig,\n-                                                 List<String> kildaTopoDiscoTopics) {\n-        createKildaTopoDiscoSpout(builder, spoutParallelism, kildaTopoDiscoTopics);\n-        createKildaTopoDiscoKafkaBolt(builder, parallelism, topicsConfig);\n-\n-        DiscoReplyBolt replyBolt = new DiscoReplyBolt(Stream.KILDA_TOPO_DISCO);\n-        builder.setBolt(ComponentType.KILDA_TOPO_DISCO_REPLY_BOLT, replyBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_TOPO_DISCO_KAFKA_SPOUT);\n+        output.shuffleGrouping(proxyBoltId);\n     }\n \n-    private void createSpeakerDiscoSpout(TopologyBuilder builder, int parallelism,\n-                                         String kildaTopoDiscoTopic) {\n-        KafkaSpout speakerDiscoSpout = buildKafkaSpout(kildaTopoDiscoTopic,\n-                ComponentType.SPEAKER_DISCO_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.SPEAKER_DISCO_KAFKA_SPOUT, speakerDiscoSpout, parallelism);\n-    }\n-\n-    private void createSpeakerDiscoKafkaBolt(TopologyBuilder builder, int parallelism,\n-                                             KafkaTopicsConfig topicsConfig) {\n-        for (String region: topologyConfig.getFloodlightRegions()) {\n-            KafkaBolt speakerDiscoKafkaBolt = buildKafkaBolt(\n-                    Stream.formatWithRegion(topicsConfig.getSpeakerDiscoRegionTopic(), region));\n-            builder.setBolt(Stream.formatWithRegion(ComponentType.SPEAKER_DISCO_KAFKA_BOLT, region),\n-                    speakerDiscoKafkaBolt, parallelism)\n-                    .shuffleGrouping(ComponentType.KILDA_TOPO_DISCO_BOLT,\n-                            Stream.formatWithRegion(Stream.SPEAKER_DISCO, region))\n-                    .shuffleGrouping(ComponentType.SPEAKER_DISCO_REQUEST_BOLT,\n-                            Stream.formatWithRegion(Stream.SPEAKER_DISCO, region));\n+    private void declareControllerToSpeakerProxy(\n+            TopologyBuilder topology, String speakerTopicsSeed, String controllerTopic, String spoutId,\n+            String proxyBoltId, BoltDeclarer output, int spoutParallelism, int proxyParallelism) {\n+        KafkaSpout<String, Message> spout = buildKafkaSpout(controllerTopic, spoutId);\n+        topology.setSpout(spoutId, spout, spoutParallelism);\n \n-        }\n+        declareControllerToSpeakerProxy(topology, speakerTopicsSeed, spoutId, proxyBoltId, output, proxyParallelism);\n     }\n \n-    private void createSpeakerDiscoRequestStream(TopologyBuilder builder, int parallelism,\n-                                                 KafkaTopicsConfig topicsConfig) {\n-        createSpeakerDiscoSpout(builder, parallelism, topicsConfig.getSpeakerDiscoTopic());\n-        createSpeakerDiscoKafkaBolt(builder, parallelism, topicsConfig);\n-        RequestBolt speakerDiscoRequestBolt = new RequestBolt(Stream.SPEAKER_DISCO,\n-                topologyConfig.getFloodlightRegions());\n-        builder.setBolt(ComponentType.SPEAKER_DISCO_REQUEST_BOLT, speakerDiscoRequestBolt, parallelism)\n-                .shuffleGrouping(ComponentType.SPEAKER_DISCO_KAFKA_SPOUT)\n-                .allGrouping(ComponentType.KILDA_TOPO_DISCO_BOLT, Stream.REGION_NOTIFICATION);\n+    private void declareControllerToSpeakerProxy(\n+            TopologyBuilder topology, String speakerTopicsSeed, String spoutId, String proxyBoltId, BoltDeclarer output,\n+            int parallelism) {\n+        ControllerToSpeakerProxyBolt proxy = new ControllerToSpeakerProxyBolt(speakerTopicsSeed, regions);\n+        topology.setBolt(proxyBoltId, proxy, parallelism)\n+                .shuffleGrouping(spoutId)\n+                .allGrouping(RegionTrackerBolt.BOLT_ID, RegionTrackerBolt.STREAM_REGION_UPDATE_ID);\n \n+        output.shuffleGrouping(proxyBoltId);\n     }\n \n-    private void createDiscoveryPipelines(TopologyBuilder builder, int parallelism, KafkaTopicsConfig topicsConfig,\n-                                          List<String> kildaTopoDiscoTopics) {\n-\n-        DiscoveryBolt discoveryBolt = new DiscoveryBolt(\n-                persistenceManager,\n-                topologyConfig.getFloodlightRegions(), topologyConfig.getFloodlightAliveTimeout(),\n-                topologyConfig.getFloodlightAliveInterval(), topologyConfig.getFloodlightDumpInterval());\n-        builder.setBolt(ComponentType.KILDA_TOPO_DISCO_BOLT, discoveryBolt, parallelism)\n-                .shuffleGrouping(ComponentType.KILDA_TOPO_DISCO_REPLY_BOLT, Stream.DISCO_REPLY);\n-    }\n-\n-    private void createStatsStatsRequestStream(TopologyBuilder builder, int parallelism,\n-                                               KafkaTopicsConfig topicsConfig) {\n-        KafkaSpout statsStatsRequestKafkaSpout = buildKafkaSpout(topicsConfig.getStatsStatsRequestPrivTopic(),\n-                ComponentType.STATS_STATS_REQUEST_KAFKA_SPOUT);\n-        builder.setSpout(ComponentType.STATS_STATS_REQUEST_KAFKA_SPOUT, statsStatsRequestKafkaSpout);\n-\n-        for (String region: topologyConfig.getFloodlightRegions()) {\n-            KafkaBolt statsStatsRequestKafkaBolt = buildKafkaBolt(\n-                    Stream.formatWithRegion(topicsConfig.getStatsStatsRequestPrivRegionTopic(), region));\n-            builder.setBolt(Stream.formatWithRegion(ComponentType.STATS_STATS_REQUEST_KAFKA_BOLT, region),\n-                    statsStatsRequestKafkaBolt, parallelism)\n-                    .shuffleGrouping(ComponentType.STATS_STATS_REQUEST_BOLT,\n-                            Stream.formatWithRegion(Stream.STATS_STATS_REQUEST_PRIV, region));\n+    private List<String> makeRegionTopics(String topicSeed) {\n+        List<String> regionTopics = new ArrayList<>(regions.size());\n+        for (String entry : regions) {\n+            regionTopics.add(Stream.formatWithRegion(topicSeed, entry));\n         }\n-\n-        BroadcastRequestBolt speakerRequestBolt = new BroadcastRequestBolt(Stream.STATS_STATS_REQUEST_PRIV,\n-                topologyConfig.getFloodlightRegions());\n-        builder.setBolt(ComponentType.STATS_STATS_REQUEST_BOLT, speakerRequestBolt, parallelism)\n-                .shuffleGrouping(ComponentType.STATS_STATS_REQUEST_KAFKA_SPOUT);\n-    }\n-\n-    private void createFlStatsSwitchesStream(TopologyBuilder builder,\n-                                             int parallelism,\n-                                             KafkaTopicsConfig topicsConfig,\n-                                             List<String> kildaFlStatsSwitchesTopics) {\n-        KafkaSpout flStatsSwitchesSpout = buildKafkaSpout(kildaFlStatsSwitchesTopics,\n-                ComponentType.FL_STATS_SWITCHES_SPOUT);\n-        builder.setSpout(ComponentType.FL_STATS_SWITCHES_SPOUT, flStatsSwitchesSpout);\n-\n-        ReplyBolt replyBolt = new ReplyBolt(Stream.FL_STATS_SWITCHES);\n-        builder.setBolt(ComponentType.FL_STATS_SWITCHES_REPLY_BOLT, replyBolt, parallelism)\n-                .shuffleGrouping(ComponentType.FL_STATS_SWITCHES_SPOUT);\n-\n-        KafkaBolt kildaFlStatsSwtichesKafkaBolt = buildKafkaBolt(topicsConfig.getFlStatsSwitchesPrivTopic());\n-        builder.setBolt(ComponentType.FL_STATS_SWITCHES_KAFKA_BOLT, kildaFlStatsSwtichesKafkaBolt, parallelism)\n-                .shuffleGrouping(ComponentType.FL_STATS_SWITCHES_REPLY_BOLT, Stream.FL_STATS_SWITCHES);\n+        return regionTopics;\n     }\n \n-    @Override\n-    public StormTopology createTopology() {\n-        logger.info(\"Creating FlowTopology - {}\", topologyName);\n-\n-        TopologyBuilder builder = new TopologyBuilder();\n-        Integer newParallelism = topologyConfig.getNewParallelism();\n-        Integer parallelism = topologyConfig.getParallelism();\n-\n-        KafkaTopicsConfig topicsConfig = topologyConfig.getKafkaTopics();\n-        Set<String> regions = topologyConfig.getFloodlightRegions();\n-        // Floodlight -- kilda.flow --> Router\n-        List<String> kildaFlowHsTopics = new ArrayList<>();\n-        for (String region: regions) {\n-            kildaFlowHsTopics.add(Stream.formatWithRegion(topicsConfig.getFlowHsSpeakerRegionTopic(), region));\n-        }\n-        createKildaFlowHsReplyStream(builder, parallelism, newParallelism, topicsConfig, kildaFlowHsTopics);\n-\n-        // Floodlight -- kilda.ping --> Router\n-        List<String> kildaPingTopics = new ArrayList<>();\n-        for (String region: regions) {\n-            kildaPingTopics.add(Stream.formatWithRegion(topicsConfig.getPingRegionTopic(), region));\n-        }\n-        createKildaPingReplyStream(builder, parallelism, newParallelism, topicsConfig, kildaPingTopics);\n-\n-        // Floodlight -- kilda.stats --> Router\n-        List<String> kildaStatsTopics = new ArrayList<>();\n-        for (String region: regions) {\n-            kildaStatsTopics.add(Stream.formatWithRegion(topicsConfig.getStatsRegionTopic(), region));\n-        }\n-        createKildaStatsReplyStream(builder, parallelism, newParallelism, topicsConfig, kildaStatsTopics);\n-\n-        // Floodlight -- kilda.topo.isl.latency --> Router\n-        List<String> kildaIslLatencyTopics = new ArrayList<>();\n-        for (String region: regions) {\n-            kildaIslLatencyTopics.add(Stream.formatWithRegion(topicsConfig.getTopoIslLatencyRegionTopic(), region));\n-        }\n-        createKildaIslLatencyReplyStream(builder, parallelism, newParallelism, topicsConfig, kildaIslLatencyTopics);\n-\n-        // Floodlight -- kilda.floodlight.connected.devices.priv --> Router\n-        List<String> kildaConnectedDevicesTopics = new ArrayList<>();\n-        for (String region: regions) {\n-            kildaConnectedDevicesTopics.add(Stream.formatWithRegion(\n-                    topicsConfig.getTopoConnectedDevicesRegionTopic(), region));\n-        }\n-        createKildaConnectedDevicesReplyStream(builder, parallelism, newParallelism,\n-                topicsConfig, kildaConnectedDevicesTopics);\n-\n-        // Floodlight -- kilda.topo.switch.manager --> Router\n-        List<String> kildaSwitchManagerTopics = new ArrayList<>();\n-        for (String region: regions) {\n-            kildaSwitchManagerTopics.add(\n-                    Stream.formatWithRegion(topicsConfig.getTopoSwitchManagerRegionTopic(), region));\n-        }\n-        createKildaSwitchManagerReplyStream(builder, parallelism,\n-                newParallelism, topicsConfig, kildaSwitchManagerTopics);\n-\n-        // Floodlight -- kilda.northbound --> Router\n-        List<String> kildaNorthboundTopics = new ArrayList<>();\n-        for (String region: regions) {\n-            kildaNorthboundTopics.add(Stream.formatWithRegion(topicsConfig.getNorthboundRegionTopic(), region));\n-        }\n-        createKildaNorthboundReplyStream(builder, parallelism,\n-                newParallelism, topicsConfig, kildaNorthboundTopics);\n-\n-        // Floodlight -- kilda.topo.nb --> Router\n-        List<String> kildaNbWorkerTopics = new ArrayList<>();\n-        for (String region: regions) {\n-            kildaNbWorkerTopics.add(Stream.formatWithRegion(topicsConfig.getTopoNbRegionTopic(), region));\n-        }\n-        createKildaNbWorkerReplyStream(builder, parallelism, newParallelism, topicsConfig, kildaNbWorkerTopics);\n-\n-        // Part3 Request to Floodlights\n-        // Storm -- kilda.speaker.flow --> Floodlight\n-        createSpeakerFlowRequestStream(builder, newParallelism, topicsConfig);\n-\n-        // Storm -- kilda.speaker.flow.ping --> Floodlight\n-        createSpeakerFlowPingRequestStream(builder, newParallelism, topicsConfig);\n-\n-        // Storm -- kilda.speaker --> Floodlight\n-        createSpeakerRequestStream(builder, newParallelism, topicsConfig);\n-\n-        // Storm -- kilda.speaker.disco --> Floodlight\n-        createSpeakerDiscoRequestStream(builder, newParallelism, topicsConfig);\n-\n-        // Storm <-- kilda.topo.disco -- Floodlight\n-        List<String> kildaTopoDiscoTopics = new ArrayList<>();\n-        for (String region : topologyConfig.getFloodlightRegions()) {\n-            kildaTopoDiscoTopics.add(Stream.formatWithRegion(topicsConfig.getTopoDiscoRegionTopic(), region));\n-\n-        }\n-        createKildaTopoDiscoReplyStream(builder, parallelism, newParallelism, topicsConfig, kildaTopoDiscoTopics);\n-\n-        createDiscoveryPipelines(builder, parallelism, topicsConfig, kildaTopoDiscoTopics);\n-\n-        // Storm -- kilda.stats.stats-request.priv --> Floodlight\n-        createStatsStatsRequestStream(builder, parallelism, topicsConfig);\n-\n-        // Storm <-- kilda.fl-stats.switches.priv -- Floodlight\n-        List<String> kildaFlStatsSwitchesTopics = regions.stream()\n-                .map(region -> Stream.formatWithRegion(topicsConfig.getFlStatsSwitchesPrivRegionTopic(), region))\n-                .collect(Collectors.toList());\n-        createFlStatsSwitchesStream(builder, parallelism, topicsConfig, kildaFlStatsSwitchesTopics);\n-\n-        return builder.createTopology();\n+    @Value\n+    private static class TopologyOutput {", "originalCommit": "e5e1f7db80a4b5ce528655a9b8aea758c6e49262", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAxODE4MA==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r460018180", "bodyText": "It removes \"knowledge\" regarding specific bolts chain requirements from createTopology level and moves it on the level of the specific chain.\nYes, it can be relatively easily removed, but I would like to keep it in the current shape. If you have strict objections, I will remove it.", "author": "surabujin", "createdAt": "2020-07-24T12:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU2NTY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2OTQyMA==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r459869420", "bodyText": "would be nice to see this tuple field names in a single place someday(not in this pr)", "author": "timofei-durakov", "createdAt": "2020-07-24T06:14:54Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/RegionAwareKafkaTopicSelector.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.floodlightrouter;\n+\n+import joptsimple.internal.Strings;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.storm.kafka.bolt.selector.KafkaTopicSelector;\n+import org.apache.storm.tuple.Tuple;\n+\n+@Slf4j\n+public class RegionAwareKafkaTopicSelector implements KafkaTopicSelector {\n+    public static final String FIELD_ID_TOPIC = \"topic\";", "originalCommit": "8a65132e396f77fe5212f0c303d6d821b4a4e398", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMDM5Ng==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r460020396", "bodyText": "? Why for?\nAny bolt that wants to use this topic-selector must use this filed names because the topic selector expects them in the tuple. So bolts can refer to these constants.\nThis class is responsible for these fields, it defines the logic of their usage and it requires their presence into the tuple. So why we need some 3rd place to define these names/constants?", "author": "surabujin", "createdAt": "2020-07-24T12:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2OTQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2OTc3NQ==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r459869775", "bodyText": "where do we use this?", "author": "timofei-durakov", "createdAt": "2020-07-24T06:16:15Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/RegionAwareKafkaTopicSelector.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.floodlightrouter;\n+\n+import joptsimple.internal.Strings;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.storm.kafka.bolt.selector.KafkaTopicSelector;\n+import org.apache.storm.tuple.Tuple;\n+\n+@Slf4j\n+public class RegionAwareKafkaTopicSelector implements KafkaTopicSelector {\n+    public static final String FIELD_ID_TOPIC = \"topic\";\n+    public static final String FIELD_ID_REGION = \"region\";\n+\n+    @Override\n+    public String getTopic(Tuple tuple) {\n+        String topic;\n+        String region;\n+        try {\n+            topic = tuple.getStringByField(FIELD_ID_TOPIC);\n+            region = tuple.getStringByField(FIELD_ID_REGION);\n+        } catch (IndexOutOfBoundsException | ClassCastException e) {\n+            reportError(tuple, \"Can't extract topic and/or region names: {}\", e);\n+            return null;\n+        }\n+\n+        if (topic == null) {\n+            reportError(tuple, \"target topic is null\");\n+            return null;\n+        }\n+\n+        return formatTopicName(topic, region);\n+    }\n+\n+    /**\n+     * Create region specific kafka-topic name or generic topic name if region is null.\n+     */\n+    public static String formatTopicName(String topic, String region) {\n+        if (Strings.isNullOrEmpty(region)) {\n+            return topic;", "originalCommit": "8a65132e396f77fe5212f0c303d6d821b4a4e398", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMDg4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r460020883", "bodyText": "Into speaker-to-controller chains.", "author": "surabujin", "createdAt": "2020-07-24T12:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2OTc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg3MDg2Ng==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r459870866", "bodyText": "how could be since this one is ticking?", "author": "timofei-durakov", "createdAt": "2020-07-24T06:20:38Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/bolts/RegionTrackerBolt.java", "diffHunk": "@@ -29,29 +30,41 @@\n import org.openkilda.wfm.CommandContext;\n import org.openkilda.wfm.topology.AbstractTopology;\n import org.openkilda.wfm.topology.floodlightrouter.ComponentType;\n+import org.openkilda.wfm.topology.floodlightrouter.RegionAwareKafkaTopicSelector;\n import org.openkilda.wfm.topology.floodlightrouter.Stream;\n import org.openkilda.wfm.topology.floodlightrouter.service.FloodlightTracker;\n import org.openkilda.wfm.topology.floodlightrouter.service.MessageSender;\n import org.openkilda.wfm.topology.floodlightrouter.service.RouterService;\n import org.openkilda.wfm.topology.floodlightrouter.service.SwitchMapping;\n import org.openkilda.wfm.topology.utils.AbstractTickRichBolt;\n \n+import lombok.extern.slf4j.Slf4j;\n import org.apache.storm.kafka.bolt.mapper.FieldNameBasedTupleToKafkaMapper;\n import org.apache.storm.task.OutputCollector;\n import org.apache.storm.task.TopologyContext;\n import org.apache.storm.topology.OutputFieldsDeclarer;\n import org.apache.storm.tuple.Fields;\n import org.apache.storm.tuple.Tuple;\n import org.apache.storm.tuple.Values;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n \n-public class DiscoveryBolt extends AbstractTickRichBolt implements MessageSender {\n-    private static final Logger logger = LoggerFactory.getLogger(DiscoveryBolt.class);\n+// FIXME(surabujin) must use AbstractBolt as base", "originalCommit": "8a65132e396f77fe5212f0c303d6d821b4a4e398", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMTg3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3576#discussion_r460021872", "bodyText": "In the same way as all other time processing bolts (see ping, network topologies or #3623)", "author": "surabujin", "createdAt": "2020-07-24T12:29:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg3MDg2Ng=="}], "type": "inlineReview"}, {"oid": "8420c8e4c2b53d7a319eaaab0f549cbb046b3391", "url": "https://github.com/telstra/open-kilda/commit/8420c8e4c2b53d7a319eaaab0f549cbb046b3391", "message": "Decrease amount of kafka bolts in flrouter", "committedDate": "2020-07-28T18:15:24Z", "type": "commit"}, {"oid": "8420c8e4c2b53d7a319eaaab0f549cbb046b3391", "url": "https://github.com/telstra/open-kilda/commit/8420c8e4c2b53d7a319eaaab0f549cbb046b3391", "message": "Decrease amount of kafka bolts in flrouter", "committedDate": "2020-07-28T18:15:24Z", "type": "forcePushed"}]}