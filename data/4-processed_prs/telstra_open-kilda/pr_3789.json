{"pr_number": 3789, "pr_title": "add flowLoop endpoint into func test", "pr_createdAt": "2020-10-16T15:04:27Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3789", "timeline": [{"oid": "2d26aab2bd9e538d95b050746efead3150d9497c", "url": "https://github.com/telstra/open-kilda/commit/2d26aab2bd9e538d95b050746efead3150d9497c", "message": "add tests for flowLoop", "committedDate": "2020-10-20T07:56:30Z", "type": "forcePushed"}, {"oid": "c6bb3da80b01c24cbdc7f73f440efede00ed0b1f", "url": "https://github.com/telstra/open-kilda/commit/c6bb3da80b01c24cbdc7f73f440efede00ed0b1f", "message": "add tests for flowLoop", "committedDate": "2020-10-21T11:31:02Z", "type": "forcePushed"}, {"oid": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "url": "https://github.com/telstra/open-kilda/commit/83ba9085f8127bda8df3ac103df5f65726abdf0d", "message": "add tests for flowLoop", "committedDate": "2020-10-21T11:37:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1ODM4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510758383", "bodyText": "Is it really mandatory to limit only neighboring switchPairs? You can miss test runs because of this", "author": "rtretyak", "createdAt": "2020-10-23T09:31:33Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 0\n+                                 destination.vlanId = 0\n+                             }\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { allocateProtectedPath = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { encapsulationType = FlowEncapsulationType.VXLAN } }\n+                 ],\n+                 [\n+                         flowDescription: \"qinq\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 10\n+                                 source.innerVlanId = 100\n+                                 destination.vlanId = 20\n+                                 destination.innerVlanId = 200\n+                             }\n+                         }\n+                 ]\n+        ]\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules\")\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Try to create flowLoop on the same switch again\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"No extra rules are not created\"\n+        //bug with rule\n+//        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+\n+        and: \"The switch is still valid\"\n+        //there is probably a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete flowLoop\"\n+        northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"FlowLoop is deleted\"\n+        with(northbound.getFlow(flow.flowId)) { !it.looped }\n+\n+        and: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules, can't delete flow\")\n+    @Tidy\n+    def \"Able to create flowLoop for a singleSwitchSinglePort flow\"() {\n+        given: \"An active singleSwitchSinglePort flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchSinglePortFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//      northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete the flow with created flowLoop\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        Set<Isl> altFlowIsls = []\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        allFlowPaths.findAll { it != flowPath }.each { altFlowIsls.addAll(pathHelper.getInvolvedIsls(it)) }\n+        def islToFail = flowIsls.find { !(it in altFlowIsls) && !(it.reversed in altFlowIsls) }\n+        antiflap.portDown(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+\n+        then: \"The flow was rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) != flowPath\n+        }\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is still created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        cleanup: \"Revive the ISL back (bring switch port up) and delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        islToFail && antiflap.portUp(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Ignore(\"wait fix for switchValidation/ sycnSwitch missing flowLoop rules\")\n+    @Tidy\n+    def \"System is able to detect and sync missing flowLoop rules\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        def flowLoopRules\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            flowLoopRules = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }*.cookie\n+            assert flowLoopRules.size() == 2\n+        }\n+\n+        when: \"Delete flowLoop rules\"\n+        flowLoopRules.each { northbound.deleteSwitchRules(switchPair.src.dpId, it) }\n+\n+        then: \"System detects missing flowLoop rules\"\n+        assert northbound.validateSwitch(switchPair.src.dpId).rules.missing.sort() == flowLoopRules.sort()\n+\n+        when: \"Sync the src switch\"\n+        def syncResponse = northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+        then: \"Sync response contains flowLoop rules into the installed section\"\n+        assert syncResponse.rules.installed.sort() == flowLoopRules.sort()\n+\n+        then: \"FlowLoop rules are synced\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.size() == 2\n+        assert northbound.validateSwitch(switchPair.src.dpId).rules.missing.empty\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop when a switch is deactivated\"() {\n+        given: \"An active flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Deactivated the src switch\"\n+        def blockData = switchHelper.knockoutSwitch(switchPair.src, RW)\n+\n+        when: \"Try to create flowLoop on th src switch(deactivated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        and: \"FlowLoop is not created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+        }\n+\n+        when: \"Try to create flowLoop on th dst switch(activated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"Human readable error is returned\" //system can't update the flow when it is down\n+        def exc2 = thrown(HttpClientErrorException)\n+        exc2.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc2.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        then: \"FlowLoop is not created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.empty\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        switchHelper.reviveSwitch(switchPair.src, blockData, true)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on the src switch when it is already created on the dst switch\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        when: \"Try to create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is not created on the dst switch\"\n+        def exc2 = thrown(HttpClientErrorException)\n+        exc2.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc2.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on a transit switch\"() {\n+        given: \"An active multi switch flow with transit switch\"\n+        def switchPair = topologyHelper.getNotNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def transitSwId = PathHelper.convert(northbound.getFlowPath(flow.flowId))[1].switchId\n+\n+        when: \"Try to create flowLoop on the transit switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(transitSwId))\n+\n+        then: \"Human readable error is returned\" //system can't update the flow when it is down\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Loop switch is not terminating in flow path\"\n+        }\n+\n+        then: \"FlowLoop is not created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(transitSwId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.empty\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    def \"getSwPairConnectedToTraffGenForSimpleFlow\"(List<SwitchId> switchIds) {\n+        getTopologyHelper().getAllNeighboringSwitchPairs().find {", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg0MDExOQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r512840119", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-10-27T16:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1ODM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1OTE5NA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510759194", "bodyText": "there should be a verb. like data.updateFlow(flow) or sth", "author": "rtretyak", "createdAt": "2020-10-23T09:32:56Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDg1NTc2OA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510855768", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-10-23T12:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1OTE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1OTgzMw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510759833", "bodyText": "not sure why this is here", "author": "rtretyak", "createdAt": "2020-10-23T09:34:04Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDg1NjYxMA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510856610", "bodyText": "it was added for debugging,\ndeleted", "author": "andriidovhan", "createdAt": "2020-10-23T12:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1OTgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc2MjgzMw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510762833", "bodyText": "every", "author": "rtretyak", "createdAt": "2020-10-23T09:39:29Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDg1NzExOA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510857118", "bodyText": "agree, fixed", "author": "andriidovhan", "createdAt": "2020-10-23T12:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc2MjgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc2NDkzMA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510764930", "bodyText": "This really depends on the priorities of catch-ping rule and flow-loop rule. Ping may be caught earlier. Need to think of how traffgens can be configured. Or maybe some packet-out from controller could be sent", "author": "rtretyak", "createdAt": "2020-10-23T09:43:18Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU5OTg3MQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r512599871", "bodyText": "dev will think about some implementation in controller", "author": "andriidovhan", "createdAt": "2020-10-27T11:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc2NDkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc2NjI2MQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510766261", "bodyText": "Well this step should definitely go before you check that loop rules are gone or validate the switch", "author": "rtretyak", "createdAt": "2020-10-23T09:45:44Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDg1ODE2NA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510858164", "bodyText": "moved into the required place", "author": "andriidovhan", "createdAt": "2020-10-23T12:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc2NjI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc2Njc3Nw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510766777", "bodyText": "end of the test1.\nLong-running 'walls of text' are allowed, but when it is really required and makes a lot of sense or saves a lot of time. I think you've been overusing this lately. Keep tests as short and simple as possible. I think it's really a logical end of the test here", "author": "rtretyak", "createdAt": "2020-10-23T09:46:40Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY4NjAyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r512686025", "bodyText": "I think you've been overusing this lately.\n\nI didn't notice that, thx\nfixed, a separate test is created (def \"Able to delete a flow with created flowLoop on it\"())", "author": "andriidovhan", "createdAt": "2020-10-27T13:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc2Njc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3MTMwMw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510771303", "bodyText": "In order to make it less verbose you can follow such pattern:\nflowTap: { FlowRequestV2 fl -> fl.pinned = true }\n\nand in the spec do flow.tap(data.flowTap) to update the flow", "author": "rtretyak", "createdAt": "2020-10-23T09:54:35Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgyMTA2NQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r512821065", "bodyText": "thx, refactored", "author": "andriidovhan", "createdAt": "2020-10-27T16:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3MTMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3MjYxMQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510772611", "bodyText": "Looks like a separate test?", "author": "rtretyak", "createdAt": "2020-10-23T09:56:41Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 0\n+                                 destination.vlanId = 0\n+                             }\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { allocateProtectedPath = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { encapsulationType = FlowEncapsulationType.VXLAN } }\n+                 ],\n+                 [\n+                         flowDescription: \"qinq\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 10\n+                                 source.innerVlanId = 100\n+                                 destination.vlanId = 20\n+                                 destination.innerVlanId = 200\n+                             }\n+                         }\n+                 ]\n+        ]\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules\")\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Try to create flowLoop on the same switch again\"", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDg4NDk0Mg==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510884942", "bodyText": "added separate test", "author": "andriidovhan", "createdAt": "2020-10-23T13:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3MjYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3MjkyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510772925", "bodyText": "double negation, please rephrase", "author": "rtretyak", "createdAt": "2020-10-23T09:57:16Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 0\n+                                 destination.vlanId = 0\n+                             }\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { allocateProtectedPath = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { encapsulationType = FlowEncapsulationType.VXLAN } }\n+                 ],\n+                 [\n+                         flowDescription: \"qinq\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 10\n+                                 source.innerVlanId = 100\n+                                 destination.vlanId = 20\n+                                 destination.innerVlanId = 200\n+                             }\n+                         }\n+                 ]\n+        ]\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules\")\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Try to create flowLoop on the same switch again\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"No extra rules are not created\"", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDg4NTczNQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510885735", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-10-23T13:32:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3MjkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3MzI5Mw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510773293", "bodyText": "from the switch", "author": "rtretyak", "createdAt": "2020-10-23T09:57:58Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 0\n+                                 destination.vlanId = 0\n+                             }\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { allocateProtectedPath = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { encapsulationType = FlowEncapsulationType.VXLAN } }\n+                 ],\n+                 [\n+                         flowDescription: \"qinq\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 10\n+                                 source.innerVlanId = 100\n+                                 destination.vlanId = 20\n+                                 destination.innerVlanId = 200\n+                             }\n+                         }\n+                 ]\n+        ]\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules\")\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Try to create flowLoop on the same switch again\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"No extra rules are not created\"\n+        //bug with rule\n+//        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+\n+        and: \"The switch is still valid\"\n+        //there is probably a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete flowLoop\"\n+        northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"FlowLoop is deleted\"\n+        with(northbound.getFlow(flow.flowId)) { !it.looped }\n+\n+        and: \"FlowLoop rules are deleted on the switch\"", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDg4Nzc3MA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510887770", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-10-23T13:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3MzI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3NDM5NA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510774394", "bodyText": "How is this supposed to work? I mean from logical point of view, a single switch single port flow is already a loop", "author": "rtretyak", "createdAt": "2020-10-23T09:59:59Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 0\n+                                 destination.vlanId = 0\n+                             }\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { allocateProtectedPath = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { encapsulationType = FlowEncapsulationType.VXLAN } }\n+                 ],\n+                 [\n+                         flowDescription: \"qinq\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 10\n+                                 source.innerVlanId = 100\n+                                 destination.vlanId = 20\n+                                 destination.innerVlanId = 200\n+                             }\n+                         }\n+                 ]\n+        ]\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules\")\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Try to create flowLoop on the same switch again\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"No extra rules are not created\"\n+        //bug with rule\n+//        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+\n+        and: \"The switch is still valid\"\n+        //there is probably a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete flowLoop\"\n+        northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"FlowLoop is deleted\"\n+        with(northbound.getFlow(flow.flowId)) { !it.looped }\n+\n+        and: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules, can't delete flow\")\n+    @Tidy\n+    def \"Able to create flowLoop for a singleSwitchSinglePort flow\"() {", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYwNDQ3NQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r512604475", "bodyText": "@rozdy could you assist in this question?", "author": "andriidovhan", "createdAt": "2020-10-27T11:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3NDM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3NDkwNw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510774907", "bodyText": "I see no reason to limit switch pool with only neighboring", "author": "rtretyak", "createdAt": "2020-10-23T10:00:53Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 0\n+                                 destination.vlanId = 0\n+                             }\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { allocateProtectedPath = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { encapsulationType = FlowEncapsulationType.VXLAN } }\n+                 ],\n+                 [\n+                         flowDescription: \"qinq\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 10\n+                                 source.innerVlanId = 100\n+                                 destination.vlanId = 20\n+                                 destination.innerVlanId = 200\n+                             }\n+                         }\n+                 ]\n+        ]\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules\")\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Try to create flowLoop on the same switch again\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"No extra rules are not created\"\n+        //bug with rule\n+//        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+\n+        and: \"The switch is still valid\"\n+        //there is probably a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete flowLoop\"\n+        northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"FlowLoop is deleted\"\n+        with(northbound.getFlow(flow.flowId)) { !it.looped }\n+\n+        and: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules, can't delete flow\")\n+    @Tidy\n+    def \"Able to create flowLoop for a singleSwitchSinglePort flow\"() {\n+        given: \"An active singleSwitchSinglePort flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchSinglePortFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//      northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete the flow with created flowLoop\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0MzIwMg==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510943202", "bodyText": "changed in other tests", "author": "andriidovhan", "createdAt": "2020-10-23T14:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3NDkwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0NjYzMA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521446630", "bodyText": "why not here?", "author": "rtretyak", "createdAt": "2020-11-11T15:40:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3NDkwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAyNTU1OQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r522025559", "bodyText": "refactored,\nnow I pick switchPair for protected flow. In this case, we can fail any ISL and be sure that an alternative path is available.", "author": "andriidovhan", "createdAt": "2020-11-12T11:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3NDkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3NzAwNQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510777005", "bodyText": "this is 100% fine code. Just a hint, you can make it 1 line\nSet<Isl> altFlowIsls = allFlowPaths.findAll{ it != flowPath }.collectMany{ pathHelper.getInvolvedIsls(it) }", "author": "rtretyak", "createdAt": "2020-10-23T10:05:04Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 0\n+                                 destination.vlanId = 0\n+                             }\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { allocateProtectedPath = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { encapsulationType = FlowEncapsulationType.VXLAN } }\n+                 ],\n+                 [\n+                         flowDescription: \"qinq\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 10\n+                                 source.innerVlanId = 100\n+                                 destination.vlanId = 20\n+                                 destination.innerVlanId = 200\n+                             }\n+                         }\n+                 ]\n+        ]\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules\")\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Try to create flowLoop on the same switch again\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"No extra rules are not created\"\n+        //bug with rule\n+//        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+\n+        and: \"The switch is still valid\"\n+        //there is probably a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete flowLoop\"\n+        northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"FlowLoop is deleted\"\n+        with(northbound.getFlow(flow.flowId)) { !it.looped }\n+\n+        and: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules, can't delete flow\")\n+    @Tidy\n+    def \"Able to create flowLoop for a singleSwitchSinglePort flow\"() {\n+        given: \"An active singleSwitchSinglePort flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchSinglePortFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//      northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete the flow with created flowLoop\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        Set<Isl> altFlowIsls = []\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        allFlowPaths.findAll { it != flowPath }.each { altFlowIsls.addAll(pathHelper.getInvolvedIsls(it)) }", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0MzEzMg==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510943132", "bodyText": "thx, refactored", "author": "andriidovhan", "createdAt": "2020-10-23T14:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3NzAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3ODUzOA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510778538", "bodyText": "I think it makes sense to check that loop rules are indeed still present on the switch", "author": "rtretyak", "createdAt": "2020-10-23T10:08:02Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 0\n+                                 destination.vlanId = 0\n+                             }\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { allocateProtectedPath = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { encapsulationType = FlowEncapsulationType.VXLAN } }\n+                 ],\n+                 [\n+                         flowDescription: \"qinq\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 10\n+                                 source.innerVlanId = 100\n+                                 destination.vlanId = 20\n+                                 destination.innerVlanId = 200\n+                             }\n+                         }\n+                 ]\n+        ]\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules\")\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Try to create flowLoop on the same switch again\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"No extra rules are not created\"\n+        //bug with rule\n+//        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+\n+        and: \"The switch is still valid\"\n+        //there is probably a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete flowLoop\"\n+        northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"FlowLoop is deleted\"\n+        with(northbound.getFlow(flow.flowId)) { !it.looped }\n+\n+        and: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules, can't delete flow\")\n+    @Tidy\n+    def \"Able to create flowLoop for a singleSwitchSinglePort flow\"() {\n+        given: \"An active singleSwitchSinglePort flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchSinglePortFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//      northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete the flow with created flowLoop\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        Set<Isl> altFlowIsls = []\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        allFlowPaths.findAll { it != flowPath }.each { altFlowIsls.addAll(pathHelper.getInvolvedIsls(it)) }\n+        def islToFail = flowIsls.find { !(it in altFlowIsls) && !(it.reversed in altFlowIsls) }\n+        antiflap.portDown(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+\n+        then: \"The flow was rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) != flowPath\n+        }\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is still created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0ODk1MA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510948950", "bodyText": "the step description is paraphrased", "author": "andriidovhan", "createdAt": "2020-10-23T15:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3ODUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4MTQ1OQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510781459", "bodyText": "exc2 strange name)", "author": "rtretyak", "createdAt": "2020-10-23T10:13:27Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 0\n+                                 destination.vlanId = 0\n+                             }\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { allocateProtectedPath = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { encapsulationType = FlowEncapsulationType.VXLAN } }\n+                 ],\n+                 [\n+                         flowDescription: \"qinq\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 10\n+                                 source.innerVlanId = 100\n+                                 destination.vlanId = 20\n+                                 destination.innerVlanId = 200\n+                             }\n+                         }\n+                 ]\n+        ]\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules\")\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Try to create flowLoop on the same switch again\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"No extra rules are not created\"\n+        //bug with rule\n+//        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+\n+        and: \"The switch is still valid\"\n+        //there is probably a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete flowLoop\"\n+        northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"FlowLoop is deleted\"\n+        with(northbound.getFlow(flow.flowId)) { !it.looped }\n+\n+        and: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules, can't delete flow\")\n+    @Tidy\n+    def \"Able to create flowLoop for a singleSwitchSinglePort flow\"() {\n+        given: \"An active singleSwitchSinglePort flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchSinglePortFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//      northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete the flow with created flowLoop\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        Set<Isl> altFlowIsls = []\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        allFlowPaths.findAll { it != flowPath }.each { altFlowIsls.addAll(pathHelper.getInvolvedIsls(it)) }\n+        def islToFail = flowIsls.find { !(it in altFlowIsls) && !(it.reversed in altFlowIsls) }\n+        antiflap.portDown(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+\n+        then: \"The flow was rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) != flowPath\n+        }\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is still created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        cleanup: \"Revive the ISL back (bring switch port up) and delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        islToFail && antiflap.portUp(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Ignore(\"wait fix for switchValidation/ sycnSwitch missing flowLoop rules\")\n+    @Tidy\n+    def \"System is able to detect and sync missing flowLoop rules\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        def flowLoopRules\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            flowLoopRules = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }*.cookie\n+            assert flowLoopRules.size() == 2\n+        }\n+\n+        when: \"Delete flowLoop rules\"\n+        flowLoopRules.each { northbound.deleteSwitchRules(switchPair.src.dpId, it) }\n+\n+        then: \"System detects missing flowLoop rules\"\n+        assert northbound.validateSwitch(switchPair.src.dpId).rules.missing.sort() == flowLoopRules.sort()\n+\n+        when: \"Sync the src switch\"\n+        def syncResponse = northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+        then: \"Sync response contains flowLoop rules into the installed section\"\n+        assert syncResponse.rules.installed.sort() == flowLoopRules.sort()\n+\n+        then: \"FlowLoop rules are synced\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.size() == 2\n+        assert northbound.validateSwitch(switchPair.src.dpId).rules.missing.empty\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop when a switch is deactivated\"() {\n+        given: \"An active flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Deactivated the src switch\"\n+        def blockData = switchHelper.knockoutSwitch(switchPair.src, RW)\n+\n+        when: \"Try to create flowLoop on th src switch(deactivated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        and: \"FlowLoop is not created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+        }\n+\n+        when: \"Try to create flowLoop on th dst switch(activated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"Human readable error is returned\" //system can't update the flow when it is down\n+        def exc2 = thrown(HttpClientErrorException)\n+        exc2.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc2.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        then: \"FlowLoop is not created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.empty\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        switchHelper.reviveSwitch(switchPair.src, blockData, true)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on the src switch when it is already created on the dst switch\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        when: \"Try to create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is not created on the dst switch\"\n+        def exc2 = thrown(HttpClientErrorException)", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYwNTUxOQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r512605519", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-10-27T11:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4MTQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4MzcwNw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510783707", "bodyText": "Fine for now, but keep in mind that we have a smaller amount of switches on stage now, and may want to pick neighboring and manipulate flow path via costs at some point. This sound like a separate task, we may want some easier tools for that to hide such code from every test in the future", "author": "rtretyak", "createdAt": "2020-10-23T10:17:35Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 0\n+                                 destination.vlanId = 0\n+                             }\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { allocateProtectedPath = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { encapsulationType = FlowEncapsulationType.VXLAN } }\n+                 ],\n+                 [\n+                         flowDescription: \"qinq\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 10\n+                                 source.innerVlanId = 100\n+                                 destination.vlanId = 20\n+                                 destination.innerVlanId = 200\n+                             }\n+                         }\n+                 ]\n+        ]\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules\")\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Try to create flowLoop on the same switch again\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"No extra rules are not created\"\n+        //bug with rule\n+//        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+\n+        and: \"The switch is still valid\"\n+        //there is probably a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete flowLoop\"\n+        northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"FlowLoop is deleted\"\n+        with(northbound.getFlow(flow.flowId)) { !it.looped }\n+\n+        and: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules, can't delete flow\")\n+    @Tidy\n+    def \"Able to create flowLoop for a singleSwitchSinglePort flow\"() {\n+        given: \"An active singleSwitchSinglePort flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchSinglePortFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//      northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete the flow with created flowLoop\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        Set<Isl> altFlowIsls = []\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        allFlowPaths.findAll { it != flowPath }.each { altFlowIsls.addAll(pathHelper.getInvolvedIsls(it)) }\n+        def islToFail = flowIsls.find { !(it in altFlowIsls) && !(it.reversed in altFlowIsls) }\n+        antiflap.portDown(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+\n+        then: \"The flow was rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) != flowPath\n+        }\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is still created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        cleanup: \"Revive the ISL back (bring switch port up) and delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        islToFail && antiflap.portUp(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Ignore(\"wait fix for switchValidation/ sycnSwitch missing flowLoop rules\")\n+    @Tidy\n+    def \"System is able to detect and sync missing flowLoop rules\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        def flowLoopRules\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            flowLoopRules = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }*.cookie\n+            assert flowLoopRules.size() == 2\n+        }\n+\n+        when: \"Delete flowLoop rules\"\n+        flowLoopRules.each { northbound.deleteSwitchRules(switchPair.src.dpId, it) }\n+\n+        then: \"System detects missing flowLoop rules\"\n+        assert northbound.validateSwitch(switchPair.src.dpId).rules.missing.sort() == flowLoopRules.sort()\n+\n+        when: \"Sync the src switch\"\n+        def syncResponse = northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+        then: \"Sync response contains flowLoop rules into the installed section\"\n+        assert syncResponse.rules.installed.sort() == flowLoopRules.sort()\n+\n+        then: \"FlowLoop rules are synced\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.size() == 2\n+        assert northbound.validateSwitch(switchPair.src.dpId).rules.missing.empty\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop when a switch is deactivated\"() {\n+        given: \"An active flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Deactivated the src switch\"\n+        def blockData = switchHelper.knockoutSwitch(switchPair.src, RW)\n+\n+        when: \"Try to create flowLoop on th src switch(deactivated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        and: \"FlowLoop is not created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+        }\n+\n+        when: \"Try to create flowLoop on th dst switch(activated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"Human readable error is returned\" //system can't update the flow when it is down\n+        def exc2 = thrown(HttpClientErrorException)\n+        exc2.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc2.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        then: \"FlowLoop is not created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.empty\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        switchHelper.reviveSwitch(switchPair.src, blockData, true)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on the src switch when it is already created on the dst switch\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        when: \"Try to create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is not created on the dst switch\"\n+        def exc2 = thrown(HttpClientErrorException)\n+        exc2.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc2.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on a transit switch\"() {\n+        given: \"An active multi switch flow with transit switch\"\n+        def switchPair = topologyHelper.getNotNeighboringSwitchPair()", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NTQwNw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510785407", "bodyText": "not an accurate way to pick a vxlan-enabled switch. Use switch features instead of manufacturer. Or even supported transit encapsulation, since it can support vxlan, but vxlan can be turned off", "author": "rtretyak", "createdAt": "2020-10-23T10:20:40Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 0\n+                                 destination.vlanId = 0\n+                             }\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { allocateProtectedPath = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { encapsulationType = FlowEncapsulationType.VXLAN } }\n+                 ],\n+                 [\n+                         flowDescription: \"qinq\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 10\n+                                 source.innerVlanId = 100\n+                                 destination.vlanId = 20\n+                                 destination.innerVlanId = 200\n+                             }\n+                         }\n+                 ]\n+        ]\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules\")\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Try to create flowLoop on the same switch again\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"No extra rules are not created\"\n+        //bug with rule\n+//        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+\n+        and: \"The switch is still valid\"\n+        //there is probably a bug, flow_loop is in excess\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete flowLoop\"\n+        northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"FlowLoop is deleted\"\n+        with(northbound.getFlow(flow.flowId)) { !it.looped }\n+\n+        and: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Ignore(\"wait for fix, no flowLoop rules, can't delete flow\")\n+    @Tidy\n+    def \"Able to create flowLoop for a singleSwitchSinglePort flow\"() {\n+        given: \"An active singleSwitchSinglePort flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchSinglePortFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        //bug\n+//    Wrappers.wait(RULES_INSTALLATION_TIME) {\n+//        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }.size() == 2\n+//    }\n+\n+        and: \"The switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//      northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Delete the flow with created flowLoop\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted on the switch\"\n+        assert northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        Set<Isl> altFlowIsls = []\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        allFlowPaths.findAll { it != flowPath }.each { altFlowIsls.addAll(pathHelper.getInvolvedIsls(it)) }\n+        def islToFail = flowIsls.find { !(it in altFlowIsls) && !(it.reversed in altFlowIsls) }\n+        antiflap.portDown(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+\n+        then: \"The flow was rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) != flowPath\n+        }\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is still created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        cleanup: \"Revive the ISL back (bring switch port up) and delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        islToFail && antiflap.portUp(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Ignore(\"wait fix for switchValidation/ sycnSwitch missing flowLoop rules\")\n+    @Tidy\n+    def \"System is able to detect and sync missing flowLoop rules\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        def flowLoopRules\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            flowLoopRules = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }*.cookie\n+            assert flowLoopRules.size() == 2\n+        }\n+\n+        when: \"Delete flowLoop rules\"\n+        flowLoopRules.each { northbound.deleteSwitchRules(switchPair.src.dpId, it) }\n+\n+        then: \"System detects missing flowLoop rules\"\n+        assert northbound.validateSwitch(switchPair.src.dpId).rules.missing.sort() == flowLoopRules.sort()\n+\n+        when: \"Sync the src switch\"\n+        def syncResponse = northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+        then: \"Sync response contains flowLoop rules into the installed section\"\n+        assert syncResponse.rules.installed.sort() == flowLoopRules.sort()\n+\n+        then: \"FlowLoop rules are synced\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.size() == 2\n+        assert northbound.validateSwitch(switchPair.src.dpId).rules.missing.empty\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop when a switch is deactivated\"() {\n+        given: \"An active flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Deactivated the src switch\"\n+        def blockData = switchHelper.knockoutSwitch(switchPair.src, RW)\n+\n+        when: \"Try to create flowLoop on th src switch(deactivated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        and: \"FlowLoop is not created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+        }\n+\n+        when: \"Try to create flowLoop on th dst switch(activated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"Human readable error is returned\" //system can't update the flow when it is down\n+        def exc2 = thrown(HttpClientErrorException)\n+        exc2.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc2.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        then: \"FlowLoop is not created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.empty\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        switchHelper.reviveSwitch(switchPair.src, blockData, true)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on the src switch when it is already created on the dst switch\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        when: \"Try to create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is not created on the dst switch\"\n+        def exc2 = thrown(HttpClientErrorException)\n+        exc2.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc2.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on a transit switch\"() {\n+        given: \"An active multi switch flow with transit switch\"\n+        def switchPair = topologyHelper.getNotNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def transitSwId = PathHelper.convert(northbound.getFlowPath(flow.flowId))[1].switchId\n+\n+        when: \"Try to create flowLoop on the transit switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(transitSwId))\n+\n+        then: \"Human readable error is returned\" //system can't update the flow when it is down\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Loop switch is not terminating in flow path\"\n+        }\n+\n+        then: \"FlowLoop is not created\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(transitSwId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.empty\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    def \"getSwPairConnectedToTraffGenForSimpleFlow\"(List<SwitchId> switchIds) {\n+        getTopologyHelper().getAllNeighboringSwitchPairs().find {\n+            [it.dst, it.src].every { it.dpId in switchIds }\n+        }\n+    }\n+\n+    def \"getSwPairConnectedToTraffGenForProtectedFlow\"(List<SwitchId> switchIds) {\n+        getTopologyHelper().getAllNeighboringSwitchPairs().find {\n+            [it.dst, it.src].every { it.dpId in switchIds } && it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+    }\n+\n+    def \"getSwPairConnectedToTraffGenForVxlanFlow\"(List<SwitchId> switchIds) {\n+        getTopologyHelper().getAllNeighboringSwitchPairs().find {\n+            [it.dst, it.src].every { it.dpId in switchIds && it.noviflow && !it.wb5164 }", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgyNzk1MA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r512827950", "bodyText": "agree, fixed", "author": "andriidovhan", "createdAt": "2020-10-27T16:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NTQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5MDAxMg==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510790012", "bodyText": "I'm pretty sure you have no idea what have happened right now. Especially when you swapped dst1<->dst2. So the flow loop is still assigned to flow1, but did the system reinstall the rules according to the new dst2 endpoint? I have no idea, neither this test. This will be very visible if dst1 and dst2 are located on different switches. I have no certainty how swap will work in this case and what will happen with the loop and flows.", "author": "rtretyak", "createdAt": "2020-10-23T10:29:17Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/SwapEndpointSpec.groovy", "diffHunk": "@@ -1373,6 +1376,66 @@ switches\"() {\n         !isSwitchValid && switches.each { northbound.synchronizeSwitch(it, true)}\n     }\n \n+    @Tidy\n+    @Unroll\n+    def \"Able to swap endpoints for a flow with flowLoop \"() {\n+        given: \"Two flows with the same source and destination switches\"\n+        flowHelper.addFlow(flow1)\n+        flowHelper.addFlow(flow2)\n+\n+        and: \"FlowLoop is created for the first flow on the dst switch\"\n+        northboundV2.createFlowLoop(flow1.id, new FlowLoopPayload(switchPair.dst.dpId))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow1.id).status == FlowState.UP\n+        }\n+\n+        when: \"Try to swap endpoints for flows\"\n+        def response = northbound.swapFlowEndpoint(\n+                new SwapFlowPayload(flow1.id, flowHelper.toFlowEndpointV2(flow1Src),\n+                        flowHelper.toFlowEndpointV2(flow1Dst)),\n+                new SwapFlowPayload(flow2.id, flowHelper.toFlowEndpointV2(flow2Src),\n+                        flowHelper.toFlowEndpointV2(flow2Dst)))\n+\n+        then: \"Endpoints are successfully swapped\"\n+        verifyEndpoints(response, flow1Src, flow1Dst, flow2Src, flow2Dst)\n+        verifyEndpoints(flow1.id, flow2.id, flow1Src, flow1Dst, flow2Src, flow2Dst)\n+\n+        and: \"FlowLoop is still created\"", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ0MTc4MA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r513441780", "bodyText": "refactored", "author": "andriidovhan", "createdAt": "2020-10-28T13:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5MDAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5MTI1NA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510791254", "bodyText": "above three endpoints are not covered in tests", "author": "rtretyak", "createdAt": "2020-10-23T10:31:39Z", "path": "src-java/testing/test-library/src/main/java/org/openkilda/testing/service/northbound/NorthboundServiceV2.java", "diffHunk": "@@ -51,6 +53,16 @@\n \n     FlowResponseV2 partialUpdate(String flowId, FlowPatchV2 patch);\n \n+    FlowLoopResponse getFlowLoop(String flowId);\n+\n+    FlowLoopResponse getFlowLoop(SwitchId switchId);\n+\n+    FlowLoopResponse getFlowLoop(String flowId, SwitchId switchId);", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3NDcxMg==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r512774712", "bodyText": "good catch, fixed", "author": "andriidovhan", "createdAt": "2020-10-27T15:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5MTI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5NjQxMw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r510796413", "bodyText": "I think interaction with protected flows is not fully revealed here. What happens when main path breaks and flow path falls to protected?", "author": "rtretyak", "createdAt": "2020-10-23T10:42:14Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.*\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        data.flow(flow)\n+        flowHelperV2.addFlow(flow)\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.src.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().each { it == 0 }\n+        }\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+//    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        when: \"Ping the flow\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        then: \"Counter on the flowLoop rules are increased\"\n+        //counter is not increased, wait verification for dev\n+//        northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+//            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+//        }*.packetCount.each { assert it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        assert deleteResponse.flowId == flow.flowId  //actually it contains switchId: null, should be removed by dev\n+\n+        and: \"FlowLoop is really deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            !it.looped\n+            !it.loopSwitchId\n+        }\n+\n+        and: \"FlowLoop rules are deleted on the src switch\"\n+        assert northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"Flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        //there is a bug, no flow_loop info in getFlowV2\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.looped\n+            it.loopSwitchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+            }.size() == 2\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"FlowLoop rules are deleted on the dst switch\"\n+        assert northbound.getSwitchRules(switchPair.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.FLOW_LOOP\n+        }.empty\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        if (!testIsCompleted) {\n+            flowHelperV2.deleteFlow(flow.flowId)\n+            [switchPair.src.dpId, switchPair.dst.dpId].each {\n+                northbound.synchronizeSwitch(it, true)\n+            }\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl -> fl.tap { pinned = true } }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flow           : { FlowRequestV2 fl ->\n+                             fl.tap {\n+                                 source.vlanId = 0\n+                                 destination.vlanId = 0\n+                             }\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)", "originalCommit": "83ba9085f8127bda8df3ac103df5f65726abdf0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgyMTU3MQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r512821571", "bodyText": "added separate test( \"System is able to autoSwapPath for a protected flow when flowLoop is created on it\")", "author": "andriidovhan", "createdAt": "2020-10-27T16:02:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5NjQxMw=="}], "type": "inlineReview"}, {"oid": "74663491a2dbc6e8019379d73df2bf55a48c4b86", "url": "https://github.com/telstra/open-kilda/commit/74663491a2dbc6e8019379d73df2bf55a48c4b86", "message": "add tests for flowLoop", "committedDate": "2020-10-28T13:28:12Z", "type": "forcePushed"}, {"oid": "6abe68894bfed1c60e5dd4f810270c3fa0bdc20e", "url": "https://github.com/telstra/open-kilda/commit/6abe68894bfed1c60e5dd4f810270c3fa0bdc20e", "message": "add tests for flowLoop", "committedDate": "2020-10-30T14:31:18Z", "type": "forcePushed"}, {"oid": "a2fc5d9b360e1505b5ec51c2df698538ce8ead57", "url": "https://github.com/telstra/open-kilda/commit/a2fc5d9b360e1505b5ec51c2df698538ce8ead57", "message": "add tests for flowLoop", "committedDate": "2020-10-30T14:34:33Z", "type": "forcePushed"}, {"oid": "486165ad044e59f1afaf9b303a4363514b61b9ee", "url": "https://github.com/telstra/open-kilda/commit/486165ad044e59f1afaf9b303a4363514b61b9ee", "message": "add tests for flowLoop", "committedDate": "2020-11-10T11:32:07Z", "type": "forcePushed"}, {"oid": "a92604c06050564e422ca346ef43ff6e7bc1e825", "url": "https://github.com/telstra/open-kilda/commit/a92604c06050564e422ca346ef43ff6e7bc1e825", "message": "add tests for flowLoop", "committedDate": "2020-11-10T15:27:36Z", "type": "forcePushed"}, {"oid": "b16c02e23a0679b8e20ab04d335368dbb3621cea", "url": "https://github.com/telstra/open-kilda/commit/b16c02e23a0679b8e20ab04d335368dbb3621cea", "message": "add tests for flowLoop", "committedDate": "2020-11-11T08:59:38Z", "type": "forcePushed"}, {"oid": "32b676d13bec7f015cee68c389691c84f2a896af", "url": "https://github.com/telstra/open-kilda/commit/32b676d13bec7f015cee68c389691c84f2a896af", "message": "add tests for flowLoop", "committedDate": "2020-11-11T09:44:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQzNzQ1Mw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521437453", "bodyText": "This construction is weird. Map is not really required here. just get rules, check size, check their packet count", "author": "rtretyak", "createdAt": "2020-11-11T15:28:13Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,772 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n+import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.PROTECTED_PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.NON_EXISTENT_FLOW_ID\n+import static org.openkilda.testing.Constants.NON_EXISTENT_SWITCH_ID\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import org.springframework.web.client.HttpServerErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.tap(data.flowTap)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"FlowLoop rules are created on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzOTY5NA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521939694", "bodyText": "agree, fixed", "author": "andriidovhan", "createdAt": "2020-11-12T08:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQzNzQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0MTI5MQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521441291", "bodyText": "is increased", "author": "rtretyak", "createdAt": "2020-11-11T15:33:24Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,772 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n+import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.PROTECTED_PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.NON_EXISTENT_FLOW_ID\n+import static org.openkilda.testing.Constants.NON_EXISTENT_SWITCH_ID\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import org.springframework.web.client.HttpServerErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.tap(data.flowTap)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"FlowLoop rules are created on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk0MTExMQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521941111", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-11-12T08:58:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0MTI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0MzI2Mg==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521443262", "bodyText": "other real flow rules should have exactly a double packet count from what is shown on the loop rule, right? Another indirect way to understand that we have a real loop", "author": "rtretyak", "createdAt": "2020-11-11T15:35:58Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,772 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n+import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.PROTECTED_PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.NON_EXISTENT_FLOW_ID\n+import static org.openkilda.testing.Constants.NON_EXISTENT_SWITCH_ID\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import org.springframework.web.client.HttpServerErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.tap(data.flowTap)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"FlowLoop rules are created on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MTEzOA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r522071138", "bodyText": "great idea,\nadded extra verification\nin our case, the packet count for simple(ingress/egreess) flow rules will be equal to zero, because the flowLoop rules have higher priority than simple flow rules", "author": "andriidovhan", "createdAt": "2020-11-12T12:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0MzI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE1MDk3Ng==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r522150976", "bodyText": "no counters on egress/ingress is only acceptable on the short side of the loop.\nlonger side:\nSW1-ingress -> SW2fw_transit -> SW3loop -> SW2rv_transit -> SW1 - egress", "author": "rtretyak", "createdAt": "2020-11-12T14:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0MzI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQzODk1OQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r522438959", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-11-12T21:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0MzI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0NzAxMA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521447010", "bodyText": "assert", "author": "rtretyak", "createdAt": "2020-11-11T15:41:16Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,772 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n+import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.PROTECTED_PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.NON_EXISTENT_FLOW_ID\n+import static org.openkilda.testing.Constants.NON_EXISTENT_SWITCH_ID\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import org.springframework.web.client.HttpServerErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.tap(data.flowTap)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"FlowLoop rules are created on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        deleteResponse.flowId == flow.flowId\n+\n+        and: \"FlowLoop is really deleted\"\n+        !northboundV2.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop rules are deleted from the src switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).empty\n+        }\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def switchIsValid = true\n+\n+        and: \"Flow allows traffic\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        cleanup: \"Delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !switchIsValid && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.pinned = true }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl ->\n+                             fl.source.vlanId = 0\n+                             fl.destination.vlanId = 0\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.allocateProtectedPath = true }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.encapsulationType = FlowEncapsulationType.VXLAN }\n+                 ],\n+                 //\"Loop for Q-in-Q flows is not implemented\"\n+//                 [\n+//                         flowDescription: \"qinq\",\n+//                         switchPair     : { List<SwitchId> switchIds ->\n+//                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+//                         },\n+//                         flowTap        : { FlowRequestV2 fl ->\n+//                             fl.source.vlanId = 10\n+//                             fl.source.innerVlanId = 100\n+//                             fl.destination.vlanId = 20\n+//                             fl.destination.innerVlanId = 200\n+//                         }\n+//                 ]\n+        ]\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to delete a flow with created flowLoop on it\"() {\n+        given: \"A active multi switch flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId, switchPair.dst.dpId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+        }\n+\n+        and: \"Flow history contains info about flowLoop\"\n+        def flowHistory = northbound.getFlowHistory(flow.flowId).last()\n+        !flowHistory.dumps.find { it.type == \"stateBefore\" }.loopSwitchId\n+        flowHistory.dumps.find { it.type == \"stateAfter\" }.loopSwitchId == switchPair.dst.dpId\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted from the dst switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).empty\n+        }\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        flow && !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId)\n+        flowLoopOnSwitch.size() == 1", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk0MzY1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521943652", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-11-12T09:02:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ0NzAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ1MjAyNw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521452027", "bodyText": "I think the loop consistency should be verified after reroute. Especially if the actual loop rule should be changed to catch from some other isl or if transit vlan changes (not sure if it automatically changes after reroute).", "author": "rtretyak", "createdAt": "2020-11-11T15:48:26Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,772 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n+import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.PROTECTED_PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.NON_EXISTENT_FLOW_ID\n+import static org.openkilda.testing.Constants.NON_EXISTENT_SWITCH_ID\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import org.springframework.web.client.HttpServerErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.tap(data.flowTap)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"FlowLoop rules are created on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        deleteResponse.flowId == flow.flowId\n+\n+        and: \"FlowLoop is really deleted\"\n+        !northboundV2.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop rules are deleted from the src switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).empty\n+        }\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def switchIsValid = true\n+\n+        and: \"Flow allows traffic\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        cleanup: \"Delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !switchIsValid && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.pinned = true }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl ->\n+                             fl.source.vlanId = 0\n+                             fl.destination.vlanId = 0\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.allocateProtectedPath = true }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.encapsulationType = FlowEncapsulationType.VXLAN }\n+                 ],\n+                 //\"Loop for Q-in-Q flows is not implemented\"\n+//                 [\n+//                         flowDescription: \"qinq\",\n+//                         switchPair     : { List<SwitchId> switchIds ->\n+//                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+//                         },\n+//                         flowTap        : { FlowRequestV2 fl ->\n+//                             fl.source.vlanId = 10\n+//                             fl.source.innerVlanId = 100\n+//                             fl.destination.vlanId = 20\n+//                             fl.destination.innerVlanId = 200\n+//                         }\n+//                 ]\n+        ]\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to delete a flow with created flowLoop on it\"() {\n+        given: \"A active multi switch flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId, switchPair.dst.dpId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+        }\n+\n+        and: \"Flow history contains info about flowLoop\"\n+        def flowHistory = northbound.getFlowHistory(flow.flowId).last()\n+        !flowHistory.dumps.find { it.type == \"stateBefore\" }.loopSwitchId\n+        flowHistory.dumps.find { it.type == \"stateAfter\" }.loopSwitchId == switchPair.dst.dpId\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted from the dst switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).empty\n+        }\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        flow && !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        Set<Isl> altFlowIsls = allFlowPaths.findAll { it != flowPath }.collectMany { pathHelper.getInvolvedIsls(it) }\n+        def islToFail = flowIsls.find { !(it in altFlowIsls) }\n+        antiflap.portDown(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+\n+        then: \"The flow was rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) != flowPath\n+        }\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is still present on the dst switch\"\n+        northboundV2.getFlow(flow.flowId).loopSwitchId == switchPair.dst.dpId\n+\n+        and: \"FlowLoop rules ar still present on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAyNDY1Ng==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r522024656", "bodyText": "added extra verification", "author": "andriidovhan", "createdAt": "2020-11-12T11:09:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ1MjAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2MTk2OA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521461968", "bodyText": "Is it possible to just topologyHelper.getSwitchPairs().find?", "author": "rtretyak", "createdAt": "2020-11-11T16:02:42Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,772 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n+import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.PROTECTED_PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.NON_EXISTENT_FLOW_ID\n+import static org.openkilda.testing.Constants.NON_EXISTENT_SWITCH_ID\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import org.springframework.web.client.HttpServerErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.tap(data.flowTap)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"FlowLoop rules are created on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        deleteResponse.flowId == flow.flowId\n+\n+        and: \"FlowLoop is really deleted\"\n+        !northboundV2.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop rules are deleted from the src switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).empty\n+        }\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def switchIsValid = true\n+\n+        and: \"Flow allows traffic\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        cleanup: \"Delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !switchIsValid && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.pinned = true }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl ->\n+                             fl.source.vlanId = 0\n+                             fl.destination.vlanId = 0\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.allocateProtectedPath = true }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.encapsulationType = FlowEncapsulationType.VXLAN }\n+                 ],\n+                 //\"Loop for Q-in-Q flows is not implemented\"\n+//                 [\n+//                         flowDescription: \"qinq\",\n+//                         switchPair     : { List<SwitchId> switchIds ->\n+//                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+//                         },\n+//                         flowTap        : { FlowRequestV2 fl ->\n+//                             fl.source.vlanId = 10\n+//                             fl.source.innerVlanId = 100\n+//                             fl.destination.vlanId = 20\n+//                             fl.destination.innerVlanId = 200\n+//                         }\n+//                 ]\n+        ]\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to delete a flow with created flowLoop on it\"() {\n+        given: \"A active multi switch flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId, switchPair.dst.dpId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+        }\n+\n+        and: \"Flow history contains info about flowLoop\"\n+        def flowHistory = northbound.getFlowHistory(flow.flowId).last()\n+        !flowHistory.dumps.find { it.type == \"stateBefore\" }.loopSwitchId\n+        flowHistory.dumps.find { it.type == \"stateAfter\" }.loopSwitchId == switchPair.dst.dpId\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted from the dst switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).empty\n+        }\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        flow && !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        Set<Isl> altFlowIsls = allFlowPaths.findAll { it != flowPath }.collectMany { pathHelper.getInvolvedIsls(it) }\n+        def islToFail = flowIsls.find { !(it in altFlowIsls) }\n+        antiflap.portDown(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+\n+        then: \"The flow was rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) != flowPath\n+        }\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is still present on the dst switch\"\n+        northboundV2.getFlow(flow.flowId).loopSwitchId == switchPair.dst.dpId\n+\n+        and: \"FlowLoop rules ar still present on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        cleanup: \"Revive the ISL back (bring switch port up) and delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        islToFail && antiflap.portUp(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System is able to detect and sync missing flowLoop rules\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        def flowLoopRules\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            flowLoopRules = getFlowLoopRules(switchPair.src.dpId)*.cookie\n+            assert flowLoopRules.size() == 2\n+        }\n+\n+        when: \"Delete flowLoop rules\"\n+        flowLoopRules.each { northbound.deleteSwitchRules(switchPair.src.dpId, it) }\n+\n+        then: \"System detects missing flowLoop rules\"\n+        northbound.validateSwitch(switchPair.src.dpId).rules.missing.sort() == flowLoopRules.sort()\n+\n+        when: \"Sync the src switch\"\n+        def syncResponse = northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+        then: \"Sync response contains flowLoop rules into the installed section\"\n+        syncResponse.rules.installed.sort() == flowLoopRules.sort()\n+\n+        then: \"FlowLoop rules are synced\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).size() == 2\n+        }\n+        northbound.validateSwitch(switchPair.src.dpId).rules.missing.empty\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Systems allows to get all flowLoops that goes through a switch\"() {\n+        given: \"Two active switches\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+\n+        and: \"Three multi switch flows\"\n+        def flow1 = flowHelperV2.randomFlow(switchPair)\n+        flow1.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow1)\n+\n+        def flow2 = flowHelperV2.randomFlow(switchPair, false, [flow1])\n+        flowHelperV2.addFlow(flow2)\n+\n+        def flow3 = flowHelperV2.randomFlow(switchPair, false, [flow1, flow2])\n+        flowHelperV2.addFlow(flow3)\n+\n+        when: \"Get all flowLoops from the src switch\"\n+        then: \"There is no flowLoop because it is not created yet\"\n+        northboundV2.getFlowLoop(switchPair.src.dpId).empty\n+\n+        when: \"Create flowLoop for flow1 and flow2 on the src switch\"\n+        northboundV2.createFlowLoop(flow1.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        northboundV2.createFlowLoop(flow2.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        and: \"Create flowLoop for the flow3 on the dst switch\"\n+        northboundV2.createFlowLoop(flow3.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        and: \"Get all flowLoops from the src switch\"\n+        def flowLoopSrcSw = northboundV2.getFlowLoop(switchPair.src.dpId)\n+\n+        then: \"The created flowLoops for flow1/flow2 are returned in the response list from the src switch\"\n+        flowLoopSrcSw.size() == 2\n+        flowLoopSrcSw*.flowId.sort() == [flow1, flow2]*.flowId.sort()\n+        flowLoopSrcSw*.switchId.unique() == [switchPair.src.dpId]\n+\n+        when: \"Get all flowLoops from the dst switch\"\n+        def flowLoopDstSw = northboundV2.getFlowLoop(switchPair.dst.dpId)\n+\n+        then: \"Only flow3 is in the response list from the dst switch\"\n+        flowLoopDstSw.size() == 1\n+        flowLoopDstSw[0].flowId == flow3.flowId\n+        flowLoopDstSw[0].switchId == switchPair.dst.dpId\n+\n+        cleanup: \"Delete the flows\"\n+        [flow1, flow2, flow3].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    @Tidy\n+    def \"System is able to autoSwapPath for a protected flow when flowLoop is created on it\"() {\n+        given: \"Two active switches with three diverse paths at least\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+\n+        def switchPair = topologyHelper.getAllNotNeighboringSwitchPairs().find {", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAwMzU1NA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r522003554", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-11-12T10:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2MTk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2NDM3Mw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521464373", "bodyText": "don't forget", "author": "rtretyak", "createdAt": "2020-11-11T16:06:21Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,772 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n+import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.PROTECTED_PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.NON_EXISTENT_FLOW_ID\n+import static org.openkilda.testing.Constants.NON_EXISTENT_SWITCH_ID\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import org.springframework.web.client.HttpServerErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.tap(data.flowTap)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"FlowLoop rules are created on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        deleteResponse.flowId == flow.flowId\n+\n+        and: \"FlowLoop is really deleted\"\n+        !northboundV2.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop rules are deleted from the src switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).empty\n+        }\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def switchIsValid = true\n+\n+        and: \"Flow allows traffic\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        cleanup: \"Delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !switchIsValid && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.pinned = true }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl ->\n+                             fl.source.vlanId = 0\n+                             fl.destination.vlanId = 0\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.allocateProtectedPath = true }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.encapsulationType = FlowEncapsulationType.VXLAN }\n+                 ],\n+                 //\"Loop for Q-in-Q flows is not implemented\"\n+//                 [\n+//                         flowDescription: \"qinq\",\n+//                         switchPair     : { List<SwitchId> switchIds ->\n+//                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+//                         },\n+//                         flowTap        : { FlowRequestV2 fl ->\n+//                             fl.source.vlanId = 10\n+//                             fl.source.innerVlanId = 100\n+//                             fl.destination.vlanId = 20\n+//                             fl.destination.innerVlanId = 200\n+//                         }\n+//                 ]\n+        ]\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to delete a flow with created flowLoop on it\"() {\n+        given: \"A active multi switch flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId, switchPair.dst.dpId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+        }\n+\n+        and: \"Flow history contains info about flowLoop\"\n+        def flowHistory = northbound.getFlowHistory(flow.flowId).last()\n+        !flowHistory.dumps.find { it.type == \"stateBefore\" }.loopSwitchId\n+        flowHistory.dumps.find { it.type == \"stateAfter\" }.loopSwitchId == switchPair.dst.dpId\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted from the dst switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).empty\n+        }\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        flow && !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        Set<Isl> altFlowIsls = allFlowPaths.findAll { it != flowPath }.collectMany { pathHelper.getInvolvedIsls(it) }\n+        def islToFail = flowIsls.find { !(it in altFlowIsls) }\n+        antiflap.portDown(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+\n+        then: \"The flow was rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) != flowPath\n+        }\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is still present on the dst switch\"\n+        northboundV2.getFlow(flow.flowId).loopSwitchId == switchPair.dst.dpId\n+\n+        and: \"FlowLoop rules ar still present on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        cleanup: \"Revive the ISL back (bring switch port up) and delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        islToFail && antiflap.portUp(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System is able to detect and sync missing flowLoop rules\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        def flowLoopRules\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            flowLoopRules = getFlowLoopRules(switchPair.src.dpId)*.cookie\n+            assert flowLoopRules.size() == 2\n+        }\n+\n+        when: \"Delete flowLoop rules\"\n+        flowLoopRules.each { northbound.deleteSwitchRules(switchPair.src.dpId, it) }\n+\n+        then: \"System detects missing flowLoop rules\"\n+        northbound.validateSwitch(switchPair.src.dpId).rules.missing.sort() == flowLoopRules.sort()\n+\n+        when: \"Sync the src switch\"\n+        def syncResponse = northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+        then: \"Sync response contains flowLoop rules into the installed section\"\n+        syncResponse.rules.installed.sort() == flowLoopRules.sort()\n+\n+        then: \"FlowLoop rules are synced\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).size() == 2\n+        }\n+        northbound.validateSwitch(switchPair.src.dpId).rules.missing.empty\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Systems allows to get all flowLoops that goes through a switch\"() {\n+        given: \"Two active switches\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+\n+        and: \"Three multi switch flows\"\n+        def flow1 = flowHelperV2.randomFlow(switchPair)\n+        flow1.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow1)\n+\n+        def flow2 = flowHelperV2.randomFlow(switchPair, false, [flow1])\n+        flowHelperV2.addFlow(flow2)\n+\n+        def flow3 = flowHelperV2.randomFlow(switchPair, false, [flow1, flow2])\n+        flowHelperV2.addFlow(flow3)\n+\n+        when: \"Get all flowLoops from the src switch\"\n+        then: \"There is no flowLoop because it is not created yet\"\n+        northboundV2.getFlowLoop(switchPair.src.dpId).empty\n+\n+        when: \"Create flowLoop for flow1 and flow2 on the src switch\"\n+        northboundV2.createFlowLoop(flow1.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        northboundV2.createFlowLoop(flow2.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        and: \"Create flowLoop for the flow3 on the dst switch\"\n+        northboundV2.createFlowLoop(flow3.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        and: \"Get all flowLoops from the src switch\"\n+        def flowLoopSrcSw = northboundV2.getFlowLoop(switchPair.src.dpId)\n+\n+        then: \"The created flowLoops for flow1/flow2 are returned in the response list from the src switch\"\n+        flowLoopSrcSw.size() == 2\n+        flowLoopSrcSw*.flowId.sort() == [flow1, flow2]*.flowId.sort()\n+        flowLoopSrcSw*.switchId.unique() == [switchPair.src.dpId]\n+\n+        when: \"Get all flowLoops from the dst switch\"\n+        def flowLoopDstSw = northboundV2.getFlowLoop(switchPair.dst.dpId)\n+\n+        then: \"Only flow3 is in the response list from the dst switch\"\n+        flowLoopDstSw.size() == 1\n+        flowLoopDstSw[0].flowId == flow3.flowId\n+        flowLoopDstSw[0].switchId == switchPair.dst.dpId\n+\n+        cleanup: \"Delete the flows\"\n+        [flow1, flow2, flow3].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    @Tidy\n+    def \"System is able to autoSwapPath for a protected flow when flowLoop is created on it\"() {\n+        given: \"Two active switches with three diverse paths at least\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+\n+        def switchPair = topologyHelper.getAllNotNeighboringSwitchPairs().find {\n+            [it.dst, it.src].every { it.dpId in allTraffGenSwIds } && it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+\n+        and: \"A protected unmetered flow with flowLoop on the src switch\"\n+        def flow = flowHelperV2.randomFlow(switchPair).tap {\n+            maximumBandwidth = 0\n+            ignoreBandwidth = true\n+            allocateProtectedPath = true\n+        }\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        when: \"Break ISL on the main path (bring port down) to init auto swap\"\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        def currentPath = pathHelper.convert(flowPathInfo)\n+        def currentProtectedPath = pathHelper.convert(flowPathInfo.protectedPath)\n+        def islToBreak = pathHelper.getInvolvedIsls(currentPath)[0]\n+        antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        def portIsDown = true\n+\n+        then: \"Flow is switched to protected path\"\n+        Wrappers.wait(PROTECTED_PATH_INSTALLATION_TIME) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+            assert pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentProtectedPath\n+        }\n+\n+        and: \"FlowLoop is still present on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        //    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"FlowLoop rules are still exist on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        cleanup: \"Revert system to original state\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        if (!portIsDown) {\n+            antiflap.portUp(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+            Wrappers.wait(WAIT_OFFSET + discoveryInterval) {\n+                assert islUtils.getIslInfo(islToBreak).get().state == IslChangeType.DISCOVERED\n+            }\n+        }\n+        database.resetCosts()\n+    }\n+\n+    def \"Unable to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpServerErrorException)\n+        exc.statusCode == HttpStatus.NOT_IMPLEMENTED\n+        def errorDetails = exc.responseBodyAsString.to(MessageError)\n+        errorDetails.errorMessage == \"Could not update flow\"\n+        errorDetails.errorDescription == \"Loop for single switch flows is not implemented\"\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop for a QinQ flow\"() {\n+        given: \"An active QinQ flow\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"Not able to find enough switches in multi-table mode\", false)\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(swP.src.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpServerErrorException) //bug TODO: create an issue", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk2MTQwNg==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521961406", "bodyText": "added", "author": "andriidovhan", "createdAt": "2020-11-12T09:30:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2NDM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2NTUwNg==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521465506", "bodyText": "\"Unable to create flowLoop both on src and dst at the same time\" describes it better", "author": "rtretyak", "createdAt": "2020-11-11T16:07:58Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,772 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n+import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.PROTECTED_PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.NON_EXISTENT_FLOW_ID\n+import static org.openkilda.testing.Constants.NON_EXISTENT_SWITCH_ID\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import org.springframework.web.client.HttpServerErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.tap(data.flowTap)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"FlowLoop rules are created on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        deleteResponse.flowId == flow.flowId\n+\n+        and: \"FlowLoop is really deleted\"\n+        !northboundV2.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop rules are deleted from the src switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).empty\n+        }\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def switchIsValid = true\n+\n+        and: \"Flow allows traffic\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        cleanup: \"Delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !switchIsValid && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.pinned = true }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl ->\n+                             fl.source.vlanId = 0\n+                             fl.destination.vlanId = 0\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.allocateProtectedPath = true }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.encapsulationType = FlowEncapsulationType.VXLAN }\n+                 ],\n+                 //\"Loop for Q-in-Q flows is not implemented\"\n+//                 [\n+//                         flowDescription: \"qinq\",\n+//                         switchPair     : { List<SwitchId> switchIds ->\n+//                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+//                         },\n+//                         flowTap        : { FlowRequestV2 fl ->\n+//                             fl.source.vlanId = 10\n+//                             fl.source.innerVlanId = 100\n+//                             fl.destination.vlanId = 20\n+//                             fl.destination.innerVlanId = 200\n+//                         }\n+//                 ]\n+        ]\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to delete a flow with created flowLoop on it\"() {\n+        given: \"A active multi switch flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId, switchPair.dst.dpId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+        }\n+\n+        and: \"Flow history contains info about flowLoop\"\n+        def flowHistory = northbound.getFlowHistory(flow.flowId).last()\n+        !flowHistory.dumps.find { it.type == \"stateBefore\" }.loopSwitchId\n+        flowHistory.dumps.find { it.type == \"stateAfter\" }.loopSwitchId == switchPair.dst.dpId\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted from the dst switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).empty\n+        }\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        flow && !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        Set<Isl> altFlowIsls = allFlowPaths.findAll { it != flowPath }.collectMany { pathHelper.getInvolvedIsls(it) }\n+        def islToFail = flowIsls.find { !(it in altFlowIsls) }\n+        antiflap.portDown(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+\n+        then: \"The flow was rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) != flowPath\n+        }\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is still present on the dst switch\"\n+        northboundV2.getFlow(flow.flowId).loopSwitchId == switchPair.dst.dpId\n+\n+        and: \"FlowLoop rules ar still present on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        cleanup: \"Revive the ISL back (bring switch port up) and delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        islToFail && antiflap.portUp(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System is able to detect and sync missing flowLoop rules\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        def flowLoopRules\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            flowLoopRules = getFlowLoopRules(switchPair.src.dpId)*.cookie\n+            assert flowLoopRules.size() == 2\n+        }\n+\n+        when: \"Delete flowLoop rules\"\n+        flowLoopRules.each { northbound.deleteSwitchRules(switchPair.src.dpId, it) }\n+\n+        then: \"System detects missing flowLoop rules\"\n+        northbound.validateSwitch(switchPair.src.dpId).rules.missing.sort() == flowLoopRules.sort()\n+\n+        when: \"Sync the src switch\"\n+        def syncResponse = northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+        then: \"Sync response contains flowLoop rules into the installed section\"\n+        syncResponse.rules.installed.sort() == flowLoopRules.sort()\n+\n+        then: \"FlowLoop rules are synced\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).size() == 2\n+        }\n+        northbound.validateSwitch(switchPair.src.dpId).rules.missing.empty\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Systems allows to get all flowLoops that goes through a switch\"() {\n+        given: \"Two active switches\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+\n+        and: \"Three multi switch flows\"\n+        def flow1 = flowHelperV2.randomFlow(switchPair)\n+        flow1.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow1)\n+\n+        def flow2 = flowHelperV2.randomFlow(switchPair, false, [flow1])\n+        flowHelperV2.addFlow(flow2)\n+\n+        def flow3 = flowHelperV2.randomFlow(switchPair, false, [flow1, flow2])\n+        flowHelperV2.addFlow(flow3)\n+\n+        when: \"Get all flowLoops from the src switch\"\n+        then: \"There is no flowLoop because it is not created yet\"\n+        northboundV2.getFlowLoop(switchPair.src.dpId).empty\n+\n+        when: \"Create flowLoop for flow1 and flow2 on the src switch\"\n+        northboundV2.createFlowLoop(flow1.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        northboundV2.createFlowLoop(flow2.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        and: \"Create flowLoop for the flow3 on the dst switch\"\n+        northboundV2.createFlowLoop(flow3.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        and: \"Get all flowLoops from the src switch\"\n+        def flowLoopSrcSw = northboundV2.getFlowLoop(switchPair.src.dpId)\n+\n+        then: \"The created flowLoops for flow1/flow2 are returned in the response list from the src switch\"\n+        flowLoopSrcSw.size() == 2\n+        flowLoopSrcSw*.flowId.sort() == [flow1, flow2]*.flowId.sort()\n+        flowLoopSrcSw*.switchId.unique() == [switchPair.src.dpId]\n+\n+        when: \"Get all flowLoops from the dst switch\"\n+        def flowLoopDstSw = northboundV2.getFlowLoop(switchPair.dst.dpId)\n+\n+        then: \"Only flow3 is in the response list from the dst switch\"\n+        flowLoopDstSw.size() == 1\n+        flowLoopDstSw[0].flowId == flow3.flowId\n+        flowLoopDstSw[0].switchId == switchPair.dst.dpId\n+\n+        cleanup: \"Delete the flows\"\n+        [flow1, flow2, flow3].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    @Tidy\n+    def \"System is able to autoSwapPath for a protected flow when flowLoop is created on it\"() {\n+        given: \"Two active switches with three diverse paths at least\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+\n+        def switchPair = topologyHelper.getAllNotNeighboringSwitchPairs().find {\n+            [it.dst, it.src].every { it.dpId in allTraffGenSwIds } && it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+\n+        and: \"A protected unmetered flow with flowLoop on the src switch\"\n+        def flow = flowHelperV2.randomFlow(switchPair).tap {\n+            maximumBandwidth = 0\n+            ignoreBandwidth = true\n+            allocateProtectedPath = true\n+        }\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        when: \"Break ISL on the main path (bring port down) to init auto swap\"\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        def currentPath = pathHelper.convert(flowPathInfo)\n+        def currentProtectedPath = pathHelper.convert(flowPathInfo.protectedPath)\n+        def islToBreak = pathHelper.getInvolvedIsls(currentPath)[0]\n+        antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        def portIsDown = true\n+\n+        then: \"Flow is switched to protected path\"\n+        Wrappers.wait(PROTECTED_PATH_INSTALLATION_TIME) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+            assert pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentProtectedPath\n+        }\n+\n+        and: \"FlowLoop is still present on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        //    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"FlowLoop rules are still exist on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        cleanup: \"Revert system to original state\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        if (!portIsDown) {\n+            antiflap.portUp(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+            Wrappers.wait(WAIT_OFFSET + discoveryInterval) {\n+                assert islUtils.getIslInfo(islToBreak).get().state == IslChangeType.DISCOVERED\n+            }\n+        }\n+        database.resetCosts()\n+    }\n+\n+    def \"Unable to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpServerErrorException)\n+        exc.statusCode == HttpStatus.NOT_IMPLEMENTED\n+        def errorDetails = exc.responseBodyAsString.to(MessageError)\n+        errorDetails.errorMessage == \"Could not update flow\"\n+        errorDetails.errorDescription == \"Loop for single switch flows is not implemented\"\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop for a QinQ flow\"() {\n+        given: \"An active QinQ flow\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"Not able to find enough switches in multi-table mode\", false)\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(swP.src.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpServerErrorException) //bug TODO: create an issue\n+        exc.statusCode == HttpStatus.NOT_IMPLEMENTED\n+        def errorDetails = exc.responseBodyAsString.to(MessageError)\n+        errorDetails.errorMessage == \"Could not update flow\"\n+        errorDetails.errorDescription == \"Loop for Q-in-Q flows is not implemented\"\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop twice on the same flow\"() {", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2NzAzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521467035", "bodyText": "I also think that below test def \"Unable to create flowLoop on the src switch when it is already created on the dst switch\"() { duplicates this one", "author": "rtretyak", "createdAt": "2020-11-11T16:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2NTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk2MDU1Mw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521960553", "bodyText": "refactored to \"Unable to create flowLoop twice on the src for the same flow\"()", "author": "andriidovhan", "createdAt": "2020-11-12T09:28:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2NTUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2NzU2Mw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521467563", "bodyText": "/system can't update the flow when it is down comment is not relevant", "author": "rtretyak", "createdAt": "2020-11-11T16:10:58Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,772 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n+import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.PROTECTED_PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.NON_EXISTENT_FLOW_ID\n+import static org.openkilda.testing.Constants.NON_EXISTENT_SWITCH_ID\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import org.springframework.web.client.HttpServerErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.tap(data.flowTap)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"FlowLoop rules are created on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        deleteResponse.flowId == flow.flowId\n+\n+        and: \"FlowLoop is really deleted\"\n+        !northboundV2.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop rules are deleted from the src switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).empty\n+        }\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def switchIsValid = true\n+\n+        and: \"Flow allows traffic\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        cleanup: \"Delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !switchIsValid && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.pinned = true }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl ->\n+                             fl.source.vlanId = 0\n+                             fl.destination.vlanId = 0\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.allocateProtectedPath = true }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.encapsulationType = FlowEncapsulationType.VXLAN }\n+                 ],\n+                 //\"Loop for Q-in-Q flows is not implemented\"\n+//                 [\n+//                         flowDescription: \"qinq\",\n+//                         switchPair     : { List<SwitchId> switchIds ->\n+//                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+//                         },\n+//                         flowTap        : { FlowRequestV2 fl ->\n+//                             fl.source.vlanId = 10\n+//                             fl.source.innerVlanId = 100\n+//                             fl.destination.vlanId = 20\n+//                             fl.destination.innerVlanId = 200\n+//                         }\n+//                 ]\n+        ]\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to delete a flow with created flowLoop on it\"() {\n+        given: \"A active multi switch flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId, switchPair.dst.dpId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+        }\n+\n+        and: \"Flow history contains info about flowLoop\"\n+        def flowHistory = northbound.getFlowHistory(flow.flowId).last()\n+        !flowHistory.dumps.find { it.type == \"stateBefore\" }.loopSwitchId\n+        flowHistory.dumps.find { it.type == \"stateAfter\" }.loopSwitchId == switchPair.dst.dpId\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted from the dst switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).empty\n+        }\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        flow && !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        Set<Isl> altFlowIsls = allFlowPaths.findAll { it != flowPath }.collectMany { pathHelper.getInvolvedIsls(it) }\n+        def islToFail = flowIsls.find { !(it in altFlowIsls) }\n+        antiflap.portDown(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+\n+        then: \"The flow was rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) != flowPath\n+        }\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is still present on the dst switch\"\n+        northboundV2.getFlow(flow.flowId).loopSwitchId == switchPair.dst.dpId\n+\n+        and: \"FlowLoop rules ar still present on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        cleanup: \"Revive the ISL back (bring switch port up) and delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        islToFail && antiflap.portUp(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System is able to detect and sync missing flowLoop rules\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        def flowLoopRules\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            flowLoopRules = getFlowLoopRules(switchPair.src.dpId)*.cookie\n+            assert flowLoopRules.size() == 2\n+        }\n+\n+        when: \"Delete flowLoop rules\"\n+        flowLoopRules.each { northbound.deleteSwitchRules(switchPair.src.dpId, it) }\n+\n+        then: \"System detects missing flowLoop rules\"\n+        northbound.validateSwitch(switchPair.src.dpId).rules.missing.sort() == flowLoopRules.sort()\n+\n+        when: \"Sync the src switch\"\n+        def syncResponse = northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+        then: \"Sync response contains flowLoop rules into the installed section\"\n+        syncResponse.rules.installed.sort() == flowLoopRules.sort()\n+\n+        then: \"FlowLoop rules are synced\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).size() == 2\n+        }\n+        northbound.validateSwitch(switchPair.src.dpId).rules.missing.empty\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Systems allows to get all flowLoops that goes through a switch\"() {\n+        given: \"Two active switches\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+\n+        and: \"Three multi switch flows\"\n+        def flow1 = flowHelperV2.randomFlow(switchPair)\n+        flow1.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow1)\n+\n+        def flow2 = flowHelperV2.randomFlow(switchPair, false, [flow1])\n+        flowHelperV2.addFlow(flow2)\n+\n+        def flow3 = flowHelperV2.randomFlow(switchPair, false, [flow1, flow2])\n+        flowHelperV2.addFlow(flow3)\n+\n+        when: \"Get all flowLoops from the src switch\"\n+        then: \"There is no flowLoop because it is not created yet\"\n+        northboundV2.getFlowLoop(switchPair.src.dpId).empty\n+\n+        when: \"Create flowLoop for flow1 and flow2 on the src switch\"\n+        northboundV2.createFlowLoop(flow1.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        northboundV2.createFlowLoop(flow2.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        and: \"Create flowLoop for the flow3 on the dst switch\"\n+        northboundV2.createFlowLoop(flow3.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        and: \"Get all flowLoops from the src switch\"\n+        def flowLoopSrcSw = northboundV2.getFlowLoop(switchPair.src.dpId)\n+\n+        then: \"The created flowLoops for flow1/flow2 are returned in the response list from the src switch\"\n+        flowLoopSrcSw.size() == 2\n+        flowLoopSrcSw*.flowId.sort() == [flow1, flow2]*.flowId.sort()\n+        flowLoopSrcSw*.switchId.unique() == [switchPair.src.dpId]\n+\n+        when: \"Get all flowLoops from the dst switch\"\n+        def flowLoopDstSw = northboundV2.getFlowLoop(switchPair.dst.dpId)\n+\n+        then: \"Only flow3 is in the response list from the dst switch\"\n+        flowLoopDstSw.size() == 1\n+        flowLoopDstSw[0].flowId == flow3.flowId\n+        flowLoopDstSw[0].switchId == switchPair.dst.dpId\n+\n+        cleanup: \"Delete the flows\"\n+        [flow1, flow2, flow3].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    @Tidy\n+    def \"System is able to autoSwapPath for a protected flow when flowLoop is created on it\"() {\n+        given: \"Two active switches with three diverse paths at least\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+\n+        def switchPair = topologyHelper.getAllNotNeighboringSwitchPairs().find {\n+            [it.dst, it.src].every { it.dpId in allTraffGenSwIds } && it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+\n+        and: \"A protected unmetered flow with flowLoop on the src switch\"\n+        def flow = flowHelperV2.randomFlow(switchPair).tap {\n+            maximumBandwidth = 0\n+            ignoreBandwidth = true\n+            allocateProtectedPath = true\n+        }\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        when: \"Break ISL on the main path (bring port down) to init auto swap\"\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        def currentPath = pathHelper.convert(flowPathInfo)\n+        def currentProtectedPath = pathHelper.convert(flowPathInfo.protectedPath)\n+        def islToBreak = pathHelper.getInvolvedIsls(currentPath)[0]\n+        antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        def portIsDown = true\n+\n+        then: \"Flow is switched to protected path\"\n+        Wrappers.wait(PROTECTED_PATH_INSTALLATION_TIME) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+            assert pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentProtectedPath\n+        }\n+\n+        and: \"FlowLoop is still present on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        //    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"FlowLoop rules are still exist on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        cleanup: \"Revert system to original state\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        if (!portIsDown) {\n+            antiflap.portUp(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+            Wrappers.wait(WAIT_OFFSET + discoveryInterval) {\n+                assert islUtils.getIslInfo(islToBreak).get().state == IslChangeType.DISCOVERED\n+            }\n+        }\n+        database.resetCosts()\n+    }\n+\n+    def \"Unable to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpServerErrorException)\n+        exc.statusCode == HttpStatus.NOT_IMPLEMENTED\n+        def errorDetails = exc.responseBodyAsString.to(MessageError)\n+        errorDetails.errorMessage == \"Could not update flow\"\n+        errorDetails.errorDescription == \"Loop for single switch flows is not implemented\"\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop for a QinQ flow\"() {\n+        given: \"An active QinQ flow\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"Not able to find enough switches in multi-table mode\", false)\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(swP.src.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpServerErrorException) //bug TODO: create an issue\n+        exc.statusCode == HttpStatus.NOT_IMPLEMENTED\n+        def errorDetails = exc.responseBodyAsString.to(MessageError)\n+        errorDetails.errorMessage == \"Could not update flow\"\n+        errorDetails.errorDescription == \"Loop for Q-in-Q flows is not implemented\"\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop twice on the same flow\"() {\n+        given: \"An active multi switch flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        when: \"Try to create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still present for the src switch\"\n+        northboundV2.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"No extra rules are created on the src/dst switches\"\n+        getFlowLoopRules(switchPair.src.dpId).size() == 2\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src/dst switches are valid\"\n+        [switchPair.src, switchPair.dst].each {\n+            northbound.validateSwitch(it.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow with created flowLoop\"\n+        northboundV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).empty\n+        }\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        if (!testIsCompleted) {\n+            [switchPair.src, switchPair.dst].each { northbound.synchronizeSwitch(it.dpId, true) }\n+        }\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop when a switch is deactivated\"() {\n+        given: \"An active flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Deactivated the src switch\"\n+        def blockData = switchHelper.knockoutSwitch(switchPair.src, RW)\n+\n+        when: \"Try to create flowLoop on th src switch(deactivated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def e = thrown(HttpClientErrorException)\n+        e.statusCode == HttpStatus.BAD_REQUEST\n+        with(e.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        and: \"FlowLoop is not created\"\n+        !northbound.getFlow(flow.flowId).loopSwitchId\n+\n+        when: \"Try to create flowLoop on th dst switch(activated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"Human readable error is returned\" //system can't update the flow when it is down\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        then: \"FlowLoop is not created\"\n+        !northbound.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        switchHelper.reviveSwitch(switchPair.src, blockData, true)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on the src switch when it is already created on the dst switch\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        when: \"Try to create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is not created on the dst switch\"\n+        def exc2 = thrown(HttpClientErrorException)\n+        exc2.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc2.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on a transit switch\"() {\n+        given: \"An active multi switch flow with transit switch\"\n+        def switchPair = topologyHelper.getNotNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def transitSwId = PathHelper.convert(northbound.getFlowPath(flow.flowId))[1].switchId\n+\n+        when: \"Try to create flowLoop on the transit switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(transitSwId))\n+\n+        then: \"Human readable error is returned\" //system can't update the flow when it is down", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk0ODI2Mw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521948263", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-11-12T09:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2NzU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2ODE4NA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521468184", "bodyText": "on the transit switch", "author": "rtretyak", "createdAt": "2020-11-11T16:11:54Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,772 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n+import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.PROTECTED_PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.NON_EXISTENT_FLOW_ID\n+import static org.openkilda.testing.Constants.NON_EXISTENT_SWITCH_ID\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import org.springframework.web.client.HttpServerErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.tap(data.flowTap)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"FlowLoop rules are created on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        deleteResponse.flowId == flow.flowId\n+\n+        and: \"FlowLoop is really deleted\"\n+        !northboundV2.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop rules are deleted from the src switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).empty\n+        }\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def switchIsValid = true\n+\n+        and: \"Flow allows traffic\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        cleanup: \"Delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !switchIsValid && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.pinned = true }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl ->\n+                             fl.source.vlanId = 0\n+                             fl.destination.vlanId = 0\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.allocateProtectedPath = true }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.encapsulationType = FlowEncapsulationType.VXLAN }\n+                 ],\n+                 //\"Loop for Q-in-Q flows is not implemented\"\n+//                 [\n+//                         flowDescription: \"qinq\",\n+//                         switchPair     : { List<SwitchId> switchIds ->\n+//                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+//                         },\n+//                         flowTap        : { FlowRequestV2 fl ->\n+//                             fl.source.vlanId = 10\n+//                             fl.source.innerVlanId = 100\n+//                             fl.destination.vlanId = 20\n+//                             fl.destination.innerVlanId = 200\n+//                         }\n+//                 ]\n+        ]\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to delete a flow with created flowLoop on it\"() {\n+        given: \"A active multi switch flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId, switchPair.dst.dpId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+        }\n+\n+        and: \"Flow history contains info about flowLoop\"\n+        def flowHistory = northbound.getFlowHistory(flow.flowId).last()\n+        !flowHistory.dumps.find { it.type == \"stateBefore\" }.loopSwitchId\n+        flowHistory.dumps.find { it.type == \"stateAfter\" }.loopSwitchId == switchPair.dst.dpId\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted from the dst switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).empty\n+        }\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        flow && !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        Set<Isl> altFlowIsls = allFlowPaths.findAll { it != flowPath }.collectMany { pathHelper.getInvolvedIsls(it) }\n+        def islToFail = flowIsls.find { !(it in altFlowIsls) }\n+        antiflap.portDown(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+\n+        then: \"The flow was rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) != flowPath\n+        }\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is still present on the dst switch\"\n+        northboundV2.getFlow(flow.flowId).loopSwitchId == switchPair.dst.dpId\n+\n+        and: \"FlowLoop rules ar still present on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        cleanup: \"Revive the ISL back (bring switch port up) and delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        islToFail && antiflap.portUp(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System is able to detect and sync missing flowLoop rules\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        def flowLoopRules\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            flowLoopRules = getFlowLoopRules(switchPair.src.dpId)*.cookie\n+            assert flowLoopRules.size() == 2\n+        }\n+\n+        when: \"Delete flowLoop rules\"\n+        flowLoopRules.each { northbound.deleteSwitchRules(switchPair.src.dpId, it) }\n+\n+        then: \"System detects missing flowLoop rules\"\n+        northbound.validateSwitch(switchPair.src.dpId).rules.missing.sort() == flowLoopRules.sort()\n+\n+        when: \"Sync the src switch\"\n+        def syncResponse = northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+        then: \"Sync response contains flowLoop rules into the installed section\"\n+        syncResponse.rules.installed.sort() == flowLoopRules.sort()\n+\n+        then: \"FlowLoop rules are synced\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).size() == 2\n+        }\n+        northbound.validateSwitch(switchPair.src.dpId).rules.missing.empty\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Systems allows to get all flowLoops that goes through a switch\"() {\n+        given: \"Two active switches\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+\n+        and: \"Three multi switch flows\"\n+        def flow1 = flowHelperV2.randomFlow(switchPair)\n+        flow1.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow1)\n+\n+        def flow2 = flowHelperV2.randomFlow(switchPair, false, [flow1])\n+        flowHelperV2.addFlow(flow2)\n+\n+        def flow3 = flowHelperV2.randomFlow(switchPair, false, [flow1, flow2])\n+        flowHelperV2.addFlow(flow3)\n+\n+        when: \"Get all flowLoops from the src switch\"\n+        then: \"There is no flowLoop because it is not created yet\"\n+        northboundV2.getFlowLoop(switchPair.src.dpId).empty\n+\n+        when: \"Create flowLoop for flow1 and flow2 on the src switch\"\n+        northboundV2.createFlowLoop(flow1.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        northboundV2.createFlowLoop(flow2.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        and: \"Create flowLoop for the flow3 on the dst switch\"\n+        northboundV2.createFlowLoop(flow3.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        and: \"Get all flowLoops from the src switch\"\n+        def flowLoopSrcSw = northboundV2.getFlowLoop(switchPair.src.dpId)\n+\n+        then: \"The created flowLoops for flow1/flow2 are returned in the response list from the src switch\"\n+        flowLoopSrcSw.size() == 2\n+        flowLoopSrcSw*.flowId.sort() == [flow1, flow2]*.flowId.sort()\n+        flowLoopSrcSw*.switchId.unique() == [switchPair.src.dpId]\n+\n+        when: \"Get all flowLoops from the dst switch\"\n+        def flowLoopDstSw = northboundV2.getFlowLoop(switchPair.dst.dpId)\n+\n+        then: \"Only flow3 is in the response list from the dst switch\"\n+        flowLoopDstSw.size() == 1\n+        flowLoopDstSw[0].flowId == flow3.flowId\n+        flowLoopDstSw[0].switchId == switchPair.dst.dpId\n+\n+        cleanup: \"Delete the flows\"\n+        [flow1, flow2, flow3].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    @Tidy\n+    def \"System is able to autoSwapPath for a protected flow when flowLoop is created on it\"() {\n+        given: \"Two active switches with three diverse paths at least\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+\n+        def switchPair = topologyHelper.getAllNotNeighboringSwitchPairs().find {\n+            [it.dst, it.src].every { it.dpId in allTraffGenSwIds } && it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+\n+        and: \"A protected unmetered flow with flowLoop on the src switch\"\n+        def flow = flowHelperV2.randomFlow(switchPair).tap {\n+            maximumBandwidth = 0\n+            ignoreBandwidth = true\n+            allocateProtectedPath = true\n+        }\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        when: \"Break ISL on the main path (bring port down) to init auto swap\"\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        def currentPath = pathHelper.convert(flowPathInfo)\n+        def currentProtectedPath = pathHelper.convert(flowPathInfo.protectedPath)\n+        def islToBreak = pathHelper.getInvolvedIsls(currentPath)[0]\n+        antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        def portIsDown = true\n+\n+        then: \"Flow is switched to protected path\"\n+        Wrappers.wait(PROTECTED_PATH_INSTALLATION_TIME) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+            assert pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentProtectedPath\n+        }\n+\n+        and: \"FlowLoop is still present on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        //    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"FlowLoop rules are still exist on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        cleanup: \"Revert system to original state\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        if (!portIsDown) {\n+            antiflap.portUp(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+            Wrappers.wait(WAIT_OFFSET + discoveryInterval) {\n+                assert islUtils.getIslInfo(islToBreak).get().state == IslChangeType.DISCOVERED\n+            }\n+        }\n+        database.resetCosts()\n+    }\n+\n+    def \"Unable to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpServerErrorException)\n+        exc.statusCode == HttpStatus.NOT_IMPLEMENTED\n+        def errorDetails = exc.responseBodyAsString.to(MessageError)\n+        errorDetails.errorMessage == \"Could not update flow\"\n+        errorDetails.errorDescription == \"Loop for single switch flows is not implemented\"\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop for a QinQ flow\"() {\n+        given: \"An active QinQ flow\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"Not able to find enough switches in multi-table mode\", false)\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(swP.src.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpServerErrorException) //bug TODO: create an issue\n+        exc.statusCode == HttpStatus.NOT_IMPLEMENTED\n+        def errorDetails = exc.responseBodyAsString.to(MessageError)\n+        errorDetails.errorMessage == \"Could not update flow\"\n+        errorDetails.errorDescription == \"Loop for Q-in-Q flows is not implemented\"\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop twice on the same flow\"() {\n+        given: \"An active multi switch flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        when: \"Try to create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still present for the src switch\"\n+        northboundV2.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"No extra rules are created on the src/dst switches\"\n+        getFlowLoopRules(switchPair.src.dpId).size() == 2\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src/dst switches are valid\"\n+        [switchPair.src, switchPair.dst].each {\n+            northbound.validateSwitch(it.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow with created flowLoop\"\n+        northboundV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).empty\n+        }\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        if (!testIsCompleted) {\n+            [switchPair.src, switchPair.dst].each { northbound.synchronizeSwitch(it.dpId, true) }\n+        }\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop when a switch is deactivated\"() {\n+        given: \"An active flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Deactivated the src switch\"\n+        def blockData = switchHelper.knockoutSwitch(switchPair.src, RW)\n+\n+        when: \"Try to create flowLoop on th src switch(deactivated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def e = thrown(HttpClientErrorException)\n+        e.statusCode == HttpStatus.BAD_REQUEST\n+        with(e.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        and: \"FlowLoop is not created\"\n+        !northbound.getFlow(flow.flowId).loopSwitchId\n+\n+        when: \"Try to create flowLoop on th dst switch(activated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"Human readable error is returned\" //system can't update the flow when it is down\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        then: \"FlowLoop is not created\"\n+        !northbound.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        switchHelper.reviveSwitch(switchPair.src, blockData, true)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on the src switch when it is already created on the dst switch\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        when: \"Try to create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is not created on the dst switch\"\n+        def exc2 = thrown(HttpClientErrorException)\n+        exc2.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc2.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on a transit switch\"() {\n+        given: \"An active multi switch flow with transit switch\"\n+        def switchPair = topologyHelper.getNotNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def transitSwId = PathHelper.convert(northbound.getFlowPath(flow.flowId))[1].switchId\n+\n+        when: \"Try to create flowLoop on the transit switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(transitSwId))\n+\n+        then: \"Human readable error is returned\" //system can't update the flow when it is down\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Loop switch is not terminating in flow path\"\n+        }\n+\n+        then: \"FlowLoop is not created\"\n+        !northbound.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk0NjAzOQ==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521946039", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-11-12T09:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2ODE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3MTM5NA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521471394", "bodyText": "getAllNotNeighboringSwitchPairs still not fixed here and in all methods below. Is it possible to just use getSwitchPairs() and operate with all available topology?", "author": "rtretyak", "createdAt": "2020-11-11T16:16:41Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -0,0 +1,772 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.LOW_PRIORITY\n+import static org.openkilda.functionaltests.extension.tags.Tag.SMOKE_SWITCHES\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.PROTECTED_PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.RULES_DELETION_TIME\n+import static org.openkilda.testing.Constants.NON_EXISTENT_FLOW_ID\n+import static org.openkilda.testing.Constants.NON_EXISTENT_SWITCH_ID\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+import static org.openkilda.testing.service.floodlight.model.FloodlightConnectMode.RW\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.IterationTag\n+import org.openkilda.functionaltests.extension.tags.IterationTags\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.PathHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.SwitchId\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.northbound.dto.v2.flows.FlowLoopPayload\n+import org.openkilda.northbound.dto.v2.flows.FlowRequestV2\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import org.springframework.web.client.HttpServerErrorException\n+import spock.lang.Ignore\n+import spock.lang.Narrative\n+import spock.lang.See\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+@See(\"https://github.com/telstra/open-kilda/tree/develop/docs/design/flow-loop\")\n+@Narrative(\"\"\"Flow loop feature designed for flow path testing. Loop provides additional flow rules on one of the \n+terminating switch so any flow traffic is returned to switch-port where it was received. Such flow has 'looped=true'\n+flag and supports all flow operations. When the loop removed system should restore the original flow rules.\n+Enabling flowLoop in flow history is registered as the 'update' operation.\"\"\")\n+class FlowLoopSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Tidy\n+    @Unroll\n+    @IterationTags([\n+            @IterationTag(tags = [SMOKE_SWITCHES, TOPOLOGY_DEPENDENT], iterationNameRegex = /protected/),\n+            @IterationTag(tags = [HARDWARE], iterationNameRegex = /vxlan/)\n+    ])\n+    def \"Able to create flowLoop for a #data.flowDescription flow\"() {\n+        given: \"An active and valid  #data.flowDescription flow\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+        def switchPair = data.switchPair(allTraffGenSwIds)\n+        assumeTrue(\"Unable to find required switch pair in topology\", switchPair != null)\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.tap(data.flowTap)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        def flowLoopPayloadSrcSw = new FlowLoopPayload(switchPair.src.dpId)\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, flowLoopPayloadSrcSw)\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == switchPair.src.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"FlowLoop rules are created on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            forward.pingSuccess\n+            reverse.pingSuccess\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        when: \"Delete flowLoop\"\n+        def deleteResponse = northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"The delete flowLoop response contains the flowId\"\n+        deleteResponse.flowId == flow.flowId\n+\n+        and: \"FlowLoop is really deleted\"\n+        !northboundV2.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop rules are deleted from the src switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).empty\n+        }\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def switchIsValid = true\n+\n+        and: \"Flow allows traffic\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        cleanup: \"Delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !switchIsValid && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+\n+        where:\n+        data << [[\n+                         flowDescription: \"pinned\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.pinned = true }\n+                 ],\n+                 [\n+                         flowDescription: \"default\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForSimpleFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl ->\n+                             fl.source.vlanId = 0\n+                             fl.destination.vlanId = 0\n+                         }\n+                 ],\n+                 [\n+                         flowDescription: \"protected\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForProtectedFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.allocateProtectedPath = true }\n+                 ],\n+                 [\n+                         flowDescription: \"vxlan\",\n+                         switchPair     : { List<SwitchId> switchIds ->\n+                             getSwPairConnectedToTraffGenForVxlanFlow(switchIds)\n+                         },\n+                         flowTap        : { FlowRequestV2 fl -> fl.encapsulationType = FlowEncapsulationType.VXLAN }\n+                 ],\n+                 //\"Loop for Q-in-Q flows is not implemented\"\n+//                 [\n+//                         flowDescription: \"qinq\",\n+//                         switchPair     : { List<SwitchId> switchIds ->\n+//                             getSwPairConnectedToTraffGenForQinQ(switchIds)\n+//                         },\n+//                         flowTap        : { FlowRequestV2 fl ->\n+//                             fl.source.vlanId = 10\n+//                             fl.source.innerVlanId = 100\n+//                             fl.destination.vlanId = 20\n+//                             fl.destination.innerVlanId = 200\n+//                         }\n+//                 ]\n+        ]\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to delete a flow with created flowLoop on it\"() {\n+        given: \"A active multi switch flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is created on the dst switch\"\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId, switchPair.dst.dpId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+        }\n+\n+        and: \"Flow history contains info about flowLoop\"\n+        def flowHistory = northbound.getFlowHistory(flow.flowId).last()\n+        !flowHistory.dumps.find { it.type == \"stateBefore\" }.loopSwitchId\n+        flowHistory.dumps.find { it.type == \"stateAfter\" }.loopSwitchId == switchPair.dst.dpId\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted from the dst switch\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.dst.dpId).empty\n+        }\n+\n+        and: \"The dst switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup: \"Delete the flow\"\n+        flow && !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && [switchPair.src.dpId, switchPair.dst.dpId].each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+    }\n+\n+    @Tidy\n+    def \"System is able to reroute a flow when flowLoop is created on it\"() {\n+        given: \"A multi switch flow with one alternative path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n+        }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = PathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"FlowLoop is created on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == switchPair.dst.dpId\n+        }\n+\n+        when: \"Fail a flow ISL (bring switch port down)\"\n+        def allFlowPaths = switchPair.paths\n+        def flowIsls = pathHelper.getInvolvedIsls(flowPath)\n+        Set<Isl> altFlowIsls = allFlowPaths.findAll { it != flowPath }.collectMany { pathHelper.getInvolvedIsls(it) }\n+        def islToFail = flowIsls.find { !(it in altFlowIsls) }\n+        antiflap.portDown(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+\n+        then: \"The flow was rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) != flowPath\n+        }\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is still present on the dst switch\"\n+        northboundV2.getFlow(flow.flowId).loopSwitchId == switchPair.dst.dpId\n+\n+        and: \"FlowLoop rules ar still present on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).size() == 2\n+\n+        and: \"The src switch is valid\"\n+        northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        cleanup: \"Revive the ISL back (bring switch port up) and delete the flow\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        islToFail && antiflap.portUp(islToFail.srcSwitch.dpId, islToFail.srcPort)\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System is able to detect and sync missing flowLoop rules\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        def flowLoopRules\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            flowLoopRules = getFlowLoopRules(switchPair.src.dpId)*.cookie\n+            assert flowLoopRules.size() == 2\n+        }\n+\n+        when: \"Delete flowLoop rules\"\n+        flowLoopRules.each { northbound.deleteSwitchRules(switchPair.src.dpId, it) }\n+\n+        then: \"System detects missing flowLoop rules\"\n+        northbound.validateSwitch(switchPair.src.dpId).rules.missing.sort() == flowLoopRules.sort()\n+\n+        when: \"Sync the src switch\"\n+        def syncResponse = northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+        then: \"Sync response contains flowLoop rules into the installed section\"\n+        syncResponse.rules.installed.sort() == flowLoopRules.sort()\n+\n+        then: \"FlowLoop rules are synced\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).size() == 2\n+        }\n+        northbound.validateSwitch(switchPair.src.dpId).rules.missing.empty\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(switchPair.src.dpId, true)\n+\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Systems allows to get all flowLoops that goes through a switch\"() {\n+        given: \"Two active switches\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+\n+        and: \"Three multi switch flows\"\n+        def flow1 = flowHelperV2.randomFlow(switchPair)\n+        flow1.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow1)\n+\n+        def flow2 = flowHelperV2.randomFlow(switchPair, false, [flow1])\n+        flowHelperV2.addFlow(flow2)\n+\n+        def flow3 = flowHelperV2.randomFlow(switchPair, false, [flow1, flow2])\n+        flowHelperV2.addFlow(flow3)\n+\n+        when: \"Get all flowLoops from the src switch\"\n+        then: \"There is no flowLoop because it is not created yet\"\n+        northboundV2.getFlowLoop(switchPair.src.dpId).empty\n+\n+        when: \"Create flowLoop for flow1 and flow2 on the src switch\"\n+        northboundV2.createFlowLoop(flow1.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        northboundV2.createFlowLoop(flow2.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        and: \"Create flowLoop for the flow3 on the dst switch\"\n+        northboundV2.createFlowLoop(flow3.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        and: \"Get all flowLoops from the src switch\"\n+        def flowLoopSrcSw = northboundV2.getFlowLoop(switchPair.src.dpId)\n+\n+        then: \"The created flowLoops for flow1/flow2 are returned in the response list from the src switch\"\n+        flowLoopSrcSw.size() == 2\n+        flowLoopSrcSw*.flowId.sort() == [flow1, flow2]*.flowId.sort()\n+        flowLoopSrcSw*.switchId.unique() == [switchPair.src.dpId]\n+\n+        when: \"Get all flowLoops from the dst switch\"\n+        def flowLoopDstSw = northboundV2.getFlowLoop(switchPair.dst.dpId)\n+\n+        then: \"Only flow3 is in the response list from the dst switch\"\n+        flowLoopDstSw.size() == 1\n+        flowLoopDstSw[0].flowId == flow3.flowId\n+        flowLoopDstSw[0].switchId == switchPair.dst.dpId\n+\n+        cleanup: \"Delete the flows\"\n+        [flow1, flow2, flow3].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    @Tidy\n+    def \"System is able to autoSwapPath for a protected flow when flowLoop is created on it\"() {\n+        given: \"Two active switches with three diverse paths at least\"\n+        def allTraffGenSwIds = topology.activeTraffGens*.switchConnected*.dpId\n+        assumeTrue(\"Unable to find switches connected to traffGens\", (allTraffGenSwIds.size() > 1))\n+\n+        def switchPair = topologyHelper.getAllNotNeighboringSwitchPairs().find {\n+            [it.dst, it.src].every { it.dpId in allTraffGenSwIds } && it.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+\n+        and: \"A protected unmetered flow with flowLoop on the src switch\"\n+        def flow = flowHelperV2.randomFlow(switchPair).tap {\n+            maximumBandwidth = 0\n+            ignoreBandwidth = true\n+            allocateProtectedPath = true\n+        }\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        when: \"Break ISL on the main path (bring port down) to init auto swap\"\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        def currentPath = pathHelper.convert(flowPathInfo)\n+        def currentProtectedPath = pathHelper.convert(flowPathInfo.protectedPath)\n+        def islToBreak = pathHelper.getInvolvedIsls(currentPath)[0]\n+        antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        def portIsDown = true\n+\n+        then: \"Flow is switched to protected path\"\n+        Wrappers.wait(PROTECTED_PATH_INSTALLATION_TIME) {\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+            assert pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentProtectedPath\n+        }\n+\n+        and: \"FlowLoop is still present on the src switch\"\n+        northbound.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"The src switch is valid\"\n+        //there is a bug, flow_loop is in excess\n+        //    northbound.validateSwitch(switchPair.src.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+\n+        and: \"FlowLoop rules are still exist on the src switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            Map<Long, Long> flowLoopsCounter = getFlowLoopRules(switchPair.src.dpId)\n+                    .collectEntries { [(it.cookie): it.packetCount] }\n+            assert flowLoopsCounter.size() == 2\n+            assert flowLoopsCounter.values().every { it == 0 }\n+        }\n+\n+        when: \"Send traffic via flow\"\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+\n+        then: \"Flow doesn't allow traffic, because it is grubbed by flowLoop rules\"\n+        withPool {\n+            [exam.forward, exam.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert !traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Counter on the flowLoop rules are increased\"\n+        getFlowLoopRules(switchPair.src.dpId)*.packetCount.every { it > 0 }\n+\n+        cleanup: \"Revert system to original state\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        if (!portIsDown) {\n+            antiflap.portUp(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+            Wrappers.wait(WAIT_OFFSET + discoveryInterval) {\n+                assert islUtils.getIslInfo(islToBreak).get().state == IslChangeType.DISCOVERED\n+            }\n+        }\n+        database.resetCosts()\n+    }\n+\n+    def \"Unable to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpServerErrorException)\n+        exc.statusCode == HttpStatus.NOT_IMPLEMENTED\n+        def errorDetails = exc.responseBodyAsString.to(MessageError)\n+        errorDetails.errorMessage == \"Could not update flow\"\n+        errorDetails.errorDescription == \"Loop for single switch flows is not implemented\"\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop for a QinQ flow\"() {\n+        given: \"An active QinQ flow\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"Not able to find enough switches in multi-table mode\", false)\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the src switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(swP.src.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpServerErrorException) //bug TODO: create an issue\n+        exc.statusCode == HttpStatus.NOT_IMPLEMENTED\n+        def errorDetails = exc.responseBodyAsString.to(MessageError)\n+        errorDetails.errorMessage == \"Could not update flow\"\n+        errorDetails.errorDescription == \"Loop for Q-in-Q flows is not implemented\"\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop twice on the same flow\"() {\n+        given: \"An active multi switch flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        when: \"Try to create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        and: \"FlowLoop is still present for the src switch\"\n+        northboundV2.getFlow(flow.flowId).loopSwitchId == switchPair.src.dpId\n+\n+        and: \"No extra rules are created on the src/dst switches\"\n+        getFlowLoopRules(switchPair.src.dpId).size() == 2\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        and: \"The src/dst switches are valid\"\n+        [switchPair.src, switchPair.dst].each {\n+            northbound.validateSwitch(it.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow with created flowLoop\"\n+        northboundV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        then: \"FlowLoop rules are deleted\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            assert getFlowLoopRules(switchPair.src.dpId).empty\n+        }\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        if (!testIsCompleted) {\n+            [switchPair.src, switchPair.dst].each { northbound.synchronizeSwitch(it.dpId, true) }\n+        }\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop when a switch is deactivated\"() {\n+        given: \"An active flow\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Deactivated the src switch\"\n+        def blockData = switchHelper.knockoutSwitch(switchPair.src, RW)\n+\n+        when: \"Try to create flowLoop on th src switch(deactivated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def e = thrown(HttpClientErrorException)\n+        e.statusCode == HttpStatus.BAD_REQUEST\n+        with(e.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        and: \"FlowLoop is not created\"\n+        !northbound.getFlow(flow.flowId).loopSwitchId\n+\n+        when: \"Try to create flowLoop on th dst switch(activated)\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"Human readable error is returned\" //system can't update the flow when it is down\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Source switch $switchPair.src.dpId is not connected to the controller\"\n+        }\n+\n+        then: \"FlowLoop is not created\"\n+        !northbound.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(switchPair.dst.dpId).empty\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        switchHelper.reviveSwitch(switchPair.src, blockData, true)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on the src switch when it is already created on the dst switch\"() {\n+        given: \"An active flow with created flowLoop on the src switch\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.src.dpId))\n+\n+        when: \"Try to create flowLoop on the dst switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(switchPair.dst.dpId))\n+\n+        then: \"FlowLoop is not created on the dst switch\"\n+        def exc2 = thrown(HttpClientErrorException)\n+        exc2.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc2.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Can't change loop switch\"\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on a transit switch\"() {\n+        given: \"An active multi switch flow with transit switch\"\n+        def switchPair = topologyHelper.getNotNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def transitSwId = PathHelper.convert(northbound.getFlowPath(flow.flowId))[1].switchId\n+\n+        when: \"Try to create flowLoop on the transit switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(transitSwId))\n+\n+        then: \"Human readable error is returned\" //system can't update the flow when it is down\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Loop switch is not terminating in flow path\"\n+        }\n+\n+        then: \"FlowLoop is not created\"\n+        !northbound.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"FlowLoop rules are not created on the dst switch\"\n+        getFlowLoopRules(transitSwId).empty\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop for a non existent flow\"() {\n+        when: \"Try to create flowLoop on the transit switch\"\n+        def sw = topology.activeSwitches.first()\n+        northboundV2.createFlowLoop(NON_EXISTENT_FLOW_ID, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.NOT_FOUND\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Flow not found\"\n+            errorDescription == \"Flow '$NON_EXISTENT_FLOW_ID' not found.\"\n+        }\n+\n+        and: \"FlowLoop rules are not created on the switch\"\n+        getFlowLoopRules(sw.dpId).empty\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def switchIsValid = true\n+\n+        cleanup:\n+        !switchIsValid && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Unable to create flowLoop on a non existent switch\"() {\n+        given: \"An active multi switch flow\"\n+        def swP = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Try to create flowLoop on a non existent switch\"\n+        northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(NON_EXISTENT_SWITCH_ID))\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        with(exc.responseBodyAsString.to(MessageError)) {\n+            errorMessage == \"Could not update flow\"\n+            errorDescription == \"Loop switch is not terminating in flow path\"\n+        }\n+\n+        and: \"FlowLoop rules are not created for the flow\"\n+        !northboundV2.getFlow(flow.flowId).loopSwitchId\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    def \"getSwPairConnectedToTraffGenForSimpleFlow\"(List<SwitchId> switchIds) {\n+        getTopologyHelper().getAllNotNeighboringSwitchPairs().collectMany { [it, it.reversed] }.find { swP ->", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAwMTc0OA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r522001748", "bodyText": "sure, replaced everywhere", "author": "andriidovhan", "createdAt": "2020-11-12T10:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3MTM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NTU4Mg==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521475582", "bodyText": "since you are strictly bind to src/dst conditions, you may also want to loop through reversed switch pairs", "author": "rtretyak", "createdAt": "2020-11-11T16:22:55Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/SwapEndpointSpec.groovy", "diffHunk": "@@ -1373,6 +1378,89 @@ switches\"() {\n         !isSwitchValid && switches.each { northbound.synchronizeSwitch(it, true)}\n     }\n \n+    @Tidy\n+    def \"Able to swap endpoints for a flow with flowLoop\"() {\n+        setup: \"Create two flows with the same src and different dst switches\"\n+        def tgSwitchIds = topology.getActiveTraffGens()*.switchConnected*.dpId\n+        assumeTrue(\"Not enough traffgen switches found\", tgSwitchIds.size() > 1)\n+        SwitchPair flow2SwitchPair = null\n+        SwitchPair flow1SwitchPair = topologyHelper.getAllNeighboringSwitchPairs().find { firstPair ->", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE0NDIzNA==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r522144234", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-11-12T14:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NTU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3ODU1Ng==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r521478556", "bodyText": "such swap is not typical. It doesn't make sense to swap both src and dst so that flows just swap their flowIds. Usually flows swap either their src and retain original dst, or vice versa", "author": "rtretyak", "createdAt": "2020-11-11T16:27:11Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/SwapEndpointSpec.groovy", "diffHunk": "@@ -1373,6 +1378,89 @@ switches\"() {\n         !isSwitchValid && switches.each { northbound.synchronizeSwitch(it, true)}\n     }\n \n+    @Tidy\n+    def \"Able to swap endpoints for a flow with flowLoop\"() {\n+        setup: \"Create two flows with the same src and different dst switches\"\n+        def tgSwitchIds = topology.getActiveTraffGens()*.switchConnected*.dpId\n+        assumeTrue(\"Not enough traffgen switches found\", tgSwitchIds.size() > 1)\n+        SwitchPair flow2SwitchPair = null\n+        SwitchPair flow1SwitchPair = topologyHelper.getAllNeighboringSwitchPairs().find { firstPair ->\n+            def firstOk = firstPair.src.dpId in tgSwitchIds && firstPair.dst.dpId in tgSwitchIds\n+            flow2SwitchPair = topologyHelper.getAllNeighboringSwitchPairs().find { secondPair ->\n+                secondPair.src.dpId == firstPair.src.dpId && secondPair.dst.dpId != firstPair.dst.dpId\n+            }\n+            firstOk && flow2SwitchPair\n+        }\n+        assumeTrue(\"Required switch pairs not found in given topology\",\n+                flow1SwitchPair.asBoolean() && flow2SwitchPair.asBoolean())\n+\n+        def flow1 = flowHelper.randomFlow(flow1SwitchPair, true)\n+        def flow2 = flowHelper.randomFlow(flow2SwitchPair, true, [flow1])\n+\n+        flowHelper.addFlow(flow1)\n+        flowHelper.addFlow(flow2)\n+\n+        and: \"FlowLoop is created for the second flow on the dst switch\"\n+        northboundV2.createFlowLoop(flow2.id, new FlowLoopPayload(flow2SwitchPair.dst.dpId))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow2.id).status == FlowState.UP\n+        }\n+\n+        when: \"Try to swap endpoints for two flows\"\n+        def flow1Dst = flow2.destination\n+        def flow1Src = flow2.source\n+        def flow2Dst = flow1.destination\n+        def flow2Src = flow1.source", "originalCommit": "32b676d13bec7f015cee68c389691c84f2a896af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExODQ1Mw==", "url": "https://github.com/telstra/open-kilda/pull/3789#discussion_r522118453", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-11-12T13:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3ODU1Ng=="}], "type": "inlineReview"}, {"oid": "bf62f95d20f9d298f85c3b87bf9a0310c147517e", "url": "https://github.com/telstra/open-kilda/commit/bf62f95d20f9d298f85c3b87bf9a0310c147517e", "message": "add tests for flowLoop", "committedDate": "2020-11-12T08:53:52Z", "type": "forcePushed"}, {"oid": "2aa0ab437293e046efea868e44694b7a386b4b7b", "url": "https://github.com/telstra/open-kilda/commit/2aa0ab437293e046efea868e44694b7a386b4b7b", "message": "add tests for flowLoop", "committedDate": "2020-11-12T13:57:59Z", "type": "forcePushed"}, {"oid": "e32f43e715c7fe4c14470cb68f59b014f3457377", "url": "https://github.com/telstra/open-kilda/commit/e32f43e715c7fe4c14470cb68f59b014f3457377", "message": "add tests for flowLoop", "committedDate": "2020-11-12T14:25:06Z", "type": "forcePushed"}, {"oid": "4f34a44622b4df5b610880d8483997aa7dc04bff", "url": "https://github.com/telstra/open-kilda/commit/4f34a44622b4df5b610880d8483997aa7dc04bff", "message": "add tests for flowLoop", "committedDate": "2020-11-12T14:32:54Z", "type": "forcePushed"}, {"oid": "c19d879ce01d88ea6e081f9ea98a1997ea340fe4", "url": "https://github.com/telstra/open-kilda/commit/c19d879ce01d88ea6e081f9ea98a1997ea340fe4", "message": "add tests for flowLoop", "committedDate": "2020-11-12T14:50:11Z", "type": "forcePushed"}, {"oid": "6b38fe628fb9e54c344b76682111b20f59d1945c", "url": "https://github.com/telstra/open-kilda/commit/6b38fe628fb9e54c344b76682111b20f59d1945c", "message": "add tests for flowLoop", "committedDate": "2020-11-12T15:15:25Z", "type": "forcePushed"}, {"oid": "fa655b417434e7bfcac43a159aec0e3142bce3fb", "url": "https://github.com/telstra/open-kilda/commit/fa655b417434e7bfcac43a159aec0e3142bce3fb", "message": "add tests for flowLoop", "committedDate": "2020-11-12T21:13:47Z", "type": "forcePushed"}, {"oid": "69b8e23807fb755ed62c958b3d8e7cbe53add810", "url": "https://github.com/telstra/open-kilda/commit/69b8e23807fb755ed62c958b3d8e7cbe53add810", "message": "add tests for flowLoop", "committedDate": "2020-11-12T21:48:54Z", "type": "forcePushed"}, {"oid": "d67895dad9ae7f236841c3c5114323e535fd7683", "url": "https://github.com/telstra/open-kilda/commit/d67895dad9ae7f236841c3c5114323e535fd7683", "message": "add tests for flowLoop", "committedDate": "2020-11-13T08:59:18Z", "type": "forcePushed"}, {"oid": "d1fcfda6b1530ce2b5cdf45aa76a5b197dd4b485", "url": "https://github.com/telstra/open-kilda/commit/d1fcfda6b1530ce2b5cdf45aa76a5b197dd4b485", "message": "add tests for flowLoop", "committedDate": "2020-11-13T09:38:33Z", "type": "forcePushed"}, {"oid": "bbec61e4ad0e410feaa6490383eaef8cd5f22089", "url": "https://github.com/telstra/open-kilda/commit/bbec61e4ad0e410feaa6490383eaef8cd5f22089", "message": "add tests for flowLoop", "committedDate": "2020-11-13T13:01:31Z", "type": "forcePushed"}, {"oid": "5229a4518193a062a5fd1fa20778b17fc5f06df8", "url": "https://github.com/telstra/open-kilda/commit/5229a4518193a062a5fd1fa20778b17fc5f06df8", "message": "adjust flowLoopSpec to work on the stage env", "committedDate": "2020-11-23T08:22:48Z", "type": "forcePushed"}, {"oid": "031722382533f456d8e2874024073ca8c385d010", "url": "https://github.com/telstra/open-kilda/commit/031722382533f456d8e2874024073ca8c385d010", "message": "adjust flowLoopSpec to work on the stage env", "committedDate": "2020-11-23T08:29:28Z", "type": "forcePushed"}, {"oid": "911debefcefe971a4e51b1ce9e12a45465c09284", "url": "https://github.com/telstra/open-kilda/commit/911debefcefe971a4e51b1ce9e12a45465c09284", "message": "unignore qinq and multiTable in flowLoopSpec", "committedDate": "2020-11-26T09:49:56Z", "type": "forcePushed"}, {"oid": "407411f3882e90518a5a7ca1c272c0420138eab0", "url": "https://github.com/telstra/open-kilda/commit/407411f3882e90518a5a7ca1c272c0420138eab0", "message": "unignore qinq and multiTable in flowLoopSpec", "committedDate": "2020-11-26T10:43:27Z", "type": "forcePushed"}, {"oid": "414e5ad52ce5e36496fdfe66482b2ecd7fe9b773", "url": "https://github.com/telstra/open-kilda/commit/414e5ad52ce5e36496fdfe66482b2ecd7fe9b773", "message": "unignore qinq and multiTable in flowLoopSpec", "committedDate": "2020-11-30T09:20:17Z", "type": "forcePushed"}, {"oid": "af1aafebf9ae3a1ad545cc1d77089d9783c710f0", "url": "https://github.com/telstra/open-kilda/commit/af1aafebf9ae3a1ad545cc1d77089d9783c710f0", "message": "unignore qinq and multiTable in flowLoopSpec", "committedDate": "2020-11-30T12:57:25Z", "type": "forcePushed"}, {"oid": "c4d0548a06170b7c0f0cea26ebd1d42f48c6a664", "url": "https://github.com/telstra/open-kilda/commit/c4d0548a06170b7c0f0cea26ebd1d42f48c6a664", "message": "add flowLoop endpoint into func test", "committedDate": "2020-12-01T08:42:07Z", "type": "commit"}, {"oid": "ccfc2ab95d157b14ac59ca2e9045a74924323629", "url": "https://github.com/telstra/open-kilda/commit/ccfc2ab95d157b14ac59ca2e9045a74924323629", "message": "add tests for flowLoop", "committedDate": "2020-12-01T08:42:07Z", "type": "commit"}, {"oid": "0c179e4cf6f40add540398c9359d51925813318b", "url": "https://github.com/telstra/open-kilda/commit/0c179e4cf6f40add540398c9359d51925813318b", "message": "adjust flowLoopSpec to work on the stage env", "committedDate": "2020-12-01T08:42:07Z", "type": "commit"}, {"oid": "36155292a3a0128713b9cf83a261bbd56382fc28", "url": "https://github.com/telstra/open-kilda/commit/36155292a3a0128713b9cf83a261bbd56382fc28", "message": "unignore qinq and multiTable in flowLoopSpec", "committedDate": "2020-12-01T08:42:07Z", "type": "commit"}, {"oid": "36155292a3a0128713b9cf83a261bbd56382fc28", "url": "https://github.com/telstra/open-kilda/commit/36155292a3a0128713b9cf83a261bbd56382fc28", "message": "unignore qinq and multiTable in flowLoopSpec", "committedDate": "2020-12-01T08:42:07Z", "type": "forcePushed"}]}