{"pr_number": 3359, "pr_title": "add test for targetPathComputationStrategy and partialUpdate", "pr_createdAt": "2020-04-02T11:12:51Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3359", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyNjY2Ng==", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r403926666", "bodyText": "already tested above", "author": "rtretyak", "createdAt": "2020-04-06T08:49:07Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -48,6 +49,18 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n                 [\n                         field   : \"priority\",\n                         newValue: 654\n+                ],\n+                [\n+                        field   : \"maxLatency\",", "originalCommit": "a4283a3e0623a87da03fac8de25825f4b27877e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk2NTg3Nw==", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r403965877", "bodyText": "oops, my bad", "author": "andriidovhan", "createdAt": "2020-04-06T09:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyNjY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyNzc4NA==", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r403927784", "bodyText": "end of test1\nstart of test2\nWe should not overuse long scenarios. Moreover in this case scenarios a pretty much isolated and don't depend on each other, don't see any benefits in keeping them in 1 test", "author": "rtretyak", "createdAt": "2020-04-06T08:50:59Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathComputationSpec.groovy", "diffHunk": "@@ -102,4 +107,74 @@ class PathComputationSpec extends HealthCheckSpecification {\n         originalLatencies && originalLatencies.each { isl, latency -> database.updateIslLatency(isl, latency) }\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n+\n+    @Tidy\n+    def \"Target flow path computation strategy is not applied immediately in case flow was updated partially\"() {\n+        given: \"Switch pair with two paths at least\"\n+        def swPair = topologyHelper.switchPairs.find { it.paths.size() >= 2 }\n+\n+        and: \"A flow with cost strategy\"\n+        def latencyStrategy = PathComputationStrategy.LATENCY.toString().toLowerCase()\n+        def costStrategy = PathComputationStrategy.COST.toString().toLowerCase()\n+        def flow = flowHelperV2.randomFlow(swPair).tap { it.pathComputationStrategy = costStrategy }\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update path computation strategy(cost -> latency) via partialUpdate\"\n+        northbound.partialUpdate(flow.flowId, new FlowPatchDto().tap {\n+            it.targetPathComputationStrategy = latencyStrategy\n+        })\n+        Wrappers.wait(WAIT_OFFSET / 2) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        then: \"Path computation strategy is not changed\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            pathComputationStrategy == costStrategy\n+            targetPathComputationStrategy == latencyStrategy\n+        }\n+\n+        and: \"Flow is valid\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        when: \"Sync the flow\"\n+        northbound.synchronizeFlow(flow.flowId)\n+\n+        then: \"Path computation strategy is updated and targetPathComputationStrategy is deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            pathComputationStrategy == latencyStrategy\n+            !targetPathComputationStrategy\n+        }\n+", "originalCommit": "a4283a3e0623a87da03fac8de25825f4b27877e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3NDE1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r403974152", "bodyText": "done", "author": "andriidovhan", "createdAt": "2020-04-06T10:05:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyNzc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzMDA3OA==", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r403930078", "bodyText": "What if latency and cost paths are the same? Will the update actually happen?", "author": "rtretyak", "createdAt": "2020-04-06T08:54:36Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathComputationSpec.groovy", "diffHunk": "@@ -102,4 +107,74 @@ class PathComputationSpec extends HealthCheckSpecification {\n         originalLatencies && originalLatencies.each { isl, latency -> database.updateIslLatency(isl, latency) }\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n+\n+    @Tidy\n+    def \"Target flow path computation strategy is not applied immediately in case flow was updated partially\"() {\n+        given: \"Switch pair with two paths at least\"\n+        def swPair = topologyHelper.switchPairs.find { it.paths.size() >= 2 }\n+\n+        and: \"A flow with cost strategy\"\n+        def latencyStrategy = PathComputationStrategy.LATENCY.toString().toLowerCase()\n+        def costStrategy = PathComputationStrategy.COST.toString().toLowerCase()\n+        def flow = flowHelperV2.randomFlow(swPair).tap { it.pathComputationStrategy = costStrategy }\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update path computation strategy(cost -> latency) via partialUpdate\"\n+        northbound.partialUpdate(flow.flowId, new FlowPatchDto().tap {\n+            it.targetPathComputationStrategy = latencyStrategy\n+        })\n+        Wrappers.wait(WAIT_OFFSET / 2) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        then: \"Path computation strategy is not changed\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            pathComputationStrategy == costStrategy\n+            targetPathComputationStrategy == latencyStrategy\n+        }\n+\n+        and: \"Flow is valid\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        when: \"Sync the flow\"\n+        northbound.synchronizeFlow(flow.flowId)\n+\n+        then: \"Path computation strategy is updated and targetPathComputationStrategy is deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            pathComputationStrategy == latencyStrategy\n+            !targetPathComputationStrategy\n+        }\n+\n+        when: \"Update path computation strategy(latency -> cost) via partialUpdate\"\n+        northbound.partialUpdate(flow.flowId, new FlowPatchDto().tap {\n+            it.targetPathComputationStrategy = costStrategy\n+        })\n+        Wrappers.wait(WAIT_OFFSET / 2) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Reroute the flow\"\n+        northboundV2.rerouteFlow(flow.flowId)", "originalCommit": "a4283a3e0623a87da03fac8de25825f4b27877e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk1Nzk2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r403957969", "bodyText": "it doesn't matter, the 'pathComputationStrategy'  will be updated anyway", "author": "andriidovhan", "createdAt": "2020-04-06T09:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzMDA3OA=="}], "type": "inlineReview"}, {"oid": "8f3b33a6b18bc5213468f4fc0c2fdac68e37269f", "url": "https://github.com/telstra/open-kilda/commit/8f3b33a6b18bc5213468f4fc0c2fdac68e37269f", "message": "add test for targetPathComputationStrategy", "committedDate": "2020-04-06T10:05:28Z", "type": "forcePushed"}, {"oid": "f576f45abd43a680c3155124e7c17a1de7a47069", "url": "https://github.com/telstra/open-kilda/commit/f576f45abd43a680c3155124e7c17a1de7a47069", "message": "add test for targetPathComputationStrategy", "committedDate": "2020-04-06T10:57:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ5NDAwOQ==", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r405494009", "bodyText": "Partial update of targetPathComputationStrategy should not cause a flow status change. Can you recheck this place please? I think these waits can be removed", "author": "rtretyak", "createdAt": "2020-04-08T12:42:34Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathComputationSpec.groovy", "diffHunk": "@@ -102,4 +107,88 @@ class PathComputationSpec extends HealthCheckSpecification {\n         originalLatencies && originalLatencies.each { isl, latency -> database.updateIslLatency(isl, latency) }\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n+\n+    @Tidy\n+    def \"Target flow path computation strategy is not applied immediately in case flow was updated partially\"() {\n+        given: \"Switch pair with two paths at least\"\n+        def swPair = topologyHelper.switchPairs.find { it.paths.size() >= 2 }\n+\n+        and: \"A flow with cost strategy\"\n+        def latencyStrategy = PathComputationStrategy.LATENCY.toString().toLowerCase()\n+        def costStrategy = PathComputationStrategy.COST.toString().toLowerCase()\n+        def flow = flowHelperV2.randomFlow(swPair).tap { it.pathComputationStrategy = costStrategy }\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update path computation strategy(cost -> latency) via partialUpdate\"\n+        northbound.partialUpdate(flow.flowId, new FlowPatchDto().tap {\n+            it.targetPathComputationStrategy = latencyStrategy\n+        })\n+        Wrappers.wait(WAIT_OFFSET / 2) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }", "originalCommit": "f576f45abd43a680c3155124e7c17a1de7a47069", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyODgyNw==", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r406728827", "bodyText": "you are completely right, fixed", "author": "andriidovhan", "createdAt": "2020-04-10T12:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ5NDAwOQ=="}], "type": "inlineReview"}, {"oid": "427a32d5031d7ca4abb025e2a2077fc05013750c", "url": "https://github.com/telstra/open-kilda/commit/427a32d5031d7ca4abb025e2a2077fc05013750c", "message": "add test for targetPathComputationStrategy", "committedDate": "2020-04-10T12:01:27Z", "type": "forcePushed"}, {"oid": "d10891f1cd954e48c23c1546862f9765bc558ad8", "url": "https://github.com/telstra/open-kilda/commit/d10891f1cd954e48c23c1546862f9765bc558ad8", "message": "add test for targetPathComputationStrategy", "committedDate": "2020-04-10T12:02:56Z", "type": "commit"}, {"oid": "d10891f1cd954e48c23c1546862f9765bc558ad8", "url": "https://github.com/telstra/open-kilda/commit/d10891f1cd954e48c23c1546862f9765bc558ad8", "message": "add test for targetPathComputationStrategy", "committedDate": "2020-04-10T12:02:56Z", "type": "forcePushed"}]}