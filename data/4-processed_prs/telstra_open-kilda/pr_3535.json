{"pr_number": 3535, "pr_title": "adjust func tests to work with full capability of qinq", "pr_createdAt": "2020-06-09T19:51:23Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3535", "timeline": [{"oid": "b62d86ea8afebf5346a3e74bb9247ad5a1c35fd3", "url": "https://github.com/telstra/open-kilda/commit/b62d86ea8afebf5346a3e74bb9247ad5a1c35fd3", "message": "Traffic counters in ingress/egress rules are reset on flow rerouting(multiTable mode)", "committedDate": "2020-06-10T13:51:52Z", "type": "forcePushed"}, {"oid": "ed8afb2ffa02820da4d12714baad5d55177f72d7", "url": "https://github.com/telstra/open-kilda/commit/ed8afb2ffa02820da4d12714baad5d55177f72d7", "message": "Traffic counters in ingress/egress rules are reset on flow rerouting(multiTable mode)", "committedDate": "2020-06-10T13:56:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1MjU4NA==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437952584", "bodyText": "very difficult verification. can you explain? If multitable is enabled we are not matching on vlan?", "author": "rtretyak", "createdAt": "2020-06-10T08:30:12Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy", "diffHunk": "@@ -946,7 +948,7 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n                 }.size() == 2\n                 def ingressRule = rules.find { it.cookie == flowInfoFromDb2.forwardPath.cookie.value }\n                 ingressRule.match.inPort == newPortNumber.toString()\n-                ingressRule.match.vlanVid == newVlanId.toString()\n+                isMultiTableEnabled ? !ingressRule.match.vlanVid : (ingressRule.match.vlanVid == newVlanId.toString())", "originalCommit": "48ba1725a6023fed378c197e5fd1540bdd80fefb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzMDM2MA==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r438630360", "bodyText": "vlan is matched in shared rule", "author": "andriidovhan", "createdAt": "2020-06-11T08:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1MjU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcwMDc3MA==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r438700770", "bodyText": "add a comment please", "author": "rtretyak", "createdAt": "2020-06-11T10:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1MjU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgxMjg3OQ==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r438812879", "bodyText": "added", "author": "andriidovhan", "createdAt": "2020-06-11T14:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1MjU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NTk3Ng==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437955976", "bodyText": "assert", "author": "rtretyak", "createdAt": "2020-06-10T08:35:47Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/MetersSpec.groovy", "diffHunk": "@@ -317,14 +319,43 @@ meters in flow rules at all (#data.flowType flow)\"() {\n         srcSwFlowMeters.size() == 1\n         dstSwFlowMeters.size() == 1\n \n-        def srcSwitchRules = northbound.getSwitchRules(flow.source.switchId).flowEntries\n-        def dstSwitchRules = northbound.getSwitchRules(flow.destination.switchId).flowEntries\n-        def srcSwFlowIngressRule = filterRules(srcSwitchRules, flow.source.portNumber, flow.source.vlanId, null)[0]\n-        def dstSwFlowIngressRule = filterRules(dstSwitchRules, flow.destination.portNumber, flow.destination.vlanId,\n-                null)[0]\n+        def srcSwitchRules = northbound.getSwitchRules(flow.source.switchId).flowEntries.findAll {  !Cookie.isDefaultRule(it.cookie) }\n+        def dstSwitchRules = northbound.getSwitchRules(flow.destination.switchId).flowEntries.findAll {  !Cookie.isDefaultRule(it.cookie) }\n \n-        srcSwFlowMeters[0].meterId == srcSwFlowIngressRule.instructions.goToMeter\n-        dstSwFlowMeters[0].meterId == dstSwFlowIngressRule.instructions.goToMeter\n+        if (northbound.getSwitchProperties(flow.source.switchId).multiTable) {\n+            def srcSwIngressFlowRules = srcSwitchRules.findAll { it.match.inPort == flow.source.portNumber.toString() }\n+            assert srcSwIngressFlowRules.size() == 2 //shared + simple ingress\n+            def srcSwIngressSharedRule = srcSwIngressFlowRules.find {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }\n+            def srcSwIngressNonSharedRule = srcSwIngressFlowRules.find {\n+                new Cookie(it.cookie).getType() != CookieType.SHARED_OF_FLOW\n+            }\n+            assert srcSwIngressSharedRule.match.vlanVid == flow.source.vlanId.toString()\n+            assert !srcSwIngressSharedRule.instructions.goToMeter\n+            assert srcSwFlowMeters[0].meterId == srcSwIngressNonSharedRule.instructions.goToMeter\n+        } else {\n+            def srcSwFlowIngressRule = filterRules(srcSwitchRules, flow.source.portNumber, flow.source.vlanId, null)[0]\n+            srcSwFlowMeters[0].meterId == srcSwFlowIngressRule.instructions.goToMeter\n+        }\n+\n+        if (northbound.getSwitchProperties(flow.destination.switchId).multiTable) {\n+            def dstSwIngressFlowRules = dstSwitchRules.findAll { it.match.inPort == flow.destination.portNumber.toString() }\n+            assert dstSwIngressFlowRules.size() == 2 //shared + simple ingress\n+            def dstSwIngressSharedRule = dstSwIngressFlowRules.find {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }\n+            def dstSwIngressNonSharedRule = dstSwIngressFlowRules.find {\n+                new Cookie(it.cookie).getType() != CookieType.SHARED_OF_FLOW\n+            }\n+            assert dstSwIngressSharedRule.match.vlanVid == flow.destination.vlanId.toString()\n+            assert !dstSwIngressSharedRule.instructions.goToMeter\n+            assert dstSwFlowMeters[0].meterId == dstSwIngressNonSharedRule.instructions.goToMeter\n+        } else {\n+            def dstSwFlowIngressRule = filterRules(dstSwitchRules, flow.destination.portNumber, flow.destination.vlanId,\n+                    null)[0]\n+            dstSwFlowMeters[0].meterId == dstSwFlowIngressRule.instructions.goToMeter", "originalCommit": "48ba1725a6023fed378c197e5fd1540bdd80fefb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzMTcwOA==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r438631708", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-06-11T08:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NjAyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437956025", "bodyText": "assert", "author": "rtretyak", "createdAt": "2020-06-10T08:35:51Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/MetersSpec.groovy", "diffHunk": "@@ -317,14 +319,43 @@ meters in flow rules at all (#data.flowType flow)\"() {\n         srcSwFlowMeters.size() == 1\n         dstSwFlowMeters.size() == 1\n \n-        def srcSwitchRules = northbound.getSwitchRules(flow.source.switchId).flowEntries\n-        def dstSwitchRules = northbound.getSwitchRules(flow.destination.switchId).flowEntries\n-        def srcSwFlowIngressRule = filterRules(srcSwitchRules, flow.source.portNumber, flow.source.vlanId, null)[0]\n-        def dstSwFlowIngressRule = filterRules(dstSwitchRules, flow.destination.portNumber, flow.destination.vlanId,\n-                null)[0]\n+        def srcSwitchRules = northbound.getSwitchRules(flow.source.switchId).flowEntries.findAll {  !Cookie.isDefaultRule(it.cookie) }\n+        def dstSwitchRules = northbound.getSwitchRules(flow.destination.switchId).flowEntries.findAll {  !Cookie.isDefaultRule(it.cookie) }\n \n-        srcSwFlowMeters[0].meterId == srcSwFlowIngressRule.instructions.goToMeter\n-        dstSwFlowMeters[0].meterId == dstSwFlowIngressRule.instructions.goToMeter\n+        if (northbound.getSwitchProperties(flow.source.switchId).multiTable) {\n+            def srcSwIngressFlowRules = srcSwitchRules.findAll { it.match.inPort == flow.source.portNumber.toString() }\n+            assert srcSwIngressFlowRules.size() == 2 //shared + simple ingress\n+            def srcSwIngressSharedRule = srcSwIngressFlowRules.find {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }\n+            def srcSwIngressNonSharedRule = srcSwIngressFlowRules.find {\n+                new Cookie(it.cookie).getType() != CookieType.SHARED_OF_FLOW\n+            }\n+            assert srcSwIngressSharedRule.match.vlanVid == flow.source.vlanId.toString()\n+            assert !srcSwIngressSharedRule.instructions.goToMeter\n+            assert srcSwFlowMeters[0].meterId == srcSwIngressNonSharedRule.instructions.goToMeter\n+        } else {\n+            def srcSwFlowIngressRule = filterRules(srcSwitchRules, flow.source.portNumber, flow.source.vlanId, null)[0]\n+            srcSwFlowMeters[0].meterId == srcSwFlowIngressRule.instructions.goToMeter", "originalCommit": "48ba1725a6023fed378c197e5fd1540bdd80fefb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzMTYzOQ==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r438631639", "bodyText": "thx, fixed", "author": "andriidovhan", "createdAt": "2020-06-11T08:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NjAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NzE4NQ==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437957185", "bodyText": "isMultitableEnabled is not an appropriate name for an integer value. As far as I understand it represents amount of rules", "author": "rtretyak", "createdAt": "2020-06-10T08:37:47Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchValidationSingleSwFlowSpec.groovy", "diffHunk": "@@ -124,8 +122,7 @@ class SwitchValidationSingleSwFlowSpec extends HealthCheckSpecification {\n         def sw = switches.first()\n \n         when: \"Create a flow\"\n-        def isMultitableEnabled = northbound.getSwitchProperties(sw.dpId).multiTable ?\n-                INGRESS_RULE_MULTI_TABLE_ID : SINGLE_TABLE_ID\n+        def isMultitableEnabled = northbound.getSwitchProperties(sw.dpId).multiTable ? 4 : 0", "originalCommit": "48ba1725a6023fed378c197e5fd1540bdd80fefb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzMjc1Ng==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r438632756", "bodyText": "agree, fixed\nisMultitableEnabled -> amountOfFlowRules", "author": "andriidovhan", "createdAt": "2020-06-11T08:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NzE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1ODY4MA==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437958680", "bodyText": "this should not be required", "author": "rtretyak", "createdAt": "2020-06-10T08:40:18Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchValidationSpec.groovy", "diffHunk": "@@ -328,31 +330,43 @@ misconfigured\"\n         and: \"Remove created meter on the srcSwitch\"\n         def forwardCookies = getCookiesWithMeter(srcSwitch.dpId)\n         def reverseCookies = getCookiesWithMeter(dstSwitch.dpId)\n+        def sharedCookieOnSrcSw = northbound.getSwitchRules(srcSwitch.dpId).flowEntries.find {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }?.cookie\n+        def untouchedCookiesOnSrcSw = northbound.getSwitchProperties(srcSwitch.dpId).multiTable ?\n+            (reverseCookies + sharedCookieOnSrcSw).sort() : reverseCookies\n+        def sharedCookieOnDstSw = northbound.getSwitchRules(dstSwitch.dpId).flowEntries.find {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }?.cookie\n+        def cookiesOnDstSw = northbound.getSwitchProperties(srcSwitch.dpId).multiTable ?\n+            (reverseCookies + forwardCookies + sharedCookieOnDstSw) : (reverseCookies + forwardCookies)\n         northbound.deleteMeter(srcSwitch.dpId, srcSwitchCreatedMeterIds[0])\n \n         then: \"Meters info/rules are moved into the 'missing' section on the srcSwitch\"\n-        verifyAll(northbound.validateSwitch(srcSwitch.dpId)) {\n-            it.rules.missing == forwardCookies\n-            it.rules.proper.findAll { !Cookie.isDefaultRule(it) } == reverseCookies//forward cookie's removed with meter\n-\n-            it.meters.missing*.meterId == srcSwitchCreatedMeterIds\n-            it.meters.missing*.cookie == forwardCookies\n-\n-            Long srcSwitchBurstSize = switchHelper.getExpectedBurst(srcSwitch.dpId, flow.maximumBandwidth)\n-            it.meters.missing.each {\n-                assert it.rate == flow.maximumBandwidth\n-                assert it.flowId == flow.flowId\n-                assert [\"KBPS\", \"BURST\", \"STATS\"].containsAll(it.flags)\n-                switchHelper.verifyBurstSizeIsCorrect(srcSwitch, srcSwitchBurstSize, it.burstSize)\n+        Wrappers.wait(RULES_DELETION_TIME) {", "originalCommit": "48ba1725a6023fed378c197e5fd1540bdd80fefb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MzAzNA==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r438663034", "bodyText": "removed\nI thought it is legal wait for deleting rule", "author": "andriidovhan", "createdAt": "2020-06-11T09:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1ODY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk2NDA5MQ==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437964091", "bodyText": "round brackets unnecessary", "author": "rtretyak", "createdAt": "2020-06-10T08:49:01Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchValidationSpec.groovy", "diffHunk": "@@ -328,31 +330,43 @@ misconfigured\"\n         and: \"Remove created meter on the srcSwitch\"\n         def forwardCookies = getCookiesWithMeter(srcSwitch.dpId)\n         def reverseCookies = getCookiesWithMeter(dstSwitch.dpId)\n+        def sharedCookieOnSrcSw = northbound.getSwitchRules(srcSwitch.dpId).flowEntries.find {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }?.cookie\n+        def untouchedCookiesOnSrcSw = northbound.getSwitchProperties(srcSwitch.dpId).multiTable ?\n+            (reverseCookies + sharedCookieOnSrcSw).sort() : reverseCookies\n+        def sharedCookieOnDstSw = northbound.getSwitchRules(dstSwitch.dpId).flowEntries.find {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }?.cookie\n+        def cookiesOnDstSw = northbound.getSwitchProperties(srcSwitch.dpId).multiTable ?\n+            (reverseCookies + forwardCookies + sharedCookieOnDstSw) : (reverseCookies + forwardCookies)\n         northbound.deleteMeter(srcSwitch.dpId, srcSwitchCreatedMeterIds[0])\n \n         then: \"Meters info/rules are moved into the 'missing' section on the srcSwitch\"\n-        verifyAll(northbound.validateSwitch(srcSwitch.dpId)) {\n-            it.rules.missing == forwardCookies\n-            it.rules.proper.findAll { !Cookie.isDefaultRule(it) } == reverseCookies//forward cookie's removed with meter\n-\n-            it.meters.missing*.meterId == srcSwitchCreatedMeterIds\n-            it.meters.missing*.cookie == forwardCookies\n-\n-            Long srcSwitchBurstSize = switchHelper.getExpectedBurst(srcSwitch.dpId, flow.maximumBandwidth)\n-            it.meters.missing.each {\n-                assert it.rate == flow.maximumBandwidth\n-                assert it.flowId == flow.flowId\n-                assert [\"KBPS\", \"BURST\", \"STATS\"].containsAll(it.flags)\n-                switchHelper.verifyBurstSizeIsCorrect(srcSwitch, srcSwitchBurstSize, it.burstSize)\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            verifyAll(northbound.validateSwitch(srcSwitch.dpId)) {\n+                it.rules.missing.sort() == forwardCookies\n+                it.rules.proper.findAll { !Cookie.isDefaultRule(it) }.sort() == untouchedCookiesOnSrcSw//forward cookie's removed with meter\n+\n+                it.meters.missing*.meterId == srcSwitchCreatedMeterIds\n+                it.meters.missing*.cookie == forwardCookies\n+\n+                Long srcSwitchBurstSize = switchHelper.getExpectedBurst(srcSwitch.dpId, flow.maximumBandwidth)\n+                it.meters.missing.each {\n+                    assert it.rate == flow.maximumBandwidth\n+                    assert it.flowId == flow.flowId\n+                    assert [\"KBPS\", \"BURST\", \"STATS\"].containsAll(it.flags)\n+                    switchHelper.verifyBurstSizeIsCorrect(srcSwitch, srcSwitchBurstSize, it.burstSize)\n+                }\n+                switchHelper.verifyMeterSectionsAreEmpty(it, [\"proper\", \"misconfigured\", \"excess\"])\n+                switchHelper.verifyRuleSectionsAreEmpty(it, [\"excess\"])\n             }\n-            switchHelper.verifyMeterSectionsAreEmpty(it, [\"proper\", \"misconfigured\", \"excess\"])\n-            switchHelper.verifyRuleSectionsAreEmpty(it, [\"excess\"])\n         }\n \n         and: \"Meters info/rules are NOT moved into the 'missing' section on the dstSwitch\"\n         verifyAll(northbound.validateSwitch(dstSwitch.dpId)) {\n-            it.rules.proper.findAll { !Cookie.isDefaultRule(it) }.size() == 2\n-            it.rules.proper.containsAll(forwardCookies + reverseCookies)\n+            it.rules.proper.findAll { !Cookie.isDefaultRule(it) }.size() == (cookiesOnDstSw).size()", "originalCommit": "48ba1725a6023fed378c197e5fd1540bdd80fefb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzMzQ4Mg==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r438633482", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-06-11T08:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk2NDA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk2NTQ0Mg==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437965442", "bodyText": "Since you are already changing this place, better remove deprecated usage:\ndef cookie = new Cookie(it)\ncookie.getServiceFlag() || cookie.getType() == CookieType.SHARED_OF_FLOW", "author": "rtretyak", "createdAt": "2020-06-10T08:51:12Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchValidationSpec.groovy", "diffHunk": "@@ -410,9 +424,16 @@ misconfigured\"\n         northbound.deleteSwitchRules(srcSwitch.dpId, ingressCookie)\n \n         then: \"Ingress rule is moved into the 'missing' section on the srcSwitch\"\n+        def sharedCookieOnSrcSw = northbound.getSwitchRules(srcSwitch.dpId).flowEntries.find {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }?.cookie\n+        def untouchedCookies = northbound.getSwitchProperties(srcSwitch.dpId).multiTable ?\n+            [egressCookie, sharedCookieOnSrcSw].sort() : [egressCookie]\n         verifyAll(northbound.validateSwitch(srcSwitch.dpId)) {\n             it.rules.missing == [ingressCookie]\n-            it.rules.proper.findAll { !Cookie.isDefaultRule(it) } == [egressCookie]\n+            it.rules.proper.findAll {\n+                !Cookie.isDefaultRule(it) || new Cookie(it).getType() == CookieType.SHARED_OF_FLOW", "originalCommit": "48ba1725a6023fed378c197e5fd1540bdd80fefb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzNDU0OQ==", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r438634549", "bodyText": "fixed in whole spec and PR", "author": "andriidovhan", "createdAt": "2020-06-11T08:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk2NTQ0Mg=="}], "type": "inlineReview"}, {"oid": "dcd7aadcf55f78721b400e95abb964ad6b1a1bcc", "url": "https://github.com/telstra/open-kilda/commit/dcd7aadcf55f78721b400e95abb964ad6b1a1bcc", "message": "adjust func tests to work with full capability of qinq", "committedDate": "2020-06-11T11:05:04Z", "type": "commit"}, {"oid": "dcd7aadcf55f78721b400e95abb964ad6b1a1bcc", "url": "https://github.com/telstra/open-kilda/commit/dcd7aadcf55f78721b400e95abb964ad6b1a1bcc", "message": "adjust func tests to work with full capability of qinq", "committedDate": "2020-06-11T11:05:04Z", "type": "forcePushed"}]}