{"pr_number": 3493, "pr_title": "Northbound V1 requests redirected to FlowHSTopology", "pr_createdAt": "2020-05-21T12:56:17Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3493", "timeline": [{"oid": "2baceb065a956949172d61f26515fb46cf0d6191", "url": "https://github.com/telstra/open-kilda/commit/2baceb065a956949172d61f26515fb46cf0d6191", "message": "Northbound V1 requests redirected to FlowHSTopology", "committedDate": "2020-05-22T07:42:44Z", "type": "commit"}, {"oid": "2baceb065a956949172d61f26515fb46cf0d6191", "url": "https://github.com/telstra/open-kilda/commit/2baceb065a956949172d61f26515fb46cf0d6191", "message": "Northbound V1 requests redirected to FlowHSTopology", "committedDate": "2020-05-22T07:42:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE5NTMwMw==", "url": "https://github.com/telstra/open-kilda/pull/3493#discussion_r429195303", "bodyText": "(nip) Why not include whole request payload (same as flow create do)?", "author": "surabujin", "createdAt": "2020-05-22T11:34:35Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/service/impl/FlowServiceImpl.java", "diffHunk": "@@ -244,22 +233,24 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    public CompletableFuture<FlowResponsePayload> updateFlow(final FlowUpdatePayload input) {\n+    public CompletableFuture<FlowResponsePayload> updateFlow(final FlowUpdatePayload request) {\n+        logger.info(\"Update flow request for flow {}\", request.getId());", "originalCommit": "2baceb065a956949172d61f26515fb46cf0d6191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMTY3OQ==", "url": "https://github.com/telstra/open-kilda/pull/3493#discussion_r429201679", "bodyText": "What about logging here?", "author": "surabujin", "createdAt": "2020-05-22T11:50:48Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/service/impl/FlowServiceImpl.java", "diffHunk": "@@ -386,7 +377,7 @@\n     private CompletableFuture<FlowResponsePayload> sendDeleteFlow(String flowId, String correlationId) {", "originalCommit": "2baceb065a956949172d61f26515fb46cf0d6191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMjU4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3493#discussion_r429202583", "bodyText": "Yey!!! At last!", "author": "surabujin", "createdAt": "2020-05-22T11:52:57Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/service/impl/FlowServiceImpl.java", "diffHunk": "@@ -499,9 +490,9 @@ private FlowPathPayload buildFlowPathPayload(List<FlowPathDto> paths, String flo\n     @Override\n     public CompletableFuture<BatchResults> unpushFlows(List<FlowInfoData> externalFlows, Boolean propagate,\n                                                        Boolean verify) {\n-        FlowOperation op = (propagate) ? FlowOperation.UNPUSH_PROPAGATE : FlowOperation.UNPUSH;\n-        // TODO: ADD the VERIFY implementation\n-        return flowPushUnpush(externalFlows, op);\n+        String correlationId = RequestCorrelationId.getId();\n+        throw new MessageException(correlationId, System.currentTimeMillis(), ErrorType.NOT_PERMITTED,", "originalCommit": "2baceb065a956949172d61f26515fb46cf0d6191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwNjIxOQ==", "url": "https://github.com/telstra/open-kilda/pull/3493#discussion_r429206219", "bodyText": "One more time - YEY!", "author": "surabujin", "createdAt": "2020-05-22T12:02:05Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/service/impl/FlowServiceImpl.java", "diffHunk": "@@ -510,9 +501,9 @@ private FlowPathPayload buildFlowPathPayload(List<FlowPathDto> paths, String flo\n     @Override\n     public CompletableFuture<BatchResults> pushFlows(List<FlowInfoData> externalFlows,\n                                                      Boolean propagate, Boolean verify) {\n-        FlowOperation op = (propagate) ? FlowOperation.PUSH_PROPAGATE : FlowOperation.PUSH;\n-        // TODO: ADD the VERIFY implementation\n-        return flowPushUnpush(externalFlows, op);\n+        String correlationId = RequestCorrelationId.getId();\n+        throw new MessageException(correlationId, System.currentTimeMillis(), ErrorType.NOT_PERMITTED,", "originalCommit": "2baceb065a956949172d61f26515fb46cf0d6191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwODAzOQ==", "url": "https://github.com/telstra/open-kilda/pull/3493#discussion_r429208039", "bodyText": "Why we do not check switch rules now?", "author": "surabujin", "createdAt": "2020-05-22T12:06:38Z", "path": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/FlowHelper.groovy", "diffHunk": "@@ -130,16 +130,7 @@ class FlowHelper {\n     FlowPayload addFlow(FlowPayload flow) {\n         log.debug(\"Adding flow '${flow.id}'\")\n         def response = northbound.addFlow(flow)\n-\n-        def flowEntry = null\n-        Wrappers.wait(WAIT_OFFSET) {\n-            assert northbound.getFlowStatus(flow.id).status == FlowState.UP\n-\n-            flowEntry = db.getFlow(flow.id)\n-            assert flowEntry\n-        }\n-        checkRulesOnSwitches(flowEntry, RULES_INSTALLATION_TIME, true)", "originalCommit": "2baceb065a956949172d61f26515fb46cf0d6191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MTY3NA==", "url": "https://github.com/telstra/open-kilda/pull/3493#discussion_r429791674", "bodyText": "previously in v1 system was not able to guarantee rules installation before setting the flow to UP, so we had to wait for them ourselves after creating each flow. In h&s now we don't have to do this for each flow, since it is checked by the system. Instead, we have a separate test that verifies that system checks this correctly for us", "author": "rtretyak", "createdAt": "2020-05-25T08:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwODAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwODQ4NA==", "url": "https://github.com/telstra/open-kilda/pull/3493#discussion_r429208484", "bodyText": "Same here", "author": "surabujin", "createdAt": "2020-05-22T12:07:41Z", "path": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/FlowHelper.groovy", "diffHunk": "@@ -148,20 +139,10 @@ class FlowHelper {\n      * It is supposed if rules absent on source and destination switches, the flow is completely deleted.\n      */\n     FlowPayload deleteFlow(String flowId) {\n-        deleteFlow(flowId, false)\n-    }\n-\n-    FlowPayload deleteFlow(String flowId, boolean verifyMeters) {\n-        def flowEntry = db.getFlow(flowId)\n-\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flowId).status != FlowState.IN_PROGRESS }\n         log.debug(\"Deleting flow '$flowId'\")\n         def response = northbound.deleteFlow(flowId)\n-\n-        checkRulesOnSwitches(flowEntry, RULES_DELETION_TIME, false)", "originalCommit": "2baceb065a956949172d61f26515fb46cf0d6191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwODY0Nw==", "url": "https://github.com/telstra/open-kilda/pull/3493#discussion_r429208647", "bodyText": "And here.", "author": "surabujin", "createdAt": "2020-05-22T12:08:01Z", "path": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/FlowHelper.groovy", "diffHunk": "@@ -170,18 +151,9 @@ class FlowHelper {\n      * It is supposed if rules are installed on source and destination switches, the flow is completely updated.\n      */\n     FlowPayload updateFlow(String flowId, FlowPayload flow) {\n-        def flowEntryBeforeUpdate = db.getFlow(flowId)\n-\n-        log.debug(\"Updating flow '${flow.id}'\")\n+        log.debug(\"Updating flow '${flowId}'\")\n         def response = northbound.updateFlow(flowId, flow)\n-        Wrappers.wait(PATH_INSTALLATION_TIME) { assert northbound.getFlowStatus(flow.id).status == FlowState.UP }\n-\n-        def flowEntryAfterUpdate = db.getFlow(flowId)\n-\n-        // TODO(ylobankov): Delete check for rules installation once we add a new test to verify this functionality.\n-        checkRulesOnSwitches(flowEntryAfterUpdate, RULES_INSTALLATION_TIME, true)", "originalCommit": "2baceb065a956949172d61f26515fb46cf0d6191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMTU0MQ==", "url": "https://github.com/telstra/open-kilda/pull/3493#discussion_r429801541", "bodyText": "there will be a lot of conflicts with #3432 =(", "author": "rtretyak", "createdAt": "2020-05-25T08:24:33Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudSpec.groovy", "diffHunk": "@@ -1077,14 +1129,38 @@ class FlowCrudSpec extends HealthCheckSpecification {\n                             flowToConflict.destination.vlanId = 0\n                             dominantFlow.destination.vlanId = 0\n                         },\n-                        getError            : { FlowPayload dominantFlow, FlowPayload flowToConflict,\n-                                                String operation = \"create\" ->\n-                            errorMessage(operation, dominantFlow, \"destination\", flowToConflict, \"destination\")\n+                        getErrorMessage            : { FlowPayload dominantFlow, FlowPayload flowToConflict,\n+                                                       String operation = \"create\" ->\n+                            \"Could not $operation flow\"\n+                        },\n+                        getErrorDescription        : { FlowPayload dominantFlow, FlowPayload flowToConflict,\n+                                                       String operation = \"create\" ->\n+                            errorDescription(operation, dominantFlow, \"destination\", flowToConflict, \"destination\")\n                         }\n                 ]\n         ]\n     }\n \n+    @Shared\n+    def errorDescription = { String operation, FlowPayload flow, String endpoint, FlowPayload conflictingFlow,\n+                             String conflictingEndpoint ->\n+        def message = \"Requested flow '$conflictingFlow.id' \" +\n+                \"conflicts with existing flow '$flow.id'. \" +\n+                \"Details: requested flow '$conflictingFlow.id' $conflictingEndpoint: \" +\n+                \"switchId=\\\"${conflictingFlow.\"$conflictingEndpoint\".datapath}\\\" \" +\n+                \"port=${conflictingFlow.\"$conflictingEndpoint\".portNumber}\"\n+        if (0 < conflictingFlow.\"$conflictingEndpoint\".vlanId) {\n+            message += \" vlanId=${conflictingFlow.\"$conflictingEndpoint\".vlanId}\";\n+        }\n+        message += \", existing flow '$flow.id' $endpoint: \" +\n+                \"switchId=\\\"${flow.\"$endpoint\".datapath}\\\" \" +\n+                \"port=${flow.\"$endpoint\".portNumber}\"\n+        if (0 < flow.\"$endpoint\".vlanId) {\n+            message += \" vlanId=${flow.\"$endpoint\".vlanId}\"\n+        }\n+        return message\n+    }\n+\n     private static Message buildMessage(final CommandData data) {", "originalCommit": "2baceb065a956949172d61f26515fb46cf0d6191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}