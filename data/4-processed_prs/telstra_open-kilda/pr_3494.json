{"pr_number": 3494, "pr_title": "Add tests for partial update v2 api", "pr_createdAt": "2020-05-21T13:48:51Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3494", "timeline": [{"oid": "23971f2acdf8baac58695280fbdac0cab276c780", "url": "https://github.com/telstra/open-kilda/commit/23971f2acdf8baac58695280fbdac0cab276c780", "message": "Add tests for partial update v2 api", "committedDate": "2020-05-22T14:41:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMTg1OA==", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429801858", "bodyText": "looks like it is needless", "author": "andriidovhan", "createdAt": "2020-05-25T08:25:07Z", "path": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/FlowHelper.groovy", "diffHunk": "@@ -17,6 +17,7 @@ import org.openkilda.messaging.payload.flow.FlowEndpointPayload\n import org.openkilda.messaging.payload.flow.FlowPayload\n import org.openkilda.messaging.payload.flow.FlowState\n import org.openkilda.model.Flow\n+import org.openkilda.northbound.dto.v1.flows.FlowPatchDto", "originalCommit": "23971f2acdf8baac58695280fbdac0cab276c780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0OTcyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429949725", "bodyText": "@Tidy?", "author": "andriidovhan", "createdAt": "2020-05-25T13:59:09Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -61,6 +137,74 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         ]\n     }\n \n+    @Tidy\n+    @Unroll\n+    def \"Able to partially update flow #data.field which causes a reroute\"() {\n+        given: \"A flow\"\n+        def swPair = topologyHelper.switchPairs.first()\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        def originalCookies = northbound.getSwitchRules(swPair.src.dpId).flowEntries.findAll { !Cookie.isDefaultRule(it.cookie) }\n+\n+        when: \"Request a flow partial update for a #field field\"\n+        def newValue = data.getNewValue(flow.\"$data.field\")\n+        def updateRequest = new FlowPatchV2().tap { it.\"$data.field\" = newValue }\n+        def response = flowHelperV2.partialUpdate(flow.flowId, updateRequest)\n+\n+        then: \"Update response reflects the changes\"\n+        response.\"$data.field\" == newValue\n+\n+        and: \"Changes actually took place\"\n+        northboundV2.getFlow(flow.flowId).\"$data.field\" == newValue\n+\n+        and: \"Flow rules have been reinstalled\"\n+        !northbound.getSwitchRules(swPair.src.dpId).flowEntries.findAll {\n+            !Cookie.isDefaultRule(it.cookie)\n+        }.any { it in originalCookies }\n+\n+        cleanup: \"Remove the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        where:\n+        data << [\n+                [\n+                        field   : \"maximumBandwidth\",\n+                        getNewValue: { it + 100 }\n+                ],\n+                [\n+                        field   : \"allocateProtectedPath\",\n+                        getNewValue: { !it }\n+                ]\n+        ]\n+    }\n+\n+    def \"Able to turn on diversity feature using partial update\"() {", "originalCommit": "23971f2acdf8baac58695280fbdac0cab276c780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk1NzIyNA==", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429957224", "bodyText": "#data.field ?", "author": "andriidovhan", "createdAt": "2020-05-25T14:14:22Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -24,6 +51,55 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n             Cookie.isIngressRulePassThrough(it.cookie) || !Cookie.isDefaultRule(it.cookie)\n         }*.cookie\n \n+        when: \"Request a flow partial update for a #field field\"", "originalCommit": "23971f2acdf8baac58695280fbdac0cab276c780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2MTE1OA==", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429961158", "bodyText": "#data.field ?", "author": "andriidovhan", "createdAt": "2020-05-25T14:22:31Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -61,6 +137,74 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         ]\n     }\n \n+    @Tidy\n+    @Unroll\n+    def \"Able to partially update flow #data.field which causes a reroute\"() {\n+        given: \"A flow\"\n+        def swPair = topologyHelper.switchPairs.first()\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        def originalCookies = northbound.getSwitchRules(swPair.src.dpId).flowEntries.findAll { !Cookie.isDefaultRule(it.cookie) }\n+\n+        when: \"Request a flow partial update for a #field field\"", "originalCommit": "23971f2acdf8baac58695280fbdac0cab276c780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2MzA3MQ==", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429963071", "bodyText": "@Tidy ?", "author": "andriidovhan", "createdAt": "2020-05-25T14:26:34Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -89,7 +233,134 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         flowHelperV2.deleteFlow(flow.flowId)\n     }\n \n-    def \"Partial update with empty body does not actually update flow in any way\"() {\n+    @Tidy\n+    def \"Able to update a flow endpoint using partial update\"() {\n+        given: \"Three active switches\"\n+        def allSwitches = topology.activeSwitches\n+        assumeTrue(\"Unable to find three active switches\", allSwitches.size() >= 3)\n+        def srcSwitch = allSwitches[0]\n+        def dstSwitch = allSwitches[1]\n+\n+        and: \"A vlan flow\"\n+        def flow = flowHelperV2.randomFlow(srcSwitch, dstSwitch, false)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update the flow: port number and vlan id on the src endpoint\"\n+        def flowInfoFromDb1 = database.getFlow(flow.flowId)\n+        def newPortNumber = topology.getAllowedPortsForSwitch(topology.activeSwitches.find {\n+            it.dpId == flow.source.switchId\n+        }).last()\n+        def newVlanId = flow.destination.vlanId + 1\n+        flowHelperV2.partialUpdate(flow.flowId, new FlowPatchV2().tap {\n+            source = new FlowPatchEndpoint().tap {\n+                portNumber = newPortNumber\n+                vlanId = newVlanId\n+            }\n+        })\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == newPortNumber\n+            it.source.vlanId == newVlanId\n+        }\n+\n+        and: \"Flow rules are recreated\"\n+        def flowInfoFromDb2 = database.getFlow(flow.flowId)\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            with(northbound.getSwitchRules(srcSwitch.dpId).flowEntries.findAll {\n+                !Cookie.isDefaultRule(it.cookie)\n+            }) { rules ->\n+                rules.findAll {\n+                    it.cookie in [flowInfoFromDb1.forwardPath.cookie.value, flowInfoFromDb1.reversePath.cookie.value]\n+                }.empty\n+                rules.findAll {\n+                    it.cookie in [flowInfoFromDb2.forwardPath.cookie.value, flowInfoFromDb2.reversePath.cookie.value]\n+                }.size() == 2\n+                def ingressRule = rules.find { it.cookie == flowInfoFromDb2.forwardPath.cookie.value }\n+                ingressRule.match.inPort == newPortNumber.toString()\n+                ingressRule.match.vlanVid == newVlanId.toString()\n+            }\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"The src switch passes switch validation\"\n+        with(northbound.validateSwitch(srcSwitch.dpId)) { validation ->\n+            validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+        def srcSwitchIsFine = true\n+\n+        when: \"Update the flow: switch id on the dst endpoint\"\n+        def newDstSwitch = allSwitches[2]\n+        flowHelperV2.partialUpdate(flow.flowId, new FlowPatchV2().tap {\n+            destination = new FlowPatchEndpoint().tap {\n+                switchId = newDstSwitch.dpId\n+                portNumber = newPortNumber\n+            }\n+        })\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.destination.switchId == newDstSwitch.dpId\n+        }\n+\n+        and: \"Flow rules are removed from the old dst switch\"\n+        def flowInfoFromDb3 = database.getFlow(flow.flowId)\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            with(northbound.getSwitchRules(dstSwitch.dpId).flowEntries.findAll {\n+                !Cookie.isDefaultRule(it.cookie)\n+            }) { rules ->\n+                rules.findAll {\n+                    it.cookie in [flowInfoFromDb2.forwardPath.cookie.value, flowInfoFromDb2.reversePath.cookie.value]\n+                }.empty\n+            }\n+        }\n+\n+        and: \"Flow rules are installed on the new dst switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            with(northbound.getSwitchRules(newDstSwitch.dpId).flowEntries.findAll {\n+                !Cookie.isDefaultRule(it.cookie)\n+            }) { rules ->\n+                rules.findAll {\n+                    it.cookie in [flowInfoFromDb3.forwardPath.cookie.value, flowInfoFromDb3.reversePath.cookie.value]\n+                }.size() == 2\n+            }\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"The new and old dst switches pass switch validation\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            [dstSwitch, newDstSwitch]*.dpId.each { switchId ->\n+                with(northbound.validateSwitch(switchId)) { validation ->\n+                    validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                    validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                }\n+            }\n+        }\n+        def dstSwitchesAreFine = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !srcSwitchIsFine && northbound.synchronizeSwitch(srcSwitch.dpId, true)\n+        !dstSwitchesAreFine && dstSwitch && newDstSwitch && [dstSwitch, newDstSwitch]*.dpId.each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+    }\n+\n+    @Tags([LOW_PRIORITY])", "originalCommit": "23971f2acdf8baac58695280fbdac0cab276c780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2NDM2MA==", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429964360", "bodyText": "@Tidy ?", "author": "andriidovhan", "createdAt": "2020-05-25T14:29:04Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -113,4 +384,213 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         cleanup: \"Remove the flow\"\n         flowHelperV2.deleteFlow(flow.flowId)\n     }\n+\n+    def \"Partial update with empty body does not actually update flow in any way\"() {", "originalCommit": "23971f2acdf8baac58695280fbdac0cab276c780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2NjYzNA==", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429966634", "bodyText": "in some test you use error.statusCode instead of exc.rawStatusCode\nas for me would be great to use the same verification everywhere\nfor example in this case  error.statusCode == HttpStatus.BAD_REQUEST", "author": "andriidovhan", "createdAt": "2020-05-25T14:33:54Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -113,4 +384,213 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         cleanup: \"Remove the flow\"\n         flowHelperV2.deleteFlow(flow.flowId)\n     }\n+\n+    def \"Partial update with empty body does not actually update flow in any way\"() {\n+        given: \"A flow\"\n+        def swPair = topologyHelper.switchPairs.first()\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        def originalCookies = northbound.getSwitchRules(swPair.src.dpId).flowEntries.findAll {\n+            Cookie.isIngressRulePassThrough(it.cookie) || !Cookie.isDefaultRule(it.cookie)\n+        }*.cookie\n+\n+        when: \"Request a flow partial update without specifying any fields\"\n+        def flowBeforeUpdate = northboundV2.getFlow(flow.flowId)\n+        northboundV2.partialUpdate(flow.flowId, new FlowPatchV2())\n+\n+        then: \"Flow is left intact\"\n+        expect northboundV2.getFlow(flow.flowId), sameBeanAs(flowBeforeUpdate)\n+                .ignoring(\"lastUpdated\")\n+                .ignoring(\"diverseWith\")\n+\n+        and: \"Flow rules have not been reinstalled\"\n+        northbound.getSwitchRules(swPair.src.dpId).flowEntries*.cookie.containsAll(originalCookies)\n+\n+        cleanup: \"Remove the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Unroll\n+    def \"Unable to partial update a flow in case new port is an isl port on a #data.switchType switch\"() {\n+        given: \"An isl\"\n+        Isl isl = topology.islsForActiveSwitches.find { it.aswitch && it.dstSwitch }\n+        assumeTrue(\"Unable to find required isl\", isl as boolean)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(isl.srcSwitch, isl.dstSwitch)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Try to edit port to isl port\"\n+        northboundV2.partialUpdate(flow.flowId, new FlowPatchV2().tap {\n+            it.\"$data.switchType\" = new FlowPatchEndpoint().tap { it.portNumber = isl.\"$data.port\" }\n+        })\n+\n+        then: \"Error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.rawStatusCode == 400", "originalCommit": "23971f2acdf8baac58695280fbdac0cab276c780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk3Mzk0Nw==", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429973947", "bodyText": "To tell the truth I am afraid when the qinq feature is merged this verification can be really difficult\nHow about checking that flow allows traffic instead of checking specific fields in rules?\nI am not insist", "author": "andriidovhan", "createdAt": "2020-05-25T14:49:44Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -89,7 +233,134 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         flowHelperV2.deleteFlow(flow.flowId)\n     }\n \n-    def \"Partial update with empty body does not actually update flow in any way\"() {\n+    @Tidy\n+    def \"Able to update a flow endpoint using partial update\"() {\n+        given: \"Three active switches\"\n+        def allSwitches = topology.activeSwitches\n+        assumeTrue(\"Unable to find three active switches\", allSwitches.size() >= 3)\n+        def srcSwitch = allSwitches[0]\n+        def dstSwitch = allSwitches[1]\n+\n+        and: \"A vlan flow\"\n+        def flow = flowHelperV2.randomFlow(srcSwitch, dstSwitch, false)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update the flow: port number and vlan id on the src endpoint\"\n+        def flowInfoFromDb1 = database.getFlow(flow.flowId)\n+        def newPortNumber = topology.getAllowedPortsForSwitch(topology.activeSwitches.find {\n+            it.dpId == flow.source.switchId\n+        }).last()\n+        def newVlanId = flow.destination.vlanId + 1\n+        flowHelperV2.partialUpdate(flow.flowId, new FlowPatchV2().tap {\n+            source = new FlowPatchEndpoint().tap {\n+                portNumber = newPortNumber\n+                vlanId = newVlanId\n+            }\n+        })\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == newPortNumber\n+            it.source.vlanId == newVlanId\n+        }\n+\n+        and: \"Flow rules are recreated\"\n+        def flowInfoFromDb2 = database.getFlow(flow.flowId)\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            with(northbound.getSwitchRules(srcSwitch.dpId).flowEntries.findAll {\n+                !Cookie.isDefaultRule(it.cookie)\n+            }) { rules ->\n+                rules.findAll {", "originalCommit": "23971f2acdf8baac58695280fbdac0cab276c780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d2f26d8456dccb3e0e07faf74ad44e94c799021d", "url": "https://github.com/telstra/open-kilda/commit/d2f26d8456dccb3e0e07faf74ad44e94c799021d", "message": "Add tests for partial update v2 api", "committedDate": "2020-05-26T11:35:30Z", "type": "forcePushed"}, {"oid": "aece295fc8164c67cbb7115565646d5fed015cf4", "url": "https://github.com/telstra/open-kilda/commit/aece295fc8164c67cbb7115565646d5fed015cf4", "message": "Add tests for partial update v2 api", "committedDate": "2020-05-26T13:50:58Z", "type": "forcePushed"}, {"oid": "b80bd7acfbcf5c5a44340d02142aad7b692d1895", "url": "https://github.com/telstra/open-kilda/commit/b80bd7acfbcf5c5a44340d02142aad7b692d1895", "message": "Add tests for partial update v2 api", "committedDate": "2020-05-27T11:08:26Z", "type": "forcePushed"}, {"oid": "5898ac34011cb3dd96e112c3b9501f0475ef989c", "url": "https://github.com/telstra/open-kilda/commit/5898ac34011cb3dd96e112c3b9501f0475ef989c", "message": "Add tests for partial update v2 api", "committedDate": "2020-05-27T13:02:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MjYxNA==", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r430862614", "bodyText": "I guess this test can be marked as @Tidy", "author": "andriidovhan", "createdAt": "2020-05-27T05:20:11Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -113,4 +363,214 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         cleanup: \"Remove the flow\"\n         flowHelperV2.deleteFlow(flow.flowId)\n     }\n+\n+    def \"Partial update with empty body does not actually update flow in any way\"() {", "originalCommit": "aece295fc8164c67cbb7115565646d5fed015cf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "496b32cb20275233c6a477f1e35cea5ce27b2031", "url": "https://github.com/telstra/open-kilda/commit/496b32cb20275233c6a477f1e35cea5ce27b2031", "message": "Add tests for partial update v2 api", "committedDate": "2020-05-29T07:52:32Z", "type": "commit"}, {"oid": "496b32cb20275233c6a477f1e35cea5ce27b2031", "url": "https://github.com/telstra/open-kilda/commit/496b32cb20275233c6a477f1e35cea5ce27b2031", "message": "Add tests for partial update v2 api", "committedDate": "2020-05-29T07:52:32Z", "type": "forcePushed"}]}