{"pr_number": 3874, "pr_title": "extend connected\u0412evices spec", "pr_createdAt": "2020-11-24T15:09:03Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3874", "timeline": [{"oid": "20ab054681584ce927338426bb893dbe70e5c927", "url": "https://github.com/telstra/open-kilda/commit/20ab054681584ce927338426bb893dbe70e5c927", "message": "improve \"Able to detect devices on free switch port (no flow or isl)\"", "committedDate": "2020-11-24T11:49:19Z", "type": "commit"}, {"oid": "31e535a1a3e97131d6ad52f7020976e706ae348f", "url": "https://github.com/telstra/open-kilda/commit/31e535a1a3e97131d6ad52f7020976e706ae348f", "message": "extend ConnectedDevicesSpec", "committedDate": "2020-11-24T15:00:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3ODU3MA==", "url": "https://github.com/telstra/open-kilda/pull/3874#discussion_r531478570", "bodyText": "this is fine I guess, but the only thing that actually changes between iterations is encapsulationType", "author": "rtretyak", "createdAt": "2020-11-27T09:25:58Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ConnectedDevicesSpec.groovy", "diffHunk": "@@ -1264,6 +1304,85 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n         100    | 200         | FlowEncapsulationType.VXLAN\n     }\n \n+    @Unroll\n+    @Tags([SMOKE_SWITCHES])\n+    def \"Able to detect devices when two qinq single-switch different-port flows exist with the same outerVlanId\"() {\n+        given: \"Two flows between different ports on the same switch with the same outerVlanId\"\n+        assumeTrue(\"Require at least 1 switch with connected traffgen\", topology.activeTraffGens.size() > 0)\n+        def sw = topology.activeTraffGens*.switchConnected.first()\n+        def initialProps = enableMultiTableIfNeeded(true, sw.dpId)\n+\n+        def flow1 = flowHelperV2.singleSwitchFlow(sw, true)\n+        flow1.source.detectConnectedDevices.lldp = true\n+        flow1.source.detectConnectedDevices.arp = true\n+        flow1.source.vlanId = commonOuterVlanId\n+        flow1.source.innerVlanId = innerVlanIdFlow1\n+        flow1.encapsulationType = encapsulationType\n+        flowHelperV2.addFlow(flow1)\n+\n+        def flow2 = flowHelperV2.singleSwitchFlow(sw, true, [flow1])\n+        flow2.source.detectConnectedDevices.lldp = true\n+        flow2.source.detectConnectedDevices.arp = true\n+        flow2.source.vlanId = commonOuterVlanId\n+        flow2.source.innerVlanId = innerVlanIdFlow2\n+        flow2.encapsulationType = encapsulationType\n+        flowHelperV2.addFlow(flow2)\n+\n+        when: \"Device connects to src endpoint and send lldp and arp packets for flow1 only\"\n+        def lldpData = LldpData.buildRandom()\n+        def arpData = ArpData.buildRandom()\n+        new ConnectedDevice(traffExamProvider.get(), topology.getTraffGen(sw.dpId),\n+                [flow1.source.vlanId, flow1.source.innerVlanId]).withCloseable {\n+            it.sendLldp(lldpData)\n+            it.sendArp(arpData)\n+        }\n+\n+        then: \"LLDP and ARP connected devices are recognized for flow1\"\n+        Wrappers.wait(WAIT_OFFSET) { //need some time for devices to appear\n+            verifyAll(northbound.getFlowConnectedDevices(flow1.flowId)) {\n+                it.source.lldp.size() == 1\n+                it.source.arp.size() == 1\n+                it.destination.lldp.empty\n+                it.destination.arp.empty\n+                verifyEquals(it.source.lldp[0], lldpData)\n+                verifyEquals(it.source.arp[0], arpData)\n+            }\n+        }\n+\n+        and: \"LLDP and ARP connected devices are not recognized for flow2\"\n+        verifyAll(northbound.getFlowConnectedDevices(flow2.flowId)) {\n+            it.source.lldp.empty\n+            it.source.arp.empty\n+            it.destination.lldp.empty\n+            it.destination.arp.empty\n+        }\n+\n+        and: \"Devices are registered on the switch\"\n+        verifyAll(northboundV2.getConnectedDevices(flow1.source.switchId).ports) {\n+            it.size() == 1\n+            it[0].portNumber == flow1.source.portNumber\n+            it[0].lldp.size() == 1\n+            it[0].lldp.first().flowId == flow1.flowId\n+            it[0].lldp.first().vlan == commonOuterVlanId //due to issue 3475\n+            verifyEquals(it[0].lldp.first(), lldpData)\n+            it[0].arp.size() == 1\n+            it[0].arp.first().flowId == flow1.flowId\n+            it[0].arp.first().vlan == commonOuterVlanId //due to issue 3475\n+            verifyEquals(it[0].arp.first(), arpData)\n+        }\n+\n+        cleanup: \"Restore initial switch properties\"\n+        flow1 && flowHelperV2.deleteFlow(flow1.flowId)\n+        flow2 && flowHelperV2.deleteFlow(flow2.flowId)\n+        initialProps && restoreSwitchProperties(sw.dpId, initialProps)\n+        sw && database.removeConnectedDevices(sw.dpId)\n+\n+        where:\n+        commonOuterVlanId | innerVlanIdFlow1 | innerVlanIdFlow2 | encapsulationType", "originalCommit": "31e535a1a3e97131d6ad52f7020976e706ae348f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ1NTA5Mw==", "url": "https://github.com/telstra/open-kilda/pull/3874#discussion_r532455093", "bodyText": "you are right,\nI just didn't want to extract them into separate variables or use magic numbers.", "author": "andriidovhan", "createdAt": "2020-11-30T09:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3ODU3MA=="}], "type": "inlineReview"}]}